diff --git a/Documentation/devicetree/bindings/hwlock/ingenic,vpu-hwspinlock.yaml b/Documentation/devicetree/bindings/hwlock/ingenic,vpu-hwspinlock.yaml
new file mode 100644
index 00000000000..b08dfd3feea
--- /dev/null
+++ b/Documentation/devicetree/bindings/hwlock/ingenic,vpu-hwspinlock.yaml
@@ -0,0 +1,47 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/hwlock/ingenic,vpu-hwspinlock.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Ingenic VPU Hardware Spinlock
+
+maintainers:
+  - Paul Cercueil <paul@crapouillou.net>
+
+description:
+  The Hardware Spinlock of the VPU provides a mutex mechanism between the main
+  processor and the co-processor present in the VPU IP.
+
+properties:
+  compatible:
+    oneOf:
+      - enum:
+          - ingenic,jz4755-vpu-hwspinlock
+      - items:
+          - enum:
+              - ingenic,jz4760-vpu-hwspinlock
+              - ingenic,jz4770-vpu-hwspinlock
+              - ingenic,jz4780-vpu-hwspinlock
+          - const: ingenic,jz4755-vpu-hwspinlock
+
+  reg:
+    maxItems: 1
+
+  '#hwlock-cells':
+    const: 0
+
+required:
+  - compatible
+  - reg
+  - '#hwlock-cells'
+
+additionalProperties: false
+
+examples:
+  - |
+    hwspinlock: hwlock@4 {
+      compatible = "ingenic,jz4755-vpu-hwspinlock";
+      reg = <0x4 0xc>;
+      #hwlock-cells = <0>;
+    };
diff --git a/Documentation/devicetree/bindings/i2c/ingenic,i2c.yaml b/Documentation/devicetree/bindings/i2c/ingenic,i2c.yaml
index b61fdc9548d..b12f2c510fe 100644
--- a/Documentation/devicetree/bindings/i2c/ingenic,i2c.yaml
+++ b/Documentation/devicetree/bindings/i2c/ingenic,i2c.yaml
@@ -38,14 +38,15 @@ properties:
     enum: [ 100000, 400000 ]
 
   dmas:
-    items:
-      - description: DMA controller phandle and request line for RX
-      - description: DMA controller phandle and request line for TX
+    minItems: 1
+    maxItems: 2
 
   dma-names:
-    items:
-      - const: rx
-      - const: tx
+    oneOf:
+      - items:
+          - const: rx
+          - const: tx
+      - const: tx-rx
 
 required:
   - compatible
diff --git a/Documentation/devicetree/bindings/mips/ingenic/devices.yaml b/Documentation/devicetree/bindings/mips/ingenic/devices.yaml
index f2e822afe7f..f57f31f0c41 100644
--- a/Documentation/devicetree/bindings/mips/ingenic/devices.yaml
+++ b/Documentation/devicetree/bindings/mips/ingenic/devices.yaml
@@ -23,16 +23,68 @@ properties:
           - const: qi,lb60
           - const: ingenic,jz4740
 
+      - description: Wolsen LDK (horizontal)
+        items:
+          - const: wolsen,ldkh
+          - const: ingenic,jz4760
+
+      - description: Wolsen LDK (vertical)
+        items:
+          - const: wolsen,ldkv
+          - const: ingenic,jz4760b
+
+      - description: Wolsen PlayGo
+        items:
+          - const: wolsen,playgo
+          - const: ingenic,jz4770
+
       - description: YLM RetroMini RS-90
         items:
           - const: ylm,rs90
           - const: ingenic,jz4725b
 
+      - description: YLM RS-97
+        items:
+          - const: ylm,rs97
+          - const: ingenic,jz4760
+
+      - description: YLM RG-300
+        items:
+          - const: ylm,rg300
+          - const: ingenic,jz4760b
+
+      - description: YLM RG-99
+        items:
+          - const: ylm,rg99
+          - const: ingenic,jz4725b
+
       - description: Game Consoles Worldwide GCW Zero
         items:
           - const: gcw,zero
           - const: ingenic,jz4770
 
+      - description: YLM RG-350
+        items:
+          - const: ylm,rg350
+          - const: ingenic,jz4770
+
+      - description: YLM RG-350M
+        items:
+          - const: ylm,rg350m
+          - const: ingenic,jz4770
+
+      - description: YLM RG-280M
+        items:
+          - enum:
+              - ylm,rg280m-v1.0
+              - ylm,rg280m-v1.1
+          - const: ingenic,jz4770
+
+      - description: YLM RG-280V
+        items:
+          - const: ylm,rg280v
+          - const: ingenic,jz4770
+
       - description: MIPS Creator CI20
         items:
           - const: img,ci20
diff --git a/Documentation/devicetree/bindings/phy/ingenic,phy-usb.yaml b/Documentation/devicetree/bindings/phy/ingenic,phy-usb.yaml
index 30b42008db0..087634cbd84 100644
--- a/Documentation/devicetree/bindings/phy/ingenic,phy-usb.yaml
+++ b/Documentation/devicetree/bindings/phy/ingenic,phy-usb.yaml
@@ -15,13 +15,19 @@ properties:
     pattern: '^usb-phy@.*'
 
   compatible:
-    enum:
-      - ingenic,jz4770-phy
-      - ingenic,jz4775-phy
-      - ingenic,jz4780-phy
-      - ingenic,x1000-phy
-      - ingenic,x1830-phy
-      - ingenic,x2000-phy
+    oneOf:
+      - enum:
+          - ingenic,jz4760-phy
+          - ingenic,jz4775-phy
+          - ingenic,jz4780-phy
+          - ingenic,x1000-phy
+          - ingenic,x1830-phy
+          - ingenic,x2000-phy
+      - items:
+          - enum:
+              - ingenic,jz4760b-phy
+              - ingenic,jz4770-phy
+          - const: ingenic,jz4760-phy
 
   reg:
     maxItems: 1
@@ -48,7 +54,7 @@ examples:
   - |
     #include <dt-bindings/clock/ingenic,jz4770-cgu.h>
     otg_phy: usb-phy@3c {
-      compatible = "ingenic,jz4770-phy";
+      compatible = "ingenic,jz4770-phy", "ingenic,jz4760-phy";
       reg = <0x3c 0x10>;
 
       vcc-supply = <&vcc>;
diff --git a/Documentation/devicetree/bindings/pinctrl/ingenic,pinctrl.yaml b/Documentation/devicetree/bindings/pinctrl/ingenic,pinctrl.yaml
index 890961826c6..df63e2c480d 100644
--- a/Documentation/devicetree/bindings/pinctrl/ingenic,pinctrl.yaml
+++ b/Documentation/devicetree/bindings/pinctrl/ingenic,pinctrl.yaml
@@ -37,6 +37,7 @@ properties:
           - ingenic,jz4750-pinctrl
           - ingenic,jz4755-pinctrl
           - ingenic,jz4760-pinctrl
+          - ingenic,jz4760b-pinctrl
           - ingenic,jz4770-pinctrl
           - ingenic,jz4775-pinctrl
           - ingenic,jz4780-pinctrl
diff --git a/Documentation/devicetree/bindings/power/supply/ingenic,battery.yaml b/Documentation/devicetree/bindings/power/supply/ingenic,battery.yaml
index 741022b4449..953cbafa0f5 100644
--- a/Documentation/devicetree/bindings/power/supply/ingenic,battery.yaml
+++ b/Documentation/devicetree/bindings/power/supply/ingenic,battery.yaml
@@ -19,6 +19,8 @@ properties:
       - items:
           - enum:
               - ingenic,jz4725b-battery
+              - ingenic,jz4760-battery
+              - ingenic,jz4760b-battery
               - ingenic,jz4770-battery
           - const: ingenic,jz4740-battery
 
diff --git a/Documentation/devicetree/bindings/remoteproc/ingenic,vpu.yaml b/Documentation/devicetree/bindings/remoteproc/ingenic,vpu.yaml
index 8b55dbd909b..4853a8d870a 100644
--- a/Documentation/devicetree/bindings/remoteproc/ingenic,vpu.yaml
+++ b/Documentation/devicetree/bindings/remoteproc/ingenic,vpu.yaml
@@ -17,7 +17,10 @@ maintainers:
 
 properties:
   compatible:
-    const: ingenic,jz4770-vpu-rproc
+    items:
+      - enum:
+          - ingenic,jz4770-vpu-rproc
+      - const: simple-mfd
 
   reg:
     items:
@@ -54,6 +57,10 @@ required:
   - clock-names
   - interrupts
 
+patternProperties:
+  "^hwlock@[a-f0-9]+$":
+    allOf: [ $ref: "../hwlock/ingenic,vpu-hwspinlock.yaml" ]
+
 additionalProperties: false
 
 examples:
@@ -61,7 +68,10 @@ examples:
     #include <dt-bindings/clock/ingenic,jz4770-cgu.h>
 
     vpu: video-decoder@132a0000 {
-      compatible = "ingenic,jz4770-vpu-rproc";
+      compatible = "ingenic,jz4770-vpu-rproc", "simple-mfd";
+      #address-cells = <1>;
+      #size-cells = <1>;
+      ranges = <0x0 0x132a0000 0x20>;
 
       reg = <0x132a0000 0x20>, /* AUX */
             <0x132b0000 0x4000>, /* TCSM0 */
@@ -74,4 +84,12 @@ examples:
 
       interrupt-parent = <&cpuintc>;
       interrupts = <3>;
+
+      hwlock: hwlock@4 {
+        compatible = "ingenic,jz4770-vpu-hwspinlock",
+                     "ingenic,jz4755-vpu-hwspinlock";
+        reg = <0x4 0xc>;
+
+        #hwlock-cells = <1>;
+      };
     };
diff --git a/Documentation/devicetree/bindings/vendor-prefixes.yaml b/Documentation/devicetree/bindings/vendor-prefixes.yaml
index 573578db950..ed710ab1451 100644
--- a/Documentation/devicetree/bindings/vendor-prefixes.yaml
+++ b/Documentation/devicetree/bindings/vendor-prefixes.yaml
@@ -1532,6 +1532,10 @@ patternProperties:
     description: Wondermedia Technologies, Inc.
   "^wobo,.*":
     description: Wobo
+  "^wanchanglong,.*":
+    description: Wanchanglong Electronics Technology（SHENZHEN）Co.，Ltd.
+  "^wolsen,.*":
+    description: Shenzhen Wolsen Technology Co., Ltd.
   "^x-powers,.*":
     description: X-Powers
   "^xen,.*":
diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index bc842185900..c3e5969f6c3 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -10,7 +10,6 @@ config MIPS
 	select ARCH_HAS_FORTIFY_SOURCE
 	select ARCH_HAS_KCOV
 	select ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE if !EVA
-	select ARCH_HAS_PTE_SPECIAL if !(32BIT && CPU_HAS_RIXI)
 	select ARCH_HAS_STRNCPY_FROM_USER
 	select ARCH_HAS_STRNLEN_USER
 	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
@@ -23,6 +22,7 @@ config MIPS
 	select ARCH_USE_QUEUED_RWLOCKS
 	select ARCH_USE_QUEUED_SPINLOCKS
 	select ARCH_SUPPORTS_HUGETLBFS if CPU_SUPPORTS_HUGEPAGES
+	select ARCH_SUPPORTS_LTO_CLANG if CPU_LITTLE_ENDIAN
 	select ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT if MMU
 	select ARCH_WANT_IPC_PARSE_VERSION
 	select ARCH_WANT_LD_ORPHAN_WARN
@@ -114,6 +114,7 @@ config MACH_INGENIC
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 	select SYS_SUPPORTS_ZBOOT
+	select CPU_SUPPORTS_HUGEPAGES
 	select DMA_NONCOHERENT
 	select IRQ_MIPS_CPU
 	select PINCTRL
@@ -1936,7 +1937,7 @@ config CPU_MIPSR1
 config CPU_MIPSR2
 	bool
 	default y if CPU_MIPS32_R2 || CPU_MIPS64_R2 || CPU_CAVIUM_OCTEON
-	select CPU_HAS_RIXI
+	#select CPU_HAS_RIXI
 	select CPU_HAS_DIEI if !CPU_DIEI_BROKEN
 	select MIPS_SPRAM
 
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index f49807e1f19..1d62aa3fefe 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -245,8 +245,10 @@ ifeq ($(CONFIG_CPU_HAS_MSA),y)
 toolchain-msa				:= $(call cc-option-yn,$(mips-cflags) -mhard-float -mfp64 -Wa$(comma)-mmsa)
 cflags-$(toolchain-msa)			+= -DTOOLCHAIN_SUPPORTS_MSA
 endif
+ifneq ($(CONFIG_CC_IS_CLANG),y)
 toolchain-virt				:= $(call cc-option-yn,$(mips-cflags) -mvirt)
 cflags-$(toolchain-virt)		+= -DTOOLCHAIN_SUPPORTS_VIRT
+endif
 # For -mmicromips, use -Wa,-fatal-warnings to catch unsupported -mxpa which
 # only warns
 xpa-cflags-y				:= $(mips-cflags)
diff --git a/arch/mips/boot/compressed/Makefile b/arch/mips/boot/compressed/Makefile
index 6cc28173bee..f6c45b2246f 100644
--- a/arch/mips/boot/compressed/Makefile
+++ b/arch/mips/boot/compressed/Makefile
@@ -27,10 +27,13 @@ ifdef CONFIG_CPU_LOONGSON64
 KBUILD_CFLAGS := $(filter-out -march=loongson3a, $(KBUILD_CFLAGS)) -march=mips64r2
 endif
 
-KBUILD_CFLAGS := $(KBUILD_CFLAGS) -D__KERNEL__ -D__DISABLE_EXPORTS \
+# Disable LTO
+KBUILD_CFLAGS := $(filter-out $(CC_FLAGS_LTO), $(KBUILD_CFLAGS))
+
+KBUILD_CFLAGS := $(KBUILD_CFLAGS) -mno-abicalls -D__KERNEL__ -D__DISABLE_EXPORTS \
 	-DBOOT_HEAP_SIZE=$(BOOT_HEAP_SIZE) -D"VMLINUX_LOAD_ADDRESS_ULL=$(VMLINUX_LOAD_ADDRESS)ull"
 
-KBUILD_AFLAGS := $(KBUILD_AFLAGS) -D__ASSEMBLY__ \
+KBUILD_AFLAGS := $(KBUILD_AFLAGS) -mno-abicalls -D__ASSEMBLY__ \
 	-DBOOT_HEAP_SIZE=$(BOOT_HEAP_SIZE) \
 	-DKERNEL_ENTRY=$(VMLINUX_ENTRY_ADDRESS)
 
diff --git a/arch/mips/boot/dts/ingenic/Makefile b/arch/mips/boot/dts/ingenic/Makefile
index 54aa0c4e609..e2aa2f25783 100644
--- a/arch/mips/boot/dts/ingenic/Makefile
+++ b/arch/mips/boot/dts/ingenic/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 dtb-$(CONFIG_JZ4740_QI_LB60)	+= qi_lb60.dtb
 dtb-$(CONFIG_JZ4740_RS90)	+= rs90.dtb
+dtb-$(CONFIG_JZ4760_RS97)	+= rs97.dtb
 dtb-$(CONFIG_JZ4770_GCW0)	+= gcw0.dtb
 dtb-$(CONFIG_JZ4780_CI20)	+= ci20.dtb
 dtb-$(CONFIG_X1000_CU1000_NEO)	+= cu1000-neo.dtb
diff --git a/arch/mips/boot/dts/ingenic/bits/gcw0-base.dtsi b/arch/mips/boot/dts/ingenic/bits/gcw0-base.dtsi
new file mode 100644
index 00000000000..7914276a612
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/bits/gcw0-base.dtsi
@@ -0,0 +1,474 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include "../jz4770.dtsi"
+
+#include <dt-bindings/clock/ingenic,tcu.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/iio/adc/ingenic,adc.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	aliases {
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+	};
+
+	memory: memory {
+		device_type = "memory";
+		reg = <0x0 0x10000000>,
+		      <0x30000000 0x10000000>;
+	};
+
+	chosen {
+		stdout-path = "serial2:57600n8";
+	};
+
+	vcc: regulator-0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc";
+
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+
+	mmc1_power: regulator-1 {
+		compatible = "regulator-fixed";
+		regulator-name = "mmc1_vcc";
+		gpio = <&gpe 9 0>;
+
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc>;
+	};
+
+	headphones_amp: analog-amplifier-0 {
+		compatible = "simple-audio-amplifier";
+		enable-gpios = <&gpf 3 GPIO_ACTIVE_LOW>;
+		enable-delay-ms = <50>;
+
+		VCC-supply = <&vcc>;
+		sound-name-prefix = "Headphones Amp";
+	};
+
+	speaker_amp: analog-amplifier-1 {
+		compatible = "simple-audio-amplifier";
+		enable-gpios = <&gpf 20 GPIO_ACTIVE_HIGH>;
+
+		VCC-supply = <&vcc>;
+		sound-name-prefix = "Speaker Amp";
+	};
+
+	sound_card: sound {
+		compatible = "simple-audio-card";
+
+		simple-audio-card,name = "gcw0-audio";
+		simple-audio-card,format = "i2s";
+
+		simple-audio-card,hp-det-gpio = <&gpf 21 GPIO_ACTIVE_LOW>;
+		simple-audio-card,aux-devs = <&speaker_amp>, <&headphones_amp>;
+
+		simple-audio-card,bitclock-master = <&dai_codec>;
+		simple-audio-card,frame-master = <&dai_codec>;
+
+		dai_cpu: simple-audio-card,cpu {
+			sound-dai = <&aic>;
+		};
+
+		dai_codec: simple-audio-card,codec {
+			sound-dai = <&codec>;
+		};
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm 1 40000 0>;
+		power-supply = <&vcc>;
+
+		brightness-levels = <0 4 8 9 10 12 16 32 64 96 128 192 255>;
+		default-brightness-level = <8>;
+
+		pinctrl-names = "init", "default";
+		pinctrl-0 = <&pins_pwm1_sleep>;
+		pinctrl-1 = <&pins_pwm1>;
+	};
+
+	gpio_keys: gpio-keys {
+		compatible = "gpio-keys";
+		autorepeat;
+
+		button-0 {
+			label = "D-pad up";
+			linux,code = <KEY_UP>;
+			linux,can-disable;
+			gpios = <&gpe 21 GPIO_ACTIVE_LOW>;
+		};
+
+		button-1 {
+			label = "D-pad down";
+			linux,code = <KEY_DOWN>;
+			linux,can-disable;
+			gpios = <&gpe 25 GPIO_ACTIVE_LOW>;
+		};
+
+		button-2 {
+			label = "D-pad left";
+			linux,code = <KEY_LEFT>;
+			linux,can-disable;
+			gpios = <&gpe 23 GPIO_ACTIVE_LOW>;
+		};
+
+		button-3 {
+			label = "D-pad right";
+			linux,code = <KEY_RIGHT>;
+			linux,can-disable;
+			gpios = <&gpe 24 GPIO_ACTIVE_LOW>;
+		};
+
+		button-4 {
+			label = "Button A";
+			linux,code = <KEY_LEFTCTRL>;
+			linux,can-disable;
+			gpios = <&gpe 29 GPIO_ACTIVE_LOW>;
+		};
+
+		button-5 {
+			label = "Button B";
+			linux,code = <KEY_LEFTALT>;
+			linux,can-disable;
+			gpios = <&gpe 20 GPIO_ACTIVE_LOW>;
+		};
+
+		btn6: button-6 {
+			label = "Button X";
+			linux,code = <KEY_SPACE>;
+			linux,can-disable;
+			gpios = <&gpe 27 GPIO_ACTIVE_LOW>;
+		};
+
+		btn7: button-7 {
+			label = "Button Y";
+			linux,code = <KEY_LEFTSHIFT>;
+			linux,can-disable;
+			gpios = <&gpe 28 GPIO_ACTIVE_LOW>;
+		};
+
+		btn8: button-8 {
+			label = "Left shoulder button";
+			linux,code = <KEY_TAB>;
+			linux,can-disable;
+			gpios = <&gpb 20 GPIO_ACTIVE_LOW>;
+		};
+
+		btn9: button-9 {
+			label = "Right shoulder button";
+			linux,code = <KEY_BACKSPACE>;
+			linux,can-disable;
+			gpios = <&gpe 26 GPIO_ACTIVE_LOW>;
+		};
+
+		button-10 {
+			label = "Start button";
+			linux,code = <KEY_ENTER>;
+			linux,can-disable;
+			gpios = <&gpb 21 GPIO_ACTIVE_LOW>;
+		};
+
+		button-11 {
+			label = "Select button";
+			linux,code = <KEY_ESC>;
+			linux,can-disable;
+			/*
+			 * This is the only button that is active high,
+			 * since it doubles as BOOT_SEL1.
+			 */
+			gpios = <&gpd 18 GPIO_ACTIVE_HIGH>;
+		};
+
+		btn12: button-12 {
+			label = "Power button";
+			linux,code = <KEY_POWER>;
+			linux,can-disable;
+			gpios = <&gpa 30 GPIO_ACTIVE_LOW>;
+			wakeup-source;
+		};
+	};
+
+	/*
+	 * SPI-over-GPIO, using the pins of the SSI0 controller.
+	 * This is useful for the devices that require 3-wire communication,
+	 * as the SSI controller in Ingenic SoCs does not support it.
+	 */
+	spi0_gpio: spi {
+		compatible = "spi-gpio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+
+		sck-gpios = <&gpe 15 GPIO_ACTIVE_HIGH>;
+		mosi-gpios = <&gpe 17 GPIO_ACTIVE_HIGH>;
+		cs-gpios = <&gpe 16 GPIO_ACTIVE_HIGH>;
+		num-chipselects = <1>;
+	};
+
+	usb_conn: connector {
+		compatible = "gpio-usb-b-connector", "usb-b-connector";
+		label = "mini-USB";
+		type = "mini";
+
+		/*
+		 * USB OTG is not yet working reliably, the ID detection
+		 * mechanism tends to fry easily for unknown reasons.
+		 * Until this is fixed, disable OTG by not providing the
+		 * ID GPIO to the driver.
+		 */
+		//id-gpios = <&gpf 18 GPIO_ACTIVE_LOW>;
+
+		vbus-gpios = <&gpb 5 GPIO_ACTIVE_HIGH>;
+		vbus-supply = <&vcc>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pins_otg>;
+
+		port {
+			usb_ep: endpoint {
+				remote-endpoint = <&usb_otg_ep>;
+			};
+		};
+	};
+
+	battery: battery {
+		compatible = "simple-battery";
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4200000>;
+	};
+
+	vdiv: voltage-divider {
+		compatible = "voltage-divider";
+		#io-channel-cells = <0>;
+
+		output-ohms = <332000>;
+		full-ohms = <1332000>;
+
+		io-channels = <&adc INGENIC_ADC_BATTERY>;
+	};
+
+	pmu: pmu {
+		compatible = "ingenic,jz4770-battery", "ingenic,jz4740-battery";
+		io-channels = <&vdiv>;
+		io-channel-names = "battery";
+		monitored-battery = <&battery>;
+
+		power-supplies = <&usb_conn>;
+	};
+
+	joystick: joystick {
+		compatible = "adc-joystick";
+		io-channels = <&adc INGENIC_ADC_TOUCH_XP>,
+			      <&adc INGENIC_ADC_TOUCH_YP>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		js_axis0: axis@0 {
+			reg = <0>;
+			linux,code = <ABS_X>;
+			abs-fuzz = <4>;
+			abs-flat = <200>;
+		};
+
+		js_axis1: axis@1 {
+			reg = <1>;
+			linux,code = <ABS_Y>;
+			abs-fuzz = <4>;
+			abs-flat = <200>;
+		};
+	};
+
+	leds: leds {
+		compatible = "gpio-leds";
+
+		power_led: led {
+			label = "power";
+			gpios = <&gpb 30 GPIO_ACTIVE_LOW>;
+			default-state = "on";
+			panic-indicator;
+			retain-state-suspended;
+		};
+	};
+
+	cpu_opp_table: opp-table {
+		compatible = "operating-points-v2";
+
+		opp-444000000 { opp-hz = /bits/ 64 <444000000>; };
+		opp-492000000 { opp-hz = /bits/ 64 <492000000>; };
+		opp-600000000 { opp-hz = /bits/ 64 <600000000>; };
+		opp-696000000 { opp-hz = /bits/ 64 <696000000>; };
+		opp-792000000 { opp-hz = /bits/ 64 <792000000>; };
+		opp-900000000 { opp-hz = /bits/ 64 <900000000>; };
+		opp-996000000 { opp-hz = /bits/ 64 <996000000>; };
+		opp-1092000000 { opp-hz = /bits/ 64 <1092000000>; };
+		opp-1200000000 { opp-hz = /bits/ 64 <1200000000>; };
+	};
+};
+
+&ext {
+	clock-frequency = <12000000>;
+};
+
+&cpu0 {
+	operating-points-v2 = <&cpu_opp_table>;
+
+	/* We use the main PLL as the CPU clock for the cpufreq driver. */
+	clocks = <&cgu JZ4770_CLK_PLL0>;
+};
+
+&pinctrl {
+	pins_lcd: lcd {
+		function = "lcd";
+		groups = "lcd-24bit";
+	};
+
+	pins_uart2: uart2 {
+		function = "uart2";
+		groups = "uart2-data";
+	};
+
+	pins_mmc0: mmc0 {
+		function = "mmc0";
+		groups = "mmc0-1bit-a", "mmc0-4bit-a";
+	};
+
+	pins_mmc1: mmc1 {
+		function = "mmc1";
+		groups = "mmc1-1bit-d", "mmc1-4bit-d";
+	};
+
+	pins_otg: otg {
+		otg-vbus-pin {
+			function = "otg";
+			groups = "otg-vbus";
+		};
+
+		vbus-pin {
+			pins = "PB5";
+			bias-disable;
+		};
+	};
+
+	pwm1 {
+		pins_pwm1_sleep: pwm1-sleep {
+			pins = "PE1";
+			output-low;
+		};
+
+		pins_pwm1: pwm1-default {
+			function = "pwm1";
+			groups = "pwm1";
+		};
+	};
+};
+
+&lcd {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_lcd>;
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_uart2>;
+
+	status = "okay";
+};
+
+&cgu {
+	/*
+	 * Put high-speed peripherals under PLL1, such that we can change the
+	 * PLL0 frequency on demand without having to suspend peripherals.
+	 * We use a rate of 432 MHz, which is the least common multiple of
+	 * 27 MHz (required by TV encoder) and 48 MHz (required by USB host).
+	 * Put the GPU under PLL0 since we want a higher frequency.
+	 * Use the 32 kHz oscillator as the parent of the RTC for a higher
+	 * precision.
+	 */
+	assigned-clocks =
+		<&cgu JZ4770_CLK_PLL1>,
+		<&cgu JZ4770_CLK_GPU>,
+		<&cgu JZ4770_CLK_RTC>,
+		<&cgu JZ4770_CLK_UHC>,
+		<&cgu JZ4770_CLK_LPCLK_MUX>,
+		<&cgu JZ4770_CLK_MMC0_MUX>,
+		<&cgu JZ4770_CLK_MMC1_MUX>;
+	assigned-clock-parents =
+		<0>,
+		<&cgu JZ4770_CLK_PLL0>,
+		<&cgu JZ4770_CLK_OSC32K>,
+		<&cgu JZ4770_CLK_PLL1>,
+		<&cgu JZ4770_CLK_PLL1>,
+		<&cgu JZ4770_CLK_PLL1>,
+		<&cgu JZ4770_CLK_PLL1>;
+	assigned-clock-rates =
+		<432000000>,
+		<600000000>;
+};
+
+&tcu {
+	/*
+	 * 750 kHz for the system timer and clocksource, 12 MHz for the OST,
+	 * and use RTC as the parent for the watchdog clock
+	 */
+	assigned-clocks = <&tcu TCU_CLK_TIMER0>, <&tcu TCU_CLK_TIMER2>,
+			  <&tcu TCU_CLK_OST>, <&tcu TCU_CLK_WDT>;
+	assigned-clock-parents = <0>, <0>, <0>, <&cgu JZ4770_CLK_RTC>;
+	assigned-clock-rates = <750000>, <750000>, <12000000>;
+
+	/* PWM1 is in use, so use channel #2 for the clocksource */
+	ingenic,pwm-channels-mask = <0xfa>;
+};
+
+&usb_otg {
+	port {
+		usb_otg_ep: endpoint {
+			remote-endpoint = <&usb_ep>;
+		};
+	};
+};
+
+&otg_phy {
+	vcc-supply = <&vcc>;
+};
+
+&rtc {
+	clocks = <&cgu JZ4770_CLK_RTC>;
+	clock-names = "rtc";
+
+	system-power-controller;
+
+	ingenic,reset-pin-assert-time-ms = <125>;
+	ingenic,min-wakeup-pin-assert-time-ms = <500>;
+};
+
+&mmc0 {
+	status = "okay";
+
+	bus-width = <4>;
+	max-frequency = <50000000>;
+	vmmc-supply = <&vcc>;
+	non-removable;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mmc0>;
+};
+
+&mmc1 {
+	status = "okay";
+
+	bus-width = <4>;
+	max-frequency = <50000000>;
+	cd-gpios = <&gpb 2 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&mmc1_power>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mmc1>;
+};
diff --git a/arch/mips/boot/dts/ingenic/bits/rs90-base.dtsi b/arch/mips/boot/dts/ingenic/bits/rs90-base.dtsi
new file mode 100644
index 00000000000..68894fb0096
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/bits/rs90-base.dtsi
@@ -0,0 +1,285 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include "../jz4725b.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/iio/adc/ingenic,adc.h>
+#include <dt-bindings/input/linux-event-codes.h>
+
+/ {
+
+	memory {
+		device_type = "memory";
+		reg = <0x0 0x2000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		vmem: video-memory@1f00000 {
+			compatible = "shared-dma-pool";
+			reg = <0x1f00000 0x100000>;
+			reusable;
+		};
+	};
+
+	vcc: regulator {
+		compatible = "regulator-fixed";
+
+		regulator-name = "vcc";
+		regulaor-min-microvolt = <3300000>;
+		regulaor-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm 3 40000 0>;
+
+		brightness-levels = <0 16 32 48 64 80 112 144 192 255>;
+		default-brightness-level = <8>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pins_pwm3>;
+
+		power-supply = <&vcc>;
+	};
+
+	amp: analog-amplifier {
+		compatible = "simple-audio-amplifier";
+		enable-gpios = <&gpc 15 GPIO_ACTIVE_HIGH>;
+
+		VCC-supply = <&vcc>;
+	};
+
+	sound_card: sound {
+		compatible = "simple-audio-card";
+
+		simple-audio-card,name = "rs90-audio";
+		simple-audio-card,format = "i2s";
+
+		simple-audio-card,widgets =
+			"Speaker", "Speaker",
+			"Headphone", "Headphones";
+		simple-audio-card,routing =
+			"INL", "LHPOUT",
+			"INR", "RHPOUT",
+			"Headphones", "LHPOUT",
+			"Headphones", "RHPOUT",
+			"Speaker", "OUTL",
+			"Speaker", "OUTR";
+		simple-audio-card,pin-switches = "Speaker";
+
+		simple-audio-card,hp-det-gpio = <&gpd 16 GPIO_ACTIVE_LOW>;
+		simple-audio-card,aux-devs = <&amp>;
+
+		simple-audio-card,bitclock-master = <&dai_codec>;
+		simple-audio-card,frame-master = <&dai_codec>;
+
+		dai_cpu: simple-audio-card,cpu {
+			sound-dai = <&aic>;
+		};
+
+		dai_codec: simple-audio-card,codec {
+			sound-dai = <&codec>;
+		};
+	};
+
+	usb_phy: usb-phy {
+		compatible = "usb-nop-xceiv";
+		#phy-cells = <0>;
+
+		clocks = <&cgu JZ4725B_CLK_UDC_PHY>;
+		clock-names = "main_clk";
+		vcc-supply = <&vcc>;
+	};
+
+	battery: battery {
+		compatible = "simple-battery";
+		voltage-min-design-microvolt = <3692000>;
+		voltage-max-design-microvolt = <3900000>;
+		charge-full-design-microamp-hours = <1020000>;
+	};
+
+	resistor: resistor {
+		compatible = "voltage-divider";
+		#io-channel-cells = <0>;
+
+		output-ohms = <1125>;
+		full-ohms = <3900>;
+
+		io-channels = <&adc INGENIC_ADC_BATTERY>;
+	};
+
+	pmu: pmu {
+		compatible = "ingenic,jz4725b-battery", "ingenic,jz4740-battery";
+		io-channels = <&resistor>;
+		io-channel-names = "battery";
+		monitored-battery = <&battery>;
+	};
+
+	cpu_opp_table: opp-table {
+		compatible = "operating-points-v2";
+
+		opp-216000000 { opp-hz = /bits/ 64 <216000000>; };
+		opp-300000000 { opp-hz = /bits/ 64 <300000000>; };
+		opp-336000000 { opp-hz = /bits/ 64 <336000000>; };
+		opp-360000000 { opp-hz = /bits/ 64 <360000000>; };
+		opp-378000000 { opp-hz = /bits/ 64 <378000000>; };
+		opp-396000000 { opp-hz = /bits/ 64 <396000000>; };
+		opp-420000000 { opp-hz = /bits/ 64 <420000000>; };
+		opp-438000000 { opp-hz = /bits/ 64 <438000000>; };
+		opp-456000000 { opp-hz = /bits/ 64 <456000000>; };
+	};
+};
+
+&ext {
+	clock-frequency = <12000000>;
+};
+
+&rtc_dev {
+	system-power-controller;
+};
+
+&udc {
+	phys = <&usb_phy>;
+};
+
+&pinctrl {
+	pins_nemc: nemc {
+		function = "nand";
+		groups = "nand-cs1", "nand-cle-ale", "nand-fre-fwe";
+	};
+
+	pins_pwm3: pwm3 {
+		function = "pwm3";
+		groups = "pwm3";
+		bias-disable;
+	};
+
+	pins_lcd: lcd {
+		function = "lcd";
+	};
+
+	pins_mmc1: mmc1 {
+		mmc1-func {
+			function = "mmc1";
+			groups = "mmc1-1bit";
+		};
+
+		pins_mmc1_cd: mmc1-cd {
+			bias-pull-up;
+		};
+	};
+};
+
+&mmc0 {
+	status = "disabled";
+};
+
+&mmc1 {
+	bus-width = <1>;
+	max-frequency = <50000000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mmc1>;
+};
+
+&uart {
+	/*
+	 * The pins for RX/TX are used for the right shoulder button and
+	 * backlight PWM.
+	 */
+	status = "disabled";
+};
+
+&nemc {
+	nandc: nand-controller@1 {
+		compatible = "ingenic,jz4725b-nand";
+		reg = <1 0 0x4000000>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ecc-engine = <&bch>;
+
+		ingenic,nemc-tAS = <10>;
+		ingenic,nemc-tAH = <5>;
+		ingenic,nemc-tBP = <10>;
+		ingenic,nemc-tAW = <15>;
+		ingenic,nemc-tSTRV = <100>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pins_nemc>;
+
+		rb-gpios = <&gpc 27 GPIO_ACTIVE_HIGH>;
+
+		nand@1 {
+			reg = <1>;
+
+			nand-ecc-step-size = <512>;
+			nand-ecc-strength = <8>;
+			nand-ecc-mode = "hw";
+			nand-is-boot-medium;
+			nand-on-flash-bbt;
+
+			partitions {
+				compatible = "fixed-partitions";
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				partition@0 {
+					label = "bootloader";
+					reg = <0x0 0x20000>;
+				};
+
+				partition@20000 {
+					label = "system";
+					reg = <0x20000 0x0>;
+				};
+			};
+		};
+	};
+};
+
+&cgu {
+	/* Use 32kHz oscillator as the parent of the RTC clock */
+	assigned-clocks = <&cgu JZ4725B_CLK_RTC>;
+	assigned-clock-parents = <&cgu JZ4725B_CLK_OSC32K>;
+};
+
+&tcu {
+	/*
+	 * 750 kHz for the system timer and clocksource, and use RTC as the
+	 * parent for the watchdog clock.
+	 */
+	assigned-clocks = <&tcu TCU_CLK_TIMER0>, <&tcu TCU_CLK_TIMER1>, <&tcu TCU_CLK_WDT>;
+	assigned-clock-parents = <0>, <0>, <&cgu JZ4725B_CLK_RTC>;
+	assigned-clock-rates = <750000>, <750000>;
+};
+
+&lcd {
+	memory-region = <&vmem>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_lcd>;
+};
+
+&lcd_ports {
+	port@0 {
+		reg = <0>;
+
+		panel_output: endpoint {
+			remote-endpoint = <&panel_input>;
+		};
+	};
+};
+
+&cpu0 {
+	operating-points-v2 = <&cpu_opp_table>;
+
+	/* We use the main PLL as the CPU clock for the cpufreq driver. */
+	clocks = <&cgu JZ4725B_CLK_PLL>;
+};
diff --git a/arch/mips/boot/dts/ingenic/gcw0.dts b/arch/mips/boot/dts/ingenic/gcw0.dts
index 5d33f26fd28..240354cd8f4 100644
--- a/arch/mips/boot/dts/ingenic/gcw0.dts
+++ b/arch/mips/boot/dts/ingenic/gcw0.dts
@@ -2,110 +2,23 @@
 /dts-v1/;
 
 #include "jz4770.dtsi"
-#include <dt-bindings/clock/ingenic,tcu.h>
-
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/iio/adc/ingenic,adc.h>
-#include <dt-bindings/input/input.h>
+#include "bits/gcw0-base.dtsi"
 
 / {
 	compatible = "gcw,zero", "ingenic,jz4770";
 	model = "GCW Zero";
 
-	aliases {
-		serial0 = &uart0;
-		serial1 = &uart1;
-		serial2 = &uart2;
-		serial3 = &uart3;
-	};
-
-	memory: memory {
-		device_type = "memory";
-		reg = <0x0 0x10000000>,
-		      <0x30000000 0x10000000>;
-	};
-
-	chosen {
-		stdout-path = "serial2:57600n8";
-	};
-
-	vcc: regulator@0 {
-		compatible = "regulator-fixed";
-		regulator-name = "vcc";
-
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		regulator-always-on;
-	};
-
-	mmc1_power: regulator@1 {
+	usb_vbus: regulator-2 {
 		compatible = "regulator-fixed";
-		regulator-name = "mmc1_vcc";
-		gpio = <&gpe 9 0>;
+		regulator-name = "USB Power";
+		gpio = <&gpf 10 0>;
+		regulator-always-on; /* always ON for now */
 
 		regulator-min-microvolt = <3300000>;
 		regulator-max-microvolt = <3300000>;
 		vin-supply = <&vcc>;
 	};
 
-	headphones_amp: analog-amplifier@0 {
-		compatible = "simple-audio-amplifier";
-		enable-gpios = <&gpf 3 GPIO_ACTIVE_LOW>;
-		enable-delay-ms = <50>;
-
-		VCC-supply = <&ldo5>;
-		sound-name-prefix = "Headphones Amp";
-	};
-
-	speaker_amp: analog-amplifier@1 {
-		compatible = "simple-audio-amplifier";
-		enable-gpios = <&gpf 20 GPIO_ACTIVE_HIGH>;
-
-		VCC-supply = <&ldo5>;
-		sound-name-prefix = "Speaker Amp";
-	};
-
-	sound {
-		compatible = "simple-audio-card";
-
-		simple-audio-card,name = "gcw0-audio";
-		simple-audio-card,format = "i2s";
-
-		simple-audio-card,widgets =
-			"Speaker", "Speaker",
-			"Headphone", "Headphones",
-			"Microphone", "Built-in Mic";
-		simple-audio-card,routing =
-			"Headphones Amp INL", "LHPOUT",
-			"Headphones Amp INR", "RHPOUT",
-			"Headphones", "Headphones Amp OUTL",
-			"Headphones", "Headphones Amp OUTR",
-			"Speaker Amp INL", "LOUT",
-			"Speaker Amp INR", "ROUT",
-			"Speaker", "Speaker Amp OUTL",
-			"Speaker", "Speaker Amp OUTR",
-			"LLINEIN", "Cap-less",
-			"RLINEIN", "Cap-less",
-			"Built-in Mic", "MICBIAS",
-			"MIC1P", "Built-in Mic",
-			"MIC1N", "Built-in Mic";
-		simple-audio-card,pin-switches = "Speaker", "Headphones";
-
-		simple-audio-card,hp-det-gpio = <&gpf 21 GPIO_ACTIVE_LOW>;
-		simple-audio-card,aux-devs = <&speaker_amp>, <&headphones_amp>;
-
-		simple-audio-card,bitclock-master = <&dai_codec>;
-		simple-audio-card,frame-master = <&dai_codec>;
-
-		dai_cpu: simple-audio-card,cpu {
-			sound-dai = <&aic>;
-		};
-
-		dai_codec: simple-audio-card,codec {
-			sound-dai = <&codec>;
-		};
-	};
-
 	rumble {
 		compatible = "pwm-vibrator";
 		pwms = <&pwm 4 2000000 0>;
@@ -115,127 +28,6 @@ rumble {
 		pinctrl-0 = <&pins_pwm4>;
 	};
 
-	backlight: backlight {
-		compatible = "pwm-backlight";
-		pwms = <&pwm 1 40000 0>;
-		power-supply = <&vcc>;
-
-		brightness-levels = <0 16 32 48 64 80 96 112 128
-				     144 160 176 192 208 224 240 255>;
-		default-brightness-level = <12>;
-
-		pinctrl-names = "default";
-		pinctrl-0 = <&pins_pwm1>;
-	};
-
-	gpio-keys {
-		compatible = "gpio-keys";
-		autorepeat;
-
-		button-0 {
-			label = "D-pad up";
-			linux,code = <KEY_UP>;
-			linux,can-disable;
-			gpios = <&gpe 21 GPIO_ACTIVE_LOW>;
-		};
-
-		button-1 {
-			label = "D-pad down";
-			linux,code = <KEY_DOWN>;
-			linux,can-disable;
-			gpios = <&gpe 25 GPIO_ACTIVE_LOW>;
-		};
-
-		button-2 {
-			label = "D-pad left";
-			linux,code = <KEY_LEFT>;
-			linux,can-disable;
-			gpios = <&gpe 23 GPIO_ACTIVE_LOW>;
-		};
-
-		button-3 {
-			label = "D-pad right";
-			linux,code = <KEY_RIGHT>;
-			linux,can-disable;
-			gpios = <&gpe 24 GPIO_ACTIVE_LOW>;
-		};
-
-		button-4 {
-			label = "Button A";
-			linux,code = <KEY_LEFTCTRL>;
-			linux,can-disable;
-			gpios = <&gpe 29 GPIO_ACTIVE_LOW>;
-		};
-
-		button-5 {
-			label = "Button B";
-			linux,code = <KEY_LEFTALT>;
-			linux,can-disable;
-			gpios = <&gpe 20 GPIO_ACTIVE_LOW>;
-		};
-
-		button-6 {
-			label = "Button Y";
-			linux,code = <KEY_SPACE>;
-			linux,can-disable;
-			gpios = <&gpe 27 GPIO_ACTIVE_LOW>;
-		};
-
-		button-7 {
-			label = "Button X";
-			linux,code = <KEY_LEFTSHIFT>;
-			linux,can-disable;
-			gpios = <&gpe 28 GPIO_ACTIVE_LOW>;
-		};
-
-		button-8 {
-			label = "Left shoulder button";
-			linux,code = <KEY_TAB>;
-			linux,can-disable;
-			gpios = <&gpb 20 GPIO_ACTIVE_LOW>;
-		};
-
-		button-9 {
-			label = "Right shoulder button";
-			linux,code = <KEY_BACKSPACE>;
-			linux,can-disable;
-			gpios = <&gpe 26 GPIO_ACTIVE_LOW>;
-		};
-
-		button-10 {
-			label = "Start button";
-			linux,code = <KEY_ENTER>;
-			linux,can-disable;
-			gpios = <&gpb 21 GPIO_ACTIVE_LOW>;
-		};
-
-		button-11 {
-			label = "Select button";
-			linux,code = <KEY_ESC>;
-			linux,can-disable;
-			/*
-			 * This is the only button that is active high,
-			 * since it doubles as BOOT_SEL1.
-			 */
-			gpios = <&gpd 18 GPIO_ACTIVE_HIGH>;
-		};
-
-		button-12 {
-			label = "Power slider";
-			linux,code = <KEY_POWER>;
-			linux,can-disable;
-			gpios = <&gpa 30 GPIO_ACTIVE_LOW>;
-			wakeup-source;
-		};
-
-		button-13 {
-			label = "Power hold";
-			linux,code = <KEY_PAUSE>;
-			linux,can-disable;
-			gpios = <&gpf 11 GPIO_ACTIVE_LOW>;
-		};
-	};
-
 	i2c3: i2c-controller@3 {
 		compatible = "i2c-gpio";
 		#address-cells = <1>;
@@ -280,11 +72,10 @@ ldo6: LDO6 {
 					inl-supply = <&vcc>;
 				};
 
-				/* ??? */
-				LDO7 {
+				/* HDMI chip */
+				ldo7: LDO7 {
 					regulator-min-microvolt = <3300000>;
 					regulator-max-microvolt = <3300000>;
-					/*regulator-always-on;*/
 					inl-supply = <&vcc>;
 				};
 
@@ -316,227 +107,261 @@ LDO_REG10 {
 		};
 	};
 
-	leds {
-		compatible = "gpio-leds";
-
-		led {
-			gpios = <&gpb 30 GPIO_ACTIVE_LOW>;
-			default-state = "on";
-		};
-	};
-
-	spi {
-		compatible = "spi-gpio";
+	i2c4: i2c-controller@4 {
+		compatible = "i2c-gpio";
 		#address-cells = <1>;
 		#size-cells = <0>;
 
-		sck-gpios = <&gpe 15 GPIO_ACTIVE_HIGH>;
-		mosi-gpios = <&gpe 17 GPIO_ACTIVE_HIGH>;
-		cs-gpios = <&gpe 16 GPIO_ACTIVE_HIGH>;
-		num-chipselects = <1>;
+		sda-gpios = <&gpd 6 GPIO_ACTIVE_HIGH>;
+		scl-gpios = <&gpd 7 GPIO_ACTIVE_HIGH>;
+		clock-frequency = <100000>;
 
-		nt39016@0 {
-			compatible = "kingdisplay,kd035g6-54nt";
-			reg = <0>;
+		it6610: hdmi@4c {
+			status = "disabled"; /* Disable until the driver works */
+
+			compatible = "ite,it6610";
+			reg = <0x4c>;
+
+			interrupt-parent = <&gpf>;
+			interrupts = <12 0>;
+			interrupt-names = "irq";
+
+			reset-gpios = <&gpe 6 GPIO_ACTIVE_LOW>;
 
-			spi-max-frequency = <3125000>;
-			spi-3wire;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pins_it6610>;
 
-			reset-gpios = <&gpe 2 GPIO_ACTIVE_LOW>;
+			power-supply = <&ldo7>;
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+
+					hdmi_input: endpoint {
+						bus-width = <24>;
+						remote-endpoint = <&hdmi_output>;
+					};
+				};
 
-			backlight = <&backlight>;
-			power-supply = <&ldo6>;
+				port@1 {
+					reg = <1>;
 
-			port {
-				panel_input: endpoint {
-					remote-endpoint = <&panel_output>;
+					hdmi_connector_out: endpoint {
+						remote-endpoint = <&hdmi_connector_in>;
+					};
 				};
 			};
 		};
 	};
 
-	connector {
-		compatible = "gpio-usb-b-connector", "usb-b-connector";
-		label = "mini-USB";
-		type = "mini";
+	dc_charger: dc-charger {
+		compatible = "gpio-charger";
+		charger-type = "mains";
+		gpios = <&gpf 5 GPIO_ACTIVE_HIGH>;
 
-		/*
-		 * USB OTG is not yet working reliably, the ID detection
-		 * mechanism tends to fry easily for unknown reasons.
-		 * Until this is fixed, disable OTG by not providing the
-		 * ID GPIO to the driver.
-		 */
-		//id-gpios = <&gpf 18 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pins_dc_charger>;
+	};
 
-		vbus-gpios = <&gpb 5 GPIO_ACTIVE_HIGH>;
-		vbus-supply = <&otg_vbus>;
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
 
-		pinctrl-names = "default";
-		pinctrl-0 = <&pins_otg>;
+		type = "c";
 
 		port {
-			usb_ep: endpoint {
-				remote-endpoint = <&usb_otg_ep>;
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_connector_out>;
 			};
 		};
 	};
 };
 
-&ext {
-	clock-frequency = <12000000>;
+&headphones_amp {
+	VCC-supply = <&ldo5>;
 };
 
-&pinctrl {
-	pins_lcd: lcd {
-		function = "lcd";
-		groups = "lcd-24bit";
-	};
+&speaker_amp {
+	VCC-supply = <&ldo5>;
+};
 
-	pins_uart2: uart2 {
-		function = "uart2";
-		groups = "uart2-data";
-	};
+&sound_card {
+	simple-audio-card,widgets =
+		"Speaker", "Speaker",
+		"Headphone", "Headphones",
+		"Microphone", "Built-in Mic";
+	simple-audio-card,routing =
+		"Headphones Amp INL", "LHPOUT",
+		"Headphones Amp INR", "RHPOUT",
+		"Headphones", "Headphones Amp OUTL",
+		"Headphones", "Headphones Amp OUTR",
+		"Speaker Amp INL", "LOUT",
+		"Speaker Amp INR", "ROUT",
+		"Speaker", "Speaker Amp OUTL",
+		"Speaker", "Speaker Amp OUTR",
+		"LLINEIN", "Cap-less",
+		"RLINEIN", "Cap-less",
+		"Built-in Mic", "MICBIAS",
+		"MIC1P", "Built-in Mic",
+		"MIC1N", "Built-in Mic";
+	simple-audio-card,pin-switches = "Speaker", "Headphones";
+};
 
-	pins_mmc0: mmc0 {
-		function = "mmc0";
-		groups = "mmc0-1bit-a", "mmc0-4bit-a";
-	};
+&btn6 {
+	label = "Button Y";
+};
+
+&btn7 {
+	label = "Button X";
+};
 
-	pins_mmc1: mmc1 {
-		function = "mmc1";
-		groups = "mmc1-1bit-d", "mmc1-4bit-d";
+&gpio_keys {
+	btn13: button-13 {
+		label = "Power hold";
+		linux,code = <KEY_PAUSE>;
+		linux,can-disable;
+		gpios = <&gpf 11 GPIO_ACTIVE_LOW>;
 	};
+};
 
-	pins_otg: otg {
-		otg-vbus-pin {
-			function = "otg";
-			groups = "otg-vbus";
-		};
+&spi0_gpio {
+	status = "okay";
 
-		vbus-pin {
-			pins = "PB5";
-			bias-disable;
-		};
-	};
+	panel: nt39016@0 {
+		compatible = "kingdisplay,kd035g6-54nt";
+		reg = <0>;
 
-	pins_pwm1: pwm1 {
-		function = "pwm1";
-		groups = "pwm1";
-	};
+		spi-max-frequency = <3125000>;
+		spi-3wire;
 
-	pins_pwm4: pwm4 {
-		function = "pwm4";
-		groups = "pwm4";
+		reset-gpios = <&gpe 2 GPIO_ACTIVE_LOW>;
+
+		backlight = <&backlight>;
+		power-supply = <&ldo6>;
+
+		port {
+			panel_input: endpoint {
+				remote-endpoint = <&panel_output>;
+			};
+		};
 	};
 };
 
-&uart2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pins_uart2>;
-
-	status = "okay";
+&usb_conn {
+	vbus-supply = <&otg_vbus>;
 };
 
-&cgu {
+&usb_otg {
 	/*
-	 * Put high-speed peripherals under PLL1, such that we can change the
-	 * PLL0 frequency on demand without having to suspend peripherals.
-	 * We use a rate of 432 MHz, which is the least common multiple of
-	 * 27 MHz (required by TV encoder) and 48 MHz (required by USB host).
-	 * Put the GPU under PLL0 since we want a higher frequency.
-	 * Use the 32 kHz oscillator as the parent of the RTC for a higher
-	 * precision.
+	 * The GCW Zero's ID detect mechanism has a tendency to toast itself,
+	 * causing it to misdetect the USB mode and dumping current on the wires
+	 * when it's not supposed to, causing further damage elsewhere.
+	 * To support devices with the toasted ID detection, as well as prevent
+	 * potential hardware damage on yet unaffected devices, force USB mode
+	 * to peripheral only.
 	 */
-	assigned-clocks =
-		<&cgu JZ4770_CLK_PLL1>,
-		<&cgu JZ4770_CLK_GPU>,
-		<&cgu JZ4770_CLK_RTC>,
-		<&cgu JZ4770_CLK_UHC>,
-		<&cgu JZ4770_CLK_LPCLK_MUX>,
-		<&cgu JZ4770_CLK_MMC0_MUX>,
-		<&cgu JZ4770_CLK_MMC1_MUX>;
-	assigned-clock-parents =
-		<0>,
-		<&cgu JZ4770_CLK_PLL0>,
-		<&cgu JZ4770_CLK_OSC32K>,
-		<&cgu JZ4770_CLK_PLL1>,
-		<&cgu JZ4770_CLK_PLL1>,
-		<&cgu JZ4770_CLK_PLL1>,
-		<&cgu JZ4770_CLK_PLL1>;
-	assigned-clock-rates =
-		<432000000>,
-		<600000000>;
+	dr_mode = "peripheral";
 };
 
-&uhc {
-	/* The WiFi module is connected to the UHC. */
-	status = "okay";
+&pmu {
+	power-supplies = <&act8600>, <&usb_conn>, <&dc_charger>;
 };
 
-&tcu {
-	/*
-	 * 750 kHz for the system timer and clocksource, 12 MHz for the OST,
-	 * and use RTC as the parent for the watchdog clock
-	 */
-	assigned-clocks = <&tcu TCU_CLK_TIMER0>, <&tcu TCU_CLK_TIMER2>,
-			  <&tcu TCU_CLK_OST>, <&tcu TCU_CLK_WDT>;
-	assigned-clock-parents = <0>, <0>, <0>, <&cgu JZ4770_CLK_RTC>;
-	assigned-clock-rates = <750000>, <750000>, <12000000>;
+&js_axis0 {
+	abs-range = <3300 0>;
+};
 
-	/* PWM1 is in use, so use channel #2 for the clocksource */
-	ingenic,pwm-channels-mask = <0xfa>;
+&js_axis1 {
+	abs-range = <0 3300>;
 };
 
-&usb_otg {
-	port {
-		usb_otg_ep: endpoint {
-			remote-endpoint = <&usb_ep>;
-		};
+&pinctrl {
+	pins_i2c0: i2c0 {
+		function = "i2c0";
+		groups = "i2c0-data";
+	};
+
+	pins_i2c1: i2c1 {
+		function = "i2c1";
+		groups = "i2c1-data";
+	};
+
+	pins_it6610: it6610 {
+		pins = "PF12";
+		bias-pull-up;
+	};
+
+	pins_pwm4: pwm4 {
+		function = "pwm4";
+		groups = "pwm4";
+	};
+
+	pins_dc_charger: dc-charger {
+		pins = "PF5";
+		bias-pull-down;
 	};
 };
 
+&uhc {
+	/* The WiFi module is connected to the UHC. */
+	status = "okay";
+};
+
 &otg_phy {
 	vcc-supply = <&ldo5>;
 };
 
-&rtc {
-	clocks = <&cgu JZ4770_CLK_RTC>;
-	clock-names = "rtc";
+&i2c0 {
+	status = "okay";
 
-	system-power-controller;
-};
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_i2c0>;
 
-&mmc0 {
-	status = "okay";
+	clock-frequency = <400000>; /* 400 kHz */
 
-	bus-width = <4>;
-	max-frequency = <48000000>;
-	vmmc-supply = <&vcc>;
-	non-removable;
+	radio: radio@11 {
+		compatible = "rda,rda5807";
+		reg = <0x11>;
 
-	pinctrl-names = "default";
-	pinctrl-0 = <&pins_mmc0>;
+		rda,lnan;
+		rda,lnap;
+		rda,analog-out;
+
+		power-supply = <&ldo6>;
+	};
 };
 
-&mmc1 {
+&i2c1 {
 	status = "okay";
 
-	bus-width = <4>;
-	max-frequency = <48000000>;
-	cd-gpios = <&gpb 2 GPIO_ACTIVE_LOW>;
-	vmmc-supply = <&mmc1_power>;
-
 	pinctrl-names = "default";
-	pinctrl-0 = <&pins_mmc1>;
+	pinctrl-0 = <&pins_i2c1>;
+
+	clock-frequency = <100000>; /* 100 kHz */
+
+	accelerometer@15 {
+		compatible = "memsic,mxc6225";
+		reg = <0x15>;
+	};
 };
 
-&lcd {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pins_lcd>;
+&lcd_ports {
+	port@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0>;
 
-	port {
-		panel_output: endpoint {
+		panel_output: endpoint@0 {
+			reg = <0>;
 			remote-endpoint = <&panel_input>;
 		};
+
+		hdmi_output: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&hdmi_input>;
+		};
 	};
 };
diff --git a/arch/mips/boot/dts/ingenic/gopher2.dts b/arch/mips/boot/dts/ingenic/gopher2.dts
new file mode 100644
index 00000000000..632135ffd04
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/gopher2.dts
@@ -0,0 +1,143 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "rs97.dts"
+
+/ {
+	compatible = "qishenglong,gopher2", "ingenic,jz4760";
+	model = "Gopher 2";
+
+	lcd-panel-1 {
+		compatible = "qishenglong,gopher2b-lcd";
+
+		backlight = <&backlight>;
+		power-supply = <&lcd_power>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pins_lcd>;
+
+		port {
+			lcd_panel_input: endpoint {
+				remote-endpoint = <&panel_output>;
+			};
+		};
+	};
+};
+
+&memory {
+	reg = <0x0 0x4000000>;
+};
+
+&btn_up {
+	gpios = <&gpd 23 GPIO_ACTIVE_LOW>;
+};
+
+&btn_down {
+	gpios = <&gpd 22 GPIO_ACTIVE_LOW>;
+};
+
+&btn_left {
+	gpios = <&gpa 29 GPIO_ACTIVE_LOW>;
+};
+
+&btn_right {
+	gpios = <&gpd 24 GPIO_ACTIVE_LOW>;
+};
+
+&btn_a {
+	gpios = <&gpb 23 GPIO_ACTIVE_LOW>;
+};
+
+&btn_b {
+	gpios = <&gpb 24 GPIO_ACTIVE_LOW>;
+};
+
+&btn_y {
+	gpios = <&gpd 6 GPIO_ACTIVE_LOW>;
+};
+
+&btn_x {
+	gpios = <&gpd 7 GPIO_ACTIVE_LOW>;
+};
+
+&btn_ltrig {
+	gpios = <&gpd 12 GPIO_ACTIVE_LOW>;
+};
+
+&btn_rtrig {
+	gpios = <&gpd 5 GPIO_ACTIVE_LOW>;
+};
+
+&btn_power {
+	status = "disabled";
+};
+
+&btn_star {
+	status = "disabled";
+};
+
+&gpio_keys {
+	btn_c: button-14 {
+		label = "Button C";
+		linux,code = <KEY_PAGEUP>;
+		linux,can-disable;
+		gpios = <&gpb 26 GPIO_ACTIVE_LOW>;
+	};
+
+	btn_z: button-15 {
+		label = "Button Z";
+		linux,code = <KEY_PAGEDOWN>;
+		linux,can-disable;
+		gpios = <&gpd 0 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&audio_amp {
+	enable-gpios = <&gpa 28 GPIO_ACTIVE_HIGH>;
+};
+
+&sound_card {
+	simple-audio-card,hp-det-gpio = <&gpe 7 GPIO_ACTIVE_HIGH>;
+};
+
+&lcd_power {
+	gpio = <&gpe 4 0>;
+};
+
+&spi {
+	status = "disabled";
+};
+
+&panel {
+	status = "disabled";
+};
+
+&usb_conn {
+	vbus-gpios = <&gpa 6 GPIO_ACTIVE_HIGH>;
+};
+
+&vdiv {
+	output-ohms = <346000>;
+	full-ohms = <1346000>;
+};
+
+&pins_lcd {
+	groups = "lcd-8bit", "lcd-16bit", "lcd-18bit", "lcd-24bit", "lcd-generic";
+};
+
+&vbus_pin {
+	pins = "PA6";
+};
+
+&panel_output {
+	remote-endpoint = <&lcd_panel_input>;
+};
+
+&panel_input {
+	remote-endpoint = <&panel_input>;
+};
+
+&mmc2 {
+	cd-gpios = <&gpe 11 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&vcc>;
+};
diff --git a/arch/mips/boot/dts/ingenic/gopher2b.dts b/arch/mips/boot/dts/ingenic/gopher2b.dts
new file mode 100644
index 00000000000..1b049f8234b
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/gopher2b.dts
@@ -0,0 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "gopher2.dts"
+#include "jz4760b.dtsi"
+
+/ {
+	compatible = "qishenglong,gopher2b", "ingenic,jz4760b";
+	model = "Gopher 2B";
+};
diff --git a/arch/mips/boot/dts/ingenic/jz4760.dtsi b/arch/mips/boot/dts/ingenic/jz4760.dtsi
new file mode 100644
index 00000000000..d1776195990
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/jz4760.dtsi
@@ -0,0 +1,488 @@
+// SPDX-License-Identifier: GPL-2.0
+#ifndef JZ4760_DTSI
+#define JZ4760_DTSI
+#include <dt-bindings/clock/ingenic,jz4760-cgu.h>
+#include <dt-bindings/clock/ingenic,tcu.h>
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	compatible = "ingenic,jz4760";
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "ingenic,xburst-fpu1.0-mxu1.1";
+			reg = <0>;
+
+			clocks = <&cgu JZ4760_CLK_CCLK>;
+			clock-names = "cpu";
+		};
+	};
+
+	cpuintc: interrupt-controller {
+		#address-cells = <0>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+		compatible = "mti,cpu-interrupt-controller";
+	};
+
+	intc: interrupt-controller@10001000 {
+		compatible = "ingenic,jz4760-intc";
+		reg = <0x10001000 0x40>;
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+
+		interrupt-parent = <&cpuintc>;
+		interrupts = <2>;
+	};
+
+	ext: ext {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+	};
+
+	osc32k: osc32k {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+	};
+
+	cgu: clock-controller@10000000 {
+		compatible = "ingenic,jz4760-cgu", "simple-mfd";
+		reg = <0x10000000 0x100>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x10000000 0x100>;
+
+		clocks = <&ext>, <&osc32k>;
+		clock-names = "ext", "osc32k";
+
+		#clock-cells = <1>;
+
+		otg_phy: usb-phy@3c {
+			compatible = "ingenic,jz4760-phy";
+			reg = <0x3c 0x10>;
+
+			clocks = <&cgu JZ4760_CLK_OTG_PHY>;
+
+			#phy-cells = <0>;
+		};
+	};
+
+	tcu: timer@10002000 {
+		compatible = "ingenic,jz4760-tcu", "simple-mfd";
+		reg = <0x10002000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x10002000 0x1000>;
+
+		#clock-cells = <1>;
+
+		clocks = <&cgu JZ4760_CLK_RTC>,
+			 <&cgu JZ4760_CLK_EXT>,
+			 <&cgu JZ4760_CLK_PCLK>;
+		clock-names = "rtc", "ext", "pclk";
+
+		interrupt-controller;
+		#interrupt-cells = <1>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <27>, <26>, <25>;
+
+		watchdog: watchdog@0 {
+			compatible = "ingenic,jz4760-watchdog",
+				     "ingenic,jz4740-watchdog";
+			reg = <0x0 0xc>;
+
+			clocks = <&tcu TCU_CLK_WDT>;
+			clock-names = "wdt";
+		};
+
+		pwm: pwm@40 {
+			compatible = "ingenic,jz4760-pwm", "ingenic,jz4740-pwm";
+			reg = <0x40 0x80>;
+
+			#pwm-cells = <3>;
+
+			clocks = <&tcu TCU_CLK_TIMER0>, <&tcu TCU_CLK_TIMER1>,
+				 <&tcu TCU_CLK_TIMER2>, <&tcu TCU_CLK_TIMER3>,
+				 <&tcu TCU_CLK_TIMER4>, <&tcu TCU_CLK_TIMER5>,
+				 <&tcu TCU_CLK_TIMER6>, <&tcu TCU_CLK_TIMER7>;
+			clock-names = "timer0", "timer1", "timer2", "timer3",
+				      "timer4", "timer5", "timer6", "timer7";
+		};
+
+		ost: timer@e0 {
+			compatible = "ingenic,jz4760-ost", "ingenic,jz4725b-ost";
+			reg = <0xe0 0x20>;
+
+			clocks = <&tcu TCU_CLK_OST>;
+			clock-names = "ost";
+
+			interrupts = <15>;
+		};
+	};
+
+	rtc: rtc@10003000 {
+		compatible = "ingenic,jz4760-rtc";
+		reg = <0x10003000 0x40>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <32>;
+	};
+
+	pinctrl: pinctrl@10010000 {
+		compatible = "ingenic,jz4760-pinctrl";
+		reg = <0x10010000 0x600>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		gpa: gpio@0 {
+			compatible = "ingenic,jz4760-gpio";
+			reg = <0>;
+
+			gpio-controller;
+			gpio-ranges = <&pinctrl 0 0 32>;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+
+			interrupt-parent = <&intc>;
+			interrupts = <17>;
+		};
+
+		gpb: gpio@1 {
+			compatible = "ingenic,jz4760-gpio";
+			reg = <1>;
+
+			gpio-controller;
+			gpio-ranges = <&pinctrl 0 32 32>;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+
+			interrupt-parent = <&intc>;
+			interrupts = <16>;
+		};
+
+		gpc: gpio@2 {
+			compatible = "ingenic,jz4760-gpio";
+			reg = <2>;
+
+			gpio-controller;
+			gpio-ranges = <&pinctrl 0 64 32>;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+
+			interrupt-parent = <&intc>;
+			interrupts = <15>;
+		};
+
+		gpd: gpio@3 {
+			compatible = "ingenic,jz4760-gpio";
+			reg = <3>;
+
+			gpio-controller;
+			gpio-ranges = <&pinctrl 0 96 32>;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+
+			interrupt-parent = <&intc>;
+			interrupts = <14>;
+		};
+
+		gpe: gpio@4 {
+			compatible = "ingenic,jz4760-gpio";
+			reg = <4>;
+
+			gpio-controller;
+			gpio-ranges = <&pinctrl 0 128 32>;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+
+			interrupt-parent = <&intc>;
+			interrupts = <13>;
+		};
+
+		gpf: gpio@5 {
+			compatible = "ingenic,jz4760-gpio";
+			reg = <5>;
+
+			gpio-controller;
+			gpio-ranges = <&pinctrl 0 160 32>;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+
+			interrupt-parent = <&intc>;
+			interrupts = <12>;
+		};
+	};
+
+	aic: audio-controller@10020000 {
+		compatible = "ingenic,jz4760-i2s";
+		reg = <0x10020000 0x94>;
+
+		#sound-dai-cells = <0>;
+
+		clocks = <&cgu JZ4760_CLK_AIC>, <&cgu JZ4760_CLK_I2S>,
+			 <&cgu JZ4760_CLK_EXT>, <&cgu JZ4760_CLK_PLL0_HALF>;
+		clock-names = "aic", "i2s", "ext", "pll half";
+
+		interrupt-parent = <&intc>;
+		interrupts = <34>;
+
+		dmas = <&dmac1 25 0>, <&dmac1 24 1>;
+		dma-names = "rx", "tx";
+	};
+
+	codec: audio-codec@100200a0 {
+		compatible = "ingenic,jz4760-codec";
+		reg = <0x100200a4 0x8>;
+
+		#sound-dai-cells = <0>;
+
+		clocks = <&cgu JZ4760_CLK_AIC>;
+		clock-names = "aic";
+	};
+
+	mmc0: mmc@10021000 {
+		compatible = "ingenic,jz4760-mmc";
+		reg = <0x10021000 0x1000>;
+
+		clocks = <&cgu JZ4760_CLK_MMC0>;
+		clock-names = "mmc";
+
+		interrupt-parent = <&intc>;
+		interrupts = <37>;
+
+		dmas = <&dmac0 26 27 0xffffffff>;
+		dma-names = "tx-rx";
+
+		cap-sd-highspeed;
+		cap-mmc-highspeed;
+		cap-sdio-irq;
+
+		status = "disabled";
+	};
+
+	mmc1: mmc@10022000 {
+		compatible = "ingenic,jz4760-mmc";
+		reg = <0x10022000 0x1000>;
+
+		clocks = <&cgu JZ4760_CLK_MMC1>;
+		clock-names = "mmc";
+
+		interrupt-parent = <&intc>;
+		interrupts = <36>;
+
+		dmas = <&dmac0 30 31 0xffffffff>;
+		dma-names = "tx-rx";
+
+		cap-sd-highspeed;
+		cap-mmc-highspeed;
+		cap-sdio-irq;
+
+		status = "disabled";
+	};
+
+	mmc2: mmc@10023000 {
+		compatible = "ingenic,jz4760-mmc";
+		reg = <0x10023000 0x1000>;
+
+		clocks = <&cgu JZ4760_CLK_MMC2>;
+		clock-names = "mmc";
+
+		interrupt-parent = <&intc>;
+		interrupts = <35>;
+
+		dmas = <&dmac0 36 37 0xffffffff>;
+		dma-names = "tx-rx";
+
+		cap-sd-highspeed;
+		cap-mmc-highspeed;
+		cap-sdio-irq;
+
+		status = "disabled";
+	};
+
+	uart0: serial@10030000 {
+		compatible = "ingenic,jz4760-uart";
+		reg = <0x10030000 0x100>;
+
+		clocks = <&ext>, <&cgu JZ4760_CLK_UART0>;
+		clock-names = "baud", "module";
+
+		interrupt-parent = <&intc>;
+		interrupts = <5>;
+
+		status = "disabled";
+	};
+
+	uart1: serial@10031000 {
+		compatible = "ingenic,jz4760-uart";
+		reg = <0x10031000 0x100>;
+
+		clocks = <&ext>, <&cgu JZ4760_CLK_UART1>;
+		clock-names = "baud", "module";
+
+		interrupt-parent = <&intc>;
+		interrupts = <4>;
+
+		status = "disabled";
+	};
+
+	uart2: serial@10032000 {
+		compatible = "ingenic,jz4760-uart";
+		reg = <0x10032000 0x100>;
+
+		clocks = <&ext>, <&cgu JZ4760_CLK_UART2>;
+		clock-names = "baud", "module";
+
+		interrupt-parent = <&intc>;
+		interrupts = <3>;
+
+		status = "disabled";
+	};
+
+	uart3: serial@10033000 {
+		compatible = "ingenic,jz4760-uart";
+		reg = <0x10033000 0x100>;
+
+		clocks = <&ext>, <&cgu JZ4760_CLK_UART3>;
+		clock-names = "baud", "module";
+
+		interrupt-parent = <&intc>;
+		interrupts = <2>;
+
+		status = "disabled";
+	};
+
+	adc: adc@10070000 {
+		compatible = "ingenic,jz4760-adc";
+		reg = <0x10070000 0x30>;
+
+		#io-channel-cells = <1>;
+
+		clocks = <&cgu JZ4760_CLK_ADC>;
+		clock-names = "adc";
+
+		interrupt-parent = <&intc>;
+		interrupts = <18>;
+	};
+
+	mdmac: dma-controller@13030000 {
+		compatible = "ingenic,jz4760-mdma";
+		reg = <0x13030000 0xc0>, <0x13030300 0x14>;
+
+		#dma-cells = <2>;
+
+		clocks = <&cgu JZ4760_CLK_MDMA>;
+		interrupt-parent = <&intc>;
+		interrupts = <22>;
+
+		status = "disabled";
+	};
+
+	lcd: lcd-controller@13050000 {
+		compatible = "ingenic,jz4760-lcd";
+		reg = <0x13050000 0x300>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <31>;
+
+		clocks = <&cgu JZ4760_CLK_LPCLK>;
+		clock-names = "lcd_pclk";
+	};
+
+	ipu: ipu@13080000 {
+		compatible = "ingenic,jz4760-ipu";
+		reg = <0x13080000 0x800>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <29>;
+
+		clocks = <&cgu JZ4760_CLK_IPU>;
+		clock-names = "ipu";
+	};
+
+	dmac0: dma-controller@13420000 {
+		compatible = "ingenic,jz4760-dma";
+		reg = <0x13420000 0xc0>, <0x13420300 0x14>;
+
+		#dma-cells = <3>;
+
+		clocks = <&cgu JZ4760_CLK_DMA>;
+		interrupt-parent = <&intc>;
+		interrupts = <24>;
+	};
+
+	dmac1: dma-controller@13420100 {
+		compatible = "ingenic,jz4760-dma";
+		reg = <0x13420100 0xc0>, <0x13420400 0x14>;
+
+		#dma-cells = <2>;
+
+		/* AIC seem to be able to only use DMAC1 channels 0 and 1 */
+		ingenic,reserved-channels = <0x3>;
+
+		clocks = <&cgu JZ4760_CLK_DMA>;
+		interrupt-parent = <&intc>;
+		interrupts = <23>;
+	};
+
+	uhc: usb@13430000 {
+		compatible = "generic-ohci";
+		reg = <0x13430000 0x1000>;
+
+		clocks = <&cgu JZ4760_CLK_UHC>;
+		assigned-clocks = <&cgu JZ4760_CLK_UHC>;
+		assigned-clock-rates = <48000000>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <20>;
+
+		status = "disabled";
+	};
+
+	usb_otg: usb@13440000 {
+		compatible = "ingenic,jz4760-musb", "ingenic,jz4740-musb";
+		reg = <0x13440000 0x10000>;
+
+		clocks = <&cgu JZ4760_CLK_OTG>;
+		clock-names = "udc";
+
+		interrupt-parent = <&intc>;
+		interrupts = <21>;
+		interrupt-names = "mc";
+
+		phys = <&otg_phy>;
+
+		usb-role-switch;
+	};
+
+	rom: rom@1fc00000 {
+		compatible = "mtd-rom";
+		probe-type = "map_rom";
+		reg = <0x1fc00000 0x2000>;
+
+		bank-width = <4>;
+		device-width = <1>;
+	};
+};
+#endif /* JZ4760_DTSI */
diff --git a/arch/mips/boot/dts/ingenic/jz4760b.dtsi b/arch/mips/boot/dts/ingenic/jz4760b.dtsi
new file mode 100644
index 00000000000..74a39baa031
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/jz4760b.dtsi
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include "jz4760.dtsi"
+
+/ {
+	compatible = "ingenic,jz4760b";
+};
+
+&lcd {
+	compatible = "ingenic,jz4760b-lcd";
+};
+
+&ost {
+	compatible = "ingenic,jz4760b-ost";
+};
+
+&pinctrl {
+	compatible = "ingenic,jz4760b-pinctrl";
+};
+
+&mdmac {
+	compatible = "ingenic,jz4760b-mdma";
+	reg = <0x13030000 0xc0>, <0x13030300 0x1c>;
+};
+
+&dmac0 {
+	compatible = "ingenic,jz4760b-dma";
+	reg = <0x13420000 0xc0>, <0x13420300 0x1c>;
+};
+
+&dmac1 {
+	compatible = "ingenic,jz4760b-dma";
+	reg = <0x13420100 0xc0>, <0x13420400 0x1c>;
+};
diff --git a/arch/mips/boot/dts/ingenic/jz4770.dtsi b/arch/mips/boot/dts/ingenic/jz4770.dtsi
index 9c0099919db..8ed5bc0531a 100644
--- a/arch/mips/boot/dts/ingenic/jz4770.dtsi
+++ b/arch/mips/boot/dts/ingenic/jz4770.dtsi
@@ -29,7 +29,7 @@ cpuintc: interrupt-controller {
 	};
 
 	intc: interrupt-controller@10001000 {
-		compatible = "ingenic,jz4770-intc";
+		compatible = "ingenic,jz4770-intc", "ingenic,jz4760-intc";
 		reg = <0x10001000 0x40>;
 
 		interrupt-controller;
@@ -73,7 +73,7 @@ otg_phy: usb-phy@3c {
 	};
 
 	tcu: timer@10002000 {
-		compatible = "ingenic,jz4770-tcu", "simple-mfd";
+		compatible = "ingenic,jz4770-tcu", "ingenic,jz4760-tcu", "simple-mfd";
 		reg = <0x10002000 0x1000>;
 		#address-cells = <1>;
 		#size-cells = <1>;
@@ -116,7 +116,7 @@ pwm: pwm@40 {
 		};
 
 		ost: timer@e0 {
-			compatible = "ingenic,jz4770-ost";
+			compatible = "ingenic,jz4770-ost", "ingenic,jz4760b-ost";
 			reg = <0xe0 0x20>;
 
 			clocks = <&tcu TCU_CLK_OST>;
@@ -134,7 +134,7 @@ rtc: rtc@10003000 {
 		interrupts = <32>;
 	};
 
-	pinctrl: pin-controller@10010000 {
+	pinctrl: pinctrl@10010000 {
 		compatible = "ingenic,jz4770-pinctrl";
 		reg = <0x10010000 0x600>;
 
@@ -268,8 +268,8 @@ mmc0: mmc@10021000 {
 		interrupt-parent = <&intc>;
 		interrupts = <37>;
 
-		dmas = <&dmac1 27 0xffffffff>, <&dmac1 26 0xffffffff>;
-		dma-names = "rx", "tx";
+		dmas = <&dmac1 26 27 0xffffffff>;
+		dma-names = "tx-rx";
 
 		cap-sd-highspeed;
 		cap-mmc-highspeed;
@@ -288,8 +288,8 @@ mmc1: mmc@10022000 {
 		interrupt-parent = <&intc>;
 		interrupts = <36>;
 
-		dmas = <&dmac1 31 0xffffffff>, <&dmac1 30 0xffffffff>;
-		dma-names = "rx", "tx";
+		dmas = <&dmac1 30 31 0xffffffff>;
+		dma-names = "tx-rx";
 
 		cap-sd-highspeed;
 		cap-mmc-highspeed;
@@ -308,8 +308,8 @@ mmc2: mmc@10023000 {
 		interrupt-parent = <&intc>;
 		interrupts = <35>;
 
-		dmas = <&dmac1 37 0xffffffff>, <&dmac1 36 0xffffffff>;
-		dma-names = "rx", "tx";
+		dmas = <&dmac1 36 37 0xffffffff>;
+		dma-names = "tx-rx";
 
 		cap-sd-highspeed;
 		cap-mmc-highspeed;
@@ -319,7 +319,7 @@ mmc2: mmc@10023000 {
 	};
 
 	uart0: serial@10030000 {
-		compatible = "ingenic,jz4770-uart";
+		compatible = "ingenic,jz4770-uart", "ingenic,jz4760-uart";
 		reg = <0x10030000 0x100>;
 
 		clocks = <&ext>, <&cgu JZ4770_CLK_UART0>;
@@ -332,7 +332,7 @@ uart0: serial@10030000 {
 	};
 
 	uart1: serial@10031000 {
-		compatible = "ingenic,jz4770-uart";
+		compatible = "ingenic,jz4770-uart", "ingenic,jz4760-uart";
 		reg = <0x10031000 0x100>;
 
 		clocks = <&ext>, <&cgu JZ4770_CLK_UART1>;
@@ -345,7 +345,7 @@ uart1: serial@10031000 {
 	};
 
 	uart2: serial@10032000 {
-		compatible = "ingenic,jz4770-uart";
+		compatible = "ingenic,jz4770-uart", "ingenic,jz4760-uart";
 		reg = <0x10032000 0x100>;
 
 		clocks = <&ext>, <&cgu JZ4770_CLK_UART2>;
@@ -358,7 +358,7 @@ uart2: serial@10032000 {
 	};
 
 	uart3: serial@10033000 {
-		compatible = "ingenic,jz4770-uart";
+		compatible = "ingenic,jz4770-uart", "ingenic,jz4760-uart";
 		reg = <0x10033000 0x100>;
 
 		clocks = <&ext>, <&cgu JZ4770_CLK_UART3>;
@@ -370,6 +370,88 @@ uart3: serial@10033000 {
 		status = "disabled";
 	};
 
+	ssi0: spi@10043000 {
+		compatible = "ingenic,jz4770-spi", "ingenic,jz4750-spi";
+		reg = <0x10043000 0x1c>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <8>;
+
+		clocks = <&cgu JZ4770_CLK_SSI0>;
+
+		dmas = <&dmac0 23 0xffffffff>, <&dmac0 22 0xffffffff>;
+		dma-names = "rx", "tx";
+
+		status = "disabled";
+	};
+
+	ssi1: spi@10044000 {
+		compatible = "ingenic,jz4770-spi", "ingenic,jz4750-spi";
+		reg = <0x10044000 0x1c>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <7>;
+
+		clocks = <&cgu JZ4770_CLK_SSI1>;
+
+		dmas = <&dmac0 33 0xffffffff>, <&dmac0 32 0xffffffff>;
+		dma-names = "rx", "tx";
+
+		status = "disabled";
+	};
+
+	i2c0: i2c@10050000 {
+		compatible = "ingenic,jz4770-i2c";
+		reg = <0x10050000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <1>;
+		clocks = <&cgu JZ4770_CLK_I2C0>;
+
+		dmas = <&dmac1 40 41 0xffffffff>;
+		dma-names = "tx-rx";
+
+		status = "disabled";
+	};
+
+	i2c1: i2c@10051000 {
+		compatible = "ingenic,jz4770-i2c";
+		reg = <0x10051000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <0>;
+		clocks = <&cgu JZ4770_CLK_I2C1>;
+
+		dmas = <&dmac1 42 43 0xffffffff>;
+		dma-names = "tx-rx";
+
+		status = "disabled";
+	};
+
+	i2c2: i2c@10055000 {
+		compatible = "ingenic,jz4770-i2c";
+		reg = <0x10055000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <22>;
+		clocks = <&cgu JZ4770_CLK_I2C2>;
+
+		dmas = <&dmac1 62 63 0xffffffff>;
+		dma-names = "tx-rx";
+
+		status = "disabled";
+	};
+
 	adc: adc@10070000 {
 		compatible = "ingenic,jz4770-adc";
 		reg = <0x10070000 0x30>;
@@ -405,6 +487,63 @@ lcd: lcd-controller@13050000 {
 
 		clocks = <&cgu JZ4770_CLK_LPCLK_MUX>;
 		clock-names = "lcd_pclk";
+
+		lcd_ports: ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@8 {
+				reg = <8>;
+
+				ipu_output: endpoint {
+					remote-endpoint = <&ipu_input>;
+				};
+			};
+		};
+	};
+
+	ipu: ipu@13080000 {
+		compatible = "ingenic,jz4770-ipu", "ingenic,jz4760-ipu";
+		reg = <0x13080000 0x800>;
+
+		interrupt-parent = <&intc>;
+		interrupts = <29>;
+
+		clocks = <&cgu JZ4770_CLK_IPU>;
+		clock-names = "ipu";
+
+		port {
+			ipu_input: endpoint {
+				remote-endpoint = <&ipu_output>;
+			};
+		};
+	};
+
+	vpu: video-decoder@132a0000 {
+		compatible = "ingenic,jz4770-vpu-rproc", "simple-mfd";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x132a0000 0x20>;
+
+		reg = <0x132a0000 0x20>, /* AUX */
+		      <0x132b0000 0x4000>, /* TCSM0 */
+		      <0x132c0000 0xc000>, /* TCSM1 */
+		      <0x132f0000 0x7000>; /* SRAM */
+		reg-names = "aux", "tcsm0", "tcsm1", "sram";
+
+		clocks = <&cgu JZ4770_CLK_AUX>, <&cgu JZ4770_CLK_VPU>;
+		clock-names = "aux", "vpu";
+
+		interrupt-parent = <&cpuintc>;
+		interrupts = <3>;
+
+		hwlock: hwlock@4 {
+			compatible = "ingenic,jz4770-vpu-hwspinlock",
+				     "ingenic,jz4755-vpu-hwspinlock";
+			reg = <0x4 0xc>;
+
+			#hwlock-cells = <0>;
+		};
 	};
 
 	dmac0: dma-controller@13420000 {
@@ -422,7 +561,7 @@ dmac1: dma-controller@13420100 {
 		compatible = "ingenic,jz4770-dma";
 		reg = <0x13420100 0xC0>, <0x13420400 0x20>;
 
-		#dma-cells = <2>;
+		#dma-cells = <3>;
 
 		clocks = <&cgu JZ4770_CLK_DMA>;
 		interrupt-parent = <&intc>;
@@ -459,7 +598,20 @@ usb_otg: usb@13440000 {
 		usb-role-switch;
 	};
 
-	rom: memory@1fc00000 {
+	bdmac: dma-controller@13450000 {
+		compatible = "ingenic,jz4770-bdma", "ingenic,jz4760b-bdma";
+		reg = <0x13450000 0xc0>, <0x13450300 0x20>;
+
+		#dma-cells = <2>;
+
+		clocks = <&cgu JZ4770_CLK_BDMA>;
+		interrupt-parent = <&intc>;
+		interrupts = <10>;
+
+		status = "disabled";
+	};
+
+	rom: rom@1fc00000 {
 		compatible = "mtd-rom";
 		probe-type = "map_rom";
 		reg = <0x1fc00000 0x2000>;
diff --git a/arch/mips/boot/dts/ingenic/ldkh.dts b/arch/mips/boot/dts/ingenic/ldkh.dts
new file mode 100644
index 00000000000..0b528b2e571
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/ldkh.dts
@@ -0,0 +1,14 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+/* LDK (horizontal) is a RS-97 with a different panel */
+#include "rs97.dts"
+
+/ {
+	compatible = "wolsen,ldkh", "ingenic,jz4760";
+	model = "Wolsen LDK (horizontal)";
+};
+
+&panel {
+	compatible = "innolux,ej030na";
+};
diff --git a/arch/mips/boot/dts/ingenic/ldkv.dts b/arch/mips/boot/dts/ingenic/ldkv.dts
new file mode 100644
index 00000000000..237a2ea0d9f
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/ldkv.dts
@@ -0,0 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+/* LDK (vertical) is a LDK (horizontal) with a JZ4760B SoC */
+#include "ldkh.dts"
+#include "jz4760b.dtsi"
+
+/ {
+	compatible = "wolsen,ldkv", "ingenic,jz4760b";
+	model = "Wolsen LDK (vertical)";
+};
diff --git a/arch/mips/boot/dts/ingenic/papk3plus.dts b/arch/mips/boot/dts/ingenic/papk3plus.dts
new file mode 100644
index 00000000000..2652874072e
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/papk3plus.dts
@@ -0,0 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "papk3s.dts"
+#include "jz4760b.dtsi"
+
+/ {
+	compatible = "ylm,papk3plus", "ingenic,jz4760b";
+	model = "PAP-KIII+";
+};
diff --git a/arch/mips/boot/dts/ingenic/papk3s.dts b/arch/mips/boot/dts/ingenic/papk3s.dts
new file mode 100644
index 00000000000..f2f3aab92d0
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/papk3s.dts
@@ -0,0 +1,63 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "rs97.dts"
+
+/ {
+	compatible = "ylm,papk3s", "ingenic,jz4760";
+	model = "PAP-KIIIS";
+
+	lcd-panel-1 {
+		compatible = "qishenglong,gopher2b-lcd";
+
+		power-supply = <&vcc>;
+		backlight = <&backlight>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pins_lcd>;
+
+		port {
+			lcd_panel_input: endpoint {
+				remote-endpoint = <&panel_output>;
+			};
+		};
+	};
+};
+
+&gpio_keys {
+	button-13 {
+		label = "Volume+ button";
+		linux,code = <KEY_VOLUMEUP>;
+		linux,can-disable;
+		gpios = <&gpd 21 GPIO_ACTIVE_LOW>;
+	};
+
+	button-14 {
+		label = "Volume- button";
+		linux,code = <KEY_VOLUMEDOWN>;
+		linux,can-disable;
+		gpios = <&gpd 25 GPIO_ACTIVE_LOW>;
+	};
+};
+
+
+
+&spi {
+	status = "disabled";
+};
+
+&panel {
+	status = "disabled";
+};
+
+&pins_lcd {
+	groups = "lcd-8bit", "lcd-16bit", "lcd-18bit", "lcd-24bit", "lcd-generic";
+};
+
+&panel_output {
+	remote-endpoint = <&lcd_panel_input>;
+};
+
+&panel_input {
+	remote-endpoint = <&panel_input>;
+};
diff --git a/arch/mips/boot/dts/ingenic/pmp5.dts b/arch/mips/boot/dts/ingenic/pmp5.dts
new file mode 100644
index 00000000000..7a6318799af
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/pmp5.dts
@@ -0,0 +1,96 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "rs90.dts"
+
+/ {
+	compatible = "ylm,pmp5", "ingenic,jz4725b";
+	model = "PMP5";
+
+	keys@0 {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		key@0 {
+			label = "D-pad left";
+			linux,code = <KEY_LEFT>;
+			gpios = <&gpb 31 GPIO_ACTIVE_LOW>;
+		};
+
+		key@1 {
+			label = "D-pad right";
+			linux,code = <KEY_RIGHT>;
+			gpios = <&gpd 21 GPIO_ACTIVE_LOW>;
+		};
+
+		key@2 {
+			label = "Button A";
+			linux,code = <KEY_LEFTCTRL>;
+			gpios = <&gpc 31 GPIO_ACTIVE_LOW>;
+		};
+
+		key@3 {
+			label = "Button B";
+			linux,code = <KEY_LEFTALT>;
+			gpios = <&gpc 30 GPIO_ACTIVE_LOW>;
+		};
+
+		key@4 {
+			label = "Right shoulder button";
+			linux,code = <KEY_BACKSPACE>;
+			gpios = <&gpc 12 GPIO_ACTIVE_LOW>;
+			debounce-interval = <10>;
+		};
+
+		key@5 {
+			label = "Start button";
+			linux,code = <KEY_ENTER>;
+			gpios = <&gpd 17 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	keys@1 {
+		compatible = "adc-keys";
+		io-channels = <&adc INGENIC_ADC_AUX>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <2800000>;
+		poll-interval = <30>;
+
+		key@0 {
+			label = "D-pad up";
+			linux,code = <KEY_UP>;
+			press-threshold-microvolt = <1500000>;	// Up key pressed voltage: ~1370 mV
+		};
+
+		key@1 {
+			label = "Select button";
+			linux,code = <KEY_ESC>;
+			press-threshold-microvolt = <1200000>;	// Select key pressed voltage: ~1060mV
+		};
+
+		key@2 {
+			label = "Left shoulder button";
+			linux,code = <KEY_TAB>;
+			press-threshold-microvolt = <800000>;	// L key pressed voltage: ~680mV
+		};
+
+		key@3 {
+			label = "D-pad down";
+			linux,code = <KEY_DOWN>;
+			press-threshold-microvolt = <500000>;	// Down key pressed voltage: ~170mV
+		};
+	};
+};
+
+&pins_lcd {
+	groups = "lcd-8bit", "lcd-16bit", "lcd-special";
+};
+
+&pins_mmc1_cd {
+	pins = "PC20";
+};
+
+&mmc1 {
+	cd-gpios = <&gpc 20 GPIO_ACTIVE_LOW>;
+};
diff --git a/arch/mips/boot/dts/ingenic/pocketgo2.dts b/arch/mips/boot/dts/ingenic/pocketgo2.dts
new file mode 100644
index 00000000000..adf7f425e87
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/pocketgo2.dts
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "bits/gcw0-base.dtsi"
+
+/ {
+	compatible = "wolsen,pocketgo2", "ingenic,jz4770";
+	model = "Wolsen PocketGo2/PlayGo";
+
+	panel {
+		compatible = "frida,frd350h54004";
+
+		reset-gpios = <&gpe 2 GPIO_ACTIVE_LOW>;
+
+		backlight = <&backlight>;
+		power-supply = <&vcc>;
+
+		port {
+			panel_input: endpoint {
+				remote-endpoint = <&panel_output>;
+			};
+		};
+	};
+};
+
+&gpio_keys {
+	btn13: button-13 {
+		label = "L2 shoulder button";
+		linux,code = <KEY_PAGEUP>;
+		linux,can-disable;
+		gpios = <&gpd 31 GPIO_ACTIVE_LOW>;
+	};
+
+	btn14: button-14 {
+		label = "R2 shoulder button";
+		linux,code = <KEY_PAGEDOWN>;
+		linux,can-disable;
+		gpios = <&gpf 10 GPIO_ACTIVE_LOW>;
+	};
+
+	btn15: button-15 {
+		label = "Volume+ button";
+		linux,code = <KEY_VOLUMEUP>;
+		linux,can-disable;
+		gpios = <&gpd 19 GPIO_ACTIVE_LOW>;
+	};
+
+	btn16: button-16 {
+		label = "Volume- button";
+		linux,code = <KEY_VOLUMEDOWN>;
+		linux,can-disable;
+		gpios = <&gpe 13 GPIO_ACTIVE_LOW>;
+	};
+
+	btn17: button-17 {
+		label = "Menu button";
+		linux,code = <KEY_HOME>;
+		linux,can-disable;
+		gpios = <&gpe 8 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&js_axis0 {
+	abs-range = <3300 0>;
+};
+
+&js_axis1 {
+	abs-range = <0 3300>;
+};
+
+&lcd_ports {
+	port@0 {
+		reg = <0>;
+
+		panel_output: endpoint {
+			remote-endpoint = <&panel_input>;
+		};
+	};
+};
+
+&sound_card {
+	simple-audio-card,widgets =
+		"Speaker", "Speaker",
+		"Headphone", "Headphones";
+	simple-audio-card,routing =
+		"Headphones Amp INL", "LHPOUT",
+		"Headphones Amp INR", "RHPOUT",
+		"Headphones", "Headphones Amp OUTL",
+		"Headphones", "Headphones Amp OUTR",
+		"Speaker Amp INL", "LOUT",
+		"Speaker Amp INR", "ROUT",
+		"Speaker", "Speaker Amp OUTL",
+		"Speaker", "Speaker Amp OUTR";
+	simple-audio-card,pin-switches = "Speaker", "Headphones";
+};
diff --git a/arch/mips/boot/dts/ingenic/pocketgo2v2.dts b/arch/mips/boot/dts/ingenic/pocketgo2v2.dts
new file mode 100644
index 00000000000..c20466e60dc
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/pocketgo2v2.dts
@@ -0,0 +1,58 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "pocketgo2.dts"
+
+/ {
+	compatible = "wolsen,pocketgo2v2", "ingenic,jz4770";
+	model = "Wolsen PocketGo2/PlayGo Rev. 2";
+};
+
+&sound_card {
+	simple-audio-card,widgets =
+		"Speaker", "Speaker",
+		"Headphone", "Headphones";
+	simple-audio-card,routing =
+		"Headphones Amp INL", "LHPOUT",
+		"Headphones Amp INR", "RHPOUT",
+		"Headphones", "Headphones Amp OUTL",
+		"Headphones", "Headphones Amp OUTR",
+		"Speaker Amp INL", "Headphones Amp OUTL",
+		"Speaker Amp INR", "Headphones Amp OUTR",
+		"Speaker", "Speaker Amp OUTL",
+		"Speaker", "Speaker Amp OUTR";
+	simple-audio-card,pin-switches = "Speaker";
+};
+
+&joystick {
+	io-channels = <&adc INGENIC_ADC_TOUCH_YP>,
+		      <&adc INGENIC_ADC_TOUCH_XP>;
+};
+
+&js_axis0 {
+	abs-range = <2400 200>;
+};
+
+&js_axis1 {
+	abs-range = <2200 0>;
+};
+
+&btn8 {
+	gpios = <&gpb 10 GPIO_ACTIVE_LOW>;
+};
+
+&btn13 {
+	gpios = <&gpb 20 GPIO_ACTIVE_LOW>;
+};
+
+&btn14 {
+	gpios = <&gpb 11 GPIO_ACTIVE_LOW>;
+};
+
+&btn15 {
+	gpios = <&gpb 12 GPIO_ACTIVE_LOW>;
+};
+
+&btn16 {
+	gpios = <&gpb 13 GPIO_ACTIVE_LOW>;
+};
diff --git a/arch/mips/boot/dts/ingenic/rg280m-v1.0.dts b/arch/mips/boot/dts/ingenic/rg280m-v1.0.dts
new file mode 100644
index 00000000000..9bfb5b5cfa1
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/rg280m-v1.0.dts
@@ -0,0 +1,108 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "rg280m-v1.1.dts"
+
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	compatible = "ylm,rg280m-v1.0", "ingenic,jz4770";
+	model = "Anbernic RG-280M v1.0";
+
+	hdmi_power: regulator-3 {
+		compatible = "regulator-fixed";
+		regulator-name = "hdmi_pwr";
+		gpio = <&gpf 22 0>;
+		enable-active-high;
+
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc>;
+	};
+
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+
+		type = "c";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_connector_out>;
+			};
+		};
+	};
+};
+
+&pinctrl {
+	pins_it66121: it66121 {
+		pins = "PF12";
+		bias-pull-up;
+	};
+
+	pins_i2c0: i2c0 {
+		function = "i2c0";
+		groups = "i2c0-data";
+	};
+};
+
+&i2c0 {
+	status = "okay";
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_i2c0>;
+
+	clock-frequency = <100000>; /* 100 kHz */
+
+	hdmi@4c {
+		compatible = "ite,it66121";
+		reg = <0x4c>;
+
+		interrupt-parent = <&gpf>;
+		interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-names = "irq";
+
+		reset-gpios = <&gpe 6 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pins_it66121>;
+
+		vrf12-supply = <&hdmi_power>;
+		vcn33-supply = <&hdmi_power>;
+		vcn18-supply = <&hdmi_power>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				hdmi_input: endpoint {
+					bus-width = <24>;
+					remote-endpoint = <&hdmi_output>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+
+				hdmi_connector_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+		};
+	};
+};
+
+&lcd_port0 {
+	hdmi_output: endpoint@1 {
+		reg = <1>;
+		remote-endpoint = <&hdmi_input>;
+	};
+};
+
+&pins_lcd {
+	/* The LCD's interface is 8 bits, but we need the 24-bit interface for HDMI */
+	groups = "lcd-24bit";
+};
diff --git a/arch/mips/boot/dts/ingenic/rg280m-v1.1.dts b/arch/mips/boot/dts/ingenic/rg280m-v1.1.dts
new file mode 100644
index 00000000000..8338d4c93bb
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/rg280m-v1.1.dts
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "rg280v.dts"
+
+/ {
+	compatible = "ylm,rg280m-v1.1", "ingenic,jz4770";
+	model = "Anbernic RG-280M v1.1";
+};
+
+&joystick {
+	status = "okay";
+
+	io-channels = <&adc INGENIC_ADC_TOUCH_YP>,
+		      <&adc INGENIC_ADC_TOUCH_XP>;
+};
+
+&js_axis0 {
+	abs-range = <3000 200>;
+};
+
+&js_axis1 {
+	abs-range = <3000 200>;
+};
+
+&sound_card {
+	simple-audio-card,routing =
+		"Headphones Amp INL", "LHPOUT",
+		"Headphones Amp INR", "RHPOUT",
+		"Headphones", "Headphones Amp OUTL",
+		"Headphones", "Headphones Amp OUTR",
+		"Speaker Amp INL", "Headphones Amp OUTL",
+		"Speaker Amp INR", "Headphones Amp OUTR",
+		"Speaker", "Speaker Amp OUTL",
+		"Speaker", "Speaker Amp OUTR";
+};
+
+&gpio_keys {
+	btn17: button-17 {
+		label = "L3 joystick button";
+		linux,code = <KEY_KPSLASH>;
+		linux,can-disable;
+		gpios = <&gpb 14 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&uhc {
+	status = "okay";
+};
diff --git a/arch/mips/boot/dts/ingenic/rg280v.dts b/arch/mips/boot/dts/ingenic/rg280v.dts
new file mode 100644
index 00000000000..6d6d0b59da7
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/rg280v.dts
@@ -0,0 +1,119 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "bits/gcw0-base.dtsi"
+
+/ {
+	compatible = "ylm,rg280v", "ingenic,jz4770";
+	model = "Anbernic RG-280V";
+
+	rumble: rumble {
+		compatible = "pwm-vibrator";
+		pwms = <&pwm 4 2000000 0>;
+		pwm-names = "enable";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pins_pwm4>;
+	};
+};
+
+&joystick {
+	status = "disabled";
+};
+
+&btn8 {
+	gpios = <&gpb 10 GPIO_ACTIVE_LOW>;
+};
+
+&gpio_keys {
+	btn13: button-13 {
+		label = "L2 shoulder button";
+		linux,code = <KEY_PAGEUP>;
+		linux,can-disable;
+		gpios = <&gpb 20 GPIO_ACTIVE_LOW>;
+	};
+
+	btn14: button-14 {
+		label = "R2 shoulder button";
+		linux,code = <KEY_PAGEDOWN>;
+		linux,can-disable;
+		gpios = <&gpb 11 GPIO_ACTIVE_LOW>;
+	};
+
+	btn15: button-15 {
+		label = "Volume+ button";
+		linux,code = <KEY_VOLUMEUP>;
+		linux,can-disable;
+		gpios = <&gpb 12 GPIO_ACTIVE_LOW>;
+	};
+
+	btn16: button-16 {
+		label = "Volume- button";
+		linux,code = <KEY_VOLUMEDOWN>;
+		linux,can-disable;
+		gpios = <&gpb 13 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&sound_card {
+	simple-audio-card,widgets =
+		"Speaker", "Speaker",
+		"Headphone", "Headphones";
+	simple-audio-card,routing =
+		"Headphones Amp INL", "LHPOUT",
+		"Headphones Amp INR", "RHPOUT",
+		"Headphones", "Headphones Amp OUTL",
+		"Headphones", "Headphones Amp OUTR",
+		"Speaker Amp INL", "LOUT",
+		"Speaker Amp INR", "ROUT",
+		"Speaker", "Speaker Amp OUTL",
+		"Speaker", "Speaker Amp OUTR";
+	simple-audio-card,pin-switches = "Speaker";
+};
+
+&pinctrl {
+	pins_pwm4: pwm4 {
+		function = "pwm4";
+		groups = "pwm4";
+	};
+};
+
+&spi0_gpio {
+	status = "okay";
+
+	panel: panel@0 {
+		compatible = "abt,y030xx067a";
+		reg = <0>;
+
+		spi-max-frequency = <3125000>;
+		spi-3wire;
+
+		reset-gpios = <&gpe 2 GPIO_ACTIVE_LOW>;
+
+		backlight = <&backlight>;
+		power-supply = <&vcc>;
+
+		port {
+			panel_input: endpoint {
+				remote-endpoint = <&panel_output>;
+			};
+		};
+	};
+};
+
+&pins_lcd {
+	groups = "lcd-8bit";
+};
+
+&lcd_ports {
+	lcd_port0: port@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0>;
+
+		panel_output: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&panel_input>;
+		};
+	};
+};
diff --git a/arch/mips/boot/dts/ingenic/rg300.dts b/arch/mips/boot/dts/ingenic/rg300.dts
new file mode 100644
index 00000000000..c7fcfe8923a
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/rg300.dts
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+/* RG-300 is a RS-97 with a JZ4760B and a different panel */
+#include "rs97.dts"
+#include "jz4760b.dtsi"
+
+/ {
+	compatible = "ylm,rg300", "ingenic,jz4760b";
+	model = "RG-300";
+};
+
+&panel {
+	compatible = "abt,y030xx067a";
+};
diff --git a/arch/mips/boot/dts/ingenic/rg300x.dts b/arch/mips/boot/dts/ingenic/rg300x.dts
new file mode 100644
index 00000000000..e26c4caca39
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/rg300x.dts
@@ -0,0 +1,67 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "rg350m.dts"
+
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	compatible = "ylm,rg300x", "ingenic,jz4770";
+	model = "Anbernic RG-300X";
+};
+
+&panel {
+	compatible = "focaltech,gpt3";
+};
+
+&btn17 {
+	status = "disabled";
+};
+
+&btn18 {
+	status = "disabled";
+};
+
+&joystick {
+	status = "disabled";
+};
+
+&pinctrl {
+	pins_power_led: power-led {
+		pin = "PB30";
+		input-enable;
+		bias-pull-up;
+	};
+
+	gpios_i2c0: gpios-i2c0 {
+		pins = "PD30", "PD31";
+		bias-pull-up;
+	};
+};
+
+/*
+ * On the RG-300X, the LEDs are way too powerful. Work around this by setting
+ * the GPIO as input with the pull-up resitor enabled, which causes the voltage
+ * to be low enough that the LEDs are just slightly lit.
+ */
+&power_led {
+	status = "disabled";
+};
+
+&leds {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_power_led>;
+};
+
+/*
+ * For some reason, the IT66121 present in the RG-300X handheld does not appear
+ * if the I2C bus is handled by the i2c-jz4780 driver. Until this issue is
+ * resolved, bitbang the bus with the i2c-gpio driver.
+ */
+&i2c0 {
+	compatible = "i2c-gpio";
+	sda-gpios = <&gpd 30 GPIO_ACTIVE_HIGH>;
+	scl-gpios = <&gpd 31 GPIO_ACTIVE_HIGH>;
+
+	pinctrl-0 = <&gpios_i2c0>;
+};
diff --git a/arch/mips/boot/dts/ingenic/rg350.dts b/arch/mips/boot/dts/ingenic/rg350.dts
new file mode 100644
index 00000000000..4e618960fe1
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/rg350.dts
@@ -0,0 +1,41 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "rg350m.dts"
+
+/ {
+	compatible = "ylm,rg350", "ingenic,jz4770";
+	model = "Anbernic RG-350";
+
+	panel {
+		compatible = "frida,frd350h54004";
+
+		reset-gpios = <&gpe 2 GPIO_ACTIVE_LOW>;
+
+		backlight = <&backlight>;
+		power-supply = <&vcc>;
+
+		port {
+			frida_input: endpoint {
+				remote-endpoint = <&panel_output>;
+			};
+		};
+	};
+};
+
+&panel {
+	status = "disabled";
+};
+
+&spi0_gpio {
+	status = "disabled";
+};
+
+/* Make ABT panel port a dummy to avoid DTC complaints */
+&panel_input {
+	remote-endpoint = <&panel_input>;
+};
+
+&panel_output {
+	remote-endpoint = <&frida_input>;
+};
diff --git a/arch/mips/boot/dts/ingenic/rg350m.dts b/arch/mips/boot/dts/ingenic/rg350m.dts
new file mode 100644
index 00000000000..9ec5df054d4
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/rg350m.dts
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "rg280m-v1.0.dts"
+
+/ {
+	compatible = "ylm,rg350m", "ingenic,jz4770";
+	model = "Anbernic RG-350M";
+};
+
+&panel {
+	compatible = "leadtek,ltk035c5444t";
+};
+
+&gpio_keys {
+	btn18: button-18 {
+		label = "R3 joystick button";
+		linux,code = <KEY_KPDOT>;
+		linux,can-disable;
+		gpios = <&gpb 15 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&joystick {
+	io-channels = <&adc INGENIC_ADC_TOUCH_YP>,
+		      <&adc INGENIC_ADC_TOUCH_XP>,
+		      <&adc INGENIC_ADC_TOUCH_YN>,
+		      <&adc INGENIC_ADC_TOUCH_XN>;
+
+	js_axis2: axis@2 {
+		reg = <2>;
+		linux,code = <ABS_RX>;
+		abs-range = <200 3000>;
+		abs-fuzz = <4>;
+		abs-flat = <200>;
+	};
+
+	js_axis3: axis@3 {
+		reg = <3>;
+		linux,code = <ABS_RY>;
+		abs-range = <200 3000>;
+		abs-fuzz = <4>;
+		abs-flat = <200>;
+	};
+};
diff --git a/arch/mips/boot/dts/ingenic/rg99.dts b/arch/mips/boot/dts/ingenic/rg99.dts
new file mode 100644
index 00000000000..d99ae48b0e1
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/rg99.dts
@@ -0,0 +1,202 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "bits/rs90-base.dtsi"
+
+/ {
+	compatible = "ylm,rg99", "ingenic,jz4725b";
+	model = "RG-99";
+
+	spi {
+		compatible = "spi-gpio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sck-gpios = <&gpd 23 GPIO_ACTIVE_HIGH>;
+		mosi-gpios = <&gpd 22 GPIO_ACTIVE_HIGH>;
+		cs-gpios = <&gpd 10 GPIO_ACTIVE_HIGH>;
+		num-chipselects = <1>;
+
+		panel@0 {
+			compatible = "abt,y030xx067a";
+			reg = <0>;
+
+			spi-max-frequency = <10000000>;
+			spi-3wire;
+
+			reset-gpios = <&gpd 25 GPIO_ACTIVE_LOW>;
+
+			backlight = <&backlight>;
+			power-supply = <&vcc>;
+
+			port {
+				panel_input: endpoint {
+					remote-endpoint = <&panel_output>;
+				};
+			};
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		button-0 {
+			label = "D-pad up";
+			linux,code = <KEY_UP>;
+			gpios = <&gpd 8 GPIO_ACTIVE_LOW>;
+		};
+
+		button-1 {
+			label = "D-pad down";
+			linux,code = <KEY_DOWN>;
+			gpios = <&gpd 9 GPIO_ACTIVE_LOW>;
+		};
+
+		button-2 {
+			label = "D-pad left";
+			linux,code = <KEY_LEFT>;
+			gpios = <&gpd 11 GPIO_ACTIVE_LOW>;
+		};
+
+		button-3 {
+			label = "D-pad right";
+			linux,code = <KEY_RIGHT>;
+			gpios = <&gpc 20 GPIO_ACTIVE_LOW>;
+		};
+
+		button-4 {
+			label = "Button A";
+			linux,code = <KEY_LEFTCTRL>;
+			gpios = <&gpd 24 GPIO_ACTIVE_LOW>;
+		};
+
+		button-5 {
+			label = "Button B";
+			linux,code = <KEY_LEFTALT>;
+			gpios = <&gpd 16 GPIO_ACTIVE_LOW>;
+		};
+
+		button-6 {
+			label = "Right shoulder button";
+			linux,code = <KEY_BACKSPACE>;
+			gpios = <&gpd 13 GPIO_ACTIVE_LOW>;
+			debounce-interval = <10>;
+		};
+
+		button-7 {
+			label = "Start button";
+			linux,code = <KEY_ENTER>;
+			gpios = <&gpc 31 GPIO_ACTIVE_LOW>;
+		};
+
+		button-8 {
+			label = "Left shoulder button";
+			linux,code = <KEY_TAB>;
+			gpios = <&gpd 14 GPIO_ACTIVE_LOW>;
+			debounce-interval = <10>;
+		};
+
+		button-9 {
+			label = "Button X";
+			linux,code = <KEY_SPACE>;
+			gpios = <&gpd 17 GPIO_ACTIVE_LOW>;
+		};
+
+		button-10 {
+			label = "Button Y";
+			linux,code = <KEY_LEFTSHIFT>;
+			gpios = <&gpd 15 GPIO_ACTIVE_LOW>;
+		};
+
+		button-11 {
+			label = "Select button";
+			linux,code = <KEY_ESC>;
+			gpios = <&gpc 30 GPIO_ACTIVE_LOW>;
+		};
+
+		button-12 {
+			label = "Menu1 button";
+			linux,code = <KEY_PAGEUP>;
+			gpios = <&gpd 12 GPIO_ACTIVE_LOW>;
+			debounce-interval = <10>;
+		};
+
+		button-13 {
+			label = "Menu2 button";
+			linux,code = <KEY_PAGEDOWN>;
+			gpios = <&gpb 31 GPIO_ACTIVE_LOW>;
+			debounce-interval = <10>;
+		};
+	};
+
+	usb_conn: connector {
+		compatible = "gpio-usb-b-connector", "usb-b-connector";
+		label = "mini-USB";
+		type = "mini";
+
+		vbus-gpios = <&gpc 10 GPIO_ACTIVE_HIGH>;
+		vbus-supply = <&vcc>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pins_vbus>;
+
+		port {
+			usb_conn_ep: endpoint {
+				remote-endpoint = <&usb_ep>;
+			};
+		};
+	};
+};
+
+&udc {
+	port {
+		usb_ep: endpoint {
+			remote-endpoint = <&usb_conn_ep>;
+		};
+	};
+};
+
+&sound_card {
+	/* TODO: What's the headphones detection GPIO? */
+	simple-audio-card,hp-det-gpio;
+};
+
+&pmu {
+	power-supplies = <&usb_conn>;
+};
+
+&pinctrl {
+	pins_vbus: vbus {
+		pins = "PC10";
+		bias-disable;
+	};
+};
+
+&pins_lcd {
+	groups = "lcd-8bit";
+};
+
+&pins_mmc1_cd {
+	pins = "PD21";
+};
+
+&mmc1 {
+	cd-gpios = <&gpd 21 GPIO_ACTIVE_LOW>;
+};
+
+&vmem {
+	/* Reserve 2 MiB of VRAM */
+	reg = <0x1e00000 0x200000>;
+};
+
+&battery {
+	voltage-min-design-microvolt = <3900000>;
+	voltage-max-design-microvolt = <4200000>;
+};
+
+&resistor {
+	output-ohms = <28000>;
+	full-ohms = <100000>;
+};
diff --git a/arch/mips/boot/dts/ingenic/rs07.dts b/arch/mips/boot/dts/ingenic/rs07.dts
new file mode 100644
index 00000000000..011f6eadbf4
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/rs07.dts
@@ -0,0 +1,104 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "rs97.dts"
+#include "jz4760b.dtsi"
+
+/ {
+	compatible = "ylm,rs07", "ingenic,jz4760b";
+	model = "RS07";
+
+	lcd-panel-1 {
+		compatible = "qishenglong,gopher2b-lcd";
+
+		power-supply = <&vcc>;
+		backlight = <&backlight>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pins_lcd>;
+
+		port {
+			lcd_panel_input: endpoint {
+				remote-endpoint = <&panel_output>;
+			};
+		};
+	};
+};
+
+&gpio_keys {
+	button-4 {
+		label = "Button A";
+		linux,code = <KEY_LEFTCTRL>;
+		linux,can-disable;
+		gpios = <&gpd 23 GPIO_ACTIVE_LOW>;
+	};
+
+	button-5 {
+		label = "Button B";
+		linux,code = <KEY_LEFTALT>;
+		linux,can-disable;
+		gpios = <&gpb 16 GPIO_ACTIVE_LOW>;
+	};
+
+	button-6 {
+		label = "Button Y";
+		linux,code = <KEY_SPACE>;
+		linux,can-disable;
+		gpios = <&gpd 22 GPIO_ACTIVE_LOW>;
+	};
+
+	button-7 {
+		label = "Button X";
+		linux,code = <KEY_LEFTSHIFT>;
+		linux,can-disable;
+		gpios = <&gpb 15 GPIO_ACTIVE_LOW>;
+	};
+
+	button-12 {
+		status = "disabled";
+	};
+
+	button-13 {
+		status = "disabled";
+	};
+};
+
+&usb_conn {
+	compatible = "gpio-usb-a-connector", "usb-a-connector";
+	label = "USB-A";
+
+	vbus-gpio = <&gpe 13 GPIO_ACTIVE_HIGH>;
+	vbus-supply = <&vcc>;
+};
+
+&pinctrl {
+	otg {
+		vbus-pin {
+			pins = "PE13";
+		};
+	};
+};
+
+&spi {
+	status = "disabled";
+};
+
+&panel {
+	status = "disabled";
+};
+
+&pins_lcd {
+	groups = "lcd-8bit", "lcd-16bit", "lcd-18bit", "lcd-24bit", "lcd-generic";
+};
+
+&panel_output {
+	remote-endpoint = <&lcd_panel_input>;
+};
+
+&panel_input {
+	remote-endpoint = <&panel_input>;
+};
+
+&usb_otg {
+	dr_mode = "host";
+};
diff --git a/arch/mips/boot/dts/ingenic/rs90.dts b/arch/mips/boot/dts/ingenic/rs90.dts
index e8df70dd42b..9aea3a632a1 100644
--- a/arch/mips/boot/dts/ingenic/rs90.dts
+++ b/arch/mips/boot/dts/ingenic/rs90.dts
@@ -1,55 +1,12 @@
 // SPDX-License-Identifier: GPL-2.0
 /dts-v1/;
 
-#include "jz4725b.dtsi"
-
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/iio/adc/ingenic,adc.h>
-#include <dt-bindings/input/linux-event-codes.h>
+#include "bits/rs90-base.dtsi"
 
 / {
 	compatible = "ylm,rs90", "ingenic,jz4725b";
 	model = "RS-90";
 
-	memory {
-		device_type = "memory";
-		reg = <0x0 0x2000000>;
-	};
-
-	reserved-memory {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		ranges;
-
-		vmem: video-memory@1f00000 {
-			compatible = "shared-dma-pool";
-			reg = <0x1f00000 0x100000>;
-			reusable;
-		};
-	};
-
-	vcc: regulator {
-		compatible = "regulator-fixed";
-
-		regulator-name = "vcc";
-		regulaor-min-microvolt = <3300000>;
-		regulaor-max-microvolt = <3300000>;
-		regulator-always-on;
-	};
-
-	backlight: backlight {
-		compatible = "pwm-backlight";
-		pwms = <&pwm 3 40000 0>;
-
-		brightness-levels = <0 16 32 48 64 80 112 144 192 255>;
-		default-brightness-level = <8>;
-
-		pinctrl-names = "default";
-		pinctrl-0 = <&pins_pwm3>;
-
-		power-supply = <&vcc>;
-	};
-
 	keys@0 {
 		compatible = "gpio-keys";
 
@@ -123,56 +80,6 @@ key@1 {
 		};
 	};
 
-	amp: analog-amplifier {
-		compatible = "simple-audio-amplifier";
-		enable-gpios = <&gpc 15 GPIO_ACTIVE_HIGH>;
-
-		VCC-supply = <&vcc>;
-	};
-
-	sound {
-		compatible = "simple-audio-card";
-
-		simple-audio-card,name = "rs90-audio";
-		simple-audio-card,format = "i2s";
-
-		simple-audio-card,widgets =
-			"Speaker", "Speaker",
-			"Headphone", "Headphones";
-		simple-audio-card,routing =
-			"INL", "LHPOUT",
-			"INR", "RHPOUT",
-			"Headphones", "LHPOUT",
-			"Headphones", "RHPOUT",
-			"Speaker", "OUTL",
-			"Speaker", "OUTR";
-		simple-audio-card,pin-switches = "Speaker";
-
-		simple-audio-card,hp-det-gpio = <&gpd 16 GPIO_ACTIVE_LOW>;
-		simple-audio-card,aux-devs = <&amp>;
-
-		simple-audio-card,bitclock-master = <&dai_codec>;
-		simple-audio-card,frame-master = <&dai_codec>;
-
-		dai_cpu: simple-audio-card,cpu {
-			sound-dai = <&aic>;
-		};
-
-		dai_codec: simple-audio-card,codec {
-			sound-dai = <&codec>;
-		};
-
-	};
-
-	usb_phy: usb-phy {
-		compatible = "usb-nop-xceiv";
-		#phy-cells = <0>;
-
-		clocks = <&cgu JZ4725B_CLK_UDC_PHY>;
-		clock-names = "main_clk";
-		vcc-supply = <&vcc>;
-	};
-
 	panel {
 		compatible = "sharp,ls020b1dd01d";
 
@@ -187,141 +94,14 @@ panel_input: endpoint {
 	};
 };
 
-&ext {
-	clock-frequency = <12000000>;
-};
-
-&rtc_dev {
-	system-power-controller;
+&pins_lcd {
+	groups = "lcd-8bit", "lcd-16bit", "lcd-special";
 };
 
-&udc {
-	phys = <&usb_phy>;
-};
-
-&pinctrl {
-	pins_mmc1: mmc1 {
-		function = "mmc1";
-		groups = "mmc1-1bit";
-	};
-
-	pins_nemc: nemc {
-		function = "nand";
-		groups = "nand-cs1", "nand-cle-ale", "nand-fre-fwe";
-	};
-
-	pins_pwm3: pwm3 {
-		function = "pwm3";
-		groups = "pwm3";
-		bias-disable;
-	};
-
-	pins_lcd: lcd {
-		function = "lcd";
-		groups = "lcd-8bit", "lcd-16bit", "lcd-special";
-	};
-};
-
-&mmc0 {
-	status = "disabled";
+&pins_mmc1_cd {
+	pins = "PC20";
 };
 
 &mmc1 {
-	bus-width = <1>;
-	max-frequency = <48000000>;
-
-	pinctrl-names = "default";
-	pinctrl-0 = <&pins_mmc1>;
-
 	cd-gpios = <&gpc 20 GPIO_ACTIVE_LOW>;
 };
-
-&uart {
-	/*
-	 * The pins for RX/TX are used for the right shoulder button and
-	 * backlight PWM.
-	 */
-	status = "disabled";
-};
-
-&nemc {
-	nandc: nand-controller@1 {
-		compatible = "ingenic,jz4725b-nand";
-		reg = <1 0 0x4000000>;
-
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		ecc-engine = <&bch>;
-
-		ingenic,nemc-tAS = <10>;
-		ingenic,nemc-tAH = <5>;
-		ingenic,nemc-tBP = <10>;
-		ingenic,nemc-tAW = <15>;
-		ingenic,nemc-tSTRV = <100>;
-
-		pinctrl-names = "default";
-		pinctrl-0 = <&pins_nemc>;
-
-		rb-gpios = <&gpc 27 GPIO_ACTIVE_HIGH>;
-
-		nand@1 {
-			reg = <1>;
-
-			nand-ecc-step-size = <512>;
-			nand-ecc-strength = <8>;
-			nand-ecc-mode = "hw";
-			nand-is-boot-medium;
-			nand-on-flash-bbt;
-
-			partitions {
-				compatible = "fixed-partitions";
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "bootloader";
-					reg = <0x0 0x20000>;
-				};
-
-				partition@20000 {
-					label = "system";
-					reg = <0x20000 0x0>;
-				};
-			};
-		};
-	};
-};
-
-&cgu {
-	/* Use 32kHz oscillator as the parent of the RTC clock */
-	assigned-clocks = <&cgu JZ4725B_CLK_RTC>;
-	assigned-clock-parents = <&cgu JZ4725B_CLK_OSC32K>;
-};
-
-&tcu {
-	/*
-	 * 750 kHz for the system timer and clocksource, and use RTC as the
-	 * parent for the watchdog clock.
-	 */
-	assigned-clocks = <&tcu TCU_CLK_TIMER0>, <&tcu TCU_CLK_TIMER1>, <&tcu TCU_CLK_WDT>;
-	assigned-clock-parents = <0>, <0>, <&cgu JZ4725B_CLK_RTC>;
-	assigned-clock-rates = <750000>, <750000>;
-};
-
-&lcd {
-	memory-region = <&vmem>;
-
-	pinctrl-names = "default";
-	pinctrl-0 = <&pins_lcd>;
-};
-
-&lcd_ports {
-	port@0 {
-		reg = <0>;
-
-		panel_output: endpoint {
-			remote-endpoint = <&panel_input>;
-		};
-	};
-};
diff --git a/arch/mips/boot/dts/ingenic/rs97.dts b/arch/mips/boot/dts/ingenic/rs97.dts
new file mode 100644
index 00000000000..6f9ebe5f526
--- /dev/null
+++ b/arch/mips/boot/dts/ingenic/rs97.dts
@@ -0,0 +1,513 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+
+#include "jz4760.dtsi"
+#include <dt-bindings/clock/ingenic,tcu.h>
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/iio/adc/ingenic,adc.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	compatible = "ylm,rs97", "ingenic,jz4760";
+	model = "RS-97";
+
+	aliases {
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+	};
+
+	memory: memory {
+		device_type = "memory";
+		reg = <0x0 0x8000000>;
+	};
+
+	chosen {
+		stdout-path = "serial1:57600n8";
+	};
+
+	vcc: regulator-0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc";
+
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+
+	lcd_power: regulator-1 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc";
+		gpio = <&gpc 9 0>;
+		enable-active-high;
+
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	mmc2_power: regulator-2 {
+		compatible = "regulator-fixed";
+		regulator-name = "mmc2_vcc";
+		gpio = <&gpf 3 0>;
+
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc>;
+	};
+
+	audio_amp: analog-amplifier {
+		compatible = "simple-audio-amplifier";
+		enable-gpios = <&gpe 9 0>;
+		enable-delay-ms = <50>;
+
+		VCC-supply = <&vcc>;
+	};
+
+	sound_card: sound {
+		compatible = "simple-audio-card";
+
+		simple-audio-card,name = "lepus-audio";
+		simple-audio-card,format = "i2s";
+
+		simple-audio-card,widgets =
+			"Speaker", "Speaker",
+			"Headphone", "Headphones";
+		simple-audio-card,routing =
+			"Headphones", "LHPOUT",
+			"Headphones", "RHPOUT",
+			"INL", "LHPOUT",
+			"INR", "RHPOUT",
+			"Speaker", "OUTL",
+			"Speaker", "OUTR";
+		simple-audio-card,pin-switches = "Speaker";
+
+		simple-audio-card,hp-det-gpio = <&gpd 6 GPIO_ACTIVE_LOW>;
+		simple-audio-card,aux-devs = <&audio_amp>;
+
+		simple-audio-card,bitclock-master = <&dai_codec>;
+		simple-audio-card,frame-master = <&dai_codec>;
+
+		dai_cpu: simple-audio-card,cpu {
+			sound-dai = <&aic>;
+		};
+
+		dai_codec: simple-audio-card,codec {
+			sound-dai = <&codec>;
+		};
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm 1 40000 0>;
+		power-supply = <&vcc>;
+
+		brightness-levels = <0 16 32 48 64 80 96 112 128
+				     144 160 176 192 208 224 240 255>;
+		default-brightness-level = <12>;
+
+		pinctrl-names = "init", "sleep", "default";
+		pinctrl-0 = <&pins_pwm1_sleep>;
+		pinctrl-1 = <&pins_pwm1_sleep>;
+		pinctrl-2 = <&pins_pwm1>;
+	};
+
+	gpio_keys: gpio-keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		autorepeat;
+
+		btn_up: button-0 {
+			label = "D-pad up";
+			linux,code = <KEY_UP>;
+			linux,can-disable;
+			gpios = <&gpb 25 GPIO_ACTIVE_LOW>;
+		};
+
+		btn_down: button-1 {
+			label = "D-pad down";
+			linux,code = <KEY_DOWN>;
+			linux,can-disable;
+			gpios = <&gpb 24 GPIO_ACTIVE_LOW>;
+		};
+
+		btn_left: button-2 {
+			label = "D-pad left";
+			linux,code = <KEY_LEFT>;
+			linux,can-disable;
+			gpios = <&gpd 0 GPIO_ACTIVE_LOW>;
+		};
+
+		btn_right: button-3 {
+			label = "D-pad right";
+			linux,code = <KEY_RIGHT>;
+			linux,can-disable;
+			gpios = <&gpb 26 GPIO_ACTIVE_LOW>;
+		};
+
+		btn_a: button-4 {
+			label = "Button A";
+			linux,code = <KEY_LEFTCTRL>;
+			linux,can-disable;
+			gpios = <&gpd 22 GPIO_ACTIVE_LOW>;
+		};
+
+		btn_b: button-5 {
+			label = "Button B";
+			linux,code = <KEY_LEFTALT>;
+			linux,can-disable;
+			gpios = <&gpd 23 GPIO_ACTIVE_LOW>;
+		};
+
+		btn_y: button-6 {
+			label = "Button Y";
+			linux,code = <KEY_LEFTSHIFT>;
+			linux,can-disable;
+			gpios = <&gpe 11 GPIO_ACTIVE_LOW>;
+		};
+
+		btn_x: button-7 {
+			label = "Button X";
+			linux,code = <KEY_SPACE>;
+			linux,can-disable;
+			gpios = <&gpe 7 GPIO_ACTIVE_LOW>;
+		};
+
+		btn_ltrig: button-8 {
+			label = "Left shoulder button";
+			linux,code = <KEY_TAB>;
+			linux,can-disable;
+			gpios = <&gpb 23 GPIO_ACTIVE_LOW>;
+		};
+
+		btn_rtrig: button-9 {
+			label = "Right shoulder button";
+			linux,code = <KEY_BACKSPACE>;
+			linux,can-disable;
+			gpios = <&gpd 24 GPIO_ACTIVE_LOW>;
+		};
+
+		button-10 {
+			label = "Start button";
+			linux,code = <KEY_ENTER>;
+			linux,can-disable;
+			gpios = <&gpd 18 GPIO_ACTIVE_HIGH>;
+		};
+
+		button-11 {
+			label = "Select button";
+			linux,code = <KEY_ESC>;
+			linux,can-disable;
+			gpios = <&gpd 17 GPIO_ACTIVE_HIGH>;
+		};
+
+		btn_power: button-12 {
+			label = "Power button";
+			linux,code = <KEY_POWER>;
+			linux,can-disable;
+			gpios = <&gpa 30 GPIO_ACTIVE_LOW>;
+			wakeup-source;
+		};
+
+		btn_star: button-13 {
+			label = "Star button";
+			linux,code = <KEY_HOME>;
+			linux,can-disable;
+			gpios = <&gpd 21 GPIO_ACTIVE_LOW>;
+			wakeup-source;
+		};
+	};
+
+	spi: spi {
+		compatible = "spi-gpio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sck-gpios = <&gpd 11 GPIO_ACTIVE_HIGH>;
+		mosi-gpios = <&gpe 2 GPIO_ACTIVE_HIGH>;
+		cs-gpios = <&gpe 0 GPIO_ACTIVE_LOW>;
+		num-chipselects = <1>;
+
+		panel: lcd-panel@0 {
+			compatible = "auo,a030jtn01";
+			reg = <0>;
+
+			spi-max-frequency = <10000000>;
+			spi-cpol;
+			spi-cpha;
+			spi-3wire;
+
+			reset-gpios = <&gpe 4 GPIO_ACTIVE_LOW>;
+			power-supply = <&lcd_power>;
+
+			backlight = <&backlight>;
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&pins_lcd>;
+
+			port {
+				panel_input: endpoint {
+					remote-endpoint = <&panel_output>;
+				};
+			};
+		};
+	};
+
+	usb_conn: connector {
+		compatible = "gpio-usb-b-connector", "usb-b-connector";
+		label = "mini-USB";
+		type = "mini";
+
+		vbus-gpios = <&gpd 7 GPIO_ACTIVE_HIGH>;
+		//id-gpios = <&gpa 11 GPIO_ACTIVE_HIGH>;
+		//vbus-supply = <&otg_vbus>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pins_otg>;
+
+		port {
+			usb_ep: endpoint {
+				remote-endpoint = <&usb_otg_ep>;
+			};
+		};
+	};
+
+	battery: battery {
+		compatible = "simple-battery";
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4200000>;
+	};
+
+	vdiv: voltage-divider {
+		compatible = "voltage-divider";
+		#io-channel-cells = <0>;
+
+		output-ohms = <332000>;
+		full-ohms = <1332000>;
+
+		io-channels = <&adc INGENIC_ADC_BATTERY>;
+	};
+
+	pmu: pmu {
+		compatible = "ingenic,jz4760-battery", "ingenic,jz4740-battery";
+		io-channels = <&vdiv>;
+		io-channel-names = "battery";
+		monitored-battery = <&battery>;
+
+		power-supplies = <&usb_conn>;
+	};
+
+	cpu_opp_table: opp-table {
+		compatible = "operating-points-v2";
+
+		opp-480000000 { opp-hz = /bits/ 64 <480000000>; };
+		opp-528000000 { opp-hz = /bits/ 64 <528000000>; };
+		opp-576000000 { opp-hz = /bits/ 64 <576000000>; };
+		opp-624000000 { opp-hz = /bits/ 64 <624000000>; };
+		opp-672000000 { opp-hz = /bits/ 64 <672000000>; };
+		opp-720000000 { opp-hz = /bits/ 64 <720000000>; };
+		opp-768000000 { opp-hz = /bits/ 64 <768000000>; };
+		opp-816000000 { opp-hz = /bits/ 64 <816000000>; };
+		opp-864000000 { opp-hz = /bits/ 64 <864000000>; };
+		opp-912000000 { opp-hz = /bits/ 64 <912000000>; };
+		opp-960000000 { opp-hz = /bits/ 64 <960000000>; };
+		opp-1008000000 { opp-hz = /bits/ 64 <1008000000>; };
+		opp-1056000000 { opp-hz = /bits/ 64 <1056000000>; };
+		opp-1104000000 { opp-hz = /bits/ 64 <1104000000>; };
+		opp-1152000000 { opp-hz = /bits/ 64 <1152000000>; };
+		opp-1200000000 { opp-hz = /bits/ 64 <1200000000>; };
+		opp-1248000000 { opp-hz = /bits/ 64 <1248000000>; };
+		opp-1296000000 { opp-hz = /bits/ 64 <1296000000>; };
+		opp-1344000000 { opp-hz = /bits/ 64 <1344000000>; };
+		opp-1392000000 { opp-hz = /bits/ 64 <1392000000>; };
+		opp-1440000000 { opp-hz = /bits/ 64 <1440000000>; };
+		opp-1488000000 { opp-hz = /bits/ 64 <1488000000>; };
+		opp-1536000000 { opp-hz = /bits/ 64 <1536000000>; };
+		opp-1584000000 { opp-hz = /bits/ 64 <1584000000>; };
+	};
+};
+
+&cpu0 {
+	operating-points-v2 = <&cpu_opp_table>;
+
+	/* We use the main PLL as the CPU clock for the cpufreq driver. */
+	clocks = <&cgu JZ4760_CLK_PLL0>;
+};
+
+&ext {
+	clock-frequency = <12000000>;
+};
+
+&pinctrl {
+	pins_lcd: lcd {
+		function = "lcd";
+		groups = "lcd-8bit";
+	};
+
+	pins_uart1: uart1 {
+		function = "uart1";
+		groups = "uart1-data";
+	};
+
+	pins_mmc0: mmc0 {
+		function = "mmc0";
+		groups = "mmc0-1bit-a", "mmc0-4bit-a";
+	};
+
+	pins_mmc2: mmc2 {
+		function = "mmc2";
+		groups = "mmc2-1bit-e", "mmc2-4bit-e";
+	};
+
+	pwm1 {
+		pins_pwm1_sleep: pwm1-sleep {
+			pins = "PE1";
+			output-low;
+		};
+
+		pins_pwm1: pwm1-default {
+			function = "pwm1";
+			groups = "pwm1";
+		};
+	};
+
+	pins_otg: otg {
+		otg-vbus-pin {
+			function = "otg";
+			groups = "otg-vbus";
+		};
+
+		vbus_pin: vbus-pin {
+			pins = "PD7";
+			bias-disable;
+		};
+	};
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_uart1>;
+
+	status = "okay";
+};
+
+&cgu {
+	/*
+	 * Put high-speed peripherals under PLL1, such that we can change the
+	 * PLL0 frequency on demand without having to suspend peripherals.
+	 * We use a rate of 432 MHz, which is the least common multiple of
+	 * 27 MHz (required by TV encoder) and 48 MHz (required by USB host).
+	 * Use the 32 kHz oscillator as the parent of the RTC for a higher
+	 * precision.
+	 */
+	assigned-clocks =
+		<&cgu JZ4760_CLK_PLL1>,
+		<&cgu JZ4760_CLK_PLL0_HALF>,
+		<&cgu JZ4760_CLK_MMC_MUX>,
+		<&cgu JZ4760_CLK_RTC>,
+		<&cgu JZ4760_CLK_UHC>,
+		<&cgu JZ4760_CLK_LPCLK_DIV>;
+	assigned-clock-parents =
+		<0>,
+		<0>,
+		<&cgu JZ4760_CLK_PLL0_HALF>,
+		<&cgu JZ4760_CLK_OSC32K>,
+		<&cgu JZ4760_CLK_PLL1>,
+		<&cgu JZ4760_CLK_PLL1>;
+	assigned-clock-rates =
+		<432000000>, <600000000>, <50000000>;
+};
+
+&tcu {
+	/*
+	 * 750 kHz for the system timer and clocksource, 12 MHz for the OST,
+	 * and use RTC as the parent for the watchdog clock
+	 */
+	assigned-clocks = <&tcu TCU_CLK_TIMER0>, <&tcu TCU_CLK_TIMER2>,
+			  <&tcu TCU_CLK_OST>, <&tcu TCU_CLK_WDT>;
+	assigned-clock-parents = <0>, <0>, <0>, <&cgu JZ4760_CLK_RTC>;
+	assigned-clock-rates = <750000>, <750000>, <12000000>;
+
+	/* PWM1 is in use, so use channel #2 for the clocksource */
+	ingenic,pwm-channels-mask = <0xfa>;
+};
+
+&usb_otg {
+	port {
+		usb_otg_ep: endpoint {
+			remote-endpoint = <&usb_ep>;
+		};
+	};
+};
+
+&otg_phy {
+	vcc-supply = <&vcc>;
+};
+
+&rtc {
+	clocks = <&cgu JZ4760_CLK_RTC>;
+	clock-names = "rtc";
+
+	system-power-controller;
+
+	ingenic,reset-pin-assert-time-ms = <125>;
+	ingenic,min-wakeup-pin-assert-time-ms = <500>;
+};
+
+&mmc0 {
+	status = "okay";
+
+	bus-width = <4>;
+	max-frequency = <50000000>;
+	vmmc-supply = <&vcc>;
+	non-removable;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mmc0>;
+};
+
+&mmc2 {
+	status = "okay";
+
+	bus-width = <4>;
+	max-frequency = <50000000>;
+	cd-gpios = <&gpf 0 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&mmc2_power>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mmc2>;
+};
+
+&lcd {
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+
+			panel_output: endpoint {
+				remote-endpoint = <&panel_input>;
+			};
+		};
+
+		port@8 {
+			reg = <8>;
+
+			ipu_output: endpoint {
+				remote-endpoint = <&ipu_input>;
+			};
+		};
+	};
+};
+
+&ipu {
+	port {
+		ipu_input: endpoint {
+			remote-endpoint = <&ipu_output>;
+		};
+	};
+};
diff --git a/arch/mips/generic/Platform b/arch/mips/generic/Platform
index 0c03623f389..7ec2828680a 100644
--- a/arch/mips/generic/Platform
+++ b/arch/mips/generic/Platform
@@ -12,7 +12,7 @@
 cflags-$(CONFIG_MACH_INGENIC_SOC)	+= -I$(srctree)/arch/mips/include/asm/mach-ingenic
 cflags-$(CONFIG_MIPS_GENERIC)	+= -I$(srctree)/arch/mips/include/asm/mach-generic
 
-load-$(CONFIG_MIPS_GENERIC)	+= 0xffffffff80100000
+load-$(CONFIG_MIPS_GENERIC)	+= $(if $(CONFIG_LD_IS_LLD),0x80100000,0xffffffff80100000)
 all-$(CONFIG_MIPS_GENERIC)	+= vmlinux.gz.itb
 
 its-y					:= vmlinux.its.S
diff --git a/arch/mips/ingenic/Kconfig b/arch/mips/ingenic/Kconfig
index f595b339a4b..440e05f2915 100644
--- a/arch/mips/ingenic/Kconfig
+++ b/arch/mips/ingenic/Kconfig
@@ -5,6 +5,7 @@ config MACH_INGENIC_GENERIC
 	select MACH_INGENIC
 	select MACH_JZ4740
 	select MACH_JZ4725B
+	select MACH_JZ4760
 	select MACH_JZ4770
 	select MACH_JZ4780
 	select MACH_X1000
@@ -27,6 +28,10 @@ config JZ4740_RS90
 	bool "YLM RetroMini (RS-90)"
 	select MACH_JZ4725B
 
+config JZ4760_RS97
+	bool "YLM RS-97"
+	select MACH_JZ4760
+
 config JZ4770_GCW0
 	bool "Game Consoles Worldwide GCW Zero"
 	select MACH_JZ4770
@@ -53,6 +58,10 @@ config MACH_JZ4740
 	bool
 	select SYS_HAS_CPU_MIPS32_R1
 
+config MACH_JZ4760
+	bool
+	select SYS_HAS_CPU_MIPS32_R1
+
 config MACH_JZ4770
 	bool
 	select MIPS_CPU_SCACHE
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 473563bc749..a34f509dac3 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2708,6 +2708,15 @@ struct clk *clk_get_parent(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_get_parent);
 
+struct clk *clk_get_first_to_set_rate(struct clk *clk)
+{
+	while (clk && (clk->core->flags & CLK_SET_RATE_PARENT))
+		clk = clk_get_parent(clk);
+
+	return clk;
+}
+EXPORT_SYMBOL_GPL(clk_get_first_to_set_rate);
+
 static struct clk_core *__clk_init_parent(struct clk_core *core)
 {
 	u8 index = 0;
diff --git a/drivers/gpu/drm/ingenic/Kconfig b/drivers/gpu/drm/ingenic/Kconfig
index b440e0cdc05..9655ee6bcc4 100644
--- a/drivers/gpu/drm/ingenic/Kconfig
+++ b/drivers/gpu/drm/ingenic/Kconfig
@@ -20,7 +20,7 @@ config DRM_INGENIC
 if DRM_INGENIC
 
 config DRM_INGENIC_IPU
-	bool "IPU support for Ingenic SoCs"
+	tristate "IPU support for Ingenic SoCs"
 	help
 	  Choose this option to enable support for the IPU found in Ingenic SoCs.
 
diff --git a/drivers/gpu/drm/ingenic/Makefile b/drivers/gpu/drm/ingenic/Makefile
index f10cc1c5a5f..e650d4ec895 100644
--- a/drivers/gpu/drm/ingenic/Makefile
+++ b/drivers/gpu/drm/ingenic/Makefile
@@ -1,4 +1,4 @@
 obj-$(CONFIG_DRM_INGENIC) += ingenic-drm.o
 ingenic-drm-y = ingenic-drm-drv.o
-ingenic-drm-$(CONFIG_DRM_INGENIC_IPU) += ingenic-ipu.o
+obj-$(CONFIG_DRM_INGENIC_IPU) += ingenic-ipu.o
 obj-$(CONFIG_DRM_INGENIC_DW_HDMI) += ingenic-dw-hdmi.o
diff --git a/drivers/gpu/drm/ingenic/ingenic-drm-drv.c b/drivers/gpu/drm/ingenic/ingenic-drm-drv.c
index 8dbd4847d3a..3e5dddb4f76 100644
--- a/drivers/gpu/drm/ingenic/ingenic-drm-drv.c
+++ b/drivers/gpu/drm/ingenic/ingenic-drm-drv.c
@@ -75,9 +75,32 @@ struct jz_soc_info {
 	unsigned int num_formats_f0, num_formats_f1;
 };
 
+struct ingenic_gem_object {
+	struct drm_gem_dma_object base;
+	struct ingenic_dma_hwdesc *hwdescs;
+	dma_addr_t hwdescs_phys;
+};
+
 struct ingenic_drm_private_state {
 	struct drm_private_state base;
 	bool use_palette;
+
+	/*
+	 * A lot of devices with an Ingenic SoC have a weird LCD panel attached,
+	 * where the pixels are not square. For instance, the AUO A030JTN01 and
+	 * Innolux EJ030NA panels have a resolution of 320x480 with a 4:3 aspect
+	 * ratio.
+	 *
+	 * All userspace applications are built with the assumption that the
+	 * pixels are square. To be able to support these devices without too
+	 * much effort, add a doublescan feature, which allows the f0 and f1
+	 * planes to be used with only half of the screen's vertical resolution,
+	 * where each line of the input is displayed twice.
+	 *
+	 * This is done using a chained list of DMA descriptors, one descriptor
+	 * per output line.
+	 */
+	bool doublescan;
 };
 
 struct ingenic_drm {
@@ -201,6 +224,11 @@ static inline struct ingenic_drm *drm_nb_get_priv(struct notifier_block *nb)
 	return container_of(nb, struct ingenic_drm, clock_nb);
 }
 
+static inline struct ingenic_gem_object *to_ingenic_gem_obj(struct drm_gem_object *gem_obj)
+{
+	return container_of(gem_obj, struct ingenic_gem_object, base.base);
+}
+
 static inline dma_addr_t dma_hwdesc_addr(const struct ingenic_drm *priv,
 					 unsigned int idx)
 {
@@ -480,7 +508,7 @@ static int ingenic_drm_plane_atomic_check(struct drm_plane *plane,
 		return PTR_ERR(priv_state);
 
 	ret = drm_atomic_helper_check_plane_state(new_plane_state, crtc_state,
-						  DRM_PLANE_NO_SCALING,
+						  0x8000,
 						  DRM_PLANE_NO_SCALING,
 						  priv->soc_info->has_osd,
 						  true);
@@ -497,6 +525,17 @@ static int ingenic_drm_plane_atomic_check(struct drm_plane *plane,
 	     (new_plane_state->src_h >> 16) != new_plane_state->crtc_h))
 		return -EINVAL;
 
+	/* Enable doublescan if the CRTC_H is twice the SRC_H. */
+	priv_state->doublescan = (new_plane_state->src_h >> 16) * 2 == new_plane_state->crtc_h;
+
+	/* Otherwise, fail if CRTC_H != SRC_H */
+	if (!priv_state->doublescan && (new_plane_state->src_h >> 16) != new_plane_state->crtc_h)
+		return -EINVAL;
+
+	/* Fail if CRTC_W != SRC_W */
+	if ((new_plane_state->src_w >> 16) != new_plane_state->crtc_w)
+		return -EINVAL;
+
 	priv_state->use_palette = new_plane_state->fb &&
 		new_plane_state->fb->format->format == DRM_FORMAT_C8;
 
@@ -548,6 +587,7 @@ void ingenic_drm_plane_disable(struct device *dev, struct drm_plane *plane)
 		regmap_clear_bits(priv->map, JZ_REG_LCD_OSDC, en_bit);
 	}
 }
+EXPORT_SYMBOL_GPL(ingenic_drm_plane_disable);
 
 static void ingenic_drm_plane_atomic_disable(struct drm_plane *plane,
 					     struct drm_atomic_state *state)
@@ -631,6 +671,7 @@ void ingenic_drm_plane_config(struct device *dev,
 			     state->crtc_h << JZ_LCD_SIZE01_HEIGHT_LSB);
 	}
 }
+EXPORT_SYMBOL_GPL(ingenic_drm_plane_config);
 
 bool ingenic_drm_map_noncoherent(const struct device *dev)
 {
@@ -638,6 +679,7 @@ bool ingenic_drm_map_noncoherent(const struct device *dev)
 
 	return priv->soc_info->map_noncoherent;
 }
+EXPORT_SYMBOL_GPL(ingenic_drm_map_noncoherent);
 
 static void ingenic_drm_update_palette(struct ingenic_drm *priv,
 				       const struct drm_color_lut *lut)
@@ -663,7 +705,10 @@ static void ingenic_drm_plane_atomic_update(struct drm_plane *plane,
 	struct ingenic_drm_private_state *priv_state;
 	struct drm_crtc_state *crtc_state;
 	struct ingenic_dma_hwdesc *hwdesc;
+	struct drm_gem_object *gem_obj;
+	struct ingenic_gem_object *obj;
 	dma_addr_t addr;
+	unsigned int i;
 	u32 fourcc;
 
 	if (newstate && newstate->fb) {
@@ -678,13 +723,36 @@ static void ingenic_drm_plane_atomic_update(struct drm_plane *plane,
 		height = newstate->src_h >> 16;
 		cpp = newstate->fb->format->cpp[0];
 
+		gem_obj = drm_gem_fb_get_obj(newstate->fb, 0);
+		obj = to_ingenic_gem_obj(gem_obj);
+
 		priv_state = ingenic_drm_get_new_priv_state(priv, state);
 		next_id = (priv_state && priv_state->use_palette) ? HWDESC_PALETTE : plane_id;
 
-		hwdesc = &priv->dma_hwdescs->hwdesc[plane_id];
-		hwdesc->addr = addr;
-		hwdesc->cmd = JZ_LCD_CMD_EOF_IRQ | (width * height * cpp / 4);
-		hwdesc->next = dma_hwdesc_addr(priv, next_id);
+		if (priv_state->doublescan) {
+			hwdesc = &obj->hwdescs[0];
+			/*
+			 * Use one DMA descriptor per output line, and display
+			 * each input line twice.
+			 */
+			for (i = 0; i < newstate->crtc_h; i++) {
+				hwdesc[i].next = obj->hwdescs_phys
+					+ (i + 1) * sizeof(*hwdesc);
+				hwdesc[i].addr = addr + (i / 2) * newstate->fb->pitches[0];
+				hwdesc[i].cmd = newstate->fb->pitches[0] / 4;
+			}
+
+			/* We want the EOF IRQ only on the very last transfer */
+			hwdesc[newstate->crtc_h - 1].cmd |= JZ_LCD_CMD_EOF_IRQ;
+			hwdesc[newstate->crtc_h - 1].next = dma_hwdesc_addr(priv, next_id);
+			priv->dma_hwdescs->hwdesc[plane_id] = *hwdesc;
+		} else {
+			/* Use one DMA descriptor for the whole frame. */
+			hwdesc = &priv->dma_hwdescs->hwdesc[plane_id];
+			hwdesc->addr = addr;
+			hwdesc->cmd = JZ_LCD_CMD_EOF_IRQ | (width * height * cpp / 4);
+			hwdesc->next = dma_hwdesc_addr(priv, next_id);
+		}
 
 		if (priv->soc_info->use_extended_hwdesc) {
 			hwdesc->cmd |= JZ_LCD_CMD_FRM_ENABLE;
@@ -897,31 +965,85 @@ static void ingenic_drm_disable_vblank(struct drm_crtc *crtc)
 	regmap_update_bits(priv->map, JZ_REG_LCD_CTRL, JZ_LCD_CTRL_EOF_IRQ, 0);
 }
 
+static void ingenic_drm_gem_fb_destroy(struct drm_framebuffer *fb)
+{
+	struct ingenic_drm *priv = drm_device_get_priv(fb->dev);
+	struct drm_gem_object *gem_obj = drm_gem_fb_get_obj(fb, 0);
+	struct ingenic_gem_object *obj = to_ingenic_gem_obj(gem_obj);
+
+	dma_free_coherent(priv->dev,
+			  sizeof(*obj->hwdescs) * fb->height * 2,
+			  obj->hwdescs, obj->hwdescs_phys);
+	drm_gem_fb_destroy(fb);
+}
+
+static int ingenic_drm_gem_dirtyfb(struct drm_framebuffer *fb,
+				   struct drm_file *file_priv, unsigned int flags,
+				   unsigned int color, struct drm_clip_rect *clips,
+				   unsigned int num_clips)
+{
+	struct ingenic_drm *priv = drm_device_get_priv(fb->dev);
+
+	if (priv->soc_info->map_noncoherent) {
+		return drm_atomic_helper_dirtyfb(fb, file_priv, flags, color,
+						 clips, num_clips);
+	}
+
+	return 0;
+}
+
+static const struct drm_framebuffer_funcs ingenic_drm_gem_fb_funcs = {
+	.destroy	= ingenic_drm_gem_fb_destroy,
+	.create_handle	= drm_gem_fb_create_handle,
+	.dirty		= ingenic_drm_gem_dirtyfb,
+};
+
 static struct drm_framebuffer *
-ingenic_drm_gem_fb_create(struct drm_device *drm, struct drm_file *file,
+ingenic_drm_gem_fb_create(struct drm_device *dev, struct drm_file *file,
 			  const struct drm_mode_fb_cmd2 *mode_cmd)
 {
-	struct ingenic_drm *priv = drm_device_get_priv(drm);
+	struct ingenic_drm *priv = drm_device_get_priv(dev);
+	struct drm_gem_object *gem_obj;
+	struct ingenic_gem_object *obj;
+	struct drm_framebuffer *fb;
 
-	if (priv->soc_info->map_noncoherent)
-		return drm_gem_fb_create_with_dirty(drm, file, mode_cmd);
+	fb = drm_gem_fb_create_with_funcs(dev, file, mode_cmd,
+					  &ingenic_drm_gem_fb_funcs);
+	if (IS_ERR(fb))
+		return fb;
+
+	gem_obj = drm_gem_fb_get_obj(fb, 0);
+	obj = to_ingenic_gem_obj(gem_obj);
 
-	return drm_gem_fb_create(drm, file, mode_cmd);
+	/*
+	 * Create (fb->height * 2) DMA descriptors, in case we want to use the
+	 * doublescan feature.
+	 */
+	obj->hwdescs = dma_alloc_coherent(priv->dev,
+					  sizeof(*obj->hwdescs) * fb->height * 2,
+					  &obj->hwdescs_phys,
+					  GFP_KERNEL);
+	if (!obj->hwdescs) {
+		drm_gem_fb_destroy(fb);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	return fb;
 }
 
 static struct drm_gem_object *
 ingenic_drm_gem_create_object(struct drm_device *drm, size_t size)
 {
 	struct ingenic_drm *priv = drm_device_get_priv(drm);
-	struct drm_gem_dma_object *obj;
+	struct ingenic_gem_object *obj;
 
 	obj = kzalloc(sizeof(*obj), GFP_KERNEL);
 	if (!obj)
 		return ERR_PTR(-ENOMEM);
 
-	obj->map_noncoherent = priv->soc_info->map_noncoherent;
+	obj->base.map_noncoherent = priv->soc_info->map_noncoherent;
 
-	return &obj->base;
+	return &obj->base.base;
 }
 
 static struct drm_private_state *
@@ -1076,6 +1198,17 @@ static void ingenic_drm_atomic_private_obj_fini(struct drm_device *drm, void *pr
 	drm_atomic_private_obj_fini(private_obj);
 }
 
+static struct clk * ingenic_drm_get_parent_clk(struct clk *clk)
+{
+	/*
+	 * Return the first clock above the one that will effectively modify
+	 * its rate when clk_set_rate(clk) is called.
+	 */
+	clk = clk_get_first_to_set_rate(clk);
+
+	return clk_get_parent(clk);
+}
+
 static int ingenic_drm_bind(struct device *dev, bool has_components)
 {
 	struct platform_device *pdev = to_platform_device(dev);
@@ -1085,7 +1218,6 @@ static int ingenic_drm_bind(struct device *dev, bool has_components)
 	struct clk *parent_clk;
 	struct drm_plane *primary;
 	struct drm_bridge *bridge;
-	struct drm_panel *panel;
 	struct drm_connector *connector;
 	struct drm_encoder *encoder;
 	struct ingenic_drm_bridge *ib;
@@ -1257,8 +1389,9 @@ static int ingenic_drm_bind(struct device *dev, bool has_components)
 	}
 
 	for (i = 0; ; i++) {
-		ret = drm_of_find_panel_or_bridge(dev->of_node, 0, i, &panel, &bridge);
-		if (ret) {
+		bridge = devm_drm_of_get_bridge(dev, dev->of_node, 0, i);
+		if (IS_ERR(bridge)) {
+			ret = PTR_ERR(bridge);
 			if (ret == -ENODEV)
 				break; /* we're done */
 			if (ret != -EPROBE_DEFER)
@@ -1266,10 +1399,6 @@ static int ingenic_drm_bind(struct device *dev, bool has_components)
 			return ret;
 		}
 
-		if (panel)
-			bridge = devm_drm_panel_bridge_add_typed(dev, panel,
-								 DRM_MODE_CONNECTOR_DPI);
-
 		ib = drmm_encoder_alloc(drm, struct ingenic_drm_bridge, encoder,
 					NULL, DRM_MODE_ENCODER_DPI, NULL);
 		if (IS_ERR(ib)) {
@@ -1362,7 +1491,8 @@ static int ingenic_drm_bind(struct device *dev, bool has_components)
 	mutex_init(&priv->clk_mutex);
 	priv->clock_nb.notifier_call = ingenic_drm_update_pixclk;
 
-	parent_clk = clk_get_parent(priv->pix_clk);
+	parent_clk = ingenic_drm_get_parent_clk(priv->pix_clk);
+
 	ret = clk_notifier_register(parent_clk, &priv->clock_nb);
 	if (ret) {
 		dev_err(dev, "Unable to register clock notifier\n");
@@ -1413,7 +1543,7 @@ static int ingenic_drm_bind_with_components(struct device *dev)
 static void ingenic_drm_unbind(struct device *dev)
 {
 	struct ingenic_drm *priv = dev_get_drvdata(dev);
-	struct clk *parent_clk = clk_get_parent(priv->pix_clk);
+	struct clk *parent_clk = ingenic_drm_get_parent_clk(priv->pix_clk);
 
 	clk_notifier_unregister(parent_clk, &priv->clock_nb);
 	if (priv->lcd_clk)
@@ -1435,6 +1565,9 @@ static int ingenic_drm_probe(struct platform_device *pdev)
 	struct component_match *match = NULL;
 	struct device_node *np;
 
+	if (drm_firmware_drivers_only())
+		return -ENODEV;
+
 	if (!IS_ENABLED(CONFIG_DRM_INGENIC_IPU))
 		return ingenic_drm_bind(dev, false);
 
@@ -1613,36 +1746,7 @@ static struct platform_driver ingenic_drm_driver = {
 	.probe = ingenic_drm_probe,
 	.remove = ingenic_drm_remove,
 };
-
-static int ingenic_drm_init(void)
-{
-	int err;
-
-	if (drm_firmware_drivers_only())
-		return -ENODEV;
-
-	if (IS_ENABLED(CONFIG_DRM_INGENIC_IPU)) {
-		err = platform_driver_register(ingenic_ipu_driver_ptr);
-		if (err)
-			return err;
-	}
-
-	err = platform_driver_register(&ingenic_drm_driver);
-	if (IS_ENABLED(CONFIG_DRM_INGENIC_IPU) && err)
-		platform_driver_unregister(ingenic_ipu_driver_ptr);
-
-	return err;
-}
-module_init(ingenic_drm_init);
-
-static void ingenic_drm_exit(void)
-{
-	platform_driver_unregister(&ingenic_drm_driver);
-
-	if (IS_ENABLED(CONFIG_DRM_INGENIC_IPU))
-		platform_driver_unregister(ingenic_ipu_driver_ptr);
-}
-module_exit(ingenic_drm_exit);
+module_platform_driver(ingenic_drm_driver);
 
 MODULE_AUTHOR("Paul Cercueil <paul@crapouillou.net>");
 MODULE_DESCRIPTION("DRM driver for the Ingenic SoCs\n");
diff --git a/drivers/gpu/drm/ingenic/ingenic-drm.h b/drivers/gpu/drm/ingenic/ingenic-drm.h
index e5bd007ea93..9b89929b81b 100644
--- a/drivers/gpu/drm/ingenic/ingenic-drm.h
+++ b/drivers/gpu/drm/ingenic/ingenic-drm.h
@@ -220,13 +220,10 @@
 struct device;
 struct drm_plane;
 struct drm_plane_state;
-struct platform_driver;
 
 void ingenic_drm_plane_config(struct device *dev,
 			      struct drm_plane *plane, u32 fourcc);
 void ingenic_drm_plane_disable(struct device *dev, struct drm_plane *plane);
 bool ingenic_drm_map_noncoherent(const struct device *dev);
 
-extern struct platform_driver *ingenic_ipu_driver_ptr;
-
 #endif /* DRIVERS_GPU_DRM_INGENIC_INGENIC_DRM_H */
diff --git a/drivers/gpu/drm/ingenic/ingenic-ipu.c b/drivers/gpu/drm/ingenic/ingenic-ipu.c
index 6d236547f61..f8da283a340 100644
--- a/drivers/gpu/drm/ingenic/ingenic-ipu.c
+++ b/drivers/gpu/drm/ingenic/ingenic-ipu.c
@@ -994,5 +994,8 @@ static struct platform_driver ingenic_ipu_driver = {
 	.probe = ingenic_ipu_probe,
 	.remove = ingenic_ipu_remove,
 };
+module_platform_driver(ingenic_ipu_driver);
 
-struct platform_driver *ingenic_ipu_driver_ptr = &ingenic_ipu_driver;
+MODULE_AUTHOR("Paul Cercueil <paul@crapouillou.net>");
+MODULE_DESCRIPTION("DRM driver for the IPU of Ingenic SoCs\n");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 869e535faef..a827f43b56b 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -10,7 +10,7 @@ menu "Display Panels"
 
 config DRM_PANEL_ABT_Y030XX067A
 	tristate "ABT Y030XX067A 320x480 LCD panel"
-	depends on OF && SPI
+	depends on SPI
 	select REGMAP_SPI
 	help
 	  Say Y here to enable support for the Asia Better Technology Ltd.
diff --git a/drivers/gpu/drm/panel/panel-abt-y030xx067a.c b/drivers/gpu/drm/panel/panel-abt-y030xx067a.c
index 662c7bcbe6e..8460bbd7981 100644
--- a/drivers/gpu/drm/panel/panel-abt-y030xx067a.c
+++ b/drivers/gpu/drm/panel/panel-abt-y030xx067a.c
@@ -139,7 +139,7 @@ static const struct reg_sequence y030xx067a_init_sequence[] = {
 	{ 0x01, REG01_COM_DC(0x3c) },
 	{ 0x02, REG02_VESA_SEL(0x3) | REG02_DA_CONTRAST(0x1f) },
 	{ 0x03, REG03_VPOSITION(0x0a) },
-	{ 0x04, REG04_HPOSITION1(0xd2) },
+	{ 0x04, REG04_HPOSITION1(0x48) },
 	{ 0x05, REG05_CLIP | REG05_NVM_VREFRESH | REG05_SLBRCHARGE(0x2) },
 	{ 0x06, REG06_NT },
 	{ 0x07, 0 },
@@ -292,7 +292,7 @@ static int y030xx067a_probe(struct spi_device *spi)
 		return PTR_ERR(priv->map);
 	}
 
-	priv->panel_info = of_device_get_match_data(dev);
+	priv->panel_info = spi_get_device_match_data(spi);
 	if (!priv->panel_info)
 		return -EINVAL;
 
@@ -329,23 +329,23 @@ static void y030xx067a_remove(struct spi_device *spi)
 
 static const struct drm_display_mode y030xx067a_modes[] = {
 	{ /* 60 Hz */
-		.clock = 14400,
+		.clock = 12000,
 		.hdisplay = 320,
-		.hsync_start = 320 + 10,
-		.hsync_end = 320 + 10 + 37,
-		.htotal = 320 + 10 + 37 + 33,
+		.hsync_start = 320 + 37,
+		.hsync_end = 320 + 37 + 12,
+		.htotal = 320 + 37 + 12 + 12,
 		.vdisplay = 480,
-		.vsync_start = 480 + 84,
-		.vsync_end = 480 + 84 + 20,
-		.vtotal = 480 + 84 + 20 + 16,
+		.vsync_start = 480 + 9,
+		.vsync_end = 480 + 9 + 20,
+		.vtotal = 480 + 9 + 20 + 16,
 		.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
 	},
 	{ /* 50 Hz */
 		.clock = 12000,
 		.hdisplay = 320,
-		.hsync_start = 320 + 10,
-		.hsync_end = 320 + 10 + 37,
-		.htotal = 320 + 10 + 37 + 33,
+		.hsync_start = 320 + 56,
+		.hsync_end = 320 + 56 + 12,
+		.htotal = 320 + 56 + 12 + 12,
 		.vdisplay = 480,
 		.vsync_start = 480 + 84,
 		.vsync_end = 480 + 84 + 20,
@@ -363,8 +363,14 @@ static const struct y030xx067a_info y030xx067a_info = {
 	.bus_flags = DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE | DRM_BUS_FLAG_DE_LOW,
 };
 
+static const struct spi_device_id y030xx067a_id[] = {
+	{ "y030xx067a", (kernel_ulong_t) &y030xx067a_info },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(spi, y030xx067a_id);
+
 static const struct of_device_id y030xx067a_of_match[] = {
-	{ .compatible = "abt,y030xx067a", .data = &y030xx067a_info },
+	{ .compatible = "abt,y030xx067a" },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, y030xx067a_of_match);
@@ -374,6 +380,7 @@ static struct spi_driver y030xx067a_driver = {
 		.name = "abt-y030xx067a",
 		.of_match_table = y030xx067a_of_match,
 	},
+	.id_table = y030xx067a_id,
 	.probe = y030xx067a_probe,
 	.remove = y030xx067a_remove,
 };
diff --git a/drivers/hwspinlock/Kconfig b/drivers/hwspinlock/Kconfig
index 3874d15b0e9..7c6b3e1ef78 100644
--- a/drivers/hwspinlock/Kconfig
+++ b/drivers/hwspinlock/Kconfig
@@ -8,6 +8,14 @@ menuconfig HWSPINLOCK
 
 if HWSPINLOCK
 
+config HWSPINLOCK_INGENIC
+	tristate "Ingenic VPU Hardware Spinlock device"
+	depends on MACH_INGENIC || COMPILE_TEST
+	help
+	  Say y here to support the Ingenic VPU Hardware Spinlock device.
+
+	  If unsure, say N.
+
 config HWSPINLOCK_OMAP
 	tristate "OMAP Hardware Spinlock device"
 	depends on ARCH_OMAP4 || SOC_OMAP5 || SOC_DRA7XX || SOC_AM33XX || SOC_AM43XX || ARCH_K3 || COMPILE_TEST
diff --git a/drivers/hwspinlock/Makefile b/drivers/hwspinlock/Makefile
index a0f16c9aaa8..cb6bf090751 100644
--- a/drivers/hwspinlock/Makefile
+++ b/drivers/hwspinlock/Makefile
@@ -4,6 +4,7 @@
 #
 
 obj-$(CONFIG_HWSPINLOCK)		+= hwspinlock_core.o
+obj-$(CONFIG_HWSPINLOCK_INGENIC)	+= ingenic_hwspinlock.o
 obj-$(CONFIG_HWSPINLOCK_OMAP)		+= omap_hwspinlock.o
 obj-$(CONFIG_HWSPINLOCK_QCOM)		+= qcom_hwspinlock.o
 obj-$(CONFIG_HWSPINLOCK_SPRD)		+= sprd_hwspinlock.o
diff --git a/drivers/hwspinlock/ingenic_hwspinlock.c b/drivers/hwspinlock/ingenic_hwspinlock.c
new file mode 100644
index 00000000000..00abc6f3c66
--- /dev/null
+++ b/drivers/hwspinlock/ingenic_hwspinlock.c
@@ -0,0 +1,120 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Ingenic VPU hardware spinlock driver
+//
+// Copyright (C) 2020, Paul Cercueil <paul@crapouillou.net>
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/hwspinlock.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include "hwspinlock_internal.h"
+
+#define REG_AUX_SPINLK		0x0
+#define REG_AUX_SPIN1		0x4
+#define REG_AUX_SPIN2		0x8
+
+#define AUX_SPIN1_LOCKED	BIT(0)
+#define AUX_SPIN2_LOCKED	BIT(1)
+
+struct ingenic_lock {
+	void __iomem *base;
+	struct clk *clk;
+	struct hwspinlock_device bank;
+};
+
+static int ingenic_hwspinlock_trylock(struct hwspinlock *lock)
+{
+	struct ingenic_lock *priv = lock->priv;
+	int err;
+	u32 val;
+
+	err = clk_enable(priv->clk);
+	if (err)
+		return err;
+
+	readl(priv->base + REG_AUX_SPIN1);
+
+	val = readl(priv->base + REG_AUX_SPINLK);
+
+	return val == AUX_SPIN1_LOCKED;
+}
+
+static void ingenic_hwspinlock_unlock(struct hwspinlock *lock)
+{
+	struct ingenic_lock *priv = lock->priv;
+
+	writel(0, priv->base + REG_AUX_SPINLK);
+	clk_disable(priv->clk);
+}
+
+static const struct hwspinlock_ops ingenic_hwspinlock_ops = {
+	.trylock	= ingenic_hwspinlock_trylock,
+	.unlock		= ingenic_hwspinlock_unlock,
+};
+
+static void ingenic_hwspinlock_clk_unprepare(void *d)
+{
+	clk_unprepare(d);
+}
+
+static int ingenic_hwspinlock_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ingenic_lock *priv;
+	int err;
+
+	priv = devm_kzalloc(dev, struct_size(priv, bank.lock, 1), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(priv->base))
+		return PTR_ERR(priv->base);
+
+	priv->clk = devm_clk_get(dev->parent, "aux");
+	if (IS_ERR(priv->clk))
+		return dev_err_probe(dev, PTR_ERR(priv->clk), "Failed to get clock\n");
+
+	err = clk_prepare(priv->clk);
+	if (err)
+		return err;
+
+	err = devm_add_action_or_reset(dev, ingenic_hwspinlock_clk_unprepare,
+				       priv->clk);
+	if (err)
+		return err;
+
+	priv->bank.lock->priv = priv;
+
+	/* Init registers */
+	writel(0, priv->base + REG_AUX_SPINLK);
+	writel(AUX_SPIN1_LOCKED, priv->base + REG_AUX_SPIN1);
+	writel(AUX_SPIN2_LOCKED, priv->base + REG_AUX_SPIN2);
+
+	return devm_hwspin_lock_register(dev, &priv->bank,
+					 &ingenic_hwspinlock_ops, 0, 1);
+}
+
+static const struct of_device_id ingenic_hwspinlock_of_match[] = {
+	{ .compatible = "ingenic,jz4760-vpu-hwspinlock", },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, ingenic_hwspinlock_of_match);
+
+static struct platform_driver ingenic_hwspinlock_driver = {
+	.probe = ingenic_hwspinlock_probe,
+	.driver = {
+		.name = "ingenic-hwspinlock",
+		.of_match_table = ingenic_hwspinlock_of_match,
+	},
+};
+module_platform_driver(ingenic_hwspinlock_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Ingenic VPU hardware spinlock driver");
+MODULE_AUTHOR("Paul Cercueil <paul@crapouillou.net>");
diff --git a/drivers/iio/adc/ingenic-adc.c b/drivers/iio/adc/ingenic-adc.c
index a7325dbbb99..5a932c375a8 100644
--- a/drivers/iio/adc/ingenic-adc.c
+++ b/drivers/iio/adc/ingenic-adc.c
@@ -804,11 +804,10 @@ static irqreturn_t ingenic_adc_irq(int irq, void *data)
 	unsigned int i;
 	u32 tdat[3];
 
-	for (i = 0; i < ARRAY_SIZE(tdat); mask >>= 2, i++) {
+	memset(tdat, 0, ARRAY_SIZE(tdat));
+	for (i = 0; mask && i < ARRAY_SIZE(tdat); mask >>= 2) {
 		if (mask & 0x3)
-			tdat[i] = readl(adc->base + JZ_ADC_REG_ADTCH);
-		else
-			tdat[i] = 0;
+			tdat[i++] = readl(adc->base + JZ_ADC_REG_ADTCH);
 	}
 
 	iio_push_to_buffers(iio_dev, tdat);
diff --git a/drivers/iio/afe/iio-rescale.c b/drivers/iio/afe/iio-rescale.c
index 56e5913ab82..f024e6c14dd 100644
--- a/drivers/iio/afe/iio-rescale.c
+++ b/drivers/iio/afe/iio-rescale.c
@@ -143,6 +143,27 @@ int rescale_process_offset(struct rescale *rescale, int scale_type,
 }
 EXPORT_SYMBOL_NS_GPL(rescale_process_offset, IIO_RESCALE);
 
+static int rescale_write_raw(struct iio_dev *indio_dev,
+			     struct iio_chan_spec const *chan,
+			     int val, int val2, long mask)
+{
+	struct rescale *rescale = iio_priv(indio_dev);
+	unsigned long long tmp;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		tmp = val * 1000000000LL;
+		do_div(tmp, rescale->numerator);
+		tmp *= rescale->denominator;
+		do_div(tmp, 1000000000LL);
+		return iio_write_channel_attribute(rescale->source, tmp, 0,
+						   IIO_CHAN_INFO_SCALE);
+	default:
+		return iio_write_channel_attribute(rescale->source,
+						   val, val2, mask);
+	}
+}
+
 static int rescale_read_raw(struct iio_dev *indio_dev,
 			    struct iio_chan_spec const *chan,
 			    int *val, int *val2, long mask)
@@ -244,12 +265,25 @@ static int rescale_read_avail(struct iio_dev *indio_dev,
 		*type = IIO_VAL_INT;
 		return iio_read_avail_channel_raw(rescale->source,
 						  vals, length);
+	case IIO_CHAN_INFO_SCALE:
+		if (rescale->chan_processed) {
+			return iio_read_avail_channel_attribute(rescale->source,
+								vals, type,
+								length,
+								IIO_CHAN_INFO_SCALE);
+		} else if (rescale->scale_len) {
+			*length = rescale->scale_len;
+			*vals = rescale->scale_data;
+			return IIO_AVAIL_LIST_WITH_TYPE;
+		}
+		fallthrough;
 	default:
 		return -EINVAL;
 	}
 }
 
 static const struct iio_info rescale_info = {
+	.write_raw = rescale_write_raw,
 	.read_raw = rescale_read_raw,
 	.read_avail = rescale_read_avail,
 };
@@ -278,11 +312,74 @@ static ssize_t rescale_write_ext_info(struct iio_dev *indio_dev,
 					  buf, len);
 }
 
+static int rescale_init_scale_avail(struct device *dev, struct rescale *rescale)
+{
+	int ret, type, length, *data;
+	const int *scale_raw;
+	unsigned int i;
+	size_t out_len;
+
+	ret = iio_read_avail_channel_attribute(rescale->source, &scale_raw,
+					       &type, &length,
+					       IIO_CHAN_INFO_SCALE);
+	if (ret < 0)
+		return ret;
+
+	switch (ret) {
+	case IIO_AVAIL_LIST_WITH_TYPE:
+		out_len = length;
+		break;
+	case IIO_AVAIL_LIST:
+		if (type == IIO_VAL_INT)
+			out_len = length * 3 / 1;
+		else
+			out_len = length * 3 / 2;
+		break;
+	default:
+		/* TODO: Support IIO_AVAIL_RANGE */
+		return -ENOTSUPP;
+	}
+
+	data = devm_kzalloc(dev, sizeof(*data) * out_len, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	if (ret == IIO_AVAIL_LIST_WITH_TYPE) {
+		memcpy(data, scale_raw, sizeof(*scale_raw) * length);
+	} else if (type == IIO_VAL_INT) {
+		for (i = 0; i < length; i++) {
+			data[i * 3 + 0] = scale_raw[i];
+			data[i * 3 + 2] = IIO_VAL_INT;
+		}
+	} else {
+		for (i = 0; i < length / 2; i++) {
+			data[i * 3 + 0] = scale_raw[i * 2];
+			data[i * 3 + 1] = scale_raw[i * 2 + 1];
+			data[i * 3 + 2] = type;
+		}
+	}
+
+	for (i = 0; i < out_len; i += 3) {
+		ret = rescale_process_scale(rescale, data[i + 2],
+					    &data[i], &data[i + 1]);
+		if (ret < 0)
+			return ret;
+
+		data[i + 2] = ret;
+	}
+
+	rescale->scale_len = out_len;
+	rescale->scale_data = data;
+
+	return 0;
+}
+
 static int rescale_configure_channel(struct device *dev,
 				     struct rescale *rescale)
 {
 	struct iio_chan_spec *chan = &rescale->chan;
 	struct iio_chan_spec const *schan = rescale->source->channel;
+	int ret;
 
 	chan->indexed = 1;
 	chan->output = schan->output;
@@ -316,6 +413,16 @@ static int rescale_configure_channel(struct device *dev,
 	    !rescale->chan_processed)
 		chan->info_mask_separate_available |= BIT(IIO_CHAN_INFO_RAW);
 
+	if (iio_channel_has_available(schan, IIO_CHAN_INFO_SCALE)) {
+		chan->info_mask_separate_available |= BIT(IIO_CHAN_INFO_SCALE);
+
+		if (!rescale->chan_processed) {
+			ret = rescale_init_scale_avail(dev, rescale);
+			if (ret)
+				return ret;
+		}
+	}
+
 	return 0;
 }
 
diff --git a/drivers/iio/industrialio-core.c b/drivers/iio/industrialio-core.c
index d752e9c0499..5b5321a0775 100644
--- a/drivers/iio/industrialio-core.c
+++ b/drivers/iio/industrialio-core.c
@@ -825,6 +825,29 @@ static ssize_t iio_format_avail_range(char *buf, const int *vals, int type)
 	return iio_format_list(buf, vals, type, length, "[", "]");
 }
 
+static ssize_t iio_format_avail_list_with_type(char *buf, const int *vals,
+					       int length)
+{
+	ssize_t len = 0;
+	int i;
+
+	for (i = 0; i < length; i += 3) {
+		if (i != 0) {
+			len += sysfs_emit_at(buf, len, " ");
+			if (len >= PAGE_SIZE)
+				return -EFBIG;
+		}
+
+		len += __iio_format_value(buf, len, vals[i + 2], 2, &vals[i]);
+		if (len >= PAGE_SIZE)
+			return -EFBIG;
+	}
+
+	len += sysfs_emit_at(buf, len, "\n");
+
+	return len;
+}
+
 static ssize_t iio_read_channel_info_avail(struct device *dev,
 					   struct device_attribute *attr,
 					   char *buf)
@@ -847,6 +870,8 @@ static ssize_t iio_read_channel_info_avail(struct device *dev,
 		return iio_format_avail_list(buf, vals, type, length);
 	case IIO_AVAIL_RANGE:
 		return iio_format_avail_range(buf, vals, type);
+	case IIO_AVAIL_LIST_WITH_TYPE:
+		return iio_format_avail_list_with_type(buf, vals, length);
 	default:
 		return -EINVAL;
 	}
diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 7a1f6713318..ebab05f437e 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -847,20 +847,25 @@ int iio_read_avail_channel_raw(struct iio_channel *chan,
 EXPORT_SYMBOL_GPL(iio_read_avail_channel_raw);
 
 static int iio_channel_read_max(struct iio_channel *chan,
-				int *val, int *val2, int *type,
+				int *val, int *val2,
 				enum iio_chan_info_enum info)
 {
 	const int *vals;
+	int unused;
 	int length;
 	int ret;
+	int type;
 
-	ret = iio_channel_read_avail(chan, &vals, type, &length, info);
+	if (!val2)
+		val2 = &unused;
+
+	ret = iio_channel_read_avail(chan, &vals, &type, &length, info);
 	if (ret < 0)
 		return ret;
 
 	switch (ret) {
 	case IIO_AVAIL_RANGE:
-		switch (*type) {
+		switch (type) {
 		case IIO_VAL_INT:
 			*val = vals[2];
 			break;
@@ -874,7 +879,7 @@ static int iio_channel_read_max(struct iio_channel *chan,
 	case IIO_AVAIL_LIST:
 		if (length <= 0)
 			return -EINVAL;
-		switch (*type) {
+		switch (type) {
 		case IIO_VAL_INT:
 			*val = max_array(vals, length);
 			break;
@@ -884,6 +889,29 @@ static int iio_channel_read_max(struct iio_channel *chan,
 		}
 		return 0;
 
+	case IIO_AVAIL_LIST_WITH_TYPE:
+		if (length <= 0 || length % 3 != 0)
+			return -EINVAL;
+
+		if (vals[length - 1] != IIO_VAL_INT) {
+			/* FIXME: learn about max for other iio values */
+			return -EINVAL;
+		}
+
+		*val = vals[length - 3];
+		length -= 3;
+
+		for (; length; length -= 3) {
+			if (vals[length - 1] != IIO_VAL_INT) {
+				/* FIXME: learn about max for other iio values */
+				return -EINVAL;
+			}
+
+			if (vals[length - 3] > *val)
+				*val = vals[length - 3];
+		}
+		return 0;
+
 	default:
 		return -EINVAL;
 	}
@@ -893,7 +921,6 @@ int iio_read_max_channel_raw(struct iio_channel *chan, int *val)
 {
 	struct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(chan->indio_dev);
 	int ret;
-	int type;
 
 	mutex_lock(&iio_dev_opaque->info_exist_lock);
 	if (!chan->indio_dev->info) {
@@ -901,7 +928,7 @@ int iio_read_max_channel_raw(struct iio_channel *chan, int *val)
 		goto err_unlock;
 	}
 
-	ret = iio_channel_read_max(chan, val, NULL, &type, IIO_CHAN_INFO_RAW);
+	ret = iio_channel_read_max(chan, val, NULL, IIO_CHAN_INFO_RAW);
 err_unlock:
 	mutex_unlock(&iio_dev_opaque->info_exist_lock);
 
diff --git a/drivers/input/joystick/adc-joystick.c b/drivers/input/joystick/adc-joystick.c
index c0deff5d428..15b0249e4ef 100644
--- a/drivers/input/joystick/adc-joystick.c
+++ b/drivers/input/joystick/adc-joystick.c
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/property.h>
+#include <linux/sort.h>
 
 #include <asm/unaligned.h>
 
@@ -25,6 +26,7 @@ struct adc_joystick {
 	struct iio_cb_buffer *buffer;
 	struct adc_joystick_axis *axes;
 	struct iio_channel *chans;
+	int *offsets;
 	int num_chans;
 	bool polled;
 };
@@ -47,35 +49,38 @@ static int adc_joystick_handle(const void *data, void *private)
 {
 	struct adc_joystick *joy = private;
 	enum iio_endian endianness;
-	int bytes, msb, val, idx, i;
-	const u16 *data_u16;
+	int bytes, msb, val, off, i;
+	const u8 *chan_data;
 	bool sign;
 
 	bytes = joy->chans[0].channel->scan_type.storagebits >> 3;
 
 	for (i = 0; i < joy->num_chans; ++i) {
-		idx = joy->chans[i].channel->scan_index;
 		endianness = joy->chans[i].channel->scan_type.endianness;
 		msb = joy->chans[i].channel->scan_type.realbits - 1;
 		sign = tolower(joy->chans[i].channel->scan_type.sign) == 's';
+		off = joy->offsets[i];
+
+		if (off < 0)
+			return -EINVAL;
+
+		chan_data = (const u8 *)data + off;
 
 		switch (bytes) {
 		case 1:
-			val = ((const u8 *)data)[idx];
+			val = *chan_data;
 			break;
 		case 2:
-			data_u16 = (const u16 *)data + idx;
-
 			/*
 			 * Data is aligned to the sample size by IIO core.
 			 * Call `get_unaligned_xe16` to hide type casting.
 			 */
 			if (endianness == IIO_BE)
-				val = get_unaligned_be16(data_u16);
+				val = get_unaligned_be16(chan_data);
 			else if (endianness == IIO_LE)
-				val = get_unaligned_le16(data_u16);
+				val = get_unaligned_le16(chan_data);
 			else /* IIO_CPU */
-				val = *data_u16;
+				val = *(const u16 *)chan_data;
 			break;
 		default:
 			return -EINVAL;
@@ -94,6 +99,70 @@ static int adc_joystick_handle(const void *data, void *private)
 	return 0;
 }
 
+static int adc_joystick_si_cmp(const void *a, const void *b, const void *priv)
+{
+	const struct iio_channel *chans = priv;
+
+	return chans[*(int *)a].channel->scan_index -
+	       chans[*(int *)b].channel->scan_index;
+}
+
+static int *adc_joystick_get_chan_offsets(struct iio_channel *chans, int count)
+{
+	struct iio_dev *indio_dev = chans[0].indio_dev;
+	struct device *dev = &indio_dev->dev;
+	const struct iio_chan_spec *ch;
+	int *offsets, *si_order;
+	int idx, i, si, length, offset = 0;
+
+	offsets = kmalloc_array(count, sizeof(int), GFP_KERNEL);
+	if (!offsets)
+		return ERR_PTR(-ENOMEM);
+
+	si_order = kmalloc_array(count, sizeof(int), GFP_KERNEL);
+	if (!si_order) {
+		kfree(offsets);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	for (i = 0; i < count; ++i)
+		si_order[i] = i;
+	/* Channels in buffer are ordered by scan index. Sort to match that. */
+	sort_r(si_order, count, sizeof(int), adc_joystick_si_cmp, NULL, chans);
+
+	for (i = 0; i < count; ++i) {
+		idx = si_order[i];
+		ch = chans[idx].channel;
+		si = ch->scan_index;
+
+		if (si < 0 || !test_bit(si, indio_dev->active_scan_mask)) {
+			offsets[idx] = -1;
+			continue;
+		}
+
+		/* Channels sharing scan indices also share the samples. */
+		if (idx > 0 && si == chans[idx - 1].channel->scan_index) {
+			offsets[idx] = offsets[idx - 1];
+			continue;
+		}
+
+		offsets[idx] = offset;
+
+		length = ch->scan_type.storagebits / 8;
+		if (ch->scan_type.repeat > 1)
+			length *= ch->scan_type.repeat;
+
+		/* Account for channel alignment. */
+		if (offset % length)
+			offset += length - (offset % length);
+		offset += length;
+	}
+
+	kfree(si_order);
+
+	return offsets;
+}
+
 static int adc_joystick_open(struct input_dev *dev)
 {
 	struct adc_joystick *joy = input_get_drvdata(dev);
@@ -101,10 +170,19 @@ static int adc_joystick_open(struct input_dev *dev)
 	int ret;
 
 	ret = iio_channel_start_all_cb(joy->buffer);
-	if (ret)
+	if (ret) {
 		dev_err(devp, "Unable to start callback buffer: %d\n", ret);
+		return ret;
+	}
 
-	return ret;
+	joy->offsets = adc_joystick_get_chan_offsets(joy->chans,
+						     joy->num_chans);
+	if (IS_ERR(joy->offsets)) {
+		dev_err(devp, "Unable to allocate channel offsets\n");
+		return PTR_ERR(joy->offsets);
+	}
+
+	return 0;
 }
 
 static void adc_joystick_close(struct input_dev *dev)
@@ -112,6 +190,7 @@ static void adc_joystick_close(struct input_dev *dev)
 	struct adc_joystick *joy = input_get_drvdata(dev);
 
 	iio_channel_stop_all_cb(joy->buffer);
+	kfree(joy->offsets);
 }
 
 static void adc_joystick_cleanup(void *data)
@@ -269,7 +348,7 @@ static int adc_joystick_probe(struct platform_device *pdev)
 
 		error = devm_add_action_or_reset(dev, adc_joystick_cleanup,
 						 joy->buffer);
-		if (error)  {
+		if (error) {
 			dev_err(dev, "Unable to add action\n");
 			return error;
 		}
diff --git a/drivers/media/radio/Kconfig b/drivers/media/radio/Kconfig
index d52eccdc7eb..826e33ab45a 100644
--- a/drivers/media/radio/Kconfig
+++ b/drivers/media/radio/Kconfig
@@ -29,6 +29,18 @@ config RADIO_MAXIRADIO
 	  To compile this driver as a module, choose M here: the
 	  module will be called radio-maxiradio.
 
+config RADIO_RDA5807
+	tristate "RDA5807 I2C FM radio support"
+	depends on I2C
+	select REGMAP_I2C
+	select PM
+	help
+	  Say Y here if you want to use the RDA5807 FM receiver connected to
+	  an I2C bus.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called radio-rda5807.
+
 config RADIO_SAA7706H
 	tristate "SAA7706H Car Radio DSP"
 	depends on I2C
diff --git a/drivers/media/radio/Makefile b/drivers/media/radio/Makefile
index cfb6af7d3bc..f0163314cf1 100644
--- a/drivers/media/radio/Makefile
+++ b/drivers/media/radio/Makefile
@@ -13,6 +13,7 @@ obj-$(CONFIG_RADIO_GEMTEK) += radio-gemtek.o
 obj-$(CONFIG_RADIO_ISA) += radio-isa.o
 obj-$(CONFIG_RADIO_MAXIRADIO) += radio-maxiradio.o
 obj-$(CONFIG_RADIO_MIROPCM20) += radio-miropcm20.o
+obj-$(CONFIG_RADIO_RDA5807) += radio-rda5807.o
 obj-$(CONFIG_RADIO_RTRACK2) += radio-rtrack2.o
 obj-$(CONFIG_RADIO_RTRACK) += radio-aimslab.o
 obj-$(CONFIG_RADIO_SAA7706H) += saa7706h.o
diff --git a/drivers/media/radio/radio-rda5807.c b/drivers/media/radio/radio-rda5807.c
new file mode 100644
index 00000000000..533c865c7ab
--- /dev/null
+++ b/drivers/media/radio/radio-rda5807.c
@@ -0,0 +1,919 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * radio-rda5807.c - Driver for using the RDA5807 FM tuner chip via I2C
+ *
+ * Copyright (c) 2011 Maarten ter Huurne <maarten@treewalker.org>
+ * Copyright (c) 2021 Paul Cercueil <paul@crapouillou.net>
+ *
+ * Many thanks to Jérôme Veres for his command line radio application that
+ * demonstrates how the chip can be controlled via I2C.
+ *
+ * Also thanks to Marcos Paulo de Souza for several patches to this driver.
+ *
+ * The RDA5807 has three ways of accessing registers:
+ * - I2C address 0x10: sequential access, RDA5800 style
+ * - I2C address 0x11: random access
+ * - I2C address 0x60: sequential access, TEA5767 compatible
+ *
+ * This driver only supports random access to the registers.
+ */
+
+
+#include <linux/bitops.h>
+#include <linux/bitfield.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+
+
+enum rda5807_reg {
+	RDA5807_REG_CHIPID		= 0x00,
+	RDA5807_REG_CTRL		= 0x02,
+	RDA5807_REG_CHAN		= 0x03,
+	RDA5807_REG_IOCFG		= 0x04,
+	RDA5807_REG_INPUT		= 0x05,
+	RDA5807_REG_BAND		= 0x07,
+	RDA5807_REG_SEEKRES		= 0x0A,
+	RDA5807_REG_SIGNAL		= 0x0B,
+};
+
+#define RDA5807_CTRL_DHIZ		BIT(15)
+#define RDA5807_CTRL_DMUTE		BIT(14)
+#define RDA5807_CTRL_MONO		BIT(13)
+#define RDA5807_CTRL_BASS		BIT(12)
+#define RDA5807_CTRL_SEEKUP		BIT(9)
+#define RDA5807_CTRL_SEEK		BIT(8)
+#define RDA5807_CTRL_SKMODE		BIT(7)
+#define RDA5807_CTRL_CLKMODE		GENMASK(6, 4)
+#define RDA5807_CTRL_SOFTRESET		BIT(1)
+#define RDA5807_CTRL_ENABLE		BIT(0)
+
+#define RDA5807_CHAN_WRCHAN		GENMASK(15, 6)
+#define RDA5807_CHAN_TUNE		BIT(4)
+#define RDA5807_CHAN_BAND		GENMASK(3, 2)
+#define RDA5807_CHAN_SPACE		GENMASK(1, 0)
+
+#define RDA5807_IOCFG_DEEMPHASIS	BIT(11)
+#define RDA5807_IOCFG_I2S_EN		BIT(6)
+
+#define RDA5807_INPUT_LNA_PORT		GENMASK(7, 6)
+#define RDA5807_INPUT_LNA_ICSEL		GENMASK(5, 4)
+#define RDA5807_INPUT_VOLUME		GENMASK(3, 0)
+
+#define RDA5807_BAND_65M_BAND		BIT(9)
+
+#define RDA5807_SEEKRES_COMPLETE	BIT(14)
+#define RDA5807_SEEKRES_FAIL		BIT(13)
+#define RDA5807_SEEKRES_STEREO		BIT(10)
+#define RDA5807_SEEKRES_READCHAN	GENMASK(9, 0)
+
+#define RDA5807_SIGNAL_RSSI		GENMASK(15, 9)
+
+
+#define RDA5807_AUTOSUSPEND_DELAY_MS	5000
+
+
+struct rda5807_driver {
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct video_device video_dev;
+	struct v4l2_device v4l2_dev;
+
+	struct device *dev;
+	struct regmap *map;
+	struct regulator *supply;
+
+	const struct v4l2_frequency_band *band;
+
+	bool unmuted;
+};
+
+enum rda5807_bands {
+	RDA5807_BAND_WORLDWIDE,
+	RDA5807_BAND_EAST_EUROPE,
+	RDA5807_BAND_UNKNOWN,
+};
+
+static const struct v4l2_frequency_band rda5807_bands[] = {
+	[RDA5807_BAND_WORLDWIDE] = {
+		.index = RDA5807_BAND_WORLDWIDE,
+		.type = V4L2_TUNER_RADIO,
+		.capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LOW |
+			V4L2_TUNER_CAP_FREQ_BANDS,
+		.rangelow = 1216000,   /* 76.0 MHz */
+		.rangehigh = 1728000,  /* 108.0 MHz */
+		.modulation = V4L2_BAND_MODULATION_FM,
+	},
+	[RDA5807_BAND_EAST_EUROPE] = {
+		.index = RDA5807_BAND_EAST_EUROPE,
+		.type = V4L2_TUNER_RADIO,
+		.capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LOW |
+			V4L2_TUNER_CAP_FREQ_BANDS,
+		.rangelow = 1040000,   /* 65.0 MHz */
+		.rangehigh = 1216000,  /* 76.0 MHz */
+		.modulation = V4L2_BAND_MODULATION_FM,
+	},
+	[RDA5807_BAND_UNKNOWN] = {
+		.index = RDA5807_BAND_UNKNOWN,
+		.type = V4L2_TUNER_RADIO,
+		.capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LOW |
+			V4L2_TUNER_CAP_FREQ_BANDS,
+		.rangelow = 800000,   /* 50.0 MHz */
+		.rangehigh = 1040000,  /* 65.0 MHz */
+		.modulation = V4L2_BAND_MODULATION_FM,
+	},
+};
+
+static const struct v4l2_frequency_band *rda5807_get_band(unsigned long min,
+							  unsigned long max)
+{
+	const struct v4l2_frequency_band *band;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(rda5807_bands); i++) {
+		band = &rda5807_bands[i];
+
+		if (band->rangelow <= min && band->rangehigh >= max)
+			return band;
+	}
+
+	return NULL;
+}
+
+static int rda5807_set_band(struct rda5807_driver *radio,
+			    const struct v4l2_frequency_band *band)
+{
+	u16 val;
+	int err;
+
+	if (band->index == RDA5807_BAND_EAST_EUROPE)
+		err = regmap_set_bits(radio->map, RDA5807_REG_BAND,
+				      RDA5807_BAND_65M_BAND);
+	else
+		err = regmap_clear_bits(radio->map, RDA5807_REG_BAND,
+					RDA5807_BAND_65M_BAND);
+	if (err)
+		return err;
+
+	if (band->index == RDA5807_BAND_WORLDWIDE)
+		val = FIELD_PREP(RDA5807_CHAN_BAND, 2);
+	else
+		val = FIELD_PREP(RDA5807_CHAN_BAND, 3);
+
+	err = regmap_update_bits(radio->map, RDA5807_REG_CHAN,
+				 RDA5807_CHAN_BAND, val);
+	if (err)
+		return err;
+
+	radio->band = band;
+	return 0;
+}
+
+static int rda5807_set_mute(struct rda5807_driver *radio, int muted)
+{
+	u16 val = muted ? 0 : RDA5807_CTRL_DMUTE /* disable mute */;
+
+	dev_dbg(radio->dev, "set mute to %d\n", muted);
+
+	return regmap_update_bits(radio->map, RDA5807_REG_CTRL,
+				  RDA5807_CTRL_DMUTE, val);
+}
+
+static int rda5807_set_volume(struct rda5807_driver *radio, int volume)
+{
+	dev_dbg(radio->dev, "set volume to %d\n", volume);
+
+	return regmap_update_bits(radio->map, RDA5807_REG_INPUT,
+				  RDA5807_INPUT_VOLUME,
+				  FIELD_PREP(RDA5807_INPUT_VOLUME, volume));
+}
+
+static int rda5807_set_deemphasis(struct rda5807_driver *radio,
+				  enum v4l2_deemphasis deemp)
+{
+	int err;
+
+	if (deemp == V4L2_DEEMPHASIS_50_uS)
+		err = regmap_set_bits(radio->map, RDA5807_REG_IOCFG,
+				      RDA5807_IOCFG_DEEMPHASIS);
+	else
+		err = regmap_clear_bits(radio->map, RDA5807_REG_IOCFG,
+					RDA5807_IOCFG_DEEMPHASIS);
+
+	dev_dbg(radio->dev, "set deemphasis to %d\n", deemp);
+	return err;
+}
+
+static inline struct rda5807_driver *ctrl_to_radio(struct v4l2_ctrl *ctrl)
+{
+	return container_of(ctrl->handler, struct rda5807_driver, ctrl_handler);
+}
+
+static int rda5807_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct rda5807_driver *radio = ctrl_to_radio(ctrl);
+	int err;
+
+	switch (ctrl->id) {
+	case V4L2_CID_AUDIO_MUTE:
+		if (radio->unmuted == !ctrl->val)
+			break;
+
+		if (ctrl->val) {
+			pm_runtime_mark_last_busy(radio->dev);
+			err = pm_runtime_put_autosuspend(radio->dev);
+			if (err < 0)
+				return err;
+		} else {
+			err = pm_runtime_get_sync(radio->dev);
+			if (err < 0) {
+				pm_runtime_put_noidle(radio->dev);
+				return err;
+			}
+		}
+
+		err = rda5807_set_mute(radio, ctrl->val);
+		if (err)
+			return err;
+
+		radio->unmuted = !ctrl->val;
+		break;
+	case V4L2_CID_AUDIO_VOLUME:
+		return rda5807_set_volume(radio, ctrl->val);
+	case V4L2_CID_TUNE_DEEMPHASIS:
+		return rda5807_set_deemphasis(radio, ctrl->val);
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops rda5807_ctrl_ops = {
+	.s_ctrl = rda5807_s_ctrl,
+};
+
+static int rda5807_vidioc_querycap(struct file *file, void *fh,
+				   struct v4l2_capability *cap)
+{
+	*cap = (struct v4l2_capability) {
+		.driver		= "rda5807",
+		.card		= "RDA5807 FM receiver",
+		.bus_info	= "I2C",
+		.device_caps	= V4L2_CAP_RADIO | V4L2_CAP_TUNER
+						 | V4L2_CAP_HW_FREQ_SEEK,
+	};
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+
+	return 0;
+}
+
+static int rda5807_vidioc_g_audio(struct file *file, void *fh,
+				  struct v4l2_audio *a)
+{
+	if (a->index != 0)
+		return -EINVAL;
+
+	*a = (struct v4l2_audio) {
+		.name = "Radio",
+		.capability = V4L2_AUDCAP_STEREO,
+		.mode = 0,
+	};
+
+	return 0;
+}
+
+static int rda5807_vidioc_g_tuner(struct file *file, void *fh,
+				  struct v4l2_tuner *a)
+{
+	struct rda5807_driver *radio = video_drvdata(file);
+	unsigned int seekres, signal;
+	u32 rxsubchans;
+	int err, active;
+
+	if (a->index != 0)
+		return -EINVAL;
+
+	active = pm_runtime_get_if_in_use(radio->dev);
+	if (active < 0)
+		return active;
+
+	if (active == 0) {
+		signal = 0;
+		rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;
+	} else {
+		err = regmap_read(radio->map, RDA5807_REG_SEEKRES, &seekres);
+		if (err < 0)
+			goto out_runtime_pm_put;
+
+		if (seekres & RDA5807_SEEKRES_COMPLETE &&
+		    !(seekres & RDA5807_SEEKRES_FAIL))
+			/* mono/stereo known */
+			rxsubchans = seekres & RDA5807_SEEKRES_STEREO
+				? V4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO;
+		else
+			/* mono/stereo unknown */
+			rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;
+
+		err = regmap_read(radio->map, RDA5807_REG_SIGNAL, &signal);
+		if (err < 0)
+			goto out_runtime_pm_put;
+	}
+
+	*a = (struct v4l2_tuner) {
+		.name = "FM",
+		.type = V4L2_TUNER_RADIO,
+		.capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO,
+		/* unit is 1/16 kHz */
+		.rangelow   = 50000 * 16,
+		.rangehigh  = 108000 * 16,
+		.rxsubchans = rxsubchans,
+		/* TODO: Implement forced mono (RDA5807_CTRL_MONO). */
+		.audmode = V4L2_TUNER_MODE_STEREO,
+		.signal = signal & RDA5807_SIGNAL_RSSI,
+		.afc = 0, /* automatic frequency control */
+	};
+
+	err = 0;
+out_runtime_pm_put:
+	if (active > 0) {
+		pm_runtime_mark_last_busy(radio->dev);
+		pm_runtime_put_autosuspend(radio->dev);
+	}
+	return err;
+}
+
+static int rda5807_vidioc_g_frequency(struct file *file, void *fh,
+				      struct v4l2_frequency *a)
+{
+	struct rda5807_driver *radio = video_drvdata(file);
+	unsigned int val;
+	int err;
+
+	if (a->tuner != 0)
+		return -EINVAL;
+	if (!radio->band)
+		return -EINVAL;
+
+	err = regmap_read(radio->map, RDA5807_REG_SEEKRES, &val);
+	if (err < 0)
+		return err;
+
+	a->frequency = 400 * (val & RDA5807_SEEKRES_READCHAN) + radio->band->rangelow;
+	return 0;
+}
+
+static int rda5807_vidioc_s_frequency(struct file *file, void *fh,
+				      const struct v4l2_frequency *a)
+{
+	struct rda5807_driver *radio = video_drvdata(file);
+	const struct v4l2_frequency_band *band;
+	u16 mask = 0;
+	u16 val = 0;
+	int err, active;
+
+	if (a->tuner != 0)
+		return -EINVAL;
+	if (a->type != V4L2_TUNER_RADIO)
+		return -EINVAL;
+
+	band = rda5807_get_band(a->frequency, a->frequency);
+	if (!band)
+		return -ERANGE;
+
+	dev_dbg(radio->dev, "set freq to %u kHz\n", a->frequency / 16);
+
+	err = rda5807_set_band(radio, band);
+	if (err)
+		return err;
+
+	/* select 50 kHz channel spacing because 25kHz can't
+	 * cover the whole 76-108 MHz range */
+	mask |= RDA5807_CHAN_SPACE;
+	val  |= FIELD_PREP(RDA5807_CHAN_SPACE, 0x2);
+
+	/* select frequency */
+	mask |= RDA5807_CHAN_WRCHAN;
+	val  |= FIELD_PREP(RDA5807_CHAN_WRCHAN,
+			   (a->frequency - band->rangelow + 400) / 800);
+
+	err = regmap_update_bits(radio->map, RDA5807_REG_CHAN, mask, val);
+	if (err)
+		return err;
+
+	active = pm_runtime_get_if_in_use(radio->dev);
+	if (active <= 0)
+		return active;
+
+	/* start tune operation */
+	err = regmap_write_bits(radio->map, RDA5807_REG_CHAN,
+				RDA5807_CHAN_TUNE, RDA5807_CHAN_TUNE);
+
+	pm_runtime_mark_last_busy(radio->dev);
+	pm_runtime_put_autosuspend(radio->dev);
+
+	return err;
+}
+
+static int rda5807_vidioc_s_hw_freq_seek(struct file *file, void *fh,
+					 const struct v4l2_hw_freq_seek *a)
+{
+	struct rda5807_driver *radio = video_drvdata(file);
+	const struct v4l2_frequency_band *band;
+	unsigned int val = RDA5807_CTRL_SEEK;
+	unsigned int freq, spacing, increment;
+	int err;
+
+	if (a->tuner != 0)
+		return -EINVAL;
+	if (a->type != V4L2_TUNER_RADIO)
+		return -EINVAL;
+
+	switch (a->spacing) {
+	case 25000:
+		spacing = 0x3;
+		break;
+	case 50000:
+		spacing = 0x2;
+		break;
+	case 100000:
+		spacing = 0x0;
+		break;
+	case 200000:
+		spacing = 0x1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	band = rda5807_get_band(a->rangelow, a->rangehigh);
+	if (!band)
+		return -ERANGE;
+
+	err = pm_runtime_get_sync(radio->dev);
+	if (err < 0) {
+		dev_err(radio->dev, "Unable to runtime get: %d\n", err);
+		pm_runtime_put_noidle(radio->dev);
+		return err;
+	}
+
+	/* Configure channel spacing */
+	err = regmap_update_bits(radio->map, RDA5807_REG_CHAN,
+				 RDA5807_CHAN_SPACE,
+				 FIELD_PREP(RDA5807_CHAN_SPACE, spacing));
+	if (err < 0)
+		goto out_runtime_pm_put;
+
+	err = rda5807_set_band(radio, band);
+	if (err < 0)
+		goto out_runtime_pm_put;
+
+	/* seek up or down? */
+	if (a->seek_upward)
+		val |= RDA5807_CTRL_SEEKUP;
+
+	/* wrap around at band limit? */
+	if (!a->wrap_around)
+		val |= RDA5807_CTRL_SKMODE;
+
+	/* Send seek command */
+	err = regmap_update_bits(radio->map, RDA5807_REG_CTRL,
+				 RDA5807_CTRL_SEEKUP |
+				 RDA5807_CTRL_SKMODE |
+				 RDA5807_CTRL_SEEK, val);
+	if (err < 0)
+		goto out_runtime_pm_put;
+
+	increment = a->spacing * 16 / 1000;
+
+	for (freq = a->rangelow; freq <= a->rangehigh; freq += increment) {
+		/*
+		 * The programming guide says we should wait for 35 ms for each
+		 * frequency tested.
+		 */
+		msleep(35);
+
+		err = regmap_read(radio->map, RDA5807_REG_SEEKRES, &val);
+		if (err < 0)
+			goto out_runtime_pm_put;
+
+		/* Seek done? */
+		if (val & RDA5807_SEEKRES_COMPLETE)
+			break;
+	}
+
+	err = regmap_clear_bits(radio->map, RDA5807_REG_CTRL,
+				RDA5807_CTRL_SEEK);
+	if (err)
+		goto out_runtime_pm_put;
+
+	if (freq > a->rangehigh)
+		err = -ETIMEDOUT;
+
+out_runtime_pm_put:
+	pm_runtime_mark_last_busy(radio->dev);
+	pm_runtime_put_autosuspend(radio->dev);
+	return err;
+}
+
+static int rda5807_vidioc_enum_freq_bands(struct file *file, void *priv,
+					  struct v4l2_frequency_band *band)
+{
+	if (band->index >= ARRAY_SIZE(rda5807_bands))
+		return -EINVAL;
+
+	*band = rda5807_bands[band->index];
+	return 0;
+}
+
+static const struct v4l2_ioctl_ops rda5807_ioctl_ops = {
+	.vidioc_querycap	= rda5807_vidioc_querycap,
+	.vidioc_g_audio		= rda5807_vidioc_g_audio,
+	.vidioc_g_tuner		= rda5807_vidioc_g_tuner,
+	.vidioc_g_frequency	= rda5807_vidioc_g_frequency,
+	.vidioc_s_frequency	= rda5807_vidioc_s_frequency,
+	.vidioc_s_hw_freq_seek  = rda5807_vidioc_s_hw_freq_seek,
+	.vidioc_enum_freq_bands	= rda5807_vidioc_enum_freq_bands,
+};
+
+static const u16 rda5807_lna_current[] = { 1800, 2100, 2500, 3000 };
+
+static int rda5807_setup(struct rda5807_driver *radio)
+{
+	struct device *dev = radio->dev;
+	u16 lna = 0, iocfg = 0, ctrl = 0;
+	u32 lna_current = 2500;
+	size_t i;
+	int err;
+
+	/* Configure chip inputs. */
+
+	if (device_property_read_bool(dev, "rda,lnan"))
+		lna |= 0x1;
+	if (device_property_read_bool(dev, "rda,lnap"))
+		lna |= 0x2;
+	if (!lna)
+		dev_warn(dev, "Both LNA inputs disabled\n");
+
+	device_property_read_u32(dev, "rda,lna-microamp", &lna_current);
+	for (i = 0; i < ARRAY_SIZE(rda5807_lna_current); i++)
+		if (rda5807_lna_current[i] == lna_current)
+			break;
+	if (i == ARRAY_SIZE(rda5807_lna_current)) {
+		dev_err(dev, "Invalid LNA current value\n");
+		return -EINVAL;
+	}
+
+	err = regmap_update_bits(radio->map, RDA5807_REG_INPUT,
+				 RDA5807_INPUT_LNA_ICSEL | RDA5807_INPUT_LNA_PORT,
+				 FIELD_PREP(RDA5807_INPUT_LNA_ICSEL, i) |
+				 FIELD_PREP(RDA5807_INPUT_LNA_PORT, lna));
+	if (err)
+		return err;
+
+	/* Configure chip outputs. */
+
+	if (device_property_read_bool(dev, "rda,i2s-out"))
+		iocfg |= RDA5807_IOCFG_I2S_EN;
+
+	if (device_property_read_bool(dev, "rda,analog-out"))
+		ctrl |= RDA5807_CTRL_DHIZ;
+
+	err = regmap_write(radio->map, RDA5807_REG_IOCFG, iocfg);
+	if (err)
+		return err;
+
+	err = regmap_write(radio->map, RDA5807_REG_CTRL, ctrl);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int rda5807_enable_regulator(struct rda5807_driver *radio)
+{
+	int err;
+
+	err = regulator_enable(radio->supply);
+	if (err)
+		return err;
+
+	/* A little sleep is needed before the registers can be accessed */
+	msleep(20);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations rda5807_fops = {
+	.owner		= THIS_MODULE,
+	.unlocked_ioctl	= video_ioctl2,
+};
+
+static const struct regmap_range rda5807_no_write_ranges[] = {
+	{ RDA5807_REG_CHIPID, RDA5807_REG_CHIPID },
+	{ RDA5807_REG_SEEKRES, RDA5807_REG_SIGNAL },
+};
+
+static const struct regmap_access_table rda5807_write_table = {
+	.no_ranges = rda5807_no_write_ranges,
+	.n_no_ranges = ARRAY_SIZE(rda5807_no_write_ranges),
+};
+
+static const struct regmap_range rda5807_volatile_ranges[] = {
+	{ RDA5807_REG_SEEKRES, RDA5807_REG_SIGNAL },
+};
+
+
+static const struct regmap_access_table rda5807_volatile_table = {
+	.yes_ranges = rda5807_volatile_ranges,
+	.n_yes_ranges = ARRAY_SIZE(rda5807_volatile_ranges),
+};
+
+static const struct reg_default rda5807_reg_defaults[] = {
+	{ RDA5807_REG_CHIPID, 0x5804 },
+	{ RDA5807_REG_CTRL, 0x0 },
+	{ RDA5807_REG_CHAN, 0x4fc0 },
+	{ RDA5807_REG_IOCFG, 0x0400 },
+	{ RDA5807_REG_INPUT, 0x888b },
+	{ RDA5807_REG_BAND, 0x5ec6 },
+};
+
+static const struct regmap_config rda5807_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 16,
+	.max_register = RDA5807_REG_SIGNAL,
+
+	.wr_table = &rda5807_write_table,
+	.volatile_table = &rda5807_volatile_table,
+
+	.reg_defaults = rda5807_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(rda5807_reg_defaults),
+
+	.cache_type = REGCACHE_FLAT,
+};
+
+static int rda5807_i2c_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct rda5807_driver *radio;
+	unsigned int chipid;
+	int err;
+
+	radio = devm_kzalloc(dev, sizeof(*radio), GFP_KERNEL);
+	if (!radio)
+		return -ENOMEM;
+
+	radio->dev = dev;
+
+	radio->map = devm_regmap_init_i2c(client, &rda5807_regmap_config);
+	if (IS_ERR(radio->map)) {
+		dev_err(dev, "Failed to create regmap\n");
+		return PTR_ERR(radio->map);
+	}
+
+	radio->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(radio->supply)) {
+		dev_err(dev, "Failed to get power supply\n");
+		return PTR_ERR(radio->supply);
+	}
+
+	err = rda5807_enable_regulator(radio);
+	if (err) {
+		dev_err(dev, "Failed to enable regulator\n");
+		return err;
+	}
+
+	/* Disable the regmap cache temporarily to force reading the chip ID */
+	regcache_cache_bypass(radio->map, true);
+	err = regmap_read(radio->map, RDA5807_REG_CHIPID, &chipid);
+	regcache_cache_bypass(radio->map, false);
+
+	regulator_disable(radio->supply);
+	if (err < 0) {
+		dev_err(dev, "Failed to read chip ID\n");
+		return err;
+	}
+
+	if ((chipid & 0xFF00) != 0x5800) {
+		dev_err(dev, "Chip ID mismatch: expected 58xx, got %04X\n",
+			chipid);
+		return -ENODEV;
+	}
+
+	dev_info(dev, "Found FM radio receiver\n");
+
+	pm_runtime_set_autosuspend_delay(dev, RDA5807_AUTOSUSPEND_DELAY_MS);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_enable(dev);
+
+	/* Only use regmap cache until the chip is brought up */
+	regcache_cache_only(radio->map, true);
+	regcache_mark_dirty(radio->map);
+
+	err = rda5807_setup(radio);
+	if (err) {
+		dev_err(dev, "Failed to setup registers\n");
+		return err;
+	}
+
+	/* Initialize controls. */
+	v4l2_ctrl_handler_init(&radio->ctrl_handler, 3);
+	v4l2_ctrl_new_std(&radio->ctrl_handler, &rda5807_ctrl_ops,
+			  V4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);
+	v4l2_ctrl_new_std(&radio->ctrl_handler, &rda5807_ctrl_ops,
+			  V4L2_CID_AUDIO_VOLUME, 0, 15, 1, 8);
+
+	v4l2_ctrl_new_std_menu(&radio->ctrl_handler, &rda5807_ctrl_ops,
+			       V4L2_CID_TUNE_DEEMPHASIS,
+			       V4L2_DEEMPHASIS_75_uS,
+			       BIT(V4L2_DEEMPHASIS_DISABLED),
+			       V4L2_DEEMPHASIS_50_uS);
+	err = radio->ctrl_handler.error;
+	if (err) {
+		dev_err(dev, "Failed to init controls handler\n");
+		goto err_ctrl_free;
+	}
+
+	err = v4l2_device_register(dev, &radio->v4l2_dev);
+	if (err < 0) {
+		dev_err(dev, "Failed to register v4l2 device\n");
+		goto err_ctrl_free;
+	}
+
+	radio->video_dev = (struct video_device) {
+		.name = "RDA5807 FM receiver",
+		.v4l2_dev = &radio->v4l2_dev,
+		.ctrl_handler = &radio->ctrl_handler,
+		.fops = &rda5807_fops,
+		.ioctl_ops = &rda5807_ioctl_ops,
+		.release = video_device_release_empty,
+		.device_caps = V4L2_CAP_RADIO | V4L2_CAP_TUNER
+					      | V4L2_CAP_HW_FREQ_SEEK,
+	};
+
+	i2c_set_clientdata(client, radio);
+	video_set_drvdata(&radio->video_dev, radio);
+
+	err = v4l2_ctrl_handler_setup(&radio->ctrl_handler);
+	if (err < 0) {
+		dev_err(dev, "Failed to set default control values\n");
+		goto err_video_unreg;
+	}
+
+	err = video_register_device(&radio->video_dev, VFL_TYPE_RADIO, -1);
+	if (err < 0) {
+		dev_err(dev, "Failed to register video device\n");
+		goto err_ctrl_free;
+	}
+
+	return 0;
+
+err_video_unreg:
+	video_unregister_device(&radio->video_dev);
+err_ctrl_free:
+	v4l2_ctrl_handler_free(&radio->ctrl_handler);
+	video_device_release_empty(&radio->video_dev);
+
+	return err;
+}
+
+static void rda5807_i2c_remove(struct i2c_client *client)
+{
+	struct rda5807_driver *radio = i2c_get_clientdata(client);
+	struct device *dev = &client->dev;
+
+	pm_runtime_disable(dev);
+	pm_runtime_force_suspend(dev);
+	pm_runtime_dont_use_autosuspend(dev);
+
+	video_unregister_device(&radio->video_dev);
+	v4l2_ctrl_handler_free(&radio->ctrl_handler);
+	video_device_release_empty(&radio->video_dev);
+}
+
+static int rda5807_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct rda5807_driver *radio = i2c_get_clientdata(client);
+	int err;
+
+	err = regmap_clear_bits(radio->map, RDA5807_REG_CTRL,
+				RDA5807_CTRL_ENABLE);
+	if (err)
+		return err;
+
+	regcache_cache_only(radio->map, true);
+	regcache_mark_dirty(radio->map);
+
+	err = regulator_disable(radio->supply);
+	if (err)
+		return err;
+
+	dev_dbg(radio->dev, "Disabled\n");
+
+	return 0;
+}
+
+static int rda5807_reset_chip(struct rda5807_driver *radio)
+{
+	int err;
+
+	err = regmap_write_bits(radio->map, RDA5807_REG_CTRL,
+				RDA5807_CTRL_SOFTRESET, RDA5807_CTRL_SOFTRESET);
+	if (err)
+		return err;
+
+	usleep_range(1000, 10000);
+
+	return regmap_write_bits(radio->map, RDA5807_REG_CTRL,
+				 RDA5807_CTRL_SOFTRESET, 0);
+}
+
+static int rda5807_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct rda5807_driver *radio = i2c_get_clientdata(client);
+	int err;
+
+	err = rda5807_enable_regulator(radio);
+	if (err)
+		return err;
+
+	regcache_cache_only(radio->map, false);
+
+	err = rda5807_reset_chip(radio);
+	if (err)
+		return err;
+
+	/* Restore cached registers to hardware */
+	err = regcache_sync(radio->map);
+	if (err) {
+		dev_err(dev, "Failed to restore regs: %d\n", err);
+		goto err_regulator_disable;
+	}
+
+	err = regmap_set_bits(radio->map, RDA5807_REG_CTRL,
+			      RDA5807_CTRL_ENABLE);
+	if (err) {
+		dev_err(dev, "Failed to enable radio: %d\n", err);
+		goto err_regulator_disable;
+	}
+
+	err = regmap_write_bits(radio->map, RDA5807_REG_CHAN,
+				RDA5807_CHAN_TUNE, RDA5807_CHAN_TUNE);
+	if (err) {
+		dev_err(dev, "Failed to tune radio: %d\n", err);
+		goto err_radio_disable;
+	}
+
+	dev_dbg(radio->dev, "Enabled\n");
+
+	return 0;
+
+err_radio_disable:
+	regmap_clear_bits(radio->map, RDA5807_REG_CTRL,
+			  RDA5807_CTRL_ENABLE);
+err_regulator_disable:
+	regulator_disable(radio->supply);
+	return err;
+}
+
+static UNIVERSAL_DEV_PM_OPS(rda5807_pm_ops, rda5807_suspend, rda5807_resume, NULL);
+
+static const struct of_device_id rda5807_dt_ids[] = {
+	{ .compatible = "rda,rda5807" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, rda5807_dt_ids);
+
+static const struct i2c_device_id rda5807_id[] = {
+	{ "rda5807", 0 },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i2c, rda5807_id);
+
+static struct i2c_driver rda5807_i2c_driver = {
+	.driver = {
+		.name = "radio-rda5807",
+		.of_match_table = of_match_ptr(rda5807_dt_ids),
+		.pm = &rda5807_pm_ops,
+	},
+	.probe = rda5807_i2c_probe,
+	.remove = rda5807_i2c_remove,
+	.id_table = rda5807_id,
+};
+module_i2c_driver(rda5807_i2c_driver);
+
+MODULE_AUTHOR("Maarten ter Huurne <maarten@treewalker.org>");
+MODULE_AUTHOR("Paul Cercueil <paul@crapouillou.net>");
+MODULE_DESCRIPTION("RDA5807 FM tuner driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mmc/host/jz4740_mmc.c b/drivers/mmc/host/jz4740_mmc.c
index f379ce5b582..f29ca1ac785 100644
--- a/drivers/mmc/host/jz4740_mmc.c
+++ b/drivers/mmc/host/jz4740_mmc.c
@@ -22,6 +22,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
+#include <linux/rwsem.h>
 #include <linux/scatterlist.h>
 
 #include <asm/cacheflush.h>
@@ -150,6 +151,9 @@ struct jz4740_mmc_host {
 	struct platform_device *pdev;
 	struct clk *clk;
 
+	struct rw_semaphore clk_rwsem;
+	struct notifier_block clock_nb;
+
 	enum jz4740_mmc_version version;
 
 	int irq;
@@ -376,6 +380,8 @@ static void jz4740_mmc_pre_request(struct mmc_host *mmc,
 	struct jz4740_mmc_host *host = mmc_priv(mmc);
 	struct mmc_data *data = mrq->data;
 
+	down_read(&host->clk_rwsem);
+
 	if (!host->use_dma)
 		return;
 
@@ -391,6 +397,8 @@ static void jz4740_mmc_post_request(struct mmc_host *mmc,
 	struct jz4740_mmc_host *host = mmc_priv(mmc);
 	struct mmc_data *data = mrq->data;
 
+	up_read(&host->clk_rwsem);
+
 	if (data && data->host_cookie != COOKIE_UNMAPPED)
 		jz4740_mmc_dma_unmap(host, data);
 
@@ -1024,6 +1032,48 @@ static const struct mmc_host_ops jz4740_mmc_ops = {
 	.start_signal_voltage_switch = jz4740_voltage_switch,
 };
 
+static inline struct jz4740_mmc_host *
+jz4740_mmc_nb_get_priv(struct notifier_block *nb)
+{
+	return container_of(nb, struct jz4740_mmc_host, clock_nb);
+}
+
+static struct clk *jz4740_mmc_get_parent_clk(struct clk *clk)
+{
+	/*
+	 * Return the first clock above the one that will effectively modify
+	 * its rate when clk_set_rate(clk) is called.
+	 */
+	clk = clk_get_first_to_set_rate(clk);
+
+	return clk_get_parent(clk);
+}
+
+static int jz4740_mmc_update_clk(struct notifier_block *nb,
+				 unsigned long action,
+				 void *data)
+{
+	struct jz4740_mmc_host *host = jz4740_mmc_nb_get_priv(nb);
+
+	/*
+	 * PLL may have changed its frequency; our clock may be running above
+	 * spec. Wait until MMC is idle (using host->clk_rwsem) before changing
+	 * the PLL clock, and after it's done, reset our clock rate.
+	 */
+
+	switch (action) {
+	case PRE_RATE_CHANGE:
+		down_write(&host->clk_rwsem);
+		break;
+	default:
+		clk_set_rate(host->clk, host->mmc->f_max);
+		up_write(&host->clk_rwsem);
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
 static const struct of_device_id jz4740_mmc_of_match[] = {
 	{ .compatible = "ingenic,jz4740-mmc", .data = (void *) JZ_MMC_JZ4740 },
 	{ .compatible = "ingenic,jz4725b-mmc", .data = (void *)JZ_MMC_JZ4725B },
@@ -1041,6 +1091,7 @@ static int jz4740_mmc_probe(struct platform_device* pdev)
 	struct mmc_host *mmc;
 	struct jz4740_mmc_host *host;
 	const struct of_device_id *match;
+	struct clk *parent_clk;
 
 	mmc = mmc_alloc_host(sizeof(struct jz4740_mmc_host), &pdev->dev);
 	if (!mmc) {
@@ -1136,12 +1187,23 @@ static int jz4740_mmc_probe(struct platform_device* pdev)
 		goto err_free_irq;
 	host->use_dma = !ret;
 
+	init_rwsem(&host->clk_rwsem);
+	host->clock_nb.notifier_call = jz4740_mmc_update_clk;
+
+	parent_clk = jz4740_mmc_get_parent_clk(host->clk);
+
+	ret = clk_notifier_register(parent_clk, &host->clock_nb);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to register clock notifier\n");
+		goto err_release_dma;
+	}
+
 	platform_set_drvdata(pdev, host);
 	ret = mmc_add_host(mmc);
 
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to add mmc host: %d\n", ret);
-		goto err_release_dma;
+		goto err_unregister_clk_notifier;
 	}
 	dev_info(&pdev->dev, "Ingenic SD/MMC card driver registered\n");
 
@@ -1152,6 +1214,8 @@ static int jz4740_mmc_probe(struct platform_device* pdev)
 
 	return 0;
 
+err_unregister_clk_notifier:
+	clk_notifier_unregister(parent_clk, &host->clock_nb);
 err_release_dma:
 	if (host->use_dma)
 		jz4740_mmc_release_dma_channels(host);
diff --git a/drivers/phy/ingenic/phy-ingenic-usb.c b/drivers/phy/ingenic/phy-ingenic-usb.c
index eb2721f72a4..656fea1598a 100644
--- a/drivers/phy/ingenic/phy-ingenic-usb.c
+++ b/drivers/phy/ingenic/phy-ingenic-usb.c
@@ -364,6 +364,7 @@ static int ingenic_usb_phy_probe(struct platform_device *pdev)
 }
 
 static const struct of_device_id ingenic_usb_phy_of_matches[] = {
+	{ .compatible = "ingenic,jz4760-phy", .data = &jz4770_soc_info },
 	{ .compatible = "ingenic,jz4770-phy", .data = &jz4770_soc_info },
 	{ .compatible = "ingenic,jz4775-phy", .data = &jz4775_soc_info },
 	{ .compatible = "ingenic,jz4780-phy", .data = &jz4780_soc_info },
diff --git a/drivers/pinctrl/pinctrl-ingenic.c b/drivers/pinctrl/pinctrl-ingenic.c
index 2f220a47b74..23d96eb7301 100644
--- a/drivers/pinctrl/pinctrl-ingenic.c
+++ b/drivers/pinctrl/pinctrl-ingenic.c
@@ -139,6 +139,7 @@ struct ingenic_gpio_chip {
 	struct ingenic_pinctrl *jzpc;
 	struct gpio_chip gc;
 	unsigned int irq, reg_base;
+	u32 levels;
 };
 
 static const unsigned long enabled_socs =
@@ -901,7 +902,15 @@ static int jz4760_pwm_pwm5_pins[] = { 0x85, };
 static int jz4760_pwm_pwm6_pins[] = { 0x6a, };
 static int jz4760_pwm_pwm7_pins[] = { 0x6b, };
 static int jz4760_otg_pins[] = { 0x8a, };
-
+static int jz4760_i2s_data_tx0_pins[] = { 0x87, };
+static int jz4760_i2s_data_tx1_pins[] = { 0x8b, };
+static int jz4760_i2s_data_tx2_pins[] = { 0x8c, };
+static int jz4760_i2s_data_tx3_pins[] = { 0x8d, };
+static int jz4760_i2s_data_rx_pins[] = { 0x86, };
+static int jz4760_i2s_clk_txrx_pins[] = { 0x6c, 0x6d, };
+static int jz4760_i2s_sysclk_pins[] = { 0x85, };
+
+static u8 jz4760_i2s_clk_txrx_funcs[] = { 1, 0, };
 static u8 jz4760_uart3_data_funcs[] = { 0, 1, };
 static u8 jz4760_mmc0_1bit_a_funcs[] = { 1, 1, 0, };
 
@@ -1014,6 +1023,14 @@ static const struct group_desc jz4760_groups[] = {
 	INGENIC_PIN_GROUP("pwm6", jz4760_pwm_pwm6, 0),
 	INGENIC_PIN_GROUP("pwm7", jz4760_pwm_pwm7, 0),
 	INGENIC_PIN_GROUP("otg-vbus", jz4760_otg, 0),
+	INGENIC_PIN_GROUP("i2s-data-tx0", jz4760_i2s_data_tx0, 0),
+	INGENIC_PIN_GROUP("i2s-data-tx1", jz4760_i2s_data_tx1, 0),
+	INGENIC_PIN_GROUP("i2s-data-tx2", jz4760_i2s_data_tx2, 0),
+	INGENIC_PIN_GROUP("i2s-data-tx3", jz4760_i2s_data_tx3, 0),
+	INGENIC_PIN_GROUP("i2s-data-rx", jz4760_i2s_data_rx, 0),
+	INGENIC_PIN_GROUP_FUNCS("i2s-clk-txrx", jz4760_i2s_clk_txrx,
+				jz4760_i2s_clk_txrx_funcs),
+	INGENIC_PIN_GROUP("i2s-sysclk", jz4760_i2s_sysclk, 2),
 };
 
 static const char *jz4760_uart0_groups[] = { "uart0-data", "uart0-hwflow", };
@@ -1074,6 +1091,10 @@ static const char *jz4760_pwm5_groups[] = { "pwm5", };
 static const char *jz4760_pwm6_groups[] = { "pwm6", };
 static const char *jz4760_pwm7_groups[] = { "pwm7", };
 static const char *jz4760_otg_groups[] = { "otg-vbus", };
+static const char *jz4760_i2s_groups[] = {
+	"i2s-data-tx0", "i2s-data-tx1", "i2s-data-tx2", "i2s-data-tx3",
+	"i2s-data-rx", "i2s-clk-txrx", "i2s-sysclk",
+};
 
 static const struct function_desc jz4760_functions[] = {
 	{ "uart0", jz4760_uart0_groups, ARRAY_SIZE(jz4760_uart0_groups), },
@@ -1105,6 +1126,7 @@ static const struct function_desc jz4760_functions[] = {
 	{ "pwm6", jz4760_pwm6_groups, ARRAY_SIZE(jz4760_pwm6_groups), },
 	{ "pwm7", jz4760_pwm7_groups, ARRAY_SIZE(jz4760_pwm7_groups), },
 	{ "otg", jz4760_otg_groups, ARRAY_SIZE(jz4760_otg_groups), },
+	{ "i2s", jz4760_i2s_groups, ARRAY_SIZE(jz4760_i2s_groups), },
 };
 
 static const struct ingenic_chip_info jz4760_chip_info = {
@@ -1249,6 +1271,7 @@ static int jz4770_mac_rmii_pins[] = {
 static int jz4770_mac_mii_pins[] = {
 	0x7b, 0x7a, 0x7d, 0x7c, 0xa7, 0x24, 0xaf,
 };
+static int jz4770_i2s_clk_rx_pins[] = { 0x88, 0x89, };
 
 static const struct group_desc jz4770_groups[] = {
 	INGENIC_PIN_GROUP("uart0-data", jz4770_uart0_data, 0),
@@ -1351,6 +1374,15 @@ static const struct group_desc jz4770_groups[] = {
 	INGENIC_PIN_GROUP("mac-rmii", jz4770_mac_rmii, 0),
 	INGENIC_PIN_GROUP("mac-mii", jz4770_mac_mii, 0),
 	INGENIC_PIN_GROUP("otg-vbus", jz4760_otg, 0),
+	INGENIC_PIN_GROUP("i2s-data-tx0", jz4760_i2s_data_tx0, 0),
+	INGENIC_PIN_GROUP("i2s-data-tx1", jz4760_i2s_data_tx1, 0),
+	INGENIC_PIN_GROUP("i2s-data-tx2", jz4760_i2s_data_tx2, 0),
+	INGENIC_PIN_GROUP("i2s-data-tx3", jz4760_i2s_data_tx3, 0),
+	INGENIC_PIN_GROUP("i2s-data-rx", jz4760_i2s_data_rx, 0),
+	INGENIC_PIN_GROUP_FUNCS("i2s-clk-txrx", jz4760_i2s_clk_txrx,
+				jz4760_i2s_clk_txrx_funcs),
+	INGENIC_PIN_GROUP("i2s-sysclk", jz4760_i2s_sysclk, 2),
+	INGENIC_PIN_GROUP("i2s-clk-rx", jz4770_i2s_clk_rx, 1),
 };
 
 static const char *jz4770_uart0_groups[] = { "uart0-data", "uart0-hwflow", };
@@ -1412,6 +1444,10 @@ static const char *jz4770_pwm5_groups[] = { "pwm5", };
 static const char *jz4770_pwm6_groups[] = { "pwm6", };
 static const char *jz4770_pwm7_groups[] = { "pwm7", };
 static const char *jz4770_mac_groups[] = { "mac-rmii", "mac-mii", };
+static const char *jz4770_i2s_groups[] = {
+	"i2s-data-tx0", "i2s-data-tx1", "i2s-data-tx2", "i2s-data-tx3",
+	"i2s-data-rx", "i2s-clk-txrx", "i2s-sysclk", "i2s-clk-rx",
+};
 
 static const struct function_desc jz4770_functions[] = {
 	{ "uart0", jz4770_uart0_groups, ARRAY_SIZE(jz4770_uart0_groups), },
@@ -1445,6 +1481,7 @@ static const struct function_desc jz4770_functions[] = {
 	{ "pwm7", jz4770_pwm7_groups, ARRAY_SIZE(jz4770_pwm7_groups), },
 	{ "mac", jz4770_mac_groups, ARRAY_SIZE(jz4770_mac_groups), },
 	{ "otg", jz4760_otg_groups, ARRAY_SIZE(jz4760_otg_groups), },
+	{ "i2s", jz4770_i2s_groups, ARRAY_SIZE(jz4770_i2s_groups), },
 };
 
 static const struct ingenic_chip_info jz4770_chip_info = {
@@ -1780,16 +1817,9 @@ static int jz4780_mmc0_8bit_a_pins[] = { 0x04, 0x05, 0x06, 0x07, 0x18, };
 static int jz4780_i2c3_pins[] = { 0x6a, 0x6b, };
 static int jz4780_i2c4_e_pins[] = { 0x8c, 0x8d, };
 static int jz4780_i2c4_f_pins[] = { 0xb9, 0xb8, };
-static int jz4780_i2s_data_tx_pins[] = { 0x87, };
-static int jz4780_i2s_data_rx_pins[] = { 0x86, };
-static int jz4780_i2s_clk_txrx_pins[] = { 0x6c, 0x6d, };
-static int jz4780_i2s_clk_rx_pins[] = { 0x88, 0x89, };
-static int jz4780_i2s_sysclk_pins[] = { 0x85, };
 static int jz4780_dmic_pins[] = { 0x32, 0x33, };
 static int jz4780_hdmi_ddc_pins[] = { 0xb9, 0xb8, };
 
-static u8 jz4780_i2s_clk_txrx_funcs[] = { 1, 0, };
-
 static const struct group_desc jz4780_groups[] = {
 	INGENIC_PIN_GROUP("uart0-data", jz4770_uart0_data, 0),
 	INGENIC_PIN_GROUP("uart0-hwflow", jz4770_uart0_hwflow, 0),
@@ -1878,12 +1908,12 @@ static const struct group_desc jz4780_groups[] = {
 	INGENIC_PIN_GROUP("i2c3-data", jz4780_i2c3, 1),
 	INGENIC_PIN_GROUP("i2c4-data-e", jz4780_i2c4_e, 1),
 	INGENIC_PIN_GROUP("i2c4-data-f", jz4780_i2c4_f, 1),
-	INGENIC_PIN_GROUP("i2s-data-tx", jz4780_i2s_data_tx, 0),
-	INGENIC_PIN_GROUP("i2s-data-rx", jz4780_i2s_data_rx, 0),
-	INGENIC_PIN_GROUP_FUNCS("i2s-clk-txrx", jz4780_i2s_clk_txrx,
-				jz4780_i2s_clk_txrx_funcs),
-	INGENIC_PIN_GROUP("i2s-clk-rx", jz4780_i2s_clk_rx, 1),
-	INGENIC_PIN_GROUP("i2s-sysclk", jz4780_i2s_sysclk, 2),
+	INGENIC_PIN_GROUP("i2s-data-tx", jz4760_i2s_data_tx0, 0),
+	INGENIC_PIN_GROUP("i2s-data-rx", jz4760_i2s_data_rx, 0),
+	INGENIC_PIN_GROUP_FUNCS("i2s-clk-txrx", jz4760_i2s_clk_txrx,
+				jz4760_i2s_clk_txrx_funcs),
+	INGENIC_PIN_GROUP("i2s-clk-rx", jz4770_i2s_clk_rx, 1),
+	INGENIC_PIN_GROUP("i2s-sysclk", jz4760_i2s_sysclk, 2),
 	INGENIC_PIN_GROUP("dmic", jz4780_dmic, 1),
 	INGENIC_PIN_GROUP("hdmi-ddc", jz4780_hdmi_ddc, 0),
 	INGENIC_PIN_GROUP("cim-data", jz4770_cim_8bit, 0),
@@ -3456,7 +3486,6 @@ static void ingenic_gpio_irq_ack(struct irq_data *irqd)
 	struct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);
 	struct ingenic_gpio_chip *jzgc = gpiochip_get_data(gc);
 	irq_hw_number_t irq = irqd_to_hwirq(irqd);
-	bool high;
 
 	if ((irqd_get_trigger_type(irqd) == IRQ_TYPE_EDGE_BOTH) &&
 	    !is_soc_or_above(jzgc->jzpc, ID_X2000)) {
@@ -3464,11 +3493,12 @@ static void ingenic_gpio_irq_ack(struct irq_data *irqd)
 		 * Switch to an interrupt for the opposite edge to the one that
 		 * triggered the interrupt being ACKed.
 		 */
-		high = ingenic_gpio_get_value(jzgc, irq);
-		if (high)
+		if (jzgc->levels & BIT(irq))
 			irq_set_type(jzgc, irq, IRQ_TYPE_LEVEL_LOW);
 		else
 			irq_set_type(jzgc, irq, IRQ_TYPE_LEVEL_HIGH);
+
+		jzgc->levels ^= BIT(irq);
 	}
 
 	if (is_soc_or_above(jzgc->jzpc, ID_JZ4770))
@@ -3508,6 +3538,10 @@ static int ingenic_gpio_irq_set_type(struct irq_data *irqd, unsigned int type)
 		bool high = ingenic_gpio_get_value(jzgc, irq);
 
 		type = high ? IRQ_TYPE_LEVEL_LOW : IRQ_TYPE_LEVEL_HIGH;
+		if (high)
+			jzgc->levels |= BIT(irq);
+		else
+			jzgc->levels &= ~BIT(irq);
 	}
 
 	irq_set_type(jzgc, irq, type);
diff --git a/drivers/power/supply/ingenic-battery.c b/drivers/power/supply/ingenic-battery.c
index 2e7fdfde47e..50bd1a48453 100644
--- a/drivers/power/supply/ingenic-battery.c
+++ b/drivers/power/supply/ingenic-battery.c
@@ -55,6 +55,18 @@ static int ingenic_battery_get_property(struct power_supply *psy,
 	}
 }
 
+static inline bool scale_type_supported(int type)
+{
+	switch (type) {
+	case IIO_VAL_INT_PLUS_NANO:
+	case IIO_VAL_INT_PLUS_MICRO:
+	case IIO_VAL_FRACTIONAL_LOG2:
+		return true;
+	default:
+		return false;
+	}
+}
+
 /* Set the most appropriate IIO channel voltage reference scale
  * based on the battery's max voltage.
  */
@@ -62,7 +74,8 @@ static int ingenic_battery_set_scale(struct ingenic_battery *bat)
 {
 	const int *scale_raw;
 	int scale_len, scale_type, best_idx = -1, best_mV, max_raw, i, ret;
-	u64 max_mV;
+	unsigned int offset;
+	u64 max_mV, scale_mV;
 
 	ret = iio_read_max_channel_raw(bat->channel, &max_raw);
 	if (ret) {
@@ -77,13 +90,48 @@ static int ingenic_battery_set_scale(struct ingenic_battery *bat)
 		dev_err(bat->dev, "Unable to read channel avail scale\n");
 		return ret;
 	}
-	if (ret != IIO_AVAIL_LIST || scale_type != IIO_VAL_FRACTIONAL_LOG2)
+
+	switch (ret) {
+	case IIO_AVAIL_LIST:
+		if (!scale_type_supported(scale_type)) {
+			dev_err(bat->dev, "Unsupported scale type\n");
+			return -EINVAL;
+		}
+
+		offset = 2;
+		break;
+	case IIO_AVAIL_LIST_WITH_TYPE:
+		for (i = 0; i < scale_len; i += 3) {
+			if (!scale_type_supported(scale_raw[i + 2])) {
+				dev_err(bat->dev, "Unsupported scale type\n");
+				return -EINVAL;
+			}
+		}
+
+		offset = 3;
+		scale_type = scale_raw[2];
+		break;
+	default:
+		dev_err(bat->dev, "Unsupported scale format\n");
 		return -EINVAL;
+	}
 
 	max_mV = bat->info->voltage_max_design_uv / 1000;
 
-	for (i = 0; i < scale_len; i += 2) {
-		u64 scale_mV = (max_raw * scale_raw[i]) >> scale_raw[i + 1];
+	for (i = 0; i < scale_len; i += offset) {
+		switch (scale_type) {
+		case IIO_VAL_INT_PLUS_MICRO:
+			scale_mV = max_raw * scale_raw[i]
+				+ max_raw * scale_raw[i + 1] / 1000;
+			break;
+		case IIO_VAL_INT_PLUS_NANO:
+			scale_mV = max_raw * scale_raw[i]
+				+ max_raw * scale_raw[i + 1] / 1000000;
+			break;
+		case IIO_VAL_FRACTIONAL_LOG2:
+			scale_mV = (max_raw * scale_raw[i]) >> scale_raw[i + 1];
+			break;
+		}
 
 		if (scale_mV < max_mV)
 			continue;
@@ -101,7 +149,7 @@ static int ingenic_battery_set_scale(struct ingenic_battery *bat)
 	}
 
 	/* Only set scale if there is more than one (fractional) entry */
-	if (scale_len > 2) {
+	if (scale_len > offset) {
 		ret = iio_write_channel_attribute(bat->channel,
 						  scale_raw[best_idx],
 						  scale_raw[best_idx + 1],
diff --git a/drivers/pwm/pwm-jz4740.c b/drivers/pwm/pwm-jz4740.c
index ef1293f2a89..ad24a3f7e36 100644
--- a/drivers/pwm/pwm-jz4740.c
+++ b/drivers/pwm/pwm-jz4740.c
@@ -27,6 +27,7 @@ struct soc_info {
 struct jz4740_pwm_chip {
 	struct pwm_chip chip;
 	struct regmap *map;
+	u32 pwm_channels_mask;
 };
 
 static inline struct jz4740_pwm_chip *to_jz4740(struct pwm_chip *chip)
@@ -37,14 +38,7 @@ static inline struct jz4740_pwm_chip *to_jz4740(struct pwm_chip *chip)
 static bool jz4740_pwm_can_use_chn(struct jz4740_pwm_chip *jz,
 				   unsigned int channel)
 {
-	/* Enable all TCU channels for PWM use by default except channels 0/1 */
-	u32 pwm_channels_mask = GENMASK(jz->chip.npwm - 1, 2);
-
-	device_property_read_u32(jz->chip.dev->parent,
-				 "ingenic,pwm-channels-mask",
-				 &pwm_channels_mask);
-
-	return !!(pwm_channels_mask & BIT(channel));
+	return !!(jz->pwm_channels_mask & BIT(channel));
 }
 
 static int jz4740_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)
@@ -96,16 +90,32 @@ static int jz4740_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
 	return 0;
 }
 
+static void jz4740_pwm_set_polarity(struct jz4740_pwm_chip *jz,
+				    unsigned int hwpwm,
+				    enum pwm_polarity polarity)
+{
+	unsigned int value = 0;
+
+	if (polarity == PWM_POLARITY_INVERSED)
+		value = TCU_TCSR_PWM_INITL_HIGH;
+
+	regmap_update_bits(jz->map, TCU_REG_TCSRc(hwpwm),
+			   TCU_TCSR_PWM_INITL_HIGH, value);
+}
+
 static void jz4740_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
 {
 	struct jz4740_pwm_chip *jz = to_jz4740(chip);
 
 	/*
-	 * Set duty > period. This trick allows the TCU channels in TCU2 mode to
-	 * properly return to their init level.
+	 * Set duty > period, then enable PWM mode and start the counter.
+	 * This trick allows to force the inactive pin level for the TCU2
+	 * channels.
 	 */
 	regmap_write(jz->map, TCU_REG_TDHRc(pwm->hwpwm), 0xffff);
 	regmap_write(jz->map, TCU_REG_TDFRc(pwm->hwpwm), 0x0);
+	regmap_set_bits(jz->map, TCU_REG_TCSRc(pwm->hwpwm), TCU_TCSR_PWM_EN);
+	regmap_write(jz->map, TCU_REG_TESR, BIT(pwm->hwpwm));
 
 	/*
 	 * Disable PWM output.
@@ -125,6 +135,7 @@ static int jz4740_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 	unsigned long long tmp = 0xffffull * NSEC_PER_SEC;
 	struct clk *clk = pwm_get_chip_data(pwm);
 	unsigned long period, duty;
+	enum pwm_polarity polarity;
 	long rate;
 	int err;
 
@@ -164,6 +175,9 @@ static int jz4740_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 	if (duty >= period)
 		duty = period - 1;
 
+	/* Restore regular polarity before disabling the channel. */
+	jz4740_pwm_set_polarity(jz4740, pwm->hwpwm, state->polarity);
+
 	jz4740_pwm_disable(chip, pwm);
 
 	err = clk_set_rate(clk, rate);
@@ -185,29 +199,30 @@ static int jz4740_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 	regmap_set_bits(jz4740->map, TCU_REG_TCSRc(pwm->hwpwm),
 			TCU_TCSR_PWM_SD);
 
-	/*
-	 * Set polarity.
-	 *
-	 * The PWM starts in inactive state until the internal timer reaches the
-	 * duty value, then becomes active until the timer reaches the period
-	 * value. In theory, we should then use (period - duty) as the real duty
-	 * value, as a high duty value would otherwise result in the PWM pin
-	 * being inactive most of the time.
-	 *
-	 * Here, we don't do that, and instead invert the polarity of the PWM
-	 * when it is active. This trick makes the PWM start with its active
-	 * state instead of its inactive state.
-	 */
-	if ((state->polarity == PWM_POLARITY_NORMAL) ^ state->enabled)
-		regmap_update_bits(jz4740->map, TCU_REG_TCSRc(pwm->hwpwm),
-				   TCU_TCSR_PWM_INITL_HIGH, 0);
-	else
-		regmap_update_bits(jz4740->map, TCU_REG_TCSRc(pwm->hwpwm),
-				   TCU_TCSR_PWM_INITL_HIGH,
-				   TCU_TCSR_PWM_INITL_HIGH);
-
-	if (state->enabled)
+	if (state->enabled) {
+		/*
+		 * Set polarity.
+		 *
+		 * The PWM starts in inactive state until the internal timer
+		 * reaches the duty value, then becomes active until the timer
+		 * reaches the period value. In theory, we should then use
+		 * (period - duty) as the real duty value, as a high duty value
+		 * would otherwise result in the PWM pin being inactive most of
+		 * the time.
+		 *
+		 * Here, we don't do that, and instead invert the polarity of
+		 * the PWM when it is active. This trick makes the PWM start
+		 * with its active state instead of its inactive state.
+		 */
+		if (state->polarity == PWM_POLARITY_NORMAL)
+			polarity = PWM_POLARITY_INVERSED;
+		else
+			polarity = PWM_POLARITY_NORMAL;
+
+		jz4740_pwm_set_polarity(jz4740, pwm->hwpwm, polarity);
+
 		jz4740_pwm_enable(chip, pwm);
+	}
 
 	return 0;
 }
@@ -233,6 +248,13 @@ static int jz4740_pwm_probe(struct platform_device *pdev)
 	if (!jz4740)
 		return -ENOMEM;
 
+	/* Enable all TCU channels for PWM use by default except channels 0/1 */
+	jz4740->pwm_channels_mask = GENMASK(jz4740->chip.npwm - 1, 2);
+
+	device_property_read_u32(dev->parent,
+				 "ingenic,pwm-channels-mask",
+				 &jz4740->pwm_channels_mask);
+
 	jz4740->map = device_node_to_regmap(dev->parent->of_node);
 	if (IS_ERR(jz4740->map)) {
 		dev_err(dev, "regmap not found: %ld\n", PTR_ERR(jz4740->map));
diff --git a/drivers/remoteproc/ingenic_rproc.c b/drivers/remoteproc/ingenic_rproc.c
index 9902cce2869..82eed93905a 100644
--- a/drivers/remoteproc/ingenic_rproc.c
+++ b/drivers/remoteproc/ingenic_rproc.c
@@ -184,7 +184,19 @@ static int ingenic_rproc_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, vpu);
 
 	mem = platform_get_resource_byname(pdev, IORESOURCE_MEM, "aux");
-	vpu->aux_base = devm_ioremap_resource(dev, mem);
+
+	/*
+	 * Request only the registers we use.
+	 * Regs 0x4->0xc will be used in a hwspinlock driver.
+	 */
+	if (!devm_request_mem_region(dev, mem->start, 0x4, dev_name(dev)) ||
+	    !devm_request_mem_region(dev, mem->start + REG_AUX_MSG_ACK,
+				     0x10, dev_name(dev))) {
+		dev_err(dev, "unable to request I/O memory region\n");
+		return -EBUSY;
+	}
+
+	vpu->aux_base = devm_ioremap(dev, mem->start, resource_size(mem));
 	if (IS_ERR(vpu->aux_base)) {
 		dev_err(dev, "Failed to ioremap\n");
 		return PTR_ERR(vpu->aux_base);
diff --git a/drivers/rtc/rtc-jz4740.c b/drivers/rtc/rtc-jz4740.c
index bafa7d1b9b8..56e0586582e 100644
--- a/drivers/rtc/rtc-jz4740.c
+++ b/drivers/rtc/rtc-jz4740.c
@@ -5,6 +5,7 @@
  *	 JZ4740 SoC RTC driver
  */
 
+#include <linux/bitfield.h>
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/io.h>
@@ -42,6 +43,9 @@
 #define JZ_RTC_CTRL_AE		BIT(2)
 #define JZ_RTC_CTRL_ENABLE	BIT(0)
 
+#define JZ_RTC_REGULATOR_NC1HZ_MASK	GENMASK(15, 0)
+#define JZ_RTC_REGULATOR_ADJC_MASK	GENMASK(25, 16)
+
 /* Magic value to enable writes on jz4780 */
 #define JZ_RTC_WENR_MAGIC	0xA55A
 
@@ -62,6 +66,7 @@ struct jz4740_rtc {
 	enum jz4740_rtc_type type;
 
 	struct rtc_device *rtc;
+	struct clk *clk;
 
 	struct clk_hw clk32k;
 
@@ -218,12 +223,51 @@ static int jz4740_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)
 	return jz4740_rtc_ctrl_set_bits(rtc, JZ_RTC_CTRL_AF_IRQ, enable);
 }
 
+static int jz4740_rtc_read_offset(struct device *dev, long *offset)
+{
+	struct jz4740_rtc *rtc = dev_get_drvdata(dev);
+	long rate = clk_get_rate(rtc->clk);
+	s32 nc1hz, adjc, offset1k;
+	u32 reg;
+
+	reg = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_REGULATOR);
+	nc1hz = FIELD_GET(JZ_RTC_REGULATOR_NC1HZ_MASK, reg);
+	adjc = FIELD_GET(JZ_RTC_REGULATOR_ADJC_MASK, reg);
+
+	offset1k = (nc1hz - rate + 1) * 1024L + adjc;
+	*offset = offset1k * 1000000L / (rate * 1024L);
+
+	return 0;
+}
+
+static int jz4740_rtc_set_offset(struct device *dev, long offset)
+{
+	struct jz4740_rtc *rtc = dev_get_drvdata(dev);
+	long rate = clk_get_rate(rtc->clk);
+	s32 offset1k, adjc, nc1hz;
+
+	offset1k = div_s64_rem(offset * rate * 1024LL, 1000000LL, &adjc);
+	nc1hz = rate - 1 + offset1k / 1024L;
+
+	if (adjc < 0) {
+		nc1hz--;
+		adjc += 1024;
+	}
+
+	nc1hz = FIELD_PREP(JZ_RTC_REGULATOR_NC1HZ_MASK, nc1hz);
+	adjc = FIELD_PREP(JZ_RTC_REGULATOR_ADJC_MASK, adjc);
+
+	return jz4740_rtc_reg_write(rtc, JZ_REG_RTC_REGULATOR, nc1hz | adjc);
+}
+
 static const struct rtc_class_ops jz4740_rtc_ops = {
 	.read_time	= jz4740_rtc_read_time,
 	.set_time	= jz4740_rtc_set_time,
 	.read_alarm	= jz4740_rtc_read_alarm,
 	.set_alarm	= jz4740_rtc_set_alarm,
 	.alarm_irq_enable = jz4740_rtc_alarm_irq_enable,
+	.read_offset	= jz4740_rtc_read_offset,
+	.set_offset	= jz4740_rtc_set_offset,
 };
 
 static irqreturn_t jz4740_rtc_irq(int irq, void *data)
@@ -365,6 +409,7 @@ static int jz4740_rtc_probe(struct platform_device *pdev)
 
 	spin_lock_init(&rtc->lock);
 
+	rtc->clk = clk;
 	platform_set_drvdata(pdev, rtc);
 
 	device_init_wakeup(dev, 1);
diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig
index 9a8cf3de061..439422fcc74 100644
--- a/drivers/usb/musb/Kconfig
+++ b/drivers/usb/musb/Kconfig
@@ -101,7 +101,6 @@ config USB_MUSB_JZ4740
 	tristate "JZ4740"
 	depends on OF
 	depends on MIPS || COMPILE_TEST
-	depends on USB_MUSB_GADGET
 	select USB_ROLE_SWITCH
 
 config USB_MUSB_MEDIATEK
diff --git a/drivers/usb/musb/jz4740.c b/drivers/usb/musb/jz4740.c
index b38df922627..536a7811f4b 100644
--- a/drivers/usb/musb/jz4740.c
+++ b/drivers/usb/musb/jz4740.c
@@ -23,6 +23,7 @@ struct jz4740_glue {
 	struct musb		*musb;
 	struct clk		*clk;
 	struct usb_role_switch	*role_sw;
+	enum musb_mode		mode;
 };
 
 static irqreturn_t jz4740_musb_interrupt(int irq, void *__hci)
@@ -30,6 +31,7 @@ static irqreturn_t jz4740_musb_interrupt(int irq, void *__hci)
 	unsigned long	flags;
 	irqreturn_t	retval = IRQ_NONE, retval_dma = IRQ_NONE;
 	struct musb	*musb = __hci;
+	struct jz4740_glue *glue = dev_get_drvdata(musb->controller->parent);
 
 	if (IS_ENABLED(CONFIG_USB_INVENTRA_DMA) && musb->dma_controller)
 		retval_dma = dma_controller_irq(irq, musb->dma_controller);
@@ -41,12 +43,13 @@ static irqreturn_t jz4740_musb_interrupt(int irq, void *__hci)
 	musb->int_rx = musb_readw(musb->mregs, MUSB_INTRRX);
 
 	/*
-	 * The controller is gadget only, the state of the host mode IRQ bits is
-	 * undefined. Mask them to make sure that the musb driver core will
-	 * never see them set
+	 * When in gadget mode, mask the host mode IRQ bits to make sure
+	 * that the musb driver core will never see them set.
 	 */
-	musb->int_usb &= MUSB_INTR_SUSPEND | MUSB_INTR_RESUME |
-			 MUSB_INTR_RESET | MUSB_INTR_SOF;
+	if (glue->mode == MUSB_PERIPHERAL) {
+		musb->int_usb &= MUSB_INTR_SUSPEND | MUSB_INTR_RESUME |
+				 MUSB_INTR_RESET | MUSB_INTR_SOF;
+	}
 
 	if (musb->int_usb || musb->int_tx || musb->int_rx)
 		retval = musb_interrupt(musb);
@@ -199,12 +202,6 @@ static const struct musb_platform_ops jz4740_musb_ops = {
 #endif
 };
 
-static const struct musb_hdrc_platform_data jz4740_musb_pdata = {
-	.mode		= MUSB_PERIPHERAL,
-	.config		= &jz4740_musb_config,
-	.platform_ops	= &jz4740_musb_ops,
-};
-
 static struct musb_fifo_cfg jz4770_musb_fifo_cfg[] = {
 	{ .hw_ep_num = 1, .style = FIFO_TX, .maxpacket = 512, },
 	{ .hw_ep_num = 1, .style = FIFO_RX, .maxpacket = 512, },
@@ -226,30 +223,28 @@ static struct musb_hdrc_config jz4770_musb_config = {
 	.fifo_cfg_size	= ARRAY_SIZE(jz4770_musb_fifo_cfg),
 };
 
-static const struct musb_hdrc_platform_data jz4770_musb_pdata = {
-	.mode		= MUSB_PERIPHERAL, /* TODO: support OTG */
-	.config		= &jz4770_musb_config,
-	.platform_ops	= &jz4740_musb_ops,
-};
-
 static int jz4740_probe(struct platform_device *pdev)
 {
 	struct device			*dev = &pdev->dev;
-	const struct musb_hdrc_platform_data *pdata;
 	struct platform_device		*musb;
 	struct jz4740_glue		*glue;
 	struct clk			*clk;
 	int				ret;
+	struct musb_hdrc_platform_data	pdata = {
+		.platform_ops = &jz4740_musb_ops,
+		.config = device_get_match_data(dev),
+	};
 
 	glue = devm_kzalloc(dev, sizeof(*glue), GFP_KERNEL);
 	if (!glue)
 		return -ENOMEM;
 
-	pdata = of_device_get_match_data(dev);
-	if (!pdata) {
-		dev_err(dev, "missing platform data\n");
-		return -EINVAL;
-	}
+	if (device_property_present(dev, "dr_mode"))
+		pdata.mode = musb_get_mode(dev);
+	else
+		pdata.mode = MUSB_PERIPHERAL;
+
+	glue->mode = pdata.mode;
 
 	musb = platform_device_alloc("musb-hdrc", PLATFORM_DEVID_AUTO);
 	if (!musb) {
@@ -287,7 +282,7 @@ static int jz4740_probe(struct platform_device *pdev)
 		goto err_clk_disable;
 	}
 
-	ret = platform_device_add_data(musb, pdata, sizeof(*pdata));
+	ret = platform_device_add_data(musb, &pdata, sizeof(pdata));
 	if (ret) {
 		dev_err(dev, "failed to add platform_data\n");
 		goto err_clk_disable;
@@ -316,9 +311,9 @@ static void jz4740_remove(struct platform_device *pdev)
 	clk_disable_unprepare(glue->clk);
 }
 
-static const struct of_device_id jz4740_musb_of_match[] = {
-	{ .compatible = "ingenic,jz4740-musb", .data = &jz4740_musb_pdata },
-	{ .compatible = "ingenic,jz4770-musb", .data = &jz4770_musb_pdata },
+static struct of_device_id jz4740_musb_of_match[] = {
+	{ .compatible = "ingenic,jz4740-musb", .data = &jz4740_musb_config },
+	{ .compatible = "ingenic,jz4770-musb", .data = &jz4770_musb_config },
 	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, jz4740_musb_of_match);
diff --git a/include/linux/clk.h b/include/linux/clk.h
index 06f1b292f8a..87258c60a0b 100644
--- a/include/linux/clk.h
+++ b/include/linux/clk.h
@@ -872,6 +872,17 @@ struct clk *clk_get_parent(struct clk *clk);
  */
 struct clk *clk_get_sys(const char *dev_id, const char *con_id);
 
+/**
+ * clk_get_first_to_set_rate - get a pointer to the clock that will
+ *   effectively modify its rate when clk_set_rate(clk) is called
+ *   (might be clk itself, or any ancestor)
+ * @clk: clock source
+ *
+ * Returns struct clk corresponding to the matched clock source, or
+ * NULL on error.
+ */
+struct clk *clk_get_first_to_set_rate(struct clk *clk);
+
 /**
  * clk_save_context - save clock context for poweroff
  *
@@ -1050,6 +1061,11 @@ static inline struct clk *clk_get_parent(struct clk *clk)
 	return NULL;
 }
 
+static inline struct clk *clk_get_first_to_set_rate(struct clk *clk)
+{
+	return NULL;
+}
+
 static inline struct clk *clk_get_sys(const char *dev_id, const char *con_id)
 {
 	return NULL;
diff --git a/include/linux/iio/afe/rescale.h b/include/linux/iio/afe/rescale.h
index 6eecb435488..74de2962f86 100644
--- a/include/linux/iio/afe/rescale.h
+++ b/include/linux/iio/afe/rescale.h
@@ -26,6 +26,8 @@ struct rescale {
 	s32 numerator;
 	s32 denominator;
 	s32 offset;
+	int scale_len;
+	int *scale_data;
 };
 
 int rescale_process_scale(struct rescale *rescale, int scale_type,
diff --git a/include/linux/iio/consumer.h b/include/linux/iio/consumer.h
index e9910b41d48..e4bcbe467ad 100644
--- a/include/linux/iio/consumer.h
+++ b/include/linux/iio/consumer.h
@@ -319,7 +319,8 @@ int iio_read_min_channel_raw(struct iio_channel *chan, int *val);
  * @vals:		Available values read back.
  * @length:		Number of entries in vals.
  *
- * Returns an error code, IIO_AVAIL_RANGE or IIO_AVAIL_LIST.
+ * Returns an error code, IIO_AVAIL_RANGE, IIO_AVAIL_LIST or
+ * IIO_AVAIL_LIST_WITH_TYPE.
  *
  * For ranges, three vals are always returned; min, step and max.
  * For lists, all the possible values are enumerated.
@@ -339,7 +340,8 @@ int iio_read_avail_channel_raw(struct iio_channel *chan,
  * @length:		Number of entries in vals.
  * @attribute:		info attribute to be read back.
  *
- * Returns an error code, IIO_AVAIL_RANGE or IIO_AVAIL_LIST.
+ * Returns an error code, IIO_AVAIL_RANGE, IIO_AVAIL_LIST or
+ * IIO_AVAIL_LIST_WITH_TYPE.
  */
 int iio_read_avail_channel_attribute(struct iio_channel *chan,
 				     const int **vals, int *type, int *length,
diff --git a/include/linux/iio/types.h b/include/linux/iio/types.h
index 117bde7d6ad..3361b3ed76c 100644
--- a/include/linux/iio/types.h
+++ b/include/linux/iio/types.h
@@ -36,6 +36,7 @@ enum iio_event_info {
 enum iio_available_type {
 	IIO_AVAIL_LIST,
 	IIO_AVAIL_RANGE,
+	IIO_AVAIL_LIST_WITH_TYPE,
 };
 
 enum iio_chan_info_enum {
diff --git a/include/net/ipx.h b/include/net/ipx.h
new file mode 100644
index 00000000000..9d1342807b5
--- /dev/null
+++ b/include/net/ipx.h
@@ -0,0 +1,171 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _NET_INET_IPX_H_
+#define _NET_INET_IPX_H_
+/*
+ *	The following information is in its entirety obtained from:
+ *
+ *	Novell 'IPX Router Specification' Version 1.10 
+ *		Part No. 107-000029-001
+ *
+ *	Which is available from ftp.novell.com
+ */
+
+#include <linux/netdevice.h>
+#include <net/datalink.h>
+#include <linux/ipx.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/refcount.h>
+
+struct ipx_address {
+	__be32  net;
+	__u8    node[IPX_NODE_LEN]; 
+	__be16  sock;
+};
+
+#define ipx_broadcast_node	"\377\377\377\377\377\377"
+#define ipx_this_node           "\0\0\0\0\0\0"
+
+#define IPX_MAX_PPROP_HOPS 8
+
+struct ipxhdr {
+	__be16			ipx_checksum __packed;
+#define IPX_NO_CHECKSUM	cpu_to_be16(0xFFFF)
+	__be16			ipx_pktsize __packed;
+	__u8			ipx_tctrl;
+	__u8			ipx_type;
+#define IPX_TYPE_UNKNOWN	0x00
+#define IPX_TYPE_RIP		0x01	/* may also be 0 */
+#define IPX_TYPE_SAP		0x04	/* may also be 0 */
+#define IPX_TYPE_SPX		0x05	/* SPX protocol */
+#define IPX_TYPE_NCP		0x11	/* $lots for docs on this (SPIT) */
+#define IPX_TYPE_PPROP		0x14	/* complicated flood fill brdcast */
+	struct ipx_address	ipx_dest __packed;
+	struct ipx_address	ipx_source __packed;
+};
+
+/* From af_ipx.c */
+extern int sysctl_ipx_pprop_broadcasting;
+
+struct ipx_interface {
+	/* IPX address */
+	__be32			if_netnum;
+	unsigned char		if_node[IPX_NODE_LEN];
+	refcount_t		refcnt;
+
+	/* physical device info */
+	struct net_device	*if_dev;
+	struct datalink_proto	*if_dlink;
+	__be16			if_dlink_type;
+
+	/* socket support */
+	unsigned short		if_sknum;
+	struct hlist_head	if_sklist;
+	spinlock_t		if_sklist_lock;
+
+	/* administrative overhead */
+	int			if_ipx_offset;
+	unsigned char		if_internal;
+	unsigned char		if_primary;
+	
+	struct list_head	node; /* node in ipx_interfaces list */
+};
+
+struct ipx_route {
+	__be32			ir_net;
+	struct ipx_interface	*ir_intrfc;
+	unsigned char		ir_routed;
+	unsigned char		ir_router_node[IPX_NODE_LEN];
+	struct list_head	node; /* node in ipx_routes list */
+	refcount_t		refcnt;
+};
+
+struct ipx_cb {
+	u8	ipx_tctrl;
+	__be32	ipx_dest_net;
+	__be32	ipx_source_net;
+	struct {
+		__be32 netnum;
+		int index;
+	} last_hop;
+};
+
+#include <net/sock.h>
+
+struct ipx_sock {
+	/* struct sock has to be the first member of ipx_sock */
+	struct sock		sk;
+	struct ipx_address	dest_addr;
+	struct ipx_interface	*intrfc;
+	__be16			port;
+#ifdef CONFIG_IPX_INTERN
+	unsigned char		node[IPX_NODE_LEN];
+#endif
+	unsigned short		type;
+	/*
+	 * To handle special ncp connection-handling sockets for mars_nwe,
+ 	 * the connection number must be stored in the socket.
+	 */
+	unsigned short		ipx_ncp_conn;
+};
+
+static inline struct ipx_sock *ipx_sk(struct sock *sk)
+{
+	return (struct ipx_sock *)sk;
+}
+
+#define IPX_SKB_CB(__skb) ((struct ipx_cb *)&((__skb)->cb[0]))
+
+#define IPX_MIN_EPHEMERAL_SOCKET	0x4000
+#define IPX_MAX_EPHEMERAL_SOCKET	0x7fff
+
+extern struct list_head ipx_routes;
+extern rwlock_t ipx_routes_lock;
+
+extern struct list_head ipx_interfaces;
+struct ipx_interface *ipx_interfaces_head(void);
+extern spinlock_t ipx_interfaces_lock;
+
+extern struct ipx_interface *ipx_primary_net;
+
+int ipx_proc_init(void);
+void ipx_proc_exit(void);
+
+const char *ipx_frame_name(__be16);
+const char *ipx_device_name(struct ipx_interface *intrfc);
+
+static __inline__ void ipxitf_hold(struct ipx_interface *intrfc)
+{
+	refcount_inc(&intrfc->refcnt);
+}
+
+void ipxitf_down(struct ipx_interface *intrfc);
+struct ipx_interface *ipxitf_find_using_net(__be32 net);
+int ipxitf_send(struct ipx_interface *intrfc, struct sk_buff *skb, char *node);
+__be16 ipx_cksum(struct ipxhdr *packet, int length);
+int ipxrtr_add_route(__be32 network, struct ipx_interface *intrfc,
+		     unsigned char *node);
+void ipxrtr_del_routes(struct ipx_interface *intrfc);
+int ipxrtr_route_packet(struct sock *sk, struct sockaddr_ipx *usipx,
+			struct msghdr *msg, size_t len, int noblock);
+int ipxrtr_route_skb(struct sk_buff *skb);
+struct ipx_route *ipxrtr_lookup(__be32 net);
+int ipxrtr_ioctl(unsigned int cmd, void __user *arg);
+
+static __inline__ void ipxitf_put(struct ipx_interface *intrfc)
+{
+	if (refcount_dec_and_test(&intrfc->refcnt))
+		ipxitf_down(intrfc);
+}
+
+static __inline__ void ipxrtr_hold(struct ipx_route *rt)
+{
+	        refcount_inc(&rt->refcnt);
+}
+
+static __inline__ void ipxrtr_put(struct ipx_route *rt)
+{
+	        if (refcount_dec_and_test(&rt->refcnt))
+			                kfree(rt);
+}
+#endif /* _NET_INET_IPX_H_ */
diff --git a/include/uapi/linux/ipx.h b/include/uapi/linux/ipx.h
new file mode 100644
index 00000000000..3168137adae
--- /dev/null
+++ b/include/uapi/linux/ipx.h
@@ -0,0 +1,87 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _IPX_H_
+#define _IPX_H_
+#include <linux/libc-compat.h>	/* for compatibility with glibc netipx/ipx.h */
+#include <linux/types.h>
+#include <linux/sockios.h>
+#include <linux/socket.h>
+#define IPX_NODE_LEN	6
+#define IPX_MTU		576
+
+#if __UAPI_DEF_SOCKADDR_IPX
+struct sockaddr_ipx {
+	__kernel_sa_family_t sipx_family;
+	__be16		sipx_port;
+	__be32		sipx_network;
+	unsigned char 	sipx_node[IPX_NODE_LEN];
+	__u8		sipx_type;
+	unsigned char	sipx_zero;	/* 16 byte fill */
+};
+#endif /* __UAPI_DEF_SOCKADDR_IPX */
+
+/*
+ * So we can fit the extra info for SIOCSIFADDR into the address nicely
+ */
+#define sipx_special	sipx_port
+#define sipx_action	sipx_zero
+#define IPX_DLTITF	0
+#define IPX_CRTITF	1
+
+#if __UAPI_DEF_IPX_ROUTE_DEFINITION
+struct ipx_route_definition {
+	__be32        ipx_network;
+	__be32        ipx_router_network;
+	unsigned char ipx_router_node[IPX_NODE_LEN];
+};
+#endif /* __UAPI_DEF_IPX_ROUTE_DEFINITION */
+
+#if __UAPI_DEF_IPX_INTERFACE_DEFINITION
+struct ipx_interface_definition {
+	__be32        ipx_network;
+	unsigned char ipx_device[16];
+	unsigned char ipx_dlink_type;
+#define IPX_FRAME_NONE		0
+#define IPX_FRAME_SNAP		1
+#define IPX_FRAME_8022		2
+#define IPX_FRAME_ETHERII	3
+#define IPX_FRAME_8023		4
+#define IPX_FRAME_TR_8022       5 /* obsolete */
+	unsigned char ipx_special;
+#define IPX_SPECIAL_NONE	0
+#define IPX_PRIMARY		1
+#define IPX_INTERNAL		2
+	unsigned char ipx_node[IPX_NODE_LEN];
+};
+#endif /* __UAPI_DEF_IPX_INTERFACE_DEFINITION */
+
+#if __UAPI_DEF_IPX_CONFIG_DATA
+struct ipx_config_data {
+	unsigned char	ipxcfg_auto_select_primary;
+	unsigned char	ipxcfg_auto_create_interfaces;
+};
+#endif /* __UAPI_DEF_IPX_CONFIG_DATA */
+
+/*
+ * OLD Route Definition for backward compatibility.
+ */
+
+#if __UAPI_DEF_IPX_ROUTE_DEF
+struct ipx_route_def {
+	__be32		ipx_network;
+	__be32		ipx_router_network;
+#define IPX_ROUTE_NO_ROUTER	0
+	unsigned char	ipx_router_node[IPX_NODE_LEN];
+	unsigned char	ipx_device[16];
+	unsigned short	ipx_flags;
+#define IPX_RT_SNAP		8
+#define IPX_RT_8022		4
+#define IPX_RT_BLUEBOOK		2
+#define IPX_RT_ROUTED		1
+};
+#endif /* __UAPI_DEF_IPX_ROUTE_DEF */
+
+#define SIOCAIPXITFCRT		(SIOCPROTOPRIVATE)
+#define SIOCAIPXPRISLT		(SIOCPROTOPRIVATE + 1)
+#define SIOCIPXCFGDATA		(SIOCPROTOPRIVATE + 2)
+#define SIOCIPXNCPCONN		(SIOCPROTOPRIVATE + 3)
+#endif /* _IPX_H_ */
diff --git a/sound/soc/jz4740/jz4740-i2s.c b/sound/soc/jz4740/jz4740-i2s.c
index 51761953161..78899078ce4 100644
--- a/sound/soc/jz4740/jz4740-i2s.c
+++ b/sound/soc/jz4740/jz4740-i2s.c
@@ -39,6 +39,7 @@
 #define JZ_AIC_CONF_SYNC_CLK_MASTER	BIT(1)
 #define JZ_AIC_CONF_ENABLE		BIT(0)
 
+#define JZ_AIC_CTRL_CHANNELS		GENMASK(26, 24)
 #define JZ_AIC_CTRL_OUTPUT_SAMPLE_SIZE	GENMASK(21, 19)
 #define JZ_AIC_CTRL_INPUT_SAMPLE_SIZE	GENMASK(18, 16)
 #define JZ_AIC_CTRL_ENABLE_RX_DMA	BIT(15)
@@ -252,9 +253,9 @@ static int jz4740_i2s_hw_params(struct snd_pcm_substream *substream,
 	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
 {
 	struct jz4740_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+	unsigned int sample_size, channels = params_channels(params);
 	struct regmap_field *div_field;
 	unsigned long i2sdiv_max;
-	unsigned int sample_size;
 	uint32_t ctrl, conf;
 	int div = 1;
 
@@ -282,10 +283,14 @@ static int jz4740_i2s_hw_params(struct snd_pcm_substream *substream,
 		ctrl &= ~JZ_AIC_CTRL_OUTPUT_SAMPLE_SIZE;
 		ctrl |= FIELD_PREP(JZ_AIC_CTRL_OUTPUT_SAMPLE_SIZE, sample_size);
 
-		if (params_channels(params) == 1)
+		if (dai->driver->playback.channels_max > 2) {
+			ctrl &= ~JZ_AIC_CTRL_CHANNELS;
+			ctrl |= FIELD_PREP(JZ_AIC_CTRL_CHANNELS, channels - 1);
+		} else if (channels == 1) {
 			ctrl |= JZ_AIC_CTRL_MONO_TO_STEREO;
-		else
+		} else {
 			ctrl &= ~JZ_AIC_CTRL_MONO_TO_STEREO;
+		}
 
 		div_field = i2s->field_i2sdiv_playback;
 		i2sdiv_max = GENMASK(i2s->soc_info->field_i2sdiv_playback.msb,
@@ -386,7 +391,7 @@ static const struct i2s_soc_info x1000_i2s_soc_info = {
 static struct snd_soc_dai_driver jz4770_i2s_dai = {
 	.playback = {
 		.channels_min = 1,
-		.channels_max = 2,
+		.channels_max = 8,
 		.rates = SNDRV_PCM_RATE_CONTINUOUS,
 		.formats = JZ4740_I2S_FMTS,
 	},
@@ -407,14 +412,6 @@ static const struct i2s_soc_info jz4770_i2s_soc_info = {
 	.field_i2sdiv_playback	= REG_FIELD(JZ_REG_AIC_CLK_DIV, 0, 3),
 };
 
-static const struct i2s_soc_info jz4780_i2s_soc_info = {
-	.dai			= &jz4770_i2s_dai,
-	.field_rx_fifo_thresh	= REG_FIELD(JZ_REG_AIC_CONF, 24, 27),
-	.field_tx_fifo_thresh	= REG_FIELD(JZ_REG_AIC_CONF, 16, 20),
-	.field_i2sdiv_capture	= REG_FIELD(JZ_REG_AIC_CLK_DIV, 8, 11),
-	.field_i2sdiv_playback	= REG_FIELD(JZ_REG_AIC_CLK_DIV, 0, 3),
-};
-
 static int jz4740_i2s_suspend(struct snd_soc_component *component)
 {
 	struct jz4740_i2s *i2s = snd_soc_component_get_drvdata(component);
@@ -492,7 +489,7 @@ static const struct of_device_id jz4740_of_matches[] = {
 	{ .compatible = "ingenic,jz4740-i2s", .data = &jz4740_i2s_soc_info },
 	{ .compatible = "ingenic,jz4760-i2s", .data = &jz4760_i2s_soc_info },
 	{ .compatible = "ingenic,jz4770-i2s", .data = &jz4770_i2s_soc_info },
-	{ .compatible = "ingenic,jz4780-i2s", .data = &jz4780_i2s_soc_info },
+	{ .compatible = "ingenic,jz4780-i2s", .data = &jz4770_i2s_soc_info },
 	{ .compatible = "ingenic,x1000-i2s", .data = &x1000_i2s_soc_info },
 	{ /* sentinel */ }
 };
@@ -541,7 +538,7 @@ static int jz4740_i2s_dev_probe(struct platform_device *pdev)
 	struct jz4740_i2s *i2s;
 	struct resource *mem;
 	void __iomem *regs;
-	int ret;
+	int ret, flags = 0;
 
 	i2s = devm_kzalloc(dev, sizeof(*i2s), GFP_KERNEL);
 	if (!i2s)
@@ -583,8 +580,10 @@ static int jz4740_i2s_dev_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	return devm_snd_dmaengine_pcm_register(dev, NULL,
-		SND_DMAENGINE_PCM_FLAG_COMPAT);
+	if (device_property_present(dev, "rx-tx"))
+		flags |= SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX;
+
+	return devm_snd_dmaengine_pcm_register(dev, NULL, flags);
 }
 
 static struct platform_driver jz4740_i2s_driver = {
