Index: linux-6.6/drivers/gpu/drm/drm_modes.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/drm_modes.c
+++ linux-6.6/drivers/gpu/drm/drm_modes.c
@@ -48,6 +48,7 @@
 #include <drm/drm_print.h>
 
 #include "drm_crtc_internal.h"
+#include "drm_modes_low_dotclock.h"
 
 /**
  * drm_mode_debug_printmodeline - print a mode to dmesg
@@ -2028,7 +2029,7 @@ static int drm_mode_parse_cmdline_res_mo
 					   struct drm_cmdline_mode *mode)
 {
 	const char *str_start = str;
-	bool rb = false, cvt = false;
+	bool rb = false, cvt = false, low_dotclock = false;
 	int xres = 0, yres = 0;
 	int remaining, i;
 	char *end_ptr;
@@ -2058,6 +2059,12 @@ static int drm_mode_parse_cmdline_res_mo
 		case 'R':
 			rb = true;
 			break;
+		case 'S':
+		case 'c':
+		case 'z':
+			low_dotclock = true;
+			DRM_DEBUG_KMS("Found one of the S/c/z low dotclock mode flag");
+			break;
 		default:
 			/*
 			 * Try to pass that to our extras parsing
@@ -2082,6 +2089,7 @@ static int drm_mode_parse_cmdline_res_mo
 	mode->yres = yres;
 	mode->cvt = cvt;
 	mode->rb = rb;
+	mode->low_dotclock = low_dotclock;
 
 	return 0;
 }
@@ -2545,7 +2553,11 @@ drm_mode_create_from_cmdline_mode(struct
 
 	if (strlen(cmd->name))
 		mode = drm_named_mode(dev, cmd);
-	else if (cmd->cvt)
+	else if (cmd->low_dotclock)
+        mode = drm_mode_low_dotclock_res(dev,
+                                    cmd->xres, cmd->yres,
+                                    cmd->interlace);
+        else if (cmd->cvt)
 		mode = drm_cvt_mode(dev,
 				    cmd->xres, cmd->yres,
 				    cmd->refresh_specified ? cmd->refresh : 60,
Index: linux-6.6/drivers/gpu/drm/drm_modes_low_dotclock.c
===================================================================
--- /dev/null
+++ linux-6.6/drivers/gpu/drm/drm_modes_low_dotclock.c
@@ -0,0 +1,155 @@
+/*
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <drm/drm_modes.h>
+#include <drm/drm_print.h>
+
+const static struct drm_display_mode drm_low_dotclock_modes[] = {
+/* 15 kHz modes */
+	/* 320x240 60.00 - generic_15 */
+		/* Switchres: Modeline "320x240_60 15.660000KHz 60.000000Hz" 6.514560 320 333 364 416 240 241 244 261 -hsync -vsync */
+		{ DRM_MODE("320x240", DRM_MODE_TYPE_DRIVER,
+			6514, 320, 333, 364, 416, 0, 240, 241, 244, 261, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 384x288 50.00 - generic_15 */
+		/* Switchres: Modeline "384x288_50 15.650000KHz 50.000000Hz" 7.809350 384 400 437 499 288 291 294 313 -hsync -vsync */
+		{ DRM_MODE("384x288", DRM_MODE_TYPE_DRIVER,
+			7809, 384, 400, 437, 499, 0, 288, 291, 294, 313, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x240 60.00 - generic_15 */
+		/* Switchres: Modeline "640x240_60 15.660000KHz 60.000000Hz" 13.013460 640 666 727 831 240 241 244 261 -hsync -vsync */
+		{ DRM_MODE("640x240", DRM_MODE_TYPE_DRIVER,
+			13013, 640, 666, 727, 831, 0, 240, 241, 244, 261, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x480 60.00 - generic_15 */
+		/* Switchres: Modeline "640x480_60i 15.690000KHz 60.000000Hz" 13.038390 640 666 727 831 480 483 489 523 interlace -hsync -vsync */
+		{ DRM_MODE("640x480i", DRM_MODE_TYPE_DRIVER,
+			13038, 640, 666, 727, 831, 0, 480, 483, 489, 523, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		DRM_MODE_FLAG_INTERLACE) },
+       /* 648x480 60.00 - generic_15 */
+               /* Switchres: Modeline "648x480_60i 15.690000KHz 60.000000Hz" 13.210980 648 674 736 842 480 483 489 523 interlace -hsync -vsync */
+               { DRM_MODE("648x480i", DRM_MODE_TYPE_DRIVER,
+                       13210, 648, 674, 736, 842, 0, 480, 483, 489, 523, 0,
+                       DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+               DRM_MODE_FLAG_INTERLACE) },
+	/* 720x480 59.95 - generic_15 */
+		/* Switchres: Modeline "720x480_59i 15.676925KHz 59.950001Hz" 14.657925 720 749 818 935 480 483 489 523 interlace -hsync -vsync */
+		{ DRM_MODE("720x480i", DRM_MODE_TYPE_DRIVER,
+			14657, 720, 749, 818, 935, 0, 480, 483, 489, 523, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		DRM_MODE_FLAG_INTERLACE) },
+	/* 768x576 50.00 - generic_15 */
+		/* Switchres: Modeline "768x576_50i 15.675000KHz 50.000000Hz" 15.627975 768 799 872 997 576 583 589 627 interlace -hsync -vsync */
+		{ DRM_MODE("768x576i", DRM_MODE_TYPE_DRIVER,
+			15627, 768, 799, 872, 997, 0, 576, 583, 589, 627, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		DRM_MODE_FLAG_INTERLACE) },
+	/* 800x576 50.00 - generic_15 */
+		/* Switchres: Modeline "800x576_50i 15.675000KHz 50.000000Hz" 16.302000 800 833 910 1040 576 583 589 627 interlace -hsync -vsync */
+		{ DRM_MODE("800x576i", DRM_MODE_TYPE_DRIVER,
+			16302, 800, 833, 910, 1040, 0, 576, 583, 589, 627, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		DRM_MODE_FLAG_INTERLACE) },
+	/* 1280x480 60.00 - generic_15 */
+		/* Switchres: Modeline "1280x480_60i 15.690000KHz 60.000000Hz" 26.108160 1280 1332 1455 1664 480 483 489 523 interlace -hsync -vsync */
+		{ DRM_MODE("1280x480i", DRM_MODE_TYPE_DRIVER,
+			26108, 1280, 1332, 1455, 1664, 0, 480, 483, 489, 523, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		DRM_MODE_FLAG_INTERLACE) },
+
+/* 25 kHz modes */
+	/* 512x384 58.59 - arcade_25ex */
+		/* Switchres: Modeline "512x384_58 24.959340KHz 58.590000Hz" 15.973977 512 525 589 640 384 391 396 426 -hsync -vsync */
+		{ DRM_MODE("512x384", DRM_MODE_TYPE_DRIVER,
+			15973, 512, 525, 589, 640, 0, 384, 391, 396, 426, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 800x600 60.00 - arcade_25ex */
+		/* Switchres: Modeline "800x600_60i 24.930000KHz 60.000000Hz" 24.930000 800 820 920 1000 600 687 697 831 interlace -hsync -vsync */
+		{ DRM_MODE("800x600i", DRM_MODE_TYPE_DRIVER,
+			24930, 800, 820, 920, 1000, 0, 600, 687, 697, 831, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		DRM_MODE_FLAG_INTERLACE) },
+	/* 1024x768 50.00 - arcade_25ex */
+		/* Switchres: Modeline "1024x768_50i 24.975000KHz 50.000000Hz" 31.968000 1024 1050 1178 1280 768 855 865 999 interlace -hsync -vsync */
+		{ DRM_MODE("1024x768i", DRM_MODE_TYPE_DRIVER,
+			31968, 1024, 1050, 1178, 1280, 0, 768, 855, 865, 999, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		DRM_MODE_FLAG_INTERLACE) },
+	/* 1024x240 60.00 - arcade_25ex */
+		/* Switchres: Modeline "1024x240_60 24.900000KHz 60.000000Hz" 31.822200 1024 1049 1176 1278 240 313 318 415 -hsync -vsync */
+		{ DRM_MODE("1024x240", DRM_MODE_TYPE_DRIVER,
+			31822, 1024, 1049, 1176, 1278, 0, 240, 313, 318, 415, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1280x240 60.00 - arcade_25ex */
+		/* Switchres: Modeline "1280x240_60 24.900000KHz 60.000000Hz" 39.790200 1280 1312 1471 1598 240 313 318 415 -hsync -vsync */
+		{ DRM_MODE("1280x240", DRM_MODE_TYPE_DRIVER,
+			39790, 1280, 1312, 1471, 1598, 0, 240, 313, 318, 415, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+
+/* 31 kHz modes */
+	/* 640x480 60.00 - arcade_31 */
+		/* Switchres: Modeline "640x480_60 31.500000KHz 60.000000Hz" 25.452000 640 664 760 808 480 491 493 525 -hsync -vsync */
+		{ DRM_MODE("640x480", DRM_MODE_TYPE_DRIVER,
+			25452, 640, 664, 760, 808, 0, 480, 491, 493, 525, 0,
+			DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+};
+
+/**
+ * drm_display_mode - get a fixed modeline
+ * @dev: drm device
+ * @hdisplay: hdisplay size
+ * @vdisplay: vdisplay size
+ * @interlaced: whether to compute an interlaced mode
+ *
+ * This function returns a modeline among predefined low dotclock modes. These are fixed
+ * modelines, until automatic mode generation gets added into kernel.
+ * No need to specify 15 or 25kHz, not the vertical refresh rate as it's only 60Hz for now.
+ * This is a very basic function. Duplicate modes (320x240 and 1024x768) are not
+ * handled, the first result will be returned.
+ *
+ * Returns:
+ * A low dotclock drm modeline
+ */
+struct drm_display_mode *drm_mode_low_dotclock_res(struct drm_device *dev,
+				int hsize, int vsize, bool interlace)
+{
+	int i;
+
+	DRM_DEBUG_KMS("Entering drm_mode_low_dotclock_res for resolution %dx%d (interlace: %s)", hsize, vsize, interlace ? "true" : "false");
+	for (i = 0; i < ARRAY_SIZE(drm_low_dotclock_modes); i++) {
+		const struct drm_display_mode *ptr = &drm_low_dotclock_modes[i];
+		if (hsize != ptr->hdisplay)
+			continue;
+		if (vsize != ptr->vdisplay)
+			continue;
+		//if ((refresh != 0) && (refresh != drm_mode_vrefresh(ptr)))
+		//	continue;
+		if (((! interlace) && (ptr->flags & DRM_MODE_FLAG_INTERLACE)) \
+		    || ((interlace) && ! (ptr->flags & DRM_MODE_FLAG_INTERLACE)))
+			continue;
+		DRM_DEBUG_KMS("Found a low dotclock mode for %dx%d (interlace: %d)", hsize, vsize, interlace);
+		drm_mode_debug_printmodeline(ptr);
+		return drm_mode_duplicate(dev, ptr);
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(drm_mode_low_dotclock_res);
Index: linux-6.6/drivers/gpu/drm/drm_modes_low_dotclock.h
===================================================================
--- /dev/null
+++ linux-6.6/drivers/gpu/drm/drm_modes_low_dotclock.h
@@ -0,0 +1,23 @@
+/*
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+struct drm_display_mode *drm_mode_low_dotclock_res(struct drm_device *dev,
+				int hsize, int vsize, bool interlace);
Index: linux-6.6/drivers/gpu/drm/drm_probe_helper.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/drm_probe_helper.c
+++ linux-6.6/drivers/gpu/drm/drm_probe_helper.c
@@ -458,21 +458,26 @@ static int __drm_helper_update_and_valid
 		mode_flags |= DRM_MODE_FLAG_3D_MASK;
 
 	list_for_each_entry(mode, &connector->modes, head) {
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] starting with mode state : %d\n", connector->base.id, connector->name, mode->status);
 		if (mode->status != MODE_OK)
 			continue;
 
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] before drm_mode_validate_driver mode is : %d\n", connector->base.id, connector->name, mode->status);
 		mode->status = drm_mode_validate_driver(dev, mode);
 		if (mode->status != MODE_OK)
 			continue;
 
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] before drm_mode_validate_size mode is : %d\n", connector->base.id, connector->name, mode->status);
 		mode->status = drm_mode_validate_size(mode, maxX, maxY);
 		if (mode->status != MODE_OK)
 			continue;
 
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] before drm_mode_validate_flag mode is : %d\n", connector->base.id, connector->name, mode->status);
 		mode->status = drm_mode_validate_flag(mode, mode_flags);
 		if (mode->status != MODE_OK)
 			continue;
 
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] before drm_mode_validate_pipeline mode is : %d\n", connector->base.id, connector->name, mode->status);
 		ret = drm_mode_validate_pipeline(mode, connector, ctx,
 						 &mode->status);
 		if (ret) {
@@ -486,9 +491,11 @@ static int __drm_helper_update_and_valid
 				return -EDEADLK;
 		}
 
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] before drm_mode_validate_ycbcr420 mode is : %d\n", connector->base.id, connector->name, mode->status);
 		if (mode->status != MODE_OK)
 			continue;
 		mode->status = drm_mode_validate_ycbcr420(mode, connector);
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] in the end mode is : %d\n", connector->base.id, connector->name, mode->status);
 	}
 
 	return 0;
@@ -558,6 +565,7 @@ int drm_helper_probe_single_connector_mo
 {
 	struct drm_device *dev = connector->dev;
 	struct drm_display_mode *mode;
+	struct drm_cmdline_mode *cmdline_mode;
 	int count = 0, ret;
 	enum drm_connector_status old_status;
 	struct drm_modeset_acquire_ctx ctx;
@@ -644,10 +652,13 @@ retry:
 		goto exit;
 	}
 
+	cmdline_mode = &connector->cmdline_mode;
+
 	count = drm_helper_probe_get_modes(connector);
 
 	if (count == 0 && (connector->status == connector_status_connected ||
-			   connector->status == connector_status_unknown)) {
+			   connector->status == connector_status_unknown) &&
+			   ! cmdline_mode->low_dotclock) {
 		count = drm_add_modes_noedid(connector, 1024, 768);
 
 		/*
Index: linux-6.6/include/drm/drm_connector.h
===================================================================
--- linux-6.6.orig/include/drm/drm_connector.h
+++ linux-6.6/include/drm/drm_connector.h
@@ -1424,6 +1424,13 @@ struct drm_cmdline_mode {
 	bool interlace;
 
 	/**
+	 * @low_dotclock:
+	 *
+	 * Flag is enabled if a valid low dotclock resolution is defined.
+	 */
+	bool low_dotclock;
+
+	/**
 	 * @cvt:
 	 *
 	 * The timings will be calculated using the VESA Coordinated
Index: linux-6.6/drivers/gpu/drm/Makefile
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/Makefile
+++ linux-6.6/drivers/gpu/drm/Makefile
@@ -30,6 +30,7 @@ drm-y := \
 	drm_ioctl.o \
 	drm_lease.o \
 	drm_managed.o \
+	drm_modes_low_dotclock.o \
 	drm_mm.o \
 	drm_mode_config.o \
 	drm_mode_object.o \
Index: linux-6.5/drivers/gpu/drm/drm_vblank.c
===================================================================
--- linux-6.5.orig/drivers/gpu/drm/drm_vblank.c
+++ linux-6.5/drivers/gpu/drm/drm_vblank.c
@@ -285,6 +285,7 @@ static void drm_update_vblank_count(stru
 	int count = DRM_TIMESTAMP_MAXRETRIES;
 	int framedur_ns = vblank->framedur_ns;
 	u32 max_vblank_count = drm_max_vblank_count(dev, pipe);
+	struct drm_crtc *crtc = drm_crtc_from_index(dev, pipe);
 
 	/*
 	 * Interrupts were disabled prior to this call, so deal with counter
@@ -303,12 +304,17 @@ static void drm_update_vblank_count(stru
 		rc = drm_get_last_vbltimestamp(dev, pipe, &t_vblank, in_vblank_irq);
 	} while (cur_vblank != __get_vblank_counter(dev, pipe) && --count > 0);
 
-	if (max_vblank_count) {
+	/* We can't use the hw counter for interlace modes */
+	if (max_vblank_count && !(crtc->hwmode.flags & DRM_MODE_FLAG_INTERLACE)) {
 		/* trust the hw counter when it's around */
 		diff = (cur_vblank - vblank->last) & max_vblank_count;
 	} else if (rc && framedur_ns) {
 		u64 diff_ns = ktime_to_ns(ktime_sub(t_vblank, vblank->time));
 
+		/* Make sure we don't have a negative diff, if so discard it */
+		if (t_vblank < vblank->time)
+			return;
+
 		/*
 		 * Figure out how many vblanks we've missed based
 		 * on the difference in the timestamps and the
Index: linux-6.6/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ linux-6.6/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -5503,6 +5503,8 @@ static void fill_stream_properties_from_
 			timing_out->flags.HSYNC_POSITIVE_POLARITY = 1;
 		if (mode_in->flags & DRM_MODE_FLAG_PVSYNC)
 			timing_out->flags.VSYNC_POSITIVE_POLARITY = 1;
+		if (mode_in->flags & DRM_MODE_FLAG_INTERLACE)
+			timing_out->flags.INTERLACE = 1;
 	}
 
 	if (stream->signal == SIGNAL_TYPE_HDMI_TYPE_A) {
@@ -6083,6 +6085,8 @@ create_stream_for_sink(struct amdgpu_dm_
 
 	if (recalculate_timing)
 		drm_mode_set_crtcinfo(&saved_mode, 0);
+	else if (!dm_state || mode.flags & DRM_MODE_FLAG_INTERLACE)
+		drm_mode_set_crtcinfo(&mode, 0);
 
 	/*
 	 * If scaling is enabled and refresh rate didn't change
@@ -6623,8 +6627,7 @@ enum drm_mode_status amdgpu_dm_connector
 	struct dc_stream_state *stream;
 	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
 
-	if ((mode->flags & DRM_MODE_FLAG_INTERLACE) ||
-			(mode->flags & DRM_MODE_FLAG_DBLSCAN))
+	if (mode->flags & DRM_MODE_FLAG_DBLSCAN)
 		return result;
 
 	/*
@@ -7320,7 +7323,7 @@ void amdgpu_dm_connector_init_helper(str
 	aconnector->connector_id = link_index;
 	aconnector->bl_idx = -1;
 	aconnector->dc_link = link;
-	aconnector->base.interlace_allowed = false;
+	aconnector->base.interlace_allowed = true;
 	aconnector->base.doublescan_allowed = false;
 	aconnector->base.stereo_allowed = false;
 	aconnector->base.dpms = DRM_MODE_DPMS_OFF;
Index: linux-6.6/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ linux-6.6/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2684,6 +2684,9 @@ static void update_scaler(struct pipe_ct
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = per_pixel_alpha;
 	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_36BPP;
 	/* scaler configuration */
+	pipe_ctx->plane_res.scl_data.lb_params.interleave_en =
+			pipe_ctx->stream->timing.flags.INTERLACE? 1:0;
+
 	pipe_ctx->plane_res.dpp->funcs->dpp_set_scaler(
 			pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data);
 }
@@ -3712,8 +3715,7 @@ int dcn10_get_vupdate_offset_from_vsync(
 
 	asic_blank_end = (patched_crtc_timing.v_total -
 			vesa_sync_start -
-			patched_crtc_timing.v_border_top)
-			* interlace_factor;
+			patched_crtc_timing.v_border_top); // * interlace_factor;
 
 	return asic_blank_end -
 			pipe_ctx->pipe_dlg_param.vstartup_start + 1;
Index: linux-6.6/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_optc.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_optc.c
+++ linux-6.6/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_optc.c
@@ -608,10 +608,6 @@ bool optc1_validate_timing(
 		timing->timing_3d_format != TIMING_3D_FORMAT_INBAND_FA)
 		return false;
 
-	/* Temporarily blocking interlacing mode until it's supported */
-	if (timing->flags.INTERLACE == 1)
-		return false;
-
 	/* Check maximum number of pixels supported by Timing Generator
 	 * (Currently will never fail, in order to fail needs display which
 	 * needs more than 8192 horizontal and
Index: linux-6.6/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hwseq.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hwseq.c
+++ linux-6.6/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hwseq.c
@@ -1572,6 +1572,9 @@ static void dcn20_update_dchubp_dpp(
 		pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->plane_state->per_pixel_alpha;
 		ASSERT(pipe_ctx->plane_res.scl_data.lb_params.depth == LB_PIXEL_DEPTH_36BPP);
 		/* scaler configuration */
+		pipe_ctx->plane_res.scl_data.lb_params.interleave_en =
+			pipe_ctx->stream->timing.flags.INTERLACE? 1:0;
+
 		pipe_ctx->plane_res.dpp->funcs->dpp_set_scaler(
 				pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data);
 	}
Index: linux-6.6/drivers/gpu/drm/amd/display/dc/dml/calcs/dcn_calc_auto.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/dc/dml/calcs/dcn_calc_auto.c
+++ linux-6.6/drivers/gpu/drm/amd/display/dc/dml/calcs/dcn_calc_auto.c
@@ -61,7 +61,8 @@ void scaler_settings_calculation(struct
 			v->v_ratio[k] = v->h_ratio[k];
 		}
 		if (v->interlace_output[k] == 1.0) {
-			v->v_ratio[k] = 2.0 * v->v_ratio[k];
+			// Commented out: this makes scale and ratio taps validation fail
+			//v->v_ratio[k] = 2.0 * v->v_ratio[k];
 		}
 		if (v->underscan_output[k] == 1.0) {
 			v->h_ratio[k] = v->h_ratio[k] * v->under_scan_factor;
Index: linux-6.6/drivers/gpu/drm/amd/display/dc/dml/calcs/dcn_calcs.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/dc/dml/calcs/dcn_calcs.c
+++ linux-6.6/drivers/gpu/drm/amd/display/dc/dml/calcs/dcn_calcs.c
@@ -446,6 +446,7 @@ static void pipe_ctx_to_e2e_pipe_params
 	input->dest.vupdate_offset = pipe->pipe_dlg_param.vupdate_offset;
 	input->dest.vupdate_offset = pipe->pipe_dlg_param.vupdate_offset;
 	input->dest.vupdate_width = pipe->pipe_dlg_param.vupdate_width;
+	input->dest.interlaced = pipe->stream->timing.flags.INTERLACE;
 
 }
 
@@ -900,7 +901,7 @@ bool dcn_validate_bandwidth(
 			continue;
 
 		v->underscan_output[input_idx] = false; /* taken care of in recout already*/
-		v->interlace_output[input_idx] = false;
+		v->interlace_output[input_idx] = pipe->stream->timing.flags.INTERLACE? 1.0 : false;
 
 		v->htotal[input_idx] = pipe->stream->timing.h_total;
 		v->vtotal[input_idx] = pipe->stream->timing.v_total;
@@ -1219,14 +1220,12 @@ bool dcn_validate_bandwidth(
 
 			asic_blank_end = (pipe->stream->timing.v_total -
 						vesa_sync_start -
-						pipe->stream->timing.v_border_top)
-			* (pipe->stream->timing.flags.INTERLACE ? 1 : 0);
+						pipe->stream->timing.v_border_top);
 
 			asic_blank_start = asic_blank_end +
 						(pipe->stream->timing.v_border_top +
 						pipe->stream->timing.v_addressable +
-						pipe->stream->timing.v_border_bottom)
-			* (pipe->stream->timing.flags.INTERLACE ? 1 : 0);
+						pipe->stream->timing.v_border_bottom);
 
 			pipe->pipe_dlg_param.vblank_start = asic_blank_start;
 			pipe->pipe_dlg_param.vblank_end = asic_blank_end;
Index: linux-6.6/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.c
+++ linux-6.6/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.c
@@ -592,9 +592,11 @@ static void fetch_pipe_params(struct dis
 		mode_lib->vba.VRatioChroma[mode_lib->vba.NumberOfActivePlanes] = scl->vscl_ratio_c;
 		mode_lib->vba.ScalerEnabled[mode_lib->vba.NumberOfActivePlanes] = scl->scl_enable;
 		mode_lib->vba.Interlace[mode_lib->vba.NumberOfActivePlanes] = dst->interlaced;
+
 		if (dst->interlaced && !ip->ptoi_supported) {
-			mode_lib->vba.VRatio[mode_lib->vba.NumberOfActivePlanes] *= 2.0;
-			mode_lib->vba.VRatioChroma[mode_lib->vba.NumberOfActivePlanes] *= 2.0;
+			// Commented out: this makes scale and ratio taps validation fail
+			//mode_lib->vba.VRatio[mode_lib->vba.NumberOfActivePlanes] *= 2.0;
+			//mode_lib->vba.VRatioChroma[mode_lib->vba.NumberOfActivePlanes] *= 2.0;
 		}
 		mode_lib->vba.htaps[mode_lib->vba.NumberOfActivePlanes] = taps->htaps;
 		mode_lib->vba.vtaps[mode_lib->vba.NumberOfActivePlanes] = taps->vtaps;
Index: linux-6.6/drivers/gpu/drm/drm_probe_helper.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/drm_probe_helper.c
+++ linux-6.6/drivers/gpu/drm/drm_probe_helper.c
@@ -162,6 +162,9 @@ static int drm_helper_probe_add_cmdline_
 				continue;
 		}
 
+		if ((mode->flags & DRM_MODE_FLAG_INTERLACE) != cmdline_mode->interlace)
+			continue;
+
 		/* Mark the matching mode as being preferred by the user */
 		mode->type |= DRM_MODE_TYPE_USERDEF;
 		return 0;
Index: linux-6.6/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ linux-6.6/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2729,6 +2729,9 @@ static void dce110_program_front_end_for
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != NULL;
 
+	// We're enabling interleave manually after setting crtc registers so this flag has no effect
+	pipe_ctx->plane_res.scl_data.lb_params.interleave_en = pipe_ctx->stream->timing.flags.INTERLACE? 1:0;
+
 	program_scaler(dc, pipe_ctx);
 
 	mi->funcs->mem_input_program_surface_config(
Index: linux-6.6/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator.c
+++ linux-6.6/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator.c
@@ -1132,10 +1132,6 @@ bool dce110_timing_generator_validate_ti
 	if (timing->timing_3d_format != TIMING_3D_FORMAT_NONE)
 		return false;
 
-	/* Temporarily blocking interlacing mode until it's supported */
-	if (timing->flags.INTERLACE == 1)
-		return false;
-
 	/* Check maximum number of pixels supported by Timing Generator
 	 * (Currently will never fail, in order to fail needs display which
 	 * needs more than 8192 horizontal and
@@ -1949,7 +1945,7 @@ void dce110_tg_set_overscan_color(struct
 	dm_write_reg(ctx, addr, value);
 }
 
-void dce110_tg_program_timing(struct timing_generator *tg,
+void dce_tg_program_timing(struct timing_generator *tg,
 	const struct dc_crtc_timing *timing,
 	int vready_offset,
 	int vstartup_start,
@@ -1964,6 +1960,28 @@ void dce110_tg_program_timing(struct tim
 		dce110_timing_generator_program_blanking(tg, timing);
 }
 
+void dce110_tg_program_timing(struct timing_generator *tg,
+	const struct dc_crtc_timing *timing,
+	int vready_offset,
+	int vstartup_start,
+	int vupdate_offset,
+	int vupdate_width,
+	const enum signal_type signal,
+	bool use_vbios)
+{
+	dce_tg_program_timing(tg, timing, 0, 0, 0, 0, 0, use_vbios);
+
+	/* Set interleave */
+	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
+	uint32_t address = CRTC_REG(mmLB_DATA_FORMAT);
+	uint32_t value = dm_read_reg(tg->ctx, address);
+	uint32_t interleave_en_mask = ~(1 << 3);
+	value = (value & interleave_en_mask) | ((timing->flags.INTERLACE == 1? 1 : 0) << 3);
+	dm_write_reg(tg->ctx, address, value);
+
+	DRM_DEBUG_KMS("Calamity: addr[%08x] value[%08x]\n", address, value);
+}
+
 bool dce110_tg_is_blanked(struct timing_generator *tg)
 {
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
Index: linux-6.6/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator.h
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator.h
+++ linux-6.6/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator.h
@@ -264,6 +264,15 @@ void dce110_tg_program_timing(struct tim
 	const enum signal_type signal,
 	bool use_vbios);
 
+void dce_tg_program_timing(struct timing_generator *tg,
+	const struct dc_crtc_timing *timing,
+	int vready_offset,
+	int vstartup_start,
+	int vupdate_offset,
+	int vupdate_width,
+	const enum signal_type signal,
+	bool use_vbios);
+
 bool dce110_tg_is_blanked(struct timing_generator *tg);
 
 void dce110_tg_set_blank(struct timing_generator *tg,
Index: linux-6.6/drivers/gpu/drm/amd/display/dc/dce120/dce120_timing_generator.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/dc/dce120/dce120_timing_generator.c
+++ linux-6.6/drivers/gpu/drm/amd/display/dc/dce120/dce120_timing_generator.c
@@ -704,6 +704,15 @@ static void dce120_tg_program_timing(str
 		dce110_timing_generator_program_timing_generator(tg, timing);
 	else
 		dce120_timing_generator_program_blanking(tg, timing);
+
+	/* Set interleave */
+	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
+	uint32_t value = dm_read_reg_soc15(tg->ctx, mmLB0_LB_DATA_FORMAT, tg110->offsets.crtc);
+	uint32_t interleave_en_mask = ~(1 << 3);
+	value = (value & interleave_en_mask) | ((timing->flags.INTERLACE == 1? 1 : 0) << 3);
+	dm_write_reg_soc15(tg->ctx, mmLB0_LB_DATA_FORMAT, tg110->offsets.crtc, value);
+
+	DRM_DEBUG_KMS("Calamity: addr[%08x] value[%08x]\n",  mmLB0_LB_DATA_FORMAT + tg110->offsets.crtc, value);
 }
 
 static bool dce120_tg_is_blanked(struct timing_generator *tg)
Index: linux-6.6/drivers/gpu/drm/amd/display/dc/dce60/dce60_hw_sequencer.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/dc/dce60/dce60_hw_sequencer.c
+++ linux-6.6/drivers/gpu/drm/amd/display/dc/dce60/dce60_hw_sequencer.c
@@ -311,6 +311,9 @@ dce60_program_front_end_for_pipe(
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
 
+	// We're enabling interleave manually after setting crtc registers so this flag has no effect
+	pipe_ctx->plane_res.scl_data.lb_params.interleave_en = pipe_ctx->stream->timing.flags.INTERLACE? 1:0;
+
 	dce60_program_scaler(dc, pipe_ctx);
 
 	mi->funcs->mem_input_program_surface_config(
Index: linux-6.6/drivers/gpu/drm/amd/display/dc/dce60/dce60_timing_generator.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/dc/dce60/dce60_timing_generator.c
+++ linux-6.6/drivers/gpu/drm/amd/display/dc/dce60/dce60_timing_generator.c
@@ -117,7 +117,17 @@ static void program_timing(struct timing
 	if (!use_vbios)
 		program_pix_dur(tg, timing->pix_clk_100hz);
 
-	dce110_tg_program_timing(tg, timing, 0, 0, 0, 0, 0, use_vbios);
+	dce_tg_program_timing(tg, timing, 0, 0, 0, 0, 0, use_vbios);
+
+	/* Set interleave */
+	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
+	uint32_t address = CRTC_REG(mmDATA_FORMAT);
+	uint32_t value = dm_read_reg(tg->ctx, address);
+	uint32_t interleave_en_mask = ~(1 << 0);
+	value = (value & interleave_en_mask) | (timing->flags.INTERLACE == 1? 1 : 0);
+	dm_write_reg(tg->ctx, address, value);
+
+	DRM_DEBUG_KMS("Calamity: addr[%08x] value[%08x]\n", address, value);
 }
 
 static void dce60_timing_generator_enable_advanced_request(
Index: linux-6.6/drivers/gpu/drm/amd/display/dc/dml/calcs/dce_calcs.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/amd/display/dc/dml/calcs/dce_calcs.c
+++ linux-6.6/drivers/gpu/drm/amd/display/dc/dml/calcs/dce_calcs.c
@@ -2871,7 +2871,8 @@ static void populate_initial_data(
 			data->bytes_per_pixel[num_displays + 4] = 4;
 			break;
 		}
-		data->interlace_mode[num_displays + 4] = false;
+		DRM_DEBUG_KMS("Calamity: pipe[%d] interlace: [%d]\n", i, pipe[i].stream->timing.flags.INTERLACE);
+		data->interlace_mode[num_displays + 4] = pipe[i].stream->timing.flags.INTERLACE;
 		data->stereo_mode[num_displays + 4] = bw_def_mono;
 
 
@@ -3000,7 +3001,8 @@ static void populate_initial_data(
 			data->bytes_per_pixel[num_displays + 4] = 4;
 		}
 
-		data->interlace_mode[num_displays + 4] = false;
+		DRM_DEBUG_KMS("Calamity: pipe[%d] interlace: [%d]\n", i, pipe[i].stream->timing.flags.INTERLACE);
+		data->interlace_mode[num_displays + 4] = pipe[i].stream->timing.flags.INTERLACE;
 		data->stereo_mode[num_displays + 4] = bw_def_mono;
 		num_displays++;
 	}
Index: linux-6.4/drivers/gpu/drm/amd/amdgpu/amdgpu_pll.c
===================================================================
--- linux-6.4.orig/drivers/gpu/drm/amd/amdgpu/amdgpu_pll.c
+++ linux-6.4/drivers/gpu/drm/amd/amdgpu/amdgpu_pll.c
@@ -89,9 +89,9 @@ static void amdgpu_pll_get_fb_ref_div(st
 
 	/* limit reference * post divider to a maximum */
 	if (adev->family == AMDGPU_FAMILY_SI)
-		ref_div_max = min(100 / post_div, ref_div_max);
+		ref_div_max = max(min(100 / post_div, ref_div_max), 1u);
 	else
-		ref_div_max = min(128 / post_div, ref_div_max);
+		ref_div_max = max(min(128 / post_div, ref_div_max), 1u);
 
 	/* get matching reference and feedback divider */
 	*ref_div = min(max(DIV_ROUND_CLOSEST(den, post_div), 1u), ref_div_max);
Index: linux-6.6/drivers/gpu/drm/drm_connector.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/drm_connector.c
+++ linux-6.6/drivers/gpu/drm/drm_connector.c
@@ -275,6 +275,7 @@ static int __drm_connector_init(struct d
 
 	INIT_LIST_HEAD(&connector->global_connector_list_entry);
 	INIT_LIST_HEAD(&connector->probed_modes);
+	INIT_LIST_HEAD(&connector->user_modes);
 	INIT_LIST_HEAD(&connector->modes);
 	mutex_init(&connector->mutex);
 	mutex_init(&connector->edid_override_mutex);
@@ -559,6 +560,11 @@ void drm_connector_cleanup(struct drm_co
 	list_for_each_entry_safe(mode, t, &connector->probed_modes, head)
 		drm_mode_remove(connector, mode);
 
+	DRM_DEBUG_KMS("[CONNECTOR:%d:%s] Cleaning up.\n",
+				      connector->base.id, connector->name);
+	list_for_each_entry_safe(mode, t, &connector->user_modes, head)
+		drm_mode_remove(connector, mode);
+
 	list_for_each_entry_safe(mode, t, &connector->modes, head)
 		drm_mode_remove(connector, mode);
 
Index: linux-6.6/drivers/gpu/drm/drm_ioctl.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/drm_ioctl.c
+++ linux-6.6/drivers/gpu/drm/drm_ioctl.c
@@ -665,8 +665,8 @@ static const struct drm_ioctl_desc drm_i
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_SETGAMMA, drm_mode_gamma_set_ioctl, DRM_MASTER),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETENCODER, drm_mode_getencoder, 0),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETCONNECTOR, drm_mode_getconnector, 0),
-	DRM_IOCTL_DEF(DRM_IOCTL_MODE_ATTACHMODE, drm_noop, DRM_MASTER),
-	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DETACHMODE, drm_noop, DRM_MASTER),
+	DRM_IOCTL_DEF(DRM_IOCTL_MODE_ATTACHMODE, drm_mode_attachmode_ioctl, DRM_MASTER),
+	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DETACHMODE, drm_mode_detachmode_ioctl, DRM_MASTER),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETPROPERTY, drm_mode_getproperty_ioctl, 0),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_SETPROPERTY, drm_connector_property_set_ioctl, DRM_MASTER),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETPROPBLOB, drm_mode_getblob_ioctl, 0),
Index: linux-6.6/drivers/gpu/drm/drm_mode_object.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/drm_mode_object.c
+++ linux-6.6/drivers/gpu/drm/drm_mode_object.c
@@ -143,6 +143,7 @@ struct drm_mode_object *__drm_mode_objec
 	obj = idr_find(&dev->mode_config.object_idr, id);
 	if (obj && type != DRM_MODE_OBJECT_ANY && obj->type != type)
 		obj = NULL;
+
 	if (obj && obj->id != id)
 		obj = NULL;
 
Index: linux-6.6/drivers/gpu/drm/drm_modes.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/drm_modes.c
+++ linux-6.6/drivers/gpu/drm/drm_modes.c
@@ -41,6 +41,7 @@
 #include <video/of_videomode.h>
 #include <video/videomode.h>
 
+#include <drm/drm_drv.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_device.h>
 #include <drm/drm_edid.h>
@@ -595,6 +596,168 @@ err_free_mode:
 EXPORT_SYMBOL(drm_analog_tv_mode);
 
 /**
+ * drm_mode_attachmode - add a mode to the user mode list
+ * @dev: DRM device
+ * @connector: connector to add the mode to
+ * @mode: mode to add
+ *
+ * Add @mode to @connector's user mode list.
+ */
+void drm_mode_attachmode(struct drm_device *dev,
+				struct drm_connector *connector,
+				struct drm_display_mode *mode)
+{
+	WARN_ON(!mutex_is_locked(&connector->dev->mode_config.mutex));
+
+	list_add_tail(&mode->head, &connector->user_modes);
+	//drm_connector_list_update(connector);
+}
+EXPORT_SYMBOL(drm_mode_attachmode);
+
+int drm_mode_detachmode(struct drm_device *dev,
+			       struct drm_connector *connector,
+			       struct drm_display_mode *mode)
+{
+	int found = 0;
+	int ret = 0;
+	struct drm_display_mode *match_mode, *t;
+
+	list_for_each_entry_safe(match_mode, t, &connector->user_modes, head) {
+		if (drm_mode_equal(match_mode, mode)) {
+			list_del(&match_mode->head);
+			drm_mode_destroy(dev, match_mode);
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found)
+		ret = -EINVAL;
+
+	return ret;
+}
+EXPORT_SYMBOL(drm_mode_detachmode);
+
+/**
+ * drm_mode_attachmode - Attach a user mode to a connector
+ * @dev: drm device for the ioctl
+ * @data: data pointer for the ioctl
+ * @file_priv: drm file for the ioctl call
+ *
+ * This attaches a user specified mode to an connector.
+ * Called by the user via ioctl.
+ *
+ * RETURNS:
+ * Zero on success, errno on failure.
+ */
+int drm_mode_attachmode_ioctl(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv)
+{
+	struct drm_mode_mode_cmd *mode_cmd = data;
+	struct drm_connector *connector;
+	struct drm_display_mode *mode;
+	struct drm_mode_object *obj;
+	struct drm_mode_modeinfo *umode = &mode_cmd->mode;
+	enum drm_mode_status mode_status;
+	int ret;
+
+	DRM_DEBUG_KMS("Will drm_core_check_feature for connector %u\n", mode_cmd->connector_id);
+	if (!drm_core_check_feature(dev, DRIVER_MODESET))
+		return -EINVAL;
+
+	drm_modeset_lock_all(dev);
+
+	DRM_DEBUG_KMS("Modeline \"%s\": %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x\n", umode->name, DIV_ROUND_CLOSEST(umode->clock * 1000, umode->htotal * umode->vtotal), umode->clock, \
+	umode->hdisplay, umode->hsync_start, umode->hsync_end, umode->htotal, \
+	umode->vdisplay, umode->vsync_start, umode->vsync_end, umode->vtotal, \
+	umode->type, umode->flags);
+
+	DRM_DEBUG_KMS("Will drm_mode_object_find for connector %u\n", mode_cmd->connector_id);
+	obj = drm_mode_object_find(dev, file_priv, mode_cmd->connector_id, DRM_MODE_OBJECT_CONNECTOR);
+	if (!obj) {
+		DRM_DEBUG_KMS("drm_mode_object_find failed\n");
+		ret = -EINVAL;
+		goto out;
+	}
+	connector = obj_to_connector(obj);
+
+	mode = drm_mode_create(dev);
+	if (!mode) {
+		DRM_DEBUG_KMS("drm_mode_create failed\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	DRM_DEBUG_KMS("Will drm_mode_convert_umode for connector %u\n", mode_cmd->connector_id);
+	ret = drm_mode_convert_umode(dev, mode, umode);
+	if (ret) {
+		DRM_DEBUG_KMS("Invalid mode\n");
+		drm_mode_destroy(dev, mode);
+		goto out;
+	}
+	mode_status = drm_mode_validate_driver(dev, mode);
+	if (mode_status != MODE_OK) {
+		DRM_DEBUG_KMS("Mode failed drm_mode_validate_driver\n");
+		drm_mode_destroy(dev, mode);
+		goto out;
+	}
+	drm_mode_attachmode(dev, connector, mode);
+out:
+	drm_modeset_unlock_all(dev);
+	return ret;
+}
+EXPORT_SYMBOL(drm_mode_attachmode_ioctl);
+
+/**
+ * drm_mode_detachmode - Detach a user specified mode from a connector
+ * @dev: drm device for the ioctl
+ * @data: data pointer for the ioctl
+ * @file_priv: drm file for the ioctl call
+ *
+ * Called by the user via ioctl.
+ *
+ * RETURNS:
+ * Zero on success, errno on failure.
+ */
+int drm_mode_detachmode_ioctl(struct drm_device *dev,
+			      void *data, struct drm_file *file_priv)
+{
+	struct drm_mode_object *obj;
+	struct drm_mode_mode_cmd *mode_cmd = data;
+	struct drm_connector *connector;
+	struct drm_display_mode mode;
+	struct drm_mode_modeinfo *umode = &mode_cmd->mode;
+	int ret;
+
+	DRM_DEBUG_KMS("Got connector id %d\n", mode_cmd->connector_id);
+	DRM_DEBUG_KMS("Checking core features\n");
+	if (!drm_core_check_feature(dev, DRIVER_MODESET))
+		return -EINVAL;
+
+	drm_modeset_lock_all(dev);
+
+	DRM_DEBUG_KMS("Finding drm mode object\n");
+	obj = drm_mode_object_find(dev, file_priv, mode_cmd->connector_id, DRM_MODE_OBJECT_CONNECTOR);
+	if (!obj) {
+		ret = -EINVAL;
+		goto out;
+	}
+	connector = obj_to_connector(obj);
+
+	ret = drm_mode_convert_umode(dev, &mode, umode);
+	if (ret) {
+		DRM_DEBUG_KMS("Invalid mode\n");
+		goto out;
+	}
+
+	ret = drm_mode_detachmode(dev, connector, &mode);
+out:
+	drm_modeset_unlock_all(dev);
+	return ret;
+}
+EXPORT_SYMBOL(drm_mode_detachmode_ioctl);
+
+/**
  * drm_cvt_mode -create a modeline based on the CVT algorithm
  * @dev: drm device
  * @hdisplay: hdisplay size
@@ -1885,7 +2048,7 @@ EXPORT_SYMBOL(drm_mode_sort);
  */
 void drm_connector_list_update(struct drm_connector *connector)
 {
-	struct drm_display_mode *pmode, *pt;
+	struct drm_display_mode *pmode, *umode, *pt;
 
 	WARN_ON(!mutex_is_locked(&connector->dev->mode_config.mutex));
 
@@ -1931,6 +2094,40 @@ void drm_connector_list_update(struct dr
 			list_move_tail(&pmode->head, &connector->modes);
 		}
 	}
+
+	list_for_each_entry_safe(umode, pt, &connector->user_modes, head) {
+		struct drm_display_mode *mode;
+		bool found_it = false;
+
+		/* go through current modes checking for the new probed mode */
+		list_for_each_entry(mode, &connector->modes, head) {
+			DRM_DEBUG("Checking umode %s VS mode %s\n", umode->name, mode->name);
+			if (!drm_mode_equal(umode, mode))
+				continue;
+
+			found_it = true;
+			break;
+		}
+
+		if (!found_it) {
+			struct drm_display_mode *mode_to_add;
+			DRM_DEBUG("Adding mode \"%s\" to connector user_mode list\n", umode->name);
+			/*
+			 * Here we duplicate the mode and add it to the modes list
+			 * instead of moving the mode from connector->user_modes
+			 * to connector->mode, thus losing it for good from the
+			 * user_modes list, which is not hwat we want
+			 */
+			mode_to_add = drm_mode_duplicate(connector->dev, umode);
+			list_add_tail(&mode_to_add->head, &connector->modes);
+		}
+	}
+	list_for_each_entry(pmode, &connector->user_modes, head) {
+		DRM_DEBUG("Connector %s user_mode: %s", connector->name, pmode->name);
+	}
+	list_for_each_entry(pmode, &connector->modes, head) {
+		DRM_DEBUG("Connector %s mode: %s", connector->name, pmode->name);
+	}
 }
 EXPORT_SYMBOL(drm_connector_list_update);
 
Index: linux-6.6/drivers/gpu/drm/drm_probe_helper.c
===================================================================
--- linux-6.6.orig/drivers/gpu/drm/drm_probe_helper.c
+++ linux-6.6/drivers/gpu/drm/drm_probe_helper.c
@@ -377,6 +377,23 @@ retry:
 	return ret;
 }
 
+void drm_mode_validate_user_mode(struct drm_device *dev,
+				 struct drm_connector *connector,
+				 struct drm_display_mode *mode)
+{
+	struct drm_display_mode *match_mode;
+
+	DRM_DEBUG_KMS("Starting debug %s for mode %s\n", connector->name, mode->name);
+	list_for_each_entry(match_mode, &connector->user_modes, head) {
+		DRM_DEBUG_KMS("Testing mode %s vs %s\n", mode->name, match_mode->name);
+		if (drm_mode_equal(match_mode, mode)) {
+			DRM_DEBUG_KMS("Modes match!\n");
+			mode->status = MODE_OK;
+			break;
+		}
+	}
+}
+
 /**
  * drm_helper_probe_detect - probe connector status
  * @connector: connector to probe
@@ -577,6 +594,8 @@ int drm_helper_probe_single_connector_mo
 
 	drm_modeset_acquire_init(&ctx, 0);
 
+	DRM_DEBUG_KMS("[CONNECTOR:%d:%s] called by %ps\n", connector->base.id,
+			connector->name, __builtin_return_address(0));
 	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n", connector->base.id,
 			connector->name);
 
@@ -594,6 +613,10 @@ retry:
 
 	old_status = connector->status;
 
+	list_for_each_entry(mode, &connector->modes, head) {
+		drm_mode_validate_user_mode(dev, connector, mode);
+	}
+
 	if (connector->force) {
 		if (connector->force == DRM_FORCE_ON ||
 		    connector->force == DRM_FORCE_ON_DIGITAL)
@@ -710,7 +733,13 @@ exit:
 
 	drm_mode_sort(&connector->modes);
 
-	DRM_DEBUG_KMS("[CONNECTOR:%d:%s] probed modes :\n", connector->base.id,
+	DRM_DEBUG_KMS("[CONNECTOR:%d:%s] final user_modes :\n", connector->base.id,
+			connector->name);
+	list_for_each_entry(mode, &connector->user_modes, head) {
+		drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
+		drm_mode_debug_printmodeline(mode);
+	}
+	DRM_DEBUG_KMS("[CONNECTOR:%d:%s] final modes :\n", connector->base.id,
 			connector->name);
 	list_for_each_entry(mode, &connector->modes, head) {
 		drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
Index: linux-6.6/include/drm/drm_connector.h
===================================================================
--- linux-6.6.orig/include/drm/drm_connector.h
+++ linux-6.6/include/drm/drm_connector.h
@@ -1618,6 +1618,14 @@ struct drm_connector {
 	struct list_head probed_modes;
 
 	/**
+	 * @user_modes:
+	 * These are modes added by probing with DDC or the BIOS, before
+	 * filtering is applied. Used by the probe helpers. Protected by
+	 * &drm_mode_config.mutex.
+	 */
+	struct list_head user_modes;
+
+	/**
 	 * @display_info: Display information is filled from EDID information
 	 * when a display is detected. For non hot-pluggable displays such as
 	 * flat panels in embedded systems, the driver should initialize the
Index: linux-6.6/include/drm/drm_modes.h
===================================================================
--- linux-6.6.orig/include/drm/drm_modes.h
+++ linux-6.6/include/drm/drm_modes.h
@@ -460,6 +460,10 @@ int drm_mode_convert_umode(struct drm_de
 			   struct drm_display_mode *out,
 			   const struct drm_mode_modeinfo *in);
 void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
+int drm_mode_attachmode_ioctl(struct drm_device *dev,
+			      void *data, struct drm_file *file_priv);
+int drm_mode_detachmode_ioctl(struct drm_device *dev,
+			      void *data, struct drm_file *file_priv);
 void drm_mode_debug_printmodeline(const struct drm_display_mode *mode);
 bool drm_mode_is_420_only(const struct drm_display_info *display,
 			  const struct drm_display_mode *mode);
