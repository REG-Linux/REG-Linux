From 6b37b76a35dc37defd5c20465f94cf90b91bc628 Mon Sep 17 00:00:00 2001
From: Xiangyi Zeng <xiangyi.zeng@linux.alibaba.com>
Date: Mon, 27 May 2024 15:35:04 +0800
Subject: [PATCH 094/400] drivers/spi: Add THEAD TH1520 QSPI driver

Signed-off-by: Xiangyi Zeng <xiangyi.zeng@linux.alibaba.com>
---
 drivers/spi/Kconfig            |   6 +
 drivers/spi/Makefile           |   1 +
 drivers/spi/spi-dw-mmio-quad.c | 216 +++++++++
 drivers/spi/spi-dw-quad.c      | 830 +++++++++++++++++++++++++++++++++
 drivers/spi/spi-dw-quad.h      | 365 +++++++++++++++
 5 files changed, 1418 insertions(+)
 create mode 100644 drivers/spi/spi-dw-mmio-quad.c
 create mode 100644 drivers/spi/spi-dw-quad.c
 create mode 100644 drivers/spi/spi-dw-quad.h

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 3ce0fd5df8e9..83c1ee0f546d 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -295,6 +295,12 @@ config SPI_DAVINCI
 	help
 	  SPI master controller for DaVinci/DA8x/OMAP-L/AM1x SPI modules.
 
+config SPI_DW_QUAD
+	tristate "DesignWare QSPI controller core support"
+	default n
+	help
+	  general driver for QSPI controller core from  DesignWare
+
 config SPI_DESIGNWARE
 	tristate "DesignWare SPI controller core support"
 	imply SPI_MEM
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 6af54842b9fa..b2f672f2b0d8 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -43,6 +43,7 @@ obj-$(CONFIG_SPI_COLDFIRE_QSPI)		+= spi-coldfire-qspi.o
 obj-$(CONFIG_SPI_CS42L43)		+= spi-cs42l43.o
 obj-$(CONFIG_SPI_DAVINCI)		+= spi-davinci.o
 obj-$(CONFIG_SPI_DLN2)			+= spi-dln2.o
+obj-$(CONFIG_SPI_DW_QUAD)		+= spi-dw-mmio-quad.o spi-dw-quad.o
 obj-$(CONFIG_SPI_DESIGNWARE)		+= spi-dw.o
 spi-dw-y				:= spi-dw-core.o
 spi-dw-$(CONFIG_SPI_DW_DMA)		+= spi-dw-dma.o
diff --git a/drivers/spi/spi-dw-mmio-quad.c b/drivers/spi/spi-dw-mmio-quad.c
new file mode 100644
index 000000000000..b5e8cef263a6
--- /dev/null
+++ b/drivers/spi/spi-dw-mmio-quad.c
@@ -0,0 +1,216 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Memory-mapped interface driver for DW ehance-spi core
+ *
+ * Copyright (c) 2021-2024, ailibaba-inc corperation.
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/scatterlist.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/acpi.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+#include "spi-dw-quad.h"
+
+#define DRIVER_NAME "dw_qspi_mmio"
+
+struct dw_qspi_mmio {
+	struct dw_spi  dws;
+	struct clk		*clk;
+	struct clk		*pclk;
+	struct clk		*sclk;
+	void			*priv;
+};
+
+static int qspi_clk_prepare_enable(struct dw_qspi_mmio *dwsmmio)
+{
+	int ret;
+
+	ret = clk_prepare_enable(dwsmmio->pclk);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(dwsmmio->sclk);
+	if (ret) {
+		clk_disable_unprepare(dwsmmio->pclk);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void qspi_clk_disable_unprepare(struct dw_qspi_mmio *dwsmmio)
+{
+	clk_disable_unprepare(dwsmmio->pclk);
+	clk_disable_unprepare(dwsmmio->sclk);
+}
+
+static int __maybe_unused dw_qspi_mmio_suspend(struct device *dev)
+{
+	int ret;
+	struct dw_qspi_mmio *dwsmmio = dev_get_drvdata(dev);
+
+	ret = dw_qspi_suspend_host(&dwsmmio->dws);
+
+	qspi_clk_disable_unprepare(dwsmmio);
+
+	return ret;
+}
+
+static int __maybe_unused dw_qspi_mmio_resume(struct device *dev)
+{
+	struct dw_qspi_mmio *dwsmmio = dev_get_drvdata(dev);
+	int ret;
+
+	ret = qspi_clk_prepare_enable(dwsmmio);
+	if (ret) {
+		dev_err(dev, "failed to enable spi clock(%d)\n", ret);
+		return ret;
+	}
+
+	return dw_qspi_resume_host(&dwsmmio->dws);
+}
+
+static int dw_qspi_mmio_probe(struct platform_device *pdev)
+{
+	int (*init_func)(struct platform_device *pdev,
+			 struct dw_qspi_mmio *dwsmmio);
+	struct dw_qspi_mmio *dwsmmio;
+	struct dw_spi *dws;
+	int ret;
+	int num_cs,rx_sample_dly;
+
+	dwsmmio = devm_kzalloc(&pdev->dev, sizeof(struct dw_qspi_mmio),
+			GFP_KERNEL);
+	if (!dwsmmio)
+		return -ENOMEM;
+
+	dws = &dwsmmio->dws;
+
+	/* Get basic io resource and map it */
+	dws->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(dws->regs)) {
+		dev_err(&pdev->dev, "QSPI region map failed\n");
+		return PTR_ERR(dws->regs);
+	}
+
+	dws->irq = platform_get_irq(pdev, 0);
+	if (dws->irq < 0)
+		return dws->irq; /* -ENXIO */
+
+	dwsmmio->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(dwsmmio->clk))
+		return PTR_ERR(dwsmmio->clk);
+	ret = clk_prepare_enable(dwsmmio->clk);
+	if (ret)
+		return ret;
+
+	/* Optional clock needed to access the registers */
+	dwsmmio->pclk = devm_clk_get_optional(&pdev->dev, "pclk");
+	if (IS_ERR(dwsmmio->pclk)) {
+		ret = PTR_ERR(dwsmmio->pclk);
+		goto out_clk;
+	}
+	ret = clk_prepare_enable(dwsmmio->pclk);
+	if (ret)
+		goto out_clk;
+
+	dwsmmio->sclk = devm_clk_get_optional(&pdev->dev, "sclk");
+	if (IS_ERR(dwsmmio->sclk)) {
+		ret = PTR_ERR(dwsmmio->sclk);
+		goto out_clk;
+	}
+	ret = clk_prepare_enable(dwsmmio->sclk);
+	if (ret)
+		goto out_clk;
+
+	/* set bus number */
+	dws->bus_num = pdev->id;
+
+	/* get supported freq in max */
+	dws->max_freq = clk_get_rate(dwsmmio->clk);
+
+	//dws->slave_cs = devm_gpiod_get_index_optional(&pdev->dev, "cs", 0,GPIOD_OUT_LOW);
+	dws->slave_cs = devm_gpiod_get_optional(&pdev->dev, "cs", GPIOD_OUT_LOW);
+	if (IS_ERR(dws->slave_cs))
+		return PTR_ERR(dws->slave_cs);
+	/* get reg width of controler */
+	device_property_read_u32(&pdev->dev, "reg-io-width", &dws->reg_io_width);
+
+	/* get chip select count of controler */
+	num_cs = 1;
+	device_property_read_u32(&pdev->dev, "num-cs", &num_cs);
+	dws->num_cs = num_cs;
+	rx_sample_dly = 4;
+	device_property_read_u32(&pdev->dev, "rx-sample-dly", &rx_sample_dly);
+	printk("get gpio succes %d\n",rx_sample_dly);
+	dws->rx_sample_delay = rx_sample_dly;
+	init_func = device_get_match_data(&pdev->dev);
+	if (init_func) {
+		ret = init_func(pdev, dwsmmio);
+		if (ret)
+			goto out;
+	}
+
+	ret = dw_qspi_add_host(&pdev->dev, dws);
+	if (ret){
+		goto out;
+		dw_drv_log("probe failed \n");
+	}
+	platform_set_drvdata(pdev, dwsmmio);
+	dw_drv_log("dw_qspi_probe success \n");
+	return 0;
+
+out:
+	clk_disable_unprepare(dwsmmio->pclk);
+	clk_disable_unprepare(dwsmmio->sclk);
+out_clk:
+	clk_disable_unprepare(dwsmmio->clk);
+	return ret;
+}
+
+static int dw_qspi_mmio_remove(struct platform_device *pdev)
+{
+	struct dw_qspi_mmio *dwsmmio = platform_get_drvdata(pdev);
+
+	dw_qspi_remove_host(&dwsmmio->dws);
+	clk_disable_unprepare(dwsmmio->pclk);
+	clk_disable_unprepare(dwsmmio->sclk);
+	clk_disable_unprepare(dwsmmio->clk);
+
+	return 0;
+}
+
+static const struct of_device_id dw_qspi_mmio_of_match[] = {
+	{ .compatible = "snps,dw-apb-ssi-quad", },
+	{ /* end of table */}
+};
+MODULE_DEVICE_TABLE(of, dw_qspi_mmio_of_match);
+
+static const struct dev_pm_ops qspi_mmio_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(dw_qspi_mmio_suspend, dw_qspi_mmio_resume)
+};
+
+static struct platform_driver dw_qspi_mmio_driver = {
+	.probe		= dw_qspi_mmio_probe,
+	.remove		= dw_qspi_mmio_remove,
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.of_match_table = dw_qspi_mmio_of_match,
+		.pm = &qspi_mmio_pm_ops,
+	},
+};
+module_platform_driver(dw_qspi_mmio_driver);
+
+MODULE_AUTHOR("linghui zeng <linghui.zlh@linux.alibaba.com>");
+MODULE_DESCRIPTION("Memory-mapped I/O interface driver for DW ehance-spi Core");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/spi/spi-dw-quad.c b/drivers/spi/spi-dw-quad.c
new file mode 100644
index 000000000000..8e815ecb135f
--- /dev/null
+++ b/drivers/spi/spi-dw-quad.c
@@ -0,0 +1,830 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Designware ehance-spi  core controller driver
+ *
+ * Copyright (c) 2021-2024, alibaba-inc Corporation.
+ *
+ * base on design-ware spi-core driver(spi-dw-xxx.c)
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/highmem.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/iopoll.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/sizes.h>
+#include <linux/spi/spi-mem.h>
+#include "spi-dw-quad.h"
+#include <linux/of_gpio.h>
+#include <linux/gpio/consumer.h>
+
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#endif
+
+/* Slave spi_dev related */
+struct chip_data {
+	u8 tmode;		/* TR/TO/RO/EEPROM */
+	u8 type;		/* SPI/SSP/MicroWire */
+
+	u8 poll_mode;		/* 1 means use poll mode */
+
+	u16 clk_div;		/* baud rate divider */
+	u32 speed_hz;		/* baud rate of spi io clk */
+	void (*cs_control)(u32 command);
+};
+
+#ifdef CONFIG_DEBUG_FS
+#define SPI_REGS_BUFSIZE	1024
+static ssize_t dw_qspi_show_regs(struct file *file, char __user *user_buf,
+		size_t count, loff_t *ppos)
+{
+	struct dw_spi *dws = file->private_data;
+	char *buf;
+	u32 len = 0;
+	ssize_t ret;
+
+	buf = kzalloc(SPI_REGS_BUFSIZE, GFP_KERNEL);
+	if (!buf)
+		return 0;
+
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"%s registers:\n", dev_name(&dws->master->dev));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"=================================\n");
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"CTRL0: \t\t0x%08x\n", dw_readl(dws, DW_SPI_CTRL0));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"CTRL1: \t\t0x%08x\n", dw_readl(dws, DW_SPI_CTRL1));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"SSIENR: \t0x%08x\n", dw_readl(dws, DW_SPI_SSIENR));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"SER: \t\t0x%08x\n", dw_readl(dws, DW_SPI_SER));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"BAUDR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_BAUDR));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"TXFTLR: \t0x%08x\n", dw_readl(dws, DW_SPI_TXFLTR));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"RXFTLR: \t0x%08x\n", dw_readl(dws, DW_SPI_RXFLTR));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"TXFLR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_TXFLR));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"RXFLR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_RXFLR));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"SR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_SR));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"IMR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_IMR));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"ISR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_ISR));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"DMACR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_DMACR));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"DMATDLR: \t0x%08x\n", dw_readl(dws, DW_SPI_DMATDLR));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"DMARDLR: \t0x%08x\n", dw_readl(dws, DW_SPI_DMARDLR));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"RX_SAMPLE_DELAY: \t0x%08x\n", dw_readl(dws, DW_SPI_RX_SMP_DLY));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"SPI_CTRL0: \t0x%08x\n", dw_readl(dws, DW_SPI_SPI_CTRLR0));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"TXD_DRIVE_EDGE: \t0x%08x\n", dw_readl(dws, DW_SPI_TXD_DRV_EDGE));
+	len += scnprintf(buf + len, SPI_REGS_BUFSIZE - len,
+			"=================================\n");
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations dw_qspi_regs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= simple_open,
+	.read		= dw_qspi_show_regs,
+	.llseek		= default_llseek,
+};
+
+static int dw_qspi_debugfs_init(struct dw_spi *dws)
+{
+	char name[32];
+
+	snprintf(name, 32, "dw_qspi%d", dws->master->bus_num);
+	dws->debugfs = debugfs_create_dir(name, NULL);
+	if (!dws->debugfs)
+		return -ENOMEM;
+
+	debugfs_create_file("registers", S_IFREG | S_IRUGO,
+		dws->debugfs, (void *)dws, &dw_qspi_regs_ops);
+	return 0;
+}
+
+static void dw_qspi_debugfs_remove(struct dw_spi *dws)
+{
+	debugfs_remove_recursive(dws->debugfs);
+}
+
+#else
+static inline int dw_qspi_debugfs_init(struct dw_spi *dws)
+{
+	return 0;
+}
+
+static inline void dw_qspi_debugfs_remove(struct dw_spi *dws)
+{
+}
+#endif /* CONFIG_DEBUG_FS */
+
+#ifdef CONFIG_PM_SLEEP
+static void dw_qspi_register_suspend(struct dw_spi *dws)
+{
+	struct dw_qspi_context *ctx = &dws->ctx;
+
+	ctx->ctrlr0		= dw_readl(dws, DW_SPI_CTRL0);
+	ctx->ctrlr1		= dw_readl(dws, DW_SPI_CTRL1);
+	ctx->ssienr		= dw_readl(dws, DW_SPI_SSIENR);
+	ctx->mwcr		= dw_readl(dws, DW_SPI_MWCR);
+	ctx->ser		= dw_readl(dws, DW_SPI_SER);
+	ctx->baudr		= dw_readl(dws, DW_SPI_BAUDR);
+	ctx->txftlr		= dw_readl(dws, DW_SPI_TXFLTR);
+	ctx->rxftlr		= dw_readl(dws, DW_SPI_RXFLTR);
+	ctx->txflr		= dw_readl(dws, DW_SPI_TXFLR);
+	ctx->rxflr		= dw_readl(dws, DW_SPI_RXFLR);
+	ctx->imr		= dw_readl(dws, DW_SPI_IMR);
+	ctx->dmacr		= dw_readl(dws, DW_SPI_DMACR);
+	ctx->dmatdlr		= dw_readl(dws, DW_SPI_DMATDLR);
+	ctx->dmardlr		= dw_readl(dws, DW_SPI_DMARDLR);
+	ctx->rx_sample_dly	= dw_readl(dws, DW_SPI_RX_SMP_DLY);
+	ctx->spi_ctrlr0		= dw_readl(dws, DW_SPI_SPI_CTRLR0);
+	ctx->txd_drv_edge	= dw_readl(dws, DW_SPI_TXD_DRV_EDGE);
+
+}
+
+static void dw_qspi_register_resume(struct dw_spi *dws)
+{
+	struct dw_qspi_context *ctx = &dws->ctx;
+
+	dw_writel(dws, DW_SPI_SSIENR, 0);
+	dw_writel(dws, DW_SPI_CTRL0, ctx->ctrlr0);
+	dw_writel(dws, DW_SPI_CTRL1, ctx->ctrlr1);
+	dw_writel(dws, DW_SPI_TXFLTR, ctx->txftlr);
+	dw_writel(dws, DW_SPI_RXFLTR, ctx->rxftlr);
+	dw_writel(dws, DW_SPI_TXFLR, ctx->txflr);
+	dw_writel(dws, DW_SPI_RXFLR, ctx->rxflr);
+	dw_writel(dws, DW_SPI_IMR, ctx->imr);
+	dw_writel(dws,DW_SPI_DMATDLR, ctx->dmatdlr);
+	dw_writel(dws, DW_SPI_DMARDLR, ctx->dmardlr);
+	dw_writel(dws, DW_SPI_RX_SMP_DLY, ctx->rx_sample_dly);
+	dw_writel(dws, DW_SPI_SPI_CTRLR0, ctx->spi_ctrlr0);
+	dw_writel(dws, DW_SPI_TXD_DRV_EDGE, ctx->txd_drv_edge);
+	dw_writel(dws, DW_SPI_SER, ctx->ser);
+	dw_writel(dws, DW_SPI_BAUDR, ctx->baudr);
+	dw_writel(dws, DW_SPI_MWCR, ctx->mwcr);
+	dw_writel(dws, DW_SPI_DMACR, ctx->dmacr);
+	dw_writel(dws, DW_SPI_SSIENR, ctx->ssienr);
+}
+#endif
+
+void dw_qspi_set_cs(struct spi_device *spi,struct dw_spi *dws, bool enable)
+{
+	bool enable1 = !enable;
+
+	if (dws->slave_cs) {
+		/*
+		 * Honour the SPI_NO_CS flag and invert the enable line, as
+		 * active low is default for SPI. Execution paths that handle
+		 * polarity inversion in gpiolib (such as device tree) will
+		 * enforce active high using the SPI_CS_HIGH resulting in a
+		 * double inversion through the code above.
+		 */
+		if (!(spi->mode & SPI_NO_CS)) {
+			if (dws->slave_cs)
+				gpiod_set_value_cansleep(dws->slave_cs, enable);
+			else
+				gpiod_set_value_cansleep(dws->slave_cs, enable1);
+		}
+		/* Some SPI masters need both GPIO CS & slave_select */
+		if ((spi->controller->flags & SPI_CONTROLLER_GPIO_SS) &&
+			spi->controller->set_cs)
+			spi->controller->set_cs(spi, !enable);
+	} else if (spi->controller->set_cs) {
+		spi->controller->set_cs(spi, !enable);
+	}
+}
+
+static void __maybe_unused set_cs(struct spi_device *spi, bool enable)
+{
+	struct dw_spi *dws = spi_controller_get_devdata(spi->controller);
+	struct chip_data *chip = spi_get_ctldata(spi);
+
+	/* Chip select logic is inverted from spi_set_cs() */
+	if (chip && chip->cs_control)
+		chip->cs_control(!enable);
+
+	if (!enable)
+		dw_writel(dws, DW_SPI_SER, BIT(spi->chip_select));
+	else if (dws->cs_override)
+		dw_writel(dws, DW_SPI_SER, 0);
+}
+
+/* Return the max entries we can fill into tx fifo */
+static inline u32 tx_max(struct dw_spi *dws)
+{
+	u32 tx_left, tx_room, rxtx_gap;
+
+	tx_left = (dws->tx_end - dws->tx) / dws->n_bytes;
+	tx_room = dws->fifo_len - dw_readl(dws, DW_SPI_TXFLR);
+
+	/*
+	 * Another concern is about the tx/rx mismatch, we
+	 * though to use (dws->fifo_len - rxflr - txflr) as
+	 * one maximum value for tx, but it doesn't cover the
+	 * data which is out of tx/rx fifo and inside the
+	 * shift registers. So a control from sw point of
+	 * view is taken.
+	 */
+	rxtx_gap =  ((dws->rx_end - dws->rx) - (dws->tx_end - dws->tx))
+			/ dws->n_bytes;
+
+	return min3(tx_left, tx_room, (u32) (dws->fifo_len - rxtx_gap));
+}
+
+/* Return the max entries we should read out of rx fifo */
+static inline u32 rx_max(struct dw_spi *dws)
+{
+	u32 rx_left = (dws->rx_end - dws->rx) / dws->n_bytes;
+
+	return min_t(u32, rx_left, dw_readl(dws, DW_SPI_RXFLR));
+}
+
+static void dw_writer(struct dw_spi *dws)
+{
+	u32 max;
+	u32 txw = 0;
+
+	spin_lock(&dws->buf_lock);
+	max = tx_max(dws);
+	while (max--) {
+		/* Set the tx word if the transfer's original "tx" is not null */
+		if (dws->tx_end - dws->len) {
+			if (dws->n_bytes == 1)
+				txw = *(u8 *)(dws->tx);
+			else if(dws->n_bytes == 2)
+				txw = *(u16 *)(dws->tx);
+			else
+				txw = *(u32 *)(dws->tx);
+		}
+		dw_write_io_reg(dws, DW_SPI_DR, txw);
+		dws->tx += dws->n_bytes;
+	}
+	spin_unlock(&dws->buf_lock);
+}
+
+static void dw_reader(struct dw_spi *dws)
+{
+	u32 max;
+	u32 rxw;
+
+	spin_lock(&dws->buf_lock);
+	max = rx_max(dws);
+	while (max--) {
+		rxw = dw_read_io_reg(dws, DW_SPI_DR);
+		/* Care rx only if the transfer's original "rx" is not null */
+		if (dws->rx_end - dws->len) {
+			if (dws->n_bytes == 1)
+				*(u8 *)(dws->rx) = rxw;
+			else if(dws->n_bytes ==2)
+				*(u16 *)(dws->rx) = rxw;
+			else
+				*(u32 *)(dws->rx) = rxw;
+		}
+		dws->rx += dws->n_bytes;
+	}
+	spin_unlock(&dws->buf_lock);
+}
+
+static irqreturn_t dw_qspi_irq(int irq, void *dev_id)
+{
+	struct spi_controller *master = dev_id;
+	struct dw_spi *dws = spi_controller_get_devdata(master);
+	u16 irq_status = dw_readl(dws, DW_SPI_ISR) & 0x3f;
+
+	if (!irq_status)
+		return IRQ_NONE;
+
+	if (!master->cur_msg) {
+		spi_mask_intr(dws, SPI_INT_TXEI);
+		return IRQ_HANDLED;
+	}
+
+	return dws->transfer_handler(dws);
+}
+
+static void dw_qspi_handle_err(struct spi_controller *master,
+		struct spi_message *msg)
+{
+	struct dw_spi *dws = spi_controller_get_devdata(master);
+
+	if (dws->dma_mapped)
+		dws->dma_ops->dma_stop(dws);
+
+	spi_reset_chip(dws);
+}
+
+/* This may be called twice for each spi dev */
+static int dw_qspi_setup(struct spi_device *spi)
+{
+	struct dw_spi_chip *chip_info = NULL;
+	struct chip_data *chip;
+
+	/* Only alloc on first setup */
+	chip = spi_get_ctldata(spi);
+	if (!chip) {
+		chip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);
+		if (!chip)
+			return -ENOMEM;
+		spi_set_ctldata(spi, chip);
+	}
+
+	/*
+	 * Protocol drivers may change the chip settings, so...
+	 * if chip_info exists, use it
+	 */
+	chip_info = spi->controller_data;
+
+	/* chip_info doesn't always exist */
+	if (chip_info) {
+		if (chip_info->cs_control)
+			chip->cs_control = chip_info->cs_control;
+
+		chip->poll_mode = chip_info->poll_mode;
+		chip->type = chip_info->type;
+	}
+
+	/* use both transmit and receive mode by default */
+	chip->tmode = SPI_TMOD_TR;
+
+	return 0;
+}
+
+static void dw_qspi_cleanup(struct spi_device *spi)
+{
+	struct chip_data *chip = spi_get_ctldata(spi);
+
+	kfree(chip);
+	spi_set_ctldata(spi, NULL);
+}
+
+/* Restart the controller, disable all interrupts, clean rx fifo */
+static void qspi_hw_init(struct device *dev, struct dw_spi *dws)
+{
+	spi_reset_chip(dws);
+
+	/*
+	 * Try to detect the FIFO depth if not set by interface driver,
+	 * the depth could be from 2 to 256 from HW spec
+	 */
+	if (!dws->fifo_len) {
+		u32 fifo;
+
+		for (fifo = 1; fifo < 256; fifo++) {
+			dw_writel(dws, DW_SPI_TXFLTR, fifo);
+			if (fifo != dw_readl(dws, DW_SPI_TXFLTR))
+				break;
+		}
+		dw_writel(dws, DW_SPI_TXFLTR, 0);
+		dw_writel(dws,DW_SPI_SER,0x3);
+		dws->fifo_len = (fifo == 1) ? 0 : fifo;
+		dev_dbg(dev, "Detected FIFO size: %u uint32 \n", dws->fifo_len);
+	}
+	spi_enable_chip(dws,0);
+	dw_writel(dws, DW_SPI_RX_SMP_DLY, dws->rx_sample_delay);
+	spi_enable_chip(dws,1);
+}
+
+static int dw_qspi_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op)
+{
+	struct dw_spi *dws = spi_controller_get_devdata(mem->spi->master);
+	/* dw spi's rx and tx have the same fifo depth */
+
+	if (op->data.dir == SPI_MEM_DATA_OUT && op->data.nbytes >= ((dws->fifo_len -2)<<2) ) {
+		op->data.nbytes = ((dws->fifo_len -2)<<2);
+	}
+
+	if (op->data.dir == SPI_MEM_DATA_IN && op->data.nbytes >= (dws->fifo_len<<2) ) {
+		op->data.nbytes = (dws->fifo_len<<2);
+	}
+	return 0;
+
+}
+
+static int dw_qspi_check_buswidth(struct dw_spi *dws, u8 width)
+{
+	switch (width) {
+	case 1:
+	case 2:
+	case 4:
+		return 0;
+	}
+
+	return -ENOTSUPP;
+}
+static bool dw_qspi_supports_op(struct spi_mem *mem, const struct spi_mem_op *op)
+{
+	struct dw_spi *dws = spi_controller_get_devdata(mem->spi->master);
+	int ret=0;
+	u32 temp_len;
+	/* check buswidth */
+
+	if(op->cmd.buswidth!=1 || \
+	  (op->addr.nbytes && op->addr.buswidth !=1) || \
+	  ( op->dummy.nbytes && op->dummy.buswidth !=1))
+	  {
+		  return false;
+	  }
+	if (op->data.nbytes)
+		ret |= dw_qspi_check_buswidth(dws, op->data.buswidth);
+
+	if (ret){
+		return false;
+	}
+	/* check addr bits length */
+	temp_len = op->addr.nbytes << 3;
+	if(op->data.nbytes && op->data.buswidth > 4 && temp_len > 60 ){
+		return false;
+	}
+
+	return true;
+}
+
+static int dw_qspi_readl_poll_time_out(struct dw_spi *dws,u32 delay_us, u32 timeout_us)
+{
+	u32 val;
+	void __iomem *reg = dws->regs + DW_SPI_SR;
+	return readl_poll_timeout(reg,val,!(val & SR_BUSY),delay_us,timeout_us);
+}
+
+static void dw_qspi_build_xfer_pre_portion(struct dw_spi *dws,const struct spi_mem_op *op)
+{
+	u32 i = 0, j = 0;	
+
+	/* operation code */
+	dws->xfer_data_pre.xfer_pre[i++]= op->cmd.opcode;
+
+	/* addr */
+	if (op->addr.nbytes)
+		for(j = 0; j < op->addr.nbytes; j++)
+			dws->xfer_data_pre.xfer_pre[i++] = (op->addr.val >> (8 *(op->addr.nbytes -j -1))) & 0xFF;
+
+	/* dummy */
+	if (op->dummy.nbytes) {
+		memset(&dws->xfer_data_pre.xfer_pre[i],0xFF,op->dummy.nbytes);
+		i += op->dummy.nbytes;
+	}
+
+	dws->xfer_data_pre.xfer_pre_len = i;
+
+	return;
+}
+
+static bool dw_qspi_can_xfer_32bits_frame(const struct spi_mem_op *op)
+{
+	bool ret = false;
+
+	if (op->data.buswidth > 1 && op->data.nbytes && !(op->data.nbytes & 0x3) && !(op->data.nbytes & 0x3)) {
+		if (op->data.dir == SPI_MEM_DATA_OUT && !((unsigned long)(op->data.buf.out) & 0x03))
+			ret = true;
+		else if (op->data.dir == SPI_MEM_DATA_IN && !((unsigned long)(op->data.buf.in) & 0x03))
+			ret = true;
+	}
+
+	return ret;
+}
+
+static int dw_qspi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
+{
+	struct dw_spi *dws = spi_controller_get_devdata(mem->spi->master);
+	struct spi_device *spi = mem->spi;
+	struct chip_data *chip = spi_get_ctldata(mem->spi);
+	int	ret = 0;
+	u32	cr0 = 0, spi_cr0 = 0;
+	u32	rx_len;
+	u32 addr_bits_len, dummy_bits_len;
+
+	/* wait for the controller being ready */
+	ret = dw_qspi_readl_poll_time_out(dws,10,1000*1000);
+	if (ret) {
+		dev_err(&dws->master->dev, "time out during waiting for spi-core idle\n");
+		return ret;
+	}
+
+	/*disable spi core */
+	spi_enable_chip(dws,0);
+	if (op->data.dir == SPI_MEM_DATA_OUT)
+		spi_disable_slave(dws,0);
+	else
+		spi_enable_slave(dws,0);
+
+	/* config clk rate, div = 8 */
+	chip->clk_div = (DIV_ROUND_UP(dws->max_freq,spi->max_speed_hz)+1) & 0xfffe;
+	chip->speed_hz = dws->current_freq = spi->max_speed_hz;
+	spi_set_clk(dws,chip->clk_div);
+
+	/* build pre-xfer data portion*/
+	dw_qspi_build_xfer_pre_portion(dws,op);
+
+	/*
+	 * default cr0 register setting
+	 * SSI_TYPE-----> SPI_FRF_SPI
+	 * CPOL&CPHA----> SPI_CPOL=SPI_CPHA = 0
+	 * FRAME_SIZE---> 8bits
+	 * SPI_TMOD_OFFSET SPI_TMOD_TO
+	 */
+
+	cr0 = (chip->type << SPI_FRF_OFFSET) | \
+		(((spi->mode & SPI_CPOL) ? 1 : 0) << SPI_SCOL_OFFSET) | \
+		(((spi->mode & SPI_CPHA) ? 1 : 0) << SPI_SCPH_OFFSET) | \
+		(chip->tmode << SPI_TMOD_OFFSET) | \
+		((8-1) << SPI_DFS32_OFFSET) ;
+
+	chip->tmode = SPI_TMOD_TO;
+	if(op->data.dir == SPI_MEM_NO_DATA || op->data.dir == SPI_MEM_DATA_OUT)
+		chip->tmode = SPI_TMOD_TO;
+	else if(op->data.dir == SPI_MEM_DATA_IN && op->data.buswidth > 1) {
+		chip->tmode = SPI_TMOD_RO;
+		rx_len = op->data.nbytes;
+		if (dw_qspi_can_xfer_32bits_frame(op))
+			rx_len >>=2;
+
+		dw_writel(dws,DW_SPI_CTRL1,rx_len -1);
+	}
+	cr0 &=~SPI_TMOD_MASK;
+	cr0 |=(chip->tmode << SPI_TMOD_OFFSET);
+
+	/* init config spi_cr0 if use non-standard spi mode */
+	if(op->data.buswidth > 1){
+		/*
+		 * trans_type = both instruction and address are sent in standard mode
+		 * instruction bits length is 8bits
+		 *
+		 */
+		spi_cr0 = (SPI_CTRLR0_TRANS_ISTD_ASTD << SPI_CTRLR0_TRNAS_OFFET) | \
+				(SPI_CTRLR0_INST_L_8 << SPI_CTRLR0_INST_L_OFFSET);
+
+		addr_bits_len = (op->addr.nbytes << 3)>>2;
+		dummy_bits_len = op->dummy.nbytes << 3;
+		spi_cr0 |= (addr_bits_len << SPI_CTRLR0_ADDR_L_OFFSET);
+		spi_cr0 |= (dummy_bits_len << SPI_CTRLR0_WAIT_CYCLES_OFFSET);
+		dw_writel(dws,DW_SPI_SPI_CTRLR0,spi_cr0);
+
+		/* update SPI_SPI_FRF */
+		cr0 &=~ SPI_SPI_FRF_MASK;
+		switch(op->data.buswidth){
+			case 2:
+				cr0 |= (SPI_SPI_FRF_DUAL << SPI_SPI_FRF_OFFSET);
+			break;
+			case 4:
+				cr0 |= (SPI_SPI_FRF_QUAD << SPI_SPI_FRF_OFFSET);
+			default:
+			break;
+		}
+	}
+
+	/*check whether can xfer through 32bit-frame size, then update cr0 */
+	if(dw_qspi_can_xfer_32bits_frame(op)){
+		cr0 &=~SPI_DFS32_MASK;
+		cr0 |= ((32-1) << SPI_DFS32_OFFSET );
+	}
+	dw_writel(dws,DW_SPI_CTRL0,cr0);
+	/*  for poll mode just disable all interrupts */
+	spi_mask_intr(dws,0xff);
+
+	/* transfer data_pre portion(cmd+addr+dummy) */
+	dw_qspi_set_cs(mem->spi,dws,true);
+	spi_enable_chip(dws,1);
+
+	/* pre portion is sent with spi-standard mode and data-frame size is 8bit frame */
+	dws->n_bytes = 1;
+	if (op->data.nbytes && op->data.buswidth > 1) {
+		/*!!!note: in quad mode, dw-ssi can't be interrupt during sending pre portion and data portion
+		 * otherwise, the timing won't be expected
+		 */
+		dw_writel(dws,DW_SPI_DR,op->cmd.opcode);
+		if(op->addr.nbytes){
+		dw_writel(dws,DW_SPI_DR,op->addr.val);
+		}
+	}
+	else {
+		dws->tx = (void *)dws->xfer_data_pre.xfer_pre;
+		dws->tx_end = dws->tx  + dws->xfer_data_pre.xfer_pre_len;
+		dws->len = dws->xfer_data_pre.xfer_pre_len;
+		do {
+			dw_writer(dws);
+		} while(dws->tx_end > dws->tx);
+	}
+
+	/* transfer data portion if needs */
+	if (op->data.dir == SPI_MEM_DATA_OUT) {
+		dws->tx =(void*) op->data.buf.out;
+		dws->tx_end = dws->tx + op->data.nbytes;
+		dws->len = op->data.nbytes;
+		if(dw_qspi_can_xfer_32bits_frame(op))
+			dws->n_bytes = 4;
+		do {
+			dw_writer(dws);
+		} while(dws->tx_end > dws->tx);
+		if(op->data.nbytes && op->data.buswidth > 1){
+			//local_irq_restore(flag);
+		}
+		spi_enable_slave(dws,0);
+	}
+	else if (op->data.dir == SPI_MEM_DATA_IN) {
+		/* if data portion use standard mode,pre transfer mode is tx, need set rx mode  */
+		if(op->data.buswidth == 1){
+			while(dw_readl(dws,DW_SPI_SR) & SR_BUSY){
+				cpu_relax();
+			}
+			spi_enable_chip(dws,0);
+			cr0 = dw_readl(dws,DW_SPI_CTRL0);
+			cr0 &=~SPI_TMOD_MASK;
+			cr0 |= (SPI_TMOD_RO << SPI_TMOD_OFFSET);
+			dw_writel(dws,DW_SPI_CTRL0,cr0);
+			dw_writel(dws,DW_SPI_CTRL1,op->data.nbytes -1);
+			spi_enable_chip(dws,1);
+			dw_write_io_reg(dws,DW_SPI_DR,0);
+			dws->rx = op->data.buf.in;
+			dws->rx_end = dws->rx + op->data.nbytes;
+			dws->len = op->data.nbytes;
+			do{
+				dw_reader(dws);
+				//cpu_relax();
+			}while(dws->rx_end > dws->rx);
+		}
+		/* non-standard mode */
+		else {
+
+			dws->rx = op->data.buf.in;
+			dws->rx_end = dws->rx + op->data.nbytes;
+			dws->len = op->data.nbytes;
+			if(dw_qspi_can_xfer_32bits_frame(op))
+				dws->n_bytes = 4;
+			do {
+				dw_reader(dws);
+			} while (dws->rx_end > dws->rx);
+			if (op->data.nbytes && op->data.buswidth > 1) {
+				//local_irq_restore(flag);
+			}
+		}
+
+	}
+
+	while(dw_readl(dws,DW_SPI_SR) & SR_BUSY) {
+		cpu_relax();
+	}
+
+	if(dw_readl(dws,DW_SPI_RISR) &(SPI_INT_RXOI|SPI_INT_RXUI) ) {
+		printk("###rx err %02x \n",dw_readl(dws,DW_SPI_RISR));
+	}
+	dw_qspi_set_cs(mem->spi,dws,false);
+	return 0;
+}
+
+static const struct spi_controller_mem_ops dw_qspi_mem_ops = {
+	.adjust_op_size = dw_qspi_adjust_op_size,
+	.supports_op =	dw_qspi_supports_op,
+	.exec_op =		dw_qspi_exec_op,
+	.get_name =		NULL,/*dw_qspi_get_name,*/
+};
+
+int dw_qspi_add_host(struct device *dev, struct dw_spi *dws)
+{
+	struct spi_controller *master;
+	int ret;
+
+	BUG_ON(dws == NULL);
+
+	/*  allocate master */
+	master = spi_alloc_master(dev, 0);
+	if (!master)
+		return -ENOMEM;
+
+	dws->master = master;
+	dws->type = SSI_MOTO_SPI;
+	dws->dma_inited = 0;
+	dws->reg_io_width = 4;
+	dws->dma_addr = (dma_addr_t)(dws->paddr + DW_SPI_DR);
+	spin_lock_init(&dws->buf_lock);
+
+	/* save device data */
+	spi_controller_set_devdata(master, dws);
+
+	/*  register interrupt call-back */
+	ret = request_irq(dws->irq, dw_qspi_irq, IRQF_SHARED, dev_name(dev),
+			  master);
+	if (ret < 0) {
+		dev_err(dev, "can not get IRQ\n");
+		goto err_free_master;
+	}
+
+	master->mode_bits = SPI_CPOL |\
+				SPI_CPHA |\
+				SPI_RX_DUAL |\
+				SPI_RX_QUAD | \
+				SPI_TX_DUAL| \
+				SPI_TX_QUAD;
+	master->bits_per_word_mask =  SPI_BPW_RANGE_MASK(4, 32);
+	master->bus_num = dws->bus_num;
+	master->num_chipselect = dws->num_cs;
+	master->setup = dw_qspi_setup;
+	master->cleanup = dw_qspi_cleanup;
+	master->handle_err = dw_qspi_handle_err;
+	master->max_speed_hz = dws->max_freq;
+	master->dev.of_node = dev->of_node;
+	master->dev.fwnode = dev->fwnode;
+
+	if (dws->set_cs)
+		master->set_cs = dws->set_cs;
+
+	/* Basic HW init */
+	qspi_hw_init(dev, dws);
+
+	if (dws->dma_ops && dws->dma_ops->dma_init) {
+		ret = dws->dma_ops->dma_init(dws);
+		if (ret) {
+			dev_warn(dev, "DMA init failed\n");
+			dws->dma_inited = 0;
+		} else {
+			master->can_dma = dws->dma_ops->can_dma;
+		}
+	}
+
+	/* set qspi-mem ops table */
+	master->mem_ops = &dw_qspi_mem_ops;
+	/* regist master controler */
+	ret = devm_spi_register_controller(dev, master);
+	if (ret) {
+		dev_err(&master->dev, "problem registering spi master\n");
+		goto err_dma_exit;
+	}
+
+	/* init debugfs feature */
+	dw_qspi_debugfs_init(dws);
+	return 0;
+
+err_dma_exit:
+	if (dws->dma_ops && dws->dma_ops->dma_exit)
+		dws->dma_ops->dma_exit(dws);
+	spi_enable_chip(dws, 0);
+	free_irq(dws->irq, master);
+err_free_master:
+	spi_controller_put(master);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(dw_qspi_add_host);
+
+void dw_qspi_remove_host(struct dw_spi *dws)
+{
+	dw_qspi_debugfs_remove(dws);
+
+	if (dws->dma_ops && dws->dma_ops->dma_exit)
+		dws->dma_ops->dma_exit(dws);
+
+	spi_shutdown_chip(dws);
+
+	free_irq(dws->irq, dws->master);
+}
+EXPORT_SYMBOL_GPL(dw_qspi_remove_host);
+
+int dw_qspi_suspend_host(struct dw_spi *dws)
+{
+	int ret;
+
+	ret = spi_controller_suspend(dws->master);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_PM_SLEEP
+	dw_qspi_register_suspend(dws);
+#endif
+
+	spi_shutdown_chip(dws);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dw_qspi_suspend_host);
+
+int dw_qspi_resume_host(struct dw_spi *dws)
+{
+	qspi_hw_init(&dws->master->dev, dws);
+#ifdef CONFIG_PM_SLEEP
+	dw_qspi_register_resume(dws);
+#endif
+	return spi_controller_resume(dws->master);
+}
+EXPORT_SYMBOL_GPL(dw_qspi_resume_host);
+
+MODULE_AUTHOR("linghui zeng<linghui.zlh@linux.alibaba.com>");
+MODULE_DESCRIPTION("Driver for DesignWare ehance-spi controller core");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/spi/spi-dw-quad.h b/drivers/spi/spi-dw-quad.h
new file mode 100644
index 000000000000..87c12dbd40f9
--- /dev/null
+++ b/drivers/spi/spi-dw-quad.h
@@ -0,0 +1,365 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Designware ehance-spi core controller driver
+ *
+ * Copyright (c) 2021-2024, alibaba-inc Corporation.
+ *
+ * base on design-ware spi-core driver(spi-dw.h)
+ */
+#ifndef DW_QSPI_HEADER_H
+#define DW_QSPI_HEADER_H
+
+#include <linux/io.h>
+#include <linux/scatterlist.h>
+#include <linux/gpio/consumer.h>
+
+//#define DW_QSPI_DRV_DEBUG
+#ifdef  DW_QSPI_DRV_DEBUG
+#define dw_drv_log(fmt,arg...) printk(fmt,##arg)
+#else
+#define dw_drv_log(fmt,arg...)
+#endif
+
+/* regs define for snps,dw-apb-ssi v4.02a */
+
+/* Register offsets */
+#define DW_SPI_CTRL0			0x00
+#define DW_SPI_CTRL1			0x04
+#define DW_SPI_SSIENR			0x08
+#define DW_SPI_MWCR				0x0c
+#define DW_SPI_SER				0x10
+#define DW_SPI_BAUDR			0x14
+#define DW_SPI_TXFLTR			0x18
+#define DW_SPI_RXFLTR			0x1c
+#define DW_SPI_TXFLR			0x20
+#define DW_SPI_RXFLR			0x24
+#define DW_SPI_SR				0x28
+#define DW_SPI_IMR				0x2c
+#define DW_SPI_ISR				0x30
+#define DW_SPI_RISR				0x34
+#define DW_SPI_TXOICR			0x38
+#define DW_SPI_RXOICR			0x3c
+#define DW_SPI_RXUICR			0x40
+#define DW_SPI_MSTICR			0x44
+#define DW_SPI_ICR				0x48
+#define DW_SPI_DMACR			0x4c
+#define DW_SPI_DMATDLR			0x50
+#define DW_SPI_DMARDLR			0x54
+#define DW_SPI_IDR				0x58
+#define DW_SPI_VERSION			0x5c
+#define DW_SPI_DR				0x60
+#define DW_SPI_RX_SMP_DLY		0xf0
+#define DW_SPI_SPI_CTRLR0		0xf4
+#define DW_SPI_TXD_DRV_EDGE		0xf8
+
+/* Bit fields in CTRLR0 */
+#define SPI_DFS_OFFSET			0		/* if SSI_MAX_XFER_SIZE is configured to 16 */
+
+#define SPI_FRF_OFFSET			4
+#define SPI_FRF_SPI				0x0
+#define SPI_FRF_SSP				0x1
+#define SPI_FRF_MICROWIRE		0x2
+#define SPI_FRF_RESV			0x3
+
+#define SPI_MODE_OFFSET			6
+#define SPI_SCPH_OFFSET			6
+#define SPI_SCOL_OFFSET			7
+
+#define SPI_TMOD_OFFSET			8
+#define SPI_TMOD_MASK			(0x3 << SPI_TMOD_OFFSET)
+#define	SPI_TMOD_TR				0x0		/* xmit & recv */
+#define SPI_TMOD_TO				0x1		/* xmit only */
+#define SPI_TMOD_RO				0x2		/* recv only */
+#define SPI_TMOD_EPROMREAD		0x3		/* eeprom read mode */
+
+#define SPI_SLVOE_OFFSET		10
+#define SPI_SRL_OFFSET			11
+#define SPI_CFS_OFFSET			12
+
+#define SPI_DFS32_OFFSET		16		/* if SSI_MAX_XFER_SIZE is configured to 32 */
+#define SPI_DFS32_MASK			(0x1f << SPI_DFS32_OFFSET)
+
+#define SPI_SPI_FRF_OFFSET		21
+#define SPI_SPI_FRF_MASK		(0x3 << SPI_SPI_FRF_OFFSET)
+#define SPI_SPI_FRF_STD			0x0
+#define SPI_SPI_FRF_DUAL		0x1
+#define SPI_SPI_FRF_QUAD		0x2
+#define SPI_SPI_FRF_OCTA		0x3
+
+#define SPI_SSTE_OFFSET			24
+#define SPI_SSTE_MASK			(1 << SPI_SSTE_OFFSET )
+
+/* Bit fields in SR, 7 bits */
+#define SR_MASK					0x7f	   /* cover 7 bits */
+#define SR_BUSY					(1 << 0)   /*  set when serial transfer is in progress */
+#define SR_TF_NOT_FULL			(1 << 1)   /*  tx fifo not full */
+#define SR_TF_EMPT				(1 << 2)   /*  tx fifo empty */
+#define SR_RF_NOT_EMPT			(1 << 3)   /*  rx fifo not empty */
+#define SR_RF_FULL				(1 << 4)   /*  rx fifo full */
+#define SR_TX_ERR				(1 << 5)   /*  tx err(tx start but fifo is empty) only set when configured as slave device */
+#define SR_DCOL					(1 << 6)   /*  data colllision error */
+
+/* Bit fields in ISR, IMR, RISR, 7 bits */
+#define SPI_INT_TXEI			(1 << 0)   /* tx fifo empty */
+#define SPI_INT_TXOI			(1 << 1)   /* tx fifo overflow */
+#define SPI_INT_RXUI			(1 << 2)   /* rx fifo underfolow */
+#define SPI_INT_RXOI			(1 << 3)   /* rx fifo overflow */
+#define SPI_INT_RXFI			(1 << 4)   /* rx fifo full  */
+#define SPI_INT_MSTI			(1 << 5)   /* multi-master contention interrupt, set only when configured as slave device */
+
+/* Bit fields in DMACR */
+#define SPI_DMA_RDMAE			(1 << 0)
+#define SPI_DMA_TDMAE			(1 << 1)
+
+/* Bit fields in SPI_CTRLR0 */
+#define SPI_CTRLR0_TRNAS_OFFET		0x0
+#define SPI_CTRLR0_TRANS_ISTD_ASTD	(0)		/* both instr and address are sent in stdandard mode */
+#define SPI_CTRLR0_TRANS_ISTD_ASPF	(1)		/* instr sent in standard mode , address sent in the mode specified by CTRLR0.SPI_FRF */
+#define SPI_CTRLR0_TRANS_ISPF_ASPF	(2)		/* both instr and address sent  in the mode specified by CTRLR0.SPI_FRF */
+
+#define SPI_CTRLR0_ADDR_L_OFFSET	0x2
+#define SPI_CTRLR0_ADDR_L_24		(6)
+#define SPI_CTRLR0_ADDR_L_16		(4)
+
+#define SPI_CTRLR0_INST_L_OFFSET	0x8
+#define SPI_CTRLR0_INST_L_0			(0)
+#define SPI_CTRLR0_INST_L_4			(1)
+#define SPI_CTRLR0_INST_L_8			(2)
+#define SPI_CTRLR0_INST_L_16		(3)
+
+#define SPI_CTRLR0_WAIT_CYCLES_OFFSET (11)		/* count in io clks */
+
+#define SPI_CTRLR0_DDR_EN_OFFSET	(16)		/* enable dual-ata rate transfers in dual/quad/octal frame formats of spi */
+#define SPI_CTRLR0_DDR_EN_MASK		(1 << SPI_CTRLR0_DDR_EN_OFFSET)
+
+#define SPI_CTRLR0_INST_DDR_EN_OFFSET (17)
+#define SPI_CTRLR0_INST_DDR_EN_MASK   (1 << SPI_CTRLR0_INST_DDR_EN_OFFSET)
+
+#define SPI_CTRLR0_RXDS_EN_OFFSET	(18)
+#define SPI_CTRLR0_RXDS_EN_MASK		(1 << SPI_CTRLR0_RXDS_EN_OFFSET)
+
+
+/* TX RX interrupt level threshold, max can be 256 */
+#define SPI_INT_THRESHOLD		32
+
+enum dw_ssi_type {
+	SSI_MOTO_SPI = 0,
+	SSI_TI_SSP,
+	SSI_NS_MICROWIRE,
+};
+
+#ifdef CONFIG_PM_SLEEP
+struct dw_qspi_context {
+	u32 ctrlr0;
+	u32 ctrlr1;
+	u32 ssienr;
+	u32 mwcr;
+	u32 ser;
+	u32 baudr;
+	u32 txftlr;
+	u32 rxftlr;
+	u32 txflr;
+	u32 rxflr;
+	u32 imr;
+	u32 dmacr;
+	u32 dmatdlr;
+	u32 dmardlr;
+	u32 rx_sample_dly;
+	u32 spi_ctrlr0;
+	u32 txd_drv_edge;
+};
+#endif
+
+struct dw_spi;
+struct dw_spi_dma_ops {
+	int (*dma_init)(struct dw_spi *dws);
+	void (*dma_exit)(struct dw_spi *dws);
+	int (*dma_setup)(struct dw_spi *dws, struct spi_transfer *xfer);
+	bool (*can_dma)(struct spi_controller *master, struct spi_device *spi,
+			struct spi_transfer *xfer);
+	int (*dma_transfer)(struct dw_spi *dws, struct spi_transfer *xfer);
+	void (*dma_stop)(struct dw_spi *dws);
+};
+
+struct xfer_pre_t{
+#define		DW_MAX_CMD_BUF_LEN		32
+	u8		xfer_pre[DW_MAX_CMD_BUF_LEN];
+	u32		xfer_pre_len;
+};
+
+struct dw_spi {
+	struct spi_controller	*master;
+	enum dw_ssi_type	type;
+
+	void __iomem		*regs;
+	unsigned long		paddr;
+	int			irq;
+	u32			fifo_len;	/* depth of the FIFO buffer */
+	u32			max_freq;	/* max bus freq supported */
+
+	int			cs_override;
+	u32			reg_io_width;	/* DR I/O width in bytes */
+	u16			bus_num;
+	u16			num_cs;		/* supported slave numbers */
+	u16			rx_sample_delay;/* timing value for rx sample delay */
+	struct gpio_desc	*slave_cs;	/* gpio cs handle */
+	void (*set_cs)(struct spi_device *spi, bool enable);
+	/* used by spi_controller_mem_ops interface */
+	struct xfer_pre_t xfer_data_pre;
+	/* Current message transfer state info */
+	size_t			len;
+	void			*tx;
+	void			*tx_end;
+	spinlock_t		buf_lock;
+	void			*rx;
+	void			*rx_end;
+	int			dma_mapped;
+	u8			n_bytes;	/* current is a 1/2/4 bytes op */
+	u32			dma_width;
+	irqreturn_t		(*transfer_handler)(struct dw_spi *dws);
+	u32			current_freq;	/* spi-io frequency in hz */
+
+	/* DMA info */
+	int			dma_inited;
+	struct dma_chan		*txchan;
+	struct dma_chan		*rxchan;
+	unsigned long		dma_chan_busy;
+	dma_addr_t		dma_addr; /* phy address of the Data register */
+	const struct dw_spi_dma_ops *dma_ops;
+	void			*dma_tx;
+	void			*dma_rx;
+
+	/* Bus interface info */
+	void			*priv;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs;
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+	struct dw_qspi_context ctx;
+#endif
+};
+
+static inline u32 dw_readl(struct dw_spi *dws, u32 offset)
+{
+	return __raw_readl(dws->regs + offset);
+}
+
+static inline u16 dw_readw(struct dw_spi *dws, u32 offset)
+{
+	return __raw_readw(dws->regs + offset);
+}
+
+static inline void dw_writel(struct dw_spi *dws, u32 offset, u32 val)
+{
+	__raw_writel(val, dws->regs + offset);
+}
+
+static inline void dw_writew(struct dw_spi *dws, u32 offset, u16 val)
+{
+	__raw_writew(val, dws->regs + offset);
+}
+
+static inline u32 dw_read_io_reg(struct dw_spi *dws, u32 offset)
+{
+	switch (dws->reg_io_width) {
+	case 2:
+		return dw_readw(dws, offset);
+	case 4:
+	default:
+		return dw_readl(dws, offset);
+	}
+}
+
+static inline void dw_write_io_reg(struct dw_spi *dws, u32 offset, u32 val)
+{
+	switch (dws->reg_io_width) {
+	case 2:
+		dw_writew(dws, offset, val);
+		break;
+	case 4:
+	default:
+		dw_writel(dws, offset, val);
+		break;
+	}
+}
+
+static inline void spi_enable_slave(struct dw_spi *dws, u32 slave_idx)
+{
+	u32 val;
+	val = dw_readl(dws,DW_SPI_SER);
+	val |= 1 << slave_idx;
+	dw_writel(dws, DW_SPI_SER, val);
+}
+static inline void spi_disable_slave(struct dw_spi *dws, u32 slave_idx)
+{
+	u32 val;
+	val = dw_readl(dws,DW_SPI_SER);
+	val &= ~(1 << slave_idx);
+	dw_writel(dws, DW_SPI_SER, val);
+}
+static inline void spi_enable_chip(struct dw_spi *dws, int enable)
+{
+	dw_writel(dws, DW_SPI_SSIENR, (enable ? 1 : 0));
+}
+
+static inline void spi_set_clk(struct dw_spi *dws, u16 div)
+{
+	dw_writel(dws, DW_SPI_BAUDR, div);
+}
+
+/* Disable IRQ bits */
+static inline void spi_mask_intr(struct dw_spi *dws, u32 mask)
+{
+	u32 new_mask;
+
+	new_mask = dw_readl(dws, DW_SPI_IMR) & ~mask;
+	dw_writel(dws, DW_SPI_IMR, new_mask);
+}
+
+/* Enable IRQ bits */
+static inline void spi_umask_intr(struct dw_spi *dws, u32 mask)
+{
+	u32 new_mask;
+
+	new_mask = dw_readl(dws, DW_SPI_IMR) | mask;
+	dw_writel(dws, DW_SPI_IMR, new_mask);
+}
+
+/*
+ * This does disable the SPI controller, interrupts, and re-enable the
+ * controller back. Transmit and receive FIFO buffers are cleared when the
+ * device is disabled.
+ */
+static inline void spi_reset_chip(struct dw_spi *dws)
+{
+	spi_enable_chip(dws, 0);
+	spi_mask_intr(dws, 0xff);
+	spi_enable_chip(dws, 1);
+}
+
+static inline void spi_shutdown_chip(struct dw_spi *dws)
+{
+	spi_enable_chip(dws, 0);
+	spi_set_clk(dws, 0);
+}
+
+/*
+ * Each SPI slave device to work with dw_api controller should
+ * has such a structure claiming its working mode (poll or PIO/DMA),
+ * which can be save in the "controller_data" member of the
+ * struct spi_device.
+ */
+struct dw_spi_chip {
+	u8 poll_mode;	/* 1 for controller polling mode */
+	u8 type;		/* SPI/SSP/MicroWire */
+	void (*cs_control)(u32 command);
+};
+
+extern void dw_qspi_set_cs(struct spi_device *spi,struct dw_spi *dws, bool enable);
+extern int  dw_qspi_add_host(struct device *dev, struct dw_spi *dws);
+extern void dw_qspi_remove_host(struct dw_spi *dws);
+extern int  dw_qspi_suspend_host(struct dw_spi *dws);
+extern int  dw_qspi_resume_host(struct dw_spi *dws);
+
+#endif /* DW_QSPI_HEADER_H */
-- 
2.43.0

