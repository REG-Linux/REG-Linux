From aded7fe9faa9186c8ae272b0aa3dbb53ec75fc1f Mon Sep 17 00:00:00 2001
From: tingming <minghq@linux.alibaba.com>
Date: Wed, 22 May 2024 16:27:27 +0800
Subject: [PATCH 085/400] drivers: clk: to add thead th1520 clk driver

---
 drivers/clk/Makefile                          |   1 +
 drivers/clk/thead/Makefile                    |   7 +
 drivers/clk/thead/clk-th1520-fm.c             | 648 +++++++++++++++
 drivers/clk/thead/clk.c                       | 766 ++++++++++++++++++
 drivers/clk/thead/clk.h                       | 126 +++
 drivers/clk/thead/gate/Makefile               |   3 +
 drivers/clk/thead/gate/audiosys-gate.c        | 124 +++
 drivers/clk/thead/gate/clk-gate.h             |  35 +
 drivers/clk/thead/gate/dspsys-gate.c          | 123 +++
 drivers/clk/thead/gate/miscsys-gate.c         | 108 +++
 drivers/clk/thead/gate/thead-gate.c           | 114 +++
 drivers/clk/thead/gate/visys-gate.c           | 144 ++++
 drivers/clk/thead/gate/vosys-gate.c           | 111 +++
 drivers/clk/thead/gate/vpsys-gate.c           |  99 +++
 include/dt-bindings/clock/th1520-audiosys.h   |  35 +
 include/dt-bindings/clock/th1520-dspsys.h     |  33 +
 .../dt-bindings/clock/th1520-fm-ap-clock.h    | 513 ++++++++++++
 include/dt-bindings/clock/th1520-miscsys.h    |  28 +
 include/dt-bindings/clock/th1520-visys.h      |  54 ++
 include/dt-bindings/clock/th1520-vosys.h      |  41 +
 include/dt-bindings/clock/th1520-vpsys.h      |  26 +
 21 files changed, 3139 insertions(+)
 create mode 100644 drivers/clk/thead/Makefile
 create mode 100644 drivers/clk/thead/clk-th1520-fm.c
 create mode 100644 drivers/clk/thead/clk.c
 create mode 100644 drivers/clk/thead/clk.h
 create mode 100644 drivers/clk/thead/gate/Makefile
 create mode 100644 drivers/clk/thead/gate/audiosys-gate.c
 create mode 100644 drivers/clk/thead/gate/clk-gate.h
 create mode 100644 drivers/clk/thead/gate/dspsys-gate.c
 create mode 100644 drivers/clk/thead/gate/miscsys-gate.c
 create mode 100644 drivers/clk/thead/gate/thead-gate.c
 create mode 100644 drivers/clk/thead/gate/visys-gate.c
 create mode 100644 drivers/clk/thead/gate/vosys-gate.c
 create mode 100644 drivers/clk/thead/gate/vpsys-gate.c
 create mode 100644 include/dt-bindings/clock/th1520-audiosys.h
 create mode 100644 include/dt-bindings/clock/th1520-dspsys.h
 create mode 100644 include/dt-bindings/clock/th1520-fm-ap-clock.h
 create mode 100644 include/dt-bindings/clock/th1520-miscsys.h
 create mode 100644 include/dt-bindings/clock/th1520-visys.h
 create mode 100644 include/dt-bindings/clock/th1520-vosys.h
 create mode 100644 include/dt-bindings/clock/th1520-vpsys.h

diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 18969cbd4bb1..a78f2165ab38 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -136,3 +136,4 @@ endif
 obj-y					+= xilinx/
 obj-$(CONFIG_ARCH_ZYNQ)			+= zynq/
 obj-$(CONFIG_COMMON_CLK_ZYNQMP)         += zynqmp/
+obj-$(CONFIG_ARCH_THEAD)               	+= thead/
diff --git a/drivers/clk/thead/Makefile b/drivers/clk/thead/Makefile
new file mode 100644
index 000000000000..18801dc56232
--- /dev/null
+++ b/drivers/clk/thead/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+
+obj-$(CONFIG_THEAD_CLK) += \
+	clk.o
+
+obj-$(CONFIG_CLK_TH1520_FM)  += clk-th1520-fm.o
+obj-$(CONFIG_CLK_TH1520_FM)  += gate/
diff --git a/drivers/clk/thead/clk-th1520-fm.c b/drivers/clk/thead/clk-th1520-fm.c
new file mode 100644
index 000000000000..cbd533e5f30a
--- /dev/null
+++ b/drivers/clk/thead/clk-th1520-fm.c
@@ -0,0 +1,648 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/clock/th1520-fm-ap-clock.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+
+#include "clk.h"
+
+static struct clk *clks[CLK_END];
+static struct clk_onecell_data clk_data;
+
+/* Th1520 Fullmask */
+static u32 share_cnt_x2h_cpusys_clk_en;
+static u32 share_cnt_dmac_cpusys_clk_en;
+static u32 share_cnt_timer0_clk_en;
+static u32 share_cnt_timer1_clk_en;
+static u32 share_cnt_axi4_cpusys2_clk_en;
+static u32 share_cnt_bmu_c910_clk_en;
+static u32 share_cnt_aon2cpu_a2x_clk_en;
+static u32 share_cnt_chip_dbg_clk_en;
+static u32 share_cnt_x2x_cpusys_clk_en;
+static u32 share_cnt_cfg2tee_x2h_clk_en;
+static u32 share_cnt_cpu2aon_x2h_clk_en;
+static u32 share_cnt_cpu2vp_x2p_clk_en;
+static u32 share_cnt_npu_core_clk_en;
+static u32 share_cnt_cpu2peri_x2h_clk_en;
+static u32 share_cnt_cpu2vi_x2h_clk_en;
+static u32 share_cnt_vpsys_axi_aclk_en;
+static u32 share_cnt_gmac1_clk_en;
+static u32 share_cnt_gmac0_clk_en;
+static u32 share_cnt_perisys_apb3_hclk_en;
+static u32 share_cnt_qspi0_clk_en;
+static u32 share_cnt_gmac_axi_clk_en;
+static u32 share_cnt_gpio0_clk_en;
+static u32 share_cnt_gpio1_clk_en;
+static u32 share_cnt_pwm_clk_en;
+static u32 share_cnt_spi_clk_en;
+static u32 share_cnt_uart0_clk_en;
+static u32 share_cnt_uart2_clk_en;
+static u32 share_cnt_i2c2_clk_en;
+static u32 share_cnt_i2c3_clk_en;
+static u32 share_cnt_peri_i2s_clk_en;
+static u32 share_cnt_qspi1_clk_en;
+static u32 share_cnt_uart1_clk_en;
+static u32 share_cnt_uart3_clk_en;
+static u32 share_cnt_uart4_clk_en;
+static u32 share_cnt_uart5_clk_en;
+static u32 share_cnt_i2c0_clk_en;
+static u32 share_cnt_i2c1_clk_en;
+static u32 share_cnt_i2c4_clk_en;
+static u32 share_cnt_i2c5_clk_en;
+static u32 share_cnt_gpio2_clk_en;
+static u32 share_cnt_gpio3_clk_en;
+static u32 share_cnt_vosys_axi_aclk_en;
+
+/* Th1520 Fullmask PLL Bypass */
+static const char * const cpu_pll0_bypass_sels[] = {"cpu_pll0_foutpostdiv", "osc_24m", };
+static const char * const cpu_pll1_bypass_sels[] = {"cpu_pll1_foutpostdiv", "osc_24m", };
+static const char * const gmac_pll_bypass_sels[] = {"gmac_pll_foutpostdiv", "osc_24m", };
+static const char * const video_pll_bypass_sels[] = {"video_pll_foutpostdiv", "osc_24m", };
+static const char * const tee_pll_bypass_sels[] = {"tee_pll_foutpostdiv", "osc_24m"};
+static const char * const dpu0_pll_bypass_sels[] = {"dpu0_pll_foutpostdiv", "osc_24m"};
+static const char * const dpu1_pll_bypass_sels[] = {"dpu1_pll_foutpostdiv", "osc_24m"};
+
+/* th1520 fullmask mux */
+static const char * const ahb2_cpusys_hclk_sels[] = {"ahb2_cpusys_hclk_out_div", "osc_24m"};
+static const char * const c910_cclk_i0_sels[] = {"cpu_pll0_foutpostdiv", "osc_24m"};
+static const char * const c910_cclk_sels[] = {"c910_cclk_i0", "cpu_pll1_foutpostdiv"};
+static const char * const cfg_axi_aclk_sels[] = {"cfg_axi_aclk_out_div", "osc_24m"};
+static const char * const teesys_hclk_sels[] = {"teesys_i1_hclk", "teesys_i0_hclk"};
+static const char * const perisys_ahb_hclk_sels[] = {"perisys_ahb_hclk_out_div", "osc_24m"};
+static const char * const clk_out_1_sels[] = {"osc_24m", "clk_out_1_out_div"};
+static const char * const clk_out_2_sels[] = {"osc_24m", "clk_out_2_out_div"};
+static const char * const clk_out_3_sels[] = {"osc_24m", "clk_out_3_out_div"};
+static const char * const clk_out_4_sels[] = {"osc_24m", "clk_out_4_out_div"};
+static const char * const peri_i2s_src_clk_sels[] = {"clkgen_peri_i2s_src_clk_0", "clkgen_peri_i2s_src_clk_1"};
+static const char * const npu_cclk_sels[] = {"gmac_pll_foutpostdiv", "npu_cclk_out_div"};
+static const char * const cfg_apb_pclk_sels[] = {"cfg_apb_pclk_out_div", "osc_24m"};
+static const char * const uart_sclk_sels[] = {"clk_100m", "osc_24m"};
+
+static const struct th1520_pll_rate_table th1520_cpupll_tbl[] = {
+	TH1520_PLL_RATE(2616000000U, 2616000000U, 1, 109, 0, 1, 1),
+	TH1520_PLL_RATE(2592000000U, 2592000000U, 1, 108, 0, 1, 1),
+	TH1520_PLL_RATE(2568000000U, 2568000000U, 1, 107, 0, 1, 1),
+	TH1520_PLL_RATE(2544000000U, 2544000000U, 1, 106, 0, 1, 1),
+	TH1520_PLL_RATE(2520000000U, 2520000000U, 1, 105, 0, 1, 1),
+	TH1520_PLL_RATE(2496000000U, 2496000000U, 1, 104, 0, 1, 1),
+	TH1520_PLL_RATE(2472000000U, 2472000000U, 1, 103, 0, 1, 1),
+	TH1520_PLL_RATE(2448000000U, 2448000000U, 1, 102, 0, 1, 1),
+	TH1520_PLL_RATE(2424000000U, 2424000000U, 1, 101, 0, 1, 1),
+	TH1520_PLL_RATE(2400000000U, 2400000000U, 1, 100, 0, 1, 1),
+	TH1520_PLL_RATE(2376000000U, 2376000000U, 1, 99,  0, 1, 1),
+	TH1520_PLL_RATE(2352000000U, 2352000000U, 1, 98,  0, 1, 1),
+	TH1520_PLL_RATE(2328000000U, 2328000000U, 1, 97,  0, 1, 1),
+	TH1520_PLL_RATE(2304000000U, 2304000000U, 1, 96,  0, 1, 1),
+	TH1520_PLL_RATE(2280000000U, 2280000000U, 1, 95,  0, 1, 1),
+	TH1520_PLL_RATE(2256000000U, 2256000000U, 1, 94,  0, 1, 1),
+	TH1520_PLL_RATE(2232000000U, 2232000000U, 1, 93,  0, 1, 1),
+	TH1520_PLL_RATE(2208000000U, 2208000000U, 1, 92,  0, 1, 1),
+	TH1520_PLL_RATE(2184000000U, 2184000000U, 1, 91,  0, 1, 1),
+	TH1520_PLL_RATE(2160000000U, 2160000000U, 1, 90,  0, 1, 1),
+	TH1520_PLL_RATE(2136000000U, 2136000000U, 1, 89,  0, 1, 1),
+	TH1520_PLL_RATE(2112000000U, 2112000000U, 1, 88,  0, 1, 1),
+	TH1520_PLL_RATE(2088000000U, 2088000000U, 1, 87,  0, 1, 1),
+	TH1520_PLL_RATE(2064000000U, 2064000000U, 1, 86,  0, 1, 1),
+	TH1520_PLL_RATE(2040000000U, 2040000000U, 1, 85,  0, 1, 1),
+	TH1520_PLL_RATE(2016000000U, 2016000000U, 1, 84,  0, 1, 1),
+	TH1520_PLL_RATE(1992000000U, 1992000000U, 1, 83,  0, 1, 1),
+	TH1520_PLL_RATE(1968000000U, 1968000000U, 1, 82,  0, 1, 1),
+	TH1520_PLL_RATE(1944000000U, 1944000000U, 1, 81,  0, 1, 1),
+	TH1520_PLL_RATE(1920000000U, 1920000000U, 1, 80,  0, 1, 1),
+	TH1520_PLL_RATE(1896000000U, 1896000000U, 1, 79,  0, 1, 1),
+	TH1520_PLL_RATE(1872000000U, 1872000000U, 1, 78,  0, 1, 1),
+	TH1520_PLL_RATE(1848000000U, 1848000000U, 1, 77,  0, 1, 1),
+	TH1520_PLL_RATE(1824000000U, 1824000000U, 1, 76,  0, 1, 1),
+	TH1520_PLL_RATE(1800000000U, 1800000000U, 1, 75,  0, 1, 1),
+	TH1520_PLL_RATE(1776000000U, 1776000000U, 1, 74,  0, 1, 1),
+	TH1520_PLL_RATE(1752000000U, 1752000000U, 1, 73,  0, 1, 1),
+	TH1520_PLL_RATE(1728000000U, 1728000000U, 1, 72,  0, 1, 1),
+	TH1520_PLL_RATE(1704000000U, 1704000000U, 1, 71,  0, 1, 1),
+	TH1520_PLL_RATE(1680000000U, 1680000000U, 1, 70,  0, 1, 1),
+	TH1520_PLL_RATE(1656000000U, 1656000000U, 1, 69,  0, 1, 1),
+	TH1520_PLL_RATE(1632000000U, 1632000000U, 1, 68,  0, 1, 1),
+	TH1520_PLL_RATE(1608000000U, 1608000000U, 1, 67,  0, 1, 1),
+	TH1520_PLL_RATE(1584000000U, 1584000000U, 1, 66,  0, 1, 1),
+	TH1520_PLL_RATE(1560000000U, 1560000000U, 1, 65,  0, 1, 1),
+	TH1520_PLL_RATE(1536000000U, 1536000000U, 1, 64,  0, 1, 1),
+	TH1520_PLL_RATE(1512000000U, 1512000000U, 1, 63,  0, 1, 1),
+	TH1520_PLL_RATE(3000000000U, 1500000000U, 1, 125, 0, 2, 1),
+	TH1520_PLL_RATE(2976000000U, 1488000000U, 1, 124, 0, 2, 1),
+	TH1520_PLL_RATE(2952000000U, 1476000000U, 1, 123, 0, 2, 1),
+	TH1520_PLL_RATE(2928000000U, 1464000000U, 1, 122, 0, 2, 1),
+	TH1520_PLL_RATE(2904000000U, 1452000000U, 1, 121, 0, 2, 1),
+	TH1520_PLL_RATE(2880000000U, 1440000000U, 1, 120, 0, 2, 1),
+	TH1520_PLL_RATE(2856000000U, 1428000000U, 1, 119, 0, 2, 1),
+	TH1520_PLL_RATE(2832000000U, 1416000000U, 1, 118, 0, 2, 1),
+	TH1520_PLL_RATE(2808000000U, 1404000000U, 1, 117, 0, 2, 1),
+	TH1520_PLL_RATE(2784000000U, 1392000000U, 1, 116, 0, 2, 1),
+	TH1520_PLL_RATE(2760000000U, 1380000000U, 1, 115, 0, 2, 1),
+	TH1520_PLL_RATE(2736000000U, 1368000000U, 1, 114, 0, 2, 1),
+	TH1520_PLL_RATE(2712000000U, 1356000000U, 1, 113, 0, 2, 1),
+	TH1520_PLL_RATE(2688000000U, 1344000000U, 1, 112, 0, 2, 1),
+	TH1520_PLL_RATE(2664000000U, 1332000000U, 1, 111, 0, 2, 1),
+	TH1520_PLL_RATE(2640000000U, 1320000000U, 1, 110, 0, 2, 1),
+	TH1520_PLL_RATE(2616000000U, 1308000000U, 1, 109, 0, 2, 1),
+	TH1520_PLL_RATE(2592000000U, 1296000000U, 1, 108, 0, 2, 1),
+	TH1520_PLL_RATE(2568000000U, 1284000000U, 1, 107, 0, 2, 1),
+	TH1520_PLL_RATE(2544000000U, 1272000000U, 1, 106, 0, 2, 1),
+	TH1520_PLL_RATE(2520000000U, 1260000000U, 1, 105, 0, 2, 1),
+	TH1520_PLL_RATE(2496000000U, 1248000000U, 1, 104, 0, 2, 1),
+	TH1520_PLL_RATE(2472000000U, 1236000000U, 1, 103, 0, 2, 1),
+	TH1520_PLL_RATE(2448000000U, 1224000000U, 1, 102, 0, 2, 1),
+	TH1520_PLL_RATE(2424000000U, 1212000000U, 1, 101, 0, 2, 1),
+	TH1520_PLL_RATE(2400000000U, 1200000000U, 1, 100, 0, 2, 1),
+	TH1520_PLL_RATE(2376000000U, 1188000000U, 1, 99,  0, 2, 1),
+	TH1520_PLL_RATE(2352000000U, 1176000000U, 1, 98,  0, 2, 1),
+	TH1520_PLL_RATE(2328000000U, 1164000000U, 1, 97,  0, 2, 1),
+	TH1520_PLL_RATE(2304000000U, 1152000000U, 1, 96,  0, 2, 1),
+	TH1520_PLL_RATE(2280000000U, 1140000000U, 1, 95,  0, 2, 1),
+	TH1520_PLL_RATE(2256000000U, 1128000000U, 1, 94,  0, 2, 1),
+	TH1520_PLL_RATE(2232000000U, 1116000000U, 1, 93,  0, 2, 1),
+	TH1520_PLL_RATE(2208000000U, 1104000000U, 1, 92,  0, 2, 1),
+	TH1520_PLL_RATE(2184000000U, 1092000000U, 1, 91,  0, 2, 1),
+	TH1520_PLL_RATE(2160000000U, 1080000000U, 1, 90,  0, 2, 1),
+	TH1520_PLL_RATE(2136000000U, 1068000000U, 1, 89,  0, 2, 1),
+	TH1520_PLL_RATE(2112000000U, 1056000000U, 1, 88,  0, 2, 1),
+	TH1520_PLL_RATE(2088000000U, 1044000000U, 1, 87,  0, 2, 1),
+	TH1520_PLL_RATE(2064000000U, 1032000000U, 1, 86,  0, 2, 1),
+	TH1520_PLL_RATE(2040000000U, 1020000000U, 1, 85,  0, 2, 1),
+	TH1520_PLL_RATE(2016000000U, 1008000000U, 1, 84,  0, 2, 1),
+	TH1520_PLL_RATE(3000000000U, 1000000000U, 1, 125, 0, 3, 1),
+	TH1520_PLL_RATE(2976000000U, 992000000U,  1, 124, 0, 3, 1),
+	TH1520_PLL_RATE(2952000000U, 984000000U,  1, 123, 0, 3, 1),
+	TH1520_PLL_RATE(2928000000U, 976000000U,  1, 122, 0, 3, 1),
+	TH1520_PLL_RATE(2904000000U, 968000000U,  1, 121, 0, 3, 1),
+	TH1520_PLL_RATE(2880000000U, 960000000U,  1, 120, 0, 3, 1),
+	TH1520_PLL_RATE(2856000000U, 952000000U,  1, 119, 0, 3, 1),
+	TH1520_PLL_RATE(2832000000U, 944000000U,  1, 118, 0, 3, 1),
+	TH1520_PLL_RATE(2808000000U, 936000000U,  1, 117, 0, 3, 1),
+	TH1520_PLL_RATE(2784000000U, 928000000U,  1, 116, 0, 3, 1),
+	TH1520_PLL_RATE(2760000000U, 920000000U,  1, 115, 0, 3, 1),
+	TH1520_PLL_RATE(2736000000U, 912000000U,  1, 114, 0, 3, 1),
+	TH1520_PLL_RATE(2712000000U, 904000000U,  1, 113, 0, 3, 1),
+	TH1520_PLL_RATE(1800000000U, 900000000U,  1, 75,  0, 2, 1),
+	TH1520_PLL_RATE(2688000000U, 896000000U,  1, 112, 0, 3, 1),
+	TH1520_PLL_RATE(2664000000U, 888000000U,  1, 111, 0, 3, 1),
+	TH1520_PLL_RATE(2640000000U, 880000000U,  1, 110, 0, 3, 1),
+	TH1520_PLL_RATE(2616000000U, 872000000U,  1, 109, 0, 3, 1),
+	TH1520_PLL_RATE(2592000000U, 864000000U,  1, 108, 0, 3, 1),
+	TH1520_PLL_RATE(2568000000U, 856000000U,  1, 107, 0, 3, 1),
+	TH1520_PLL_RATE(2544000000U, 848000000U,  1, 106, 0, 3, 1),
+	TH1520_PLL_RATE(2520000000U, 840000000U,  1, 105, 0, 3, 1),
+	TH1520_PLL_RATE(2496000000U, 832000000U,  1, 104, 0, 3, 1),
+	TH1520_PLL_RATE(2472000000U, 824000000U,  1, 103, 0, 3, 1),
+	TH1520_PLL_RATE(2448000000U, 816000000U,  1, 102, 0, 3, 1),
+	TH1520_PLL_RATE(2424000000U, 808000000U,  1, 101, 0, 3, 1),
+	TH1520_PLL_RATE(2400000000U, 800000000U,  1, 100, 0, 3, 1),
+	TH1520_PLL_RATE(2376000000U, 792000000U,  1, 99,  0, 3, 1),
+	TH1520_PLL_RATE(2352000000U, 784000000U,  1, 98,  0, 3, 1),
+	TH1520_PLL_RATE(2328000000U, 776000000U,  1, 97,  0, 3, 1),
+	TH1520_PLL_RATE(2304000000U, 768000000U,  1, 96,  0, 3, 1),
+	TH1520_PLL_RATE(2280000000U, 760000000U,  1, 95,  0, 3, 1),
+	TH1520_PLL_RATE(2256000000U, 752000000U,  1, 94,  0, 3, 1),
+	TH1520_PLL_RATE(2232000000U, 744000000U,  1, 93,  0, 3, 1),
+	TH1520_PLL_RATE(2208000000U, 736000000U,  1, 92,  0, 3, 1),
+	TH1520_PLL_RATE(2184000000U, 728000000U,  1, 91,  0, 3, 1),
+	TH1520_PLL_RATE(2160000000U, 720000000U,  1, 90,  0, 3, 1),
+	TH1520_PLL_RATE(2136000000U, 712000000U,  1, 89,  0, 3, 1),
+	TH1520_PLL_RATE(2808000000U, 702000000U,  1, 117, 0, 4, 1),
+	TH1520_PLL_RATE(2760000000U, 690000000U,  1, 115, 0, 4, 1),
+	TH1520_PLL_RATE(2712000000U, 678000000U,  1, 113, 0, 4, 1),
+	TH1520_PLL_RATE(2664000000U, 666000000U,  1, 111, 0, 4, 1),
+	TH1520_PLL_RATE(2616000000U, 654000000U,  1, 109, 0, 4, 1),
+	TH1520_PLL_RATE(2568000000U, 642000000U,  1, 107, 0, 4, 1),
+	TH1520_PLL_RATE(2520000000U, 630000000U,  1, 105, 0, 4, 1),
+	TH1520_PLL_RATE(2472000000U, 618000000U,  1, 103, 0, 4, 1),
+	TH1520_PLL_RATE(2424000000U, 606000000U,  1, 101, 0, 4, 1),
+	TH1520_PLL_RATE(3000000000U, 600000000U,  1, 125, 0, 5, 1),
+	TH1520_PLL_RATE(2952000000U, 590400000U,  1, 123, 0, 5, 1),
+	TH1520_PLL_RATE(2904000000U, 580800000U,  1, 121, 0, 5, 1),
+	TH1520_PLL_RATE(2856000000U, 571200000U,  1, 119, 0, 5, 1),
+	TH1520_PLL_RATE(2808000000U, 561600000U,  1, 117, 0, 5, 1),
+	TH1520_PLL_RATE(2760000000U, 552000000U,  1, 115, 0, 5, 1),
+	TH1520_PLL_RATE(2712000000U, 542400000U,  1, 113, 0, 5, 1),
+	TH1520_PLL_RATE(2664000000U, 532800000U,  1, 111, 0, 5, 1),
+	TH1520_PLL_RATE(2616000000U, 523200000U,  1, 109, 0, 5, 1),
+	TH1520_PLL_RATE(2568000000U, 513600000U,  1, 107, 0, 5, 1),
+	TH1520_PLL_RATE(2520000000U, 504000000U,  1, 105, 0, 5, 1),
+	TH1520_PLL_RATE(3000000000U, 500000000U,  1, 125, 0, 6, 1),
+	TH1520_PLL_RATE(2952000000U, 492000000U,  1, 123, 0, 6, 1),
+	TH1520_PLL_RATE(2904000000U, 484000000U,  1, 121, 0, 6, 1),
+	TH1520_PLL_RATE(2856000000U, 476000000U,  1, 119, 0, 6, 1),
+	TH1520_PLL_RATE(2808000000U, 468000000U,  1, 117, 0, 6, 1),
+	TH1520_PLL_RATE(2760000000U, 460000000U,  1, 115, 0, 6, 1),
+	TH1520_PLL_RATE(2712000000U, 452000000U,  1, 113, 0, 6, 1),
+	TH1520_PLL_RATE(2664000000U, 444000000U,  1, 111, 0, 6, 1),
+	TH1520_PLL_RATE(2616000000U, 436000000U,  1, 109, 0, 6, 1),
+	TH1520_PLL_RATE(2568000000U, 428000000U,  1, 107, 0, 6, 1),
+	TH1520_PLL_RATE(2520000000U, 420000000U,  1, 105, 0, 6, 1),
+	TH1520_PLL_RATE(2472000000U, 412000000U,  1, 103, 0, 6, 1),
+	TH1520_PLL_RATE(2400000000U, 400000000U,  1, 100, 0, 3, 2),
+	TH1520_PLL_RATE(2352000000U, 392000000U,  1, 98,  0, 3, 2),
+	TH1520_PLL_RATE(2304000000U, 384000000U,  1, 96,  0, 3, 2),
+	TH1520_PLL_RATE(2256000000U, 376000000U,  1, 94,  0, 3, 2),
+	TH1520_PLL_RATE(2208000000U, 368000000U,  1, 92,  0, 3, 2),
+	TH1520_PLL_RATE(2160000000U, 360000000U,  1, 90,  0, 3, 2),
+	TH1520_PLL_RATE(2112000000U, 352000000U,  1, 88,  0, 3, 2),
+	TH1520_PLL_RATE(2064000000U, 344000000U,  1, 86,  0, 3, 2),
+	TH1520_PLL_RATE(2016000000U, 336000000U,  1, 84,  0, 3, 2),
+	TH1520_PLL_RATE(1968000000U, 328000000U,  1, 82,  0, 3, 2),
+	TH1520_PLL_RATE(1920000000U, 320000000U,  1, 80,  0, 3, 2),
+	TH1520_PLL_RATE(1872000000U, 312000000U,  1, 78,  0, 3, 2),
+	TH1520_PLL_RATE(1824000000U, 304000000U,  1, 76,  0, 3, 2),
+	TH1520_PLL_RATE(3000000000U, 300000000U,  1, 125, 0, 5, 2),
+	TH1520_PLL_RATE(2880000000U, 288000000U,  1, 120, 0, 5, 2),
+	TH1520_PLL_RATE(2760000000U, 276000000U,  1, 115, 0, 5, 2),
+	TH1520_PLL_RATE(2640000000U, 264000000U,  1, 110, 0, 5, 2),
+	TH1520_PLL_RATE(2520000000U, 252000000U,  1, 105, 0, 5, 2),
+	TH1520_PLL_RATE(2400000000U, 240000000U,  1, 100, 0, 5, 2),
+	TH1520_PLL_RATE(2280000000U, 228000000U,  1, 95,  0, 5, 2),
+	TH1520_PLL_RATE(2160000000U, 216000000U,  1, 90,  0, 5, 2),
+	TH1520_PLL_RATE(2040000000U, 204000000U,  1, 85,  0, 5, 2),
+	TH1520_PLL_RATE(3000000000U, 200000000U,  1, 125, 0, 5, 3),
+	TH1520_PLL_RATE(2880000000U, 192000000U,  1, 120, 0, 5, 3),
+	TH1520_PLL_RATE(2760000000U, 184000000U,  1, 115, 0, 5, 3),
+	TH1520_PLL_RATE(2640000000U, 176000000U,  1, 110, 0, 5, 3),
+	TH1520_PLL_RATE(2520000000U, 168000000U,  1, 105, 0, 5, 3),
+	TH1520_PLL_RATE(2400000000U, 160000000U,  1, 100, 0, 5, 3),
+	TH1520_PLL_RATE(2280000000U, 152000000U,  1, 95,  0, 5, 3),
+	TH1520_PLL_RATE(2160000000U, 144000000U,  1, 90,  0, 5, 3),
+	TH1520_PLL_RATE(2040000000U, 136000000U,  1, 85,  0, 5, 3),
+	TH1520_PLL_RATE(1920000000U, 128000000U,  1, 80,  0, 5, 3),
+	TH1520_PLL_RATE(3000000000U, 125000000U,  1, 125, 0, 6, 4),
+	TH1520_PLL_RATE(2760000000U, 115000000U,  1, 115, 0, 6, 4),
+	TH1520_PLL_RATE(2520000000U, 105000000U,  1, 105, 0, 6, 4),
+	TH1520_PLL_RATE(2280000000U, 95000000U,   1, 95,  0, 6, 4),
+	TH1520_PLL_RATE(2040000000U, 85000000U,   1, 85,  0, 6, 4),
+	TH1520_PLL_RATE(1800000000U, 75000000U,   1, 75,  0, 6, 4),
+	TH1520_PLL_RATE(1560000000U, 65000000U,   1, 65,  0, 6, 4),
+	TH1520_PLL_RATE(1320000000U, 55000000U,   1, 55,  0, 6, 4),
+};
+
+static const struct th1520_pll_rate_table th1520_dpupll_tbl[] = {
+	TH1520_PLL_RATE(2376000000U, 1188000000U, 1, 99, 0, 2, 1),
+	TH1520_PLL_RATE(1980000000U, 990000000U, 2, 165, 0, 2, 1),
+	TH1520_PLL_RATE(2970000000U, 742500000U, 4, 495, 0, 4, 1),
+	TH1520_PLL_RATE(2304000000U, 1152000000U, 1, 96, 0, 2, 1),
+	TH1520_PLL_RATE(1512000000U, 504000000U, 1, 63, 0, 3, 1),
+	TH1520_PLL_RATE(1512000000U, 503500000U, 1, 63, 0, 3, 1),
+	TH1520_PLL_RATE(2898000000U, 483000000U, 4, 483, 0, 6, 1),
+	TH1520_PLL_RATE(2592000000U, 648000000U, 1, 108, 0, 4, 1),
+	TH1520_PLL_RATE(2772000000U, 924000000U, 2, 231, 0, 3, 1),
+	TH1520_PLL_RATE(2856000000U, 476000000U, 1, 119, 0, 6, 1),
+	TH1520_PLL_RATE(2130000000U, 355000000U, 4, 355, 0, 6, 1),
+	TH1520_PLL_RATE(3192000000U, 456000000U, 1, 133, 0, 7, 1),
+	TH1520_PLL_RATE(2730000000U, 390000000U, 4, 455, 0, 7, 1),
+	TH1520_PLL_RATE(1680000000U, 240000000U, 1, 70, 0, 7, 1),
+	TH1520_PLL_RATE(2832000000U, 708000000U, 1, 118, 0, 4, 1),
+	TH1520_PLL_RATE(1026000000U, 342000000U, 4, 171, 0, 3, 1),
+	TH1520_PLL_RATE(1260000000U, 630000000U, 4, 210, 0, 2, 1),
+};
+
+static struct th1520_pll_clk th1520_cpu_pll0div = {
+	.out_type = TH1520_PLL_DIV,
+	.clk_type = TH1520_CPU_PLL0,
+	.rate_table = th1520_cpupll_tbl,
+	.rate_count = ARRAY_SIZE(th1520_cpupll_tbl),
+};
+
+static struct th1520_pll_clk th1520_cpu_pll1div = {
+	.out_type = TH1520_PLL_DIV,
+	.clk_type = TH1520_CPU_PLL1,
+	.rate_table = th1520_cpupll_tbl,
+	.rate_count = ARRAY_SIZE(th1520_cpupll_tbl),
+};
+
+static struct th1520_pll_clk th1520_dpu0_plldiv = {
+	.out_type = TH1520_PLL_DIV,
+	.clk_type = TH1520_DPU0_PLL,
+	.rate_table = th1520_dpupll_tbl,
+	.rate_count = ARRAY_SIZE(th1520_dpupll_tbl),
+};
+
+static struct th1520_pll_clk th1520_dpu1_plldiv = {
+	.out_type = TH1520_PLL_DIV,
+	.clk_type = TH1520_DPU1_PLL,
+	.rate_table = th1520_dpupll_tbl,
+	.rate_count = ARRAY_SIZE(th1520_dpupll_tbl),
+};
+
+static int th1520_clocks_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	void __iomem *ap_base;
+	int ret;
+	const bool *teesys = of_device_get_match_data(dev);
+
+	pr_info("th1520_clocks_probe !!! start !\n");
+
+	/* Clock source */
+	clks[CLK_DUMMY] = thead_clk_fixed("dummy", 0);
+	clks[OSC_32K] = of_clk_get_by_name(np, "osc_32k");
+	clks[OSC_24M] = of_clk_get_by_name(np, "osc_24m");
+	clks[RC_24M] = of_clk_get_by_name(np, "rc_24m");
+
+	np = dev->of_node;
+	ap_base = devm_platform_ioremap_resource(pdev, 0);
+	if (WARN_ON(IS_ERR(ap_base))) {
+		ret = PTR_ERR(ap_base);
+		goto unregister_clks;
+	}
+
+	/* Th1520 Fullmask AP PLL clocks */
+	clks[CPU_PLL0_FOUTPOSTDIV] = thead_th1520_pll("cpu_pll0_foutpostdiv", "osc_24m", ap_base, &th1520_cpu_pll0div);
+	clks[CPU_PLL1_FOUTPOSTDIV] = thead_th1520_pll("cpu_pll1_foutpostdiv", "osc_24m", ap_base, &th1520_cpu_pll1div);
+
+	clks[DPU0_PLL_FOUTPOSTDIV] = thead_th1520_pll("dpu0_pll_foutpostdiv", "osc_24m", ap_base, &th1520_dpu0_plldiv);
+	clks[DPU1_PLL_FOUTPOSTDIV] = thead_th1520_pll("dpu1_pll_foutpostdiv", "osc_24m", ap_base, &th1520_dpu1_plldiv);
+
+	/* Th1520 Fullmask AP Fixed PLL */
+	clks[GMAC_PLL_FOUTPOSTDIV] = thead_clk_fixed("gmac_pll_foutpostdiv", 1000000000);
+	clks[VIDEO_PLL_FOUTPOSTDIV] = thead_clk_fixed("video_pll_foutpostdiv", 792000000);
+	clks[VIDEO_PLL_FOUTVCO] = thead_clk_fixed("video_pll_foutvco", 2376000000);
+	clks[TEE_PLL_FOUTPOSTDIV] = thead_clk_fixed("tee_pll_foutpostdiv", 792000000);
+	clks[CLKGEN_PERI_I2S_SRC_CLK_0] = thead_clk_fixed("clkgen_peri_i2s_src_clk_0", 294912000);	//from audio_pll_foutpostdiv
+	clks[CLKGEN_PERI_I2S_SRC_CLK_1] = thead_clk_fixed("clkgen_peri_i2s_src_clk_1", 135475200);	//from sys_pll_foutpostdiv
+	clks[CLKGEN_C910_BUS_CLK_NO_ICG] = thead_clk_fixed("clkgen_c910_bus_clk_no_icg", 750000000);
+	clks[AONSYS_BUS_CLK] = thead_clk_fixed("aonsys_hclk", 101606400);	//from sys_pll, maybe change ?
+
+	/* Th1520 Fullmask AP MUX */
+	clks[CPU_PLL0_BYPASS] = thead_th1520_clk_mux_flags("cpu_pll0_bypass", ap_base + 0x4, 30, 1, cpu_pll0_bypass_sels, ARRAY_SIZE(cpu_pll0_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[CPU_PLL1_BYPASS] = thead_th1520_clk_mux_flags("cpu_pll1_bypass", ap_base + 0x14, 30, 1, cpu_pll1_bypass_sels, ARRAY_SIZE(cpu_pll1_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[GMAC_PLL_BYPASS] = thead_th1520_clk_mux_flags("gmac_pll_bypass", ap_base + 0x24, 30, 1, gmac_pll_bypass_sels, ARRAY_SIZE(gmac_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[VIDEO_PLL_BYPASS] = thead_th1520_clk_mux_flags("video_pll_bypass", ap_base + 0x34, 30, 1, video_pll_bypass_sels, ARRAY_SIZE(video_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[TEE_PLL_BYPASS] = thead_th1520_clk_mux_flags("tee_pll_bypass", ap_base + 0x64, 30, 1, tee_pll_bypass_sels, ARRAY_SIZE(tee_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[DPU0_PLL_BYPASS] = thead_th1520_clk_mux_flags("dpu0_pll_bypass", ap_base + 0x44, 30, 1, dpu0_pll_bypass_sels, ARRAY_SIZE(dpu0_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[DPU1_PLL_BYPASS] = thead_th1520_clk_mux_flags("dpu1_pll_bypass", ap_base + 0x54, 30, 1, dpu1_pll_bypass_sels, ARRAY_SIZE(dpu1_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+
+	clks[AHB2_CPUSYS_HCLK] = thead_th1520_clk_mux_flags("ahb2_cpusys_hclk", ap_base + 0x120, 5, 1, ahb2_cpusys_hclk_sels, ARRAY_SIZE(ahb2_cpusys_hclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[C910_CCLK_I0] = thead_th1520_clk_mux_flags("c910_cclk_i0", ap_base + 0x100, 1, 1, c910_cclk_i0_sels, ARRAY_SIZE(c910_cclk_i0_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[C910_CCLK] = thead_th1520_clk_mux_flags("c910_cclk", ap_base + 0x100, 0, 1, c910_cclk_sels, ARRAY_SIZE(c910_cclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[CFG_AXI_ACLK] = thead_th1520_clk_mux_flags("cfg_axi_aclk", ap_base + 0x138, 5, 1, cfg_axi_aclk_sels, ARRAY_SIZE(cfg_axi_aclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+
+	if (teesys)
+		clks[TEESYS_HCLK] = thead_th1520_clk_mux_flags("teesys_hclk", ap_base + 0x1cc, 13, 1, teesys_hclk_sels, ARRAY_SIZE(teesys_hclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT); //just for teesys!!!
+
+	clks[PERISYS_AHB_HCLK] = thead_th1520_clk_mux_flags("perisys_ahb_hclk", ap_base + 0x140, 5, 1, perisys_ahb_hclk_sels, ARRAY_SIZE(perisys_ahb_hclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[CLK_OUT_1] = thead_th1520_clk_mux_flags("clk_out_1", ap_base + 0x1b4, 4, 1, clk_out_1_sels, ARRAY_SIZE(clk_out_1_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[CLK_OUT_2] = thead_th1520_clk_mux_flags("clk_out_2", ap_base + 0x1b8, 4, 1, clk_out_2_sels, ARRAY_SIZE(clk_out_2_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[CLK_OUT_3] = thead_th1520_clk_mux_flags("clk_out_3", ap_base + 0x1bc, 4, 1, clk_out_3_sels, ARRAY_SIZE(clk_out_3_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[CLK_OUT_4] = thead_th1520_clk_mux_flags("clk_out_4", ap_base + 0x1c0, 4, 1, clk_out_4_sels, ARRAY_SIZE(clk_out_4_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[PERI_I2S_SRC_CLK] = thead_th1520_clk_mux_flags("peri_i2s_src_clk", ap_base + 0x1f0, 0, 1, peri_i2s_src_clk_sels, ARRAY_SIZE(peri_i2s_src_clk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[NPU_CCLK] = thead_th1520_clk_mux_flags("npu_cclk", ap_base + 0x1c8, 6, 1, npu_cclk_sels, ARRAY_SIZE(npu_cclk_sels), CLK_SET_RATE_PARENT);
+	clks[CFG_APB_PCLK] = thead_th1520_clk_mux_flags("cfg_apb_pclk", ap_base + 0x1c4, 7, 1, cfg_apb_pclk_sels, ARRAY_SIZE(cfg_apb_pclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[UART_SCLK] = thead_th1520_clk_mux_flags("uart_sclk", ap_base + 0x210, 0, 1, uart_sclk_sels, ARRAY_SIZE(uart_sclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+
+	/* Th1520 Fullmask AP Divider */
+	clks[AHB2_CPUSYS_HCLK_OUT_DIV] = thead_clk_th1520_divider("ahb2_cpusys_hclk_out_div", "gmac_pll_fout1ph0", ap_base + 0x120, 0, 3, 4, MUX_TYPE_DIV, 2, 7);
+	clks[APB3_CPUSYS_PCLK] = thead_clk_th1520_divider("apb3_cpusys_pclk", "ahb2_cpusys_hclk", ap_base + 0x130, 0, 3, 3, MUX_TYPE_CDE, 1, 7);
+	clks[AXI4_CPUSYS2_ACLK] = thead_clk_th1520_divider("axi4_cpusys2_aclk", "gmac_pll_foutpostdiv", ap_base + 0x134, 0, 3, 4, MUX_TYPE_DIV, 2, 7);
+	clks[CFG_AXI_ACLK_OUT_DIV] = thead_clk_th1520_divider("cfg_axi_aclk_out_div", "video_pll_foutpostdiv", ap_base + 0x138, 0, 4, 4, MUX_TYPE_DIV, 2, 15);
+
+	if (teesys) {
+		clks[TEESYS_I0_HCLK] = thead_clk_th1520_divider("teesys_i0_hclk", "tee_pll_foutpostdiv", ap_base + 0x1cc, 0, 4, 4, MUX_TYPE_DIV, 2, 15); //just for teesys!!!
+		clks[TEESYS_I1_HCLK] = thead_clk_th1520_divider("teesys_i1_hclk", "video_pll_foutpostdiv", ap_base + 0x1cc, 8, 4, 12, MUX_TYPE_DIV, 2, 15); //just for teesys!!!
+	}
+
+	clks[PERISYS_AHB_HCLK_OUT_DIV] = thead_clk_th1520_divider("perisys_ahb_hclk_out_div", "gmac_pll_fout1ph0", ap_base + 0x140, 0, 4, 4, MUX_TYPE_DIV, 2, 7);
+	clks[PERISYS_APB_PCLK] = thead_clk_th1520_divider("perisys_apb_pclk", "perisys_ahb_hclk", ap_base + 0x150, 0, 3, 3, MUX_TYPE_CDE, 3, 7);
+	clks[PERI2SYS_APB_PCLK] = thead_clk_th1520_divider("peri2sys_apb_pclk", "gmac_pll_fout4", ap_base + 0x150, 4, 3, 8, MUX_TYPE_DIV, 2, 7);
+	clks[CLK_OUT_1_OUT_DIV] = thead_clk_th1520_divider("clk_out_1_out_div", "osc_24m", ap_base + 0x1b4, 0, 3, 3, MUX_TYPE_DIV, 2, 4);
+	clks[CLK_OUT_2_OUT_DIV] = thead_clk_th1520_divider("clk_out_2_out_div", "osc_24m", ap_base + 0x1b8, 0, 3, 3, MUX_TYPE_DIV, 2, 4);
+	clks[CLK_OUT_3_OUT_DIV] = thead_clk_th1520_divider("clk_out_3_out_div", "osc_24m", ap_base + 0x1bc, 0, 3, 3, MUX_TYPE_DIV, 2, 4);
+	clks[CLK_OUT_4_OUT_DIV] = thead_clk_th1520_divider("clk_out_4_out_div", "osc_24m", ap_base + 0x1c0, 0, 3, 3, MUX_TYPE_DIV, 2, 4);
+	clks[VOSYS_ACLK_M] = thead_clk_th1520_divider("vosys_aclk_m", "video_pll_foutvco", ap_base + 0x1dc, 0, 4, 4, MUX_TYPE_DIV, 3, 15);
+	clks[NPU_CCLK_OUT_DIV] = thead_clk_th1520_divider("npu_cclk_out_div", "video_pll_foutvco", ap_base + 0x1c8, 0, 3, 3, MUX_TYPE_DIV, 3, 7);
+	clks[CFG_APB_PCLK_OUT_DIV] = thead_clk_th1520_divider("cfg_apb_pclk_out_div", "gmac_pll_foutpostdiv", ap_base + 0x1c4, 0, 4, 4, MUX_TYPE_DIV, 4, 15);
+	clks[VISYS_ACLK_M] = thead_clk_th1520_divider("visys_aclk_m", "video_pll_foutvco", ap_base + 0x1d0, 16, 4, 20, MUX_TYPE_DIV, 3, 15);
+	clks[VISYS_AHB_HCLK] = thead_clk_th1520_divider("visys_ahb_hclk", "video_pll_foutvco", ap_base + 0x1d0, 0, 4, 4, MUX_TYPE_DIV, 6, 15);
+	clks[VPSYS_APB_PCLK] = thead_clk_th1520_divider("vpsys_apb_pclk", "gmac_pll_fout1ph0", ap_base + 0x1e0, 0, 3, 4, MUX_TYPE_DIV, 2, 7);
+	clks[VPSYS_AXI_ACLK] = thead_clk_th1520_divider("vpsys_axi_aclk", "video_pll_foutvco", ap_base + 0x1e0, 8, 4, 12, MUX_TYPE_DIV, 3, 15);
+	clks[VENC_CCLK] = thead_clk_th1520_divider_closest("venc_cclk", "gmac_pll_foutpostdiv", ap_base + 0x1e4, 0, 3, 4, MUX_TYPE_DIV, 2, 7);
+	clks[DPU0_PLL_DIV_CLK] = thead_clk_th1520_divider("dpu0_pll_div_clk", "dpu0_pll_foutpostdiv", ap_base + 0x1e8, 0, 8, 8, MUX_TYPE_DIV, 2, 214);
+	clks[DPU1_PLL_DIV_CLK] = thead_clk_th1520_divider("dpu1_pll_div_clk", "dpu1_pll_foutpostdiv", ap_base + 0x1ec, 0, 8, 8, MUX_TYPE_DIV, 2, 214);
+
+	/* Th1520 Fullmask PLL FOUT */
+	clks[GMAC_PLL_FOUT1PH0] = thead_th1520_clk_fixed_factor("gmac_pll_fout1ph0", "gmac_pll_bypass", 1, 2);
+	clks[GMAC_PLL_FOUT4] = thead_th1520_clk_fixed_factor("gmac_pll_fout4", "gmac_pll_bypass", 1, 8);
+	clks[VIDEO_PLL_FOUT1PH0] = thead_th1520_clk_fixed_factor("video_pll_fout1ph0", "video_pll_bypass", 1, 2);
+	clks[VIDEO_PLL_FOUT4] = thead_th1520_clk_fixed_factor("video_pll_fout4", "video_pll_bypass", 1, 8);
+	clks[TEE_PLL_FOUT4] = thead_th1520_clk_fixed_factor("tee_pll_fout4", "tee_pll_bypass", 1, 8);
+	clks[CPU_PLL0_FOUT4] = thead_th1520_clk_fixed_factor("cpu_pll0_fout4", "cpu_pll0_bypass", 1, 8);
+	clks[CPU_PLL1_FOUT4] = thead_th1520_clk_fixed_factor("cpu_pll1_fout4", "cpu_pll1_bypass", 1, 8);
+	clks[DPU0_PLL_FOUT4] = thead_th1520_clk_fixed_factor("dpu0_pll_fout4", "dpu0_pll_bypass", 1, 8);
+	clks[DPU1_PLL_FOUT4] = thead_th1520_clk_fixed_factor("dpu1_pll_fout4", "dpu1_pll_bypass", 1, 8);
+
+	/* Th1520 Fullmask Fixed Factor */
+	clks[C910_OSC_CLK] = thead_th1520_clk_fixed_factor("c910_osc_clk", "osc_24m", 1, 1);
+	clks[QSPI_SSI_CLK] = thead_th1520_clk_fixed_factor("qspi_ssi_clk", "video_pll_foutpostdiv", 1, 1);		/* Note: no mux to select, use default value */
+	clks[QSPI0_SSI_CLK] = thead_th1520_clk_fixed_factor("qspi0_ssi_clk", "qspi_ssi_clk", 1, 1);
+	clks[QSPI1_SSI_CLK] = thead_th1520_clk_fixed_factor("qspi1_ssi_clk", "video_pll_fout1ph0", 1, 1);
+	clks[SPI_SSI_CLK] = thead_th1520_clk_fixed_factor("spi_ssi_clk", "video_pll_fout1ph0", 1, 1);
+	clks[EMMC_SDIO_REF_CLK] = thead_th1520_clk_fixed_factor("emmc_sdio_ref_clk", "video_pll_foutpostdiv", 1, 4);	/* Note: base clk is div 4 to 198M*/
+	clks[PWM_CCLK] = thead_th1520_clk_fixed_factor("pwm_cclk", "osc_24m", 1, 1);
+	clks[CHIP_DBG_CCLK] = thead_th1520_clk_fixed_factor("chip_dbg_cclk", "osc_24m", 1, 1);
+	clks[GMAC_CCLK] = thead_th1520_clk_fixed_factor("gmac_cclk", "gmac_pll_fout1ph0", 1, 1);
+	clks[GPIO0_DBCLK] = thead_th1520_clk_fixed_factor("gpio0_dbclk", "pad_rtc_clk", 1, 1);
+	clks[GPIO1_DBCLK] = thead_th1520_clk_fixed_factor("gpio1_dbclk", "pad_rtc_clk", 1, 1);
+	clks[GPIO2_DBCLK] = thead_th1520_clk_fixed_factor("gpio2_dbclk", "pad_rtc_clk", 1, 1);
+	clks[GPIO3_DBCLK] = thead_th1520_clk_fixed_factor("gpio3_dbclk", "pad_rtc_clk", 1, 1);
+	clks[CLK_100M] = thead_th1520_clk_fixed_factor("clk_100m", "gmac_pll_foutpostdiv", 1, 10);
+	clks[I2C_IC_CLK] = thead_th1520_clk_fixed_factor("i2c_ic_clk", "clk_100m", 1, 2);
+	clks[TIMER_CCLK] = thead_th1520_clk_fixed_factor("timer_cclk", "osc_24m", 1, 1);
+	clks[AXI4_CPUSYS1_ACLK] = thead_th1520_clk_fixed_factor("axi4_cpusys1_aclk", "clkgen_c910_bus_clk_no_icg", 1, 1);
+	clks[CPU_BUS_DFTCLK] = thead_th1520_clk_fixed_factor("cpu_bus_dftclk", "cpu_pll0_foutpostdiv", 1, 2);
+	clks[CPU_PLL0_TEST_CLK] = thead_th1520_clk_fixed_factor("cpu_pll0_test_clk", "cpu_pll0_fout4", 1, 8);
+	clks[CPU_PLL1_TEST_CLK] = thead_th1520_clk_fixed_factor("cpu_pll1_test_clk", "cpu_pll1_fout4", 1, 8);
+	clks[DPU0_PLL_TEST_CLK] = thead_th1520_clk_fixed_factor("dpu0_pll_test_clk", "dpu0_pll_fout4", 1, 8);
+	clks[DPU1_PLL_TEST_CLK] = thead_th1520_clk_fixed_factor("dpu1_pll_test_clk", "dpu1_pll_fout4", 1, 8);
+	clks[GMAC_PLL_TEST_CLK] = thead_th1520_clk_fixed_factor("gmac_pll_test_clk", "gmac_pll_fout4", 1, 8);
+	clks[VIDEO_PLL_TEST_CLK] = thead_th1520_clk_fixed_factor("video_pll_test_clk", "video_pll_fout4", 1, 8);
+	clks[TEE_PLL_TEST_CLK] = thead_th1520_clk_fixed_factor("tee_pll_test_clk", "tee_pll_fout4", 1, 8);
+	clks[AONSYS_BUS_CLK] = thead_th1520_clk_fixed_factor("aonsys_bus_clk", "aonsys_hclk", 1, 1);
+
+	/* Th1520 Fullmask Clock Gate */
+	clks[CLKGEN_AHB2_CPUSYS_HCLK] = thead_clk_th1520_gate("clkgen_ahb2_cpusys_hclk", "ahb2_cpusys_hclk", ap_base + 0x120, 6);
+	clks[CLKGEN_APB3_CPUSYS_HCLK] = thead_clk_th1520_gate("clkgen_apb3_cpusys_hclk", "ahb2_cpusys_hclk", ap_base + 0x130, 4);
+	clks[CLKGEN_C910_BROM_HCLK] = thead_clk_th1520_gate("clkgen_c910_brom_hclk", "ahb2_cpusys_hclk", ap_base + 0x100, 4);
+	clks[CLKGEN_SPINLOCK_HCLK] = thead_clk_th1520_gate("clkgen_spinlock_hclk", "ahb2_cpusys_hclk", ap_base + 0x208, 10);
+	clks[CLKGEN_MBOX0_PCLK] = thead_clk_th1520_gate("clkgen_mbox0_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 7);
+	clks[CLKGEN_MBOX1_PCLK] = thead_clk_th1520_gate("clkgen_mbox1_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 6);
+	clks[CLKGEN_MBOX2_PCLK] = thead_clk_th1520_gate("clkgen_mbox2_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 5);
+	clks[CLKGEN_MBOX3_PCLK] = thead_clk_th1520_gate("clkgen_mbox3_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 4);
+	clks[CLKGEN_WDT0_PCLK] = thead_clk_th1520_gate("clkgen_wdt0_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 3);
+	clks[CLKGEN_WDT1_PCLK] = thead_clk_th1520_gate("clkgen_wdt1_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 2);
+
+	if (teesys)
+		clks[CLKGEN_MISCSYS_TEE_CCLK] = thead_clk_th1520_gate("clkgen_miscsys_tee_cclk", "teesys_hclk", ap_base + 0x1cc, 25); //just for teesys!!!
+
+	clks[CLKGEN_SRAM_AXI_ACLK_2] = thead_clk_th1520_gate("clkgen_sram_axi_aclk_2", "axi4_cpusys1_aclk", ap_base + 0x20c, 2);
+	clks[CLKGEN_PERISYS_AHB_HCLK] = thead_clk_th1520_gate("clkgen_perisys_ahb_hclk", "perisys_ahb_hclk", ap_base + 0x140, 6);
+	clks[CLKGEN_PERISYS_APB1_HCLK] = thead_clk_th1520_gate("clkgen_perisys_apb1_hclk", "perisys_ahb_hclk", ap_base + 0x150, 9);
+	clks[CLKGEN_PERISYS_APB2_HCLK] = thead_clk_th1520_gate("clkgen_perisys_apb2_hclk", "perisys_ahb_hclk", ap_base + 0x150, 10);
+	clks[CLKGEN_PERISYS_APB4_HCLK] = thead_clk_th1520_gate("clkgen_perisys_apb4_hclk", "perisys_ahb_hclk", ap_base + 0x150, 12);
+	clks[CLKGEN_PADCTRL0_APSYS_PCLK] = thead_clk_th1520_gate("clkgen_padctrl0_apsys_pclk", "perisys_ahb_hclk", ap_base + 0x204, 22);
+	clks[CLKGEN_DSMART_PCLK] = thead_clk_th1520_gate("clkgen_dsmart_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 23);
+	clks[CLKGEN_PADCTRL1_APSYS_PCLK] = thead_clk_th1520_gate("clkgen_padctrl1_apsys_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 24);
+	clks[CLKGEN_CLK_OUT_1_CLK] = thead_clk_th1520_gate("clkgen_clk_out_1_clk", "clk_out_1", ap_base + 0x1b4, 5);
+	clks[CLKGEN_CLK_OUT_2_CLK] = thead_clk_th1520_gate("clkgen_clk_out_2_clk", "clk_out_2", ap_base + 0x1b8, 5);
+	clks[CLKGEN_CLK_OUT_3_CLK] = thead_clk_th1520_gate("clkgen_clk_out_3_clk", "clk_out_3", ap_base + 0x1bc, 5);
+	clks[CLKGEN_CLK_OUT_4_CLK] = thead_clk_th1520_gate("clkgen_clk_out_4_clk", "clk_out_4", ap_base + 0x1c0, 5);
+	clks[CLKGEN_NPUSYS_AXI_ACLK] = thead_clk_th1520_gate("clkgen_npusys_axi_aclk", "npu_cclk", ap_base + 0x1c8, 5);
+	clks[CLKGEN_SRAM_AXI_ACLK_0] = thead_clk_th1520_gate("clkgen_sram_axi_aclk_0", "npu_cclk", ap_base + 0x20c, 4);
+	clks[CLKGEN_APB_CPU2CFG_HCLK] = thead_clk_th1520_gate("clkgen_apb_cpu2cfg_hclk", "cfg_apb_pclk", ap_base + 0x1c4, 5);
+	clks[CLKGEN_SRAM_AXI_ACLK_1] = thead_clk_th1520_gate("clkgen_sram_axi_aclk_1", "visys_aclk_m", ap_base + 0x20c, 3);
+	clks[CLKGEN_SRAM_AXI_ACLK_3] = thead_clk_th1520_gate("clkgen_sram_axi_aclk_3", "vpsys_axi_aclk", ap_base + 0x20c, 1);
+	clks[CLKGEN_VPSYS_VENC_CCLK] = thead_clk_th1520_gate("clkgen_vpsys_venc_cclk", "venc_cclk", ap_base + 0x1e4, 5);
+	clks[CLKGEN_EMMC_SDIO_REF_CLK] = thead_clk_th1520_gate("clkgen_emmc_sdio_ref_clk", "emmc_sdio_ref_clk", ap_base + 0x204, 30);
+
+	clks[CLKGEN_X2H_CPUSYS_MHCLK] = thead_clk_th1520_gate_shared("clkgen_x2h_cpusys_mhclk", "ahb2_cpusys_hclk", ap_base + 0x120, 7, &share_cnt_x2h_cpusys_clk_en);
+	clks[CLKGEN_X2H_CPUSYS_ACLK] = thead_clk_th1520_gate_shared("clkgen_x2h_cpusys_aclk", "cfg_axi_aclk", ap_base + 0x120, 7, &share_cnt_x2h_cpusys_clk_en);
+	clks[CLKGEN_DMAC_CPUSYS_HCLK] = thead_clk_th1520_gate_shared("clkgen_dmac_cpusys_hclk", "ahb2_cpusys_hclk", ap_base + 0x208, 8, &share_cnt_dmac_cpusys_clk_en);
+	clks[CLKGEN_IOPMP_DMAC_CPUSYS_PCLK] = thead_clk_th1520_gate_shared("clkgen_iopmp_dmac_cpusys_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 8, &share_cnt_dmac_cpusys_clk_en);
+	clks[CLKGEN_DMAC_CPUSYS_ACLK] = thead_clk_th1520_gate_shared("clkgen_dmac_cpusys_aclk", "axi4_cpusys2_aclk", ap_base + 0x208, 8, &share_cnt_dmac_cpusys_clk_en);
+	clks[CLKGEN_TIMER0_PCLK] = thead_clk_th1520_gate_shared("clkgen_timer0_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 1, &share_cnt_timer0_clk_en);
+	clks[CLKGEN_TIMER0_CCLK] = thead_clk_th1520_gate_shared("clkgen_timer0_cclk", "timer_cclk", ap_base + 0x208, 1, &share_cnt_timer0_clk_en);
+	clks[CLKGEN_TIMER1_PCLK] = thead_clk_th1520_gate_shared("clkgen_timer1_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 0, &share_cnt_timer1_clk_en);
+	clks[CLKGEN_TIMER1_CCLK] = thead_clk_th1520_gate_shared("clkgen_timer1_cclk", "timer_cclk", ap_base + 0x208, 0, &share_cnt_timer1_clk_en);
+	clks[CLKGEN_AXI4_CPUSYS2_PCLK] = thead_clk_th1520_gate_shared("clkgen_axi4_cpusys2_pclk", "apb3_cpusys_pclk", ap_base + 0x134, 5, &share_cnt_axi4_cpusys2_clk_en);
+	clks[CLKGEN_AXI4_CPUSYS2_ACLK] = thead_clk_th1520_gate_shared("clkgen_axi4_cpusys2_aclk", "axi4_cpusys2_aclk", ap_base + 0x134, 5, &share_cnt_axi4_cpusys2_clk_en);
+	clks[CLKGEN_BMU_C910_PCLK] = thead_clk_th1520_gate_shared("clkgen_bmu_c910_pclk", "apb3_cpusys_pclk", ap_base + 0x100, 5, &share_cnt_bmu_c910_clk_en);
+	clks[CLKGEN_BMU_C910_ACLK] = thead_clk_th1520_gate_shared("clkgen_bmu_c910_aclk", "axi4_cpusys1_aclk", ap_base + 0x100, 5, &share_cnt_bmu_c910_clk_en);
+	clks[CLKGEN_IOPMP_AON_PCLK] = thead_clk_th1520_gate_shared("clkgen_iopmp_aon_pclk", "apb3_cpusys_pclk", ap_base + 0x134, 8, &share_cnt_aon2cpu_a2x_clk_en);
+	clks[CLKGEN_AON2CPU_A2X_ACLK] = thead_clk_th1520_gate_shared("clkgen_aon2cpu_a2x_aclk", "axi4_cpusys2_aclk", ap_base + 0x134, 8, &share_cnt_aon2cpu_a2x_clk_en);
+	clks[CLKGEN_AON2CPU_A2X_HCLK] = thead_clk_th1520_gate_shared("clkgen_aon2cpu_a2x_hclk", "aonsys_bus_clk", ap_base + 0x134, 8, &share_cnt_aon2cpu_a2x_clk_en);
+	clks[CLKGEN_IOPMP_CHIP_DBG_PCLK] = thead_clk_th1520_gate_shared("clkgen_iopmp_chip_dbg_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 9, &share_cnt_chip_dbg_clk_en);
+	clks[CLKGEN_CHIP_DBG_ACLK] = thead_clk_th1520_gate_shared("clkgen_chip_dbg_aclk", "axi4_cpusys2_aclk", ap_base + 0x208, 9, &share_cnt_chip_dbg_clk_en);
+	clks[CLKGEN_CHIP_DBG_CCLK] = thead_clk_th1520_gate_shared("clkgen_chip_dbg_cclk", "chip_dbg_cclk", ap_base + 0x208, 9, &share_cnt_chip_dbg_clk_en);
+	clks[CLKGEN_X2X_CPUSYS_ACLK_M] = thead_clk_th1520_gate_shared("clkgen_x2x_cpusys_aclk_m", "axi4_cpusys2_aclk", ap_base + 0x134, 7, &share_cnt_x2x_cpusys_clk_en);
+	clks[CLKGEN_X2X_CPUSYS_ACLK_S] = thead_clk_th1520_gate_shared("clkgen_x2x_cpusys_aclk_s", "axi4_cpusys1_aclk", ap_base + 0x134, 7, &share_cnt_x2x_cpusys_clk_en);
+	clks[CLKGEN_CPU2PERI_X2H_ACLK] = thead_clk_th1520_gate_shared("clkgen_cpu2peri_x2h_aclk", "axi4_cpusys1_aclk", ap_base + 0x140, 9, &share_cnt_cpu2peri_x2h_clk_en);
+	clks[CLKGEN_CPU2PERI_X2H_MHCLK] = thead_clk_th1520_gate_shared("clkgen_cpu2peri_x2h_mhclk", "perisys_ahb_hclk", ap_base + 0x140, 9, &share_cnt_cpu2peri_x2h_clk_en);
+	clks[CLKGEN_CPU2VI_X2H_ACLK] = thead_clk_th1520_gate_shared("clkgen_cpu2vi_x2h_aclk", "axi4_cpusys1_aclk", ap_base + 0x1d0, 21, &share_cnt_cpu2vi_x2h_clk_en);
+	clks[CLKGEN_CPU2VI_X2H_MHCLK] = thead_clk_th1520_gate_shared("clkgen_cpu2vi_x2h_mhclk", "visys_ahb_hclk", ap_base + 0x1d0, 21, &share_cnt_cpu2vi_x2h_clk_en);
+	clks[CLKGEN_CFG2TEE_X2H_ACLK] = thead_clk_th1520_gate_shared("clkgen_cfg2tee_x2h_aclk", "cfg_axi_aclk", ap_base + 0x1cc, 24, &share_cnt_cfg2tee_x2h_clk_en); // just for teesys!!!
+	clks[CLKGEN_CFG2TEE_X2H_MHCLK] = thead_clk_th1520_gate_shared("clkgen_cfg2tee_x2h_mhclk", "teesys_hclk", ap_base + 0x1cc, 24, &share_cnt_cfg2tee_x2h_clk_en); // just for teesys!!!
+	clks[CLKGEN_CPU2AON_X2H_ACLK] = thead_clk_th1520_gate_shared("clkgen_cpu2aon_x2h_aclk", "cfg_axi_aclk", ap_base + 0x138, 8, &share_cnt_cpu2aon_x2h_clk_en);
+	clks[CLKGEN_CPU2AON_X2H_MHCLK] = thead_clk_th1520_gate_shared("clkgen_cpu2aon_x2h_mhclk", "aonsys_bus_clk", ap_base + 0x138, 8, &share_cnt_cpu2aon_x2h_clk_en);
+	clks[CLKGEN_CPU2VP_X2P_ACLK] = thead_clk_th1520_gate_shared("clkgen_cpu2vp_x2p_aclk", "cfg_axi_aclk", ap_base + 0x1e0, 13, &share_cnt_cpu2vp_x2p_clk_en);
+	clks[CLKGEN_CPU2VP_X2P_PCLK] = thead_clk_th1520_gate_shared("clkgen_cpu2vp_x2p_pclk", "vpsys_apb_pclk", ap_base + 0x1e0, 13, &share_cnt_cpu2vp_x2p_clk_en);
+	clks[CLKGEN_TOP_AXI4S_ACLK] = thead_clk_th1520_gate_shared("clkgen_top_axi4s_aclk", "cfg_axi_aclk", ap_base + 0x1c8, 4, &share_cnt_npu_core_clk_en);
+	clks[CLKGEN_TOP_APB_SX_PCLK] = thead_clk_th1520_gate_shared("clkgen_top_apb_sx_pclk", "cfg_apb_pclk", ap_base + 0x1c8, 4, &share_cnt_npu_core_clk_en);
+	clks[CLKGEN_MISC2VP_X2X_ACLK_M] = thead_clk_th1520_gate_shared("clkgen_misc2vp_x2x_aclk_m", "perisys_ahb_hclk", ap_base + 0x1e0, 15, &share_cnt_vpsys_axi_aclk_en);
+	clks[CLKGEN_VPSYS_ACLK] = thead_clk_th1520_gate_shared("clkgen_vpsys_aclk", "vpsys_axi_aclk", ap_base + 0x1e0, 15, &share_cnt_vpsys_axi_aclk_en);
+	clks[CLKGEN_GMAC1_HCLK] = thead_clk_th1520_gate_shared("clkgen_gmac1_hclk", "perisys_ahb_hclk", ap_base + 0x204, 26, &share_cnt_gmac1_clk_en);
+	clks[CLKGEN_GMAC1_PCLK] = thead_clk_th1520_gate_shared("clkgen_gmac1_pclk", "perisys_ahb_hclk", ap_base + 0x204, 26, &share_cnt_gmac1_clk_en);
+	clks[CLKGEN_GMAC1_CCLK] = thead_clk_th1520_gate_shared("clkgen_gmac1_cclk", "gmac_cclk", ap_base + 0x204, 26, &share_cnt_gmac1_clk_en);
+	clks[CLKGEN_GMAC0_HCLK] = thead_clk_th1520_gate_shared("clkgen_gmac0_hclk", "perisys_ahb_hclk", ap_base + 0x204, 19, &share_cnt_gmac0_clk_en);
+	clks[CLKGEN_GMAC0_PCLK] = thead_clk_th1520_gate_shared("clkgen_gmac0_pclk", "perisys_ahb_hclk", ap_base + 0x204, 19, &share_cnt_gmac0_clk_en);
+	clks[CLKGEN_GMAC0_CCLK] = thead_clk_th1520_gate_shared("clkgen_gmac0_cclk", "gmac_cclk", ap_base + 0x204, 19, &share_cnt_gmac0_clk_en);
+	clks[CLKGEN_PERI2PERI1_APB_HCLK] = thead_clk_th1520_gate_shared("clkgen_peri2peri1_apb_hclk", "perisys_ahb_hclk", ap_base + 0x150, 11, &share_cnt_perisys_apb3_hclk_en);
+	clks[CLKGEN_PERI2PERI1_APB_PCLK] = thead_clk_th1520_gate_shared("clkgen_peri2peri1_apb_pclk", "peri2sys_apb_pclk", ap_base + 0x150, 11, &share_cnt_perisys_apb3_hclk_en);
+	clks[CLKGEN_QSPI0_PCLK] = thead_clk_th1520_gate_shared("clkgen_qspi0_pclk", "perisys_ahb_hclk", ap_base + 0x204, 17, &share_cnt_qspi0_clk_en);
+	clks[CLKGEN_QSPI0_SSI_CLK] = thead_clk_th1520_gate_shared("clkgen_qspi0_ssi_clk", "qspi0_ssi_clk", ap_base + 0x204, 17, &share_cnt_qspi0_clk_en);
+	clks[CLKGEN_GMAC_AXI_ACLK] = thead_clk_th1520_gate_shared("clkgen_gmac_axi_aclk", "perisys_ahb_hclk", ap_base + 0x204, 21, &share_cnt_gmac_axi_clk_en);
+	clks[CLKGEN_GMAC_AXI_PCLK] = thead_clk_th1520_gate_shared("clkgen_gmac_axi_pclk", "perisys_ahb_hclk", ap_base + 0x204, 21, &share_cnt_gmac_axi_clk_en);
+	clks[CLKGEN_GPIO0_PCLK] = thead_clk_th1520_gate_shared("clkgen_gpio0_pclk", "perisys_ahb_hclk", ap_base + 0x204, 8, &share_cnt_gpio0_clk_en);
+	clks[CLKGEN_GPIO0_DBCLK] = thead_clk_th1520_gate_shared("clkgen_gpio0_dbclk", "gpio0_dbclk", ap_base + 0x204, 8, &share_cnt_gpio0_clk_en);
+	clks[CLKGEN_GPIO1_PCLK] = thead_clk_th1520_gate_shared("clkgen_gpio1_pclk", "perisys_ahb_hclk", ap_base + 0x204, 7, &share_cnt_gpio0_clk_en);
+	clks[CLKGEN_GPIO1_DBCLK] = thead_clk_th1520_gate_shared("clkgen_gpio1_dbclk", "gpio1_dbclk", ap_base + 0x204, 7, &share_cnt_gpio1_clk_en);
+	clks[CLKGEN_PWM_PCLK] = thead_clk_th1520_gate_shared("clkgen_pwm_pclk", "perisys_apb_pclk", ap_base + 0x204, 18, &share_cnt_pwm_clk_en);
+	clks[CLKGEN_PWM_CCLK] = thead_clk_th1520_gate_shared("clkgen_pwm_cclk", "pwm_cclk", ap_base + 0x204, 18, &share_cnt_pwm_clk_en);
+	clks[CLKGEN_SPI_PCLK] = thead_clk_th1520_gate_shared("clkgen_spi_pclk", "perisys_apb_pclk", ap_base + 0x204, 15, &share_cnt_spi_clk_en);
+	clks[CLKGEN_SPI_SSI_CLK] = thead_clk_th1520_gate_shared("clkgen_spi_ssi_clk", "spi_ssi_clk", ap_base + 0x204, 15, &share_cnt_spi_clk_en);
+	clks[CLKGEN_UART0_PCLK] = thead_clk_th1520_gate_shared("clkgen_uart0_pclk", "perisys_apb_pclk", ap_base + 0x204, 14, &share_cnt_uart0_clk_en);
+	clks[CLKGEN_UART0_SCLK] = thead_clk_th1520_gate_shared("clkgen_uart0_sclk", "uart_sclk", ap_base + 0x204, 14, &share_cnt_uart0_clk_en);
+	clks[CLKGEN_UART2_PCLK] = thead_clk_th1520_gate_shared("clkgen_uart2_pclk", "perisys_apb_pclk", ap_base + 0x204, 12, &share_cnt_uart2_clk_en);
+	clks[CLKGEN_UART2_SCLK] = thead_clk_th1520_gate_shared("clkgen_uart2_sclk", "uart_sclk", ap_base + 0x204, 12, &share_cnt_uart2_clk_en);
+	clks[CLKGEN_I2C2_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2c2_pclk", "perisys_apb_pclk", ap_base + 0x204, 3, &share_cnt_i2c2_clk_en);
+	clks[CLKGEN_I2C2_IC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2c2_ic_clk", "i2c_ic_clk", ap_base + 0x204, 3, &share_cnt_i2c2_clk_en);
+	clks[CLKGEN_I2C3_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2c3_pclk", "perisys_apb_pclk", ap_base + 0x204, 2, &share_cnt_i2c3_clk_en);
+	clks[CLKGEN_I2C3_IC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2c3_ic_clk", "i2c_ic_clk", ap_base + 0x204, 2, &share_cnt_i2c3_clk_en);
+	clks[CLKGEN_I2S_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2s_pclk", "perisys_apb_pclk", ap_base + 0x1f0, 1, &share_cnt_peri_i2s_clk_en);
+	clks[CLKGEN_I2S_SRC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2s_src_clk", "peri_i2s_src_clk", ap_base + 0x1f0, 1, &share_cnt_peri_i2s_clk_en);
+	clks[CLKGEN_QSPI1_PCLK] = thead_clk_th1520_gate_shared("clkgen_qspi1_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 16, &share_cnt_qspi1_clk_en);
+	clks[CLKGEN_QSPI1_SSI_CLK] = thead_clk_th1520_gate_shared("clkgen_qspi1_ssi_clk", "qspi1_ssi_clk", ap_base + 0x204, 16, &share_cnt_qspi1_clk_en);
+	clks[CLKGEN_UART1_PCLK] = thead_clk_th1520_gate_shared("clkgen_uart1_pclk", "per2sys_apb_pclk", ap_base + 0x204, 13, &share_cnt_uart1_clk_en);
+	clks[CLKGEN_UART1_SCLK] = thead_clk_th1520_gate_shared("clkgen_uart1_sclk", "uart_sclk", ap_base + 0x204, 13, &share_cnt_uart1_clk_en);
+	clks[CLKGEN_UART3_PCLK] = thead_clk_th1520_gate_shared("clkgen_uart3_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 11, &share_cnt_uart3_clk_en);
+	clks[CLKGEN_UART3_SCLK] = thead_clk_th1520_gate_shared("clkgen_uart3_sclk", "uart_sclk", ap_base + 0x204, 11, &share_cnt_uart3_clk_en);
+	clks[CLKGEN_UART4_PCLK] = thead_clk_th1520_gate_shared("clkgen_uart4_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 10, &share_cnt_uart4_clk_en);
+	clks[CLKGEN_UART4_SCLK] = thead_clk_th1520_gate_shared("clkgen_uart4_sclk", "uart_sclk", ap_base + 0x204, 10, &share_cnt_uart4_clk_en);
+	clks[CLKGEN_UART5_PCLK] = thead_clk_th1520_gate_shared("clkgen_uart5_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 9, &share_cnt_uart5_clk_en);
+	clks[CLKGEN_UART5_SCLK] = thead_clk_th1520_gate_shared("clkgen_uart5_sclk", "uart_sclk", ap_base + 0x204, 9, &share_cnt_uart5_clk_en);
+	clks[CLKGEN_I2C0_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2c0_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 5, &share_cnt_i2c0_clk_en);
+	clks[CLKGEN_I2C0_IC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2c0_ic_clk", "i2c_ic_clk", ap_base + 0x204, 5, &share_cnt_i2c0_clk_en);
+	clks[CLKGEN_I2C1_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2c1_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 4, &share_cnt_i2c1_clk_en);
+	clks[CLKGEN_I2C1_IC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2c1_ic_clk", "i2c_ic_clk", ap_base + 0x204, 4, &share_cnt_i2c1_clk_en);
+	clks[CLKGEN_I2C4_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2c4_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 1, &share_cnt_i2c4_clk_en);
+	clks[CLKGEN_I2C4_IC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2c4_ic_clk", "i2c_ic_clk", ap_base + 0x204, 1, &share_cnt_i2c4_clk_en);
+	clks[CLKGEN_I2C5_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2c5_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 0, &share_cnt_i2c5_clk_en);
+	clks[CLKGEN_I2C5_IC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2c5_ic_clk", "i2c_ic_clk", ap_base + 0x204, 0, &share_cnt_i2c5_clk_en);
+	clks[CLKGEN_GPIO2_PCLK] = thead_clk_th1520_gate_shared("clkgen_gpio2_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 6, &share_cnt_gpio2_clk_en);
+	clks[CLKGEN_GPIO2_DBCLK] = thead_clk_th1520_gate_shared("clkgen_gpio2_dbclk", "gpio2_dbclk", ap_base + 0x204, 6, &share_cnt_gpio2_clk_en);
+	clks[CLKGEN_GPIO3_PCLK] = thead_clk_th1520_gate_shared("clkgen_gpio3_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 6, &share_cnt_gpio2_clk_en); //!!! gpio3 pclk is controlled by gpio2_clk_en
+	clks[CLKGEN_GPIO3_DBCLK] = thead_clk_th1520_gate_shared("clkgen_gpio3_dbclk", "gpio3_dbclk", ap_base + 0x204, 20, &share_cnt_gpio3_clk_en);
+	clks[CLKGEN_VOSYS_AXI_ACLK] = thead_clk_th1520_gate_shared("clkgen_vosys_axi_aclk", "vosys_aclk_m", ap_base + 0x1dc, 5, &share_cnt_vosys_axi_aclk_en);
+	clks[CLKGEN_VOSYS_X2X_ACLK_S] = thead_clk_th1520_gate_shared("clkgen_vosys_x2x_aclk_s", "npu_cclk", ap_base + 0x1dc, 5, &share_cnt_vosys_axi_aclk_en);
+
+	clk_data.clks = clks;
+	clk_data.clk_num = ARRAY_SIZE(clks);
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register clks for th1520\n");
+		goto unregister_clks;
+	}
+
+#ifndef FPGA_EMU
+	/* HW defalut */
+	clk_set_parent(clks[C910_CCLK], clks[CPU_PLL1_FOUTPOSTDIV]);
+#else
+	clk_set_parent(clks[C910_CCLK_I0], clks[OSC_24M]);
+	clk_set_parent(clks[C910_CCLK], clks[C910_CCLK_I0]);
+#endif
+	dev_info(dev, "succeed to register th1520 fullmask clock driver\n");
+
+	return 0;
+
+unregister_clks:
+	thead_unregister_clocks(clks, ARRAY_SIZE(clks));
+	return ret;
+}
+
+const bool tee_sys_flag;
+
+static const struct of_device_id th1520_clk_of_match[] = {
+	{ .compatible = "thead,th1520-fm-ree-clk" },
+	{ .compatible = "thead,th1520-fm-tee-clk", .data = &tee_sys_flag,},
+	{ /* Sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, th1520_clk_of_match);
+
+static struct platform_driver th1520_clk_driver = {
+	.probe = th1520_clocks_probe,
+	.driver = {
+		.name = "th1520-fm-clk",
+		.of_match_table = of_match_ptr(th1520_clk_of_match),
+	},
+};
+
+module_platform_driver(th1520_clk_driver);
+MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
+MODULE_DESCRIPTION("Thead Th1520 Fullmask clock driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/thead/clk.c b/drivers/clk/thead/clk.c
new file mode 100644
index 000000000000..a64eff5b08df
--- /dev/null
+++ b/drivers/clk/thead/clk.c
@@ -0,0 +1,766 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include "clk.h"
+
+#define TH1520_PLL_CFG0		0x0
+#define TH1520_PLL_CFG1		0x04
+#define TH1520_PLL_CFG2		0x8
+#define TH1520_POSTDIV2_SHIFT	24
+#define TH1520_POSTDIV2_MASK	GENMASK(26, 24)
+#define TH1520_POSTDIV1_SHIFT	20
+#define TH1520_POSTDIV1_MASK	GENMASK(22, 20)
+#define TH1520_FBDIV_SHIFT	8
+#define TH1520_FBDIV_MASK	GENMASK(19, 8)
+#define TH1520_REFDIV_SHIFT	0
+#define TH1520_REFDIV_MASK	GENMASK(5, 0)
+#define TH1520_BYPASS_MASK	BIT(30)
+#define TH1520_RST_MASK		BIT(29)
+#define TH1520_DSMPD_MASK	BIT(24)
+#define TH1520_DACPD_MASK	BIT(25)
+#define TH1520_FRAC_MASK		GENMASK(23, 0)
+#define TH1520_FRAC_SHIFT	0
+#define TH1520_FRAC_DIV		BIT(24)
+
+#define LOCK_TIMEOUT_US		10000
+
+#define div_mask(d)	((1 << (d->width)) - 1)
+
+DEFINE_SPINLOCK(thead_th1520_clk_lock);
+
+enum th1520_pll_mode {
+        PLL_MODE_FRAC,
+        PLL_MODE_INT,
+};
+
+struct clk_th1520pll {
+	struct clk_hw			hw;
+	void __iomem			*base;
+	enum th1520_pll_clktype		clk_type;
+	enum th1520_pll_outtype		out_type;
+	enum th1520_pll_mode		pll_mode;
+	const struct th1520_pll_rate_table *rate_table;
+	int rate_count;
+
+	u32 cfg0_reg_off;
+	u32 pll_sts_off;
+	int pll_lock_bit;
+
+	/* Th1520 MPW Aon/ddr pll define bypass:rst bits as: 31:30
+	 * but AP pll define bypass:rst bits as: 30:29
+	 *
+	 * Th1520 Fullmask align these register field define, all pll
+	 * define bypss:rst bits as: 30:29
+	 */
+	int pll_rst_bit;
+	int pll_bypass_bit;
+};
+
+struct clk_th1520div {
+	struct clk_divider divider;
+	enum th1520_div_type div_type;
+	u16 min_div;
+	u16 max_div;
+	u8 sync_en;
+	const struct clk_ops *ops;
+};
+
+struct clk_th1520gate {
+	struct clk_gate gate;
+	unsigned int *share_count;
+	const struct clk_ops *ops;
+};
+
+#define to_clk_th1520pll(_hw) container_of(_hw, struct clk_th1520pll, hw)
+
+void thead_unregister_clocks(struct clk *clks[], unsigned int count)
+{
+        unsigned int i;
+
+        for (i = 0; i < count; i++)
+                clk_unregister(clks[i]);
+}
+
+static void clk_th1520_pll_cfg_init(struct clk_th1520pll *pll)
+{
+	switch (pll->clk_type) {
+	case TH1520_AUDIO_PLL:
+		pll->cfg0_reg_off = 0x0;
+		pll->pll_sts_off = 0x90;
+		pll->pll_lock_bit = BIT(0);
+		pll->pll_bypass_bit = BIT(31);
+		pll->pll_rst_bit = BIT(30);
+		pll->pll_mode = PLL_MODE_FRAC;
+		break;
+	case TH1520_SYS_PLL:
+		pll->cfg0_reg_off = 0x10;
+		pll->pll_sts_off = 0x90;
+		pll->pll_lock_bit = BIT(1);
+		pll->pll_bypass_bit = BIT(31);
+		pll->pll_rst_bit = BIT(30);
+		pll->pll_mode = PLL_MODE_FRAC;
+		break;
+	case TH1520_CPU_PLL0:
+		pll->cfg0_reg_off = 0x0;
+		pll->pll_sts_off = 0x80;
+		pll->pll_lock_bit = BIT(1);
+		pll->pll_bypass_bit = BIT(30);
+		pll->pll_rst_bit = BIT(29);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	case TH1520_CPU_PLL1:
+		pll->cfg0_reg_off = 0x10;
+		pll->pll_sts_off = 0x80;
+		pll->pll_lock_bit = BIT(4);
+		pll->pll_bypass_bit = BIT(30);
+		pll->pll_rst_bit = BIT(29);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	case TH1520_GMAC_PLL:
+		pll->cfg0_reg_off = 0x20;
+		pll->pll_sts_off = 0x80;
+		pll->pll_lock_bit = BIT(3);
+		pll->pll_bypass_bit = BIT(30);
+		pll->pll_rst_bit = BIT(29);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	case TH1520_VIDEO_PLL:
+		pll->cfg0_reg_off = 0x30;
+		pll->pll_sts_off = 0x80;
+		pll->pll_lock_bit = BIT(7);
+		pll->pll_bypass_bit = BIT(30);
+		pll->pll_rst_bit = BIT(29);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	case TH1520_DDR_PLL:
+		pll->cfg0_reg_off = 0x8;
+		pll->pll_sts_off = 0x18;
+		pll->pll_lock_bit = BIT(0);
+		pll->pll_bypass_bit = BIT(31);
+		pll->pll_rst_bit = BIT(30);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	case TH1520_DPU0_PLL:
+		pll->cfg0_reg_off = 0x40;
+		pll->pll_sts_off = 0x80;
+		pll->pll_lock_bit = BIT(8);
+		pll->pll_bypass_bit = BIT(30);
+		pll->pll_rst_bit = BIT(29);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	case TH1520_DPU1_PLL:
+		pll->cfg0_reg_off = 0x50;
+		pll->pll_sts_off = 0x80;
+		pll->pll_lock_bit = BIT(9);
+		pll->pll_bypass_bit = BIT(30);
+		pll->pll_rst_bit = BIT(29);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	default:
+		pr_err("%s: Unknown pll type\n", __func__);
+	};
+}
+
+static int clk_th1520_pll_wait_lock(struct clk_th1520pll *pll)
+{
+	u32 val;
+
+	return readl_poll_timeout(pll->base + pll->pll_sts_off, val,
+				  val & pll->pll_lock_bit, 0,
+				  LOCK_TIMEOUT_US);
+}
+
+static int clk_th1520_pll_prepare(struct clk_hw *hw)
+{
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	void __iomem *cfg1_off;
+	u32 val;
+	int ret;
+
+	cfg1_off = pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1;
+	val = readl_relaxed(cfg1_off);
+	if (!(val & pll->pll_rst_bit))
+		return 0;
+
+	/* Enable RST */
+	val |= pll->pll_rst_bit;
+	writel_relaxed(val, cfg1_off);
+
+	udelay(3);
+
+	/* Disable RST */
+	val &= ~pll->pll_rst_bit;
+	writel_relaxed(val, cfg1_off);
+
+	ret = clk_th1520_pll_wait_lock(pll);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int clk_th1520_pll_is_prepared(struct clk_hw *hw)
+{
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	u32 val;
+
+	val = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+
+	return (val & pll->pll_rst_bit) ? 0 : 1;
+}
+
+static void clk_th1520_pll_unprepare(struct clk_hw *hw)
+{
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	u32 val;
+
+	val = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+	val |= pll->pll_rst_bit;
+	writel_relaxed(val, pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+}
+
+static unsigned long clk_th1520_pll_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+#ifndef CONFIG_TH1520_CLK_EMU
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	u32 refdiv, fbdiv, postdiv1, postdiv2, frac;
+	u32 pll_cfg0, pll_cfg1;
+	u64 fvco = 0;
+
+	pll_cfg0 = readl_relaxed(pll->base + pll->cfg0_reg_off);
+	pll_cfg1 = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+	refdiv = (pll_cfg0 & TH1520_REFDIV_MASK) >> TH1520_REFDIV_SHIFT;
+	fbdiv = (pll_cfg0 & TH1520_FBDIV_MASK) >> TH1520_FBDIV_SHIFT;
+	postdiv1 = (pll_cfg0 & TH1520_POSTDIV1_MASK) >> TH1520_POSTDIV1_SHIFT;
+	postdiv2 = (pll_cfg0 & TH1520_POSTDIV2_MASK) >> TH1520_POSTDIV2_SHIFT;
+	frac = (pll_cfg1 & TH1520_FRAC_MASK) >> TH1520_FRAC_SHIFT;
+
+	/* rate calculation:
+	 * INT mode: FOUTVCO = FREE * FBDIV / REFDIV
+	 * FRAC mode:FOUTVCO = (FREE * FBDIV + FREE * FRAC/BIT(24)) / REFDIV
+	 */
+	if (pll->pll_mode == PLL_MODE_FRAC)
+		fvco = (parent_rate * frac) / TH1520_FRAC_DIV;
+
+	fvco += (parent_rate * fbdiv);
+	do_div(fvco, refdiv);
+
+	if (pll->out_type == TH1520_PLL_DIV)
+		do_div(fvco, postdiv1 * postdiv2);
+
+	return fvco;
+#else
+
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
+
+	/* return minimum supported value */
+	if (pll->out_type == TH1520_PLL_DIV)
+		return rate_table[0].rate;
+
+	return rate_table[0].vco_rate;
+#endif
+}
+
+static const struct th1520_pll_rate_table *th1520_get_pll_div_settings(
+		struct clk_th1520pll *pll, unsigned long rate)
+{
+	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
+	int i;
+
+	for (i = 0; i < pll->rate_count; i++)
+		if (rate == rate_table[i].rate)
+			return &rate_table[i];
+
+	return NULL;
+}
+
+static const struct th1520_pll_rate_table *th1520_get_pll_vco_settings(
+		struct clk_th1520pll *pll, unsigned long rate)
+{
+	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
+	int i;
+
+	for (i = 0; i < pll->rate_count; i++)
+		if (rate == rate_table[i].vco_rate)
+			return &rate_table[i];
+
+	return NULL;
+}
+
+static inline bool clk_th1520_pll_change(struct clk_th1520pll *pll,
+					const struct th1520_pll_rate_table *rate)
+{
+	u32 refdiv_old, fbdiv_old, postdiv1_old, postdiv2_old, frac_old;
+	u32 cfg0, cfg1;
+	bool pll_changed;
+
+	cfg0 = readl_relaxed(pll->base + pll->cfg0_reg_off);
+	cfg1 = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+
+	refdiv_old = (cfg0 & TH1520_REFDIV_MASK) >> TH1520_REFDIV_SHIFT;
+	fbdiv_old = (cfg0 & TH1520_FBDIV_MASK) >> TH1520_FBDIV_SHIFT;
+	postdiv1_old = (cfg0 & TH1520_POSTDIV1_MASK) >> TH1520_POSTDIV1_SHIFT;
+	postdiv2_old = (cfg0 & TH1520_POSTDIV2_MASK) >> TH1520_POSTDIV2_SHIFT;
+	frac_old = (cfg1 & TH1520_FRAC_MASK) >> TH1520_FRAC_SHIFT;
+
+	pll_changed = rate->refdiv != refdiv_old || rate->fbdiv != fbdiv_old ||
+		      rate->postdiv1 != postdiv1_old || rate->postdiv2 != postdiv2_old;
+	if (pll->pll_mode == PLL_MODE_FRAC)
+		pll_changed |= (rate->frac != frac_old);
+
+	return pll_changed;
+}
+
+static int clk_th1520_pll_set_rate(struct clk_hw *hw, unsigned long drate,
+				 unsigned long prate)
+{
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	const struct th1520_pll_rate_table *rate;
+	void __iomem *cfg1_off;
+	u32 tmp, div_val;
+	int ret;
+
+	if (pll->out_type == TH1520_PLL_VCO) {
+		rate = th1520_get_pll_vco_settings(pll, drate);
+		if (!rate) {
+			pr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,
+				drate, clk_hw_get_name(hw));
+			return -EINVAL;
+		}
+	} else {
+		rate = th1520_get_pll_div_settings(pll, drate);
+		if (!rate) {
+			pr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,
+				drate, clk_hw_get_name(hw));
+			return -EINVAL;
+		}
+	}
+
+	if (!clk_th1520_pll_change(pll, rate))
+		return 0;
+
+	/* Enable RST */
+	cfg1_off = pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1;
+	tmp = readl_relaxed(cfg1_off);
+	tmp |= pll->pll_rst_bit;
+	writel_relaxed(tmp, cfg1_off);
+
+	div_val = (rate->refdiv << TH1520_REFDIV_SHIFT) |
+		  (rate->fbdiv << TH1520_FBDIV_SHIFT) |
+		  (rate->postdiv1 << TH1520_POSTDIV1_SHIFT) |
+		  (rate->postdiv2 << TH1520_POSTDIV2_SHIFT);
+	writel_relaxed(div_val, pll->base + pll->cfg0_reg_off);
+
+	if (pll->pll_mode == PLL_MODE_FRAC) {
+		tmp &= ~(TH1520_FRAC_MASK << TH1520_FRAC_SHIFT);
+		tmp |= rate->frac;
+		writel_relaxed(tmp, cfg1_off);
+	}
+
+	udelay(3);
+
+	/* Disable RST */
+	tmp &= ~pll->pll_rst_bit;
+	writel_relaxed(tmp, cfg1_off);
+
+	/* Wait Lock, ~20us cost */
+	ret = clk_th1520_pll_wait_lock(pll);
+	if (ret)
+		return ret;
+
+	/* HW requires 30us for pll stable */
+	udelay(30);
+
+	return 0;
+}
+
+static long clk_th1520_pllvco_round_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long *prate)
+{
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
+	unsigned long best = 0, now = 0;
+	unsigned int i, best_i = 0;
+
+	for (i = 0; i < pll->rate_count; i++) {
+		now = rate_table[i].vco_rate;
+
+		if (rate == now) {
+			return rate_table[i].vco_rate;
+		} else if (abs(now - rate) < abs(best - rate)) {
+			best = now;
+			best_i = i;
+		}
+	}
+
+	/* return minimum supported value */
+	return rate_table[best_i].vco_rate;
+}
+
+static long clk_th1520_plldiv_round_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long *prate)
+{
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
+	unsigned long best = 0, now = 0;
+	unsigned int i, best_i = 0;
+
+	for (i = 0; i < pll->rate_count; i++) {
+		now = rate_table[i].rate;
+
+		if (rate == now) {
+			return rate_table[i].rate;
+		} else if (abs(now - rate) < abs(best - rate)) {
+			best = now;
+			best_i = i;
+		}
+	}
+
+	/* return minimum supported value */
+	return rate_table[best_i].rate;
+}
+
+static const struct clk_ops clk_th1520_pll_def_ops = {
+	.recalc_rate	= clk_th1520_pll_recalc_rate,
+};
+
+static const struct clk_ops clk_th1520_pllvco_ops = {
+	.prepare	= clk_th1520_pll_prepare,
+	.unprepare	= clk_th1520_pll_unprepare,
+	.is_prepared	= clk_th1520_pll_is_prepared,
+	.recalc_rate	= clk_th1520_pll_recalc_rate,
+	.round_rate	= clk_th1520_pllvco_round_rate,
+	.set_rate	= clk_th1520_pll_set_rate,
+};
+
+static const struct clk_ops clk_th1520_plldiv_ops = {
+	.prepare	= clk_th1520_pll_prepare,
+	.unprepare	= clk_th1520_pll_unprepare,
+	.is_prepared	= clk_th1520_pll_is_prepared,
+	.recalc_rate	= clk_th1520_pll_recalc_rate,
+	.round_rate	= clk_th1520_plldiv_round_rate,
+	.set_rate	= clk_th1520_pll_set_rate,
+};
+
+struct clk *thead_th1520_pll(const char *name, const char *parent_name,
+			    void __iomem *base,
+			    const struct th1520_pll_clk *pll_clk)
+{
+	struct clk_th1520pll *pll;
+	struct clk *clk;
+	struct clk_init_data init;
+	u32 val;
+
+	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.flags = pll_clk->flags;
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	switch (pll_clk->out_type) {
+	case TH1520_PLL_VCO:
+		if (pll_clk->rate_table)
+			init.ops = &clk_th1520_pllvco_ops;
+		break;
+	case TH1520_PLL_DIV:
+		if (pll_clk->rate_table)
+			init.ops = &clk_th1520_plldiv_ops;
+		break;
+	default:
+		pr_err("%s: Unknown pll out type for pll clk %s\n",
+		       __func__, name);
+	};
+
+	if (!pll_clk->rate_table)
+		init.ops = &clk_th1520_pll_def_ops;
+
+	pll->base = base;
+	pll->hw.init = &init;
+	pll->out_type = pll_clk->out_type;
+	pll->clk_type = pll_clk->clk_type;
+	pll->rate_table = pll_clk->rate_table;
+	pll->rate_count = pll_clk->rate_count;
+
+	clk_th1520_pll_cfg_init(pll);
+
+	val = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+	val &= ~pll->pll_bypass_bit;
+	val |= TH1520_DACPD_MASK;
+	val |= TH1520_DSMPD_MASK;
+	if (pll->pll_mode == PLL_MODE_FRAC) {
+		val &= ~TH1520_DSMPD_MASK;
+		val &= ~TH1520_DACPD_MASK;
+	}
+	writel_relaxed(val, pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+
+	clk = clk_register(NULL, &pll->hw);
+	if (IS_ERR(clk)) {
+		pr_err("%s: failed to register pll %s %lu\n",
+			__func__, name, PTR_ERR(clk));
+		kfree(pll);
+	}
+
+	return clk;
+}
+
+static inline struct clk_th1520div *to_clk_th1520div(struct clk_hw *hw)
+{
+	struct clk_divider *divider = to_clk_divider(hw);
+
+	return container_of(divider, struct clk_th1520div, divider);
+}
+
+static unsigned long clk_th1520div_recalc_rate(struct clk_hw *hw,
+					 unsigned long parent_rate)
+{
+	struct clk_th1520div *th1520_div = to_clk_th1520div(hw);
+
+	return th1520_div->ops->recalc_rate(&th1520_div->divider.hw, parent_rate);
+}
+
+static long clk_th1520div_round_rate(struct clk_hw *hw, unsigned long rate,
+			       unsigned long *prate)
+{
+	struct clk_th1520div *th1520_div = to_clk_th1520div(hw);
+
+	return th1520_div->ops->round_rate(&th1520_div->divider.hw, rate, prate);
+}
+
+static int clk_th1520div_set_rate(struct clk_hw *hw, unsigned long rate,
+				 unsigned long parent_rate)
+{
+	struct clk_th1520div *th1520_div = to_clk_th1520div(hw);
+	struct clk_divider *div = to_clk_divider(hw);
+	unsigned int divider, value;
+	unsigned long flags = 0;
+	u32 val;
+
+	/** 
+	 * The clk-divider will calculate the node frequency by rounding up 
+	 * based on the parent frequency and the target divider.
+	 * This calculation is to restore accurate frequency divider. 
+	*/
+	divider = DIV64_U64_ROUND_CLOSEST(parent_rate, rate);
+
+	/* DIV is zero based divider, but CDE is not */
+	if (th1520_div->div_type == MUX_TYPE_DIV)
+		value = divider;
+	else
+		value = divider - 1;
+
+	/* handle the div valid range */
+	if (value > th1520_div->max_div)
+		value = th1520_div->max_div;
+	if (value < th1520_div->min_div)
+		value = th1520_div->min_div;
+
+	spin_lock_irqsave(div->lock, flags);
+
+	val = readl(div->reg);
+	val &= ~BIT(th1520_div->sync_en);
+	writel(val, div->reg);
+
+	udelay(1);
+
+	val &= ~(div_mask(div) << div->shift);
+	val |= value << div->shift;
+	writel(val, div->reg);
+
+	udelay(1);
+
+	val |= BIT(th1520_div->sync_en);
+	writel(val, div->reg);
+
+	spin_unlock_irqrestore(div->lock, flags);
+
+	return 0;
+}
+
+static const struct clk_ops clk_th1520div_ops = {
+	.recalc_rate = clk_th1520div_recalc_rate,
+	.round_rate = clk_th1520div_round_rate,
+	.set_rate = clk_th1520div_set_rate,
+};
+
+static struct clk *thead_clk_th1520_divider_internal(const char *name, const char *parent,
+				       void __iomem *reg, u8 shift, u8 width,
+				       u8 sync, enum th1520_div_type div_type,
+				       u16 min, u16 max, bool closest)
+{
+	struct clk_th1520div *th1520_div;
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int ret;
+
+	th1520_div = kzalloc(sizeof(*th1520_div), GFP_KERNEL);
+	if (!th1520_div)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.ops = &clk_th1520div_ops;
+	init.flags = CLK_SET_RATE_PARENT;
+	init.parent_names = parent ? &parent : NULL;
+	init.num_parents = parent ? 1 : 0;
+
+	th1520_div->divider.reg = reg;
+	th1520_div->divider.shift = shift;
+	th1520_div->divider.width = width;
+	th1520_div->divider.lock = &thead_th1520_clk_lock;
+	th1520_div->divider.hw.init = &init;
+	th1520_div->ops = &clk_divider_ops;
+	th1520_div->sync_en = sync;
+	th1520_div->div_type = div_type;
+	if (th1520_div->div_type == MUX_TYPE_DIV)
+		th1520_div->divider.flags = CLK_DIVIDER_ONE_BASED;
+
+	if (closest)
+		th1520_div->divider.flags |= CLK_DIVIDER_ROUND_CLOSEST;
+
+	th1520_div->min_div = min > ((1 << width) - 1) ?
+			     ((1 << width) - 1) : min;
+	th1520_div->max_div = max > ((1 << width) - 1) ?
+			     ((1 << width) - 1) : max;
+
+	hw = &th1520_div->divider.hw;
+
+	ret = clk_hw_register(NULL, hw);
+	if (ret) {
+		kfree(th1520_div);
+		return ERR_PTR(ret);
+	}
+
+	return hw->clk;
+}
+
+struct clk *thead_clk_th1520_divider(const char *name, const char *parent,
+				       void __iomem *reg, u8 shift, u8 width,
+				       u8 sync, enum th1520_div_type div_type,
+				       u16 min, u16 max)
+{
+	return thead_clk_th1520_divider_internal(name, parent, reg, shift, width,
+											sync, div_type, min, max, false);
+}
+
+struct clk *thead_clk_th1520_divider_closest(const char *name, const char *parent,
+				       void __iomem *reg, u8 shift, u8 width,
+				       u8 sync, enum th1520_div_type div_type,
+				       u16 min, u16 max)
+{
+	return thead_clk_th1520_divider_internal(name, parent, reg, shift, width,
+											sync, div_type, min, max, true);
+}
+
+static inline struct clk_th1520gate *to_clk_th1520gate(struct clk_hw *hw)
+{
+	struct clk_gate *gate = to_clk_gate(hw);
+
+	return container_of(gate, struct clk_th1520gate, gate);
+}
+
+static int clk_th1520_gate_share_is_enabled(struct clk_hw *hw)
+{
+	struct clk_th1520gate *th1520_gate = to_clk_th1520gate(hw);
+
+	return th1520_gate->ops->is_enabled(hw);
+}
+
+static int clk_th1520_gate_share_enable(struct clk_hw *hw)
+{
+	struct clk_th1520gate *th1520_gate = to_clk_th1520gate(hw);
+
+	if (th1520_gate->share_count && (*th1520_gate->share_count)++ > 0) {
+		pr_debug("[%s,%d]share_count = %d\n", __func__, __LINE__, (*th1520_gate->share_count));
+		return 0;
+	}
+
+	pr_debug("[%s,%d]share_count = %d\n", __func__, __LINE__, (*th1520_gate->share_count));
+
+	return th1520_gate->ops->enable(hw);
+}
+
+static void clk_th1520_gate_share_disable(struct clk_hw *hw)
+{
+	struct clk_th1520gate *th1520_gate = to_clk_th1520gate(hw);
+
+	if (th1520_gate->share_count) {
+		if (WARN_ON(*th1520_gate->share_count == 0))
+			return;
+		else if (--(*th1520_gate->share_count) > 0) {
+			pr_debug("[%s,%d]share_count = %d\n", __func__, __LINE__, (*th1520_gate->share_count));
+			return;
+		}
+	}
+
+	pr_debug("[%s,%d]share_count = %d\n", __func__, __LINE__, (*th1520_gate->share_count));
+
+	th1520_gate->ops->disable(hw);
+}
+
+static void clk_th1520_gate_share_disable_unused(struct clk_hw *hw)
+{
+	struct clk_th1520gate *th1520_gate = to_clk_th1520gate(hw);
+
+	if (!th1520_gate->share_count || *th1520_gate->share_count == 0)
+		return th1520_gate->ops->disable(hw);
+}
+
+static const struct clk_ops clk_th1520gate_share_ops = {
+	.enable = clk_th1520_gate_share_enable,
+	.disable = clk_th1520_gate_share_disable,
+	.disable_unused = clk_th1520_gate_share_disable_unused,
+	.is_enabled = clk_th1520_gate_share_is_enabled,
+};
+
+struct clk *thead_clk_th1520_register_gate_shared(const char *name, const char *parent,
+						 unsigned long flags, void __iomem *reg,
+						 u8 shift, spinlock_t *lock,
+						 unsigned int *share_count)
+{
+	struct clk_th1520gate *th1520_gate;
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int ret;
+
+	th1520_gate = kzalloc(sizeof(*th1520_gate), GFP_KERNEL);
+	if (!th1520_gate)
+		return ERR_PTR(-ENOMEM);
+
+	th1520_gate->gate.reg = reg;
+	th1520_gate->gate.bit_idx = shift;
+	th1520_gate->gate.flags = 0;
+	th1520_gate->gate.lock = lock;
+	th1520_gate->gate.hw.init = &init;
+	th1520_gate->ops = &clk_gate_ops;
+	th1520_gate->share_count = share_count;
+
+	init.name = name;
+	init.ops = &clk_th1520gate_share_ops;
+	init.flags = flags;
+	init.parent_names = parent ? &parent : NULL;
+	init.num_parents = parent ? 1 : 0;
+
+	hw = &th1520_gate->gate.hw;
+
+	ret = clk_hw_register(NULL, hw);
+	if (ret) {
+		kfree(th1520_gate);
+		return ERR_PTR(ret);
+	}
+
+	return hw->clk;
+}
diff --git a/drivers/clk/thead/clk.h b/drivers/clk/thead/clk.h
new file mode 100644
index 000000000000..f4cf639aed49
--- /dev/null
+++ b/drivers/clk/thead/clk.h
@@ -0,0 +1,126 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+
+#ifndef __MACH_THEAD_CLK_H
+#define __MACH_THEAD_CLK_H
+
+#include <linux/spinlock.h>
+#include <linux/clk-provider.h>
+
+extern spinlock_t thead_th1520_clk_lock;
+
+#define TH1520_PLL_RATE(_vco, _rate, _r, _b, _f, _p, _k)	\
+	{						\
+		.vco_rate	=	(_vco),		\
+		.rate		=	(_rate),	\
+		.refdiv		=	(_r),		\
+		.fbdiv		=	(_b),		\
+		.frac		=	(_f),		\
+		.postdiv1	=	(_p),		\
+		.postdiv2	=	(_k),		\
+	}
+
+enum th1520_pll_outtype {
+	TH1520_PLL_VCO,
+	TH1520_PLL_DIV,
+};
+
+enum th1520_div_type {
+        MUX_TYPE_DIV,
+        MUX_TYPE_CDE,
+};
+
+enum th1520_pll_clktype {
+	TH1520_AUDIO_PLL,
+	TH1520_SYS_PLL,
+	TH1520_CPU_PLL0,
+	TH1520_CPU_PLL1,
+	TH1520_GMAC_PLL,
+	TH1520_VIDEO_PLL,
+	TH1520_DDR_PLL,
+	TH1520_DPU0_PLL,
+	TH1520_DPU1_PLL,
+};
+
+struct th1520_pll_rate_table {
+	unsigned long vco_rate;
+	unsigned long rate;
+	unsigned int refdiv;
+	unsigned int fbdiv;
+	unsigned int frac;
+	unsigned int postdiv1;
+	unsigned int postdiv2;
+};
+
+struct th1520_pll_clk {
+	enum th1520_pll_outtype out_type;
+	enum th1520_pll_clktype clk_type;
+	const struct th1520_pll_rate_table *rate_table;
+	int rate_count;
+	int flags;
+};
+
+static inline struct clk *thead_th1520_clk_fixed_factor(const char *name,
+		const char *parent, unsigned int mult, unsigned int div)
+{
+	return clk_register_fixed_factor(NULL, name, parent,
+			CLK_SET_RATE_PARENT, mult, div);
+}
+
+struct clk *thead_th1520_pll(const char *name, const char *parent_name,
+			    void __iomem *base,
+			    const struct th1520_pll_clk *pll_clk);
+
+static inline struct clk *thead_clk_th1520_gate(const char *name, const char *parent,
+					       void __iomem *reg, u8 shift)
+{
+	return clk_register_gate(NULL, name, parent, CLK_SET_RATE_PARENT, reg,
+			shift, 0, &thead_th1520_clk_lock);
+}
+
+struct clk *thead_clk_th1520_register_gate_shared(const char *name, const char *parent,
+						 unsigned long flags, void __iomem *reg,
+						 u8 shift, spinlock_t *lock,
+						 unsigned int *share_count);
+
+struct clk *thead_clk_th1520_divider(const char *name, const char *parent,
+				    void __iomem *reg, u8 shift, u8 width,
+				    u8 sync, enum th1520_div_type div_type,
+				    u16 min, u16 max);
+
+/**
+* By default, the clk framework calculates frequency by rounding downwards.
+* This function is to achieve closest frequency.
+*/
+struct clk *thead_clk_th1520_divider_closest(const char *name, const char *parent,
+				    void __iomem *reg, u8 shift, u8 width,
+				    u8 sync, enum th1520_div_type div_type,
+				    u16 min, u16 max);
+
+void thead_unregister_clocks(struct clk *clks[], unsigned int count);
+
+static inline struct clk *thead_clk_fixed(const char *name, unsigned long rate)
+{
+	return clk_register_fixed_rate(NULL, name, NULL, 0, rate);
+}
+
+static inline struct clk *thead_clk_th1520_gate_shared(const char *name, const char *parent,
+					void __iomem *reg, u8 shift,
+					unsigned int *share_count)
+{
+	return thead_clk_th1520_register_gate_shared(name, parent, CLK_SET_RATE_PARENT, reg,
+						    shift, &thead_th1520_clk_lock, share_count);
+}
+
+static inline struct clk *thead_th1520_clk_mux_flags(const char *name,
+			void __iomem *reg, u8 shift, u8 width,
+			const char * const *parents, int num_parents,
+			unsigned long flags)
+{
+	return clk_register_mux(NULL, name, parents, num_parents,
+			flags , reg, shift, width, 0,
+			&thead_th1520_clk_lock);
+}
+#endif
diff --git a/drivers/clk/thead/gate/Makefile b/drivers/clk/thead/gate/Makefile
new file mode 100644
index 000000000000..7e4b7ef11d44
--- /dev/null
+++ b/drivers/clk/thead/gate/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+
+obj-$(CONFIG_CLK_TH1520_FM) += thead-gate.o visys-gate.o vpsys-gate.o vosys-gate.o dspsys-gate.o audiosys-gate.o miscsys-gate.o
diff --git a/drivers/clk/thead/gate/audiosys-gate.c b/drivers/clk/thead/gate/audiosys-gate.c
new file mode 100644
index 000000000000..583320fe0600
--- /dev/null
+++ b/drivers/clk/thead/gate/audiosys-gate.c
@@ -0,0 +1,124 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/clock/th1520-fm-ap-clock.h>
+#include <dt-bindings/clock/th1520-audiosys.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "clk-gate.h"
+#include "../clk.h"
+
+static struct clk *gates[TH1520_CLKGEN_AUDIO_CLK_END];
+static struct clk_onecell_data clk_gate_data;
+
+static int th1520_audiosys_clk_probe(struct platform_device *pdev)
+{
+	struct regmap *audiosys_regmap;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	audiosys_regmap = syscon_regmap_lookup_by_phandle(np, "audiosys-regmap");
+	if (IS_ERR(audiosys_regmap)) {
+		dev_err(&pdev->dev, "cannot find regmap for vi system register\n");
+		return PTR_ERR(audiosys_regmap);
+	}
+
+	printk("%s audiosys_regmap=0x%px\n", __func__, audiosys_regmap);
+
+	/* we assume that the gate clock is a root clock  */
+	gates[TH1520_CLKGEN_AUDIO_CPU] = thead_gate_clk_register("clkgen_audiosys_cpu_clk", NULL,
+									audiosys_regmap, 0x10, 0, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_SRAM0] = thead_gate_clk_register("clkgen_audiosys_sram0_clk", NULL,
+									audiosys_regmap, 0x10, 1, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_SRAM1] = thead_gate_clk_register("clkgen_audiosys_sram1_clk", NULL,
+									audiosys_regmap, 0x10, 2, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_DMA] = thead_gate_clk_register("clkgen_audiosys_dma_clk", NULL,
+									audiosys_regmap, 0x10, 3, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_BSM] = thead_gate_clk_register("clkgen_audiosys_bsm_clk", NULL,
+									audiosys_regmap, 0x10, 4, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_TIMER] = thead_gate_clk_register("clkgen_audiosys_timer_clk", NULL,
+									audiosys_regmap, 0x10, 8, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_TIMER_CNT1] = thead_gate_clk_register("clkgen_audiosys_timer_cnt1_clk", NULL,
+									audiosys_regmap, 0x10, 9, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_TIMER_CNT2] = thead_gate_clk_register("clkgen_audiosys_timer_cnt2_clk", NULL,
+									audiosys_regmap, 0x10, 10, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_TIMER_CNT3] = thead_gate_clk_register("clkgen_audiosys_timer_cnt3_clk", NULL,
+									audiosys_regmap, 0x10, 11, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_TIMER_CNT4] = thead_gate_clk_register("clkgen_audiosys_timer_cnt4_clk", NULL,
+									audiosys_regmap, 0x10, 12, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_WDR] = thead_gate_clk_register("clkgen_audiosys_wdr_clk", NULL,
+									audiosys_regmap, 0x10, 13, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_I2C0] = thead_gate_clk_register("clkgen_audiosys_i2c0_clk", NULL,
+									audiosys_regmap, 0x10, 14, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_I2C1] = thead_gate_clk_register("clkgen_audiosys_i2c1_clk", NULL,
+									audiosys_regmap, 0x10, 15, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_UART] = thead_gate_clk_register("clkgen_audiosys_uart_clk", NULL,
+									audiosys_regmap, 0x10, 16, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_I2S0] = thead_gate_clk_register("clkgen_audiosys_i2s0_clk", NULL,
+									audiosys_regmap, 0x10, 17, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_I2S1] = thead_gate_clk_register("clkgen_audiosys_i2s1_clk", NULL,
+									audiosys_regmap, 0x10, 18, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_I2S2] = thead_gate_clk_register("clkgen_audiosys_i2s2_clk", NULL,
+									audiosys_regmap, 0x10, 19, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_I2S8CH] = thead_gate_clk_register("clkgen_audiosys_i2s8ch_clk", NULL,
+									audiosys_regmap, 0x10, 20, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_TDM] = thead_gate_clk_register("clkgen_audiosys_tdm_clk", NULL,
+									audiosys_regmap, 0x10, 21, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_GPIO] = thead_gate_clk_register("clkgen_audiosys_gpio_clk", NULL,
+									audiosys_regmap, 0x10, 22, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_SPDIF0] = thead_gate_clk_register("clkgen_audiosys_spdif0_clk", NULL,
+									audiosys_regmap, 0x10, 23, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_SPDIF1] = thead_gate_clk_register("clkgen_audiosys_spdif1_clk", NULL,
+									audiosys_regmap, 0x10, 24, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_VAD] = thead_gate_clk_register("clkgen_audiosys_vad_clk", NULL,
+									audiosys_regmap, 0x10, 25, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_IOMUX] = thead_gate_clk_register("clkgen_audiosys_iomux_clk", NULL,
+									audiosys_regmap, 0x10, 26, GATE_NOT_SHARED, NULL, dev);
+
+	clk_gate_data.clks = gates;
+	clk_gate_data.clk_num = ARRAY_SIZE(gates);
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register gate clks for th1520 audiosys\n");
+		goto unregister_clks;
+	}
+
+	dev_info(dev, "succeed to register audiosys gate clock provider\n");
+
+	return 0;
+
+unregister_clks:
+	thead_unregister_clocks(gates, ARRAY_SIZE(gates));
+	return ret;
+}
+
+static const struct of_device_id audiosys_clk_gate_of_match[] = {
+	{ .compatible = "thead,audiosys-gate-controller" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, audiosys_clk_gate_of_match);
+
+static struct platform_driver th1520_audiosys_clk_driver = {
+	.probe = th1520_audiosys_clk_probe,
+	.driver = {
+		.name = "audiosys-clk-gate-provider",
+		.of_match_table = of_match_ptr(audiosys_clk_gate_of_match),
+	},
+};
+
+module_platform_driver(th1520_audiosys_clk_driver);
+MODULE_AUTHOR("nanli.yd <nanli.yd@linux.alibaba.com>");
+MODULE_DESCRIPTION("Thead Th1520 Fullmask audiosys clock gate provider");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/thead/gate/clk-gate.h b/drivers/clk/thead/gate/clk-gate.h
new file mode 100644
index 000000000000..ebb190374a0e
--- /dev/null
+++ b/drivers/clk/thead/gate/clk-gate.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#ifndef CLK_GATE_H
+#define CLK_GATE_H
+
+#include <linux/clk-provider.h>
+#include <linux/mfd/syscon.h>
+
+enum clk_gate_type {
+	GATE_NOT_SHARED,
+	GATE_SHARED,
+};
+
+struct thead_clk_gate {
+	struct clk_hw hw;
+	struct regmap *regmap;
+	u32 offset;
+	u8 bit;
+	bool shared;
+	u32 *share_count;
+};
+
+struct clk *thead_gate_clk_register(const char *name,
+				    const char *parent_name,
+				    struct regmap *regmap,
+				    int offset,
+				    u8 bit,
+				    bool shared,
+				    u32 *share_count,
+				    struct device *dev);
+
+#endif
diff --git a/drivers/clk/thead/gate/dspsys-gate.c b/drivers/clk/thead/gate/dspsys-gate.c
new file mode 100644
index 000000000000..c70e11255afa
--- /dev/null
+++ b/drivers/clk/thead/gate/dspsys-gate.c
@@ -0,0 +1,123 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/clock/th1520-dspsys.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "clk-gate.h"
+#include "../clk.h"
+
+static struct clk *gates[TH1520_CLKGEN_DSPSYS_CLK_END];
+static struct clk_onecell_data clk_gate_data;
+static const char * const dsp0_cclk_sels[] = {"gmac_pll_foutpostdiv", "dspsys_dsp_clk"};
+static const char * const dsp1_cclk_sels[] = {"gmac_pll_foutpostdiv", "dspsys_dsp_clk"};
+
+static int thead_dspsys_clk_probe(struct platform_device *pdev)
+{
+	struct regmap *dspsys_regmap, *tee_dspsys_regmap;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct device_node *np_reg = of_parse_phandle(np, "dspsys-regmap", 0);
+	void __iomem *gate_base;
+	int ret;
+
+	dspsys_regmap = syscon_regmap_lookup_by_phandle(np, "dspsys-regmap");
+	if (IS_ERR(dspsys_regmap)) {
+		dev_err(&pdev->dev, "cannot find regmap for dsp system register\n");
+		return PTR_ERR(dspsys_regmap);
+	}
+
+	tee_dspsys_regmap = syscon_regmap_lookup_by_phandle(np, "tee-dspsys-regmap");
+	if (IS_ERR(tee_dspsys_regmap)) {
+		dev_warn(&pdev->dev, "cannot find regmap for tee dsp system register\n");
+		tee_dspsys_regmap = NULL;
+	}
+	gate_base = of_iomap(np_reg,0);
+	// MUX 
+	gates[DSPSYS_DSP0_CLK_SWITCH] = thead_th1520_clk_mux_flags("dspsys_dsp0_clk_switch", gate_base + 0x1c, 0, 1, dsp0_cclk_sels, ARRAY_SIZE(dsp0_cclk_sels), 0);
+	gates[DSPSYS_DSP1_CLK_SWITCH] = thead_th1520_clk_mux_flags("dspsys_dsp1_clk_switch", gate_base + 0x20, 0, 1, dsp1_cclk_sels, ARRAY_SIZE(dsp1_cclk_sels), 0);
+
+	// DIV & CDE
+	gates[DSPSYS_DSP_CLK] = thead_th1520_clk_fixed_factor("dspsys_dsp_clk", "video_pll_foutvco", 1, 3);
+	gates[DSPSYS_DSP0_CLK_CDE] = thead_clk_th1520_divider("dspsys_dsp0_clk_cde", "dspsys_dsp0_clk_switch", gate_base + 0x0, 0, 3, 4, MUX_TYPE_CDE, 0, 7);
+	gates[DSPSYS_DSP1_CLK_CDE] = thead_clk_th1520_divider("dspsys_dsp1_clk_cde", "dspsys_dsp1_clk_switch", gate_base + 0x4, 0, 3, 4, MUX_TYPE_CDE, 0, 7);
+
+	// gate
+	gates[CLKGEN_DSP0_PCLK] = thead_gate_clk_register("clkgen_dsp0_pclk", NULL, dspsys_regmap,
+							  0x24, 0, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_DSP1_PCLK] = thead_gate_clk_register("clkgen_dsp1_pclk", NULL, dspsys_regmap,
+							  0x24, 1, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_DSP1_CCLK] = thead_gate_clk_register("clkgen_dsp1_cclk", "dspsys_dsp1_clk_cde", dspsys_regmap,
+							  0x24, 2, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_DSP0_CCLK] = thead_gate_clk_register("clkgen_dsp0_cclk", "dspsys_dsp0_clk_cde", dspsys_regmap,
+							  0x24, 3, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_X2X_DSP2_ACLK_S] = thead_gate_clk_register("clkgen_x2x_dsp2_aclk_s", NULL, dspsys_regmap,
+							  0x24, 4, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_X2X_DSP0_ACLK_S] = thead_gate_clk_register("clkgen_x2x_dsp0_aclk_s", NULL, dspsys_regmap,
+							  0x24, 5, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_X2X_X4_DSPSLV_DSP1_ACLK_M] = thead_gate_clk_register("clkgen_x2x_x4_dspslv_dsp1_aclk_m",
+							  NULL, dspsys_regmap, 0x24, 6, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_X2X_X4_DSPSLV_DSP0_ACLK_M] = thead_gate_clk_register("clkgen_x2x_x4_dspslv_dsp0_aclk_m",
+							  NULL, dspsys_regmap, 0x24, 7, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_AXI4_DSPSYS_SLV_ACLK] = thead_gate_clk_register("clkgen_axi4_dspsys_slv_aclk", NULL, dspsys_regmap,
+							  0x24, 20, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_AXI4_DSPSYS_SLV_PCLK] = thead_gate_clk_register("clkgen_axi4_dspsys_slv_pclk", NULL, dspsys_regmap,
+							  0x24, 21, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_AXI4_DSPSYS_ACLK] = thead_gate_clk_register("clkgen_axi4_dspsys_aclk", NULL, dspsys_regmap,
+							  0x24, 23, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_AXI4_DSPSYS_PCLK] = thead_gate_clk_register("clkgen_axi4_dspsys_pclk", NULL, dspsys_regmap,
+							  0x24, 24, GATE_NOT_SHARED, NULL, dev);
+	if (tee_dspsys_regmap) {
+		gates[CLKGEN_IOPMP_DSP1_PCLK] = thead_gate_clk_register("clkgen_iopmp_dsp1_pclk", NULL, tee_dspsys_regmap,
+							  0x24, 25, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_IOPMP_DSP0_PCLK] = thead_gate_clk_register("clkgen_iopmp_dsp0_pclk", NULL, tee_dspsys_regmap,
+							  0x24, 26, GATE_NOT_SHARED, NULL, dev);
+	}
+
+	clk_gate_data.clks = gates;
+	clk_gate_data.clk_num = ARRAY_SIZE(gates);
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register gate clks for th1520 dspsys\n");
+		goto unregister_clks;
+	}
+
+	dev_info(dev, "succeed to register dspsys gate clock provider\n");
+
+	return 0;
+
+unregister_clks:
+	thead_unregister_clocks(gates, ARRAY_SIZE(gates));
+	return ret;
+}
+
+static const struct of_device_id dspsys_clk_gate_of_match[] = {
+	{ .compatible = "thead,dspsys-gate-controller" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, dspsys_clk_gate_of_match);
+
+static struct platform_driver thead_dspsys_clk_driver = {
+	.probe = thead_dspsys_clk_probe,
+	.driver = {
+		.name = "dspsys-clk-gate-provider",
+		.of_match_table = of_match_ptr(dspsys_clk_gate_of_match),
+	},
+};
+
+module_platform_driver(thead_dspsys_clk_driver);
+MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
+MODULE_DESCRIPTION("Thead Th1520 Fullmask dspsys clock gate provider");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/thead/gate/miscsys-gate.c b/drivers/clk/thead/gate/miscsys-gate.c
new file mode 100644
index 000000000000..808e822e4844
--- /dev/null
+++ b/drivers/clk/thead/gate/miscsys-gate.c
@@ -0,0 +1,108 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+#include <dt-bindings/clock/th1520-miscsys.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "clk-gate.h"
+#include "../clk.h"
+static struct clk *gates[CLKGEN_MISCSYS_CLK_END];
+static struct clk_onecell_data clk_gate_data;
+static int thead_miscsys_clk_probe(struct platform_device *pdev)
+{
+	struct regmap *miscsys_regmap, *tee_miscsys_regmap = NULL;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	miscsys_regmap = syscon_regmap_lookup_by_phandle(np, "miscsys-regmap");
+	if (IS_ERR(miscsys_regmap)) {
+		dev_err(&pdev->dev, "cannot find regmap for misc system register\n");
+		return PTR_ERR(miscsys_regmap);
+	}
+	tee_miscsys_regmap = syscon_regmap_lookup_by_phandle(np, "tee-miscsys-regmap");
+	if (IS_ERR(tee_miscsys_regmap)) {
+		dev_err(&pdev->dev, "cannot find regmap for tee misc system register\n");
+		return PTR_ERR(tee_miscsys_regmap);
+	}
+	/* we assume that the gate clock is a root clock  */
+	gates[CLKGEN_MISCSYS_MISCSYS_ACLK] = thead_gate_clk_register("clkgen_missys_aclk", NULL,
+								miscsys_regmap, 0x100, 0, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_USB3_DRD_CLK] = thead_gate_clk_register("clkgen_usb3_drd_clk", NULL,
+								miscsys_regmap, 0x104, 0, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_USB3_DRD_CTRL_REF_CLK] = thead_gate_clk_register("clkgen_usb3_drd_ctrl_ref_clk", "osc_24m",
+								miscsys_regmap, 0x104, 1, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_USB3_DRD_PHY_REF_CLK] = thead_gate_clk_register("clkgen_usb3_drd_phy_ref_clk", "osc_24m",
+								miscsys_regmap, 0x104, 2, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_USB3_DRD_SUSPEND_CLK] = thead_gate_clk_register("clkgen_usb3_drd_suspend_clk", NULL,
+								miscsys_regmap, 0x104, 3, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_EMMC_CLK] = thead_gate_clk_register("clkgen_emmc_clk", "osc_24m",
+								miscsys_regmap, 0x108, 0, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_SDIO0_CLK] = thead_gate_clk_register("clkgen_sdio0_clk", "osc_24m",
+								miscsys_regmap, 0x10c, 0, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_SDIO1_CLK] = thead_gate_clk_register("clkgen_sdio1_clk", "osc_24m",
+								miscsys_regmap, 0x110, 0, GATE_NOT_SHARED, NULL, dev);
+	if (tee_miscsys_regmap) {
+		gates[CLKGEN_MISCSYS_AHB2_TEESYS_HCLK] = thead_gate_clk_register("clkgen_ahb2_teesys_hclk", NULL,
+								tee_miscsys_regmap, 0x120, 0, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_APB3_TEESYS_HCLK] = thead_gate_clk_register("clkgen_apb3_teesys_hclk", NULL,
+								tee_miscsys_regmap, 0x120, 1, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_AXI4_TEESYS_ACLK] = thead_gate_clk_register("clkgen_axi4_teesys_aclk", NULL,
+								tee_miscsys_regmap, 0x120, 2, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_EIP120SI_CLK] = thead_gate_clk_register("clkgen_eip120si_clk", NULL,
+								tee_miscsys_regmap, 0x120, 3, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_EIP120SII_CLK] = thead_gate_clk_register("clkgen_eip120sii_clk", NULL,
+								tee_miscsys_regmap, 0x120, 4, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_EIP120SIII_CLK] = thead_gate_clk_register("clkgen_eip120siii_clk", NULL,
+								tee_miscsys_regmap, 0x120, 5, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_TEEDMAC_CLK] = thead_gate_clk_register("clkgen_teedmac_clk", NULL,
+								tee_miscsys_regmap, 0x120, 6, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_EIP150B_HCLK] = thead_gate_clk_register("clkgen_eip150b_hclk", NULL,
+								tee_miscsys_regmap, 0x120, 7, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_OCRAM_HCLK] = thead_gate_clk_register("clkgen_ocram_hclk", NULL,
+								tee_miscsys_regmap, 0x120, 8, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_EFUSE_PCLK] = thead_gate_clk_register("clkgen_efuse_pclk", NULL,
+								tee_miscsys_regmap, 0x120, 9, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_TEE_SYSREG_PCLK] = thead_gate_clk_register("clkgen_tee_sysreg_pclk", NULL,
+								tee_miscsys_regmap, 0x120, 10, GATE_NOT_SHARED, NULL, dev);
+	}
+	clk_gate_data.clks = gates;
+	clk_gate_data.clk_num = ARRAY_SIZE(gates);
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register gate clks for th1520 miscsys\n");
+		goto unregister_clks;
+	}
+	dev_info(dev, "succeed to register miscsys gate clock provider\n");
+	return 0;
+unregister_clks:
+	thead_unregister_clocks(gates, ARRAY_SIZE(gates));
+	return ret;
+}
+static const struct of_device_id miscsys_clk_gate_of_match[] = {
+	{ .compatible = "thead,miscsys-gate-controller" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, miscsys_clk_gate_of_match);
+static struct platform_driver thead_miscsys_clk_driver = {
+	.probe = thead_miscsys_clk_probe,
+	.driver = {
+		.name = "miscsys-clk-gate-provider",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(miscsys_clk_gate_of_match),
+	},
+};
+module_platform_driver(thead_miscsys_clk_driver);
+MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
+MODULE_AUTHOR("Esther.Z <Esther.Z@linux.alibaba.com>");
+MODULE_DESCRIPTION("Thead th1520 Fullmask miscsys clock gate provider");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/thead/gate/thead-gate.c b/drivers/clk/thead/gate/thead-gate.c
new file mode 100644
index 000000000000..372c11dee1b9
--- /dev/null
+++ b/drivers/clk/thead/gate/thead-gate.c
@@ -0,0 +1,114 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/regmap.h>
+#include "clk-gate.h"
+
+#define to_thead_clk_gate(_hw)	container_of(_hw, struct thead_clk_gate, hw)
+
+static int thead_clk_gate_is_enabled(struct clk_hw *hw)
+{
+	struct thead_clk_gate *tcg = to_thead_clk_gate(hw);
+	u32 val;
+
+	regmap_read(tcg->regmap, tcg->offset, &val);
+
+	val &= BIT(tcg->bit);
+
+	return val != 0;
+}
+
+static void thead_clk_gate_disable(struct clk_hw *hw)
+{
+	struct thead_clk_gate *tcg = to_thead_clk_gate(hw);
+
+	if (!tcg->shared)
+		goto out;
+
+	if (tcg->share_count) {
+		if (WARN_ON(*tcg->share_count == 0))
+			return;
+		else if (--(*tcg->share_count) > 0) {
+			pr_info("[%s,%d]share_count = %d\n", __func__, __LINE__,
+					(*tcg->share_count));
+			return;
+		}
+	}
+
+out:
+	regmap_update_bits(tcg->regmap, tcg->offset,
+			   BIT(tcg->bit), 0);
+}
+
+static int thead_clk_gate_enable(struct clk_hw *hw)
+{
+	struct thead_clk_gate *tcg = to_thead_clk_gate(hw);
+
+	if (!tcg->shared)
+		goto out;
+
+	if (tcg->share_count && (*tcg->share_count)++ > 0) {
+		pr_info("[%s,%d]share_count = %d\n", __func__, __LINE__, (*tcg->share_count));
+		return 0;
+	}
+
+out:
+	return regmap_update_bits(tcg->regmap, tcg->offset,
+				  BIT(tcg->bit), BIT(tcg->bit));
+}
+
+const struct clk_ops thead_gate_clk_ops = {
+	.enable = thead_clk_gate_enable,
+	.disable = thead_clk_gate_disable,
+	.is_enabled = thead_clk_gate_is_enabled,
+};
+
+struct clk *thead_gate_clk_register(const char *name,
+				    const char *parent_name,
+				    struct regmap *regmap,
+				    int offset,
+				    u8 bit,
+				    bool shared,
+				    u32 *share_count,
+				    struct device *dev)
+{
+	struct thead_clk_gate *tcg;
+	struct clk *clk;
+	struct clk_init_data init = {};
+
+	tcg = kzalloc(sizeof(*tcg), GFP_KERNEL);
+	if (!tcg)
+		return ERR_PTR(-ENOMEM);
+
+	tcg->regmap = regmap;
+	tcg->offset = offset;
+	tcg->bit = bit;
+	tcg->shared = shared;
+	tcg->share_count = share_count;
+
+	init.name = name;
+	init.flags = CLK_SET_RATE_PARENT;
+	init.parent_names = parent_name ? &parent_name : NULL;
+	init.num_parents = parent_name ? 1 : 0;
+	init.ops = &thead_gate_clk_ops;
+
+	tcg->hw.init = &init;
+
+	clk = clk_register(dev, &tcg->hw);
+	if (IS_ERR(clk))
+		kfree(tcg);
+
+	return clk;
+}
diff --git a/drivers/clk/thead/gate/visys-gate.c b/drivers/clk/thead/gate/visys-gate.c
new file mode 100644
index 000000000000..8522de108fac
--- /dev/null
+++ b/drivers/clk/thead/gate/visys-gate.c
@@ -0,0 +1,144 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/clock/th1520-fm-ap-clock.h>
+#include <dt-bindings/clock/th1520-visys.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "clk-gate.h"
+#include "../clk.h"
+
+static struct clk *gates[TH1520_CLKGEN_VISYS_CLK_END];
+static struct clk_onecell_data clk_gate_data;
+
+static u32 share_cnt_isp0_hclk_en;
+static u32 share_cnt_isp0_aclk_en;
+
+static int thead_visys_clk_probe(struct platform_device *pdev)
+{
+	struct regmap *visys_regmap;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	visys_regmap = syscon_regmap_lookup_by_phandle(np, "visys-regmap");
+	if (IS_ERR(visys_regmap)) {
+		dev_err(&pdev->dev, "cannot find regmap for vi system register\n");
+		return PTR_ERR(visys_regmap);
+	}
+
+	/* we assume that the gate clock is a root clock  */
+	gates[TH1520_CLKGEN_DW200_ACLK] = thead_gate_clk_register("clkgen_dw200_aclk", NULL,
+									visys_regmap, 0xa0, 27, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AXI4_VISYS1_ACLK] = thead_gate_clk_register("clkgen_axi4_visys1_aclk", NULL,
+									visys_regmap, 0xa0, 26, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AXI4_VISYS2_ACLK] = thead_gate_clk_register("clkgen_axi4_visys2_aclk", NULL,
+									visys_regmap, 0xa0, 25, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AXI4_VISYS3_ACLK] = thead_gate_clk_register("clkgen_axi4_visys3_aclk", NULL,
+									visys_regmap, 0xa0, 24, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP_RY_ACLK] = thead_gate_clk_register("clkgen_isp_ry_aclk", NULL,
+									visys_regmap, 0xa0, 22, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP_VENC_SHAKE_ACLK] = thead_gate_clk_register("clkgen_isp_venc_shake_aclk", NULL,
+									visys_regmap, 0xa0, 30, GATE_NOT_SHARED, NULL, dev);
+
+	gates[TH1520_CLKGEN_VIPRE_ACLK] = thead_gate_clk_register("clkgen_vipre_aclk", NULL,
+									visys_regmap, 0xa0, 31, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_DW200_HCLK] = thead_gate_clk_register("clkgen_dw200_hclk", NULL,
+									visys_regmap, 0xa0, 13, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP_RY_HCLK] = thead_gate_clk_register("clkgen_isp_ry_hclk", NULL,
+									visys_regmap, 0xa0, 12, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI0_PCLK] = thead_gate_clk_register("clkgen_mipi_csi0_pclk", NULL,
+									visys_regmap, 0xa0, 18, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI1_PCLK] = thead_gate_clk_register("clkgen_mipi_csi1_pclk", NULL,
+									visys_regmap, 0xa0, 17, GATE_NOT_SHARED, NULL, dev);
+
+	gates[TH1520_CLKGEN_MIPI_CSI2_PCLK] = thead_gate_clk_register("clkgen_mipi_csi2_pclk", NULL,
+									visys_regmap, 0xa0, 16, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_VIPRE_PCLK] = thead_gate_clk_register("clkgen_vipre_pclk", NULL,
+									visys_regmap, 0xa0, 15, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP_VENC_SHAKE_PCLK] = thead_gate_clk_register("clkgen_isp_venc_shake_pclk", NULL,
+									visys_regmap, 0xa0, 29, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI0_PIXCLK] = thead_gate_clk_register("clkgen_mipi_csi0_pixclk", NULL,
+									visys_regmap, 0xa0, 11, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI1_PIXCLK] = thead_gate_clk_register("clkgen_mipi_csi1_pixclk", NULL,
+									visys_regmap, 0xa0, 10, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI2_PIXCLK] = thead_gate_clk_register("clkgen_mipi_csi2_pixclk", NULL,
+									visys_regmap, 0xa0, 9, GATE_NOT_SHARED, NULL, dev);
+
+	gates[TH1520_CLKGEN_VIPRE_PIXELCLK] = thead_gate_clk_register("clkgen_vipre_pixelclk", NULL,
+									visys_regmap, 0xa4, 23, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI0_CFG_CLK] = thead_gate_clk_register("clkgen_mipi_csi0_cfg_clk", NULL,
+									visys_regmap, 0xa0, 8, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI1_CFG_CLK] = thead_gate_clk_register("clkgen_mipi_csi1_cfg_clk", NULL,
+									visys_regmap, 0xa0, 6, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI2_CFG_CLK] = thead_gate_clk_register("clkgen_mipi_csi2_cfg_clk", NULL,
+									visys_regmap, 0xa0, 7, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_DW200_CLK_VSE] = thead_gate_clk_register("clkgen_dw200_clk_vse", NULL,
+									visys_regmap, 0xa0, 5, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_DW200_CLK_DWE] = thead_gate_clk_register("clkgen_dw200_clk_dwe", NULL,
+									visys_regmap, 0xa0, 4, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP0_CLK] = thead_gate_clk_register("clkgen_isp_clk_0", NULL,
+									visys_regmap, 0xa4, 31, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP1_CLK] = thead_gate_clk_register("clkgen_isp_clk_1", NULL,
+									visys_regmap, 0xa4, 30, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP_RY_CCLK] = thead_gate_clk_register("clkgen_isp_ry_cclk", NULL,
+									visys_regmap, 0xa0, 21, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP1_PIXELCLK] = thead_gate_clk_register("clkgen_isp1_pixelclk", NULL,
+									visys_regmap, 0xa4, 28, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP0_PIXELCLK] = thead_gate_clk_register("clkgen_isp0_pixelclk", NULL,
+									visys_regmap, 0xa4, 29, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP1_HCLK] = thead_gate_clk_register("clkgen_isp1_hclk", NULL,
+									visys_regmap, 0xa0, 1, GATE_SHARED, &share_cnt_isp0_hclk_en, dev);
+	gates[TH1520_CLKGEN_ISP0_HCLK] = thead_gate_clk_register("clkgen_isp0_hclk", NULL,
+									visys_regmap, 0xa0, 1, GATE_SHARED, &share_cnt_isp0_hclk_en, dev);
+	gates[TH1520_CLKGEN_ISP1_ACLK] = thead_gate_clk_register("clkgen_isp1_aclk", NULL,
+									visys_regmap, 0xa0, 3, GATE_SHARED, &share_cnt_isp0_aclk_en, dev);
+	gates[TH1520_CLKGEN_ISP0_ACLK] = thead_gate_clk_register("clkgen_isp0_aclk", NULL,
+									visys_regmap, 0xa0, 3, GATE_SHARED, &share_cnt_isp0_aclk_en, dev);
+
+	clk_gate_data.clks = gates;
+	clk_gate_data.clk_num = ARRAY_SIZE(gates);
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register gate clks for th1520 visys\n");
+		goto unregister_clks;
+	}
+
+	dev_info(dev, "succeed to register visys gate clock provider\n");
+
+	return 0;
+
+unregister_clks:
+	thead_unregister_clocks(gates, ARRAY_SIZE(gates));
+	return ret;
+}
+
+static const struct of_device_id visys_clk_gate_of_match[] = {
+	{ .compatible = "thead,visys-gate-controller" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, visys_clk_gate_of_match);
+
+static struct platform_driver thead_visys_clk_driver = {
+	.probe = thead_visys_clk_probe,
+	.driver = {
+		.name = "visys-clk-gate-provider",
+		.of_match_table = of_match_ptr(visys_clk_gate_of_match),
+	},
+};
+
+module_platform_driver(thead_visys_clk_driver);
+MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
+MODULE_DESCRIPTION("Thead Th1520 Fullmask visys clock gate provider");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/thead/gate/vosys-gate.c b/drivers/clk/thead/gate/vosys-gate.c
new file mode 100644
index 000000000000..9a179272a66e
--- /dev/null
+++ b/drivers/clk/thead/gate/vosys-gate.c
@@ -0,0 +1,111 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/clock/th1520-fm-ap-clock.h>
+#include <dt-bindings/clock/th1520-vosys.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "../clk.h"
+
+static struct clk *gates[TH1520_CLKGEN_VOSYS_CLK_END];
+static struct clk_onecell_data clk_gate_data;
+
+static int thead_vosys_clk_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	void __iomem *gate_base;
+	int ret;
+
+	gate_base = devm_platform_ioremap_resource(pdev, 0);
+	if (WARN_ON(IS_ERR(gate_base)))
+		return PTR_ERR(gate_base);
+
+	/* we assume that the gate clock is a root clock  */
+	gates[TH1520_CLKGEN_AXI4_VO_PCLK] = thead_clk_th1520_gate("clkgen_axi4_vo_pclk", NULL,
+								gate_base + 0x50, 22);
+	gates[TH1520_CLKGEN_IOPMP_VOSYS_DPU_PCLK] = thead_clk_th1520_gate("clkgen_iopmp_dpu_pclk", NULL,
+								gate_base + 0x50, 23);
+	gates[TH1520_CLKGEN_IOPMP_VOSYS_DPU1_PCLK] = thead_clk_th1520_gate("clkgen_iopmp_dpu1_pclk", NULL,
+								gate_base + 0x50, 24);
+	gates[TH1520_CLKGEN_IOPMP_VOSYS_GPU_PCLK] = thead_clk_th1520_gate("clkgen_iopmp_gpu_pclk", NULL,
+								gate_base + 0x50, 25);
+	gates[TH1520_CLKGEN_HDMI_PCLK] = thead_clk_th1520_gate("clkgen_hdmi_pclk", NULL, gate_base + 0x50, 11);
+	gates[TH1520_CLKGEN_MIPIDSI0_PCLK] = thead_clk_th1520_gate("clkgen_mipidsi0_pclk", NULL,
+								  gate_base + 0x50, 13);
+	gates[TH1520_CLKGEN_MIPIDSI1_PCLK] = thead_clk_th1520_gate("clkgen_mipidsi1_pclk", NULL,
+								  gate_base + 0x50, 14);
+	gates[TH1520_CLKGEN_AXI4_VO_ACLK] = thead_clk_th1520_gate("clkgen_axi4_vo_aclk", NULL,
+								  gate_base + 0x50, 0);
+	gates[TH1520_CLKGEN_IOPMP_GPU_ACLK] = thead_clk_th1520_gate("clkgen_iopmp_gpu_aclk", NULL,
+								  gate_base + 0x50, 29);
+	gates[TH1520_CLKGEN_IOPMP_DPU_ACLK] = thead_clk_th1520_gate("clkgen_iopmp_dpu_aclk", NULL,
+								  gate_base + 0x50, 28);
+	gates[TH1520_CLKGEN_IOPMP_DPU1_ACLK] = thead_clk_th1520_gate("clkgen_iopmp_dpu1_aclk", NULL,
+								  gate_base + 0x50, 27);
+	gates[TH1520_CLKGEN_X2H_DPU_ACLK] = thead_clk_th1520_gate("clkgen_x2h_dpu_aclk", NULL, gate_base + 0x50, 21);
+	gates[TH1520_CLKGEN_X2H_DPU1_ACLK] = thead_clk_th1520_gate("clkgen_x2h_dpu1_aclk", NULL, gate_base + 0x50, 20);
+	gates[TH1520_CLKGEN_MIPIDSI0_PIXCLK] = thead_clk_th1520_gate("clkgen_mipidsi0_pixclk", NULL, gate_base + 0x50, 30);
+	gates[TH1520_CLKGEN_HDMI_PIXCLK] = thead_clk_th1520_gate("clkgen_hdmi_pixclk", NULL, gate_base + 0x54, 0);
+	gates[TH1520_CLKGEN_MIPIDSI1_PIXCLK] = thead_clk_th1520_gate("clkgen_mipidsi1_pixclk", NULL, gate_base + 0x50, 31);
+	gates[TH1520_CLKGEN_HDMI_SFR_CLK] = thead_clk_th1520_gate("clkgen_hdmi_sfr_clk", NULL, gate_base + 0x50, 10);
+	gates[TH1520_CLKGEN_HDMI_CEC_CLK] = thead_clk_th1520_gate("clkgen_hdmi_cec_cclk", NULL, gate_base + 0x50, 12);
+	gates[TH1520_CLKGEN_HDMI_I2S_CLK] = thead_clk_th1520_gate("clkgen_hdmi_i2s_clk", NULL, gate_base + 0x50, 19);
+	gates[TH1520_CLKGEN_MIPIDSI0_CFG_CLK] = thead_clk_th1520_gate("clkgen_mipidsi0_cfg_clk", NULL, gate_base + 0x50, 15);
+	gates[TH1520_CLKGEN_MIPIDSI1_CFG_CLK] = thead_clk_th1520_gate("clkgen_mipidsi1_cfg_clk", NULL, gate_base + 0x50, 16);
+	gates[TH1520_CLKGEN_MIPIDSI0_REFCLK] = thead_clk_th1520_gate("clkgen_mipidsi0_refclk", NULL, gate_base + 0x50, 17);
+	gates[TH1520_CLKGEN_MIPIDSI1_REFCLK] = thead_clk_th1520_gate("clkgen_mipidsi1_refclk", NULL, gate_base + 0x50, 18);
+	gates[TH1520_CLKGEN_GPU_CORE_CLK] = thead_clk_th1520_gate("clkgen_gpu_core_clk", "vosys_aclk_m", gate_base + 0x50, 3);
+	gates[TH1520_CLKGEN_GPU_CFG_ACLK] = thead_clk_th1520_gate("clkgen_gpu_cfg_aclk", NULL, gate_base + 0x50, 4);
+	gates[TH1520_CLKGEN_DPU_HCLK] = thead_clk_th1520_gate("clkgen_dpu_hclk", NULL, gate_base + 0x50, 7);
+	gates[TH1520_CLKGEN_DPU_ACLK] = thead_clk_th1520_gate("clkgen_dpu_aclk", NULL, gate_base + 0x50, 8);
+	gates[TH1520_CLKGEN_DPU_CCLK] = thead_clk_th1520_gate("clkgen_dpu_cclk", NULL, gate_base + 0x50, 9);
+	gates[TH1520_CLKGEN_DPU_PIXCLK0] = thead_clk_th1520_gate("clkgen_dpu_pixclk0", NULL, gate_base + 0x50, 5);
+	gates[TH1520_CLKGEN_DPU_PIXCLK1] = thead_clk_th1520_gate("clkgen_dpu_pixclk1", NULL, gate_base + 0x50, 6);
+
+	clk_gate_data.clks = gates;
+	clk_gate_data.clk_num = ARRAY_SIZE(gates);
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register gate clks for th1520 vosys\n");
+		goto unregister_clks;
+	}
+
+	dev_info(dev, "succeed to register vosys gate clock provider\n");
+
+	return 0;
+
+unregister_clks:
+	thead_unregister_clocks(gates, ARRAY_SIZE(gates));
+	return ret;
+}
+
+static const struct of_device_id vosys_clk_gate_of_match[] = {
+	{ .compatible = "thead,vosys-gate-controller" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, vosys_clk_gate_of_match);
+
+static struct platform_driver thead_vosys_clk_driver = {
+	.probe = thead_vosys_clk_probe,
+	.driver = {
+		.name = "vosys-clk-gate-provider",
+		.of_match_table = of_match_ptr(vosys_clk_gate_of_match),
+	},
+};
+
+module_platform_driver(thead_vosys_clk_driver);
+MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
+MODULE_DESCRIPTION("Thead Th1520 Fullmask vosys clock gate provider");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/thead/gate/vpsys-gate.c b/drivers/clk/thead/gate/vpsys-gate.c
new file mode 100644
index 000000000000..738b6cac0948
--- /dev/null
+++ b/drivers/clk/thead/gate/vpsys-gate.c
@@ -0,0 +1,99 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/clock/th1520-fm-ap-clock.h>
+#include <dt-bindings/clock/th1520-vpsys.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "../clk.h"
+
+static struct clk *gates[TH1520_VPSYS_CLK_END];
+static struct clk_onecell_data clk_gate_data;
+
+static u32 share_cnt_g2d_clk_en;
+static u32 share_cnt_fce_clk_en;
+
+static int thead_vpsys_clk_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	void __iomem *gate_base;
+	int ret;
+
+	gate_base = devm_platform_ioremap_resource(pdev, 0);
+	if (WARN_ON(IS_ERR(gate_base)))
+		return PTR_ERR(gate_base);
+
+	// DIV & CDE
+	gates[TH1520_VPSYS_G2D_CCLK_DIV] = thead_clk_th1520_divider("clkgen_vpsys_g2d_cclk_div", "video_pll_foutvco", gate_base + 0x30, 0, 4, 4, MUX_TYPE_DIV, 3, 15);
+	gates[TH1520_VPSYS_DEC_CCLK_DIV] = thead_clk_th1520_divider("clkgen_vpsys_dec_cclk_div", "video_pll_foutvco", gate_base + 0x24, 0, 4, 4, MUX_TYPE_DIV, 4, 15);
+
+	/* G2D clock configuration : Completed the upward configuration of CCLK */
+	gates[TH1520_VPSYS_G2D_PCLK] = thead_clk_th1520_gate_shared("clkgen_vpsys_g2d_pclk", NULL,
+								   gate_base + 0x20, 3, &share_cnt_g2d_clk_en);
+	gates[TH1520_VPSYS_G2D_ACLK] = thead_clk_th1520_gate_shared("clkgen_vpsys_g2d_aclk", NULL,
+								   gate_base + 0x20, 3, &share_cnt_g2d_clk_en);
+	gates[TH1520_VPSYS_G2D_CCLK] = thead_clk_th1520_gate_shared("clkgen_vpsys_g2d_cclk", "clkgen_vpsys_g2d_cclk_div",
+								   gate_base + 0x20, 3, &share_cnt_g2d_clk_en);
+
+	/* we assume that the gate clock is a root clock  */
+	gates[TH1520_VPSYS_FCE_PCLK] = thead_clk_th1520_gate_shared("clkgen_vpsys_fce_pclk", NULL,
+								   gate_base + 0x20, 2, &share_cnt_fce_clk_en);
+	gates[TH1520_VPSYS_FCE_ACLK] = thead_clk_th1520_gate_shared("clkgen_vpsys_fce_aclk", NULL,
+								   gate_base + 0x20, 2, &share_cnt_fce_clk_en);
+
+	/* VENC&VDEC clock configuration : Completed the upward configuration of CCLK */
+	gates[TH1520_VPSYS_VDEC_ACLK] = thead_clk_th1520_gate("clkgen_vdec_aclk", NULL, gate_base + 0x20, 4);
+	gates[TH1520_VPSYS_VDEC_CCLK] = thead_clk_th1520_gate("clkgen_vdec_cclk", "clkgen_vpsys_dec_cclk_div", gate_base + 0x20, 5);
+	gates[TH1520_VPSYS_VDEC_PCLK] = thead_clk_th1520_gate("clkgen_vdec_pclk", NULL, gate_base + 0x20, 6);
+
+	gates[TH1520_VPSYS_VENC_CCLK] = thead_clk_th1520_gate("clkgen_venc_cclk", "clkgen_vpsys_venc_cclk", gate_base + 0x20, 8);
+	gates[TH1520_VPSYS_VENC_PCLK] = thead_clk_th1520_gate("clkgen_venc_pclk", NULL, gate_base + 0x20, 9);
+	gates[TH1520_VPSYS_VENC_ACLK] = thead_clk_th1520_gate("clkgen_venc_aclk", NULL, gate_base + 0x20, 7);
+
+	clk_gate_data.clks = gates;
+	clk_gate_data.clk_num = ARRAY_SIZE(gates);
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register gate clks for th1520 vpsys\n");
+		goto unregister_clks;
+	}
+
+	dev_info(dev, "succeed to register vpsys gate clock provider\n");
+
+	return 0;
+
+unregister_clks:
+	thead_unregister_clocks(gates, ARRAY_SIZE(gates));
+	return ret;
+}
+
+static const struct of_device_id vpsys_clk_gate_of_match[] = {
+	{ .compatible = "thead,vpsys-gate-controller" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, vpsys_clk_gate_of_match);
+
+static struct platform_driver thead_vpsys_clk_driver = {
+	.probe = thead_vpsys_clk_probe,
+	.driver = {
+		.name = "vpsys-clk-gate-provider",
+		.of_match_table = of_match_ptr(vpsys_clk_gate_of_match),
+	},
+};
+
+module_platform_driver(thead_vpsys_clk_driver);
+MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
+MODULE_DESCRIPTION("Thead Th1520 Fullmask vpsys clock gate provider");
+MODULE_LICENSE("GPL v2");
diff --git a/include/dt-bindings/clock/th1520-audiosys.h b/include/dt-bindings/clock/th1520-audiosys.h
new file mode 100644
index 000000000000..2001545b68b8
--- /dev/null
+++ b/include/dt-bindings/clock/th1520-audiosys.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#ifndef _TH1520_AUDIOSYS_H_
+#define _TH1520_AUDIOSYS_H_
+
+#define TH1520_CLKGEN_AUDIO_CPU			      0
+#define TH1520_CLKGEN_AUDIO_SRAM0			      1
+#define TH1520_CLKGEN_AUDIO_SRAM1		      2
+#define TH1520_CLKGEN_AUDIO_DMA                 3
+#define TH1520_CLKGEN_AUDIO_BSM                 4
+#define TH1520_CLKGEN_AUDIO_TIMER                        5
+#define TH1520_CLKGEN_AUDIO_TIMER_CNT1                      6
+#define TH1520_CLKGEN_AUDIO_TIMER_CNT2              7
+#define TH1520_CLKGEN_AUDIO_TIMER_CNT3                       8
+#define TH1520_CLKGEN_AUDIO_TIMER_CNT4                 9
+#define TH1520_CLKGEN_AUDIO_WDR                      10
+#define TH1520_CLKGEN_AUDIO_I2C0                       11
+#define TH1520_CLKGEN_AUDIO_I2C1                      12
+#define TH1520_CLKGEN_AUDIO_UART                   13
+#define TH1520_CLKGEN_AUDIO_I2S0                  14
+#define TH1520_CLKGEN_AUDIO_I2S1                   15
+#define TH1520_CLKGEN_AUDIO_I2S2                  16
+#define TH1520_CLKGEN_AUDIO_I2S8CH                   17
+#define TH1520_CLKGEN_AUDIO_TDM                  18
+#define TH1520_CLKGEN_AUDIO_GPIO                       19
+#define TH1520_CLKGEN_AUDIO_SPDIF0                       20
+#define TH1520_CLKGEN_AUDIO_SPDIF1                21
+#define TH1520_CLKGEN_AUDIO_VAD              22
+#define TH1520_CLKGEN_AUDIO_IOMUX                 23
+#define TH1520_CLKGEN_AUDIO_CLK_END		      24
+
+#endif
diff --git a/include/dt-bindings/clock/th1520-dspsys.h b/include/dt-bindings/clock/th1520-dspsys.h
new file mode 100644
index 000000000000..973e80bb0d09
--- /dev/null
+++ b/include/dt-bindings/clock/th1520-dspsys.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#ifndef _TH1520_DSPSYS_H
+#define _TH1520_DSPSYS_H
+// gate
+#define CLKGEN_DSP0_PCLK			0
+#define CLKGEN_DSP0_CCLK                        1
+#define CLKGEN_DSP1_PCLK                        2
+#define CLKGEN_DSP1_CCLK                        3
+#define CLKGEN_X2X_X4_DSPSLV_DSP0_ACLK_M        4
+#define CLKGEN_X2X_X4_DSPSLV_DSP1_ACLK_M        5
+#define CLKGEN_AXI4_DSPSYS_SLV_ACLK             6
+#define CLKGEN_AXI4_DSPSYS_ACLK                 7
+#define CLKGEN_IOPMP_DSP0_PCLK                  8
+#define CLKGEN_IOPMP_DSP1_PCLK                  9
+#define CLKGEN_AXI4_DSPSYS_SLV_PCLK             10
+#define CLKGEN_AXI4_DSPSYS_PCLK                 11
+#define CLKGEN_X2X_DSP0_ACLK_S			12
+#define CLKGEN_X2X_DSP2_ACLK_S			13
+// MUX
+#define DSPSYS_DSP0_CLK_SWITCH          14
+#define DSPSYS_DSP1_CLK_SWITCH          15
+// DIV
+#define DSPSYS_DSP_CLK              16
+#define DSPSYS_DSP0_CLK_CDE         17
+#define DSPSYS_DSP1_CLK_CDE         18
+
+#define TH1520_CLKGEN_DSPSYS_CLK_END		19
+
+#endif
diff --git a/include/dt-bindings/clock/th1520-fm-ap-clock.h b/include/dt-bindings/clock/th1520-fm-ap-clock.h
new file mode 100644
index 000000000000..8bb23b690f98
--- /dev/null
+++ b/include/dt-bindings/clock/th1520-fm-ap-clock.h
@@ -0,0 +1,513 @@
+#ifndef _APSYS_CLKGEN_H
+#define _APSYS_CLKGEN_H
+
+#define C910_CCLK_I0                                       0
+#define AXI4_CPUSYS1_ACLK                                  1
+#define CLKGEN_GPIO2_DBCLK                                 2
+#define CLKGEN_MBOX0_PCLK                                  3
+#define CLKGEN_GMAC0_CCLK                                  4
+#define CLKGEN_SPI_PCLK                                    5
+#define CLKGEN_CLK_OUT_1_CLK                               6
+#define PAD_RTC_CLK                                        7
+#define CLKGEN_SPINLOCK_HCLK                               8
+#define CLKGEN_QSPI1_PCLK                                  9
+#define CLKGEN_HDMI_ISCAN_CK_REF_CLK                       10
+#define CLKGEN_IOPMP_AON_PCLK                              11
+#define CLKGEN_ISP_RY_ACLK                                 12
+#define CLKGEN_MIPIDSI0_SCANRXCLKESC                       13
+#define CLKGEN_EIP120SII_HCLK                              14
+#define CLKGEN_MIPI_CSI0_PIXCLK                            15
+#define CLKGEN_SRAM_AXI_ACLK_3                             16
+#define CLKGEN_PERISYS_AHB_HCLK                            17
+#define VOSYS_HDMI_ISCAN_RX_WORD_CLK0_CLK                  18
+#define CLKGEN_QSPI0_SSI_CLK                               19
+#define CLKGEN_DW200_ACLK                                  20
+#define CLKGEN_IOPMP_EIP120SIII_PCLK                       21
+#define VISYS_MIPI_CSI2_CFGCLK                             22
+#define CLKGEN_APB3_CPUSYS_HCLK                            23
+#define CLKGEN_PERISYS_APB1_HCLK                           24
+#define CLKGEN_GPU_CORE_CLK                                25
+#define CLKGEN_USB3_DRD_ACLK                               26
+#define CLKGEN_VISYS_ACLK                                  27
+#define CLKGEN_USB3_DRD_CTRL_REF_CLK                       28
+#define CLKGEN_TEE_DMAC_ACLK                               29
+#define CLKGEN_AUDIO_SUBSYS_ACLK_CP2AP                     30
+#define CLKGEN_SRAM_AXI_ACLK_2                             31
+#define CLKGEN_IOPMP_VOSYS_GPU_PCLK                        32
+#define CLKGEN_CFG2TEE_X2H_ACLK                            33
+#define CLKGEN_SRAM_AXI_ACLK_1                             34
+#define MISC_SDIO0_OSC_CLK                                 35
+#define CLKGEN_SDIO0_ACLK                                  36
+#define CLKGEN_MIPI_DSI1_CFGCLK                            37
+#define APB3_CPUSYS_PCLK                                   38
+#define CLKGEN_TEE_DMAC_HCLK                               39
+#define VOSYS_DPU0_PIXELCLK                                40
+#define CLKGEN_CPU2CFG_X2H_MHCLK                           41
+#define CLKGEN_VPSYS_ACLK                                  42
+#define CLKGEN_MIPIDSI1_SCANRXCLKESC                       43
+#define CLKGEN_MISC2VP_X2X_ACLK_S                          44
+#define CLKGEN_MIPI_CSI_SCANBYTECLK                        45
+#define CLKGEN_APB3_TEESYS_HCLK                            46
+#define VENC_CCLK                                          47
+#define VPSYS_VDEC_CCLK                                    48
+#define CLKGEN_MIPI_CSI0_CFG_CLK                           49
+#define CLKGEN_MISCSYS_BUS_CLK                             50
+#define CLKGEN_DPU_HCLK                                    51
+#define CLKGEN_UART1_SCLK                                  52
+#define GMAC_PLL_FOUTPOSTDIV                               53
+#define MISC_BUS_CLK                                       54
+#define CLKGEN_USB3_DRD_SPDCLK                             55
+#define CLKGEN_MIPI_CSI2_CFG_CLK                           56
+#define CLKGEN_TOP_AXI4S_ACLK                              57
+#define CLKGEN_IOPMP_EIP120SII_ACLK                        58
+#define CORE_CLK                                           59
+#define CLKGEN_VPSYS_FCE_ACLK                              60
+#define CLKGEN_I2C3_PCLK                                   61
+#define DPU1_PLL_DIV_CLK                                   62
+#define CLKGEN_USB3_DRD_PHY_REF_CLK                        63
+#define CLKGEN_AON2CPU_A2X_ACLK                            64
+#define CLKGEN_QSPI1_SSI_CLK                               65
+#define CLKGEN_DPU_CCLK                                    66
+#define VISYS_MASTER_BUS_ACLK                              67
+#define CLKGEN_PERI_I2S_SRC_CLK_0                          68
+#define VOSYS_ACLK_M                                       69
+#define TEESYS_I0_HCLK                                     70
+#define CLKGEN_MIPI_DSI1_REFCLK                            71
+#define CLKGEN_MIPI_DSI0_PCLK                              72
+#define CLKGEN_VOSYS_ACLK_S                                73
+#define CLKGEN_CPU2VP_X2P_PCLK                             74
+#define CLKGEN_X2X_CPUSYS_ACLK_S                           75
+#define CLKGEN_HDMI_ISCAN_RX_WORD_CLK1_CLK                 76
+#define CLKGEN_IOPMP_VOSYS_DPU1_PCLK                       77
+#define CLKGEN_MISC2VP_X2X_ACLK_M                          78
+#define CLKGEN_WDT0_PCLK                                   79
+#define VOSYS_MIPIDSI0_SCANTXCLKESC                        80
+#define VISYS_MIPI_CSI1_CFGCLK                             81
+#define AHB2_CPUSYS_HCLK                                   82
+#define CLKGEN_SDIO1_HCLK                                  83
+#define CLKGEN_SDIO0_HCLK                                  84
+#define CLKGEN_CLK_OUT_3_CLK                               85
+#define CLKGEN_GMAC_AXI_ACLK                               86
+#define GMAC_CCLK                                          87
+#define CLKGEN_VIPRE_PCLK                                  88
+#define CLKGEN_HDMI_ISCAN_TX_CK_OUT2_CLK                   89
+#define CLKGEN_MIPIDSI1_SCANTXCLKESC                       90
+#define CLKGEN_VISYS_SLAVE_HCLK                            91
+#define VOSYS_HDMI_ISCAN_TX_CK_OUT1_CLK                    92
+#define CLKGEN_X2X_CPUSYS_ACLK_M                           93
+#define CLKGEN_CPU2CFG_X2X_ACLK_S                          94
+#define C910_OSC_CLK                                       95
+#define CLKGEN_X2H_DPU1_ACLK                               96
+#define CLKGEN_I2C4_PCLK                                   97
+#define CLKGEN_GMAC0_ACLK                                  98
+#define MISC_USB3_PHY_REF_CLK                              99
+#define VOSYS_MIPIDSI0_CFG_CLK                             100
+#define CLKGEN_VPSYS_VDEC_CCLK                             101
+#define VOSYS_MIPIDSI1_CFG_CLK                             102
+#define CLKGEN_I2S_PCLK                                    103
+#define CLKGEN_DMAC_CPUSYS_ACLK                            104
+#define VISYS_DW200_CLK_DWE                                105
+#define CLKGEN_OCRAM_HCLK                                  106
+#define CLKGEN_EFUSE_PCLK                                  107
+#define CLKGEN_X2H_DPU_ACLK                                108
+#define CLKGEN_IOPMP_SDIO0_ACLK                            109
+#define VOSYS_DPU1_PIXELCLK                                110
+#define CPU_PLL1_FOUT4                                     111
+#define CLKGEN_GPIO2_PCLK                                  112
+#define CLKGEN_GMAC1_CCLK                                  113
+#define CPU_PLL1_FOUTPOSTDIV                               114
+#define VOSYS_HDMI_ISCAN_40M_CLK                           115
+#define CLKGEN_VOSYS_X2X_ACLK_S                            116
+#define CLKGEN_PERISYS_APB2_HCLK                           117
+#define VOSYS_OSC_CLK_MUX_I2S_CLK_OCCBUF                   118
+#define CLKGEN_HDMI_CEC_CLK                                119
+#define CLKGEN_X2P_X4_VOSYS_PCLK                           120
+#define CLKGEN_VOSYS_ACLK_M                                121
+#define CLKGEN_EMMC_SDIO_REF_CLK                           122
+#define CLKGEN_IOPMP_EMMC_ACLK                             123
+#define VIDEO_PLL_FOUTVCO                                  124
+#define CLKGEN_HDMI_ISCAN_CKO_WORD_CLK                     125
+#define CLKGEN_IOPMP_VOSYS_DPU_PCLK                        126
+#define CLKGEN_AXI4_VISYS3_ACLK                            127
+#define CLKGEN_VISYS_SYSREG_PCLK                           128
+#define CLKGEN_MIPIDSI0_SCANTXCLKESC                       129
+#define CLKGEN_HDMI_ISCAN_TX_CK_OUT1_CLK                   130
+#define CLKGEN_IOPMP_EIP120SIII_ACLK                       131
+#define CLKGEN_EIP120SII_ACLK                              132
+#define CLKGEN_MBOX2_PCLK                                  133
+#define CLKGEN_AXI4_VISYS1_ACLK                            134
+#define CLKGEN_UART1_PCLK                                  135
+#define CLK_OUT_3                                          136
+#define CLKGEN_UART5_SCLK                                  137
+#define CLKGEN_HDMI_ISCAN_RX_WORD_CLK2_CLK                 138
+#define CLKGEN_MBOX3_PCLK                                  139
+#define QSPI1_SSI_CLK                                      140
+#define CLKGEN_I2C1_PCLK                                   141
+#define CLKGEN_HDMI_I2S_CLK                                142
+#define CLKGEN_AXI4_CPUSYS2_PCLK                           143
+#define CLKGEN_CFG2TEE_X2H_MHCLK                           144
+#define CLKGEN_C910_CPU_CLK                                145
+#define VOSYS_HDMI_ISCAN_TX_CK_OUT2_CLK                    146
+#define CLKGEN_HDMI_PCLK                                   147
+#define CLKGEN_IOPMP_EIP120SII_PCLK                        148
+#define CLKGEN_MISCSYS_AXI_PCLK                            149
+#define CLKGEN_EIP120SI_ACLK                               150
+#define TEESYS_I1_HCLK                                     151
+#define PERISYS_APB_PCLK                                   152
+#define VOSYS_HDMI_ISCAN_RX_WORD_CLK0_DIV2_CLK             153
+#define CLKGEN_TIMER0_CCLK                                 154
+#define CLKGEN_IOPMP_USB3_ACLK                             155
+#define CLKGEN_UART2_PCLK                                  156
+#define CLK_OUT_4                                          157
+#define AXI4_CPUSYS2_ACLK                                  158
+#define CLKGEN_AUDIO_SUBSYS_ACLK_AP2CP                     159
+#define CLKGEN_I2C3_IC_CLK                                 160
+#define CLKGEN_IOPMP_GPU_ACLK                              161
+#define CLKGEN_TIMER1_CCLK                                 162
+#define VOSYS_I2S_CLK                                      163
+#define CLKGEN_I2C5_IC_CLK                                 164
+#define VOSYS_OSC_CLK_MUX_I2S_CLK                          165
+#define CLKGEN_DDR_SUBSYS_ACLK_0                           166
+#define CLKGEN_TIMER1_PCLK                                 167
+#define CLKGEN_I2C1_IC_CLK                                 168
+#define CLKGEN_I2S_SRC_CLK                                 169
+#define VISYS_DW200_CLK_VSE                                170
+#define CLKGEN_MIPIDSI1_PIXCLK                             171
+#define VOSYS_RTC_CLK                                      172
+#define CLK_OUT_1                                          173
+#define CLKGEN_PERISYS_APB4_HCLK                           174
+#define MISC_USB3_CTRL_REF_CLK                             175
+#define CLKGEN_TEE_SYSREG_PCLK                             176
+#define CLKGEN_MISCSYS_AXI_ACLK                            177
+#define CLKGEN_MIPIDSI1_SCANCLK                            178
+#define CLKGEN_GPIO3_DBCLK                                 179
+#define CLKGEN_HDMI_ISCAN_40M_CLK                          180
+#define CLKGEN_PERI2PERI1_APB_HCLK                         181
+#define CLKGEN_GMAC0_HCLK                                  182
+#define CLKGEN_DDR_SUBSYS_PCLK                             183
+#define VOSYS_PCLK                                         184
+#define CLKGEN_MIPIDSI1_SCANBYTECLK                        185
+#define CLKGEN_VPSYS_G2D_ACLK                              186
+#define CLKGEN_EIP150B_HCLK                                187
+#define CLKGEN_UART4_SCLK                                  188
+#define DPU1_PLL_TEST_CLK                                  189
+#define CLKGEN_VOSYS_X2X_ACLK_M                            190
+#define CLKGEN_IOPMP_EIP120SI_ACLK                         191
+#define CLKGEN_CLK_OUT_4_CLK                               192
+#define CLKGEN_GPIO0_FPCLK                                 193
+#define PAD_OSC_CLK                                        194
+#define CLKGEN_C910_BUS_CLK_NO_ICG                         195
+#define CLKGEN_TIMER0_PCLK                                 196
+#define CLKGEN_AHB2_CPUSYS_HCLK                            197
+#define EMMC_SDIO_REF_CLK                                  198
+#define CLKGEN_IOPMP_CHIP_DBG_PCLK                         199
+#define CLKGEN_BMU_C910_PCLK                               200
+#define CLKGEN_IOPMP_DPU1_ACLK                             201
+#define CLKGEN_PADCTRL0_APSYS_PCLK                         202
+#define MISC_SDIO1_OSC_CLK                                 203
+#define CLKGEN_C910_OSC_CLK                                204
+#define VISYS_ISP_RY_CCLK                                  205
+#define CLKGEN_VPSYS_PCLK                                  206
+#define VISYS_MIPI_CSI0_PIXELCLK                           207
+#define NPU_CCLK                                           208
+#define CLKGEN_AXI4_TEESYS_ACLK                            209
+#define PERI2SYS_APB_PCLK                                  210
+#define CLKGEN_IOPMP_GMAC0_PCLK                            211
+#define CLKGEN_VPSYS_G2D_PCLK                              212
+#define CLKGEN_EMMC_ACLK                                   213
+#define CLKGEN_UART3_SCLK                                  214
+#define AONSYS_BUS_CLK                                     215
+#define DPU0_PLL_FOUT4                                     216
+#define VOSYS_MIPIDSI1_SCANCLK                             217
+#define CLKGEN_UART4_PCLK                                  218
+#define CLKGEN_HDMI_ISCAN_SCL                              219
+#define CLKGEN_MIPI_CSI1_PIXCLK                            220
+#define CLKGEN_APSYS_CLKGEN_PCLK                           221
+#define CLKGEN_GPU_TIMER_REFCLK                            222
+#define GMAC_PLL_FOUT1PH0                                  223
+#define VOSYS_MIPIDSI1_SCANBYTECLK                         224
+#define CLKGEN_GPIO3_FPCLK                                 225
+#define CLKGEN_SDIO1_OSC_CLK                               226
+#define CLKGEN_GPIO3_PCLK                                  227
+#define CLKGEN_VPSYS_AXI_ACLK                              228
+#define CLKGEN_HDMI_ISCAN_TX_CK_20B_CLK                    229
+#define CLKGEN_VOSYSREG_PCLK                               230
+#define VIDEO_PLL_TEST_CLK                                 231
+#define CLKGEN_MBOX1_PCLK                                  232
+#define CLKGEN_I2C2_IC_CLK                                 233
+#define VOSYS_MIPIDSI0_PLL_SCANCLK                         234
+#define VOSYS_MIPIDSI1_SCANTXCLKESC                        235
+#define VOSYS_HDMI_ISCAN_RX_WORD_CLK1_DIV2_CLK             236
+#define CLKGEN_UART2_SCLK                                  237
+#define MISC_TEESYS_PCLK                                   238
+#define AUDIO_PLL_TEST_CLK                                 239
+#define CLKGEN_DPU_PIXELCLK1                               240
+#define CLKGEN_IOPMP_TEEDMAC_PCLK                          241
+#define CLKGEN_TOP_APB_SX_PCLK                             242
+#define CLKGEN_I2C4_IC_CLK                                 243
+#define GMAC_PLL_TEST_CLK                                  244
+#define CLKGEN_HDMI_JTAG_TCLK                              245
+#define VISYS_MIPI_CSI0_CFGCLK                             246
+#define CLKGEN_CPU2AON_X2H_ACLK                            247
+#define VOSYS_HDMI_ISCAN_TX_CK_OUT0_CLK                    248
+#define QSPI_SSI_CLK                                       249
+#define VOSYS_DPU_CCLK                                     250
+#define CLKGEN_CPU2VI_X2H_MHCLK                            251
+#define CLKGEN_MIPI_DSI0_REFCLK                            252
+#define CLKGEN_DSPSYS_HCLK                                 253
+#define CLKGEN_IOPMP_AUD_PCLK                              254
+#define CLKGEN_PERI2PERI1_APB_PCLK                         255
+#define CFG_AXI_ACLK                                       256
+#define VPSYS_FCE_CCLK                                     257
+#define CLKGEN_HDMI_ISCAN_CLK                              258
+#define CPU_PLL0_TEST_CLK                                  259
+#define CLKGEN_CPU2PERI_X2H_MHCLK                          260
+#define VISYS_ACLK_M                                       261
+#define VOSYS_HDMI_JTAG_TCLK                               262
+#define CLKGEN_IOPMP_AUD_ACLK                              263
+#define CLKGEN_HDMI_ISCAN_RX_WORD_CLK1_DIV2_CLK            264
+#define VOSYS_HDMI_ISCAN_RX_WORD_CLK1_CLK                  265
+#define VOSYS_MIPIDSI0_REFCLK                              266
+#define CLKGEN_VISYS_ACLK_M                                267
+#define VOSYS_MIPIDSI0_SCANRXCLKESC                        268
+#define CLKGEN_SDIO1_ACLK                                  269
+#define CFG_APB_PCLK                                       270
+#define CLKGEN_PADCTRL1_APSYS_PCLK                         271
+#define VOSYS_MIPIDSI0_SCANCLK                             272
+#define CLKGEN_I2C0_IC_CLK                                 273
+#define CLKGEN_VPSYS_APB_PCLK                              274
+#define CLKGEN_VPSYS_VENC_CCLK                             275
+#define CLKGEN_AXI4_CFG_BUS_ACLK                           276
+#define CLKGEN_MIPIDSI0_SCANBYTECLK                        277
+#define GPIO3_DBCLK                                        278
+#define CLKGEN_HDMI_ISCAN_RX_WORD_CLK0_CLK                 279
+#define CLKGEN_UART5_PCLK                                  280
+#define DPU0_PLL_FOUTPOSTDIV_ICG                           281
+#define CPU_PLL0_FOUT4                                     282
+#define CLKGEN_GPIO2_FPCLK                                 283
+#define CLKGEN_DPU_ACLK                                    284
+#define CLKGEN_AXI4_CPUSYS2_ACLK                           285
+#define CLKGEN_DSPSYS_PCLK                                 286
+#define TEE_PLL_FOUTPOSTDIV                                287
+#define TIMER_CCLK                                         288
+#define VOSYS_MIPIDSI1_PLL_SCANCLK                         289
+#define CLKGEN_GMAC_AXI_PCLK                               290
+#define CLKGEN_USB3_DRD_PCLK                               291
+#define CLKGEN_AXI4_CPUSYS1_PCLK                           292
+#define VOSYS_ACLK                                         293
+#define CLKGEN_IOPMP_EIP120SI_PCLK                         294
+#define VOSYS_HDMI_ISCAN_TMDSCLKIN_CLK                     295
+#define VOSYS_HDMI_ISCAN_CKO_WORD_CLK                      296
+#define CLKGEN_NPUSYS_AXI_ACLK                             297
+#define CLKGEN_IOPMP_SDIO0_PCLK                            298
+#define CLKGEN_DW200_HCLK                                  299
+#define VOSYS_HDMI_ISCAN_RX_WORD_CLK2_CLK                  300
+#define CLKGEN_UART0_PCLK                                  301
+#define CLKGEN_CLK_OUT_2_CLK                               302
+#define CLKGEN_GPIO0_PCLK                                  303
+#define CLKGEN_EMMC_OSC_CLK                                304
+#define VPSYS_APB_PCLK                                     305
+#define CLKGEN_HDMI_PIXCLK                                 306
+#define CLKGEN_IOPMP_TEEDMAC_ACLK                          307
+#define AUDIO_PLL_FOUT4                                    308
+#define CLKGEN_MIPI_CSI2_PCLK                              309
+#define CLKGEN_MIPI_DSI1_PCLK                              310
+#define CLKGEN_MIPI_DSI0_CFGCLK                            311
+#define VISYS_ISP0_CLK                                     312
+#define VISYS_ISP1_CLK                                     313
+#define MISC_EMMC_OSC_CLK                                  314
+#define DPU0_PLL_FOUTPOSTDIV                               315
+#define VISYS_AHB_HCLK                                     316
+#define CLKGEN_IOPMP_SDIO1_ACLK                            317
+#define CLKGEN_EMMC_HCLK                                   318
+#define I2S_CLK                                            319
+#define CLKGEN_CPU2PERI_X2H_ACLK                           320
+#define VPSYS_AXI_ACLK                                     321
+#define CLKGEN_IOPMP_SDIO1_PCLK                            322
+#define CLKGEN_EIP120SIII_HCLK                             323
+#define CLKGEN_BMU_C910_ACLK                               324
+#define CLKGEN_IOPMP_DMAC_CPUSYS_PCLK                      325
+#define GPIO2_DBCLK                                        326
+#define CHIP_DBG_CCLK                                      327
+#define CLKGEN_MISCSYS_TEE_CCLK                            328
+#define CLKGEN_I2C5_PCLK                                   329
+#define CLKGEN_X2H_CPUSYS_MHCLK                            330
+#define CLKGEN_PWM_CCLK                                    331
+#define DPU0_PLL_TEST_CLK                                  332
+#define CLKGEN_VISYS_PCLK                                  333
+#define MISC_TEESYS_HCLK                                   334
+#define SPI_SSI_CLK                                        335
+#define CLKGEN_PWM_PCLK                                    336
+#define VOSYS_MIPIDSI1_SCANRXCLKESC                        337
+#define QSPI0_SSI_CLK                                      338
+#define CLKGEN_HDMI_ISCAN_TMDSCLKIN_CLK                    339
+#define CLKGEN_SPI_SSI_CLK                                 340
+#define VIDEO_PLL_FOUT4                                    341
+#define CLKGEN_IOPMP_GMAC0_ACLK                            342
+#define CLKGEN_VIPRE_ACLK                                  343
+#define MISC_OSC_CLK_DIV24                                 344
+#define CLKGEN_ISP_VENC_SHAKE_PCLK                         345
+#define CLKGEN_HDMI_ISCAN_TX_CK_OUT0_CLK                   346
+#define CLKGEN_VPSYS_G2D_CCLK                              347
+#define CLKGEN_CPU2CFG_X2X_ACLK_M                          348
+#define CLKGEN_GMAC1_PCLK                                  349
+#define CLKGEN_MIPIDSI0_PLL_SCANCLK                        350
+#define CLKGEN_HDMI_ISCAN_RX_WORD_CLK0_DIV2_CLK            351
+#define TEE_PLL_FOUT4                                      352
+#define PERISYS_AHB_HCLK                                   353
+#define VIDEO_PLL_FOUT1PH0                                 354
+#define CLKGEN_MIPIDSI0_PIXCLK                             355
+#define CLKGEN_PERI_I2S_SRC_CLK_1                          356
+#define CLKGEN_MIPI_CSI0_PCLK                              357
+#define CLKGEN_DDR_SUBSYS_ACLK_1                           358
+#define CLKGEN_GMAC0_PCLK                                  359
+#define CLK_OUT_2                                          360
+#define CLKGEN_EIP120SIII_ACLK                             361
+#define AONSYS_HCLK                                        362
+#define CLKGEN_ISP0_CLK                                    363
+#define CLKGEN_C910_BROM_HCLK                              364
+#define DPU1_PLL_FOUT4                                     365
+#define PERI_I2S_SRC_CLK                                   366
+#define CPU_PLL1_TEST_CLK                                  367
+#define CLKGEN_DDR_SUBSYS_ACLK_2                           368
+#define CLKGEN_MIPIDSI0_SCANCLK                            369
+#define I2C_IC_CLK                                         370
+#define CLKGEN_DPU_PIXELCLK0                               371
+#define CLKGEN_GPIO1_DBCLK                                 372
+#define CLKGEN_C910_TOP_DS_PCLK                            373
+#define CLKGEN_DSPSYS_ACLK_M                               374
+#define CLKGEN_AON2CPU_A2X_HCLK                            375
+#define VOSYS_HDMI_ISCAN_CK_REF_CLK                        376
+#define CLKGEN_IOPMP_EMMC_PCLK                             377
+#define NPU_CORE_CLK                                       378
+#define CLKGEN_IOPMP_USB3_PCLK                             379
+#define VPSYS_PCLK                                         380
+#define VIDEO_PLL_FOUTPOSTDIV                              381
+#define CLKGEN_CPU2VP_X2P_ACLK                             382
+#define CLKGEN_APB_CPU2CFG_HCLK                            383
+#define VOSYS_OSC_CLK_MUX_CEC_CLK_OCCBUF                   384
+#define CLKGEN_GPIO1_PCLK                                  385
+#define CLKGEN_APSYS_SYSREG_PCLK                           386
+#define CLKGEN_VISYS_HCLK                                  387
+#define CLKGEN_MIPI_CSI1_PCLK                              388
+#define CLKGEN_AHB2_TEESYS_HCLK                            389
+#define CLKGEN_DDR_SUBSYS_ACLK_4                           390
+#define SYS_PLL_TEST_CLK                                   391
+#define VISYS_MIPI_CSI_SCANCLK                             392
+#define CPU_PLL0_FOUTPOSTDIV                               393
+#define CLKGEN_UART3_PCLK                                  394
+#define CLKGEN_X2H_CPUSYS_ACLK                             395
+#define CLKGEN_MIPI_CSI1_CFG_CLK                           396
+#define CLKGEN_HDMI_ISCAN_RX_WORD_CLK2_DIV2_CLK            397
+#define CLKGEN_MISCSYS_APB_HCLK                            398
+#define CLKGEN_CPU2CFG_X2H_ACLK                            399
+#define CLKGEN_MIPI_CSI2_FPCLK                             400
+#define CLKGEN_ISP_RY_CCLK                                 401
+#define CLKGEN_X2P_VOSYS_ACLK                              402
+#define CLKGEN_VIPRE_PIXELCLK                              403
+#define VOSYS_GPU_TIMER_REFCLK                             404
+#define VOSYS_OSC_CLK_MUX_CEC_CLK                          405
+#define CLKGEN_APSYS_RSTGEN_PCLK                           406
+#define VOSYS_HDMI_ISCAN_SCL                               407
+#define CLKGEN_ISP_RY_HCLK                                 408
+#define VOSYS_OSC_CLK                                      409
+#define VISYS_PCLK                                         410
+#define CLKGEN_AXI4_VO_ACLK                                411
+#define CLKGEN_MIPIDSI1_PLL_SCANCLK                        412
+#define GPIO1_DBCLK                                        413
+#define CLKGEN_AXI4_VISYS2_ACLK                            414
+#define CLKGEN_EIP120SI_HCLK                               415
+#define CLKGEN_IOPMP_CHIP_DBG_ACLK                         416
+#define VOSYS_HDMI_ISCAN_TX_CK_20B_CLK                     417
+#define VOSYS_MIPIDSI1_REFCLK                              418
+#define CLKGEN_CHIP_DBG_ACLK                               419
+#define VOSYS_CFG_ACLK                                     420
+#define CLKGEN_VOSYS_AXI_ACLK                              421
+#define CPU_BUS_DFTCLK                                     422
+#define VOSYS_HDMI_ISCAN_CLK                               423
+#define VISYS_SLAVE_BUS_HCLK                               424
+#define CLKGEN_VPSYS_VDEC_PCLK                             425
+#define GMAC_PLL_FOUT4                                     426
+#define CLKGEN_QSPI0_PCLK                                  427
+#define CLKGEN_ISP1_CLK                                    428
+#define CLKGEN_MIPI_CSI0_FPCLK                             429
+#define CLKGEN_ISP0_ACLK                                   430
+#define CLKGEN_CPU2VI_X2H_ACLK                             431
+#define C910_CCLK                                          432
+#define CLKGEN_DW200_CLK_VSE                               433
+#define CLKGEN_AXI4_CPUSYS1_ACLK                           434
+#define CLKGEN_GPU_CFG_ACLK                                435
+#define CLKGEN_GPIO1_FPCLK                                 436
+#define CLKGEN_SRAM_AXI_ACLK_0                             437
+#define CLKGEN_I2C2_PCLK                                   438
+#define CLKGEN_IOPMP_GMAC1_PCLK                            439
+#define CLKGEN_ISP0_S_HCLK                                 440
+#define GPIO0_DBCLK                                        441
+#define CLKGEN_AXI4_VO_CFG_ACLK                            442
+#define CLKGEN_NPU_CORE_CLK                                443
+#define DPU0_PLL_DIV_CLK                                   444
+#define VOSYS_MIPIDSI0_SCANBYTECLK                         445
+#define CLKGEN_CHIP_DBG_CCLK                               446
+#define CLKGEN_DMAC_CPUSYS_HCLK                            447
+#define CLKGEN_IOPMP_DPU_ACLK                              448
+#define CLKGEN_DDR_SUBSYS_ACLK_3                           449
+#define CLK_100M                                           450
+#define CLKGEN_DSMART_PCLK                                 451
+#define CLKGEN_DW200_CLK_DWE                               452
+#define VPSYS_G2D_CCLK                                     453
+#define CLKGEN_WDT1_PCLK                                   454
+#define DPU1_PLL_FOUTPOSTDIV                               455
+#define CLKGEN_IOPMP_GMAC1_ACLK                            456
+#define CLKGEN_VPSYS_FCE_PCLK                              457
+#define CLKGEN_MIPI_CSI_SCANCLK                            458
+#define CLKGEN_MIPI_CSI2_PIXCLK                            459
+#define CLKGEN_I2C0_PCLK                                   460
+#define VOSYS_HDMI_ISCAN_RX_WORD_CLK2_DIV2_CLK             461
+#define CLKGEN_HDMI_SFR_CLK                                462
+#define TEE_PLL_TEST_CLK                                   463
+#define CLKGEN_IOPMP_DMAC_CPUSYS_ACLK                      464
+#define CLKGEN_ISP_PIXELCLK                                465
+#define CLKGEN_MIPI_CSI1_FPCLK                             466
+#define SYS_PLL_FOUT4                                      467
+#define CLKGEN_AXI4_VO_PCLK                                468
+#define CLKGEN_UART0_SCLK                                  469
+#define CLKGEN_CPU2AON_X2H_MHCLK                           470
+#define VISYS_MIPI_CSI_SCANBYTECLK                         471
+#define UART_SCLK                                          472
+#define CLKGEN_IOPMP_AON_ACLK                              473
+#define CLKGEN_VPSYS_VDEC_ACLK                             474
+#define CLKGEN_GMAC1_HCLK                                  475
+#define CLKGEN_ISP_VENC_SHAKE_ACLK                         476
+#define TEESYS_HCLK                                        477
+#define PWM_CCLK                                           478
+#define CLKGEN_GPIO0_DBCLK                                 479
+#define CLKGEN_SDIO0_OSC_CLK                               480
+#define CLKGEN_GMAC1_ACLK                                  481
+#define VPSYS_ACLK                                         482
+
+#define AHB2_CPUSYS_HCLK_OUT_DIV			   483
+#define APB3_CPUSYS_PCLK_DIV				   484
+#define CFG_AXI_ACLK_OUT_DIV				   485
+#define PERISYS_AHB_HCLK_OUT_DIV			   486
+#define CLK_OUT_1_OUT_DIV				   487
+#define CLK_OUT_2_OUT_DIV                                  488
+#define CLK_OUT_3_OUT_DIV                                  489
+#define CLK_OUT_4_OUT_DIV                                  490
+#define NPU_CCLK_OUT_DIV				   491
+#define CFG_APB_PCLK_OUT_DIV				   492
+#define CPU_PLL0_BYPASS					   493
+#define CPU_PLL1_BYPASS					   494
+#define GMAC_PLL_BYPASS					   495
+#define VIDEO_PLL_BYPASS				   496
+#define TEE_PLL_BYPASS					   497
+#define DPU0_PLL_BYPASS					   498
+#define DPU1_PLL_BYPASS					   499
+
+#define CLK_DUMMY					   500
+#define OSC_32K						   501
+#define OSC_24M						   502
+#define RC_24M						   503
+
+#define CLK_END						   504
+
+#endif
diff --git a/include/dt-bindings/clock/th1520-miscsys.h b/include/dt-bindings/clock/th1520-miscsys.h
new file mode 100644
index 000000000000..a23a623b3ea8
--- /dev/null
+++ b/include/dt-bindings/clock/th1520-miscsys.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+#ifndef _TH1520_MISCSYS_H
+#define _TH1520_MISCSYS_H
+#define CLKGEN_MISCSYS_MISCSYS_ACLK			0
+#define CLKGEN_MISCSYS_USB3_DRD_CLK			1
+#define CLKGEN_MISCSYS_USB3_DRD_CTRL_REF_CLK		2
+#define CLKGEN_MISCSYS_USB3_DRD_PHY_REF_CLK		3
+#define CLKGEN_MISCSYS_USB3_DRD_SUSPEND_CLK		4
+#define CLKGEN_MISCSYS_EMMC_CLK				5
+#define CLKGEN_MISCSYS_SDIO0_CLK			6
+#define CLKGEN_MISCSYS_SDIO1_CLK			7
+#define CLKGEN_MISCSYS_AHB2_TEESYS_HCLK			8
+#define CLKGEN_MISCSYS_APB3_TEESYS_HCLK			9
+#define CLKGEN_MISCSYS_AXI4_TEESYS_ACLK			10
+#define CLKGEN_MISCSYS_EIP120SI_CLK			11
+#define CLKGEN_MISCSYS_EIP120SII_CLK			12
+#define CLKGEN_MISCSYS_EIP120SIII_CLK			13
+#define CLKGEN_MISCSYS_TEEDMAC_CLK			14
+#define CLKGEN_MISCSYS_EIP150B_HCLK			15
+#define CLKGEN_MISCSYS_OCRAM_HCLK			16
+#define CLKGEN_MISCSYS_EFUSE_PCLK			17
+#define CLKGEN_MISCSYS_TEE_SYSREG_PCLK			18
+#define CLKGEN_MISCSYS_CLK_END				19
+#endif
+
diff --git a/include/dt-bindings/clock/th1520-visys.h b/include/dt-bindings/clock/th1520-visys.h
new file mode 100644
index 000000000000..4caed847fc7a
--- /dev/null
+++ b/include/dt-bindings/clock/th1520-visys.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#ifndef _TH1520_VISYS_H
+#define _TH1520_VISYS_H
+
+#define TH1520_CLKGEN_VISYS_ACLK			      0
+#define TH1520_CLKGEN_DW200_ACLK			      1
+#define TH1520_CLKGEN_AXI4_VISYS1_ACLK		      2
+#define TH1520_CLKGEN_AXI4_VISYS2_ACLK                 3
+#define TH1520_CLKGEN_AXI4_VISYS3_ACLK                 4
+#define TH1520_CLKGEN_ISP0_ACLK                        5
+#define TH1520_CLKGEN_ISP_RY_ACLK                      6
+#define TH1520_CLKGEN_ISP_VENC_SHAKE_ACLK              7
+#define TH1520_CLKGEN_VIPRE_ACLK                       8
+#define TH1520_CLKGEN_VISYS_SLAVE_HCLK                 9
+#define TH1520_CLKGEN_ISP0_S_HCLK                      10
+#define TH1520_CLKGEN_DW200_HCLK                       11
+#define TH1520_CLKGEN_ISP_RY_HCLK                      12
+#define TH1520_CLKGEN_MIPI_CSI0_PCLK                   13
+#define TH1520_CLKGEN_MIPI_CSI0_FPCLK                  14
+#define TH1520_CLKGEN_MIPI_CSI1_PCLK                   15
+#define TH1520_CLKGEN_MIPI_CSI1_FPCLK                  16
+#define TH1520_CLKGEN_MIPI_CSI2_PCLK                   17
+#define TH1520_CLKGEN_MIPI_CSI2_FPCLK                  18
+#define TH1520_CLKGEN_VIPRE_PCLK                       19
+#define TH1520_CLKGEN_VISYS_PCLK                       20
+#define TH1520_CLKGEN_VISYS_SYSREG_PCLK                21
+#define TH1520_CLKGEN_ISP_VENC_SHAKE_PCLK              22
+#define TH1520_CLKGEN_MIPI_CSI0_PIXCLK                 23
+#define TH1520_CLKGEN_MIPI_CSI1_PIXCLK                 24
+#define TH1520_CLKGEN_MIPI_CSI2_PIXCLK                 25
+#define TH1520_CLKGEN_VIPRE_PIXELCLK                   26
+#define TH1520_CLKGEN_ISP_PIXELCLK                     27
+#define TH1520_CLKGEN_MIPI_CSI0_CFG_CLK                28
+#define TH1520_CLKGEN_MIPI_CSI1_CFG_CLK                29
+#define TH1520_CLKGEN_MIPI_CSI2_CFG_CLK                30
+#define TH1520_CLKGEN_DW200_CLK_VSE                    31
+#define TH1520_CLKGEN_DW200_CLK_DWE                    32
+#define TH1520_CLKGEN_ISP0_CLK                         33
+#define TH1520_CLKGEN_ISP1_CLK                         34
+#define TH1520_CLKGEN_ISP_RY_CCLK                      35
+#define TH1520_CLKGEN_MIPI_CSI_SCANBYTECLK             36
+#define TH1520_CLKGEN_MIPI_CSI_SCANCLK                 37
+#define TH1520_CLKGEN_ISP1_PIXELCLK		      38
+#define TH1520_CLKGEN_ISP0_PIXELCLK		      39
+#define TH1520_CLKGEN_ISP1_HCLK			      40
+#define TH1520_CLKGEN_ISP0_HCLK			      41
+#define TH1520_CLKGEN_ISP1_ACLK			      42
+#define TH1520_CLKGEN_VISYS_CLK_END		      43
+
+#endif
diff --git a/include/dt-bindings/clock/th1520-vosys.h b/include/dt-bindings/clock/th1520-vosys.h
new file mode 100644
index 000000000000..9b9de7739cec
--- /dev/null
+++ b/include/dt-bindings/clock/th1520-vosys.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#ifndef TH1520_VOSYS_H
+#define TH1520_VOSYS_H
+
+#define TH1520_CLKGEN_AXI4_VO_PCLK			0
+#define TH1520_CLKGEN_IOPMP_VOSYS_DPU_PCLK		1
+#define TH1520_CLKGEN_IOPMP_VOSYS_DPU1_PCLK		2
+#define TH1520_CLKGEN_IOPMP_VOSYS_GPU_PCLK		3
+#define TH1520_CLKGEN_HDMI_PCLK				4
+#define TH1520_CLKGEN_MIPIDSI0_PCLK			5
+#define TH1520_CLKGEN_MIPIDSI1_PCLK			6
+#define TH1520_CLKGEN_AXI4_VO_ACLK			7
+#define TH1520_CLKGEN_IOPMP_GPU_ACLK			8
+#define TH1520_CLKGEN_IOPMP_DPU_ACLK			9
+#define TH1520_CLKGEN_IOPMP_DPU1_ACLK			10
+#define TH1520_CLKGEN_X2H_DPU_ACLK			11
+#define TH1520_CLKGEN_X2H_DPU1_ACLK			12
+#define TH1520_CLKGEN_MIPIDSI0_PIXCLK			13
+#define TH1520_CLKGEN_HDMI_PIXCLK			14
+#define TH1520_CLKGEN_MIPIDSI1_PIXCLK			15
+#define TH1520_CLKGEN_HDMI_SFR_CLK			16
+#define TH1520_CLKGEN_HDMI_CEC_CLK			17
+#define TH1520_CLKGEN_HDMI_I2S_CLK			18
+#define TH1520_CLKGEN_MIPIDSI0_CFG_CLK			19
+#define TH1520_CLKGEN_MIPIDSI1_CFG_CLK			20
+#define TH1520_CLKGEN_MIPIDSI0_REFCLK			21
+#define TH1520_CLKGEN_MIPIDSI1_REFCLK			22
+#define TH1520_CLKGEN_GPU_CORE_CLK			23
+#define TH1520_CLKGEN_GPU_CFG_ACLK			24
+#define TH1520_CLKGEN_DPU_HCLK				25
+#define TH1520_CLKGEN_DPU_ACLK				26
+#define TH1520_CLKGEN_DPU_CCLK				27
+#define TH1520_CLKGEN_DPU_PIXCLK0			28
+#define TH1520_CLKGEN_DPU_PIXCLK1                        29
+#define TH1520_CLKGEN_VOSYS_CLK_END			30
+
+#endif
diff --git a/include/dt-bindings/clock/th1520-vpsys.h b/include/dt-bindings/clock/th1520-vpsys.h
new file mode 100644
index 000000000000..1dd3bbb78da6
--- /dev/null
+++ b/include/dt-bindings/clock/th1520-vpsys.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#ifndef _TH1520_VPSYS_H
+#define _TH1520_VPSYS_H
+
+#define TH1520_VPSYS_G2D_PCLK		0
+#define TH1520_VPSYS_G2D_ACLK		1
+#define TH1520_VPSYS_G2D_CCLK		2
+#define TH1520_VPSYS_FCE_PCLK		3
+#define TH1520_VPSYS_FCE_ACLK		4
+#define TH1520_VPSYS_VDEC_PCLK		5
+#define TH1520_VPSYS_VDEC_ACLK		6
+#define TH1520_VPSYS_VDEC_CCLK		7
+#define TH1520_VPSYS_AXI_ACLK		8
+#define TH1520_VPSYS_VENC_CCLK		9
+#define TH1520_VPSYS_VENC_PCLK		10
+#define TH1520_VPSYS_VENC_ACLK		11
+#define TH1520_VPSYS_G2D_CCLK_DIV    12
+#define TH1520_VPSYS_DEC_CCLK_DIV    13
+#define TH1520_VPSYS_CLK_END		14
+
+#endif
+
-- 
2.43.0

