From 176624e38b490e9098abd0383207d7d34db84e2f Mon Sep 17 00:00:00 2001
From: Xiangyi Zeng <xiangyi.zeng@linux.alibaba.com>
Date: Thu, 6 Jun 2024 21:12:12 +0800
Subject: [PATCH 124/400] drivers/soc/event: Add THEAD TH1520 event driver

Signed-off-by: Xiangyi Zeng <xiangyi.zeng@linux.alibaba.com>
---
 drivers/soc/Kconfig                         |   1 +
 drivers/soc/Makefile                        |   1 +
 drivers/soc/thead/Kconfig                   |  10 +
 drivers/soc/thead/Makefile                  |   2 +
 drivers/soc/thead/th1520_event.c            | 280 ++++++++++++++++++++
 drivers/watchdog/dw_wdt.c                   |   2 +
 include/linux/firmware/thead/th1520_event.h |  35 +++
 kernel/panic.c                              |   6 +
 8 files changed, 337 insertions(+)
 create mode 100644 drivers/soc/thead/Kconfig
 create mode 100644 drivers/soc/thead/Makefile
 create mode 100644 drivers/soc/thead/th1520_event.c
 create mode 100644 include/linux/firmware/thead/th1520_event.h

diff --git a/drivers/soc/Kconfig b/drivers/soc/Kconfig
index d21e75d69294..6ce6f6300055 100644
--- a/drivers/soc/Kconfig
+++ b/drivers/soc/Kconfig
@@ -31,5 +31,6 @@ source "drivers/soc/ti/Kconfig"
 source "drivers/soc/ux500/Kconfig"
 source "drivers/soc/versatile/Kconfig"
 source "drivers/soc/xilinx/Kconfig"
+source "drivers/soc/thead/Kconfig"
 
 endmenu
diff --git a/drivers/soc/Makefile b/drivers/soc/Makefile
index 0706a27d13be..f86b4aab27f5 100644
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -35,3 +35,4 @@ obj-y				+= ti/
 obj-$(CONFIG_ARCH_U8500)	+= ux500/
 obj-$(CONFIG_PLAT_VERSATILE)	+= versatile/
 obj-y				+= xilinx/
+obj-y				+= thead/
diff --git a/drivers/soc/thead/Kconfig b/drivers/soc/thead/Kconfig
new file mode 100644
index 000000000000..ddd68b37d7bd
--- /dev/null
+++ b/drivers/soc/thead/Kconfig
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0-only
+menu "Thead SoC drivers"
+
+config TH1520_REBOOTMODE
+	bool "Thead th1520 rebootmode support"
+	default y
+	help
+	 This driver supports check rebootmode feature in TH1520 FM platform
+
+endmenu
diff --git a/drivers/soc/thead/Makefile b/drivers/soc/thead/Makefile
new file mode 100644
index 000000000000..19ec6d7c52fd
--- /dev/null
+++ b/drivers/soc/thead/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0-only
+obj-$(CONFIG_TH1520_REBOOTMODE)	+= th1520_event.o
diff --git a/drivers/soc/thead/th1520_event.c b/drivers/soc/thead/th1520_event.c
new file mode 100644
index 000000000000..9d7123921638
--- /dev/null
+++ b/drivers/soc/thead/th1520_event.c
@@ -0,0 +1,280 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+#include <linux/firmware/thead/ipc.h>
+#include <linux/firmware/thead/th1520_event.h>
+
+/*
+ * AON SRAM total size is 0x10000, reserve 0x100 for event.
+ * Notice: c902 *.ld also need resize.
+ * -------------- 0xff_ffef8000
+ * |		|
+ * |		|
+ * |		|
+ * |  c902	|
+ * |		|
+ * |		|
+ * |		|
+ * -------------- 0xff_fff07f00
+ * |   reserve	|
+ * |		|
+ * --------------
+ */
+#define TH1520_AON_SRAM_LEN	0x10000
+#define TH1520_AON_SRAM_RESERV	(TH1520_AON_SRAM_LEN - 0x100)
+#define TH1520_EVENT_OFFSET	(TH1520_AON_SRAM_RESERV + 0x10)
+#define TH1520_EVENT_CHECK	(TH1520_EVENT_OFFSET + 0x4)
+
+#define TH1520_EVENT_MAGIC	0x5A5A5A5A
+
+struct th1520_aon_msg_event_ctrl {
+	struct th1520_aon_rpc_msg_hdr hdr;
+	u32 reserve_offset;
+	u32 reserved[5];
+} __packed __aligned(1);
+
+struct th1520_event {
+	struct device *dev;
+
+	struct th1520_aon_ipc *ipc_handle;
+	struct th1520_aon_msg_event_ctrl msg;
+
+	struct regmap *aon_iram;
+	bool init;
+};
+
+struct th1520_event *th1520_event;
+
+static void th1520_event_msg_hdr_fill(struct th1520_aon_rpc_msg_hdr *hdr, enum th1520_aon_sys_func func)
+{
+	hdr->svc = (uint8_t)TH1520_AON_RPC_SVC_SYS;
+	hdr->func = (uint8_t)func;
+	hdr->size = TH1520_AON_RPC_MSG_NUM;
+}
+
+static int th1520_event_aon_reservemem(struct th1520_event *event)
+{
+	struct th1520_aon_ipc *ipc = event->ipc_handle;
+	struct th1520_aon_rpc_ack_common ack_msg;
+	int ret = 0;
+
+	dev_dbg(event->dev, "aon reservemem...\n");
+
+	th1520_event_msg_hdr_fill(&event->msg.hdr, TH1520_AON_SYS_FUNC_AON_RESERVE_MEM);
+
+	RPC_SET_BE32(&event->msg.reserve_offset, 0, TH1520_EVENT_OFFSET);
+
+	ret = th1520_aon_call_rpc(ipc, &event->msg, &ack_msg, true);
+	if (ret)
+		dev_err(event->dev, "failed to set aon reservemem\n");
+
+	return ret;
+}
+
+int th1520_event_set_rebootmode(enum th1520_rebootmode_index mode)
+{
+	int ret;
+
+	if (!th1520_event || !th1520_event->init)
+		return -EINVAL;
+
+	ret = regmap_write(th1520_event->aon_iram, TH1520_EVENT_OFFSET, mode);
+	if (ret) {
+		dev_err(th1520_event->dev, "set rebootmode failed,ret:%d\n", ret);
+		return ret;
+	}
+
+	dev_info(th1520_event->dev, "set rebootmode:0x%x\n", mode);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(th1520_event_set_rebootmode);
+
+int th1520_event_get_rebootmode(enum th1520_rebootmode_index *mode)
+{
+	int ret;
+
+	if (!th1520_event || !th1520_event->init)
+		return -EINVAL;
+
+	ret = regmap_read(th1520_event->aon_iram, TH1520_EVENT_OFFSET, mode);
+	if (ret) {
+		dev_err(th1520_event->dev, "get rebootmode failed,ret:%d\n", ret);
+		return ret;
+	}
+	dev_dbg(th1520_event->dev, "%s get rebootmode:0x%x\n", __func__, *mode);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(th1520_event_get_rebootmode);
+
+static int th1520_event_check_powerup(void)
+{
+	enum th1520_rebootmode_index mode;
+	unsigned int val;
+	int ret;
+
+	if (!th1520_event->init)
+		return -EINVAL;
+
+	ret = regmap_read(th1520_event->aon_iram, TH1520_EVENT_CHECK, &val);
+	if (ret) {
+		dev_err(th1520_event->dev, "get magicnum failed,ret:%d\n", ret);
+		return ret;
+	}
+	ret = regmap_read(th1520_event->aon_iram, TH1520_EVENT_OFFSET, &mode);
+	if (ret) {
+		dev_err(th1520_event->dev, "get rebootmode failed,ret:%d\n", ret);
+		return ret;
+	}
+	dev_info(th1520_event->dev, "magicnum:0x%x mode:0x%x\n", val, mode);
+
+	/* powerup means SRAM data is randam */
+	if (val != TH1520_EVENT_MAGIC && mode != TH1520_EVENT_PMIC_ONKEY)
+		th1520_event_set_rebootmode(TH1520_EVENT_PMIC_POWERUP);
+
+	ret = regmap_write(th1520_event->aon_iram, TH1520_EVENT_CHECK, TH1520_EVENT_MAGIC);
+	if (ret) {
+		dev_err(th1520_event->dev, "set magicnum failed,ret:%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static ssize_t rebootmode_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	enum th1520_rebootmode_index mode;
+
+	if (kstrtouint(buf, 0, &mode) < 0)
+		return -EINVAL;
+	th1520_event_set_rebootmode(mode);
+
+	return count;
+}
+
+static ssize_t
+rebootmode_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	enum th1520_rebootmode_index mode;
+
+	th1520_event_get_rebootmode(&mode);
+
+	return sprintf(buf, "0x%x\n", mode);
+}
+static DEVICE_ATTR_RW(rebootmode);
+
+static struct attribute *event_attrs[] = {
+	&dev_attr_rebootmode.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(event);
+
+static int th1520_event_open(struct inode *inode, struct file *f)
+{
+	return 0;
+}
+
+static int th1520_event_release(struct inode *inode, struct file *f)
+{
+	return 0;
+}
+
+static long th1520_event_ioctl(struct file *f, unsigned int ioctl,
+			    unsigned long arg)
+{
+	return 0;
+}
+
+static const struct file_operations th1520_event_fops = {
+	.owner          = THIS_MODULE,
+	.release        = th1520_event_release,
+	.open           = th1520_event_open,
+	.unlocked_ioctl = th1520_event_ioctl,
+};
+
+static struct miscdevice th1520_event_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "th1520-event",
+	.fops = &th1520_event_fops,
+};
+
+static int th1520_event_probe(struct platform_device *pdev)
+{
+	struct device		*dev = &pdev->dev;
+	struct device_node	*np = dev->of_node;
+	struct th1520_event	*thead;
+	int			ret;
+
+	thead = devm_kzalloc(&pdev->dev, sizeof(*thead), GFP_KERNEL);
+	if (!thead)
+		return -ENOMEM;
+
+	ret = th1520_aon_get_handle(&(thead->ipc_handle));
+	if (ret == -EPROBE_DEFER)
+		return ret;
+
+	platform_set_drvdata(pdev, thead);
+	thead->dev = &pdev->dev;
+
+	thead->aon_iram = syscon_regmap_lookup_by_phandle(np, "aon-iram-regmap");
+	if (IS_ERR(thead->aon_iram))
+		return PTR_ERR(thead->aon_iram);
+
+	ret = misc_register(&th1520_event_misc);
+	if (ret < 0)
+		return ret;
+
+	ret = th1520_event_aon_reservemem(thead);
+	if (ret) {
+		dev_err(dev, "set aon reservemem failed!\n");
+		return -EPERM;
+	}
+	thead->init = true;
+	th1520_event = thead;
+
+	ret = th1520_event_check_powerup();
+	if (ret) {
+		dev_err(dev, "check powerup failed!\n");
+		th1520_event = NULL;
+		return -EPERM;
+	}
+	dev_info(dev, "th1520-event driver init successfully\n");
+
+	return 0;
+}
+
+static int th1520_event_remove(struct platform_device *pdev)
+{
+	misc_deregister(&th1520_event_misc);
+
+	return 0;
+}
+
+static const struct of_device_id th1520_event_of_match[] = {
+	{ .compatible = "thead,th1520-event" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, th1520_event_of_match);
+
+static struct platform_driver th1520_event_driver = {
+	.probe		= th1520_event_probe,
+	.remove		= th1520_event_remove,
+	.driver		= {
+		.name	= "th1520-event",
+		.dev_groups	= event_groups,
+		.of_match_table	= th1520_event_of_match,
+	},
+};
+
+module_platform_driver(th1520_event_driver);
+
+MODULE_DESCRIPTION("th1520-event driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/watchdog/dw_wdt.c b/drivers/watchdog/dw_wdt.c
index e5e6d7f15918..d61145fdbc25 100644
--- a/drivers/watchdog/dw_wdt.c
+++ b/drivers/watchdog/dw_wdt.c
@@ -28,6 +28,7 @@
 #include <linux/pm.h>
 #include <linux/reset.h>
 #include <linux/watchdog.h>
+#include <linux/firmware/thead/th1520_event.h>
 
 #define WDOG_CONTROL_REG_OFFSET		    0x00
 #define WDOG_CONTROL_REG_WDT_EN_MASK	    0x01
@@ -369,6 +370,7 @@ static irqreturn_t dw_wdt_irq(int irq, void *devid)
 	val = readl(dw_wdt->regs + WDOG_INTERRUPT_STATUS_REG_OFFSET);
 	if (!val)
 		return IRQ_NONE;
+	th1520_event_set_rebootmode(TH1520_EVENT_SW_WATCHDOG);
 
 	watchdog_notify_pretimeout(&dw_wdt->wdd);
 
diff --git a/include/linux/firmware/thead/th1520_event.h b/include/linux/firmware/thead/th1520_event.h
new file mode 100644
index 000000000000..b88ae8727c29
--- /dev/null
+++ b/include/linux/firmware/thead/th1520_event.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _TH1520_EVENT_H
+#define _TH1520_EVENT_H
+
+enum th1520_rebootmode_index {
+	/* C902 event rebootmode */
+        TH1520_EVENT_PMIC_RESET = 0x0,
+        TH1520_EVENT_PMIC_ONKEY,
+        TH1520_EVENT_PMIC_POWERUP,
+
+	/* C910 event rebootmode */
+        TH1520_EVENT_SW_REBOOT = 0x20,
+        TH1520_EVENT_SW_WATCHDOG,
+        TH1520_EVENT_SW_PANIC,
+        TH1520_EVENT_SW_HANG,
+        TH1520_EVENT_MAX,
+};
+
+#if IS_ENABLED(CONFIG_TH1520_REBOOTMODE)
+extern int th1520_event_set_rebootmode(enum th1520_rebootmode_index mode);
+extern int th1520_event_get_rebootmode(enum th1520_rebootmode_index *mode);
+#else
+static int th1520_event_set_rebootmode(enum th1520_rebootmode_index mode)
+{
+	return 0;
+}
+static int th1520_event_get_rebootmode(enum th1520_rebootmode_index *mode)
+{
+	*mode = TH1520_EVENT_MAX;
+
+	return 0;
+}
+#endif
+
+#endif
diff --git a/kernel/panic.c b/kernel/panic.c
index d7973e975474..ca65f140a278 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -37,6 +37,7 @@
 #include <linux/context_tracking.h>
 #include <trace/events/error_report.h>
 #include <asm/sections.h>
+#include <linux/firmware/thead/th1520_event.h>
 
 #define PANIC_TIMER_STEP 100
 #define PANIC_BLINK_SPD 18
@@ -281,6 +282,11 @@ void panic(const char *fmt, ...)
 	int state = 0;
 	int old_cpu, this_cpu;
 	bool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;
+	enum th1520_rebootmode_index mode;
+
+	if (!th1520_event_get_rebootmode(&mode) &&
+			mode != TH1520_EVENT_SW_WATCHDOG)
+			th1520_event_set_rebootmode(TH1520_EVENT_SW_PANIC);
 
 	if (panic_on_warn) {
 		/*
-- 
2.43.0

