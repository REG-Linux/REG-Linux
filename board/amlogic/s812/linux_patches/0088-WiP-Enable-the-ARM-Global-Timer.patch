From 3c5bcaa04e5d06d7a2ac36795b61bffb12c2ede2 Mon Sep 17 00:00:00 2001
From: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date: Sun, 18 Feb 2024 18:14:39 +0100
Subject: [PATCH] WiP: Enable the ARM Global Timer

Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
---
 arch/arm/boot/dts/amlogic/meson8.dtsi  | 15 ++++++++++---
 arch/arm/boot/dts/amlogic/meson8b.dtsi | 15 ++++++++++---
 drivers/clocksource/arm_global_timer.c | 31 ++++++++++++++++++++++----
 3 files changed, 51 insertions(+), 10 deletions(-)

diff --git a/arch/arm/boot/dts/amlogic/meson8.dtsi b/arch/arm/boot/dts/amlogic/meson8.dtsi
index 611431cf79c07b..36bd5b14c9197f 100644
--- a/arch/arm/boot/dts/amlogic/meson8.dtsi
+++ b/arch/arm/boot/dts/amlogic/meson8.dtsi
@@ -931,10 +931,19 @@
 		clocks = <&clkc CLKID_PERIPH>;
 
 		/*
-		 * the arm_global_timer driver currently does not handle clock
-		 * rate changes. Keep it disabled for now.
+		 * The ARM Global Timer can only change the prescaler at
+		 * runtime, which means that we need to find a pre-divider
+		 * which works together with the prescaler and can match
+		 * any CPU clock rate (from the slowest at 24MHz to the
+		 * highest at 1992MHz).
+		 * A pre-divider of 8 is a good compromise because it allows
+		 * running the ARM Global Timer at 3MHz which can be evenly
+		 * divided by all supported CPU frequencies from 24MHz to
+		 * 1992MHz while not overflowing the 8-bit prescaler in the
+		 * timer.
 		 */
-		status = "disabled";
+		assigned-clocks = <&clkc CLKID_PERIPH_SEL>;
+		assigned-clock-parents = <&clkc CLKID_CPU_CLK_DIV8>;
 	};
 
 	timer@600 {
diff --git a/arch/arm/boot/dts/amlogic/meson8b.dtsi b/arch/arm/boot/dts/amlogic/meson8b.dtsi
index 52a12c46bb625b..b45c682a73d14f 100644
--- a/arch/arm/boot/dts/amlogic/meson8b.dtsi
+++ b/arch/arm/boot/dts/amlogic/meson8b.dtsi
@@ -832,10 +832,19 @@
 		clocks = <&clkc CLKID_PERIPH>;
 
 		/*
-		 * the arm_global_timer driver currently does not handle clock
-		 * rate changes. Keep it disabled for now.
+		 * The ARM Global Timer can only change the prescaler at
+		 * runtime, which means that we need to find a pre-divider
+		 * which works together with the prescaler and can match
+		 * any CPU clock rate (from the slowest at 24MHz to the
+		 * highest at 1992MHz).
+		 * A pre-divider of 8 is a good compromise because it allows
+		 * running the ARM Global Timer at 3MHz which can be evenly
+		 * divided by all supported CPU frequencies from 24MHz to
+		 * 1992MHz while not overflowing the 8-bit prescaler in the
+		 * timer.
 		 */
-		status = "disabled";
+		assigned-clocks = <&clkc CLKID_PERIPH_SEL>;
+		assigned-clock-parents = <&clkc CLKID_CPU_CLK_DIV8>;
 	};
 
 	timer@600 {
diff --git a/drivers/clocksource/arm_global_timer.c b/drivers/clocksource/arm_global_timer.c
index 2d5cdedc52ef43..95716136f6ca2d 100644
--- a/drivers/clocksource/arm_global_timer.c
+++ b/drivers/clocksource/arm_global_timer.c
@@ -340,9 +340,22 @@ static int gt_clk_rate_change_cb(struct notifier_block *nb,
 struct gt_prescaler_config {
 	const char *compatible;
 	unsigned long prescaler;
+	unsigned long target_rate;
 };
 
 static const struct gt_prescaler_config gt_prescaler_configs[] = {
+	/*
+	 * On Amlogic Meson8/8b/8m2 SoCs the global timer clock is derived
+	 * from the CPU clock, which runs at 24MHz (slowest) to 1992MHz
+	 * (highest). It uses a fixed pre-divider of 8 because it allows
+	 * running the ARM Global Timer at 3MHz which can be evenly divided
+	 * by all supported CPU frequencies while not overflowing the 8-bit
+	 * prescaler in the ARM Global Timer registers. We don't know the
+	 * CPU clock chosen by the bootloader.
+	 */
+	{ .compatible = "amlogic,meson8", .target_rate = 3 * 1000 * 1000 },
+	{ .compatible = "amlogic,meson8b", .target_rate = 3 * 1000 * 1000 },
+	{ .compatible = "amlogic,meson8m2", .target_rate = 3 * 1000 * 1000 },
 	/*
 	 * On am43 the global timer clock is a child of the clock used for CPU
 	 * OPPs, so the initial prescaler has to be compatible with all OPPs
@@ -355,7 +368,7 @@ static const struct gt_prescaler_config gt_prescaler_configs[] = {
 	{ .compatible = NULL }
 };
 
-static unsigned long gt_get_initial_prescaler_value(struct device_node *np)
+static unsigned long gt_get_initial_prescaler_value(unsigned long gt_clk_rate)
 {
 	const struct gt_prescaler_config *config;
 
@@ -363,8 +376,18 @@ static unsigned long gt_get_initial_prescaler_value(struct device_node *np)
 		return CONFIG_ARM_GT_INITIAL_PRESCALER_VAL;
 
 	for (config = gt_prescaler_configs; config->compatible; config++) {
-		if (of_machine_is_compatible(config->compatible))
-			return config->prescaler;
+		if (!of_machine_is_compatible(config->compatible))
+			continue;
+
+		if (config->target_rate) {
+			if (gt_clk_rate % config->target_rate)
+				pr_warn("global-timer: targeted rate %luHz is not cleanly achievable on a %luHz clock\n",
+					config->target_rate, gt_clk_rate);
+
+			return (gt_clk_rate / config->target_rate) - 1;
+		}
+
+		return config->prescaler;
 	}
 
 	return 1;
@@ -411,8 +434,8 @@ static int __init global_timer_of_register(struct device_node *np)
 		goto out_unmap;
 	}
 
-	psv = gt_get_initial_prescaler_value(np);
 	gt_clk_rate = clk_get_rate(gt_clk);
+	psv = gt_get_initial_prescaler_value(gt_clk_rate);
 	gt_target_rate = gt_clk_rate / psv;
 	gt_clk_rate_change_nb.notifier_call =
 		gt_clk_rate_change_cb;
