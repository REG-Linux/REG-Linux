From a0d80f0ef244f0bb198613a43a9665d0fc3f885f Mon Sep 17 00:00:00 2001
From: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date: Sun, 12 Oct 2025 23:39:20 +0200
Subject: [PATCH] Revert "WiP: Enable the ARM Global Timer"

This reverts commit 622ef5b590cfece4bcf3a766c44dd3e3413a12bd.
---
 arch/arm/boot/dts/amlogic/meson8.dtsi  | 15 +++----------
 arch/arm/boot/dts/amlogic/meson8b.dtsi | 15 +++----------
 drivers/clocksource/arm_global_timer.c | 31 ++++----------------------
 3 files changed, 10 insertions(+), 51 deletions(-)

diff --git a/arch/arm/boot/dts/amlogic/meson8.dtsi b/arch/arm/boot/dts/amlogic/meson8.dtsi
index 36bd5b14c9197f..611431cf79c07b 100644
--- a/arch/arm/boot/dts/amlogic/meson8.dtsi
+++ b/arch/arm/boot/dts/amlogic/meson8.dtsi
@@ -931,19 +931,10 @@
 		clocks = <&clkc CLKID_PERIPH>;
 
 		/*
-		 * The ARM Global Timer can only change the prescaler at
-		 * runtime, which means that we need to find a pre-divider
-		 * which works together with the prescaler and can match
-		 * any CPU clock rate (from the slowest at 24MHz to the
-		 * highest at 1992MHz).
-		 * A pre-divider of 8 is a good compromise because it allows
-		 * running the ARM Global Timer at 3MHz which can be evenly
-		 * divided by all supported CPU frequencies from 24MHz to
-		 * 1992MHz while not overflowing the 8-bit prescaler in the
-		 * timer.
+		 * the arm_global_timer driver currently does not handle clock
+		 * rate changes. Keep it disabled for now.
 		 */
-		assigned-clocks = <&clkc CLKID_PERIPH_SEL>;
-		assigned-clock-parents = <&clkc CLKID_CPU_CLK_DIV8>;
+		status = "disabled";
 	};
 
 	timer@600 {
diff --git a/arch/arm/boot/dts/amlogic/meson8b.dtsi b/arch/arm/boot/dts/amlogic/meson8b.dtsi
index b45c682a73d14f..52a12c46bb625b 100644
--- a/arch/arm/boot/dts/amlogic/meson8b.dtsi
+++ b/arch/arm/boot/dts/amlogic/meson8b.dtsi
@@ -832,19 +832,10 @@
 		clocks = <&clkc CLKID_PERIPH>;
 
 		/*
-		 * The ARM Global Timer can only change the prescaler at
-		 * runtime, which means that we need to find a pre-divider
-		 * which works together with the prescaler and can match
-		 * any CPU clock rate (from the slowest at 24MHz to the
-		 * highest at 1992MHz).
-		 * A pre-divider of 8 is a good compromise because it allows
-		 * running the ARM Global Timer at 3MHz which can be evenly
-		 * divided by all supported CPU frequencies from 24MHz to
-		 * 1992MHz while not overflowing the 8-bit prescaler in the
-		 * timer.
+		 * the arm_global_timer driver currently does not handle clock
+		 * rate changes. Keep it disabled for now.
 		 */
-		assigned-clocks = <&clkc CLKID_PERIPH_SEL>;
-		assigned-clock-parents = <&clkc CLKID_CPU_CLK_DIV8>;
+		status = "disabled";
 	};
 
 	timer@600 {
diff --git a/drivers/clocksource/arm_global_timer.c b/drivers/clocksource/arm_global_timer.c
index 95716136f6ca2d..2d5cdedc52ef43 100644
--- a/drivers/clocksource/arm_global_timer.c
+++ b/drivers/clocksource/arm_global_timer.c
@@ -340,22 +340,9 @@ static int gt_clk_rate_change_cb(struct notifier_block *nb,
 struct gt_prescaler_config {
 	const char *compatible;
 	unsigned long prescaler;
-	unsigned long target_rate;
 };
 
 static const struct gt_prescaler_config gt_prescaler_configs[] = {
-	/*
-	 * On Amlogic Meson8/8b/8m2 SoCs the global timer clock is derived
-	 * from the CPU clock, which runs at 24MHz (slowest) to 1992MHz
-	 * (highest). It uses a fixed pre-divider of 8 because it allows
-	 * running the ARM Global Timer at 3MHz which can be evenly divided
-	 * by all supported CPU frequencies while not overflowing the 8-bit
-	 * prescaler in the ARM Global Timer registers. We don't know the
-	 * CPU clock chosen by the bootloader.
-	 */
-	{ .compatible = "amlogic,meson8", .target_rate = 3 * 1000 * 1000 },
-	{ .compatible = "amlogic,meson8b", .target_rate = 3 * 1000 * 1000 },
-	{ .compatible = "amlogic,meson8m2", .target_rate = 3 * 1000 * 1000 },
 	/*
 	 * On am43 the global timer clock is a child of the clock used for CPU
 	 * OPPs, so the initial prescaler has to be compatible with all OPPs
@@ -368,7 +355,7 @@ static const struct gt_prescaler_config gt_prescaler_configs[] = {
 	{ .compatible = NULL }
 };
 
-static unsigned long gt_get_initial_prescaler_value(unsigned long gt_clk_rate)
+static unsigned long gt_get_initial_prescaler_value(struct device_node *np)
 {
 	const struct gt_prescaler_config *config;
 
@@ -376,18 +363,8 @@ static unsigned long gt_get_initial_prescaler_value(unsigned long gt_clk_rate)
 		return CONFIG_ARM_GT_INITIAL_PRESCALER_VAL;
 
 	for (config = gt_prescaler_configs; config->compatible; config++) {
-		if (!of_machine_is_compatible(config->compatible))
-			continue;
-
-		if (config->target_rate) {
-			if (gt_clk_rate % config->target_rate)
-				pr_warn("global-timer: targeted rate %luHz is not cleanly achievable on a %luHz clock\n",
-					config->target_rate, gt_clk_rate);
-
-			return (gt_clk_rate / config->target_rate) - 1;
-		}
-
-		return config->prescaler;
+		if (of_machine_is_compatible(config->compatible))
+			return config->prescaler;
 	}
 
 	return 1;
@@ -434,8 +411,8 @@ static int __init global_timer_of_register(struct device_node *np)
 		goto out_unmap;
 	}
 
+	psv = gt_get_initial_prescaler_value(np);
 	gt_clk_rate = clk_get_rate(gt_clk);
-	psv = gt_get_initial_prescaler_value(gt_clk_rate);
 	gt_target_rate = gt_clk_rate / psv;
 	gt_clk_rate_change_nb.notifier_call =
 		gt_clk_rate_change_cb;
