#!/bin/dash
[ "$1" = "stop" ] && umount -l -a -t nfs,nfs2,nfs4,cifs
[ "$1" != "start" ] && exit 0

printf "Starting SHARE: "
###
# SHARECONFFILE can contain :
# INTERNAL     => /dev/mmcblk0p2
# RAM          => tmpfs
# ANYEXTERNAL  => any device found not starting by /dev/mmcblk0p (use it when you've several usb keys, but plug only one at a time)
# NETWORK      => use the NAS specified by sharenetwork_[smb-or-nfs][0-9] options
# DEV [FSUUID] => a device having the FSUID uuid
# DEVICES      => use local storage devices specified by sharedevice_part[1-9]
###

SHARECONFFILE="/boot/system-boot.conf"
INTERNALDEVICE=$(/usr/bin/system-part "share_internal")
INTERNALDEVICETYPE=$(blkid -o value -s TYPE "${INTERNALDEVICE}")

# Read sharedevice in one shot
SHAREDEVICE=$(awk -F= '/^[[:space:]]*sharedevice[[:space:]]*=/ {gsub(/^[[:space:]]+|[[:space:]]+$/, "", $2); print $2; exit}' "${SHARECONFFILE}")
: "${SHAREDEVICE:=INTERNAL}"

MAXTRY="${sharewait:-15}"
NTRY=0

mountRAMDisk() {
    mount -t tmpfs -o size=256M tmpfs /userdata
}

mountDeviceOrFallback() {
    DEVICE=$1
    TDEVICE=$2
    REGLINUXFULLFS="/var/reglinuxfs"
    FALLBACK=1

    [ -n "${DEVICE}" ] && mkdir -p "${REGLINUXFULLFS}" && system-mount "${TDEVICE}" 1 "${DEVICE}" "${REGLINUXFULLFS}" && mkdir -p "${REGLINUXFULLFS}/reglinux" && mount --bind "${REGLINUXFULLFS}/reglinux" "/userdata" -o noatime && FALLBACK=0

    [ "${FALLBACK}" = "1" ] && ! system-mount "${INTERNALDEVICETYPE}" 1 "${INTERNALDEVICE}" /userdata && mountRAMDisk
}

mountPartByTag() {
    TAG=$1
    DIR=$2

    FSTYPE=$(blkid -l -t "${TAG}" -s TYPE -o value)
    [ -z "$FSTYPE" ] && return 1
    FSDEVICE=$(blkid -l -t "${TAG}" -o device)

    case "${FSTYPE}" in
        ntfs)
            { modprobe ntfs3 >/dev/null 2>&1 && FSTYPE=ntfs3 ; } || { modprobe fuse >/dev/null 2>&1 && FSTYPE=ntfs-3g ; }
            ntfsinfo -m "${FSDEVICE}" 2>&1 | grep -q 'Volume is scheduled for check.' && ntfsfix -d "${FSDEVICE}" >/dev/null 2>&1
            ;;
        *)
            modprobe "${FSTYPE}" >/dev/null 2>&1
            ;;
    esac
    mount -t "${FSTYPE}" "${TAG}" "${DIR}"
}

mountPartSubdir() {
    CMD_KEYPART=$1
    CMD_PART=$2
    CMD_SUBDIR=$3
    CMD_TDIR=$4

    SUBDIR_PATH="/var/reglinux_subdir_${CMD_KEYPART}"
    { mkdir -p "${SUBDIR_PATH}" && mountPartByTag "UUID=${CMD_PART}" "${SUBDIR_PATH}" && mkdir -p "${SUBDIR_PATH}${CMD_SUBDIR}" && mount --bind "${SUBDIR_PATH}${CMD_SUBDIR}" "${CMD_TDIR}"; } || return 1
}

mountDevicesOrNetwork() {
    # /boot/system-boot.conf examples :
    # sharedevice=NETWORK
    #
    # Basic commands : sharenetwork_<nfs|smb><[0-9]>=<DIR>@<host>:<remote directory>:<mount options>
    # Where <DIR> can be one of SHARE|ROMS|SAVES|BIOS|MUSIC|DECORATIONS|SCREENSHOTS|THEMES|CHEATS|SOUNDS|LIBRARY|CONFIGS
    #
    # sharenetwork_nfs1=SHARE@192.168.0.1:/Documents/reglinux
    # or
    # sharenetwork_nfs1=ROMS@192.168.0.1:/Documents/reglinux/roms
    # sharenetwork_nfs2=SAVES@192.168.0.1:/Documents/reglinux/saves
    # or
    # sharenetwork_smb1=SHARE@192.168.0.1:Documents/reglinux:guest
    #
    # Advanced commands : sharenetwork_cmd<[0-9]>=<command to run>
    # sharenetwork_cmd1=mount -o port=2049,nolock,proto=tcp 192.168.0.1:/Documents/reglinux /userdata
    # or
    # sharenetwork_cmd1=mount -o port=2049,nolock,proto=tcp 192.168.0.1:/Documents/reglinux/roms /userdata/roms
    # sharenetwork_cmd2=mount -o port=2049,nolock,proto=tcp 192.168.0.1:/Documents/reglinux/saves /userdata/saves
    # or
    # sharenetwork_cmd1=mount.cifs //192.168.0.1/reglinux /userdata -o guest
    #
    # mounting full partitions or sub folders of partitions on top of the internal partition
    # sharedevice=DEVICES
    # sharedevice_part1=SHARE@abcdefg-1234-5678-hijk-lmnopq0000
    # sharedevice_part2=ROMS@68dc61b8-5008-4659-bde9-5938a547680a:/Documents/roms

    # execute all commands in /boot/system-boot.conf which are like : sharenetwork_cmd1=my command    # Use a temp file to avoid subshell variable loss
    TMPFILE=$(mktemp)
    trap 'rm -f "${TMPFILE}"' EXIT

    # Extract all sharenetwork_*/sharedevice_* lines
    awk '
        /^[[:space:]]*share(network|device)_[a-z]*[0-9][[:space:]]*=/ {
            gsub(/^[[:space:]]*share(network|device)_/, "", $0)
            split($0, a, "=")
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", a[1])
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", a[2])
            print a[1] " " a[2]
        }
    ' "${SHARECONFFILE}" > "${TMPFILE}"

    XWAIT=4
    XTRY=$((MAXTRY / XWAIT))
    while IFS=" " read -r CTYPE CMD; do
        [ -z "${CTYPE}" ] && continue
        CMD_EXEC="echo"
        if [ "${CTYPE}" = "cmd" ]; then
            CMD_EXEC="${CMD}"
        else
            # Extract CMD_TARGET, CMD_HOST, CMD_RDIR, CMD_OPT, CMD_PART, CMD_SUBDIR
            case "${CTYPE}" in
                nfs|smb)
                    CMD_TARGET=${CMD%%@*}
                    REMAINDER=${CMD#*@}
                    CMD_HOST=${REMAINDER%%:*}
                    REMAINDER2=${REMAINDER#*:}
                    CMD_RDIR=${REMAINDER2%%:*}
                    CMD_OPT=${REMAINDER2#*:}
                    [ "${CMD_OPT}" = "${REMAINDER2}" ] && CMD_OPT=""
                    ;;
                part)
                    CMD_TARGET=${CMD%%@*}
                    CMD_PART_FULL=${CMD#*@}
                    CMD_SUBDIR="/"
                    if [ "${CMD_PART_FULL#*:}" != "${CMD_PART_FULL}" ]; then
                        CMD_SUBDIR="/${CMD_PART_FULL#*:}"
                        CMD_PART=${CMD_PART_FULL%%:*}
                    else
                        CMD_PART=${CMD_PART_FULL}
                    fi
                    CMD_KEYPART=$(printf '%s' "${CMD_PART}" | md5sum | cut -c1-10)
                    ;;
                *)
                    printf 'unknown type: %s\n' "${CTYPE}" >&2
                    return 1
                    ;;
            esac

            # Map target to directory
            case "${CMD_TARGET}" in
                SHARE)       CMD_TDIR="/userdata" ;;
                ROMS)        CMD_TDIR="/userdata/roms" ;;
                SAVES)       CMD_TDIR="/userdata/saves" ;;
                BIOS)        CMD_TDIR="/userdata/bios" ;;
                MUSIC)       CMD_TDIR="/userdata/music" ;;
                DECORATIONS) CMD_TDIR="/userdata/decorations" ;;
                SCREENSHOTS) CMD_TDIR="/userdata/screenshots" ;;
                THEMES)      CMD_TDIR="/userdata/themes" ;;
                CHEATS)      CMD_TDIR="/userdata/cheats" ;;
                SOUNDS)      CMD_TDIR="/userdata/sounds" ;;
                LIBRARY)     CMD_TDIR="/userdata/library" ;;
                CONFIGS)     CMD_TDIR="/userdata/system/configs" ;;
                RECORDINGS)  CMD_TDIR="/userdata/recordings" ;;
                *)           CMD_TDIR="/userdata" ;;
            esac

            mkdir -p "${CMD_TDIR}" || return 1
            case "${CTYPE}" in
                nfs)
                    modprobe nfs >/dev/null 2>&1
                    CMD_ADDOPT=${CMD_OPT:+",$CMD_OPT"}
                    CMD_EXEC="mount -o port=2049,nolock,proto=tcp${CMD_ADDOPT} ${CMD_HOST}:${CMD_RDIR} ${CMD_TDIR}"
                    ;;
                smb)
                    modprobe cifs >/dev/null 2>&1
                    CMD_ADDOPT=${CMD_OPT:+"-o $CMD_OPT"}
                    CMD_EXEC="mount.cifs //${CMD_HOST}/${CMD_RDIR} ${CMD_TDIR} ${CMD_ADDOPT}"
                    ;;
                part)
                    if [ "${CMD_SUBDIR}" = "/" ]; then
                        CMD_EXEC="mountPartByTag UUID=${CMD_PART} ${CMD_TDIR}"
                    else
                        CMD_EXEC="mountPartSubdir ${CMD_KEYPART} ${CMD_PART} ${CMD_SUBDIR} ${CMD_TDIR}"
                    fi
                    ;;
            esac
        fi

        TRYCOUNT=${XTRY}
        while [ ${TRYCOUNT} -gt 0 ]; do
            TRYCOUNT=$((TRYCOUNT - 1))
            if eval "${CMD_EXEC}"; then
                printf 'success: %s\n' "${CMD_EXEC}" >&2
                break
            else
                printf 'fail (%d): %s\n' "${TRYCOUNT}" "${CMD_EXEC}" >&2
                if [ ${TRYCOUNT} -eq 0 ]; then
                    printf 'giving up: %s\n' "${CMD_EXEC}" >&2
                    return 1
                fi
                sleep ${XWAIT}
            fi
        done
    done < "${TMPFILE}"

    return 0
}

# Parse RMODE
RMODE="${SHAREDEVICE}"
case "${RMODE}" in
    DEV\ *)
        MODE="DEV"
        UUID=${RMODE#DEV }
        ;;
    *)
        MODE="${RMODE}"
        ;;
esac

# LVM scan if tools exist
if command -v vgscan >/dev/null 2>&1 && command -v vgchange >/dev/null 2>&1; then
    vgscan >/dev/null 2>&1
    vgchange -ay >/dev/null 2>&1
fi

case "${MODE}" in
    DEV)
        LDEVICE=""
        while [ -z "${LDEVICE}" ] && [ "${NTRY}" -lt "${MAXTRY}" ]; do
            NTRY=$((NTRY + 1))
            sleep 1
            LDEVICE=$(blkid | grep -m 1 " UUID=\"${UUID}\"")
        done
        if [ -n "${LDEVICE}" ]; then 
            DEVICE=${LDEVICE%%:*}
            TDEVICE=$(printf '%s' "${LDEVICE}" | sed 's/.* TYPE="\([^"]*\)".*/\1/')
            mountDeviceOrFallback "${DEVICE}" "${TDEVICE}"
        else
            mountRAMDisk
        fi
        ;;
    ANYEXTERNAL)
        PARTPREFIX=$(system-part prefix "${INTERNALDEVICE}")
        LDEVICE=""
        while [ -z "${LDEVICE}" ] && [ "${NTRY}" -lt "${MAXTRY}" ]; do
            NTRY=$((NTRY + 1))
            sleep 1
            LDEVICE=$(blkid | grep -F TYPE= | grep -F UUID= | grep -v "^${PARTPREFIX}" | head -n1)
        done
        if [ -n "${LDEVICE}" ]; then
            DEVICE=${LDEVICE%%:*}
            TDEVICE=$(printf '%s' "${LDEVICE}" | sed 's/.* TYPE="\([^"]*\)".*/\1/')
            mountDeviceOrFallback "${DEVICE}" "${TDEVICE}"
        else
            mountRAMDisk
        fi
        ;;
    RAM)
        mountRAMDisk
        ;;
    NETWORK|DEVICES)
        system-mount "${INTERNALDEVICETYPE}" 1 "${INTERNALDEVICE}" /userdata || mountRAMDisk
        mountDevicesOrNetwork > /tmp/mountDevicesOrNetwork.log 2> /tmp/mountDevicesOrNetwork.err
        ;;
    INTERNAL|*)
        system-mount "${INTERNALDEVICETYPE}" 1 "${INTERNALDEVICE}" /userdata || mountRAMDisk
        ;;
esac

# Enable compression if btrfs and enabled
# /userdata is not yet mounted, system.fscompression.enabled has to be in /boot/system-boot.conf
[ "$(/usr/bin/regmsg systemconf getconfigkey system.fscompression.enabled)" = "1" ] && grep -q "^/dev/[^ ]* /userdata btrfs" /proc/mounts && { mount -o remount,compress-force=zstd,autodefrag /userdata || exit 1; }

# Handle delayed usbmount
if [ -d /var/run/usbmount.delay ]; then
    for RULE in /var/run/usbmount.delay/*; do
        [ -f "${RULE}" ] || continue
        RTYPE=${RULE##*/}; RTYPE=${RTYPE#*.}
        (
            . "${RULE}"
            /usr/share/usbmount/usbmount "${RTYPE}"
            rm -f "${RULE}"
        )
    done
fi
touch /var/run/system.share.mounted
# Remove carriage returns from .conf file
grep -q "$(printf '\r')" /userdata/system/system.conf 2>/dev/null && tr -d '\r' < /userdata/system/system.conf > /tmp/system.conf.tmp && mv /tmp/system.conf.tmp /userdata/system/system.conf
echo "done."
