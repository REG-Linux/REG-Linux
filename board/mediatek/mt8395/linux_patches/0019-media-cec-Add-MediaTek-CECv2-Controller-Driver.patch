From b704a2949499bcc143fc8cebeb2ce2b24e6ccddf Mon Sep 17 00:00:00 2001
From: AngeloGioacchino Del Regno <angelogioacchino.delregno@collabora.com>
Date: Mon, 18 Nov 2024 20:34:39 +0100
Subject: [PATCH 19/79] media: cec: Add MediaTek CECv2 Controller Driver

Add the MediaTek CEC v2 Controller driver, found in SoCs equipped
with the HDMIv2 Controller IP, like MT8195 and MT8188.

In the MT8195 SoC the (single) CEC Controller is shared between
the HDMI-TX and the HDMI-RX controllers, while in MT8188 this is
used only for HDMI-TX (as there is no receiver in the latter).

Signed-off-by: AngeloGioacchino Del Regno <angelogioacchino.delregno@collabora.com>
---
 drivers/media/cec/platform/Kconfig           |  11 +
 drivers/media/cec/platform/Makefile          |   1 +
 drivers/media/cec/platform/mediatek/Makefile |   2 +
 drivers/media/cec/platform/mediatek/cec-v2.c | 616 +++++++++++++++++++
 4 files changed, 630 insertions(+)
 create mode 100644 drivers/media/cec/platform/mediatek/Makefile
 create mode 100644 drivers/media/cec/platform/mediatek/cec-v2.c

diff --git a/drivers/media/cec/platform/Kconfig b/drivers/media/cec/platform/Kconfig
index e40413609f53..0fd98fd2d313 100644
--- a/drivers/media/cec/platform/Kconfig
+++ b/drivers/media/cec/platform/Kconfig
@@ -14,6 +14,17 @@ config CEC_CROS_EC
 	  The CEC bus is present in the HDMI connector and enables communication
 	  between compatible devices.
 
+config CEC_MEDIATEK_V2
+	tristate "MediaTek SoC HDMI CEC driver"
+	depends on ARCH_MEDIATEK || COMPILE_TEST
+	select CEC_CORE
+	select CEC_NOTIFIER
+	help
+	  This is a driver for the CEC Interface in MediaTek SoCs with
+	  the HDMIv2 IP. It uses the generic CEC framework interface.
+	  CEC bus is present in the HDMI connector and enables communication
+	  between compatible devices.
+
 config CEC_MESON_AO
 	tristate "Amlogic Meson AO CEC driver"
 	depends on ARCH_MESON || COMPILE_TEST
diff --git a/drivers/media/cec/platform/Makefile b/drivers/media/cec/platform/Makefile
index a51e98ab4958..1aa56e37a69b 100644
--- a/drivers/media/cec/platform/Makefile
+++ b/drivers/media/cec/platform/Makefile
@@ -6,6 +6,7 @@
 # Please keep it in alphabetic order
 obj-$(CONFIG_CEC_CROS_EC) += cros-ec/
 obj-$(CONFIG_CEC_GPIO) += cec-gpio/
+obj-y += mediatek/
 obj-y += meson/
 obj-$(CONFIG_CEC_SAMSUNG_S5P) += s5p/
 obj-$(CONFIG_CEC_SECO) += seco/
diff --git a/drivers/media/cec/platform/mediatek/Makefile b/drivers/media/cec/platform/mediatek/Makefile
new file mode 100644
index 000000000000..1bfeb5f0797e
--- /dev/null
+++ b/drivers/media/cec/platform/mediatek/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0-only
+obj-$(CONFIG_CEC_MEDIATEK_V2)	+= cec-v2.o
diff --git a/drivers/media/cec/platform/mediatek/cec-v2.c b/drivers/media/cec/platform/mediatek/cec-v2.c
new file mode 100644
index 000000000000..200cc714e447
--- /dev/null
+++ b/drivers/media/cec/platform/mediatek/cec-v2.c
@@ -0,0 +1,616 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * MediaTek HDMI v2 CEC Controller driver
+ *
+ * Copyright (c) 2022 MediaTek Inc.
+ * Copyright (c) 2024 Collabora Ltd.
+ *                    AngeloGioacchino Del Regno <angelogioacchino.delregno@collabora.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/units.h>
+
+#include <media/cec-notifier.h>
+#include <media/cec.h>
+#include <uapi/linux/cec.h>
+
+/* Device registers */
+#define CEC2_TR_CONFIG			0x0
+#define  CEC2_RX_RESET_B		BIT(0)
+#define  CEC2_TX_RESET_B		BIT(1)
+#define  CEC2_RX_ACK_ERROR_BYPASS	BIT(13)
+#define  CEC2_DEVICE_ADDR1		GENMASK(19, 16)
+#define  CEC2_DEVICE_ADDR2		GENMASK(23, 20)
+#define  CEC2_DEVICE_ADDR3		GENMASK(27, 24)
+#define  CEC2_BYPASS_DEVICE_ADDRESS	BIT(28)
+#define  CEC2_RX_CHK_DST		BIT(29)
+
+#define CEC2_CKGEN			0x4
+#define  CEC2_CLK_DIV			GENMASK(15, 0)
+#define  CEC2_CLK_PDN			BIT(16)
+#define  CEC2_CLK_SEL_DIV		BIT(17)
+#define  CEC2_CLK_27M_EN		BIT(18)
+
+#define CEC2_TX_TIMER_DATA_S		0x28
+#define  CEC2_TX_COMP_CNT		GENMASK(20, 16)
+
+#define CEC2_TX_ARB			0x2c
+#define CEC2_BCNT_NEW_INIT		GENMASK(3, 0)
+#define CEC2_BCNT_NEW_MSG		GENMASK(7, 4)
+#define CEC2_BCNT_REXMIT		GENMASK(11, 8)
+#define CEC2_DELAY_TX_RUNNING		BIT(12)
+#define CEC2_TX_REXMIT_POLLING_EN	BIT(13)
+#define CEC2_MAX_REXMIT_NUM_NACK	GENMASK(19, 16)
+#define CEC2_MAX_REXMIT_NUM_COL		GENMASK(23, 20)
+#define CEC2_MAX_REXMIT_NUM_ARB		GENMASK(29, 24)
+
+/* These two have the same layout except the meaning of the last bit */
+#define CEC2_TX_HEADER			0x30
+#define CEC2_RX_BUF_HEADER		0x4c
+#define  CEC2_HEADER_SRC		GENMASK(3, 0)
+#define  CEC2_HEADER_DST		GENMASK(7, 4)
+#define  CEC2_HEADER_EOM		BIT(8)
+#define  CEC2_DATA_CNT			GENMASK(15, 12)
+#define  CEC2_TX_READY			BIT(16)
+#define  CEC2_RX_BUF_RISC_ACK		BIT(16)
+
+#define CEC2_TX_DATA0			0x34
+
+#define CEC2_LINE_DET			0x48
+#define  CEC2_TIME_HIGH_LONG		GENMASK(15, 0)
+#define  CEC2_TIME_LOW_LONG		GENMASK(31, 16)
+
+#define CEC2_RX_DATA0			0x54
+
+#define CEC2_RX_STATUS			0x60
+#define  CEC2_CEC_INPUT			BIT(31)
+
+#define CEC2_TX_STATUS			0x64
+#define  CEC2_TX_STATUS_FSM_IDLE	BIT(0)
+#define  CEC2_TX_STATUS_FSM_INIT	BIT(1)
+#define  CEC2_TX_STATUS_FSM_FAIL	BIT(4)
+
+/* Interrupt registers (clr/en/sta) all share the same layout */
+#define CEC2_INT_CLR			0x74
+#define CEC2_INT_EN			0x78
+#define CEC2_INT_STA			0x7c
+#define  CEC2_LINE_LOW_LONG_INT		BIT(7)
+#define  CEC2_TX_DATA_FINISH_INT	BIT(8)
+#define  CEC2_TX_FAIL_SRC_INT		BIT(9)
+#define  CEC2_TX_FAIL_HEADER_INT	BIT(10)
+#define  CEC2_TX_FAIL_DATA_INT		BIT(11)
+#define  CEC2_TX_FAIL_REXMIT_INT	BIT(12)
+#define  CEC2_TX_FAIL_HDR_ACK_INT	BIT(13)
+#define  CEC2_TX_FAIL_DATA_ACK_INT	BIT(14)
+#define  CEC2_RX_BUF_READY_INT		BIT(16)
+#define  CEC2_RX_DATA_RCVD_INT		BIT(18)
+#define  CEC2_RX_BUF_FULL_INT		BIT(28)
+
+/* DIV_SEL = xtal_freq / (2 * target_freq) */
+#define CEC2_CKGEN_DIV_SEL_VAL	((27 * MEGA) / (2 * 100 * KILO))
+
+/* Interrupts that this driver enables and can handle */
+#define CEC2_IRQBITS_TX_FAIL	(CEC2_LINE_LOW_LONG_INT | CEC2_TX_FAIL_SRC_INT |	\
+				 CEC2_TX_FAIL_HEADER_INT | CEC2_TX_FAIL_DATA_INT | 	\
+				 CEC2_TX_FAIL_REXMIT_INT | CEC2_TX_FAIL_HDR_ACK_INT |	\
+				 CEC2_TX_FAIL_DATA_ACK_INT)
+
+#define CEC2_IRQBITS_TX		(CEC2_IRQBITS_TX_FAIL | CEC2_TX_DATA_FINISH_INT)
+
+#define CEC2_IRQBITS_RX		(CEC2_RX_BUF_READY_INT | CEC2_RX_DATA_RCVD_INT |	\
+				 CEC2_RX_BUF_FULL_INT)
+
+#define CEC2_IRQBITS_ENABLED	(CEC2_IRQBITS_TX | CEC2_IRQBITS_RX)
+
+#define CEC2_MAX_LOG_ADDR	2
+#define CEC2_TX_MAX_DATA_BLOCKS	16
+#define CEC_HEADER_BLOCK_SIZE	1
+
+struct mtk_cec {
+	struct device *dev;
+	struct cec_adapter *adap;
+	struct cec_notifier *notifier;
+	struct regmap *regs;
+	struct clk_bulk_data *clks;
+	int num_clks;
+	int irq;
+
+	u8 log_addrs;
+	bool do_rx;
+	bool do_tx;
+};
+
+static void mtk_cec_v2_enable_line_low_long_irq(struct mtk_cec *cec, bool enable)
+{
+	if (enable)
+		regmap_set_bits(cec->regs, CEC2_INT_EN, CEC2_LINE_LOW_LONG_INT);
+	else
+		regmap_clear_bits(cec->regs, CEC2_INT_EN, CEC2_LINE_LOW_LONG_INT);
+}
+
+static void mtk_cec_v2_reset_rx(struct mtk_cec *cec)
+{
+	regmap_clear_bits(cec->regs, CEC2_TR_CONFIG, CEC2_RX_RESET_B);
+	udelay(1);
+	regmap_set_bits(cec->regs, CEC2_TR_CONFIG, CEC2_RX_RESET_B);
+}
+
+static void mtk_cec_v2_reset_tx(struct mtk_cec *cec)
+{
+	regmap_clear_bits(cec->regs, CEC2_TR_CONFIG, CEC2_TX_RESET_B);
+	udelay(1);
+	regmap_set_bits(cec->regs, CEC2_TR_CONFIG, CEC2_TX_RESET_B);
+}
+
+static void mtk_cec_v2_hw_init(struct mtk_cec *cec)
+{
+	/* Enable internal 27MHz xtal output and divide to get 100KHz */
+	regmap_update_bits(cec->regs, CEC2_CKGEN,
+			   CEC2_CLK_DIV | CEC2_CLK_SEL_DIV | CEC2_CLK_27M_EN,
+			   FIELD_PREP(CEC2_CLK_SEL_DIV, 0) |
+			   FIELD_PREP(CEC2_CLK_DIV, CEC2_CKGEN_DIV_SEL_VAL));
+
+	/* Enable checking if destination address matches DEVICE_ADDR or broadcast msg */
+	regmap_set_bits(cec->regs, CEC2_TR_CONFIG, CEC2_RX_CHK_DST);
+	regmap_clear_bits(cec->regs, CEC2_TR_CONFIG, CEC2_BYPASS_DEVICE_ADDRESS);
+
+	/* Bypass error detection in ACK bit */
+	regmap_set_bits(cec->regs, CEC2_TR_CONFIG, CEC2_RX_ACK_ERROR_BYPASS);
+
+	/* TX Data Bit Sample timing: set delay to 4 cycles */
+	regmap_update_bits(cec->regs, CEC2_TX_TIMER_DATA_S, CEC2_TX_COMP_CNT,
+			   FIELD_PREP(CEC2_TX_COMP_CNT, 4));
+
+	/* Line Detection timing: HV time 40 cyc, LV time 170 cyc */
+	regmap_write(cec->regs, CEC2_LINE_DET,
+		     FIELD_PREP(CEC2_TIME_HIGH_LONG, 40) |
+		     FIELD_PREP(CEC2_TIME_LOW_LONG, 170));
+
+	/*
+	 * TX Arbitration setup:
+	 * - Retry only once for arbitration failure, collision and NACK
+	 * - Signal free time for retransmission: 3 cycles
+	 * - Signal free time for new message: 7 cycles
+	 * - Signal free time for new initiator: 5 cycles
+	 * - Signal tx_running after sending the source addr of the header
+	 *   block to block receiving messages on the RX HW side
+	 * - Enable retransmitting a message that only has header block
+	 *   when ACK is not as expected
+	 */
+	regmap_write(cec->regs, CEC2_TX_ARB,
+		     FIELD_PREP(CEC2_BCNT_NEW_INIT, 5) |
+		     FIELD_PREP(CEC2_BCNT_NEW_MSG, 7)  |
+		     FIELD_PREP(CEC2_BCNT_REXMIT, 3) |
+		     FIELD_PREP(CEC2_MAX_REXMIT_NUM_NACK, 1) |
+		     FIELD_PREP(CEC2_MAX_REXMIT_NUM_COL, 1) |
+		     FIELD_PREP(CEC2_MAX_REXMIT_NUM_ARB, 1) |
+		     CEC2_DELAY_TX_RUNNING | CEC2_TX_REXMIT_POLLING_EN);
+
+	mtk_cec_v2_reset_rx(cec);
+	mtk_cec_v2_reset_tx(cec);
+
+	/* Setup interrupts now: clear all and then enable */
+	regmap_write(cec->regs, CEC2_INT_CLR, GENMASK(31, 0));
+	regmap_write(cec->regs, CEC2_INT_CLR, 0);
+	regmap_write(cec->regs, CEC2_INT_EN, CEC2_IRQBITS_ENABLED);
+}
+
+static int mtk_cec_v2_adap_enable(struct cec_adapter *adap, bool enable)
+{
+	struct mtk_cec *cec = cec_get_drvdata(adap);
+	int ret;
+
+	if (enable) {
+		ret = clk_bulk_prepare_enable(cec->num_clks, cec->clks);
+		if (ret)
+			return ret;
+
+		regmap_set_bits(cec->regs, CEC2_CKGEN, CEC2_CLK_PDN);
+		mtk_cec_v2_hw_init(cec);
+	} else {
+		regmap_write(cec->regs, CEC2_INT_EN, 0);
+		regmap_clear_bits(cec->regs, CEC2_CKGEN, CEC2_CLK_PDN);
+		clk_bulk_disable_unprepare(cec->num_clks, cec->clks);
+	}
+
+	return 0;
+}
+
+static bool mtk_cec_is_new_log_addr(struct mtk_cec *cec, u8 logical_addr)
+{
+	u32 val;
+
+	regmap_read(cec->regs, CEC2_TR_CONFIG, &val);
+	if (logical_addr != FIELD_GET(CEC2_DEVICE_ADDR1, val) ||
+	    logical_addr != FIELD_GET(CEC2_DEVICE_ADDR1, val) ||
+	    logical_addr != FIELD_GET(CEC2_DEVICE_ADDR1, val))
+		return true;
+
+	return false;
+}
+
+static int mtk_cec_v2_adap_log_addr(struct cec_adapter *adap, u8 logical_addr)
+{
+	struct mtk_cec *cec = cec_get_drvdata(adap);
+	u32 mask, val;
+
+	/* LOG_ADDR_INVALID is a request to erase all programmed logical addresses */
+	if (logical_addr == CEC_LOG_ADDR_INVALID) {
+		cec->log_addrs = 0;
+		regmap_clear_bits(cec->regs, CEC2_TR_CONFIG,
+				  CEC2_DEVICE_ADDR1 | CEC2_DEVICE_ADDR2 | CEC2_DEVICE_ADDR3);
+		return 0;
+	}
+
+	/* Check if this address was already programmed earlier */
+	if (!mtk_cec_is_new_log_addr(cec, logical_addr))
+		return 0;
+
+	switch (cec->log_addrs) {
+	case 0:
+		mask = CEC2_DEVICE_ADDR1;
+		val = FIELD_PREP(CEC2_DEVICE_ADDR1, logical_addr);
+		break;
+	case 1:
+		mask = CEC2_DEVICE_ADDR2;
+		val = FIELD_PREP(CEC2_DEVICE_ADDR2, logical_addr);
+		break;
+	case 2:
+		mask = CEC2_DEVICE_ADDR3;
+		val = FIELD_PREP(CEC2_DEVICE_ADDR3, logical_addr);
+		break;
+	default:
+		/* Cannot add more than MAX_LOG_ADDR */
+		return -ENXIO;
+	};
+
+	regmap_update_bits(cec->regs, CEC2_TR_CONFIG, mask, val);
+	cec->log_addrs++;
+
+	return 0;
+}
+
+static int mtk_cec_v2_adap_transmit(struct cec_adapter *adap, u8 attempts,
+				    u32 signal_free_time, struct cec_msg *msg)
+{
+	struct mtk_cec *cec = cec_get_drvdata(adap);
+	u8 data_sz = msg->len - CEC_HEADER_BLOCK_SIZE;
+	bool fsm_is_idle, fsm_fail, tx_fail;
+	u32 val;
+
+	regmap_read(cec->regs, CEC2_INT_STA, &val);
+	tx_fail = val & CEC2_IRQBITS_TX_FAIL;
+
+	regmap_read(cec->regs, CEC2_TX_STATUS, &val);
+	fsm_fail = FIELD_GET(CEC2_TX_STATUS_FSM_FAIL, val);
+	fsm_is_idle = FIELD_GET(CEC2_TX_STATUS_FSM_IDLE, val);
+
+	if (fsm_fail || tx_fail) {
+		u32 rx_status;
+
+		mtk_cec_v2_reset_tx(cec);
+
+		/* If CEC line is high, the reset will cause a bus low error: reset it */
+		regmap_read(cec->regs, CEC2_RX_STATUS, &rx_status);
+		if (rx_status & CEC2_CEC_INPUT) {
+			regmap_set_bits(cec->regs, CEC2_INT_CLR, CEC2_LINE_LOW_LONG_INT);
+			regmap_clear_bits(cec->regs, CEC2_INT_CLR, CEC2_LINE_LOW_LONG_INT);
+		}
+
+		return -EIO;
+	}
+
+	if (data_sz > CEC_MAX_MSG_SIZE)
+		return -EINVAL;
+
+	/* The transmitter must be resetted if it's not in idle state */
+	if (!fsm_is_idle)
+		mtk_cec_v2_reset_tx(cec);
+
+	/* Format/Write the TX Header and Data to the transmitter HW */
+	val = FIELD_PREP(CEC2_HEADER_SRC, cec_msg_initiator(msg));
+	val |= FIELD_PREP(CEC2_HEADER_DST, cec_msg_destination(msg));
+
+	if (data_sz) {
+		/*
+		 * This field is only four bits long! Permissible values are:
+		 * - A number from 1 to 15, interpreted 1:1 as number of
+		 *   bytes to send; or
+		 * - Zero, interpreted as 16 bytes!
+		 */
+		val |= FIELD_PREP(CEC2_DATA_CNT, data_sz == 16 ? 0 : data_sz);
+
+		/* Program all the relevant TX_DATA registers in the transmitter */
+		regmap_bulk_write(cec->regs, CEC2_TX_DATA0, &msg->msg[1], data_sz);
+	} else {
+		/* Give a hint to the HW if sending only the header block */
+		val |= CEC2_HEADER_EOM;
+	}
+
+	/* Set the header */
+	regmap_write(cec->regs, CEC2_TX_HEADER, val);
+
+	/* Enable TX Failure and TX Done interrupts */
+	mtk_cec_v2_enable_line_low_long_irq(cec, true);
+	regmap_set_bits(cec->regs, CEC2_INT_EN, CEC2_TX_FAIL_REXMIT_INT);
+	regmap_set_bits(cec->regs, CEC2_INT_EN, CEC2_TX_DATA_FINISH_INT);
+
+	/* Setup is done: trigger transmission now! */
+	regmap_set_bits(cec->regs, CEC2_TX_HEADER, CEC2_TX_READY);
+
+	return 0;
+}
+
+static const struct cec_adap_ops mtk_cec_v2_ops = {
+	.adap_enable = mtk_cec_v2_adap_enable,
+	.adap_log_addr = mtk_cec_v2_adap_log_addr,
+	.adap_transmit = mtk_cec_v2_adap_transmit
+};
+
+static void mtk_cec_v2_clear_rx_irq(struct mtk_cec *cec)
+{
+	regmap_set_bits(cec->regs, CEC2_INT_CLR, CEC2_IRQBITS_RX);
+	regmap_clear_bits(cec->regs, CEC2_INT_CLR, CEC2_IRQBITS_RX);
+}
+
+static void mtk_cec_v2_clear_tx_irq(struct mtk_cec *cec)
+{
+	regmap_set_bits(cec->regs, CEC2_INT_CLR, CEC2_IRQBITS_TX);
+	regmap_clear_bits(cec->regs, CEC2_INT_CLR, CEC2_IRQBITS_TX);
+}
+
+static u8 mtk_cec_v2_get_rx_data_len(struct mtk_cec *cec)
+{
+	u32 val;
+
+	regmap_read(cec->regs, CEC2_RX_BUF_HEADER, &val);
+	if (val & CEC2_DATA_CNT)
+		return FIELD_GET(CEC2_DATA_CNT, val);
+
+	/* For header_eom and anything else, the data buffer count is zero */
+	return 0;
+}
+
+static void mtk_cec_v2_do_rx(struct mtk_cec *cec, u32 intr)
+{
+	struct cec_adapter *adap = cec->adap;
+	struct cec_msg msg = { };
+	u8 destination, initiator;
+	u32 val;
+
+	if (intr & CEC2_RX_BUF_FULL_INT) {
+		msg.rx_status = CEC_RX_STATUS_ABORTED;
+	} else if (intr & CEC2_RX_DATA_RCVD_INT || intr & CEC2_RX_BUF_READY_INT) {
+		/* Check if the buffer is actually ready, otherwise error out */
+		if (intr & CEC2_RX_BUF_READY_INT) {
+			msg.len = mtk_cec_v2_get_rx_data_len(cec);
+			if (!msg.len) {
+				msg.rx_status = CEC_RX_STATUS_OK;
+			} else if (msg.len > 15) {
+				dev_err(cec->dev, "Bad RX message length %u\n", msg.len);
+				msg.rx_status = CEC_RX_STATUS_ABORTED;
+			}
+		} else {
+			msg.rx_status = CEC_RX_STATUS_ABORTED;
+		}
+	} else {
+		dev_warn(cec->dev, "Unhandled interrupt! int_sta=0x%x\n", intr);
+		msg.rx_status = CEC_RX_STATUS_ABORTED;
+	}
+
+	if (msg.rx_status == CEC_RX_STATUS_OK) {
+		/* Read the received message header */
+		regmap_read(cec->regs, CEC2_RX_BUF_HEADER, &val);
+		initiator = FIELD_GET(CEC2_HEADER_SRC, val);
+		destination = FIELD_GET(CEC2_HEADER_DST, val);
+		msg.msg[0] = (initiator << 4) | destination;
+
+		/* Raed the received message data */
+		regmap_bulk_read(cec->regs, CEC2_RX_DATA0, &msg.msg[1], msg.len);
+
+		/* Give an ACK to the state machine to signal that we processed the message */
+		regmap_set_bits(cec->regs, CEC2_RX_BUF_HEADER, CEC2_RX_BUF_RISC_ACK);
+	}
+
+	cec_received_msg(adap, &msg);
+}
+
+static void mtk_cec_v2_do_tx(struct mtk_cec *cec, u32 intr)
+{
+	u8 cec_status, destination;
+	u32 hdr;
+
+	if (intr & CEC2_LINE_LOW_LONG_INT) {
+		mtk_cec_v2_enable_line_low_long_irq(cec, false);
+		cec_status = CEC_TX_STATUS_LOW_DRIVE;
+	} else if (intr & CEC2_TX_FAIL_REXMIT_INT) {
+		regmap_read(cec->regs, CEC2_TX_HEADER, &hdr);
+		destination = FIELD_GET(CEC2_HEADER_DST, hdr);
+
+		if (destination & CEC_LOG_ADDR_BROADCAST) {
+			if (intr & CEC2_TX_FAIL_HDR_ACK_INT || intr & CEC2_TX_FAIL_DATA_ACK_INT)
+				cec_status = CEC_TX_STATUS_OK;
+			else
+				cec_status = CEC_TX_STATUS_ERROR;
+		} else {
+			if (intr & CEC2_TX_FAIL_HDR_ACK_INT || intr & CEC2_TX_FAIL_DATA_ACK_INT)
+				cec_status = CEC_TX_STATUS_NACK;
+			else if (intr & CEC2_TX_FAIL_HEADER_INT || intr & CEC2_TX_FAIL_DATA_INT ||
+				 intr & CEC2_TX_FAIL_SRC_INT)
+				cec_status = CEC_TX_STATUS_ERROR;
+			else
+				cec_status = CEC_TX_STATUS_MAX_RETRIES;
+		}
+	} else if (intr & CEC2_TX_DATA_FINISH_INT) {
+		cec_status = CEC_TX_STATUS_OK;
+	} else {
+		dev_warn(cec->dev, "Unhandled interrupt! int_sta=0x%x\n", intr);
+		cec_status = CEC_TX_STATUS_ERROR;
+	}
+
+	mtk_cec_v2_clear_tx_irq(cec);
+
+	cec_transmit_attempt_done(cec->adap, cec_status);
+}
+
+static irqreturn_t mtk_cec_v2_isr_thread(int irq, void *arg)
+{
+	struct mtk_cec *cec = arg;
+	u32 intr;
+
+	regmap_read(cec->regs, CEC2_INT_STA, &intr);
+
+	if (cec->do_rx)
+		mtk_cec_v2_do_rx(cec, intr);
+
+	if (cec->do_tx)
+		mtk_cec_v2_do_tx(cec, intr);
+
+	/* Re-enable any interrupts that was disabled by the hardirq handler */
+	regmap_write(cec->regs, CEC2_INT_EN, CEC2_IRQBITS_ENABLED);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mtk_cec_v2_isr(int irq, void *arg)
+{
+	struct mtk_cec *cec = arg;
+	unsigned int irq_sta;
+
+	regmap_read(cec->regs, CEC2_INT_STA, &irq_sta);
+
+	/* Check if we have any RX interrupt */
+	if (irq_sta & CEC2_IRQBITS_RX) {
+		/* If the buffer is full or not ready clear interrupts and go out */
+		if (irq_sta & CEC2_RX_BUF_FULL_INT || !(irq_sta & CEC2_RX_BUF_READY_INT)) {
+			mtk_cec_v2_clear_rx_irq(cec);
+			return IRQ_HANDLED;
+		}
+
+		/* Disable RX interrupts but do not clear their state */
+		regmap_clear_bits(cec->regs, CEC2_INT_EN, CEC2_IRQBITS_RX);
+
+		cec->do_rx = true;
+	}
+
+	/* Check if we have any TX interrupt */
+	if (irq_sta & CEC2_IRQBITS_TX) {
+		/* Disable TX interrupts but do not clear their state */
+		regmap_clear_bits(cec->regs, CEC2_INT_EN, CEC2_IRQBITS_TX);
+
+		cec->do_tx = true;
+	}
+
+	return cec->do_rx || cec->do_tx ? IRQ_WAKE_THREAD : IRQ_HANDLED;
+}
+
+static int mtk_cec_v2_probe(struct platform_device *pdev)
+{
+	u32 cec_caps = CEC_CAP_DEFAULTS | CEC_CAP_CONNECTOR_INFO | CEC_CAP_PHYS_ADDR;
+	struct device *dev = &pdev->dev;
+	struct device *hdmi_dev;
+	struct mtk_cec *cec;
+	int ret;
+
+	hdmi_dev = cec_notifier_parse_hdmi_phandle(dev);
+	if (IS_ERR(hdmi_dev))
+		return PTR_ERR(hdmi_dev);
+
+	cec = devm_kzalloc(dev, sizeof(*cec), GFP_KERNEL);
+	if (!cec)
+		return -ENOMEM;
+
+	cec->dev = dev;
+	cec->regs = device_node_to_regmap(dev->of_node);
+	if (IS_ERR_OR_NULL(cec->regs))
+		return dev_err_probe(dev,
+				     IS_ERR(cec->regs) ? PTR_ERR(cec->regs) : -EINVAL,
+				     "Cannot get regmap\n");
+
+	cec->irq = platform_get_irq(pdev, 0);
+	if (cec->irq < 0)
+		return cec->irq;
+
+	cec->num_clks = devm_clk_bulk_get_all(dev, &cec->clks);
+	if (cec->num_clks < 0)
+		return dev_err_probe(dev, cec->num_clks, "Cannot get clocks\n");
+
+	/* Clean HW interrupts state before registering ISR */
+	ret = clk_bulk_prepare_enable(cec->num_clks, cec->clks);
+	if (ret)
+		return dev_err_probe(dev, ret, "Cannot enable clocks for setup\n");
+
+	regmap_set_bits(cec->regs, CEC2_CKGEN, CEC2_CLK_PDN);
+	regmap_write(cec->regs, CEC2_INT_EN, 0);
+	regmap_clear_bits(cec->regs, CEC2_CKGEN, CEC2_CLK_PDN);
+	clk_bulk_disable_unprepare(cec->num_clks, cec->clks);
+
+	platform_set_drvdata(pdev, cec);
+
+	ret = devm_request_threaded_irq(dev, cec->irq, mtk_cec_v2_isr,
+					mtk_cec_v2_isr_thread,
+					IRQ_TYPE_LEVEL_HIGH,
+					dev_name(dev), cec);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "Cannot request IRQ\n");
+
+	if (!IS_ENABLED(CONFIG_MEDIA_CEC_RC))
+		cec_caps &= ~CEC_CAP_RC;
+
+	cec->adap = cec_allocate_adapter(&mtk_cec_v2_ops, cec, "mediatek-cec-v2",
+					 cec_caps, CEC2_MAX_LOG_ADDR + 1);
+	if (IS_ERR(cec->adap))
+		return PTR_ERR(cec->adap);
+
+	cec->notifier = cec_notifier_cec_adap_register(hdmi_dev, NULL, cec->adap);
+	if (!cec->notifier)
+		return -ENOMEM;
+
+	ret = cec_register_adapter(cec->adap, dev);
+	if (ret) {
+		cec_notifier_cec_adap_unregister(cec->notifier, cec->adap);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void mtk_cec_v2_remove(struct platform_device *pdev)
+{
+	struct mtk_cec *cec = platform_get_drvdata(pdev);
+
+	cec_notifier_cec_adap_unregister(cec->notifier, cec->adap);
+	cec_unregister_adapter(cec->adap);
+}
+
+static const struct of_device_id mtk_drm_cec_v2_of_ids[] = {
+	{ .compatible = "mediatek,mt8195-cec" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, mtk_drm_cec_v2_of_ids);
+
+static struct platform_driver mtk_cec_v2_driver = {
+	.probe = mtk_cec_v2_probe,
+	.remove = mtk_cec_v2_remove,
+	.driver = {
+		.name = "mediatek-cec-v2",
+		.of_match_table = mtk_drm_cec_v2_of_ids,
+	},
+};
+module_platform_driver(mtk_cec_v2_driver);
+
+MODULE_AUTHOR("AngeloGioacchino Del Regno <angelogioacchino.delregno@collabora.com>");
+MODULE_DESCRIPTION("MediaTek HDMIv2 CEC Controller Driver");
+MODULE_LICENSE("GPL");
-- 
2.43.0

