From 19d0764d04e260ac39370bb2fd1dc630ff7fba39 Mon Sep 17 00:00:00 2001
From: Anton Bambura <jenneron@protonmail.com>
Date: Sat, 30 Mar 2024 11:38:32 +0200
Subject: [PATCH] panel-innolux-td4328: re-generate over odin m2 fdt

---
 drivers/gpu/drm/panel/panel-innolux-td4328.c | 329 ++++++++-----------
 1 file changed, 141 insertions(+), 188 deletions(-)

diff --git a/drivers/gpu/drm/panel/panel-innolux-td4328.c b/drivers/gpu/drm/panel/panel-innolux-td4328.c
index 51f47dc5c6c48..7c17f8c065120 100644
--- b/drivers/gpu/drm/panel/panel-innolux-td4328.c
+++ a/drivers/gpu/drm/panel/panel-innolux-td4328.c
@@ -1,7 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2022 Teguh Sobirin
+ * Author: Teguh Sobirin <teguh@sobir.in>
+ *
+ * This driver is for the DSI interface to Innolux panel
+ * Using the TD4328 display driver IC from Synaptics.
+ */
-// SPDX-License-Identifier: GPL-2.0-only
-// Copyright (c) 2024 FIXME
-// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
-//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
 
 #include <linux/delay.h>
 #include <linux/gpio/consumer.h>
@@ -9,168 +13,177 @@
 #include <linux/of.h>
 #include <linux/regulator/consumer.h>
 
+#include <video/display_timing.h>
+#include <video/mipi_display.h>
+
 #include <drm/drm_mipi_dsi.h>
 #include <drm/drm_modes.h>
 #include <drm/drm_panel.h>
 
+struct td4328 {
+	struct device *dev;
-struct innolux_td4328 {
 	struct drm_panel panel;
+	struct regulator *supply;
-	struct mipi_dsi_device *dsi;
-	struct regulator_bulk_data supplies[3];
 	struct gpio_desc *reset_gpio;
 	enum drm_panel_orientation orientation;
 	bool prepared;
 };
 
+static inline struct td4328 *panel_to_td4328(struct drm_panel *panel)
-static inline struct innolux_td4328 *to_innolux_td4328(struct drm_panel *panel)
 {
+	return container_of(panel, struct td4328, panel);
-	return container_of(panel, struct innolux_td4328, panel);
 }
 
+static int td4328_init_sequence(struct td4328 *ctx)
-static void innolux_td4328_reset(struct innolux_td4328 *ctx)
 {
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	struct device *dev = ctx->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(70);
-	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
-	usleep_range(10000, 11000);
-	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-	usleep_range(10000, 11000);
-	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
-	msleep(80);
-}
 
+	ret = mipi_dsi_dcs_set_column_address(dsi, 0, 1080 - 1);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set sleep column address: %d\n", ret);
+		return ret;
+	}
-static int innolux_td4328_on(struct innolux_td4328 *ctx)
-{
-	struct mipi_dsi_device *dsi = ctx->dsi;
-	struct device *dev = &dsi->dev;
-	int ret;
 
+	ret = mipi_dsi_dcs_set_page_address(dsi, 0, 1920 - 1);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set sleep page address: %d\n", ret);
+		return ret;
+	}
-	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
 
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
-	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x00);
-	mipi_dsi_generic_write_seq(dsi, 0xc2,
-				   0x01, 0xf7, 0x80, 0x04, 0x68, 0x08, 0x09,
-				   0x10, 0x00, 0x08, 0x30, 0x00, 0x00, 0x00,
-				   0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x00,
-				   0x00, 0x00);
-	mipi_dsi_generic_write_seq(dsi, 0xd6, 0x01);
-	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x03);
-	mipi_dsi_dcs_write_seq(dsi, 0x2a, 0x00, 0x00, 0x04, 0x37);
-	mipi_dsi_dcs_write_seq(dsi, 0x2b, 0x00, 0x00, 0x07, 0x7f);
-	mipi_dsi_dcs_write_seq(dsi, 0x35);
 
-	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
 	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
-		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
 		return ret;
 	}
-	msleep(150);
 
 	ret = mipi_dsi_dcs_set_display_on(dsi);
 	if (ret < 0) {
 		dev_err(dev, "Failed to set display on: %d\n", ret);
 		return ret;
 	}
-	msleep(50);
 
+	dev_dbg(dev, "Panel init sequence done\n");
 	return 0;
 }
 
+static int td4328_unprepare(struct drm_panel *panel)
-static int innolux_td4328_off(struct innolux_td4328 *ctx)
 {
+	struct td4328 *ctx = panel_to_td4328(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
-	struct mipi_dsi_device *dsi = ctx->dsi;
-	struct device *dev = &dsi->dev;
 	int ret;
 
+	if (!ctx->prepared)
+		return 0;
-	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
 
 	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0)
+		dev_err(ctx->dev, "failed to set display off: %d\n", ret);
-	if (ret < 0) {
-		dev_err(dev, "Failed to set display off: %d\n", ret);
-		return ret;
-	}
-	usleep_range(5000, 6000);
 
 	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
 	if (ret < 0) {
+		dev_err(ctx->dev, "failed to enter sleep mode: %d\n", ret);
-		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
 		return ret;
 	}
+
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
-	msleep(83);
 
 	return 0;
 }
 
+static int td4328_prepare(struct drm_panel *panel)
-static int innolux_td4328_prepare(struct drm_panel *panel)
 {
+	struct td4328 *ctx = panel_to_td4328(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
-	struct innolux_td4328 *ctx = to_innolux_td4328(panel);
-	struct device *dev = &ctx->dsi->dev;
 	int ret;
 
 	if (ctx->prepared)
 		return 0;
 
+	dev_dbg(ctx->dev, "Resetting the panel\n");
+	ret = regulator_enable(ctx->supply);
-	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
 	if (ret < 0) {
+		dev_err(ctx->dev, "Failed to enable supply: %d\n", ret);
-		dev_err(dev, "Failed to enable regulators: %d\n", ret);
 		return ret;
 	}
 
+	msleep(20);
-	innolux_td4328_reset(ctx);
 
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10, 20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+
+	msleep(20);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
-	ret = innolux_td4328_on(ctx);
 	if (ret < 0) {
+		dev_err(ctx->dev, "Failed to exit sleep mode: %d\n", ret);
+		goto disable_supply;
-		dev_err(dev, "Failed to initialize panel: %d\n", ret);
-		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
-		return ret;
 	}
 
+	msleep(250);
-	ctx->prepared = true;
-	return 0;
-}
 
+	ret = td4328_init_sequence(ctx);
+	if (ret < 0) {
+		dev_err(ctx->dev, "Panel init sequence failed: %d\n", ret);
+		goto disable_supply;
+	}
-static int innolux_td4328_unprepare(struct drm_panel *panel)
-{
-	struct innolux_td4328 *ctx = to_innolux_td4328(panel);
-	struct device *dev = &ctx->dsi->dev;
-	int ret;
 
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(ctx->dev, "Failed to set display on: %d\n", ret);
+		goto disable_supply;
+	}
-	if (!ctx->prepared)
-		return 0;
 
+	msleep(50);
-	ret = innolux_td4328_off(ctx);
-	if (ret < 0)
-		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
 
+	ctx->prepared = true;
-	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
 
-	ctx->prepared = false;
 	return 0;
+
+disable_supply:
+	regulator_disable(ctx->supply);
+	return ret;
 }
 
+static const struct drm_display_mode default_mode = {
+	.clock       = (1080 + 60 + 10 + 60) * (1920 + 20 + 8 + 20) * 60 / 1000,
+	.hdisplay    = 1080,
-static const struct drm_display_mode innolux_td4328_mode = {
-	.clock = (1080 + 60 + 10 + 60) * (1920 + 20 + 8 + 20) * 60 / 1000,
-	.hdisplay = 1080,
 	.hsync_start = 1080 + 60,
+	.hsync_end   = 1080 + 60 + 10,
+	.htotal      = 1080 + 60 + 10 + 60,
+	.vdisplay    = 1920,
-	.hsync_end = 1080 + 60 + 10,
-	.htotal = 1080 + 60 + 10 + 60,
-	.vdisplay = 1920,
 	.vsync_start = 1920 + 20,
+	.vsync_end   = 1920 + 20 + 8,
+	.vtotal      = 1920 + 20 + 8 + 20,
+	.width_mm    = 75,
+	.height_mm   = 132,
-	.vsync_end = 1920 + 20 + 8,
-	.vtotal = 1920 + 20 + 8 + 20,
-	.width_mm = 75,
-	.height_mm = 132,
 };
 
+static int td4328_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
-static int innolux_td4328_get_modes(struct drm_panel *panel,
-				    struct drm_connector *connector)
 {
+	struct td4328 *ctx = panel_to_td4328(panel);
-	struct innolux_td4328 *ctx = to_innolux_td4328(panel);
 	struct drm_display_mode *mode;
 
+	mode = drm_mode_duplicate(connector->dev, &default_mode);
+	if (!mode) {
+		dev_err(ctx->dev, "Failed to add mode %ux%u@%u\n",
+			default_mode.hdisplay, default_mode.vdisplay,
+			drm_mode_vrefresh(&default_mode));
-	mode = drm_mode_duplicate(connector->dev, &innolux_td4328_mode);
-	if (!mode)
 		return -ENOMEM;
+	}
 
 	drm_mode_set_name(mode);
 
@@ -178,52 +191,64 @@ static int td4328_get_modes(struct drm_panel *panel,
 	connector->display_info.width_mm = mode->width_mm;
 	connector->display_info.height_mm = mode->height_mm;
 	drm_mode_probed_add(connector, mode);
-
-	/*
-	 * TODO: Remove once all drm drivers call
-	 * drm_connector_set_orientation_from_panel()
-	 */
 	drm_connector_set_panel_orientation(connector, ctx->orientation);
 
 	return 1;
 }
 
+static const struct drm_panel_funcs td4328_funcs = {
+	.unprepare	= td4328_unprepare,
+	.prepare	= td4328_prepare,
+	.get_modes	= td4328_get_modes,
-static enum drm_panel_orientation innolux_td4328_get_orientation(struct drm_panel *panel)
-{
-	struct innolux_td4328 *ctx = to_innolux_td4328(panel);
-
-	return ctx->orientation;
-}
-
-static const struct drm_panel_funcs innolux_td4328_panel_funcs = {
-	.prepare = innolux_td4328_prepare,
-	.unprepare = innolux_td4328_unprepare,
-	.get_modes = innolux_td4328_get_modes,
-	.get_orientation = innolux_td4328_get_orientation,
 };
 
+static int td4328_probe(struct mipi_dsi_device *dsi)
-static int innolux_td4328_probe(struct mipi_dsi_device *dsi)
 {
 	struct device *dev = &dsi->dev;
+	struct td4328 *ctx;
-	struct innolux_td4328 *ctx;
 	int ret;
 
 	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
+	ctx->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio)) {
+		dev_err(dev, "cannot get reset gpio\n");
+		return PTR_ERR(ctx->reset_gpio);
+	}
+
+	ctx->supply = devm_regulator_get(dev, "vdd");
+	if (IS_ERR(ctx->supply)) {
+		ret = PTR_ERR(ctx->supply);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "Failed to request vdd regulator: %d\n", ret);
+		return ret;
+	}
+
+	ctx->supply = devm_regulator_get(dev, "vddio");
+	if (IS_ERR(ctx->supply)) {
+		ret = PTR_ERR(ctx->supply);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "Failed to request vddio regulator: %d\n", ret);
+		return ret;
+	}
+
+	ctx->supply = devm_regulator_get(dev, "vddpos");
+	if (IS_ERR(ctx->supply)) {
+		ret = PTR_ERR(ctx->supply);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "Failed to request vddpos regulator: %d\n", ret);
+		return ret;
+	}
-	ctx->supplies[0].supply = "vddio";
-	ctx->supplies[1].supply = "vddpos";
-	ctx->supplies[2].supply = "vddneg";
-	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
-				      ctx->supplies);
-	if (ret < 0)
-		return dev_err_probe(dev, ret, "Failed to get regulators\n");
 
+	ctx->supply = devm_regulator_get(dev, "vddneg");
+	if (IS_ERR(ctx->supply)) {
+		ret = PTR_ERR(ctx->supply);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "Failed to request vddneg regulator: %d\n", ret);
+		return ret;
+	}
-	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(ctx->reset_gpio))
-		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
-				     "Failed to get reset-gpios\n");
 
 	ret = of_drm_get_panel_orientation(dev->of_node, &ctx->orientation);
 	if (ret < 0) {
@@ -231,27 +256,30 @@ static int td4328_probe(struct mipi_dsi_device *dsi)
 		return ret;
 	}
 
-	ctx->dsi = dsi;
 	mipi_dsi_set_drvdata(dsi, ctx);
 
+	ctx->dev = dev;
+
 	dsi->lanes = 4;
 	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_LPM
+		| MIPI_DSI_MODE_VIDEO_HSE
+		| MIPI_DSI_CLOCK_NON_CONTINUOUS
+		| MIPI_DSI_MODE_VIDEO_BURST
+		| MIPI_DSI_MODE_NO_EOT_PACKET;
-	dsi->mode_flags = MIPI_DSI_MODE_NO_EOT_PACKET |
-			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
 
+	drm_panel_init(&ctx->panel, &dsi->dev, &td4328_funcs,
-	drm_panel_init(&ctx->panel, dev, &innolux_td4328_panel_funcs,
 		       DRM_MODE_CONNECTOR_DSI);
-	ctx->panel.prepare_prev_first = true;
 
 	ret = drm_panel_of_backlight(&ctx->panel);
 	if (ret)
+		return ret;
-		return dev_err_probe(dev, ret, "Failed to get backlight\n");
 
 	drm_panel_add(&ctx->panel);
 
 	ret = mipi_dsi_attach(dsi);
 	if (ret < 0) {
+		dev_err(dev, "mipi_dsi_attach failed: %d\n", ret);
-		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
 		drm_panel_remove(&ctx->panel);
 		return ret;
 	}
@@ -259,34 +287,53 @@ static int td4328_probe(struct mipi_dsi_device *dsi)
 	return 0;
 }
 
+static void td4328_shutdown(struct mipi_dsi_device *dsi)
-static void innolux_td4328_remove(struct mipi_dsi_device *dsi)
 {
+	struct td4328 *ctx = mipi_dsi_get_drvdata(dsi);
-	struct innolux_td4328 *ctx = mipi_dsi_get_drvdata(dsi);
 	int ret;
 
+	ret = drm_panel_unprepare(&ctx->panel);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to unprepare panel: %d\n", ret);
+
+	ret = drm_panel_disable(&ctx->panel);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to disable panel: %d\n", ret);
+}
+
+static int td4328_remove(struct mipi_dsi_device *dsi)
+{
+	struct td4328 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	td4328_shutdown(dsi);
+
 	ret = mipi_dsi_detach(dsi);
 	if (ret < 0)
 		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
 
 	drm_panel_remove(&ctx->panel);
+
+	return 0;
 }
 
+static const struct of_device_id td4328_of_match[] = {
+	{ .compatible = "innolux,td4328" },
-static const struct of_device_id innolux_td4328_of_match[] = {
-	{ .compatible = "innolux,td4328" }, // FIXME
 	{ /* sentinel */ }
 };
+MODULE_DEVICE_TABLE(of, td4328_of_match);
-MODULE_DEVICE_TABLE(of, innolux_td4328_of_match);
 
+static struct mipi_dsi_driver td4328_driver = {
-static struct mipi_dsi_driver innolux_td4328_driver = {
-	.probe = innolux_td4328_probe,
-	.remove = innolux_td4328_remove,
 	.driver = {
 		.name = "panel-innolux-td4328",
+		.of_match_table = td4328_of_match,
-		.of_match_table = innolux_td4328_of_match,
 	},
+	.probe	= td4328_probe,
+	.remove = td4328_remove,
+	.shutdown = td4328_shutdown,
 };
+module_mipi_dsi_driver(td4328_driver);
-module_mipi_dsi_driver(innolux_td4328_driver);
 
+MODULE_AUTHOR("Teguh Sobirin <teguh@sobir.in>");
+MODULE_DESCRIPTION("DRM driver for TD4328 cmd mode DSI Innolux panel");
+MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
-MODULE_DESCRIPTION("DRM driver for TD4328 cmd mode dsi panel without DSC");
-MODULE_LICENSE("GPL");
+- 
GitLab

--- a/drivers/gpu/drm/panel/panel-innolux-td4328.c	2025-11-24 23:21:51.192174560 +0100
+++ b/drivers/gpu/drm/panel/panel-innolux-td4328.c	2025-11-24 23:22:14.834806050 +0100
@@ -301,7 +301,7 @@
 		dev_err(&dsi->dev, "Failed to disable panel: %d\n", ret);
 }
 
-static int td4328_remove(struct mipi_dsi_device *dsi)
+static void td4328_remove(struct mipi_dsi_device *dsi)
 {
 	struct td4328 *ctx = mipi_dsi_get_drvdata(dsi);
 	int ret;
@@ -313,8 +313,6 @@
 		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
 
 	drm_panel_remove(&ctx->panel);
-
-	return 0;
 }
 
 static const struct of_device_id td4328_of_match[] = {
