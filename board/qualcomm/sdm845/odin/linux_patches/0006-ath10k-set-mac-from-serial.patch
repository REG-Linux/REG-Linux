diff -rupbN linux.orig/drivers/bluetooth/btqca.c linux/drivers/bluetooth/btqca.c
--- linux.orig/drivers/bluetooth/btqca.c	2022-06-13 16:08:51.000000000 +0000
+++ linux/drivers/bluetooth/btqca.c	2025-07-07 21:33:35.757583282 +0000
@@ -15,6 +15,79 @@
 
 #define VERSION "0.1"
 
+extern const char *qcom_serial_number;
+
+/* Define a static, predefined BD_ADDR structure */
+static const bdaddr_t static_bdaddr = {
+	.b = { 0x00, 0x03, 0x7F, 0x33, 0x22, 0x11 }
+};
+
+/**
+ * generate_bdaddr_from_serial - Generates a BD_ADDR using the serial number
+ * @hdev: HCI device
+ * @bdaddr: Pointer to bdaddr_t structure to populate
+ *
+ * This function sets the first 3 bytes to 00:03:7F and the last 3 bytes
+ * are derived from the last 6 characters of qcom_serial_number in reversed order.
+ *
+ * Returns 0 on success, negative error code on failure.
+ */
+static int generate_bdaddr_from_serial(struct hci_dev *hdev, bdaddr_t *bdaddr)
+{
+	size_t serial_len;
+	const char *serial = qcom_serial_number;
+	char last6[7] = {0}; // 6 characters + null terminator
+	int i;
+	int ret;
+
+	if (!serial) {
+		bt_dev_err(hdev, "qcom_serial_number is NULL");
+		return -EINVAL;
+	}
+
+	serial_len = strlen(serial);
+	if (serial_len < 6) {
+		bt_dev_err(hdev, "qcom_serial_number is too short: %zu characters", serial_len);
+		return -EINVAL;
+	}
+
+	// Extract the last 6 characters
+	strncpy(last6, serial + serial_len - 6, 6);
+
+	// Initialize the first 3 bytes
+	bdaddr->b[5] = 0x00;
+	bdaddr->b[4] = 0x03;
+	bdaddr->b[3] = 0x7F;
+
+	// Convert the last 6 characters into 3 bytes in reversed order
+	for (i = 0; i < 3; i++) {
+		char byte_str[3] = {0};
+		u8 byte_val;
+
+		byte_str[0] = last6[i * 2];
+		byte_str[1] = last6[i * 2 + 1];
+
+		if (!isxdigit(byte_str[0]) || !isxdigit(byte_str[1])) {
+			bt_dev_err(hdev, "Invalid hex characters in serial number: %c%c",
+				   byte_str[0], byte_str[1]);
+			return -EINVAL;
+		}
+
+		ret = kstrtou8(byte_str, 16, &byte_val);
+		if (ret < 0) {
+			bt_dev_err(hdev, "Failed to convert hex string to u8: %c%c",
+				   byte_str[0], byte_str[1]);
+			return ret;
+		}
+
+		bdaddr->b[2 - i] = byte_val; // Assign to bytes 2,1,0 (reversed order)
+	}
+
+	bt_dev_info(hdev, "BT MAC address set from serial: %pMR", bdaddr);
+
+	return 0;
+}
+
 int qca_read_soc_version(struct hci_dev *hdev, struct qca_btsoc_version *ver,
 			 enum qca_btsoc_type soc_type)
 {
@@ -863,6 +863,7 @@
 	u8 rom_ver = 0;
 	u32 soc_ver;
 	u16 boardid = 0;
+	bdaddr_t generated_bdaddr;
 
 	bt_dev_dbg(hdev, "QCA setup on UART");
 
@@ -692,6 +766,24 @@ int qca_uart_setup(struct hci_dev *hdev,
 			return err;
 	}
 
+	/* Generate BD_ADDR from qcom_serial_number */
+	err = generate_bdaddr_from_serial(hdev, &generated_bdaddr);
+	if (err) {
+		bt_dev_err(hdev, "Failed to generate BD_ADDR from serial number");
+		return err;
+	}
+
+	/* Set the generated BD_ADDR */
+	err = qca_set_bdaddr(hdev, &generated_bdaddr);
+	if (err) {
+		bt_dev_err(hdev, "Failed to set the generated BD_ADDR from serial number");
+		return err;
+	}
+
+	/* Update hdev->public_addr and hdev->bdaddr */
+	bacpy(&hdev->public_addr, &generated_bdaddr);
+	bacpy(&hdev->bdaddr, &generated_bdaddr);
+
 	bt_dev_info(hdev, "QCA setup on UART is completed");
 
 	return 0;
diff -rupbN linux.orig/drivers/net/wireless/ath/ath10k/mac.c linux/drivers/net/wireless/ath/ath10k/mac.c
--- linux.orig/drivers/net/wireless/ath/ath10k/mac.c	2022-06-13 16:08:51.000000000 +0000
+++ linux/drivers/net/wireless/ath/ath10k/mac.c	2025-07-07 21:33:17.565169120 +0000
@@ -92,6 +92,70 @@ static const struct cfg80211_sar_capa at
 	.freq_ranges = &ath10k_sar_freq_ranges[0],
 };
 
+extern const char *qcom_serial_number;
+
+struct macaddr_t {
+	u8 b[ETH_ALEN];
+};
+
+static const struct macaddr_t static_macaddr = {
+	.b = { 0x00, 0x03, 0x7F, 0x11, 0x22, 0x33 }
+};
+
+static void ath10k_reverse_mac(u8 *dst, const u8 *src)
+{
+	int i;
+	for (i = 0; i < ETH_ALEN; i++)
+		dst[i] = src[ETH_ALEN - 1 - i];
+}
+
+static int generate_macaddr_from_serial(struct ath10k *ar, struct macaddr_t *macaddr)
+{
+	const char *serial = qcom_serial_number;
+	char last6[7] = {0};
+	int i, ret;
+	size_t serial_len;
+
+	if (!serial) {
+		ath10k_warn(ar, "qcom_serial_number is NULL\n");
+		return -EINVAL;
+	}
+
+	serial_len = strlen(serial);
+	if (serial_len < 6) {
+		ath10k_warn(ar, "qcom_serial_number too short: %zu\n", serial_len);
+		return -EINVAL;
+	}
+
+	strncpy(last6, serial + serial_len - 6, 6);
+
+	macaddr->b[5] = 0x00;
+	macaddr->b[4] = 0x03;
+	macaddr->b[3] = 0x7F;
+
+	for (i = 0; i < 3; i++) {
+		char byte_str[3] = { last6[i * 2], last6[i * 2 + 1], 0 };
+		u8 byte_val;
+
+		if (!isxdigit(byte_str[0]) || !isxdigit(byte_str[1])) {
+			ath10k_warn(ar, "invalid hex in serial: %c%c\n", byte_str[0], byte_str[1]);
+			return -EINVAL;
+		}
+
+		ret = kstrtou8(byte_str, 16, &byte_val);
+		if (ret < 0) {
+			ath10k_warn(ar, "failed to convert hex to byte: %c%c\n", byte_str[0], byte_str[1]);
+			return ret;
+		}
+
+		macaddr->b[2 - i] = byte_val;
+	}
+
+	ath10k_dbg(ar, ATH10K_DBG_BOOT, "generated mac from serial: %pM\n", macaddr->b);
+	return 0;
+}
+
+
 #define ATH10K_MAC_FIRST_OFDM_RATE_IDX 4
 
 #define ath10k_a_rates (ath10k_rates + ATH10K_MAC_FIRST_OFDM_RATE_IDX)
@@ -9889,9 +9953,19 @@ int ath10k_mac_register(struct ath10k *a
 	int ret;
 
 	if (!is_valid_ether_addr(ar->mac_addr)) {
-		ath10k_warn(ar, "invalid MAC address; choosing random\n");
+		struct macaddr_t generated_macaddr;
+		int ret;
+
+		ret = generate_macaddr_from_serial(ar, &generated_macaddr);
+		if (ret) {
+			ath10k_warn(ar, "using random MAC (serial-based gen failed)\n");
 		eth_random_addr(ar->mac_addr);
+		} else {
+			ath10k_reverse_mac(ar->mac_addr, generated_macaddr.b);
+			ath10k_info(ar, "WIFI MAC address set from serial: %pM\n", ar->mac_addr);
 	}
+	}
+
 	SET_IEEE80211_PERM_ADDR(ar->hw, ar->mac_addr);
 
 	SET_IEEE80211_DEV(ar->hw, ar->dev);
diff -rupbN linux.orig/drivers/soc/qcom/socinfo.c linux/drivers/soc/qcom/socinfo.c
--- linux.orig/drivers/soc/qcom/socinfo.c	2022-06-13 16:08:51.000000000 +0000
+++ linux/drivers/soc/qcom/socinfo.c	2025-07-07 20:21:51.660754943 +0000
@@ -171,6 +171,10 @@
 };
 #endif /* CONFIG_DEBUG_FS */
 
+/* Global variable to hold the serial number */
+const char *qcom_serial_number;
+EXPORT_SYMBOL(qcom_serial_number);
+
 struct qcom_socinfo {
 	struct soc_device *soc_dev;
 	struct soc_device_attribute attr;
@@ -648,6 +652,9 @@ static int qcom_socinfo_probe(struct pla
 							"%u",
 							le32_to_cpu(info->serial_num));
 
+	/* Assign the serial number to the global variable */
+	qcom_serial_number = qs->attr.serial_number;
+
 	qs->soc_dev = soc_device_register(&qs->attr);
 	if (IS_ERR(qs->soc_dev))
 		return PTR_ERR(qs->soc_dev);
@@ -670,6 +677,9 @@ static int qcom_socinfo_remove(struct pl
 
 	socinfo_debugfs_exit(qs);
 
+	/* Clear the global serial number */
+	qcom_serial_number = NULL;
+
 	return 0;
 }
 
