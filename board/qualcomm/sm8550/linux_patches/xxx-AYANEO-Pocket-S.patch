From 34014c26e894c4228a918de04ac7100a3c08e5c2 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sat, 2 Nov 2024 06:40:28 +0000
Subject: [PATCH 01/39] arm64/configs: add a trimming config for qualcomm
 platforms

---
 arch/arm64/configs/q_defconfig | 1214 ++++++++++++++++++++++++++++++++
 1 file changed, 1214 insertions(+)
 create mode 100644 arch/arm64/configs/q_defconfig

diff --git a/arch/arm64/configs/q_defconfig b/arch/arm64/configs/q_defconfig
new file mode 100644
index 000000000000..987468c08e2c
--- /dev/null
+++ b/arch/arm64/configs/q_defconfig
@@ -0,0 +1,1214 @@
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_BPF_JIT=y
+CONFIG_PREEMPT=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_NUMA_BALANCING=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EXPERT=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PROFILING=y
+CONFIG_KEXEC=y
+CONFIG_KEXEC_FILE=y
+CONFIG_ARCH_QCOM=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_NUMA=y
+CONFIG_XEN=y
+CONFIG_COMPAT=y
+CONFIG_RANDOMIZE_BASE=y
+CONFIG_HIBERNATION=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_ENERGY_MODEL=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+CONFIG_CPUFREQ_DT=y
+CONFIG_ARM_SCPI_CPUFREQ=y
+CONFIG_ARM_QCOM_CPUFREQ_NVMEM=y
+CONFIG_ARM_QCOM_CPUFREQ_HW=y
+CONFIG_ARM_SCMI_CPUFREQ=y
+CONFIG_ACPI_CPPC_CPUFREQ=m
+CONFIG_ACPI=y
+CONFIG_ACPI_HOTPLUG_MEMORY=y
+CONFIG_ACPI_HMAT=y
+CONFIG_ACPI_APEI=y
+CONFIG_ACPI_APEI_GHES=y
+CONFIG_ACPI_APEI_PCIEAER=y
+CONFIG_ACPI_APEI_MEMORY_FAILURE=y
+CONFIG_ACPI_APEI_EINJ=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_MEMORY_HOTPLUG=y
+CONFIG_MEMORY_HOTREMOVE=y
+CONFIG_KSM=y
+CONFIG_MEMORY_FAILURE=y
+CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IPV6=m
+CONFIG_NETFILTER=y
+CONFIG_BRIDGE_NETFILTER=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_IP_VS=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_NET_DSA=m
+CONFIG_NET_DSA_TAG_OCELOT=m
+CONFIG_NET_DSA_TAG_OCELOT_8021Q=m
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_VLAN_8021Q_MVRP=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CBS=m
+CONFIG_NET_SCH_ETF=m
+CONFIG_NET_SCH_TAPRIO=m
+CONFIG_NET_SCH_MQPRIO=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_FLOWER=m
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_GACT=m
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_NET_ACT_GATE=m
+CONFIG_QRTR_SMD=m
+CONFIG_QRTR_TUN=m
+CONFIG_CAN=m
+CONFIG_BT=m
+CONFIG_BT_HIDP=m
+# CONFIG_BT_LE is not set
+CONFIG_BT_LEDS=y
+# CONFIG_BT_DEBUGFS is not set
+CONFIG_BT_HCIBTUSB=m
+CONFIG_BT_HCIBTUSB_MTK=y
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_HCIUART_BCM=y
+CONFIG_BT_HCIUART_QCA=y
+CONFIG_BT_HCIUART_MRVL=y
+CONFIG_BT_MRVL=m
+CONFIG_BT_MRVL_SDIO=m
+CONFIG_BT_QCOMSMD=m
+CONFIG_BT_NXPUART=m
+CONFIG_CFG80211=m
+CONFIG_MAC80211=m
+CONFIG_RFKILL=m
+CONFIG_RFKILL_INPUT=y
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+CONFIG_NFC=m
+CONFIG_NFC_NCI=m
+CONFIG_NFC_S3FWRN5_I2C=m
+CONFIG_PAGE_POOL_STATS=y
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+CONFIG_PCI_IOV=y
+CONFIG_PCI_PASID=y
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HOTPLUG_PCI_ACPI=y
+CONFIG_PCIE_ALTERA=y
+CONFIG_PCIE_ALTERA_MSI=y
+CONFIG_PCI_HOST_THUNDER_PEM=y
+CONFIG_PCI_HOST_THUNDER_ECAM=y
+CONFIG_PCI_HOST_GENERIC=y
+CONFIG_PCI_XGENE=y
+CONFIG_PCI_MESON=m
+CONFIG_PCI_HISI=y
+CONFIG_PCIE_KIRIN=y
+CONFIG_PCIE_QCOM=y
+CONFIG_PCI_ENDPOINT=y
+CONFIG_PCI_ENDPOINT_CONFIGFS=y
+CONFIG_PCI_EPF_TEST=m
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_VEXPRESS_CONFIG=y
+CONFIG_MHI_BUS_PCI_GENERIC=m
+CONFIG_ARM_SCMI_PROTOCOL=y
+CONFIG_IMX_SCMI_BBM_EXT=y
+CONFIG_IMX_SCMI_MISC_EXT=y
+CONFIG_ARM_SCPI_PROTOCOL=y
+CONFIG_GOOGLE_FIRMWARE=y
+CONFIG_GOOGLE_CBMEM=m
+CONFIG_GOOGLE_COREBOOT_TABLE=m
+CONFIG_EFI_CAPSULE_LOADER=y
+CONFIG_IMX_SCMI_MISC_DRV=y
+CONFIG_QCOM_TZMEM_MODE_SHMBRIDGE=y
+CONFIG_QCOM_QSEECOM=y
+CONFIG_QCOM_QSEECOM_UEFISECAPP=y
+CONFIG_GNSS=m
+CONFIG_GNSS_MTK_SERIAL=m
+CONFIG_MTD=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_DATAFLASH=y
+CONFIG_MTD_SST25L=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_MTD_NAND_DENALI_DT=y
+CONFIG_MTD_NAND_BRCMNAND=m
+CONFIG_MTD_NAND_BRCMNAND_BCMBCA=m
+CONFIG_MTD_NAND_BRCMNAND_BRCMSTB=m
+CONFIG_MTD_NAND_BRCMNAND_IPROC=m
+CONFIG_MTD_NAND_QCOM=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_UBI=m
+CONFIG_MTD_HYPERBUS=m
+CONFIG_OF_OVERLAY=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_NBD=m
+CONFIG_VIRTIO_BLK=y
+CONFIG_BLK_DEV_NVME=m
+CONFIG_QCOM_COINCELL=m
+CONFIG_QCOM_FASTRPC=m
+CONFIG_SRAM=y
+CONFIG_PCI_ENDPOINT_TEST=m
+CONFIG_EEPROM_AT24=m
+CONFIG_EEPROM_AT25=m
+CONFIG_UACCE=m
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_SCSI_HISI_SAS=y
+CONFIG_SCSI_HISI_SAS_PCI=y
+CONFIG_MEGARAID_SAS=y
+CONFIG_SCSI_MPT3SAS=m
+CONFIG_ATA=y
+CONFIG_SATA_AHCI=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_DWC=m
+CONFIG_AHCI_CEVA=y
+CONFIG_SATA_SIL24=y
+CONFIG_PATA_OF_PLATFORM=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_MIRROR=m
+CONFIG_DM_ZERO=m
+CONFIG_NETDEVICES=y
+CONFIG_MACVLAN=m
+CONFIG_MACVTAP=m
+CONFIG_TUN=y
+CONFIG_VETH=m
+CONFIG_VIRTIO_NET=y
+CONFIG_MHI_NET=m
+CONFIG_B53_SRAB_DRIVER=m
+CONFIG_NET_DSA_BCM_SF2=m
+CONFIG_AMD_XGBE=y
+CONFIG_ATL1C=m
+CONFIG_BCMGENET=m
+CONFIG_BNX2X=m
+CONFIG_SYSTEMPORT=m
+CONFIG_MACB=y
+CONFIG_THUNDER_NIC_PF=y
+CONFIG_HIX5HD2_GMAC=y
+CONFIG_HNS_DSAF=y
+CONFIG_HNS_ENET=y
+CONFIG_HNS3=y
+CONFIG_HNS3_HCLGE=y
+CONFIG_HNS3_ENET=y
+CONFIG_E1000=y
+CONFIG_E1000E=y
+CONFIG_IGB=y
+CONFIG_IGBVF=y
+CONFIG_MVMDIO=y
+CONFIG_SKY2=y
+CONFIG_MLX4_EN=m
+CONFIG_MLX5_CORE=m
+CONFIG_MLX5_CORE_EN=y
+CONFIG_QCOM_EMAC=m
+CONFIG_RMNET=m
+CONFIG_R8169=m
+CONFIG_SMC91X=y
+CONFIG_SMSC911X=y
+CONFIG_STMMAC_ETH=m
+CONFIG_QCOM_IPA=m
+CONFIG_AQUANTIA_PHY=y
+CONFIG_BROADCOM_PHY=m
+CONFIG_BCM54140_PHY=m
+CONFIG_MARVELL_PHY=m
+CONFIG_MARVELL_10G_PHY=y
+CONFIG_MARVELL_88Q2XXX_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_MICROSEMI_PHY=y
+CONFIG_AT803X_PHY=y
+CONFIG_REALTEK_PHY=y
+CONFIG_ROCKCHIP_PHY=y
+CONFIG_DP83867_PHY=y
+CONFIG_DP83869_PHY=m
+CONFIG_DP83TD510_PHY=y
+CONFIG_VITESSE_PHY=y
+CONFIG_CAN_FLEXCAN=m
+CONFIG_CAN_M_CAN=m
+CONFIG_CAN_M_CAN_PLATFORM=m
+CONFIG_CAN_MCP251XFD=m
+CONFIG_MDIO_BITBANG=y
+CONFIG_MDIO_BCM_UNIMAC=y
+CONFIG_MDIO_GPIO=y
+CONFIG_MDIO_BUS_MUX_MULTIPLEXER=y
+CONFIG_MDIO_BUS_MUX_MMIOREG=y
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_RTL8152=m
+CONFIG_USB_LAN78XX=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_DM9601=m
+CONFIG_USB_NET_SR9800=m
+CONFIG_USB_NET_SMSC75XX=m
+CONFIG_USB_NET_SMSC95XX=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_ATH10K=m
+CONFIG_ATH10K_PCI=m
+CONFIG_ATH10K_SDIO=m
+CONFIG_ATH10K_SNOC=m
+CONFIG_WCN36XX=m
+CONFIG_ATH11K=m
+CONFIG_ATH11K_AHB=m
+CONFIG_ATH11K_PCI=m
+CONFIG_ATH12K=m
+CONFIG_BRCMFMAC=m
+CONFIG_IWLWIFI=m
+CONFIG_IWLDVM=m
+CONFIG_IWLMVM=m
+CONFIG_MWIFIEX=m
+CONFIG_MWIFIEX_SDIO=m
+CONFIG_MWIFIEX_PCIE=m
+CONFIG_MT7921E=m
+CONFIG_RSI_91X=m
+CONFIG_WL18XX=m
+CONFIG_WLCORE_SDIO=m
+CONFIG_WWAN=m
+CONFIG_MHI_WWAN_CTRL=m
+CONFIG_MHI_WWAN_MBIM=m
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_ADC=m
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_GPIO_POLLED=m
+CONFIG_KEYBOARD_IMX_BBM_SCMI=y
+CONFIG_KEYBOARD_CROS_EC=y
+CONFIG_KEYBOARD_MTK_PMIC=m
+CONFIG_MOUSE_ELAN_I2C=m
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_SIDEWINDER=m
+CONFIG_JOYSTICK_XPAD=m
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_JOYSTICK_PSXPAD_SPI=m
+CONFIG_JOYSTICK_PSXPAD_SPI_FF=y
+CONFIG_JOYSTICK_PXRC=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GOODIX=m
+CONFIG_TOUCHSCREEN_GOODIX_BERLIN_I2C=m
+CONFIG_TOUCHSCREEN_GOODIX_BERLIN_SPI=m
+CONFIG_TOUCHSCREEN_S6SY761=m
+CONFIG_TOUCHSCREEN_EDT_FT5X06=m
+CONFIG_TOUCHSCREEN_STMFTS=m
+CONFIG_TOUCHSCREEN_HIMAX_HX83112B=m
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_PM8941_PWRKEY=y
+CONFIG_INPUT_PM8XXX_VIBRATOR=m
+# CONFIG_INPUT_XEN_KBDDEV_FRONTEND is not set
+CONFIG_RMI4_CORE=m
+CONFIG_RMI4_I2C=m
+CONFIG_RMI4_SPI=m
+CONFIG_RMI4_F03=y
+CONFIG_RMI4_F11=y
+CONFIG_RMI4_F12=y
+CONFIG_RMI4_F30=y
+CONFIG_RMI4_F34=y
+CONFIG_RMI4_F3A=y
+CONFIG_RMI4_F54=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_AMBAKMI=y
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=8
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_SERIAL_MSM=y
+CONFIG_SERIAL_MSM_CONSOLE=y
+CONFIG_SERIAL_QCOM_GENI=y
+CONFIG_SERIAL_QCOM_GENI_CONSOLE=y
+CONFIG_SERIAL_XILINX_PS_UART=y
+CONFIG_SERIAL_XILINX_PS_UART_CONSOLE=y
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+CONFIG_SERIAL_FSL_LINFLEXUART=y
+CONFIG_SERIAL_FSL_LINFLEXUART_CONSOLE=y
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_IPMI_HANDLER=m
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_VIRTIO=y
+CONFIG_HW_RANDOM_CN10K=y
+CONFIG_TCG_TPM=y
+CONFIG_TCG_TIS=m
+CONFIG_TCG_TIS_SPI=m
+CONFIG_TCG_TIS_SPI_CR50=y
+CONFIG_TCG_TIS_I2C_CR50=m
+CONFIG_TCG_TIS_I2C_INFINEON=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_CADENCE=m
+CONFIG_I2C_DESIGNWARE_CORE=y
+CONFIG_I2C_GPIO=m
+CONFIG_I2C_QCOM_CCI=m
+CONFIG_I2C_QCOM_GENI=m
+CONFIG_I2C_QUP=y
+CONFIG_I2C_RK3X=y
+CONFIG_I2C_CROS_EC_TUNNEL=y
+CONFIG_I2C_SLAVE=y
+CONFIG_SPI=y
+CONFIG_SPI_CADENCE_QUADSPI=y
+CONFIG_SPI_DESIGNWARE=m
+CONFIG_SPI_DW_DMA=y
+CONFIG_SPI_DW_MMIO=m
+CONFIG_SPI_PL022=y
+CONFIG_SPI_QCOM_QSPI=m
+CONFIG_SPI_QUP=y
+CONFIG_SPI_QCOM_GENI=m
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPMI=y
+CONFIG_PINCTRL_DA9062=m
+CONFIG_PINCTRL_MAX77620=y
+CONFIG_PINCTRL_RK805=m
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINCTRL_MSM=y
+CONFIG_PINCTRL_IPQ5018=y
+CONFIG_PINCTRL_IPQ5332=y
+CONFIG_PINCTRL_IPQ8074=y
+CONFIG_PINCTRL_IPQ6018=y
+CONFIG_PINCTRL_IPQ9574=y
+CONFIG_PINCTRL_MSM8916=y
+CONFIG_PINCTRL_MSM8953=y
+CONFIG_PINCTRL_MSM8976=y
+CONFIG_PINCTRL_MSM8994=y
+CONFIG_PINCTRL_MSM8996=y
+CONFIG_PINCTRL_MSM8998=y
+CONFIG_PINCTRL_QCM2290=y
+CONFIG_PINCTRL_QCS404=y
+CONFIG_PINCTRL_QDF2XXX=y
+CONFIG_PINCTRL_QDU1000=y
+CONFIG_PINCTRL_SA8775P=y
+CONFIG_PINCTRL_SC7180=y
+CONFIG_PINCTRL_SC7280=y
+CONFIG_PINCTRL_SC8180X=y
+CONFIG_PINCTRL_SC8280XP=y
+CONFIG_PINCTRL_SDM660=y
+CONFIG_PINCTRL_SDM670=y
+CONFIG_PINCTRL_SDM845=y
+CONFIG_PINCTRL_SDX75=y
+CONFIG_PINCTRL_SM4450=y
+CONFIG_PINCTRL_SM6115=y
+CONFIG_PINCTRL_SM6125=y
+CONFIG_PINCTRL_SM6350=y
+CONFIG_PINCTRL_SM6375=y
+CONFIG_PINCTRL_SM8150=y
+CONFIG_PINCTRL_SM8250=y
+CONFIG_PINCTRL_SM8350=y
+CONFIG_PINCTRL_SM8450=y
+CONFIG_PINCTRL_SM8550=y
+CONFIG_PINCTRL_SM8650=y
+CONFIG_PINCTRL_X1E80100=y
+CONFIG_PINCTRL_QCOM_SPMI_PMIC=y
+CONFIG_PINCTRL_LPASS_LPI=m
+CONFIG_PINCTRL_SC7280_LPASS_LPI=m
+CONFIG_PINCTRL_SM6115_LPASS_LPI=m
+CONFIG_PINCTRL_SM8250_LPASS_LPI=m
+CONFIG_PINCTRL_SM8350_LPASS_LPI=m
+CONFIG_PINCTRL_SM8450_LPASS_LPI=m
+CONFIG_PINCTRL_SC8280XP_LPASS_LPI=m
+CONFIG_PINCTRL_SM8550_LPASS_LPI=m
+CONFIG_PINCTRL_SM8650_LPASS_LPI=m
+CONFIG_GPIO_ALTERA=m
+CONFIG_GPIO_DWAPB=y
+CONFIG_GPIO_MB86S7X=y
+CONFIG_GPIO_PL061=y
+CONFIG_GPIO_SYSCON=y
+CONFIG_GPIO_WCD934X=m
+CONFIG_GPIO_XGENE=y
+CONFIG_GPIO_MAX732X=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCA953X_IRQ=y
+CONFIG_GPIO_ADP5585=m
+CONFIG_GPIO_BD9571MWV=m
+CONFIG_GPIO_MAX77620=y
+CONFIG_GPIO_AGGREGATOR=m
+CONFIG_POWER_RESET_MSM=y
+CONFIG_POWER_RESET_QCOM_PON=m
+CONFIG_POWER_RESET_XGENE=y
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_POWER_RESET_SYSCON_POWEROFF=y
+CONFIG_SYSCON_REBOOT_MODE=y
+CONFIG_NVMEM_REBOOT_MODE=m
+CONFIG_BATTERY_QCOM_BATTMGR=m
+CONFIG_BATTERY_SBS=m
+CONFIG_BATTERY_BQ27XXX=y
+CONFIG_BATTERY_MAX17042=m
+CONFIG_CHARGER_MT6360=m
+CONFIG_CHARGER_BQ25890=m
+CONFIG_CHARGER_BQ25980=m
+CONFIG_CHARGER_RK817=m
+CONFIG_SENSORS_ARM_SCMI=y
+CONFIG_SENSORS_ARM_SCPI=y
+CONFIG_SENSORS_GPIO_FAN=m
+CONFIG_SENSORS_JC42=m
+CONFIG_SENSORS_LM75=m
+CONFIG_SENSORS_LM90=m
+CONFIG_SENSORS_PWM_FAN=m
+CONFIG_SENSORS_INA2XX=m
+CONFIG_SENSORS_INA3221=m
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+CONFIG_GENERIC_ADC_THERMAL=m
+CONFIG_QCOM_TSENS=y
+CONFIG_QCOM_SPMI_ADC_TM5=m
+CONFIG_QCOM_SPMI_TEMP_ALARM=m
+CONFIG_QCOM_LMH=m
+CONFIG_WATCHDOG=y
+CONFIG_ARM_SP805_WATCHDOG=y
+CONFIG_ARM_SBSA_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_QCOM_WDT=m
+CONFIG_ARM_SMC_WATCHDOG=y
+CONFIG_PM8916_WATCHDOG=m
+CONFIG_MFD_ADP5585=m
+CONFIG_MFD_BD9571MWV=y
+CONFIG_MFD_AXP20X_I2C=y
+CONFIG_MFD_DA9062=m
+CONFIG_MFD_HI6421_PMIC=y
+CONFIG_MFD_MAX77620=y
+CONFIG_MFD_MT6360=y
+CONFIG_MFD_MT6397=y
+CONFIG_MFD_SPMI_PMIC=y
+CONFIG_MFD_RK8XX_I2C=y
+CONFIG_MFD_RK8XX_SPI=y
+CONFIG_MFD_SEC_CORE=y
+CONFIG_MFD_TI_LP873X=m
+CONFIG_MFD_TPS65219=y
+CONFIG_MFD_TPS6594_I2C=m
+CONFIG_MFD_WM8994=m
+CONFIG_MFD_ROHM_BD718XX=y
+CONFIG_MFD_WCD934X=m
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_ARM_SCMI=y
+CONFIG_REGULATOR_AXP20X=y
+CONFIG_REGULATOR_BD718XX=y
+CONFIG_REGULATOR_BD9571MWV=y
+CONFIG_REGULATOR_CROS_EC=y
+CONFIG_REGULATOR_DA9211=m
+CONFIG_REGULATOR_FAN53555=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_HI6421V530=y
+CONFIG_REGULATOR_LP873X=m
+CONFIG_REGULATOR_MAX77620=y
+CONFIG_REGULATOR_MAX8973=y
+CONFIG_REGULATOR_MAX20411=m
+CONFIG_REGULATOR_MP8859=y
+CONFIG_REGULATOR_MT6315=m
+CONFIG_REGULATOR_MT6357=y
+CONFIG_REGULATOR_MT6358=y
+CONFIG_REGULATOR_MT6359=y
+CONFIG_REGULATOR_MT6360=y
+CONFIG_REGULATOR_MT6397=y
+CONFIG_REGULATOR_PCA9450=y
+CONFIG_REGULATOR_PF8X00=y
+CONFIG_REGULATOR_PFUZE100=y
+CONFIG_REGULATOR_PWM=y
+CONFIG_REGULATOR_QCOM_REFGEN=m
+CONFIG_REGULATOR_QCOM_RPMH=y
+CONFIG_REGULATOR_QCOM_SMD_RPM=y
+CONFIG_REGULATOR_QCOM_SPMI=y
+CONFIG_REGULATOR_QCOM_USB_VBUS=m
+CONFIG_REGULATOR_RAA215300=y
+CONFIG_REGULATOR_RK808=y
+CONFIG_REGULATOR_S2MPS11=y
+CONFIG_REGULATOR_TPS65132=m
+CONFIG_REGULATOR_TPS65219=y
+CONFIG_REGULATOR_VCTRL=m
+CONFIG_RC_CORE=m
+CONFIG_RC_DECODERS=y
+CONFIG_RC_DEVICES=y
+CONFIG_IR_GPIO_CIR=m
+CONFIG_MEDIA_CEC_SUPPORT=y
+CONFIG_MEDIA_SUPPORT=m
+CONFIG_MEDIA_SUPPORT_FILTER=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_ANALOG_TV_SUPPORT=y
+CONFIG_MEDIA_DIGITAL_TV_SUPPORT=y
+CONFIG_MEDIA_SDR_SUPPORT=y
+CONFIG_MEDIA_PLATFORM_SUPPORT=y
+# CONFIG_DVB_NET is not set
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_SDR_PLATFORM_DRIVERS=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_CADENCE_CSI2RX=m
+CONFIG_VIDEO_QCOM_CAMSS=m
+CONFIG_VIDEO_QCOM_VENUS=m
+CONFIG_VIDEO_IMX219=m
+CONFIG_VIDEO_IMX412=m
+CONFIG_VIDEO_OV5640=m
+CONFIG_VIDEO_OV5645=m
+CONFIG_DRM=y
+CONFIG_DRM_DISPLAY_DP_AUX_CEC=y
+CONFIG_DRM_DISPLAY_DP_AUX_CHARDEV=y
+CONFIG_DRM_I2C_CH7006=m
+CONFIG_DRM_I2C_SIL164=m
+CONFIG_DRM_I2C_NXP_TDA998X=m
+CONFIG_DRM_MSM=m
+CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=m
+CONFIG_DRM_PANEL_EDP=m
+CONFIG_DRM_PANEL_SIMPLE=m
+CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA=m
+CONFIG_DRM_PANEL_VISIONOX_R66451=m
+CONFIG_DRM_PANEL_VISIONOX_RM69299=m
+CONFIG_DRM_PANEL_VISIONOX_VTDR6130=m
+CONFIG_DRM_DISPLAY_CONNECTOR=m
+CONFIG_DRM_LONTIUM_LT8912B=m
+CONFIG_DRM_LONTIUM_LT9611=m
+CONFIG_DRM_LONTIUM_LT9611UXC=m
+CONFIG_DRM_ITE_IT66121=m
+CONFIG_DRM_NWL_MIPI_DSI=m
+CONFIG_DRM_PARADE_PS8640=m
+CONFIG_DRM_SAMSUNG_DSIM=m
+CONFIG_DRM_SII902X=m
+CONFIG_DRM_SIMPLE_BRIDGE=m
+CONFIG_DRM_THINE_THC63LVD1024=m
+CONFIG_DRM_TOSHIBA_TC358767=m
+CONFIG_DRM_TOSHIBA_TC358768=m
+CONFIG_DRM_TI_TFP410=m
+CONFIG_DRM_TI_SN65DSI83=m
+CONFIG_DRM_TI_SN65DSI86=m
+CONFIG_DRM_ANALOGIX_ANX7625=m
+CONFIG_DRM_I2C_ADV7511=m
+CONFIG_DRM_I2C_ADV7511_AUDIO=y
+CONFIG_DRM_CDNS_MHDP8546=m
+CONFIG_DRM_ETNAVIV=m
+CONFIG_DRM_HISI_HIBMC=m
+CONFIG_DRM_HISI_KIRIN=m
+CONFIG_DRM_SIMPLEDRM=y
+CONFIG_FB=y
+CONFIG_FB_EFI=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=m
+CONFIG_BACKLIGHT_PWM=m
+CONFIG_BACKLIGHT_LP855X=m
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_ALOOP=m
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_FSL_ASRC=m
+CONFIG_SND_SOC_FSL_SAI=m
+CONFIG_SND_SOC_FSL_AUDMIX=m
+CONFIG_SND_SOC_FSL_SSI=m
+CONFIG_SND_SOC_FSL_SPDIF=m
+CONFIG_SND_SOC_FSL_ESAI=m
+CONFIG_SND_SOC_FSL_MICFIL=m
+CONFIG_SND_SOC_FSL_EASRC=m
+CONFIG_SND_SOC_IMX_AUDMUX=m
+CONFIG_SND_SOC_QCOM=m
+CONFIG_SND_SOC_APQ8016_SBC=m
+CONFIG_SND_SOC_MSM8996=m
+CONFIG_SND_SOC_SDM845=m
+CONFIG_SND_SOC_SM8250=m
+CONFIG_SND_SOC_SC8280XP=m
+CONFIG_SND_SOC_SC7180=m
+CONFIG_SND_SOC_SC7280=m
+CONFIG_SND_SOC_X1E80100=m
+CONFIG_SND_SOC_SOF_TOPLEVEL=y
+CONFIG_SND_SOC_SOF_OF=y
+CONFIG_SND_SOC_SOF_MTK_TOPLEVEL=y
+CONFIG_SND_SOC_AK4613=m
+CONFIG_SND_SOC_AK4619=m
+CONFIG_SND_SOC_BT_SCO=m
+CONFIG_SND_SOC_DA7213=m
+CONFIG_SND_SOC_DMIC=m
+CONFIG_SND_SOC_ES7134=m
+CONFIG_SND_SOC_ES7241=m
+CONFIG_SND_SOC_ES8316=m
+CONFIG_SND_SOC_GTM601=m
+CONFIG_SND_SOC_MAX98390=m
+CONFIG_SND_SOC_MSM8916_WCD_ANALOG=m
+CONFIG_SND_SOC_MSM8916_WCD_DIGITAL=m
+CONFIG_SND_SOC_PCM3168A_I2C=m
+CONFIG_SND_SOC_RK817=m
+CONFIG_SND_SOC_RT5640=m
+CONFIG_SND_SOC_RT5659=m
+CONFIG_SND_SOC_SGTL5000=m
+CONFIG_SND_SOC_SIMPLE_AMPLIFIER=m
+CONFIG_SND_SOC_SIMPLE_MUX=m
+CONFIG_SND_SOC_SPDIF=m
+CONFIG_SND_SOC_TAS2552=m
+CONFIG_SND_SOC_TAS571X=m
+CONFIG_SND_SOC_TLV320AIC31XX=m
+CONFIG_SND_SOC_TLV320AIC32X4_I2C=m
+CONFIG_SND_SOC_TLV320AIC3X_I2C=m
+CONFIG_SND_SOC_TS3A227E=m
+CONFIG_SND_SOC_WCD9335=m
+CONFIG_SND_SOC_WCD934X=m
+CONFIG_SND_SOC_WCD939X_SDW=m
+CONFIG_SND_SOC_WM8524=m
+CONFIG_SND_SOC_WM8904=m
+CONFIG_SND_SOC_WM8960=m
+CONFIG_SND_SOC_WM8962=m
+CONFIG_SND_SOC_WM8978=m
+CONFIG_SND_SOC_WSA881X=m
+CONFIG_SND_SOC_WSA883X=m
+CONFIG_SND_SOC_WSA884X=m
+CONFIG_SND_SOC_MT6357=m
+CONFIG_SND_SOC_MT6358=m
+CONFIG_SND_SOC_NAU8822=m
+CONFIG_SND_SOC_LPASS_WSA_MACRO=m
+CONFIG_SND_SOC_LPASS_VA_MACRO=m
+CONFIG_SND_SIMPLE_CARD=m
+CONFIG_SND_AUDIO_GRAPH_CARD=m
+CONFIG_SND_AUDIO_GRAPH_CARD2=m
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_ITE=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_REDRAGON=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=m
+CONFIG_I2C_HID_ACPI=m
+CONFIG_I2C_HID_OF=m
+CONFIG_I2C_HID_OF_ELAN=m
+CONFIG_USB_CONN_GPIO=y
+CONFIG_USB_OTG=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PCI_RENESAS=m
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_ACM=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_CDNS_SUPPORT=m
+CONFIG_USB_CDNS3=m
+CONFIG_USB_CDNS3_GADGET=y
+CONFIG_USB_CDNS3_HOST=y
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_DWC2=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_ISP1760=y
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_QCOM_EUD=m
+CONFIG_USB_HSIC_USB3503=y
+CONFIG_USB_ONBOARD_DEV=m
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_ULPI=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_SNP_UDC_PLAT=y
+CONFIG_USB_BDC_UDC=y
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_TYPEC=m
+CONFIG_TYPEC_TCPM=m
+CONFIG_TYPEC_TCPCI=m
+CONFIG_TYPEC_FUSB302=m
+CONFIG_TYPEC_QCOM_PMIC=m
+CONFIG_TYPEC_UCSI=m
+CONFIG_UCSI_CCG=m
+CONFIG_UCSI_PMIC_GLINK=m
+CONFIG_TYPEC_TPS6598X=m
+CONFIG_TYPEC_HD3SS3220=m
+CONFIG_TYPEC_MUX_FSA4480=m
+CONFIG_TYPEC_MUX_GPIO_SBU=m
+CONFIG_TYPEC_MUX_NB7VPQ904M=m
+CONFIG_TYPEC_MUX_WCD939X_USBSS=m
+CONFIG_TYPEC_DP_ALTMODE=m
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_ARMMMCI=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_ACPI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_ARASAN=y
+CONFIG_MMC_SDHCI_OF_DWCMSHC=y
+CONFIG_MMC_SDHCI_CADENCE=y
+CONFIG_MMC_SDHCI_F_SDH30=y
+CONFIG_MMC_SDHCI_MSM=y
+CONFIG_MMC_SPI=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_EXYNOS=y
+CONFIG_MMC_DW_HI3798CV200=y
+CONFIG_MMC_DW_K3=y
+CONFIG_MMC_MTK=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_SCSI_UFSHCD=y
+CONFIG_SCSI_UFS_BSG=y
+CONFIG_SCSI_UFSHCD_PLATFORM=y
+CONFIG_SCSI_UFS_CDNS_PLATFORM=m
+CONFIG_SCSI_UFS_QCOM=m
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_CLASS_MULTICOLOR=m
+CONFIG_LEDS_LM3692X=m
+CONFIG_LEDS_PCA9532=m
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_PWM=y
+CONFIG_LEDS_SYSCON=y
+CONFIG_LEDS_QCOM_LPG=m
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_DISK=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGER_PANIC=y
+CONFIG_EDAC=y
+CONFIG_EDAC_GHES=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_DS1307=m
+CONFIG_RTC_DRV_HYM8563=m
+CONFIG_RTC_DRV_MAX77686=y
+CONFIG_RTC_DRV_RK808=m
+CONFIG_RTC_DRV_ISL1208=m
+CONFIG_RTC_DRV_PCF85063=m
+CONFIG_RTC_DRV_PCF85363=m
+CONFIG_RTC_DRV_PCF8563=m
+CONFIG_RTC_DRV_M41T80=m
+CONFIG_RTC_DRV_BQ32K=m
+CONFIG_RTC_DRV_RX8581=m
+CONFIG_RTC_DRV_RV3028=m
+CONFIG_RTC_DRV_RV8803=m
+CONFIG_RTC_DRV_S5M=y
+CONFIG_RTC_DRV_DS3232=y
+CONFIG_RTC_DRV_PCF2127=m
+CONFIG_RTC_DRV_DA9063=m
+CONFIG_RTC_DRV_EFI=y
+CONFIG_RTC_DRV_CROS_EC=y
+CONFIG_RTC_DRV_PL031=y
+CONFIG_RTC_DRV_PM8XXX=m
+CONFIG_RTC_DRV_IMX_BBM_SCMI=y
+CONFIG_RTC_DRV_MT6397=m
+CONFIG_DMADEVICES=y
+CONFIG_BCM_SBA_RAID=m
+CONFIG_FSL_EDMA=y
+CONFIG_MV_XOR_V2=y
+CONFIG_PL330_DMA=y
+CONFIG_QCOM_BAM_DMA=y
+CONFIG_QCOM_GPI_DMA=m
+CONFIG_QCOM_HIDMA_MGMT=y
+CONFIG_QCOM_HIDMA=y
+CONFIG_DW_EDMA=m
+CONFIG_VFIO=y
+CONFIG_VFIO_PCI=y
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_MMIO=y
+CONFIG_XEN_GNTDEV=y
+CONFIG_XEN_GRANT_DEV_ALLOC=y
+CONFIG_STAGING=y
+CONFIG_STAGING_MEDIA=y
+CONFIG_VIDEO_MAX96712=m
+CONFIG_CHROME_PLATFORMS=y
+CONFIG_CROS_EC=y
+CONFIG_CROS_EC_I2C=y
+CONFIG_CROS_EC_RPMSG=m
+CONFIG_CROS_EC_SPI=y
+CONFIG_CROS_KBD_LED_BACKLIGHT=m
+CONFIG_CROS_EC_CHARDEV=m
+CONFIG_CLK_VEXPRESS_OSC=y
+CONFIG_COMMON_CLK_RK808=y
+CONFIG_COMMON_CLK_SCMI=y
+CONFIG_COMMON_CLK_SCPI=y
+CONFIG_COMMON_CLK_CS2000_CP=y
+CONFIG_COMMON_CLK_S2MPS11=y
+CONFIG_COMMON_CLK_XGENE=y
+CONFIG_COMMON_CLK_PWM=y
+CONFIG_COMMON_CLK_RS9_PCIE=y
+CONFIG_COMMON_CLK_VC3=y
+CONFIG_COMMON_CLK_VC5=y
+CONFIG_COMMON_CLK_BD718XX=m
+CONFIG_COMMON_CLK_QCOM=y
+CONFIG_CLK_X1E80100_CAMCC=m
+CONFIG_CLK_X1E80100_DISPCC=m
+CONFIG_CLK_X1E80100_GCC=y
+CONFIG_CLK_X1E80100_GPUCC=m
+CONFIG_CLK_X1E80100_TCSRCC=y
+CONFIG_QCOM_A53PLL=y
+CONFIG_QCOM_CLK_APCS_MSM8916=y
+CONFIG_QCOM_CLK_APCC_MSM8996=y
+CONFIG_QCOM_CLK_SMD_RPM=y
+CONFIG_QCOM_CLK_RPMH=y
+CONFIG_IPQ_APSS_6018=y
+CONFIG_IPQ_GCC_5018=y
+CONFIG_IPQ_GCC_5332=y
+CONFIG_IPQ_GCC_6018=y
+CONFIG_IPQ_GCC_8074=y
+CONFIG_IPQ_GCC_9574=y
+CONFIG_MSM_GCC_8916=y
+CONFIG_MSM_MMCC_8994=m
+CONFIG_MSM_GCC_8994=y
+CONFIG_MSM_GCC_8996=y
+CONFIG_MSM_MMCC_8996=m
+CONFIG_MSM_GCC_8998=y
+CONFIG_MSM_MMCC_8998=m
+CONFIG_QCM_GCC_2290=y
+CONFIG_QCM_DISPCC_2290=m
+CONFIG_QCS_GCC_404=y
+CONFIG_SC_CAMCC_8280XP=m
+CONFIG_SC_DISPCC_7280=m
+CONFIG_SC_DISPCC_8280XP=m
+CONFIG_SA_GCC_8775P=y
+CONFIG_SA_GPUCC_8775P=m
+CONFIG_SC_GCC_7180=y
+CONFIG_SC_GCC_7280=y
+CONFIG_SC_GCC_8180X=y
+CONFIG_SC_GCC_8280XP=y
+CONFIG_SC_GPUCC_7280=m
+CONFIG_SC_GPUCC_8280XP=m
+CONFIG_SC_LPASSCC_8280XP=m
+CONFIG_SDM_CAMCC_845=m
+CONFIG_QDU_GCC_1000=y
+CONFIG_SDM_GPUCC_845=y
+CONFIG_SDM_VIDEOCC_845=y
+CONFIG_SDM_DISPCC_845=y
+CONFIG_SDM_LPASSCC_845=m
+CONFIG_SDX_GCC_75=y
+CONFIG_SM_CAMCC_8250=m
+CONFIG_SM_DISPCC_6115=m
+CONFIG_SM_DISPCC_8250=y
+CONFIG_SM_DISPCC_8450=m
+CONFIG_SM_DISPCC_8550=m
+CONFIG_SM_GCC_4450=y
+CONFIG_SM_GCC_6115=y
+CONFIG_SM_GCC_8350=y
+CONFIG_SM_GCC_8450=y
+CONFIG_SM_GCC_8550=y
+CONFIG_SM_GCC_8650=y
+CONFIG_SM_GPUCC_6115=m
+CONFIG_SM_GPUCC_8150=y
+CONFIG_SM_GPUCC_8250=y
+CONFIG_SM_GPUCC_8350=m
+CONFIG_SM_GPUCC_8450=m
+CONFIG_SM_GPUCC_8550=m
+CONFIG_SM_GPUCC_8650=m
+CONFIG_SM_TCSRCC_8550=y
+CONFIG_SM_TCSRCC_8650=y
+CONFIG_SM_VIDEOCC_8250=y
+CONFIG_QCOM_HFPLL=y
+CONFIG_CLK_GFM_LPASS_SM8250=m
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_QCOM=y
+CONFIG_ARM_MHU=y
+CONFIG_PLATFORM_MHU=y
+CONFIG_QCOM_APCS_IPC=y
+CONFIG_QCOM_IPCC=y
+CONFIG_IOMMU_IO_PGTABLE_ARMV7S=y
+CONFIG_IOMMU_IO_PGTABLE_DART=y
+CONFIG_ARM_SMMU=y
+CONFIG_ARM_SMMU_V3=y
+CONFIG_QCOM_IOMMU=y
+CONFIG_REMOTEPROC=y
+CONFIG_QCOM_Q6V5_ADSP=m
+CONFIG_QCOM_Q6V5_MSS=m
+CONFIG_QCOM_Q6V5_PAS=m
+CONFIG_QCOM_SYSMON=m
+CONFIG_QCOM_WCNSS_PIL=m
+CONFIG_RPMSG_CHAR=m
+CONFIG_RPMSG_CTRL=m
+CONFIG_RPMSG_QCOM_GLINK_RPM=y
+CONFIG_RPMSG_QCOM_GLINK_SMEM=m
+CONFIG_RPMSG_QCOM_SMD=y
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_SOUNDWIRE=m
+CONFIG_SOUNDWIRE_QCOM=m
+CONFIG_FSL_RCPM=y
+CONFIG_QCOM_AOSS_QMP=y
+CONFIG_QCOM_COMMAND_DB=y
+CONFIG_QCOM_GENI_SE=y
+CONFIG_QCOM_LLCC=m
+CONFIG_QCOM_OCMEM=m
+CONFIG_QCOM_PMIC_GLINK=m
+CONFIG_QCOM_RMTFS_MEM=m
+CONFIG_QCOM_RPMH=y
+CONFIG_QCOM_SMEM=y
+CONFIG_QCOM_SMD_RPM=y
+CONFIG_QCOM_SMP2P=y
+CONFIG_QCOM_SMSM=y
+CONFIG_QCOM_SOCINFO=m
+CONFIG_QCOM_SPM=m
+CONFIG_QCOM_STATS=m
+CONFIG_QCOM_WCNSS_CTRL=m
+CONFIG_QCOM_APR=m
+CONFIG_QCOM_ICC_BWMON=m
+CONFIG_QCOM_PBS=m
+CONFIG_SOC_TI=y
+CONFIG_QCOM_CPR=y
+CONFIG_QCOM_RPMHPD=y
+CONFIG_QCOM_RPMPD=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+CONFIG_DEVFREQ_GOV_PASSIVE=m
+CONFIG_EXTCON_PTN5150=m
+CONFIG_EXTCON_USB_GPIO=y
+CONFIG_EXTCON_USBC_CROS_EC=y
+CONFIG_MEMORY=y
+CONFIG_IIO=y
+CONFIG_MAX9611=m
+CONFIG_QCOM_SPMI_VADC=m
+CONFIG_QCOM_SPMI_ADC5=m
+CONFIG_TI_ADS1015=m
+CONFIG_IIO_CROS_EC_SENSORS_CORE=m
+CONFIG_IIO_CROS_EC_SENSORS=m
+CONFIG_IIO_ST_LSM6DSX=m
+CONFIG_IIO_CROS_EC_LIGHT_PROX=m
+CONFIG_SENSORS_ISL29018=m
+CONFIG_VCNL4000=m
+CONFIG_IIO_ST_MAGN_3AXIS=m
+CONFIG_IIO_CROS_EC_BARO=m
+CONFIG_MPL3115=m
+CONFIG_PWM=y
+CONFIG_PWM_ADP5585=m
+CONFIG_PWM_CROS_EC=m
+CONFIG_QCOM_PDC=y
+CONFIG_QCOM_MPM=y
+CONFIG_RESET_GPIO=m
+CONFIG_RESET_QCOM_AOSS=y
+CONFIG_RESET_QCOM_PDC=m
+CONFIG_PHY_CAN_TRANSCEIVER=m
+CONFIG_PHY_CADENCE_TORRENT=m
+CONFIG_PHY_CADENCE_DPHY_RX=m
+CONFIG_PHY_CADENCE_SIERRA=m
+CONFIG_PHY_CADENCE_SALVO=m
+CONFIG_PHY_QCOM_EDP=m
+CONFIG_PHY_QCOM_PCIE2=m
+CONFIG_PHY_QCOM_QMP=m
+CONFIG_PHY_QCOM_QUSB2=m
+CONFIG_PHY_QCOM_SNPS_EUSB2=m
+CONFIG_PHY_QCOM_EUSB2_REPEATER=m
+CONFIG_PHY_QCOM_M31_USB=m
+CONFIG_PHY_QCOM_USB_HS=m
+CONFIG_PHY_QCOM_USB_SNPS_FEMTO_V2=m
+CONFIG_PHY_QCOM_USB_HS_28NM=m
+CONFIG_PHY_QCOM_USB_SS=m
+CONFIG_PHY_QCOM_SGMII_ETH=m
+CONFIG_PHY_SAMSUNG_USB2=y
+CONFIG_ARM_CCI_PMU=m
+CONFIG_ARM_CCN=m
+CONFIG_ARM_CMN=m
+CONFIG_ARM_SMMU_V3_PMU=m
+CONFIG_ARM_DSU_PMU=m
+CONFIG_QCOM_L2_PMU=y
+CONFIG_QCOM_L3_PMU=y
+CONFIG_ARM_SPE_PMU=m
+CONFIG_ARM_DMC620_PMU=m
+CONFIG_HISI_PMU=y
+CONFIG_ARM_CORESIGHT_PMU_ARCH_SYSTEM_PMU=m
+CONFIG_NVIDIA_CORESIGHT_PMU_ARCH_SYSTEM_PMU=m
+CONFIG_NVMEM_LAYOUT_SL28_VPD=m
+CONFIG_NVMEM_QCOM_QFPROM=y
+CONFIG_NVMEM_QCOM_SEC_QFPROM=m
+CONFIG_NVMEM_RMEM=m
+CONFIG_NVMEM_SPMI_SDAM=m
+CONFIG_FPGA=y
+CONFIG_FPGA_MGR_ALTERA_CVP=m
+CONFIG_FPGA_BRIDGE=m
+CONFIG_ALTERA_FREEZE_BRIDGE=m
+CONFIG_FPGA_REGION=m
+CONFIG_OF_FPGA_REGION=m
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_MUX_GPIO=m
+CONFIG_MUX_MMIO=y
+CONFIG_SLIM_QCOM_CTRL=m
+CONFIG_SLIM_QCOM_NGD_CTRL=m
+CONFIG_INTERCONNECT_QCOM=y
+CONFIG_INTERCONNECT_QCOM_MSM8916=m
+CONFIG_INTERCONNECT_QCOM_MSM8996=y
+CONFIG_INTERCONNECT_QCOM_OSM_L3=m
+CONFIG_INTERCONNECT_QCOM_QCM2290=y
+CONFIG_INTERCONNECT_QCOM_QCS404=m
+CONFIG_INTERCONNECT_QCOM_QDU1000=y
+CONFIG_INTERCONNECT_QCOM_SA8775P=y
+CONFIG_INTERCONNECT_QCOM_SC7180=y
+CONFIG_INTERCONNECT_QCOM_SC7280=y
+CONFIG_INTERCONNECT_QCOM_SC8180X=y
+CONFIG_INTERCONNECT_QCOM_SC8280XP=y
+CONFIG_INTERCONNECT_QCOM_SDM845=y
+CONFIG_INTERCONNECT_QCOM_SDX75=y
+CONFIG_INTERCONNECT_QCOM_SM6115=y
+CONFIG_INTERCONNECT_QCOM_SM8150=y
+CONFIG_INTERCONNECT_QCOM_SM8250=y
+CONFIG_INTERCONNECT_QCOM_SM8350=y
+CONFIG_INTERCONNECT_QCOM_SM8450=y
+CONFIG_INTERCONNECT_QCOM_SM8550=y
+CONFIG_INTERCONNECT_QCOM_SM8650=y
+CONFIG_INTERCONNECT_QCOM_X1E80100=y
+CONFIG_COUNTER=m
+CONFIG_HTE=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_BTRFS_FS=m
+CONFIG_BTRFS_FS_POSIX_ACL=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA=y
+CONFIG_AUTOFS_FS=y
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_OVERLAY_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_EFIVAR_FS=y
+CONFIG_UBIFS_FS=m
+CONFIG_SQUASHFS=y
+CONFIG_PSTORE_RAM=m
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+CONFIG_9P_FS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_SECURITY=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_ECHAINIV=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_USER_API_RNG=m
+CONFIG_CRYPTO_CHACHA20_NEON=m
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_SHA512_ARM64_CE=m
+CONFIG_CRYPTO_SHA3_ARM64=m
+CONFIG_CRYPTO_SM3_ARM64_CE=m
+CONFIG_CRYPTO_AES_ARM64_BS=m
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_CRCT10DIF_ARM64_CE=m
+CONFIG_CRYPTO_DEV_QCE=m
+CONFIG_CRYPTO_DEV_QCOM_RNG=m
+CONFIG_CRYPTO_DEV_CCREE=m
+CONFIG_CRYPTO_DEV_HISI_SEC2=m
+CONFIG_CRYPTO_DEV_HISI_ZIP=m
+CONFIG_CRYPTO_DEV_HISI_HPRE=m
+CONFIG_CRYPTO_DEV_HISI_TRNG=m
+CONFIG_CRYPTO_DEV_AMLOGIC_GXL=m
+CONFIG_INDIRECT_PIO=y
+CONFIG_CRC_CCITT=m
+CONFIG_DMA_RESTRICTED_POOL=y
+CONFIG_CMA_SIZE_MBYTES=32
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
+CONFIG_DEBUG_INFO_REDUCED=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_FTRACE is not set
+CONFIG_CORESIGHT=m
+CONFIG_CORESIGHT_LINK_AND_SINK_TMC=m
+CONFIG_CORESIGHT_CATU=m
+CONFIG_CORESIGHT_SINK_TPIU=m
+CONFIG_CORESIGHT_SINK_ETBV10=m
+CONFIG_CORESIGHT_STM=m
+CONFIG_CORESIGHT_CPU_DEBUG=m
+CONFIG_CORESIGHT_CTI=m
+CONFIG_MEMTEST=y
-- 
2.43.0


From 7559ba6584e80eded7fd4bd4d18dea6c779bc3ed Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sat, 2 Nov 2024 16:41:03 +0000
Subject: [PATCH 03/39] arm64/config: Trimming more unused modules in
 q_defconfig.

---
 arch/arm64/configs/q_defconfig | 162 ++++++++++-----------------------
 1 file changed, 48 insertions(+), 114 deletions(-)

diff --git a/arch/arm64/configs/q_defconfig b/arch/arm64/configs/q_defconfig
index 987468c08e2c..701ff3837f12 100644
--- a/arch/arm64/configs/q_defconfig
+++ b/arch/arm64/configs/q_defconfig
@@ -38,9 +38,10 @@ CONFIG_ARCH_QCOM=y
 CONFIG_SCHED_MC=y
 CONFIG_SCHED_SMT=y
 CONFIG_NUMA=y
-CONFIG_XEN=y
+CONFIG_PARAVIRT=y
 CONFIG_COMPAT=y
 CONFIG_RANDOMIZE_BASE=y
+# CONFIG_DMI is not set
 CONFIG_HIBERNATION=y
 CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
 CONFIG_ENERGY_MODEL=y
@@ -83,7 +84,7 @@ CONFIG_IP_MULTICAST=y
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
 CONFIG_IP_PNP_BOOTP=y
-CONFIG_IPV6=m
+CONFIG_IPV6_SIT=m
 CONFIG_NETFILTER=y
 CONFIG_BRIDGE_NETFILTER=m
 CONFIG_NF_CONNTRACK=m
@@ -129,7 +130,6 @@ CONFIG_NET_ACT_MIRRED=m
 CONFIG_NET_ACT_GATE=m
 CONFIG_QRTR_SMD=m
 CONFIG_QRTR_TUN=m
-CONFIG_CAN=m
 CONFIG_BT=m
 CONFIG_BT_HIDP=m
 # CONFIG_BT_LE is not set
@@ -154,13 +154,19 @@ CONFIG_NET_9P=y
 CONFIG_NET_9P_VIRTIO=y
 CONFIG_NFC=m
 CONFIG_NFC_NCI=m
-CONFIG_NFC_S3FWRN5_I2C=m
+CONFIG_NFC_NCI_SPI=m
+CONFIG_NFC_NCI_UART=m
+CONFIG_NFC_HCI=m
+CONFIG_NFC_SHDLC=y
+CONFIG_NFC_NXP_NCI=m
+CONFIG_NFC_NXP_NCI_I2C=m
 CONFIG_PAGE_POOL_STATS=y
 CONFIG_PCI=y
 CONFIG_PCIEPORTBUS=y
 CONFIG_PCIEAER=y
 CONFIG_PCI_IOV=y
 CONFIG_PCI_PASID=y
+# CONFIG_VGA_ARB is not set
 CONFIG_HOTPLUG_PCI=y
 CONFIG_HOTPLUG_PCI_ACPI=y
 CONFIG_PCIE_ALTERA=y
@@ -193,8 +199,6 @@ CONFIG_IMX_SCMI_MISC_DRV=y
 CONFIG_QCOM_TZMEM_MODE_SHMBRIDGE=y
 CONFIG_QCOM_QSEECOM=y
 CONFIG_QCOM_QSEECOM_UEFISECAPP=y
-CONFIG_GNSS=m
-CONFIG_GNSS_MTK_SERIAL=m
 CONFIG_MTD=y
 CONFIG_MTD_BLOCK=y
 CONFIG_MTD_CFI=y
@@ -202,6 +206,7 @@ CONFIG_MTD_CFI_ADV_OPTIONS=y
 CONFIG_MTD_CFI_INTELEXT=y
 CONFIG_MTD_CFI_AMDSTD=y
 CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_COMPLEX_MAPPINGS=y
 CONFIG_MTD_PHYSMAP=y
 CONFIG_MTD_PHYSMAP_OF=y
 CONFIG_MTD_DATAFLASH=y
@@ -214,8 +219,6 @@ CONFIG_MTD_NAND_BRCMNAND_BRCMSTB=m
 CONFIG_MTD_NAND_BRCMNAND_IPROC=m
 CONFIG_MTD_NAND_QCOM=y
 CONFIG_MTD_SPI_NOR=y
-CONFIG_MTD_UBI=m
-CONFIG_MTD_HYPERBUS=m
 CONFIG_OF_OVERLAY=y
 CONFIG_BLK_DEV_LOOP=y
 CONFIG_BLK_DEV_NBD=m
@@ -243,7 +246,6 @@ CONFIG_AHCI_CEVA=y
 CONFIG_SATA_SIL24=y
 CONFIG_PATA_OF_PLATFORM=y
 CONFIG_MD=y
-CONFIG_BLK_DEV_MD=m
 CONFIG_BLK_DEV_DM=m
 CONFIG_DM_MIRROR=m
 CONFIG_DM_ZERO=m
@@ -300,10 +302,6 @@ CONFIG_DP83867_PHY=y
 CONFIG_DP83869_PHY=m
 CONFIG_DP83TD510_PHY=y
 CONFIG_VITESSE_PHY=y
-CONFIG_CAN_FLEXCAN=m
-CONFIG_CAN_M_CAN=m
-CONFIG_CAN_M_CAN_PLATFORM=m
-CONFIG_CAN_MCP251XFD=m
 CONFIG_MDIO_BITBANG=y
 CONFIG_MDIO_BCM_UNIMAC=y
 CONFIG_MDIO_GPIO=y
@@ -320,6 +318,7 @@ CONFIG_USB_NET_SMSC75XX=m
 CONFIG_USB_NET_SMSC95XX=m
 CONFIG_USB_NET_PLUSB=m
 CONFIG_USB_NET_MCS7830=m
+# CONFIG_WLAN_VENDOR_ADMTEK is not set
 CONFIG_ATH10K=m
 CONFIG_ATH10K_PCI=m
 CONFIG_ATH10K_SDIO=m
@@ -329,17 +328,20 @@ CONFIG_ATH11K=m
 CONFIG_ATH11K_AHB=m
 CONFIG_ATH11K_PCI=m
 CONFIG_ATH12K=m
+# CONFIG_WLAN_VENDOR_ATMEL is not set
 CONFIG_BRCMFMAC=m
 CONFIG_IWLWIFI=m
 CONFIG_IWLDVM=m
 CONFIG_IWLMVM=m
-CONFIG_MWIFIEX=m
-CONFIG_MWIFIEX_SDIO=m
-CONFIG_MWIFIEX_PCIE=m
-CONFIG_MT7921E=m
-CONFIG_RSI_91X=m
-CONFIG_WL18XX=m
-CONFIG_WLCORE_SDIO=m
+# CONFIG_WLAN_VENDOR_INTERSIL is not set
+# CONFIG_WLAN_VENDOR_MARVELL is not set
+# CONFIG_WLAN_VENDOR_MEDIATEK is not set
+# CONFIG_WLAN_VENDOR_MICROCHIP is not set
+# CONFIG_WLAN_VENDOR_PURELIFI is not set
+# CONFIG_WLAN_VENDOR_RALINK is not set
+# CONFIG_WLAN_VENDOR_ST is not set
+# CONFIG_WLAN_VENDOR_TI is not set
+# CONFIG_WLAN_VENDOR_QUANTENNA is not set
 CONFIG_WWAN=m
 CONFIG_MHI_WWAN_CTRL=m
 CONFIG_MHI_WWAN_MBIM=m
@@ -350,7 +352,6 @@ CONFIG_KEYBOARD_GPIO=y
 CONFIG_KEYBOARD_GPIO_POLLED=m
 CONFIG_KEYBOARD_IMX_BBM_SCMI=y
 CONFIG_KEYBOARD_CROS_EC=y
-CONFIG_KEYBOARD_MTK_PMIC=m
 CONFIG_MOUSE_ELAN_I2C=m
 CONFIG_INPUT_JOYSTICK=y
 CONFIG_JOYSTICK_SIDEWINDER=m
@@ -371,7 +372,6 @@ CONFIG_TOUCHSCREEN_HIMAX_HX83112B=m
 CONFIG_INPUT_MISC=y
 CONFIG_INPUT_PM8941_PWRKEY=y
 CONFIG_INPUT_PM8XXX_VIBRATOR=m
-# CONFIG_INPUT_XEN_KBDDEV_FRONTEND is not set
 CONFIG_RMI4_CORE=m
 CONFIG_RMI4_I2C=m
 CONFIG_RMI4_SPI=m
@@ -441,10 +441,6 @@ CONFIG_SPI_QUP=y
 CONFIG_SPI_QCOM_GENI=m
 CONFIG_SPI_SPIDEV=m
 CONFIG_SPMI=y
-CONFIG_PINCTRL_DA9062=m
-CONFIG_PINCTRL_MAX77620=y
-CONFIG_PINCTRL_RK805=m
-CONFIG_PINCTRL_SINGLE=y
 CONFIG_PINCTRL_MSM=y
 CONFIG_PINCTRL_IPQ5018=y
 CONFIG_PINCTRL_IPQ5332=y
@@ -475,6 +471,7 @@ CONFIG_PINCTRL_SM6115=y
 CONFIG_PINCTRL_SM6125=y
 CONFIG_PINCTRL_SM6350=y
 CONFIG_PINCTRL_SM6375=y
+CONFIG_PINCTRL_SM7150=y
 CONFIG_PINCTRL_SM8150=y
 CONFIG_PINCTRL_SM8250=y
 CONFIG_PINCTRL_SM8350=y
@@ -485,6 +482,7 @@ CONFIG_PINCTRL_X1E80100=y
 CONFIG_PINCTRL_QCOM_SPMI_PMIC=y
 CONFIG_PINCTRL_LPASS_LPI=m
 CONFIG_PINCTRL_SC7280_LPASS_LPI=m
+CONFIG_PINCTRL_SM4250_LPASS_LPI=m
 CONFIG_PINCTRL_SM6115_LPASS_LPI=m
 CONFIG_PINCTRL_SM8250_LPASS_LPI=m
 CONFIG_PINCTRL_SM8350_LPASS_LPI=m
@@ -502,10 +500,9 @@ CONFIG_GPIO_XGENE=y
 CONFIG_GPIO_MAX732X=y
 CONFIG_GPIO_PCA953X=y
 CONFIG_GPIO_PCA953X_IRQ=y
-CONFIG_GPIO_ADP5585=m
-CONFIG_GPIO_BD9571MWV=m
-CONFIG_GPIO_MAX77620=y
 CONFIG_GPIO_AGGREGATOR=m
+CONFIG_W1=m
+CONFIG_W1_MASTER_GPIO=m
 CONFIG_POWER_RESET_MSM=y
 CONFIG_POWER_RESET_QCOM_PON=m
 CONFIG_POWER_RESET_XGENE=y
@@ -517,7 +514,6 @@ CONFIG_BATTERY_QCOM_BATTMGR=m
 CONFIG_BATTERY_SBS=m
 CONFIG_BATTERY_BQ27XXX=y
 CONFIG_BATTERY_MAX17042=m
-CONFIG_CHARGER_MT6360=m
 CONFIG_CHARGER_BQ25890=m
 CONFIG_CHARGER_BQ25980=m
 CONFIG_CHARGER_RK817=m
@@ -546,45 +542,26 @@ CONFIG_DW_WATCHDOG=y
 CONFIG_QCOM_WDT=m
 CONFIG_ARM_SMC_WATCHDOG=y
 CONFIG_PM8916_WATCHDOG=m
-CONFIG_MFD_ADP5585=m
-CONFIG_MFD_BD9571MWV=y
-CONFIG_MFD_AXP20X_I2C=y
-CONFIG_MFD_DA9062=m
-CONFIG_MFD_HI6421_PMIC=y
+CONFIG_MFD_CROS_EC_DEV=m
 CONFIG_MFD_MAX77620=y
-CONFIG_MFD_MT6360=y
-CONFIG_MFD_MT6397=y
+CONFIG_MFD_QCOM_RPM=m
 CONFIG_MFD_SPMI_PMIC=y
 CONFIG_MFD_RK8XX_I2C=y
 CONFIG_MFD_RK8XX_SPI=y
 CONFIG_MFD_SEC_CORE=y
-CONFIG_MFD_TI_LP873X=m
-CONFIG_MFD_TPS65219=y
-CONFIG_MFD_TPS6594_I2C=m
-CONFIG_MFD_WM8994=m
-CONFIG_MFD_ROHM_BD718XX=y
 CONFIG_MFD_WCD934X=m
+CONFIG_MFD_QCOM_PM8008=m
 CONFIG_REGULATOR_FIXED_VOLTAGE=y
 CONFIG_REGULATOR_ARM_SCMI=y
-CONFIG_REGULATOR_AXP20X=y
-CONFIG_REGULATOR_BD718XX=y
-CONFIG_REGULATOR_BD9571MWV=y
 CONFIG_REGULATOR_CROS_EC=y
 CONFIG_REGULATOR_DA9211=m
 CONFIG_REGULATOR_FAN53555=y
 CONFIG_REGULATOR_GPIO=y
-CONFIG_REGULATOR_HI6421V530=y
-CONFIG_REGULATOR_LP873X=m
 CONFIG_REGULATOR_MAX77620=y
 CONFIG_REGULATOR_MAX8973=y
 CONFIG_REGULATOR_MAX20411=m
 CONFIG_REGULATOR_MP8859=y
 CONFIG_REGULATOR_MT6315=m
-CONFIG_REGULATOR_MT6357=y
-CONFIG_REGULATOR_MT6358=y
-CONFIG_REGULATOR_MT6359=y
-CONFIG_REGULATOR_MT6360=y
-CONFIG_REGULATOR_MT6397=y
 CONFIG_REGULATOR_PCA9450=y
 CONFIG_REGULATOR_PF8X00=y
 CONFIG_REGULATOR_PFUZE100=y
@@ -598,12 +575,7 @@ CONFIG_REGULATOR_RAA215300=y
 CONFIG_REGULATOR_RK808=y
 CONFIG_REGULATOR_S2MPS11=y
 CONFIG_REGULATOR_TPS65132=m
-CONFIG_REGULATOR_TPS65219=y
 CONFIG_REGULATOR_VCTRL=m
-CONFIG_RC_CORE=m
-CONFIG_RC_DECODERS=y
-CONFIG_RC_DEVICES=y
-CONFIG_IR_GPIO_CIR=m
 CONFIG_MEDIA_CEC_SUPPORT=y
 CONFIG_MEDIA_SUPPORT=m
 CONFIG_MEDIA_SUPPORT_FILTER=y
@@ -667,14 +639,16 @@ CONFIG_FB=y
 CONFIG_FB_EFI=y
 CONFIG_FB_MODE_HELPERS=y
 CONFIG_BACKLIGHT_CLASS_DEVICE=m
+CONFIG_BACKLIGHT_KTZ8866=m
 CONFIG_BACKLIGHT_PWM=m
-CONFIG_BACKLIGHT_LP855X=m
+CONFIG_BACKLIGHT_QCOM_WLED=m
 CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_MONO is not set
 # CONFIG_LOGO_LINUX_VGA16 is not set
 CONFIG_SOUND=y
 CONFIG_SND=y
 CONFIG_SND_ALOOP=m
+# CONFIG_SND_PCI is not set
 CONFIG_SND_SOC=y
 CONFIG_SND_SOC_FSL_ASRC=m
 CONFIG_SND_SOC_FSL_SAI=m
@@ -686,6 +660,7 @@ CONFIG_SND_SOC_FSL_MICFIL=m
 CONFIG_SND_SOC_FSL_EASRC=m
 CONFIG_SND_SOC_IMX_AUDMUX=m
 CONFIG_SND_SOC_QCOM=m
+CONFIG_SND_SOC_STORM=m
 CONFIG_SND_SOC_APQ8016_SBC=m
 CONFIG_SND_SOC_MSM8996=m
 CONFIG_SND_SOC_SDM845=m
@@ -697,46 +672,22 @@ CONFIG_SND_SOC_X1E80100=m
 CONFIG_SND_SOC_SOF_TOPLEVEL=y
 CONFIG_SND_SOC_SOF_OF=y
 CONFIG_SND_SOC_SOF_MTK_TOPLEVEL=y
-CONFIG_SND_SOC_AK4613=m
-CONFIG_SND_SOC_AK4619=m
 CONFIG_SND_SOC_BT_SCO=m
-CONFIG_SND_SOC_DA7213=m
+CONFIG_SND_SOC_CS35L41_I2C=m
 CONFIG_SND_SOC_DMIC=m
-CONFIG_SND_SOC_ES7134=m
-CONFIG_SND_SOC_ES7241=m
-CONFIG_SND_SOC_ES8316=m
-CONFIG_SND_SOC_GTM601=m
 CONFIG_SND_SOC_MAX98390=m
 CONFIG_SND_SOC_MSM8916_WCD_ANALOG=m
 CONFIG_SND_SOC_MSM8916_WCD_DIGITAL=m
-CONFIG_SND_SOC_PCM3168A_I2C=m
-CONFIG_SND_SOC_RK817=m
-CONFIG_SND_SOC_RT5640=m
-CONFIG_SND_SOC_RT5659=m
-CONFIG_SND_SOC_SGTL5000=m
 CONFIG_SND_SOC_SIMPLE_AMPLIFIER=m
 CONFIG_SND_SOC_SIMPLE_MUX=m
-CONFIG_SND_SOC_SPDIF=m
-CONFIG_SND_SOC_TAS2552=m
-CONFIG_SND_SOC_TAS571X=m
-CONFIG_SND_SOC_TLV320AIC31XX=m
-CONFIG_SND_SOC_TLV320AIC32X4_I2C=m
-CONFIG_SND_SOC_TLV320AIC3X_I2C=m
-CONFIG_SND_SOC_TS3A227E=m
+CONFIG_SND_SOC_TAS2562=m
 CONFIG_SND_SOC_WCD9335=m
 CONFIG_SND_SOC_WCD934X=m
+CONFIG_SND_SOC_WCD937X_SDW=m
 CONFIG_SND_SOC_WCD939X_SDW=m
-CONFIG_SND_SOC_WM8524=m
-CONFIG_SND_SOC_WM8904=m
-CONFIG_SND_SOC_WM8960=m
-CONFIG_SND_SOC_WM8962=m
-CONFIG_SND_SOC_WM8978=m
 CONFIG_SND_SOC_WSA881X=m
 CONFIG_SND_SOC_WSA883X=m
 CONFIG_SND_SOC_WSA884X=m
-CONFIG_SND_SOC_MT6357=m
-CONFIG_SND_SOC_MT6358=m
-CONFIG_SND_SOC_NAU8822=m
 CONFIG_SND_SOC_LPASS_WSA_MACRO=m
 CONFIG_SND_SOC_LPASS_VA_MACRO=m
 CONFIG_SND_SIMPLE_CARD=m
@@ -759,6 +710,7 @@ CONFIG_HID_MULTITOUCH=m
 CONFIG_I2C_HID_ACPI=m
 CONFIG_I2C_HID_OF=m
 CONFIG_I2C_HID_OF_ELAN=m
+CONFIG_I2C_HID_OF_GOODIX=m
 CONFIG_USB_CONN_GPIO=y
 CONFIG_USB_OTG=y
 CONFIG_USB_XHCI_HCD=y
@@ -876,15 +828,12 @@ CONFIG_RTC_DRV_RV8803=m
 CONFIG_RTC_DRV_S5M=y
 CONFIG_RTC_DRV_DS3232=y
 CONFIG_RTC_DRV_PCF2127=m
-CONFIG_RTC_DRV_DA9063=m
 CONFIG_RTC_DRV_EFI=y
 CONFIG_RTC_DRV_CROS_EC=y
 CONFIG_RTC_DRV_PL031=y
 CONFIG_RTC_DRV_PM8XXX=m
 CONFIG_RTC_DRV_IMX_BBM_SCMI=y
-CONFIG_RTC_DRV_MT6397=m
 CONFIG_DMADEVICES=y
-CONFIG_BCM_SBA_RAID=m
 CONFIG_FSL_EDMA=y
 CONFIG_MV_XOR_V2=y
 CONFIG_PL330_DMA=y
@@ -895,21 +844,20 @@ CONFIG_QCOM_HIDMA=y
 CONFIG_DW_EDMA=m
 CONFIG_VFIO=y
 CONFIG_VFIO_PCI=y
+CONFIG_VIRT_DRIVERS=y
+CONFIG_ARM_PKVM_GUEST=y
 CONFIG_VIRTIO_PCI=y
 CONFIG_VIRTIO_BALLOON=y
 CONFIG_VIRTIO_MMIO=y
-CONFIG_XEN_GNTDEV=y
-CONFIG_XEN_GRANT_DEV_ALLOC=y
 CONFIG_STAGING=y
 CONFIG_STAGING_MEDIA=y
-CONFIG_VIDEO_MAX96712=m
 CONFIG_CHROME_PLATFORMS=y
 CONFIG_CROS_EC=y
 CONFIG_CROS_EC_I2C=y
 CONFIG_CROS_EC_RPMSG=m
 CONFIG_CROS_EC_SPI=y
 CONFIG_CROS_KBD_LED_BACKLIGHT=m
-CONFIG_CROS_EC_CHARDEV=m
+# CONFIG_ARM64_PLATFORM_DEVICES is not set
 CONFIG_CLK_VEXPRESS_OSC=y
 CONFIG_COMMON_CLK_RK808=y
 CONFIG_COMMON_CLK_SCMI=y
@@ -921,7 +869,6 @@ CONFIG_COMMON_CLK_PWM=y
 CONFIG_COMMON_CLK_RS9_PCIE=y
 CONFIG_COMMON_CLK_VC3=y
 CONFIG_COMMON_CLK_VC5=y
-CONFIG_COMMON_CLK_BD718XX=m
 CONFIG_COMMON_CLK_QCOM=y
 CONFIG_CLK_X1E80100_CAMCC=m
 CONFIG_CLK_X1E80100_DISPCC=m
@@ -993,9 +940,12 @@ CONFIG_QCOM_HFPLL=y
 CONFIG_CLK_GFM_LPASS_SM8250=m
 CONFIG_HWSPINLOCK=y
 CONFIG_HWSPINLOCK_QCOM=y
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
 CONFIG_ARM_MHU=y
 CONFIG_PLATFORM_MHU=y
 CONFIG_QCOM_APCS_IPC=y
+CONFIG_QCOM_CPUCP_MBOX=y
 CONFIG_QCOM_IPCC=y
 CONFIG_IOMMU_IO_PGTABLE_ARMV7S=y
 CONFIG_IOMMU_IO_PGTABLE_DART=y
@@ -1016,7 +966,6 @@ CONFIG_RPMSG_QCOM_SMD=y
 CONFIG_RPMSG_VIRTIO=y
 CONFIG_SOUNDWIRE=m
 CONFIG_SOUNDWIRE_QCOM=m
-CONFIG_FSL_RCPM=y
 CONFIG_QCOM_AOSS_QMP=y
 CONFIG_QCOM_COMMAND_DB=y
 CONFIG_QCOM_GENI_SE=y
@@ -1061,7 +1010,6 @@ CONFIG_IIO_ST_MAGN_3AXIS=m
 CONFIG_IIO_CROS_EC_BARO=m
 CONFIG_MPL3115=m
 CONFIG_PWM=y
-CONFIG_PWM_ADP5585=m
 CONFIG_PWM_CROS_EC=m
 CONFIG_QCOM_PDC=y
 CONFIG_QCOM_MPM=y
@@ -1103,14 +1051,8 @@ CONFIG_NVMEM_QCOM_QFPROM=y
 CONFIG_NVMEM_QCOM_SEC_QFPROM=m
 CONFIG_NVMEM_RMEM=m
 CONFIG_NVMEM_SPMI_SDAM=m
-CONFIG_FPGA=y
-CONFIG_FPGA_MGR_ALTERA_CVP=m
-CONFIG_FPGA_BRIDGE=m
-CONFIG_ALTERA_FREEZE_BRIDGE=m
-CONFIG_FPGA_REGION=m
-CONFIG_OF_FPGA_REGION=m
+CONFIG_STM=m
 CONFIG_TEE=y
-CONFIG_OPTEE=y
 CONFIG_MUX_GPIO=m
 CONFIG_MUX_MMIO=y
 CONFIG_SLIM_QCOM_CTRL=m
@@ -1142,8 +1084,6 @@ CONFIG_HTE=y
 CONFIG_EXT4_FS=y
 CONFIG_EXT4_FS_POSIX_ACL=y
 CONFIG_EXT4_FS_SECURITY=y
-CONFIG_BTRFS_FS=m
-CONFIG_BTRFS_FS_POSIX_ACL=y
 CONFIG_FANOTIFY=y
 CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
 CONFIG_QUOTA=y
@@ -1155,7 +1095,6 @@ CONFIG_VFAT_FS=y
 CONFIG_TMPFS_POSIX_ACL=y
 CONFIG_HUGETLBFS=y
 CONFIG_EFIVAR_FS=y
-CONFIG_UBIFS_FS=m
 CONFIG_SQUASHFS=y
 CONFIG_PSTORE_RAM=m
 CONFIG_NFS_FS=y
@@ -1171,6 +1110,10 @@ CONFIG_CRYPTO_USER=y
 CONFIG_CRYPTO_TEST=m
 CONFIG_CRYPTO_DES=m
 CONFIG_CRYPTO_ECHAINIV=y
+CONFIG_CRYPTO_BLAKE2B=m
+CONFIG_CRYPTO_XXHASH=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_ZSTD=m
 CONFIG_CRYPTO_ANSI_CPRNG=y
 CONFIG_CRYPTO_USER_API_RNG=m
 CONFIG_CRYPTO_CHACHA20_NEON=m
@@ -1192,7 +1135,6 @@ CONFIG_CRYPTO_DEV_HISI_HPRE=m
 CONFIG_CRYPTO_DEV_HISI_TRNG=m
 CONFIG_CRYPTO_DEV_AMLOGIC_GXL=m
 CONFIG_INDIRECT_PIO=y
-CONFIG_CRC_CCITT=m
 CONFIG_DMA_RESTRICTED_POOL=y
 CONFIG_CMA_SIZE_MBYTES=32
 CONFIG_PRINTK_TIME=y
@@ -1203,12 +1145,4 @@ CONFIG_DEBUG_FS=y
 CONFIG_DEBUG_MEMORY_INIT=y
 # CONFIG_SCHED_DEBUG is not set
 # CONFIG_FTRACE is not set
-CONFIG_CORESIGHT=m
-CONFIG_CORESIGHT_LINK_AND_SINK_TMC=m
-CONFIG_CORESIGHT_CATU=m
-CONFIG_CORESIGHT_SINK_TPIU=m
-CONFIG_CORESIGHT_SINK_ETBV10=m
-CONFIG_CORESIGHT_STM=m
-CONFIG_CORESIGHT_CPU_DEBUG=m
-CONFIG_CORESIGHT_CTI=m
 CONFIG_MEMTEST=y
-- 
2.43.0


From d0a8898e0807d0bc63b9bb4c873941f3c8fa7b34 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Tue, 19 Nov 2024 13:21:51 +0000
Subject: [PATCH 04/39] arm64/config/q_defconfig: Builtin qcom UFS driver and
 phy.

---
 arch/arm64/configs/q_defconfig | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/arch/arm64/configs/q_defconfig b/arch/arm64/configs/q_defconfig
index 701ff3837f12..7f77d77ae0fa 100644
--- a/arch/arm64/configs/q_defconfig
+++ b/arch/arm64/configs/q_defconfig
@@ -792,8 +792,7 @@ CONFIG_MMC_SDHCI_XENON=y
 CONFIG_SCSI_UFSHCD=y
 CONFIG_SCSI_UFS_BSG=y
 CONFIG_SCSI_UFSHCD_PLATFORM=y
-CONFIG_SCSI_UFS_CDNS_PLATFORM=m
-CONFIG_SCSI_UFS_QCOM=m
+CONFIG_SCSI_UFS_QCOM=y
 CONFIG_NEW_LEDS=y
 CONFIG_LEDS_CLASS=y
 CONFIG_LEDS_CLASS_MULTICOLOR=m
@@ -1023,7 +1022,10 @@ CONFIG_PHY_CADENCE_SIERRA=m
 CONFIG_PHY_CADENCE_SALVO=m
 CONFIG_PHY_QCOM_EDP=m
 CONFIG_PHY_QCOM_PCIE2=m
-CONFIG_PHY_QCOM_QMP=m
+CONFIG_PHY_QCOM_QMP=y
+CONFIG_PHY_QCOM_QMP_PCIE=m
+CONFIG_PHY_QCOM_QMP_PCIE_8996=m
+CONFIG_PHY_QCOM_QMP_USB=m
 CONFIG_PHY_QCOM_QUSB2=m
 CONFIG_PHY_QCOM_SNPS_EUSB2=m
 CONFIG_PHY_QCOM_EUSB2_REPEATER=m
-- 
2.43.0


From 4e0283c34666cdc2271ed9fffd74630b294e9e13 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Tue, 19 Nov 2024 13:22:44 +0000
Subject: [PATCH 05/39] arm64/dts/qcom: Copy pmx55 dtsi from arm dts folder.

---
 arch/arm64/boot/dts/qcom/pmx55.dtsi | 85 +++++++++++++++++++++++++++++
 1 file changed, 85 insertions(+)
 create mode 100644 arch/arm64/boot/dts/qcom/pmx55.dtsi

diff --git a/arch/arm64/boot/dts/qcom/pmx55.dtsi b/arch/arm64/boot/dts/qcom/pmx55.dtsi
new file mode 100644
index 000000000000..da0851173c69
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/pmx55.dtsi
@@ -0,0 +1,85 @@
+// SPDX-License-Identifier: BSD-3-Clause
+
+/*
+ * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, Linaro Limited
+ */
+
+#include <dt-bindings/iio/qcom,spmi-vadc.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/spmi/spmi.h>
+
+&spmi_bus {
+	pmic@8 {
+		compatible = "qcom,pmx55", "qcom,spmi-pmic";
+		reg = <0x8 SPMI_USID>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		pon@800 {
+			compatible = "qcom,pm8916-pon";
+			reg = <0x0800>;
+
+			status = "disabled";
+		};
+
+		pmx55_temp: temp-alarm@2400 {
+			compatible = "qcom,spmi-temp-alarm";
+			reg = <0x2400>;
+			interrupts = <0x8 0x24 0x0 IRQ_TYPE_EDGE_BOTH>;
+			io-channels = <&pmx55_adc ADC5_DIE_TEMP>;
+			io-channel-names = "thermal";
+			#thermal-sensor-cells = <0>;
+		};
+
+		pmx55_adc: adc@3100 {
+			compatible = "qcom,spmi-adc5";
+			reg = <0x3100>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#io-channel-cells = <1>;
+			interrupts = <0x8 0x31 0x0 IRQ_TYPE_EDGE_RISING>;
+
+			channel@0 {
+				reg = <ADC5_REF_GND>;
+				qcom,pre-scaling = <1 1>;
+				label = "ref_gnd";
+			};
+
+			channel@1 {
+				reg = <ADC5_1P25VREF>;
+				qcom,pre-scaling = <1 1>;
+				label = "vref_1p25";
+			};
+
+			channel@6 {
+				reg = <ADC5_DIE_TEMP>;
+				qcom,pre-scaling = <1 1>;
+				label = "die_temp";
+			};
+
+			channel@9 {
+				reg = <ADC5_CHG_TEMP>;
+				qcom,pre-scaling = <1 1>;
+				label = "chg_temp";
+			};
+		};
+
+		pmx55_gpios: gpio@c000 {
+			compatible = "qcom,pmx55-gpio", "qcom,spmi-gpio";
+			reg = <0xc000>;
+			gpio-controller;
+			gpio-ranges = <&pmx55_gpios 0 0 11>;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+	};
+
+	pmic@9 {
+		compatible = "qcom,pmx55", "qcom,spmi-pmic";
+		reg = <0x9 SPMI_USID>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+};
-- 
2.43.0


From 336f997af2b194d10bc076ef8eb180d7beb8d31a Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Tue, 19 Nov 2024 13:23:37 +0000
Subject: [PATCH 06/39] arm64/dts/qcom: Add pmk8002 dtsi.

---
 arch/arm64/boot/dts/qcom/pmk8002.dtsi | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)
 create mode 100644 arch/arm64/boot/dts/qcom/pmk8002.dtsi

diff --git a/arch/arm64/boot/dts/qcom/pmk8002.dtsi b/arch/arm64/boot/dts/qcom/pmk8002.dtsi
new file mode 100644
index 000000000000..da5569037d59
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/pmk8002.dtsi
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, Linaro Limited
+ */
+
+#include <dt-bindings/spmi/spmi.h>
+
+&spmi_bus {
+	pmic@6 {
+		compatible = "qcom,pmk8002", "qcom,spmi-pmic";
+		reg = <0x6 SPMI_USID>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+
+	pmic@7 {
+		compatible = "qcom,pmk8002", "qcom,spmi-pmic";
+		reg = <0x7 SPMI_USID>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+};
-- 
2.43.0


From 3c74e80d87c0c866e1603314bc9dfe57b702a4c5 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Tue, 19 Nov 2024 13:24:28 +0000
Subject: [PATCH 07/39] arm64/dts/qcom: Add LG V60 dts.

---
 arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts | 1028 +++++++++++++++++++
 1 file changed, 1028 insertions(+)
 create mode 100644 arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts

diff --git a/arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts b/arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts
new file mode 100644
index 000000000000..11a09c9b7351
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts
@@ -0,0 +1,1028 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/regulator/qcom,rpmh-regulator.h>
+#include <dt-bindings/sound/qcom,q6afe.h>
+#include <dt-bindings/sound/qcom,q6asm.h>
+#include <dt-bindings/gpio/gpio.h>
+#include "sm8250.dtsi"
+#include "pm8150.dtsi"
+#include "pm8150b.dtsi"
+#include "pm8150l.dtsi"
+// #include "pm8009.dtsi"
+#include "pmk8002.dtsi"
+#include "pmx55.dtsi"
+
+/ {
+	model = "LG Electronics V60";
+	compatible = "qcom,sm8250-mtp", "qcom,sm8250";
+	chassis-type = "handset";
+	qcom,msm-id = <0x164 0x20001>;
+	qcom,board-id = <0xc0008 0x0>;
+
+	aliases {
+		serial0 = &uart12;
+        display0 = &framebuffer;
+	};
+	
+	chosen {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		// stdout-path = "serial0:115200n8";
+		stdout-path = "display0";
+		bootargs = "panic=30 loglevel=7 pd_ignore_unused clk_ignore_unused console=ttyS0,115200 console=tty1 root=/dev/sda27 rw";
+
+		framebuffer: framebuffer@9c000000 {
+			compatible = "simple-framebuffer";
+			reg = <0x0 0x9c000000 0x0 0x1200000>;
+			width = <1080>;
+			height = <2460>;
+			stride = <(1080 * 4)>;
+			format = "a8r8g8b8";
+			/*
+			 * That's a lot of clocks, but it's necessary due
+			 * to unused clk cleanup & no panel driver yet..
+			 */
+			// clocks = <&dispcc DISP_CC_MDSS_AHB_CLK>,
+			// 	 <&gcc GCC_DISP_HF_AXI_CLK>,
+			// 	 <&gcc GCC_DISP_SF_AXI_CLK>,
+			// 	 <&dispcc DISP_CC_MDSS_VSYNC_CLK>,
+			// 	 <&dispcc DISP_CC_MDSS_MDP_CLK>,
+			// 	 <&dispcc DISP_CC_MDSS_BYTE0_CLK>,
+			// 	 <&dispcc DISP_CC_MDSS_BYTE0_INTF_CLK>,
+			// 	 <&dispcc DISP_CC_MDSS_PCLK0_CLK>,
+			// 	 <&dispcc DISP_CC_MDSS_ESC0_CLK>;
+			// power-domains = <&dispcc MDSS_GDSC>;
+		};
+	};
+
+	reserved-memory {
+		ramoops_region@b0000000 {
+			compatible = "removed-dma-pool";
+			no-map;
+			reg = <0x0 0xb0000000 0x0 0x300000>;
+		};
+
+		cont_splash_region@9c000000 {
+			reg = <0x0 0x9c000000 0x0 0x1200000>;
+			label = "cont_splash_region";
+			no-map;
+		};
+	};
+
+	wcd938x: audio-codec {
+		compatible = "qcom,wcd9380-codec";
+
+		reset-gpios = <&tlmm 32 GPIO_ACTIVE_LOW>;
+
+		vdd-buck-supply = <&vreg_s4a_1p8>;
+		vdd-rxtx-supply = <&vreg_s4a_1p8>;
+		vdd-io-supply = <&vreg_s4a_1p8>;
+		vdd-mic-bias-supply = <&vreg_bob>;
+
+		qcom,micbias1-microvolt = <1800000>;
+		qcom,micbias2-microvolt = <1800000>;
+		qcom,micbias3-microvolt = <1800000>;
+		qcom,micbias4-microvolt = <1800000>;
+		qcom,mbhc-buttons-vthreshold-microvolt = <75000 150000 237000 500000 500000 500000 500000 500000>;
+		qcom,mbhc-headset-vthreshold-microvolt = <1700000>;
+		qcom,mbhc-headphone-vthreshold-microvolt = <50000>;
+		qcom,rx-device = <&wcd_rx>;
+		qcom,tx-device = <&wcd_tx>;
+
+		#sound-dai-cells = <1>;
+	};
+
+	thermal-zones {
+		camera-thermal {
+			thermal-sensors = <&pm8150l_adc_tm 0>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+
+		conn-thermal {
+			thermal-sensors = <&pm8150b_adc_tm 0>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+
+		mmw-pa1-thermal {
+			thermal-sensors = <&pm8150_adc_tm 2>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+
+		mmw-pa2-thermal {
+			thermal-sensors = <&pm8150l_adc_tm 2>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+
+		skin-msm-thermal {
+			thermal-sensors = <&pm8150l_adc_tm 1>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+
+		skin-thermal {
+			thermal-sensors = <&pm8150_adc_tm 1>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+
+		xo-thermal {
+			thermal-sensors = <&pm8150_adc_tm 0>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+	};
+
+	vph_pwr: vph-pwr-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vph_pwr";
+		regulator-min-microvolt = <3700000>;
+		regulator-max-microvolt = <3700000>;
+	};
+
+	vreg_s4a_1p8: pm8150-s4 {
+		compatible = "regulator-fixed";
+		regulator-name = "vreg_s4a_1p8";
+
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+
+		regulator-always-on;
+		regulator-boot-on;
+
+		vin-supply = <&vph_pwr>;
+	};
+
+	vreg_s6c_0p88: smpc6-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vreg_s6c_0p88";
+
+		regulator-min-microvolt = <880000>;
+		regulator-max-microvolt = <880000>;
+		regulator-always-on;
+		vin-supply = <&vph_pwr>;
+	};
+};
+
+&adsp {
+	status = "okay";
+	firmware-name = "qcom/sm8250/lge/timelm/adsp.mbn";
+};
+
+&apps_rsc {
+	regulators-0 {
+		compatible = "qcom,pm8150-rpmh-regulators";
+		qcom,pmic-id = "a";
+
+		vdd-s1-supply = <&vph_pwr>;
+		vdd-s2-supply = <&vph_pwr>;
+		vdd-s3-supply = <&vph_pwr>;
+		vdd-s4-supply = <&vph_pwr>;
+		vdd-s5-supply = <&vph_pwr>;
+		vdd-s6-supply = <&vph_pwr>;
+		vdd-s7-supply = <&vph_pwr>;
+		vdd-s8-supply = <&vph_pwr>;
+		vdd-s9-supply = <&vph_pwr>;
+		vdd-s10-supply = <&vph_pwr>;
+		vdd-l1-l8-l11-supply = <&vreg_s6c_0p88>;
+		vdd-l2-l10-supply = <&vreg_bob>;
+		vdd-l3-l4-l5-l18-supply = <&vreg_s6a_0p95>;
+		vdd-l6-l9-supply = <&vreg_s8c_1p3>;
+		vdd-l7-l12-l14-l15-supply = <&vreg_s5a_1p9>;
+		vdd-l13-l16-l17-supply = <&vreg_bob>;
+
+		vreg_s5a_1p9: smps5 {
+			regulator-name = "vreg_s5a_1p9";
+			regulator-min-microvolt = <1904000>;
+			regulator-max-microvolt = <2000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_s6a_0p95: smps6 {
+			regulator-name = "vreg_s6a_0p95";
+			regulator-min-microvolt = <920000>;
+			regulator-max-microvolt = <1128000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l2a_3p1: ldo2 {
+			regulator-name = "vreg_l2a_3p1";
+			regulator-min-microvolt = <3072000>;
+			regulator-max-microvolt = <3072000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3a_0p9: ldo3 {
+			regulator-name = "vreg_l3a_0p9";
+			regulator-min-microvolt = <928000>;
+			regulator-max-microvolt = <932000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l5a_0p875: ldo5 {
+			regulator-name = "vreg_l5a_0p875";
+			regulator-min-microvolt = <880000>;
+			regulator-max-microvolt = <880000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l6a_1p2: ldo6 {
+			regulator-name = "vreg_l6a_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7a_1p7: ldo7 {
+			regulator-name = "vreg_l7a_1p7";
+			regulator-min-microvolt = <1704000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l9a_1p2: ldo9 {
+			regulator-name = "vreg_l9a_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l10a_1p8: ldo10 {
+			regulator-name = "vreg_l10a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l12a_1p8: ldo12 {
+			regulator-name = "vreg_l12a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l13a_ts_3p0: ldo13 {
+			regulator-name = "vreg_l13a_ts_3p0";
+			regulator-min-microvolt = <3008000>;
+			regulator-max-microvolt = <3008000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l14a_1p8: ldo14 {
+			regulator-name = "vreg_l14a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1880000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l15a_11ad_io_1p8: ldo15 {
+			regulator-name = "vreg_l15a_11ad_io_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l16a_2p7: ldo16 {
+			regulator-name = "vreg_l16a_2p7";
+			regulator-min-microvolt = <2704000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l17a_3p0: ldo17 {
+			regulator-name = "vreg_l17a_3p0";
+			regulator-min-microvolt = <2856000>;
+			regulator-max-microvolt = <3008000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l18a_0p9: ldo18 {
+			regulator-name = "vreg_l18a_0p9";
+			regulator-min-microvolt = <912000>;
+			regulator-max-microvolt = <912000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+
+	regulators-1 {
+		compatible = "qcom,pm8150l-rpmh-regulators";
+		qcom,pmic-id = "c";
+
+		vdd-s1-supply = <&vph_pwr>;
+		vdd-s2-supply = <&vph_pwr>;
+		vdd-s3-supply = <&vph_pwr>;
+		vdd-s4-supply = <&vph_pwr>;
+		vdd-s5-supply = <&vph_pwr>;
+		vdd-s6-supply = <&vph_pwr>;
+		vdd-s7-supply = <&vph_pwr>;
+		vdd-s8-supply = <&vph_pwr>;
+		vdd-l1-l8-supply = <&vreg_s4a_1p8>;
+		vdd-l2-l3-supply = <&vreg_s8c_1p3>;
+		vdd-l4-l5-l6-supply = <&vreg_bob>;
+		vdd-l7-l11-supply = <&vreg_bob>;
+		vdd-l9-l10-supply = <&vreg_bob>;
+		vdd-bob-supply = <&vph_pwr>;
+
+		vreg_bob: bob {
+			regulator-name = "vreg_bob";
+			regulator-min-microvolt = <3008000>;
+			regulator-max-microvolt = <4000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_AUTO>;
+		};
+
+		vreg_s8c_1p3: smps8 {
+			regulator-name = "vreg_s8c_1p3";
+			regulator-min-microvolt = <1352000>;
+			regulator-max-microvolt = <1352000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l1c_1p8: ldo1 {
+			regulator-name = "vreg_l1c_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l2c_1p2: ldo2 {
+			regulator-name = "vreg_l2c_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3c_0p92: ldo3 {
+			regulator-name = "vreg_l3c_0p92";
+			regulator-min-microvolt = <920000>;
+			regulator-max-microvolt = <920000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l4c_1p7: ldo4 {
+			regulator-name = "vreg_l4c_1p7";
+			regulator-min-microvolt = <1704000>;
+			regulator-max-microvolt = <2928000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l5c_1p8: ldo5 {
+			regulator-name = "vreg_l5c_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2928000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l6c_2p9: ldo6 {
+			regulator-name = "vreg_l6c_2p9";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7c_cam_vcm0_2p85: ldo7 {
+			regulator-name = "vreg_l7c_cam_vcm0_2p85";
+			regulator-min-microvolt = <2856000>;
+			regulator-max-microvolt = <3104000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l8c_1p8: ldo8 {
+			regulator-name = "vreg_l8c_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l9c_2p9: ldo9 {
+			regulator-name = "vreg_l9c_2p9";
+			regulator-min-microvolt = <2704000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l10c_3p0: ldo10 {
+			regulator-name = "vreg_l10c_3p0";
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l11c_3p3: ldo11 {
+			regulator-name = "vreg_l11c_3p3";
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3312000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+};
+
+&cdsp {
+	status = "okay";
+	firmware-name = "qcom/sm8250/lge/timelm/cdsp.mbn";
+};
+
+&gmu {
+	status = "disabled";
+};
+
+&gpu {
+	status = "disabled";
+
+	zap-shader {
+		memory-region = <&gpu_mem>;
+		firmware-name = "qcom/sm8250/lge/timelm/a650_zap.mbn";
+	};
+};
+
+&pcie0 {
+	status = "okay";
+};
+
+&pcie0_phy {
+	status = "okay";
+	vdda-phy-supply = <&vreg_l5a_0p875>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+};
+
+&pcie2 {
+	status = "okay";
+};
+
+&pcie2_phy {
+	status = "okay";
+	vdda-phy-supply = <&vreg_l5a_0p875>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+};
+
+&i2c1 {
+	status = "okay";
+	clock-frequency = <1000000>;
+	
+	pn547@28 {
+		compatible = "nxp,nxp-nci-i2c";
+		status = "okay";
+		reg = <0x28>;
+		interrupt-parent = <&tlmm>;
+		interrupts = <111 IRQ_TYPE_LEVEL_HIGH>;
+		enable-gpios = <&tlmm 6 GPIO_ACTIVE_HIGH>;
+		firmware-gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&i2c13 {
+	status = "okay";
+	sw42902@28 {
+		compatible = "lge,sw42902";
+		reg = <0x28>;
+		status = "okay";
+		interrupt-parent = <&tlmm>;
+		interrupts = <39 0x2008>; /* IRQF_ONESHOT|IRQF_TRIGGER_LOW */
+		irqflags = <2>; /* IRQF_TRIGGER_FALLING */
+
+		vdd-gpio = <&tlmm 68 0>;
+		vcl-gpio = <&tlmm 67 0>;
+		reset-gpio = <&tlmm 38 0>;
+		irq-gpio = <&tlmm 39 0x2008>; /* IRQF_ONESHOT|IRQF_TRIGGER_LOW */
+
+		/* caps */
+		max_x = <1080>;
+		max_y = <2460>;
+		max_pressure = <255>;
+		max_width_major = <2460>;
+		max_width_minor = <2460>;
+		max_orientation = <90>;
+		max_id = <10>;
+		hw_reset_delay = <90>;
+		sw_reset_delay = <10>;
+
+		/* role */
+		use_lpwg = <1>;
+		use_lpwg_test = <1>;
+		hide_coordinate = <1>;
+		use_activepen_status = <1>;
+		use_film_status = <1>;
+		use_dex_mode = <1>;
+
+		/* firmware */
+		fw_image = "touch/timelm/B3W68TIME_0_74.img",
+			   "touch/timelm/B3W68DS3_0_16.img";
+
+		/* asc */
+		use_asc = <0>;
+		low_delta_thres = <350>;
+		high_delta_thres = <600>;
+		max_delta_cnt = <2>;
+
+		/* Performance Test */
+		use_perf_test = <1>;
+		test_delay = <8>;
+		test_pressure = <50>;
+		test_width = <100>;
+		click_test_x = <180>;
+		click_test_y = <760>;
+		v_drag_test_x = <144>;
+		v_drag_test_start_y = <2003>;
+		v_drag_test_end_y = <1116>;
+		h_drag_test_start_x = <1163>;
+		h_drag_test_end_x = <276>;
+		h_drag_test_y = <2184>;
+	};
+};
+
+&i2c15 {
+	status = "okay";
+	tfa9878_l: tfa9878@34 {
+		compatible = "nxp,tfa9879";
+		reg = <0x34>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&tfa9878_reset_active>;
+		#sound-dai-cells = <0>;
+	};
+	
+	tfa9878_r: tfa9878@35 {
+		compatible = "nxp,tfa9879";
+		reg = <0x35>;
+		#sound-dai-cells = <0>;
+	};
+};
+
+&pm8150_adc {
+	channel@4c {
+		reg = <ADC5_XO_THERM_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "xo_therm";
+	};
+
+	channel@4d {
+		reg = <ADC5_AMUX_THM1_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "skin_therm";
+	};
+
+	channel@4e {
+		reg = <ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "pa_therm1";
+	};
+};
+
+&pm8150_adc_tm {
+	status = "okay";
+
+	xo-therm@0 {
+		reg = <0>;
+		io-channels = <&pm8150_adc ADC5_XO_THERM_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+
+	skin-therm@1 {
+		reg = <1>;
+		io-channels = <&pm8150_adc ADC5_AMUX_THM1_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+
+	pa-therm1@2 {
+		reg = <2>;
+		io-channels = <&pm8150_adc ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+};
+
+&pm8150b_adc {
+	channel@4f {
+		reg = <ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "conn_therm";
+	};
+};
+
+&pm8150b_adc_tm {
+	status = "okay";
+
+	conn-therm@0 {
+		reg = <0>;
+		io-channels = <&pm8150b_adc ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+};
+
+&pm8150l_adc_tm {
+	status = "okay";
+
+	camera-flash-therm@0 {
+		reg = <0>;
+		io-channels = <&pm8150l_adc ADC5_AMUX_THM1_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+
+	skin-msm-therm@1 {
+		reg = <1>;
+		io-channels = <&pm8150l_adc ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+
+	pa-therm2@2 {
+		reg = <2>;
+		io-channels = <&pm8150l_adc ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+};
+
+&pm8150l_adc {
+	channel@4d {
+		reg = <ADC5_AMUX_THM1_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "camera_flash_therm";
+	};
+
+	channel@4e {
+		reg = <ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "skin_msm_therm";
+	};
+
+	channel@4f {
+		reg = <ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "pa_therm2";
+	};
+};
+
+&qupv3_id_0 {
+	status = "okay";
+};
+
+&qupv3_id_1 {
+	status = "okay";
+};
+
+&qupv3_id_2 {
+	status = "okay";
+};
+
+&rxmacro {
+	status = "okay";
+};
+
+&slpi {
+	status = "okay";
+	firmware-name = "qcom/sm8250/lge/timelm/slpi.mbn";
+};
+
+&sound {
+	compatible = "qcom,sm8250-sndcard";
+	pinctrl-0 = <&sec_mi2s_active>;
+	pinctrl-names = "default";
+	model = "SM8250-MTP-WCD9380-TFA9878-VA-DMIC";
+	audio-routing =
+		"IN1_HPHL", "HPHL_OUT",
+		"IN2_HPHR", "HPHR_OUT",
+		"AMIC1", "MIC BIAS1",
+		"AMIC2", "MIC BIAS2",
+		"AMIC3", "MIC BIAS3",
+		"AMIC4", "MIC BIAS3",
+		"AMIC5", "MIC BIAS4";
+
+	mm1-dai-link {
+		link-name = "MultiMedia1";
+		cpu {
+			sound-dai = <&q6asmdai  MSM_FRONTEND_DAI_MULTIMEDIA1>;
+		};
+	};
+
+	mm2-dai-link {
+		link-name = "MultiMedia2";
+		cpu {
+			sound-dai = <&q6asmdai  MSM_FRONTEND_DAI_MULTIMEDIA2>;
+		};
+	};
+
+	mm3-dai-link {
+		link-name = "MultiMedia3";
+		cpu {
+			sound-dai = <&q6asmdai  MSM_FRONTEND_DAI_MULTIMEDIA3>;
+		};
+	};
+
+	wcd-playback-dai-link {
+		link-name = "WCD Playback";
+		cpu {
+			sound-dai = <&q6afedai RX_CODEC_DMA_RX_0>;
+		};
+		codec {
+			sound-dai = <&wcd938x 0>, <&swr1 0>, <&rxmacro 0>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+
+	wcd-capture-dai-link {
+		link-name = "WCD Capture";
+		cpu {
+			sound-dai = <&q6afedai TX_CODEC_DMA_TX_3>;
+		};
+
+		codec {
+			sound-dai = <&wcd938x 1>, <&swr2 0>, <&txmacro 0>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+	
+	tfa9878-dai-link {
+		link-name = "Speaker Playback";
+		cpu {
+			sound-dai = <&q6afedai SECONDARY_MI2S_RX>;
+		};
+
+		platform {
+			sound-dai = <&q6routing>;
+		};
+
+		codec {
+			sound-dai = <&tfa9878_l 0>, <&tfa9878_r 0>;
+		};
+	};
+
+	va-dai-link {
+		link-name = "VA Capture";
+		cpu {
+			sound-dai = <&q6afedai VA_CODEC_DMA_TX_0>;
+		};
+
+		platform {
+			sound-dai = <&q6routing>;
+		};
+
+		codec {
+			sound-dai = <&vamacro 0>;
+		};
+	};
+};
+
+&swr1 {
+	status = "okay";
+
+	wcd_rx: wcd9380-rx@0,4 {
+		compatible = "sdw20217010d00";
+		reg = <0 4>;
+		qcom,rx-port-mapping = <1 2 3 4 5>;
+	};
+};
+
+&swr2 {
+	status = "okay";
+
+	wcd_tx: wcd9380-tx@0,3 {
+		compatible = "sdw20217010d00";
+		reg = <0 3>;
+		qcom,tx-port-mapping = <2 3 4 5>;
+	};
+};
+
+&tlmm {
+	gpio-reserved-ranges = <28 4>, <40 4>;
+
+	wcd938x_reset_default: wcd938x-reset-default-state {
+		pins = "gpio32";
+		function = "gpio";
+		drive-strength = <16>;
+		output-high;
+	};
+
+	wcd938x_reset_sleep: wcd938x-reset-sleep-state {
+		pins = "gpio32";
+		function = "gpio";
+		drive-strength = <16>;
+		bias-disable;
+		output-low;
+	};
+
+	sec_mi2s_active: sec-mi2s-active-state {
+		mclk-pins {
+			pins = "gpio137";
+			function = "sec_mi2s";
+			drive-strength = <8>;
+			bias-disable;
+		};
+
+		sck-pins {
+			pins = "gpio142";
+			function = "mi2s1_sck";
+			drive-strength = <8>;
+			bias-disable;
+		};
+
+		data0-pins {
+			pins = "gpio143";
+			function = "mi2s1_data0";
+			drive-strength = <8>;
+			bias-disable;
+		};
+		
+		data1-pins {
+			pins = "gpio144";
+			function = "mi2s1_data1";
+			drive-strength = <8>;
+			bias-disable;
+		};
+
+		ws-pins {
+			pins = "gpio145";
+			function = "mi2s1_ws";
+			drive-strength = <8>;
+			output-high;
+		};
+	};
+
+	ts_reset_active: ts-reset-active {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <6>;
+		output-high;
+	};
+
+	ts_reset_suspend: ts-reset-suspend {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <6>;
+		bias-disable;
+		output-low;
+	};
+
+	ts_int_active: ts-int-active {
+		pins = "gpio39";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	ts_int_suspend: ts-int-suspend {
+		pins = "gpio39";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+	
+	tfa9878_reset_active: tfa9878-reset-active {
+		pins = "gpio99";
+		function = "gpio";
+		drive-strength = <2>;
+		output-high;
+	};
+};
+
+&txmacro {
+	status = "okay";
+};
+
+&uart12 {
+	status = "okay";
+};
+
+&ufs_mem_hc {
+	status = "okay";
+
+	vcc-supply = <&vreg_l17a_3p0>;
+	vcc-max-microamp = <750000>;
+	vccq-supply = <&vreg_l6a_1p2>;
+	vccq-max-microamp = <700000>;
+	vccq2-supply = <&vreg_s4a_1p8>;
+	vccq2-max-microamp = <750000>;
+};
+
+&ufs_mem_phy {
+	status = "okay";
+
+	vdda-phy-supply = <&vreg_l5a_0p875>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+};
+
+&usb_1 {
+	status = "okay";
+};
+
+&usb_1_dwc3 {
+	dr_mode = "host";
+};
+
+&usb_1_hsphy {
+	status = "okay";
+
+	vdda-pll-supply = <&vreg_l5a_0p875>;
+	vdda18-supply = <&vreg_l12a_1p8>;
+	vdda33-supply = <&vreg_l2a_3p1>;
+};
+
+&usb_1_qmpphy {
+	status = "okay";
+
+	vdda-phy-supply = <&vreg_l9a_1p2>;
+	vdda-pll-supply = <&vreg_l18a_0p9>;
+};
+
+&usb_2 {
+	status = "okay";
+};
+
+&usb_2_dwc3 {
+	dr_mode = "host";
+};
+
+&usb_2_hsphy {
+	status = "okay";
+
+	vdda-pll-supply = <&vreg_l5a_0p875>;
+	vdda18-supply = <&vreg_l12a_1p8>;
+	vdda33-supply = <&vreg_l2a_3p1>;
+};
+
+&usb_2_qmpphy {
+	status = "okay";
+
+	vdda-phy-supply = <&vreg_l9a_1p2>;
+	vdda-pll-supply = <&vreg_l18a_0p9>;
+};
+
+&venus {
+	status = "okay";
+};
+
+&adsp_mem {
+	reg = <0x0 0x8a100000 0x0 0x2500000>;
+};
+
+&spss_mem {
+	reg = <0x0 0x8c600000 0x0 0x100000>;
+};
+
+&cdsp_secure_heap {
+	reg = <0x0 0x8c700000 0x0 0x4600000>;
+};
-- 
2.43.0


From 0dc2ad3b284e9d1931dea0400a3367a4ab98eeb7 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Tue, 26 Nov 2024 14:25:43 +0000
Subject: [PATCH 08/39] arm64/config: add fbcon rotate.

---
 arch/arm64/configs/q_defconfig | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/arch/arm64/configs/q_defconfig b/arch/arm64/configs/q_defconfig
index 7f77d77ae0fa..044fcebe5611 100644
--- a/arch/arm64/configs/q_defconfig
+++ b/arch/arm64/configs/q_defconfig
@@ -78,6 +78,7 @@ CONFIG_MEMORY_HOTREMOVE=y
 CONFIG_KSM=y
 CONFIG_MEMORY_FAILURE=y
 CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_CMA=y
 CONFIG_NET=y
 CONFIG_PACKET=y
 CONFIG_IP_MULTICAST=y
@@ -631,9 +632,6 @@ CONFIG_DRM_ANALOGIX_ANX7625=m
 CONFIG_DRM_I2C_ADV7511=m
 CONFIG_DRM_I2C_ADV7511_AUDIO=y
 CONFIG_DRM_CDNS_MHDP8546=m
-CONFIG_DRM_ETNAVIV=m
-CONFIG_DRM_HISI_HIBMC=m
-CONFIG_DRM_HISI_KIRIN=m
 CONFIG_DRM_SIMPLEDRM=y
 CONFIG_FB=y
 CONFIG_FB_EFI=y
@@ -642,6 +640,7 @@ CONFIG_BACKLIGHT_CLASS_DEVICE=m
 CONFIG_BACKLIGHT_KTZ8866=m
 CONFIG_BACKLIGHT_PWM=m
 CONFIG_BACKLIGHT_QCOM_WLED=m
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
 CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_MONO is not set
 # CONFIG_LOGO_LINUX_VGA16 is not set
@@ -936,7 +935,8 @@ CONFIG_SM_TCSRCC_8550=y
 CONFIG_SM_TCSRCC_8650=y
 CONFIG_SM_VIDEOCC_8250=y
 CONFIG_QCOM_HFPLL=y
-CONFIG_CLK_GFM_LPASS_SM8250=m
+CONFIG_CLK_GFM_LPASS_SM8250=y
+CONFIG_SM_VIDEOCC_8450=m
 CONFIG_HWSPINLOCK=y
 CONFIG_HWSPINLOCK_QCOM=y
 # CONFIG_FSL_ERRATUM_A008585 is not set
@@ -1138,6 +1138,7 @@ CONFIG_CRYPTO_DEV_HISI_TRNG=m
 CONFIG_CRYPTO_DEV_AMLOGIC_GXL=m
 CONFIG_INDIRECT_PIO=y
 CONFIG_DMA_RESTRICTED_POOL=y
+CONFIG_DMA_CMA=y
 CONFIG_CMA_SIZE_MBYTES=32
 CONFIG_PRINTK_TIME=y
 CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-- 
2.43.0


From e59a986b22f4fb4e146baadc5a047ef09481af9a Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Tue, 26 Nov 2024 14:45:58 +0000
Subject: [PATCH 09/39] drm/panel: Add a jdi panel and a wt panel.

---
 drivers/gpu/drm/panel/Kconfig                 |  20 +
 drivers/gpu/drm/panel/Makefile                |   2 +
 .../gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c  | 435 ++++++++++++++++++
 drivers/gpu/drm/panel/panel-wt0600-60hz.c     | 219 +++++++++
 4 files changed, 676 insertions(+)
 create mode 100644 drivers/gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c
 create mode 100644 drivers/gpu/drm/panel/panel-wt0600-60hz.c

diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index d3a9a9fafe4e..c998cfd06268 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -282,6 +282,17 @@ config DRM_PANEL_JDI_LPM102A188A
 	  The panel has a 2560×1800 resolution. It provides a MIPI DSI interface
 	  to the host.
 
+config CONFIG_DRM_PANEL_JDI_MP42020B
+	tristate "JDI MP42020B DSI panel"
+	depends on OF && GPIOLIB
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to enable support for JDI MP42020B DSI
+	  command mode panel as found in Xiaomi 10.
+	  The panel has a 2340×1080 resolution. It provides a MIPI DSI interface
+	  to the host.
+
 config DRM_PANEL_JDI_LT070ME05000
 	tristate "JDI LT070ME05000 WUXGA DSI panel"
 	depends on OF
@@ -979,6 +990,15 @@ config DRM_PANEL_WIDECHIPS_WS2401
 	  480x800 display controller used in panels such as Samsung LMS380KF01.
 	  This display is used in the Samsung Galaxy Ace 2 GT-I8160 (Codina).
 
+config DRM_PANEL_AYANEO_WT0600_2K
+      tristate "Ayaneo WT0600 2K 60hz panel driver"
+      depends on OF
+      depends on DRM_MIPI_DSI
+      depends on BACKLIGHT_CLASS_DEVICE
+      help
+        Say Y here if you want to enable support for Ayaneo WT0600
+        1440x2560 60hz Dual-DSI None-DSC Display Panel.
+
 config DRM_PANEL_XINPENG_XPP055C272
 	tristate "Xinpeng XPP055C272 panel driver"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 987a08702410..ae2d24895f34 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -29,6 +29,7 @@ obj-$(CONFIG_DRM_PANEL_INNOLUX_EJ030NA) += panel-innolux-ej030na.o
 obj-$(CONFIG_DRM_PANEL_INNOLUX_P079ZCA) += panel-innolux-p079zca.o
 obj-$(CONFIG_DRM_PANEL_JADARD_JD9365DA_H3) += panel-jadard-jd9365da-h3.o
 obj-$(CONFIG_DRM_PANEL_JDI_LT070ME05000) += panel-jdi-lt070me05000.o
+obj-$(CONFIG_DRM_PANEL_JDI_MP42020B) += panel-j2-mp-42-02-0b-dsc.o
 obj-$(CONFIG_DRM_PANEL_JDI_LPM102A188A) += panel-jdi-lpm102a188a.o
 obj-$(CONFIG_DRM_PANEL_JDI_R63452) += panel-jdi-fhd-r63452.o
 obj-$(CONFIG_DRM_PANEL_KHADAS_TS050) += panel-khadas-ts050.o
@@ -99,4 +100,5 @@ obj-$(CONFIG_DRM_PANEL_VISIONOX_RM69299) += panel-visionox-rm69299.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_VTDR6130) += panel-visionox-vtdr6130.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_R66451) += panel-visionox-r66451.o
 obj-$(CONFIG_DRM_PANEL_WIDECHIPS_WS2401) += panel-widechips-ws2401.o
+obj-$(CONFIG_DRM_PANEL_AYANEO_WT0600_2K) += panel-wt0600-60hz.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
diff --git a/drivers/gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c b/drivers/gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c
new file mode 100644
index 000000000000..ed5a6876a7c3
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c
@@ -0,0 +1,435 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2023 Kancy Joe
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, Kancy Joe. All rights reserved.
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/display/drm_dsc.h>
+#include <drm/display/drm_dsc_helper.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct j2_mp_42_02_0b_dsc {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct drm_dsc_config dsc;
+	struct gpio_desc *reset_gpio;
+    struct regulator_bulk_data supplies[1];
+	bool prepared;
+};
+
+static inline
+struct j2_mp_42_02_0b_dsc *to_j2_mp_42_02_0b_dsc(struct drm_panel *panel)
+{
+	return container_of(panel, struct j2_mp_42_02_0b_dsc, panel);
+}
+
+static void j2_mp_42_02_0b_dsc_reset(struct j2_mp_42_02_0b_dsc *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int j2_mp_42_02_0b_dsc_on(struct j2_mp_42_02_0b_dsc *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x33);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x58, 0x00, 0x08, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x00, 0x12, 0x61, 0x25, 0x43, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x48, 0x48, 0x48, 0x48);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0xcd, 0x05, 0x61);
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x88, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x04, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x04, 0x00, 0x00, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x04, 0x00, 0x00, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0xaa, 0x55, 0xa5, 0x81);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x0d);
+	mipi_dsi_dcs_write_seq(dsi, 0xf3, 0xab);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xfd, 0x00, 0xda);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0xaa, 0x55, 0xa5, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0xfc, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x36);
+	mipi_dsi_dcs_write_seq(dsi, 0xf6, 0x42);
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0x00, 0x0c, 0x00, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x90, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x93,
+			       0x89, 0x28, 0x00, 0x0c, 0x02, 0x00, 0x02, 0x0e,
+			       0x01, 0x1f, 0x00, 0x07, 0x08, 0xbb, 0x08, 0x7a,
+			       0x10, 0xf0);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_MEMORY_START);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0x00, 0x00, 0x00, 0x00);
+
+	ret = mipi_dsi_dcs_set_column_address(dsi, 0x0000, 0x0437);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set column address: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_page_address(dsi, 0x0000, 0x0923);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set page address: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4,
+			       0xcb, 0xbb, 0xbb, 0xaa, 0x99, 0x77, 0x66, 0x00,
+			       0x00, 0x00, 0xb4, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0,
+			       0x86, 0x86, 0x3c, 0x3c, 0xf2, 0xf2, 0xa8, 0xa8,
+			       0x36, 0x36, 0x36, 0x36, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x2f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
+
+    /* Set pixel format */
+    ret = mipi_dsi_dcs_set_pixel_format(dsi, 0x77);
+    if (ret < 0) {
+        dev_err(dev, "Failed to set pixel format (%d)\n", ret);
+        return ret;
+    }
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(100);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x84);
+
+	return 0;
+}
+
+static int j2_mp_42_02_0b_dsc_off(struct j2_mp_42_02_0b_dsc *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int j2_mp_42_02_0b_dsc_prepare(struct drm_panel *panel)
+{
+	struct j2_mp_42_02_0b_dsc *ctx = to_j2_mp_42_02_0b_dsc(panel);
+	struct device *dev = &ctx->dsi->dev;
+	struct drm_dsc_picture_parameter_set pps;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+    ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+    if (ret < 0) {
+        dev_err(dev, "Failed to enable regulators: %d\n", ret);
+        return ret;
+    }
+
+	j2_mp_42_02_0b_dsc_reset(ctx);
+
+	ret = j2_mp_42_02_0b_dsc_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		return ret;
+	}
+
+	drm_dsc_pps_payload_pack(&pps, &ctx->dsc);
+
+	ret = mipi_dsi_picture_parameter_set(ctx->dsi, &pps);
+	if (ret < 0) {
+		dev_err(panel->dev, "failed to transmit PPS: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_compression_mode(ctx->dsi, true);
+	if (ret < 0) {
+		dev_err(dev, "failed to enable compression mode: %d\n", ret);
+		return ret;
+	}
+
+	msleep(28); /* TODO: Is this panel-dependent? */
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int j2_mp_42_02_0b_dsc_unprepare(struct drm_panel *panel)
+{
+	struct j2_mp_42_02_0b_dsc *ctx = to_j2_mp_42_02_0b_dsc(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = j2_mp_42_02_0b_dsc_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode j2_mp_42_02_0b_dsc_mode = {
+	.clock = ((1080 + 16 + 8 + 8) * (2340 + 600 + 32 + 560) * 60 / 1000)*2,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 16,
+	.hsync_end = 1080 + 16 + 8,
+	.htotal = 1080 + 16 + 8 + 8,
+	.vdisplay = 2340,
+	.vsync_start = 2340 + 600,
+	.vsync_end = 2340 + 600 + 32,
+	.vtotal = 2340 + 600 + 32 + 560,
+	.width_mm = 710,
+	.height_mm = 1537,
+};
+
+static int j2_mp_42_02_0b_dsc_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &j2_mp_42_02_0b_dsc_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs j2_mp_42_02_0b_dsc_panel_funcs = {
+	.prepare = j2_mp_42_02_0b_dsc_prepare,
+	.unprepare = j2_mp_42_02_0b_dsc_unprepare,
+	.get_modes = j2_mp_42_02_0b_dsc_get_modes,
+};
+
+static int j2_mp_42_02_0b_dsc_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness_large(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static int j2_mp_42_02_0b_dsc_bl_get_brightness(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_get_display_brightness_large(dsi, &brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return brightness;
+}
+
+static const struct backlight_ops j2_mp_42_02_0b_dsc_bl_ops = {
+	.update_status = j2_mp_42_02_0b_dsc_bl_update_status,
+	.get_brightness = j2_mp_42_02_0b_dsc_bl_get_brightness,
+};
+
+static struct backlight_device *
+j2_mp_42_02_0b_dsc_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 2047,
+		.max_brightness = 2047,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &j2_mp_42_02_0b_dsc_bl_ops, &props);
+}
+
+static int j2_mp_42_02_0b_dsc_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct j2_mp_42_02_0b_dsc *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vddio";
+    ret = devm_regulator_bulk_get(&dsi->dev, ARRAY_SIZE(ctx->supplies),
+            ctx->supplies);
+
+//    if (ret < 0)
+//        return dev_err_probe(dev, PTR_ERR(ctx->supplies), "Failed to get vddio.\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &j2_mp_42_02_0b_dsc_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = j2_mp_42_02_0b_dsc_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	/* This panel only supports DSC; unconditionally enable it */
+	dsi->dsc = &ctx->dsc;
+
+	ctx->dsc.dsc_version_major = 1;
+	ctx->dsc.dsc_version_minor = 1;
+
+	/* TODO: Pass slice_per_pkt = 2 */
+	ctx->dsc.slice_height = 12;
+	ctx->dsc.slice_width = 540;
+	/*
+	 * TODO: hdisplay should be read from the selected mode once
+	 * it is passed back to drm_panel (in prepare?)
+	 */
+	WARN_ON(1080 % ctx->dsc.slice_width);
+	ctx->dsc.slice_count = 1080 / ctx->dsc.slice_width;
+	ctx->dsc.bits_per_component = 8;
+	ctx->dsc.bits_per_pixel = 8 << 4; /* 4 fractional bits */
+	ctx->dsc.block_pred_enable = true;
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void j2_mp_42_02_0b_dsc_remove(struct mipi_dsi_device *dsi)
+{
+	struct j2_mp_42_02_0b_dsc *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id j2_mp_42_02_0b_dsc_of_match[] = {
+	{ .compatible = "csot,j2-mp-42-02-0b-dsc" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, j2_mp_42_02_0b_dsc_of_match);
+
+static struct mipi_dsi_driver j2_mp_42_02_0b_dsc_driver = {
+	.probe = j2_mp_42_02_0b_dsc_probe,
+	.remove = j2_mp_42_02_0b_dsc_remove,
+	.driver = {
+		.name = "panel-j2-mp-42-02-0b-dsc",
+		.of_match_table = j2_mp_42_02_0b_dsc_of_match,
+	},
+};
+module_mipi_dsi_driver(j2_mp_42_02_0b_dsc_driver);
+
+MODULE_AUTHOR("KancyJoe <sunflower2333@outlook.com>");
+MODULE_DESCRIPTION("DRM driver for xiaomi 42 02 0b cmd mode dsc dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/panel-wt0600-60hz.c b/drivers/gpu/drm/panel/panel-wt0600-60hz.c
new file mode 100644
index 000000000000..1551b7dfa6c8
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-wt0600-60hz.c
@@ -0,0 +1,219 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 Kancy Joe
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved.
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct wt0600_60hz {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct wt0600_60hz *to_wt0600_60hz(struct drm_panel *panel)
+{
+	return container_of(panel, struct wt0600_60hz, panel);
+}
+
+static void wt0600_60hz_reset(struct wt0600_60hz *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(55);
+}
+
+static int wt0600_60hz_on(struct wt0600_60hz *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(150);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	return 0;
+}
+
+static int wt0600_60hz_off(struct wt0600_60hz *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(150);
+
+	return 0;
+}
+
+static int wt0600_60hz_prepare(struct drm_panel *panel)
+{
+	struct wt0600_60hz *ctx = to_wt0600_60hz(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	wt0600_60hz_reset(ctx);
+
+	ret = wt0600_60hz_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int wt0600_60hz_unprepare(struct drm_panel *panel)
+{
+	struct wt0600_60hz *ctx = to_wt0600_60hz(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = wt0600_60hz_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+	return 0;
+}
+
+static const struct drm_display_mode wt0600_60hz_mode = {
+	.clock = (720 + 100 + 8 + 40) * (2560 + 8 + 2 + 7) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 100,
+	.hsync_end = 720 + 100 + 8,
+	.htotal = 720 + 100 + 8 + 40,
+	.vdisplay = 2560,
+	.vsync_start = 2560 + 8,
+	.vsync_end = 2560 + 8 + 2,
+	.vtotal = 2560 + 8 + 2 + 7,
+	.width_mm = 0,
+	.height_mm = 0,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int wt0600_60hz_get_modes(struct drm_panel *panel,
+				 struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &wt0600_60hz_mode);
+}
+
+static const struct drm_panel_funcs wt0600_60hz_panel_funcs = {
+	.prepare = wt0600_60hz_prepare,
+	.unprepare = wt0600_60hz_unprepare,
+	.get_modes = wt0600_60hz_get_modes,
+};
+
+static int wt0600_60hz_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct wt0600_60hz *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &wt0600_60hz_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void wt0600_60hz_remove(struct mipi_dsi_device *dsi)
+{
+	struct wt0600_60hz *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id wt0600_60hz_of_match[] = {
+	{ .compatible = "ayaneo,wt0600-2k" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, wt0600_60hz_of_match);
+
+static struct mipi_dsi_driver wt0600_60hz_driver = {
+	.probe = wt0600_60hz_probe,
+	.remove = wt0600_60hz_remove,
+	.driver = {
+		.name = "panel-wt0600-2k60hz",
+		.of_match_table = wt0600_60hz_of_match,
+	},
+};
+module_mipi_dsi_driver(wt0600_60hz_driver);
+
+MODULE_AUTHOR("Kancy Joe <sunflower2333@outlook.com>");
+MODULE_DESCRIPTION("DRM driver for wt0600 2k video mode dsi panel");
+MODULE_LICENSE("GPL");
-- 
2.43.0


From 2bfa17103e4947c5a6dbc3de111a1058dbd12352 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Wed, 27 Nov 2024 01:53:26 +0000
Subject: [PATCH 10/39] arm64/config: Compile cpufreq governor in kernel.

---
 arch/arm64/configs/q_defconfig | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/arm64/configs/q_defconfig b/arch/arm64/configs/q_defconfig
index 044fcebe5611..2891351bb87d 100644
--- a/arch/arm64/configs/q_defconfig
+++ b/arch/arm64/configs/q_defconfig
@@ -48,10 +48,10 @@ CONFIG_ENERGY_MODEL=y
 CONFIG_ARM_PSCI_CPUIDLE=y
 CONFIG_CPU_FREQ=y
 CONFIG_CPU_FREQ_STAT=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
 CONFIG_CPU_FREQ_GOV_USERSPACE=y
 CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
 CONFIG_CPUFREQ_DT=y
 CONFIG_ARM_SCPI_CPUFREQ=y
 CONFIG_ARM_QCOM_CPUFREQ_NVMEM=y
-- 
2.43.0


From 6c616e6ca35fb6f9c601c2bc7ac681753db43769 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Wed, 27 Nov 2024 04:29:41 +0000
Subject: [PATCH 11/39] arm64/config: remove unused clks in q_defconfig.

---
 arch/arm64/configs/q_defconfig | 31 +++++++++----------------------
 1 file changed, 9 insertions(+), 22 deletions(-)

diff --git a/arch/arm64/configs/q_defconfig b/arch/arm64/configs/q_defconfig
index 2891351bb87d..0d257b295d95 100644
--- a/arch/arm64/configs/q_defconfig
+++ b/arch/arm64/configs/q_defconfig
@@ -873,10 +873,8 @@ CONFIG_CLK_X1E80100_DISPCC=m
 CONFIG_CLK_X1E80100_GCC=y
 CONFIG_CLK_X1E80100_GPUCC=m
 CONFIG_CLK_X1E80100_TCSRCC=y
-CONFIG_QCOM_A53PLL=y
-CONFIG_QCOM_CLK_APCS_MSM8916=y
-CONFIG_QCOM_CLK_APCC_MSM8996=y
-CONFIG_QCOM_CLK_SMD_RPM=y
+CONFIG_QCOM_CLK_RPM=m
+CONFIG_QCOM_CLK_SMD_RPM=m
 CONFIG_QCOM_CLK_RPMH=y
 CONFIG_IPQ_APSS_6018=y
 CONFIG_IPQ_GCC_5018=y
@@ -884,17 +882,10 @@ CONFIG_IPQ_GCC_5332=y
 CONFIG_IPQ_GCC_6018=y
 CONFIG_IPQ_GCC_8074=y
 CONFIG_IPQ_GCC_9574=y
-CONFIG_MSM_GCC_8916=y
-CONFIG_MSM_MMCC_8994=m
-CONFIG_MSM_GCC_8994=y
-CONFIG_MSM_GCC_8996=y
-CONFIG_MSM_MMCC_8996=m
-CONFIG_MSM_GCC_8998=y
-CONFIG_MSM_MMCC_8998=m
-CONFIG_QCM_GCC_2290=y
-CONFIG_QCM_DISPCC_2290=m
-CONFIG_QCS_GCC_404=y
+CONFIG_SC_CAMCC_7180=m
+CONFIG_SC_CAMCC_7280=m
 CONFIG_SC_CAMCC_8280XP=m
+CONFIG_SC_DISPCC_7180=m
 CONFIG_SC_DISPCC_7280=m
 CONFIG_SC_DISPCC_8280XP=m
 CONFIG_SA_GCC_8775P=y
@@ -905,15 +896,16 @@ CONFIG_SC_GCC_8180X=y
 CONFIG_SC_GCC_8280XP=y
 CONFIG_SC_GPUCC_7280=m
 CONFIG_SC_GPUCC_8280XP=m
+CONFIG_SC_LPASSCC_7280=m
 CONFIG_SC_LPASSCC_8280XP=m
 CONFIG_SDM_CAMCC_845=m
-CONFIG_QDU_GCC_1000=y
 CONFIG_SDM_GPUCC_845=y
 CONFIG_SDM_VIDEOCC_845=y
 CONFIG_SDM_DISPCC_845=y
 CONFIG_SDM_LPASSCC_845=m
 CONFIG_SDX_GCC_75=y
-CONFIG_SM_CAMCC_8250=m
+CONFIG_SM_CAMCC_8150=m
+CONFIG_SM_CAMCC_8250=y
 CONFIG_SM_DISPCC_6115=m
 CONFIG_SM_DISPCC_8250=y
 CONFIG_SM_DISPCC_8450=m
@@ -1060,11 +1052,7 @@ CONFIG_MUX_MMIO=y
 CONFIG_SLIM_QCOM_CTRL=m
 CONFIG_SLIM_QCOM_NGD_CTRL=m
 CONFIG_INTERCONNECT_QCOM=y
-CONFIG_INTERCONNECT_QCOM_MSM8916=m
-CONFIG_INTERCONNECT_QCOM_MSM8996=y
-CONFIG_INTERCONNECT_QCOM_OSM_L3=m
-CONFIG_INTERCONNECT_QCOM_QCM2290=y
-CONFIG_INTERCONNECT_QCOM_QCS404=m
+CONFIG_INTERCONNECT_QCOM_OSM_L3=y
 CONFIG_INTERCONNECT_QCOM_QDU1000=y
 CONFIG_INTERCONNECT_QCOM_SA8775P=y
 CONFIG_INTERCONNECT_QCOM_SC7180=y
@@ -1072,7 +1060,6 @@ CONFIG_INTERCONNECT_QCOM_SC7280=y
 CONFIG_INTERCONNECT_QCOM_SC8180X=y
 CONFIG_INTERCONNECT_QCOM_SC8280XP=y
 CONFIG_INTERCONNECT_QCOM_SDM845=y
-CONFIG_INTERCONNECT_QCOM_SDX75=y
 CONFIG_INTERCONNECT_QCOM_SM6115=y
 CONFIG_INTERCONNECT_QCOM_SM8150=y
 CONFIG_INTERCONNECT_QCOM_SM8250=y
-- 
2.43.0


From b374dcc8b6bef9f9f12b1af042b1abbbba818030 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Wed, 27 Nov 2024 05:17:13 +0000
Subject: [PATCH 12/39] driver/drm/panel: Regenerate panel for csot
 j2-mp-42-02-0b-dsc panel.

---
 drivers/gpu/drm/panel/Kconfig                 |   6 +-
 drivers/gpu/drm/panel/Makefile                |   2 +-
 .../gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c  | 268 +++++++-----------
 3 files changed, 102 insertions(+), 174 deletions(-)

diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 6e01f4e1f90c..b1fc66de8a67 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -282,13 +282,13 @@ config DRM_PANEL_JDI_LPM102A188A
 	  The panel has a 2560×1800 resolution. It provides a MIPI DSI interface
 	  to the host.
 
-config CONFIG_DRM_PANEL_JDI_MP42020B
-	tristate "JDI MP42020B DSI panel"
+config DRM_PANEL_CSOT_MP42020B
+	tristate "CSOT MP42020B DSI panel"
 	depends on OF && GPIOLIB
 	depends on DRM_MIPI_DSI
 	depends on BACKLIGHT_CLASS_DEVICE
 	help
-	  Say Y here if you want to enable support for JDI MP42020B DSI
+	  Say Y here if you want to enable support for CSOT MP42020B DSI
 	  command mode panel as found in Xiaomi 10.
 	  The panel has a 2340×1080 resolution. It provides a MIPI DSI interface
 	  to the host.
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 5905f680225f..1f8a69c6ddba 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -10,6 +10,7 @@
 obj-$(CONFIG_DRM_PANEL_BOE_TV101WUM_NL6) += panel-boe-tv101wum-nl6.o
 obj-$(CONFIG_DRM_PANEL_BOE_XM91080G) += panel-boe-xm91080g.o
 obj-$(CONFIG_DRM_PANEL_CHIPONE_ICNA3512) += panel-chipone-icna3512.o
+obj-$(CONFIG_DRM_PANEL_CSOT_MP42020B) += panel-j2-mp-42-02-0b-dsc.o
 obj-$(CONFIG_DRM_PANEL_DSI_CM) += panel-dsi-cm.o
 obj-$(CONFIG_DRM_PANEL_LVDS) += panel-lvds.o
 obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-simple.o
@@ -29,7 +30,6 @@ obj-$(CONFIG_DRM_PANEL_INNOLUX_EJ030NA) += panel-innolux-ej030na.o
 obj-$(CONFIG_DRM_PANEL_INNOLUX_P079ZCA) += panel-innolux-p079zca.o
 obj-$(CONFIG_DRM_PANEL_JADARD_JD9365DA_H3) += panel-jadard-jd9365da-h3.o
 obj-$(CONFIG_DRM_PANEL_JDI_LT070ME05000) += panel-jdi-lt070me05000.o
-obj-$(CONFIG_DRM_PANEL_JDI_MP42020B) += panel-j2-mp-42-02-0b-dsc.o
 obj-$(CONFIG_DRM_PANEL_JDI_LPM102A188A) += panel-jdi-lpm102a188a.o
 obj-$(CONFIG_DRM_PANEL_JDI_R63452) += panel-jdi-fhd-r63452.o
 obj-$(CONFIG_DRM_PANEL_KHADAS_TS050) += panel-khadas-ts050.o
diff --git a/drivers/gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c b/drivers/gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c
index ed5a6876a7c3..17ec7944bb46 100644
--- a/drivers/gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c
+++ b/drivers/gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c
@@ -1,29 +1,26 @@
 // SPDX-License-Identifier: GPL-2.0-only
-// Copyright (c) 2023 Kancy Joe
+// Copyright (c) 2024 Kancy joe
 // Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
-//   Copyright (c) 2013, Kancy Joe. All rights reserved.
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved.
 
 #include <linux/backlight.h>
 #include <linux/delay.h>
 #include <linux/gpio/consumer.h>
+#include <linux/mod_devicetable.h>
 #include <linux/module.h>
-#include <linux/of.h>
-
-#include <video/mipi_display.h>
 
 #include <drm/display/drm_dsc.h>
 #include <drm/display/drm_dsc_helper.h>
 #include <drm/drm_mipi_dsi.h>
 #include <drm/drm_modes.h>
 #include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
 
 struct j2_mp_42_02_0b_dsc {
 	struct drm_panel panel;
 	struct mipi_dsi_device *dsi;
 	struct drm_dsc_config dsc;
 	struct gpio_desc *reset_gpio;
-    struct regulator_bulk_data supplies[1];
-	bool prepared;
 };
 
 static inline
@@ -44,136 +41,99 @@ static void j2_mp_42_02_0b_dsc_reset(struct j2_mp_42_02_0b_dsc *ctx)
 
 static int j2_mp_42_02_0b_dsc_on(struct j2_mp_42_02_0b_dsc *ctx)
 {
-	struct mipi_dsi_device *dsi = ctx->dsi;
-	struct device *dev = &dsi->dev;
-	int ret;
-
-	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x07);
-	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x10);
-	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
-	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0x00);
-	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
-	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
-	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x00);
-	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
-	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x33);
-	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x58, 0x00, 0x08, 0x08);
-	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
-	mipi_dsi_dcs_write_seq(dsi, 0xca, 0x30);
-	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x80);
-	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
-	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0x13);
-	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
-	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
-	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x00, 0x12, 0x61, 0x25, 0x43, 0x07);
-	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e);
-	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x48, 0x48, 0x48, 0x48);
-	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
-	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x13);
-	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x01);
-	mipi_dsi_dcs_write_seq(dsi, 0xb4, 0x13);
-	mipi_dsi_dcs_write_seq(dsi, 0xcd, 0x05, 0x61);
-	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
-	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x88, 0x80);
-	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x04, 0x01);
-	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x04, 0x00, 0x00, 0x01);
-	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x04, 0x00, 0x00, 0x01);
-	mipi_dsi_dcs_write_seq(dsi, 0xff, 0xaa, 0x55, 0xa5, 0x81);
-	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x0d);
-	mipi_dsi_dcs_write_seq(dsi, 0xf3, 0xab);
-	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x05);
-	mipi_dsi_dcs_write_seq(dsi, 0xfd, 0x00, 0xda);
-	mipi_dsi_dcs_write_seq(dsi, 0xff, 0xaa, 0x55, 0xa5, 0x80);
-	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x0a);
-	mipi_dsi_dcs_write_seq(dsi, 0xfc, 0x02);
-	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x36);
-	mipi_dsi_dcs_write_seq(dsi, 0xf6, 0x42);
-	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x00, 0x00);
-	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0x00, 0x0c, 0x00, 0x04);
-	mipi_dsi_dcs_write_seq(dsi, 0x90, 0x01);
-	mipi_dsi_dcs_write_seq(dsi, 0x93,
-			       0x89, 0x28, 0x00, 0x0c, 0x02, 0x00, 0x02, 0x0e,
-			       0x01, 0x1f, 0x00, 0x07, 0x08, 0xbb, 0x08, 0x7a,
-			       0x10, 0xf0);
-	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x11);
-	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_MEMORY_START);
-
-	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
-	if (ret < 0) {
-		dev_err(dev, "Failed to set tear on: %d\n", ret);
-		return ret;
-	}
-
-	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x20);
-	mipi_dsi_dcs_write_seq(dsi, 0x51, 0x00, 0x00, 0x00, 0x00);
-
-	ret = mipi_dsi_dcs_set_column_address(dsi, 0x0000, 0x0437);
-	if (ret < 0) {
-		dev_err(dev, "Failed to set column address: %d\n", ret);
-		return ret;
-	}
-
-	ret = mipi_dsi_dcs_set_page_address(dsi, 0x0000, 0x0923);
-	if (ret < 0) {
-		dev_err(dev, "Failed to set page address: %d\n", ret);
-		return ret;
-	}
-
-	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
-	mipi_dsi_dcs_write_seq(dsi, 0xb4,
-			       0xcb, 0xbb, 0xbb, 0xaa, 0x99, 0x77, 0x66, 0x00,
-			       0x00, 0x00, 0xb4, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0,
-			       0x86, 0x86, 0x3c, 0x3c, 0xf2, 0xf2, 0xa8, 0xa8,
-			       0x36, 0x36, 0x36, 0x36, 0x0a);
-	mipi_dsi_dcs_write_seq(dsi, 0x2f, 0x01);
-	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
-
-    /* Set pixel format */
-    ret = mipi_dsi_dcs_set_pixel_format(dsi, 0x77);
-    if (ret < 0) {
-        dev_err(dev, "Failed to set pixel format (%d)\n", ret);
-        return ret;
-    }
-
-	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
-	if (ret < 0) {
-		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
-		return ret;
-	}
-	msleep(100);
-
-	ret = mipi_dsi_dcs_set_display_on(dsi);
-	if (ret < 0) {
-		dev_err(dev, "Failed to set display on: %d\n", ret);
-		return ret;
-	}
-
-	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
-	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x84);
-
-	return 0;
+	struct mipi_dsi_multi_context dsi_ctx = { .dsi = ctx->dsi };
+
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xf0,
+				     0x55, 0xaa, 0x52, 0x08, 0x07);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc0, 0x10);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xf0,
+				     0x55, 0xaa, 0x52, 0x08, 0x03);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xd4, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xf0,
+				     0x55, 0xaa, 0x52, 0x08, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb5, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc0, 0x33);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb2, 0x58, 0x00, 0x08, 0x08);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xca, 0x30);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb5, 0x80);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc6, 0x13);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xf0,
+				     0x55, 0xaa, 0x52, 0x08, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xd2,
+				     0x00, 0x12, 0x61, 0x25, 0x43, 0x07);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb7,
+				     0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb8, 0x48, 0x48, 0x48, 0x48);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb3, 0x13);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x6f, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb4, 0x13);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xcd, 0x05, 0x61);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xf0,
+				     0x55, 0xaa, 0x52, 0x08, 0x05);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb3, 0x88, 0x80);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb5, 0x04, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb7, 0x04, 0x00, 0x00, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb8, 0x04, 0x00, 0x00, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xff, 0xaa, 0x55, 0xa5, 0x81);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x6f, 0x0d);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xf3, 0xab);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x6f, 0x05);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xfd, 0x00, 0xda);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xff, 0xaa, 0x55, 0xa5, 0x80);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x6f, 0x0a);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xfc, 0x02);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x6f, 0x36);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xf6, 0x42);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xf0,
+				     0x55, 0xaa, 0x52, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x3b, 0x00, 0x0c, 0x00, 0x04);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x90, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x93,
+				     0x89, 0x28, 0x00, 0x0c, 0x02, 0x00, 0x02,
+				     0x0e, 0x01, 0x1f, 0x00, 0x07, 0x08, 0xbb,
+				     0x08, 0x7a, 0x10, 0xf0);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x03, 0x11);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x2c);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x35, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x53, 0x20);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x51, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x2a, 0x00, 0x00, 0x04, 0x37);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x2b, 0x00, 0x00, 0x09, 0x23);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xf0,
+				     0x55, 0xaa, 0x52, 0x08, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb4,
+				     0xcb, 0xbb, 0xbb, 0xaa, 0x99, 0x77, 0x66,
+				     0x00, 0x00, 0x00, 0xb4, 0xd0, 0xd0, 0xd0,
+				     0xd0, 0xd0, 0x86, 0x86, 0x3c, 0x3c, 0xf2,
+				     0xf2, 0xa8, 0xa8, 0x36, 0x36, 0x36, 0x36,
+				     0x0a);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x2f, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x26, 0x01);
+	mipi_dsi_dcs_exit_sleep_mode_multi(&dsi_ctx);
+	mipi_dsi_msleep(&dsi_ctx, 100);
+	mipi_dsi_dcs_set_display_on_multi(&dsi_ctx);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xf0,
+				     0x55, 0xaa, 0x52, 0x08, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb5, 0x84);
+
+	return dsi_ctx.accum_err;
 }
 
 static int j2_mp_42_02_0b_dsc_off(struct j2_mp_42_02_0b_dsc *ctx)
 {
-	struct mipi_dsi_device *dsi = ctx->dsi;
-	struct device *dev = &dsi->dev;
-	int ret;
-
-	ret = mipi_dsi_dcs_set_display_off(dsi);
-	if (ret < 0) {
-		dev_err(dev, "Failed to set display off: %d\n", ret);
-		return ret;
-	}
+	struct mipi_dsi_multi_context dsi_ctx = { .dsi = ctx->dsi };
 
-	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
-	if (ret < 0) {
-		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
-		return ret;
-	}
-	msleep(120);
+	mipi_dsi_dcs_set_display_off_multi(&dsi_ctx);
+	mipi_dsi_dcs_enter_sleep_mode_multi(&dsi_ctx);
+	mipi_dsi_msleep(&dsi_ctx, 120);
 
-	return 0;
+	return dsi_ctx.accum_err;
 }
 
 static int j2_mp_42_02_0b_dsc_prepare(struct drm_panel *panel)
@@ -183,15 +143,6 @@ static int j2_mp_42_02_0b_dsc_prepare(struct drm_panel *panel)
 	struct drm_dsc_picture_parameter_set pps;
 	int ret;
 
-	if (ctx->prepared)
-		return 0;
-
-    ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
-    if (ret < 0) {
-        dev_err(dev, "Failed to enable regulators: %d\n", ret);
-        return ret;
-    }
-
 	j2_mp_42_02_0b_dsc_reset(ctx);
 
 	ret = j2_mp_42_02_0b_dsc_on(ctx);
@@ -217,7 +168,6 @@ static int j2_mp_42_02_0b_dsc_prepare(struct drm_panel *panel)
 
 	msleep(28); /* TODO: Is this panel-dependent? */
 
-	ctx->prepared = true;
 	return 0;
 }
 
@@ -227,21 +177,17 @@ static int j2_mp_42_02_0b_dsc_unprepare(struct drm_panel *panel)
 	struct device *dev = &ctx->dsi->dev;
 	int ret;
 
-	if (!ctx->prepared)
-		return 0;
-
 	ret = j2_mp_42_02_0b_dsc_off(ctx);
 	if (ret < 0)
 		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
 
 	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
 
-	ctx->prepared = false;
 	return 0;
 }
 
 static const struct drm_display_mode j2_mp_42_02_0b_dsc_mode = {
-	.clock = ((1080 + 16 + 8 + 8) * (2340 + 600 + 32 + 560) * 60 / 1000)*2,
+	.clock = (1080 + 16 + 8 + 8) * (2340 + 600 + 32 + 560) * 60 / 1000,
 	.hdisplay = 1080,
 	.hsync_start = 1080 + 16,
 	.hsync_end = 1080 + 16 + 8,
@@ -252,25 +198,13 @@ static const struct drm_display_mode j2_mp_42_02_0b_dsc_mode = {
 	.vtotal = 2340 + 600 + 32 + 560,
 	.width_mm = 710,
 	.height_mm = 1537,
+	.type = DRM_MODE_TYPE_DRIVER,
 };
 
 static int j2_mp_42_02_0b_dsc_get_modes(struct drm_panel *panel,
 					struct drm_connector *connector)
 {
-	struct drm_display_mode *mode;
-
-	mode = drm_mode_duplicate(connector->dev, &j2_mp_42_02_0b_dsc_mode);
-	if (!mode)
-		return -ENOMEM;
-
-	drm_mode_set_name(mode);
-
-	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
-	connector->display_info.width_mm = mode->width_mm;
-	connector->display_info.height_mm = mode->height_mm;
-	drm_mode_probed_add(connector, mode);
-
-	return 1;
+	return drm_connector_helper_get_modes_fixed(connector, &j2_mp_42_02_0b_dsc_mode);
 }
 
 static const struct drm_panel_funcs j2_mp_42_02_0b_dsc_panel_funcs = {
@@ -296,6 +230,8 @@ static int j2_mp_42_02_0b_dsc_bl_update_status(struct backlight_device *bl)
 	return 0;
 }
 
+// TODO: Check if /sys/class/backlight/.../actual_brightness actually returns
+// correct values. If not, remove this function.
 static int j2_mp_42_02_0b_dsc_bl_get_brightness(struct backlight_device *bl)
 {
 	struct mipi_dsi_device *dsi = bl_get_data(bl);
@@ -342,13 +278,6 @@ static int j2_mp_42_02_0b_dsc_probe(struct mipi_dsi_device *dsi)
 	if (!ctx)
 		return -ENOMEM;
 
-	ctx->supplies[0].supply = "vddio";
-    ret = devm_regulator_bulk_get(&dsi->dev, ARRAY_SIZE(ctx->supplies),
-            ctx->supplies);
-
-//    if (ret < 0)
-//        return dev_err_probe(dev, PTR_ERR(ctx->supplies), "Failed to get vddio.\n");
-
 	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
 	if (IS_ERR(ctx->reset_gpio))
 		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
@@ -394,9 +323,8 @@ static int j2_mp_42_02_0b_dsc_probe(struct mipi_dsi_device *dsi)
 
 	ret = mipi_dsi_attach(dsi);
 	if (ret < 0) {
-		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
 		drm_panel_remove(&ctx->panel);
-		return ret;
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
 	}
 
 	return 0;
@@ -430,6 +358,6 @@ static struct mipi_dsi_driver j2_mp_42_02_0b_dsc_driver = {
 };
 module_mipi_dsi_driver(j2_mp_42_02_0b_dsc_driver);
 
-MODULE_AUTHOR("KancyJoe <sunflower2333@outlook.com>");
+MODULE_AUTHOR("Linux mdss panel generator");
 MODULE_DESCRIPTION("DRM driver for xiaomi 42 02 0b cmd mode dsc dsi panel");
 MODULE_LICENSE("GPL");
-- 
2.43.0


From 29352236dd58f07ac78b2f3b183a403fa3d03b7a Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Wed, 27 Nov 2024 05:18:09 +0000
Subject: [PATCH 13/39] arm64/config: compile csot panels as module.

---
 arch/arm64/configs/q_defconfig | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/arch/arm64/configs/q_defconfig b/arch/arm64/configs/q_defconfig
index 0d257b295d95..586c0bdb4f46 100644
--- a/arch/arm64/configs/q_defconfig
+++ b/arch/arm64/configs/q_defconfig
@@ -606,12 +606,16 @@ CONFIG_DRM_I2C_SIL164=m
 CONFIG_DRM_I2C_NXP_TDA998X=m
 CONFIG_DRM_MSM=m
 CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=m
+CONFIG_DRM_PANEL_DSI_CM=m
+CONFIG_DRM_PANEL_LVDS=m
+CONFIG_DRM_PANEL_CSOT_MP42020B=m
 CONFIG_DRM_PANEL_EDP=m
 CONFIG_DRM_PANEL_SIMPLE=m
 CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA=m
 CONFIG_DRM_PANEL_VISIONOX_R66451=m
 CONFIG_DRM_PANEL_VISIONOX_RM69299=m
 CONFIG_DRM_PANEL_VISIONOX_VTDR6130=m
+CONFIG_DRM_PANEL_AYANEO_WT0600_2K=m
 CONFIG_DRM_DISPLAY_CONNECTOR=m
 CONFIG_DRM_LONTIUM_LT8912B=m
 CONFIG_DRM_LONTIUM_LT9611=m
-- 
2.43.0


From 2c3560c620d168a03ccd6f08a0a57f865a0626be Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Mon, 2 Dec 2024 13:57:18 +0000
Subject: [PATCH 14/39] arm64/config/qconfig: Update kernel config.

---
 arch/arm64/configs/q_defconfig | 44 +++++++++++++++++++++++++++++++++-
 1 file changed, 43 insertions(+), 1 deletion(-)

diff --git a/arch/arm64/configs/q_defconfig b/arch/arm64/configs/q_defconfig
index 586c0bdb4f46..1f395edd5b33 100644
--- a/arch/arm64/configs/q_defconfig
+++ b/arch/arm64/configs/q_defconfig
@@ -328,7 +328,9 @@ CONFIG_WCN36XX=m
 CONFIG_ATH11K=m
 CONFIG_ATH11K_AHB=m
 CONFIG_ATH11K_PCI=m
+CONFIG_ATH11K_DEBUG=y
 CONFIG_ATH12K=m
+CONFIG_ATH12K_DEBUG=y
 # CONFIG_WLAN_VENDOR_ATMEL is not set
 CONFIG_BRCMFMAC=m
 CONFIG_IWLWIFI=m
@@ -718,24 +720,28 @@ CONFIG_USB_CONN_GPIO=y
 CONFIG_USB_OTG=y
 CONFIG_USB_XHCI_HCD=y
 CONFIG_USB_XHCI_PCI_RENESAS=m
+CONFIG_USB_XHCI_PLATFORM=y
 CONFIG_USB_EHCI_HCD=y
 CONFIG_USB_EHCI_HCD_PLATFORM=y
 CONFIG_USB_OHCI_HCD=y
 CONFIG_USB_OHCI_HCD_PLATFORM=y
 CONFIG_USB_ACM=m
 CONFIG_USB_STORAGE=y
+CONFIG_USB_UAS=m
 CONFIG_USB_CDNS_SUPPORT=m
 CONFIG_USB_CDNS3=m
 CONFIG_USB_CDNS3_GADGET=y
 CONFIG_USB_CDNS3_HOST=y
 CONFIG_USB_MUSB_HDRC=y
-CONFIG_USB_DWC3=y
+CONFIG_USB_DWC3=m
+CONFIG_USB_DWC3_ULPI=y
 CONFIG_USB_DWC2=y
 CONFIG_USB_CHIPIDEA=y
 CONFIG_USB_CHIPIDEA_UDC=y
 CONFIG_USB_CHIPIDEA_HOST=y
 CONFIG_USB_ISP1760=y
 CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
 CONFIG_USB_SERIAL_CP210X=m
 CONFIG_USB_SERIAL_FTDI_SIO=m
 CONFIG_USB_SERIAL_OPTION=m
@@ -745,6 +751,7 @@ CONFIG_USB_ONBOARD_DEV=m
 CONFIG_NOP_USB_XCEIV=y
 CONFIG_USB_ULPI=y
 CONFIG_USB_GADGET=y
+CONFIG_U_SERIAL_CONSOLE=y
 CONFIG_USB_SNP_UDC_PLAT=y
 CONFIG_USB_BDC_UDC=y
 CONFIG_USB_CONFIGFS=m
@@ -758,7 +765,35 @@ CONFIG_USB_CONFIGFS_RNDIS=y
 CONFIG_USB_CONFIGFS_EEM=y
 CONFIG_USB_CONFIGFS_MASS_STORAGE=y
 CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_UAC1=y
+CONFIG_USB_CONFIGFS_F_UAC2=y
+CONFIG_USB_CONFIGFS_F_MIDI=y
+CONFIG_USB_CONFIGFS_F_MIDI2=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_CONFIGFS_F_UVC=y
+CONFIG_USB_CONFIGFS_F_PRINTER=y
+CONFIG_USB_ZERO=m
+CONFIG_USB_AUDIO=m
+CONFIG_GADGET_UAC1=y
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_EEM=y
+CONFIG_USB_G_NCM=m
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_FUNCTIONFS=m
+CONFIG_USB_FUNCTIONFS_ETH=y
+CONFIG_USB_FUNCTIONFS_RNDIS=y
+CONFIG_USB_FUNCTIONFS_GENERIC=y
 CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_MIDI_GADGET=m
+CONFIG_USB_G_PRINTER=m
+CONFIG_USB_CDC_COMPOSITE=m
+CONFIG_USB_G_ACM_MS=m
+CONFIG_USB_G_MULTI=m
+CONFIG_USB_G_MULTI_CDC=y
+CONFIG_USB_G_HID=m
+CONFIG_USB_G_DBGP=m
+CONFIG_USB_G_WEBCAM=m
+CONFIG_USB_RAW_GADGET=m
 CONFIG_TYPEC=m
 CONFIG_TYPEC_TCPM=m
 CONFIG_TYPEC_TCPCI=m
@@ -772,6 +807,7 @@ CONFIG_TYPEC_HD3SS3220=m
 CONFIG_TYPEC_MUX_FSA4480=m
 CONFIG_TYPEC_MUX_GPIO_SBU=m
 CONFIG_TYPEC_MUX_NB7VPQ904M=m
+CONFIG_TYPEC_MUX_PTN36502=m
 CONFIG_TYPEC_MUX_WCD939X_USBSS=m
 CONFIG_TYPEC_DP_ALTMODE=m
 CONFIG_MMC=y
@@ -986,7 +1022,9 @@ CONFIG_QCOM_RPMHPD=y
 CONFIG_QCOM_RPMPD=y
 CONFIG_DEVFREQ_GOV_USERSPACE=y
 CONFIG_DEVFREQ_GOV_PASSIVE=m
+CONFIG_EXTCON_GPIO=m
 CONFIG_EXTCON_PTN5150=m
+CONFIG_EXTCON_QCOM_SPMI_MISC=m
 CONFIG_EXTCON_USB_GPIO=y
 CONFIG_EXTCON_USBC_CROS_EC=y
 CONFIG_MEMORY=y
@@ -1089,6 +1127,10 @@ CONFIG_TMPFS_POSIX_ACL=y
 CONFIG_HUGETLBFS=y
 CONFIG_EFIVAR_FS=y
 CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_LZ4=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_ZSTD=y
 CONFIG_PSTORE_RAM=m
 CONFIG_NFS_FS=y
 CONFIG_NFS_V4=y
-- 
2.43.0


From 1bab516ca72675ac3683a030fe796be87f993dd0 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Mon, 2 Dec 2024 13:58:06 +0000
Subject: [PATCH 15/39] driver: drm/panel: Fix panel for xiaomi 10.

---
 .../gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c  | 23 ++++++++++++-------
 1 file changed, 15 insertions(+), 8 deletions(-)

diff --git a/drivers/gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c b/drivers/gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c
index 17ec7944bb46..bf3fdc1f3265 100644
--- a/drivers/gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c
+++ b/drivers/gpu/drm/panel/panel-j2-mp-42-02-0b-dsc.c
@@ -21,6 +21,7 @@ struct j2_mp_42_02_0b_dsc {
 	struct mipi_dsi_device *dsi;
 	struct drm_dsc_config dsc;
 	struct gpio_desc *reset_gpio;
+	struct gpio_desc *disprate_gpio;
 };
 
 static inline
@@ -99,7 +100,7 @@ static int j2_mp_42_02_0b_dsc_on(struct j2_mp_42_02_0b_dsc *ctx)
 				     0x0e, 0x01, 0x1f, 0x00, 0x07, 0x08, 0xbb,
 				     0x08, 0x7a, 0x10, 0xf0);
 	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x03, 0x11);
-	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x2c);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x2c, 0x00);
 	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x35, 0x00);
 	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x53, 0x20);
 	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x51, 0x00, 0x00, 0x00, 0x00);
@@ -116,7 +117,7 @@ static int j2_mp_42_02_0b_dsc_on(struct j2_mp_42_02_0b_dsc *ctx)
 	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x2f, 0x01);
 	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x26, 0x01);
 	mipi_dsi_dcs_exit_sleep_mode_multi(&dsi_ctx);
-	mipi_dsi_msleep(&dsi_ctx, 100);
+	mipi_dsi_msleep(&dsi_ctx, 180);
 	mipi_dsi_dcs_set_display_on_multi(&dsi_ctx);
 	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xf0,
 				     0x55, 0xaa, 0x52, 0x08, 0x00);
@@ -160,13 +161,14 @@ static int j2_mp_42_02_0b_dsc_prepare(struct drm_panel *panel)
 		return ret;
 	}
 
-	ret = mipi_dsi_compression_mode(ctx->dsi, true);
-	if (ret < 0) {
-		dev_err(dev, "failed to enable compression mode: %d\n", ret);
-		return ret;
-	}
+//	ret = mipi_dsi_compression_mode(ctx->dsi, true);
+//	if (ret < 0) {
+//		dev_err(dev, "failed to enable compression mode: %d\n", ret);
+//		return ret;
+//	}
 
-	msleep(28); /* TODO: Is this panel-dependent? */
+	msleep(128); /* TODO: Is this panel-dependent? */
+	gpiod_set_value_cansleep(ctx->disprate_gpio, 1);
 
 	return 0;
 }
@@ -283,6 +285,11 @@ static int j2_mp_42_02_0b_dsc_probe(struct mipi_dsi_device *dsi)
 		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
 				     "Failed to get reset-gpios\n");
 
+	ctx->disprate_gpio = devm_gpiod_get(dev, "disprate", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->disprate_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->disprate_gpio),
+				     "Failed to get disprate-gpios\n");
+
 	ctx->dsi = dsi;
 	mipi_dsi_set_drvdata(dsi, ctx);
 
-- 
2.43.0


From 0f6ffe87bfb17aadff080e94fc43166e5c30ca7f Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Mon, 2 Dec 2024 13:58:47 +0000
Subject: [PATCH 16/39] arm64/dts/qcom: Add xiaomi 10 device tree draft.

---
 .../arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts | 1574 +++++++++++++++++
 1 file changed, 1574 insertions(+)
 create mode 100644 arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts

diff --git a/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts b/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts
new file mode 100644
index 000000000000..3b12c2b36dc8
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts
@@ -0,0 +1,1574 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/regulator/qcom,rpmh-regulator.h>
+#include <dt-bindings/sound/qcom,q6afe.h>
+#include <dt-bindings/sound/qcom,q6asm.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/usb/pd.h>
+#include "sm8250.dtsi"
+#include "pm8150.dtsi"
+#include "pm8150b.dtsi"
+#include "pm8150l.dtsi"
+#include "pm8009.dtsi"
+
+/delete-node/ &adsp_mem;
+/delete-node/ &cdsp_secure_heap;
+/delete-node/ &slpi_mem;
+/delete-node/ &spss_mem;
+/delete-node/ &xbl_aop_mem;
+
+/ {
+	model = "Xiaomi Technologies, Inc. Mi10";
+	compatible = "qcom,sm8250-mtp", "qcom,sm8250";
+	chassis-type = "handset";
+    qcom,msm-id = <0x164 0x20001>;
+	qcom,board-id = <0x2b 0x00>;
+
+	aliases {
+		serial0 = &uart12;
+		serial1 = &uart6;
+	};
+
+	wcd938x: audio-codec {
+		compatible = "qcom,wcd9380-codec";
+		status = "okay";
+		reset-gpios = <&tlmm 32 GPIO_ACTIVE_LOW>;
+
+		vdd-buck-supply = <&vreg_s4a_1p8>;
+		vdd-rxtx-supply = <&vreg_s4a_1p8>;
+		vdd-io-supply = <&vreg_s4a_1p8>;
+		vdd-mic-bias-supply = <&vreg_bob>;
+
+		qcom,micbias1-microvolt = <1800000>;
+		qcom,micbias2-microvolt = <1800000>;
+		qcom,micbias3-microvolt = <1800000>;
+		qcom,micbias4-microvolt = <1800000>;
+		qcom,mbhc-buttons-vthreshold-microvolt = <75000 150000 237000 500000 500000 500000 500000 500000>;
+		qcom,mbhc-headset-vthreshold-microvolt = <1700000>;
+		qcom,mbhc-headphone-vthreshold-microvolt = <50000>;
+		qcom,rx-device = <&wcd_rx>;
+		qcom,tx-device = <&wcd_tx>;
+
+		#sound-dai-cells = <1>;
+	};
+
+	chosen {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		// stdout-path = "serial0:115200n8";
+		stdout-path = "display0";
+		bootargs = "pd_ignore_unused clk_ignore_unused panic=30 loglevel=7 console=ttyS0,115200 console=tty1 rootfs_part=sda36 root=/dev/sda36 rw systemd.journald.forward_to_console=true systemd.log_level=debug systemd.log_target=kmsg log_buf_len=10M printk.devkmsg=on";
+		//  pd_ignore_unused clk_ignore_unused 
+		display0: framebuffer@9c000000 {
+			compatible = "simple-framebuffer";
+			reg = <0x0 0x9c000000 0x0 0x2300000>;
+			width = <1080>;
+			height = <2340>;
+			stride = <(1080 * 4)>;
+			format = "a8r8g8b8";
+			/*
+			 * That's a lot of clocks, but it's necessary due
+			 * to unused clk cleanup & no panel driver yet..
+			 */
+			// clocks = <&dispcc DISP_CC_MDSS_AHB_CLK>,
+			// 	 <&gcc GCC_DISP_HF_AXI_CLK>,
+			// 	 <&gcc GCC_DISP_SF_AXI_CLK>,
+			// 	 <&dispcc DISP_CC_MDSS_VSYNC_CLK>,
+			// 	 <&dispcc DISP_CC_MDSS_MDP_CLK>,
+			// 	 <&dispcc DISP_CC_MDSS_BYTE0_CLK>,
+			// 	 <&dispcc DISP_CC_MDSS_BYTE0_INTF_CLK>,
+			// 	 <&dispcc DISP_CC_MDSS_PCLK0_CLK>,
+			// 	 <&dispcc DISP_CC_MDSS_ESC0_CLK>;
+			// power-domains = <&dispcc MDSS_GDSC>;
+		};
+	};
+
+	qca6390-pmu {
+		compatible = "qcom,qca6390-pmu";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&bt_en_state>, <&wlan_en_state>, <&mdm2ap_default>, <&ap2mdm_default>, <&ap2mdm_active>;
+
+		vddaon-supply = <&vreg_s6a_0p95>;
+		vddpmu-supply = <&vreg_s2f_0p95>;
+		vddrfa0p95-supply = <&vreg_s2f_0p95>;
+		vddrfa1p3-supply = <&vreg_s8c_1p3>;
+		vddrfa1p9-supply = <&vreg_s5a_1p9>;
+		vddpcie1p3-supply = <&vreg_s8c_1p3>;
+		vddpcie1p9-supply = <&vreg_s5a_1p9>;
+		vddio-supply = <&vreg_s4a_1p8>;
+
+		wlan-enable-gpios = <&tlmm 20 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 21 GPIO_ACTIVE_HIGH>;
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p7: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p7";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
+
+	thermal-zones {
+		camera-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&pm8150l_adc_tm 0>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+
+		conn-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&pm8150b_adc_tm 0>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+
+		mmw-pa1-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&pm8150_adc_tm 2>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+
+		mmw-pa2-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&pm8150l_adc_tm 2>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+
+		skin-msm-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&pm8150l_adc_tm 1>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+
+		skin-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&pm8150_adc_tm 1>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+
+		xo-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&pm8150_adc_tm 0>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "passive";
+				};
+			};
+		};
+	};
+
+	vph_pwr: vph-pwr-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vph_pwr";
+		regulator-min-microvolt = <3700000>;
+		regulator-max-microvolt = <3700000>;
+	};
+
+	vreg_s4a_1p8: pm8150-s4 {
+		compatible = "regulator-fixed";
+		regulator-name = "vreg_s4a_1p8";
+
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+
+		regulator-always-on;
+		regulator-boot-on;
+
+		vin-supply = <&vph_pwr>;
+	};
+
+	vreg_s6c_0p88: smpc6-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vreg_s6c_0p88";
+
+		regulator-min-microvolt = <880000>;
+		regulator-max-microvolt = <880000>;
+		regulator-always-on;
+		vin-supply = <&vph_pwr>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		key-vol-up {
+			label = "Volume Up";
+			linux,code = <KEY_VOLUMEUP>;
+			gpios = <&pm8150_gpios 6 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	vdd_boost_vreg: vdd_boost_vreg {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_boost_vreg";
+		startup-delay-us = <4000>;
+		enable-active-high;
+		regulator-always-on;
+		gpio = <&pm8150b_gpios 5 0>;
+	 };
+
+	ext_5v_boost: ext-5v-boost {
+		compatible = "regulator-fixed";
+		status = "okay";
+		regulator-name = "ext_5v_boost";
+		gpio = <&pm8150b_gpios 12 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-enable-ramp-delay = <1600>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&otg_vbus_boost>;
+	};
+
+	touch_vddio_vreg: touch_vddio_vreg {
+		status = "okay";
+		compatible = "regulator-fixed";
+		regulator-name = "disp_vddio_vreg";
+		enable-active-high;
+		gpio = <&tlmm 69 0>;
+	};
+
+	xiaomi_touch: xiaomi_touch {
+		compatible = "xiaomi-touch";
+		status = "ok";
+		touch,name = "xiaomi-touch";
+	};
+
+	reserved-memory {
+		xbl_aop_mem: memory@80600000 {
+			reg = <0x0 0x80600000 0x0 0x260000>;
+			no-map;
+		};
+
+		xbl_uefi_log: memory@80880000 {
+			reg = <0x0 0x80880000 0x0 0x14000>;
+			no-map;
+		};
+
+		slpi_mem: memory@88c00000 {
+			reg = <0x0 0x88c00000 0x0 0x2f00000>;
+			no-map;
+		};
+
+		adsp_mem: memory@8bb00000 {
+			reg = <0x0 0x8bb00000 0x0 0x2500000>;
+			no-map;
+		};
+
+		spss_mem: memory@8e000000 {
+			reg = <0x0 0x8e000000 0x0 0x100000>;
+			no-map;
+		};
+
+		cdsp_secure_heap: memory@8e100000 {
+			reg = <0x0 0x8e100000 0x0 0x4600000>;
+			no-map;
+		};
+		
+		dfps_data_region: memory@9e300000 {
+			reg = <0x0 0x9e300000 0x0 0x100000>;
+			no-map;
+		};
+
+		disp_rdump_region: memory@b0400000 {
+			reg = <0x0 0xb0400000 0x0 0x1000000>;
+			no-map;
+		};
+
+		cont_splash_region@9c000000 {
+			reg = <0x0 0x9c000000 0x0 0x2300000>;
+			label = "cont_splash_region";
+			no-map;
+		};
+	};
+};
+
+&pm8150b_vbus {
+	regulator-min-microamp = <500000>;
+	regulator-max-microamp = <3000000>;
+	status = "okay";
+};
+
+&pon_pwrkey {
+	status = "okay";
+};
+
+&pon_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+&adsp {
+	status = "okay";
+	firmware-name = "qcom/sm8250/umi/adsp.mbn";
+};
+
+// &cpu0 {
+// 	capacity-dmips-mhz = <1024>;
+// 	dynamic-power-coefficient = <100>;
+// };
+
+// &cpu1 {
+// 	capacity-dmips-mhz = <1024>;
+// 	dynamic-power-coefficient = <100>;
+
+// };
+
+// &cpu2 {
+// 	capacity-dmips-mhz = <1024>;
+// 	dynamic-power-coefficient = <100>;
+// };
+
+// &cpu3 {
+// 	capacity-dmips-mhz = <1024>;
+// 	dynamic-power-coefficient = <100>;
+// };
+
+// &cpu4 {
+// 	capacity-dmips-mhz = <1894>;
+// 	dynamic-power-coefficient = <533>;
+// };
+
+// &cpu5 {
+// 	capacity-dmips-mhz = <1894>;
+// 	dynamic-power-coefficient = <533>;
+// };
+
+// &cpu6 {
+// 	capacity-dmips-mhz = <1894>;
+// 	dynamic-power-coefficient = <533>;
+// };
+
+// &cpu7 {
+// 	capacity-dmips-mhz = <1894>;
+// 	dynamic-power-coefficient = <642>;
+// };
+
+&apps_rsc {
+	regulators-0 {
+		compatible = "qcom,pm8150-rpmh-regulators";
+		qcom,pmic-id = "a";
+
+		vdd-s1-supply = <&vph_pwr>;
+		vdd-s2-supply = <&vph_pwr>;
+		vdd-s3-supply = <&vph_pwr>;
+		vdd-s4-supply = <&vph_pwr>;
+		vdd-s5-supply = <&vph_pwr>;
+		vdd-s6-supply = <&vph_pwr>;
+		vdd-s7-supply = <&vph_pwr>;
+		vdd-s8-supply = <&vph_pwr>;
+		vdd-s9-supply = <&vph_pwr>;
+		vdd-s10-supply = <&vph_pwr>;
+		vdd-l1-l8-l11-supply = <&vreg_s6c_0p88>;
+		vdd-l2-l10-supply = <&vreg_bob>;
+		vdd-l3-l4-l5-l18-supply = <&vreg_s6a_0p95>;
+		vdd-l6-l9-supply = <&vreg_s8c_1p3>;
+		vdd-l7-l12-l14-l15-supply = <&vreg_s5a_1p9>;
+		vdd-l13-l16-l17-supply = <&vreg_bob>;
+
+		vreg_s5a_1p9: smps5 {
+			regulator-name = "vreg_s5a_1p9";
+			regulator-min-microvolt = <1904000>;
+			regulator-max-microvolt = <2000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_s6a_0p95: smps6 {
+			regulator-name = "vreg_s6a_0p95";
+			regulator-min-microvolt = <920000>;
+			regulator-max-microvolt = <1128000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l2a_3p1: ldo2 {
+			regulator-name = "vreg_l2a_3p1";
+			regulator-min-microvolt = <3072000>;
+			regulator-max-microvolt = <3072000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3a_0p9: ldo3 {
+			regulator-name = "vreg_l3a_0p9";
+			regulator-min-microvolt = <928000>;
+			regulator-max-microvolt = <932000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l5a_0p875: ldo5 {
+			regulator-name = "vreg_l5a_0p875";
+			regulator-min-microvolt = <880000>;
+			regulator-max-microvolt = <880000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l6a_1p2: ldo6 {
+			regulator-name = "vreg_l6a_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7a_1p7: ldo7 {
+			regulator-name = "vreg_l7a_1p7";
+			regulator-min-microvolt = <1704000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l9a_1p2: ldo9 {
+			regulator-name = "vreg_l9a_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l10a_1p8: ldo10 {
+			regulator-name = "vreg_l10a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l12a_1p8: ldo12 {
+			regulator-name = "vreg_l12a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l13a_ts_3p0: ldo13 {
+			regulator-name = "vreg_l13a_ts_3p0";
+			regulator-min-microvolt = <3008000>;
+			regulator-max-microvolt = <3008000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l14a_1p8: ldo14 {
+			regulator-name = "vreg_l14a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1880000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l15a_11ad_io_1p8: ldo15 {
+			regulator-name = "vreg_l15a_11ad_io_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l16a_2p7: ldo16 {
+			regulator-name = "vreg_l16a_2p7";
+			regulator-min-microvolt = <2704000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l17a_3p0: ldo17 {
+			regulator-name = "vreg_l17a_3p0";
+			regulator-min-microvolt = <2856000>;
+			regulator-max-microvolt = <3008000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l18a_0p9: ldo18 {
+			regulator-name = "vreg_l18a_0p9";
+			regulator-min-microvolt = <912000>;
+			regulator-max-microvolt = <912000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+
+	regulators-1 {
+		compatible = "qcom,pm8150l-rpmh-regulators";
+		qcom,pmic-id = "c";
+
+		vdd-s1-supply = <&vph_pwr>;
+		vdd-s2-supply = <&vph_pwr>;
+		vdd-s3-supply = <&vph_pwr>;
+		vdd-s4-supply = <&vph_pwr>;
+		vdd-s5-supply = <&vph_pwr>;
+		vdd-s6-supply = <&vph_pwr>;
+		vdd-s7-supply = <&vph_pwr>;
+		vdd-s8-supply = <&vph_pwr>;
+		vdd-l1-l8-supply = <&vreg_s4a_1p8>;
+		vdd-l2-l3-supply = <&vreg_s8c_1p3>;
+		vdd-l4-l5-l6-supply = <&vreg_bob>;
+		vdd-l7-l11-supply = <&vreg_bob>;
+		vdd-l9-l10-supply = <&vreg_bob>;
+		vdd-bob-supply = <&vph_pwr>;
+
+		vreg_bob: bob {
+			regulator-name = "vreg_bob";
+			regulator-min-microvolt = <3008000>;
+			regulator-max-microvolt = <4000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_AUTO>;
+		};
+
+		vreg_s8c_1p3: smps8 {
+			regulator-name = "vreg_s8c_1p3";
+			regulator-min-microvolt = <1352000>;
+			regulator-max-microvolt = <1352000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l1c_1p8: ldo1 {
+			regulator-name = "vreg_l1c_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l2c_1p2: ldo2 {
+			regulator-name = "vreg_l2c_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3c_0p92: ldo3 {
+			regulator-name = "vreg_l3c_0p92";
+			regulator-min-microvolt = <920000>;
+			regulator-max-microvolt = <920000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l4c_1p7: ldo4 {
+			regulator-name = "vreg_l4c_1p7";
+			regulator-min-microvolt = <1704000>;
+			regulator-max-microvolt = <2928000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l5c_1p8: ldo5 {
+			regulator-name = "vreg_l5c_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2928000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l6c_2p9: ldo6 {
+			regulator-name = "vreg_l6c_2p9";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7c_cam_vcm0_2p85: ldo7 {
+			regulator-name = "vreg_l7c_cam_vcm0_2p85";
+			regulator-min-microvolt = <2856000>;
+			regulator-max-microvolt = <3104000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l8c_1p8: ldo8 {
+			regulator-name = "vreg_l8c_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l9c_2p9: ldo9 {
+			regulator-name = "vreg_l9c_2p9";
+			regulator-min-microvolt = <2704000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l10c_3p0: ldo10 {
+			regulator-name = "vreg_l10c_3p0";
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l11c_3p3: ldo11 {
+			regulator-name = "vreg_l11c_3p3";
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3312000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+
+	regulators-2 {
+		compatible = "qcom,pm8009-rpmh-regulators";
+		qcom,pmic-id = "f";
+
+		vdd-s1-supply = <&vph_pwr>;
+		vdd-s2-supply = <&vreg_bob>;
+		vdd-l2-supply = <&vreg_s8c_1p3>;
+		vdd-l5-l6-supply = <&vreg_bob>;
+		vdd-l7-supply = <&vreg_s4a_1p8>;
+
+		vreg_s2f_0p95: smps2 {
+			regulator-name = "vreg_s2f_0p95";
+			regulator-min-microvolt = <900000>;
+			regulator-max-microvolt = <952000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_AUTO>;
+		};
+
+		vreg_l1f_cam_dvdd1_1p1: ldo1 {
+			regulator-name = "vreg_l1f_cam_dvdd1_1p1";
+			regulator-min-microvolt = <1104000>;
+			regulator-max-microvolt = <1104000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l2f_cam_dvdd0_1p2: ldo2 {
+			regulator-name = "vreg_l2f_cam_dvdd0_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3f_cam_dvdd2_1p05: ldo3 {
+			regulator-name = "vreg_l3f_cam_dvdd2_1p05";
+			regulator-min-microvolt = <1056000>;
+			regulator-max-microvolt = <1056000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l5f_cam_avdd0_2p85: ldo5 {
+			regulator-name = "vreg_l5f_cam_avdd0_2p85";
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <2800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l6f_cam_avdd1_2p85: ldo6 {
+			regulator-name = "vreg_l6f_cam_avdd1_2p85";
+			regulator-min-microvolt = <2856000>;
+			regulator-max-microvolt = <2856000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7f_1p8: ldo7 {
+			regulator-name = "vreg_l7f_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+};
+
+&cdsp {
+	status = "okay";
+	firmware-name = "qcom/sm8250/umi/cdsp.mbn";
+};
+
+&venus {
+	status = "okay";
+	firmware-name = "qcom/sm8250/umi/venus.mbn";
+};
+
+&gmu {
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+
+	zap-shader {
+		memory-region = <&gpu_mem>;
+		firmware-name = "qcom/sm8250/umi/a650_zap.mbn";
+	};
+};
+
+&i2c1 {
+	status = "disabled";
+
+	// nfc@28 {
+	// 	compatible = "nxp,nxp-nci-i2c";
+	// 	reg = <0x28>;
+	// 	interrupt-parent = <&tlmm>;
+	// 	interrupts = <111 IRQ_TYPE_EDGE_RISING>;
+	// 	enable-gpios = <&tlmm 83 GPIO_ACTIVE_HIGH>;
+	// 	firmware-gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
+	// };
+};
+
+&spi2 {
+	status = "okay";
+	spi-max-frequency = <0x124f800>;
+
+	ir-spi@0 {
+		compatible = "ir-spi";
+		reg = <0x00>;
+		status = "ok";
+	};
+};
+
+&i2c3 {
+	status = "okay";
+	clock-frequency = <1000000>;
+
+	cs35l41_l: speaker-amp@40 {
+		compatible = "cirrus,cs35l41";
+		reg = <0x40>;
+		interrupt-parent = <&tlmm>;
+		interrupts = <113 IRQ_TYPE_LEVEL_LOW>;
+		reset-gpios = <&tlmm 114 GPIO_ACTIVE_HIGH>;
+		cirrus,boost-peak-milliamp = <4000>;
+		cirrus,boost-ind-nanohenry = <1000>;
+		cirrus,boost-cap-microfarad = <15>;
+		cirrus,asp-sdout-hiz = <1>;
+		cirrus,gpio2-src-select = <4>;
+		cirrus,gpio2-output-enable;
+		#sound-dai-cells = <1>;
+	};
+
+	cs35l41_r: speaker-amp@42 {
+		compatible = "cirrus,cs35l41";
+		reg = <0x42>;
+		status = "disabled";
+		interrupt-parent = <&tlmm>;
+		interrupts = <112 IRQ_TYPE_LEVEL_LOW>;
+		reset-gpios = <&tlmm 114 GPIO_ACTIVE_HIGH>;
+		cirrus,boost-peak-milliamp = <4000>;
+		cirrus,boost-ind-nanohenry = <1000>;
+		cirrus,boost-cap-microfarad = <15>;
+		cirrus,asp-sdout-hiz = <1>;
+		cirrus,gpio2-src-select = <4>;
+		cirrus,gpio2-output-enable;
+		#sound-dai-cells = <1>;
+	};
+};
+
+&i2c13 {
+	clock-frequency = <400000>;
+	status = "disabled";
+
+	/* st,stmfts @ 49 */
+	fts@49 {
+		status = "disabled";
+		compatible = "st,fts";
+		reg = <0x49>;
+		interrupt-parent = <&tlmm>;
+		interrupts = <39 0x2008>;
+		pinctrl-names = "pmx_ts_active", "pmx_ts_suspend";
+		pinctrl-0 = <&ts_active>;
+		pinctrl-1 = <&ts_int_suspend &ts_reset_suspend>;
+		avdd-supply = <&touch_vddio_vreg>;
+		vdd-supply = <&vreg_l5a_0p875>;
+		fts,pwr-reg-name = "avdd";
+		fts,bus-reg-name = "vdd";
+		fts,irq-gpio = <&tlmm 39 0x2008>;
+		fts,irq-gpio-name = "fts_irq";
+		fts,reset-gpio-enable;
+		fts,reset-gpio = <&tlmm 38 0x00>;
+		fts,reset-gpio-name = "fts_rst";
+		fts,irq-flags = <0x2008>; /* IRQF_ONESHOT | IRQF_TRIGGER_LOW */
+		fts,x-max = <1080>;
+		fts,y-max = <2340>;
+		fts,fod-lx = <421>;
+		fts,fod-ly = <1788>;
+		fts,fod-x-size = <238>;
+		fts,fod-y-size = <238>;
+		fts,default-fw-name = "st_fts_j2.ftb";
+		fts,config-array-size = <2>;
+		fts,dump-click-count;
+		fts,support-fod;
+		fts,touch-up-threshold-min = <40>;
+		fts,touch-up-threshold-max = <120>;
+		fts,touch-up-threshold-def = <80>;
+		fts,touch-tolerance-min = <5>;
+		fts,touch-tolerance-max = <35>;
+		fts,touch-tolerance-def = <25>;
+		fts,touch-idletime-min = <0>;
+		fts,touch-idletime-max = <12750>;
+		fts,touch-idletime-def = <12450>;
+
+		/*edge filter rects in gamemode*/
+		fts,cornerfilter-area-step1 = <100>;
+		fts,cornerfilter-area-step2 = <170>;
+		fts,cornerfilter-area-step3 = <250>;
+		fts,touch-deadzone-filter-ver = <2 0 0 0 0 0 0 0
+							2 1 0 0 0 0 0 0
+							2 2 0 0 5 2339 0 0
+							2 3 1074 0 1079 2339 0 0>;
+		fts,touch-deadzone-filter-hor = <2 0 0 0 1079 5 0 0
+							2 1 0 2334 1079 2339 0 0
+							2 2 0 0 5 2339 0 0
+							2 3 1074 0 1079 2339 0 0>;
+		fts,touch-edgezone-filter-ver = <1 0 0 0 0 0 0 0
+							1 1 0 0 0 0 0 0
+							1 2 0 0 40 2339 0 0
+							1 3 1039 0 1079 2339 0 0>;
+		fts,touch-edgezone-filter-hor = <1 0 0 0 1079 40 0 0
+							1 1 0 2299 1079 2339 0 0
+							1 2 0 0 40 2339 0 0
+							1 3 1039 0 1079 2339 0 0>;
+		fts,touch-cornerzone-filter-ver = <0 0 0 0 0 0 0 0
+							0 1 0 0 0 0 0 0
+							0 2 0 2039 150 2339 0 0
+							0 3 929 2039 1079 2339 0 0>;
+		fts,touch-cornerzone-filter-hor1 = <0 0 0 0 170 170 0 0
+							0 1 0 0 0 0 0 0
+							0 2 0 2169 170 2339 0 0
+							0 3 0 0 0 0 0 0>;
+		fts,touch-cornerzone-filter-hor2 = <0 0 0 0 0 0 0 0
+							0 1 909 0 1079 170 0 0
+							0 2 0 0 0 0 0 0
+							0 3 909 2169 1079 2339 0 0>;
+		fts,cfg_0 {
+			fts,tp-vendor = <0x38>;
+			fts,tp-module = <0>;
+			fts,fw-name = "st_fts_j2_1.ftb";
+			fts,limit-name = "stm_fts_production_limits_1.csv";
+		};
+		fts,cfg_1 {
+			fts,tp-vendor = <0x42>;
+			fts,tp-module = <1>;
+			fts,fw-name = "st_fts_j2_2.ftb";
+			fts,limit-name = "stm_fts_production_limits_2.csv";
+		};
+	};
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dp {
+	status = "okay";
+};
+
+&mdss_dp_out {
+	data-lanes = <0 1>;
+	remote-endpoint = <&usb_1_qmpphy_dp_in>;
+};
+
+&mdss_dsi0_out {
+	remote-endpoint = <&panel_in_0>;
+	data-lanes = <0 1 2 3>;
+};
+
+&mdss_dsi0_phy {
+	vdds-supply = <&vreg_l5a_0p875>;
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	vdda-supply = <&vreg_l9a_1p2>;
+	status = "okay";
+
+	display_panel: panel@0 {
+		reg = <0>;
+		compatible = "csot,j2-mp-42-02-0b-dsc";
+		vddio-supply = <&vreg_l14a_1p8>;
+		reset-gpios = <&tlmm 12 GPIO_ACTIVE_LOW>;
+		disprate-gpios = <&tlmm 50 GPIO_ACTIVE_HIGH>;
+		
+		pinctrl-names = "default";
+		pinctrl-0 = <&panel_default>, <&te_default>;
+
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				panel_in_0: endpoint {
+					remote-endpoint = <&mdss_dsi0_out>;
+				};
+			};
+		};
+	};
+};
+
+&pcie0 {
+	status = "okay";
+};
+
+&pcie0_phy {
+	vdda-phy-supply = <&vreg_l5a_0p875>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+	status = "okay";
+};
+
+&pcieport0 {
+	wifi@0 {
+		compatible = "pci17cb,1101";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p7-supply = <&vreg_pmu_rfa_1p7>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
+&pcie2 {
+	status = "okay";
+	pinctrl-0 = <&pcie2_default_state>;
+	// &mdm2ap_default &ap2mdm_default &ap2mdm_active
+};
+
+&pcie2_phy {
+	vdda-phy-supply = <&vreg_l5a_0p875>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+	status = "okay";
+};
+
+&pm8150_adc {
+	channel@4c {
+		reg = <ADC5_XO_THERM_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "xo_therm";
+	};
+
+	channel@4d {
+		reg = <ADC5_AMUX_THM1_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "skin_therm";
+	};
+
+	channel@4e {
+		reg = <ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "pa_therm1";
+	};
+};
+
+&pm8150_adc_tm {
+	status = "okay";
+
+	xo-therm@0 {
+		reg = <0>;
+		io-channels = <&pm8150_adc ADC5_XO_THERM_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+
+	skin-therm@1 {
+		reg = <1>;
+		io-channels = <&pm8150_adc ADC5_AMUX_THM1_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+
+	pa-therm1@2 {
+		reg = <2>;
+		io-channels = <&pm8150_adc ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+};
+
+&pm8150b_adc {
+	channel@4f {
+		reg = <ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "conn_therm";
+	};
+};
+
+&pm8150b_adc_tm {
+	status = "okay";
+
+	conn-therm@0 {
+		reg = <0>;
+		io-channels = <&pm8150b_adc ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+};
+
+&pm8150l_adc_tm {
+	status = "okay";
+
+	camera-flash-therm@0 {
+		reg = <0>;
+		io-channels = <&pm8150l_adc ADC5_AMUX_THM1_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+
+	skin-msm-therm@1 {
+		reg = <1>;
+		io-channels = <&pm8150l_adc ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+
+	pa-therm2@2 {
+		reg = <2>;
+		io-channels = <&pm8150l_adc ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+};
+
+&pm8150l_adc {
+	channel@4d {
+		reg = <ADC5_AMUX_THM1_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "camera_flash_therm";
+	};
+
+	channel@4e {
+		reg = <ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "skin_msm_therm";
+	};
+
+	channel@4f {
+		reg = <ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "pa_therm2";
+	};
+};
+
+&gpi_dma0 {
+	status = "okay";
+};
+
+&gpi_dma1 {
+	status = "okay";
+};
+
+&gpi_dma2 {
+	status = "okay";
+};
+
+&qupv3_id_0 {
+	status = "okay";
+};
+
+&qupv3_id_1 {
+	status = "okay";
+};
+
+&qupv3_id_2 {
+	status = "okay";
+};
+
+&rxmacro {
+	status = "okay";
+};
+
+&slpi {
+	status = "disabled";
+	firmware-name = "qcom/sm8250/umi/slpi.mbn";
+};
+
+&sound {
+	status = "okay";
+	compatible = "qcom,sm8250-sndcard";
+	model = "XIAOMI-UMI-WCD9380-CS35L41-VA-DMIC";
+	pinctrl-names = "default";
+	pinctrl-0 = <&tert_mi2s_active>;
+	audio-routing =
+		"SPK", "Main AMP",
+		"IN1_HPHL", "HPHL_OUT",
+		"IN2_HPHR", "HPHR_OUT",
+		"AMIC1", "MIC BIAS1",
+		"AMIC2", "MIC BIAS2",
+		"AMIC3", "MIC BIAS3",
+		"AMIC4", "MIC BIAS3",
+		"AMIC5", "MIC BIAS4",
+		"TX SWR_ADC0", "ADC1_OUTPUT",
+		"TX SWR_ADC1", "ADC2_OUTPUT",
+		"TX SWR_ADC2", "ADC3_OUTPUT",
+		"TX SWR_ADC3", "ADC4_OUTPUT",
+		"TX SWR_DMIC0", "DMIC1_OUTPUT",
+		"TX SWR_DMIC1", "DMIC2_OUTPUT",
+		"TX SWR_DMIC2", "DMIC3_OUTPUT",
+		"TX SWR_DMIC3", "DMIC4_OUTPUT",
+		"TX SWR_DMIC4", "DMIC5_OUTPUT",
+		"TX SWR_DMIC5", "DMIC6_OUTPUT",
+		"TX SWR_DMIC6", "DMIC7_OUTPUT",
+		"TX SWR_DMIC7", "DMIC8_OUTPUT";
+
+	mm1-dai-link {
+		link-name = "MultiMedia1";
+		cpu {
+			sound-dai = <&q6asmdai  MSM_FRONTEND_DAI_MULTIMEDIA1>;
+		};
+	};
+
+	mm2-dai-link {
+		link-name = "MultiMedia2";
+		cpu {
+			sound-dai = <&q6asmdai  MSM_FRONTEND_DAI_MULTIMEDIA2>;
+		};
+	};
+
+	mm3-dai-link {
+		link-name = "MultiMedia3";
+		cpu {
+			sound-dai = <&q6asmdai  MSM_FRONTEND_DAI_MULTIMEDIA3>;
+		};
+	};
+
+	wcd-playback-dai-link {
+		link-name = "WCD Playback";
+		cpu {
+			sound-dai = <&q6afedai RX_CODEC_DMA_RX_0>;
+		};
+		codec {
+			sound-dai = <&wcd938x 0>, <&swr1 0>, <&rxmacro 0>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+
+	wcd-capture-dai-link {
+		link-name = "WCD Capture";
+		cpu {
+			sound-dai = <&q6afedai TX_CODEC_DMA_TX_3>;
+		};
+
+		codec {
+			sound-dai = <&wcd938x 1>, <&swr2 0>, <&txmacro 0>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+
+	cs35l41-dai-link {
+		link-name = "Tertiary MI2S Playback";
+		cpu {
+			sound-dai = <&q6afedai TERTIARY_MI2S_RX>;
+		};
+
+		platform {
+			sound-dai = <&q6routing>;
+		};
+
+		codec {
+			sound-dai = <&cs35l41_l 0>;//, <&cs35l41_r 0>;
+		};
+	};
+
+	va-dai-link {
+		link-name = "VA Capture";
+		cpu {
+			sound-dai = <&q6afedai VA_CODEC_DMA_TX_0>;
+		};
+
+		platform {
+			sound-dai = <&q6routing>;
+		};
+
+		codec {
+			sound-dai = <&vamacro 0>;
+		};
+	};
+};
+
+&vamacro {
+	pinctrl-0 = <&dmic01_active>;
+	pinctrl-names = "default";
+	vdd-micb-supply = <&vreg_s4a_1p8>;
+	qcom,dmic-sample-rate = <600000>;
+};
+
+&q6afedai {
+	dai@20 {
+		reg = <TERTIARY_MI2S_RX>;
+		qcom,sd-lines = <1>;
+	};
+};
+
+&q6asmdai {
+	dai@0 {
+		reg = <0>;
+	};
+
+	dai@1 {
+		reg = <1>;
+	};
+
+	dai@2 {
+		reg = <2>;
+	};
+};
+
+&swr1 {
+	status = "okay";
+	wcd_rx: wcd9380-rx@0,4 {
+		compatible = "sdw20217010d00";
+		reg = <0 4>;
+		qcom,rx-port-mapping = <1 2 3 4 5>;
+	};
+};
+
+&swr2 {
+	status = "okay";
+	wcd_tx: wcd9380-tx@0,3 {
+		compatible = "sdw20217010d00";
+		reg = <0 3>;
+		qcom,tx-port-mapping = <2 3 4 5>;
+	};
+};
+
+&tert_mi2s_active{
+	data1-pins {
+		pins = "gpio137";
+		function = "mi2s2_data1";
+		drive-strength = <8>;
+		bias-disable;
+		output-high;
+	};
+};
+
+&tlmm {
+	gpio-reserved-ranges = <28 4>, <40 4>;
+
+	wcd938x_reset_default: wcd938x-reset-default-state {
+		pins = "gpio32";
+		function = "gpio";
+		drive-strength = <16>;
+		output-high;
+	};
+
+	wcd938x_reset_sleep: wcd938x-reset-sleep-state {
+		pins = "gpio32";
+		function = "gpio";
+		drive-strength = <16>;
+		bias-disable;
+		output-low;
+	};
+
+	ts_int_suspend: ts_int_suspend {
+		pins = "gpio39";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	ts_active: ts_active {
+		pins = "gpio38", "gpio39";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+
+	ts_reset_suspend: ts_reset_suspend {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	ts_release: ts_release {
+		pins = "gpio38", "gpio39";
+		function = "gpio";
+		drive-strength = <2>;
+	};
+
+	mdm2ap_default: mdm2ap-default-state {
+		pins = "gpio1", "gpio3";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	ap2mdm_default: ap2mdm-default-state {
+		pins = "gpio57";
+		function = "gpio";
+		drive-strength = <16>;
+		bias-disable;
+		output-low;
+	};
+
+	ap2mdm_active: ap2mdm-active-state {
+        pins = "gpio56";
+        function = "gpio";
+        drive-strength = <16>;
+		bias-disable;
+		output-high;
+    };
+
+	bt_en_state: bt-default-state {
+		pins = "gpio21";
+		function = "gpio";
+		drive-strength = <16>;
+		output-low;
+		bias-pull-up;
+	};
+
+	wlan_en_state: wlan-default-state {
+		pins = "gpio20";
+		function = "gpio";
+		drive-strength = <16>;
+		output-low;
+		bias-pull-up;
+	};
+
+	panel_default: panel-active-state {
+		pins = "gpio12";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	te_default: te-state {
+		pins = "gpio66";
+		function = "mdp_vsync";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+};
+
+&uart6 {
+	status = "okay";
+
+	bluetooth {
+		compatible = "qcom,qca6390-bt";
+
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddbtcmx-supply = <&vreg_pmu_btcmx_0p85>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p7-supply = <&vreg_pmu_rfa_1p7>;
+	};
+};
+
+&txmacro {
+	status = "okay";
+};
+
+&uart12 {
+	status = "okay";
+};
+
+&ufs_mem_hc {
+	status = "okay";
+	vcc-supply = <&vreg_l17a_3p0>;
+	vcc-max-microamp = <800000>;
+	vccq-supply = <&vreg_l6a_1p2>;
+	vccq-max-microamp = <800000>;
+	vccq2-supply = <&vreg_s4a_1p8>;
+	vccq2-max-microamp = <800000>;
+};
+
+&ufs_mem_phy {
+	status = "okay";
+	vdda-phy-supply = <&vreg_l5a_0p875>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+};
+
+&usb_1 {
+	status = "okay";
+};
+
+&usb_1_dwc3 {
+	dr_mode = "otg";
+	// dr_mode = "peripheral";
+	usb-role-switch;
+};
+
+&usb_1_dwc3_hs_out {
+	remote-endpoint = <&pm8150b_hs_in>;
+};
+
+&usb_1_hsphy {
+	status = "okay";
+	vdda-pll-supply = <&vreg_l5a_0p875>;
+	vdda18-supply = <&vreg_l12a_1p8>;
+	vdda33-supply = <&vreg_l2a_3p1>;
+};
+
+&usb_1_qmpphy {
+	status = "okay";
+	vdda-phy-supply = <&vreg_l9a_1p2>;
+	vdda-pll-supply = <&vreg_l18a_0p9>;
+};
+
+&i2c15 {
+	status = "okay";
+
+	typec-mux@42 {
+		compatible = "fcs,fsa4480";
+		reg = <0x42>;
+		mode-switch;
+		orientation-switch;
+		port {
+			fsa4480_sbu_mux: endpoint {
+				remote-endpoint = <&pm8150b_typec_sbu_out>;
+			};
+		};
+	};
+};
+
+&usb_1_qmpphy_out {
+	remote-endpoint = <&pm8150b_typec_mux_in>;
+};
+
+&usb_1_qmpphy_dp_in {
+	remote-endpoint = <&mdss_dp_out>;
+};
+
+&pm8150b_gpios {
+	otg_vbus_boost: otg-vbus-boost {
+		pins = "gpio12";
+		function = "normal";
+		power-source = <0x00>;
+		output-low;
+	};
+};
+
+&pm8150b_typec {
+	status = "okay";
+
+	vdd-pdphy-supply = <&vreg_l2a_3p1>;
+	vdd-vbus-supply = <&ext_5v_boost>;
+
+	connector {
+		compatible = "usb-c-connector";
+		label = "USB-C";
+
+		power-role = "source";
+		data-role = "dual";
+		self-powered;
+		accessory-mode-audio = <1>;
+
+		source-pdos = <PDO_FIXED(5000, 3000,
+					 PDO_FIXED_DUAL_ROLE |
+					 PDO_FIXED_USB_COMM |
+					 PDO_FIXED_DATA_SWAP)>;
+
+		altmodes {
+			displayport {
+				svid = /bits/ 16 <0xff01>;
+				vdo = <0x00001c46>;
+			};
+		};
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				pm8150b_hs_in: endpoint {
+					remote-endpoint = <&usb_1_dwc3_hs_out>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				pm8150b_typec_mux_in: endpoint {
+					remote-endpoint = <&usb_1_qmpphy_out>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+
+				pm8150b_typec_sbu_out: endpoint {
+					remote-endpoint = <&fsa4480_sbu_mux>;
+				};
+			};
+		};
+	};
+};
\ No newline at end of file
-- 
2.43.0


From 8abcdc78536fdf0ee59ca48eceb101b9b6578960 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sat, 7 Dec 2024 12:31:25 +0000
Subject: [PATCH 17/39] drm/panel: add panel for lg sw43103 a3.

---
 drivers/gpu/drm/panel/Kconfig               |  12 +
 drivers/gpu/drm/panel/Makefile              |   1 +
 drivers/gpu/drm/panel/panel-lg-sw43103-a3.c | 511 ++++++++++++++++++++
 3 files changed, 524 insertions(+)
 create mode 100644 drivers/gpu/drm/panel/panel-lg-sw43103-a3.c

diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index b1fc66de8a67..fe186bcf0a35 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -384,6 +384,18 @@ config DRM_PANEL_LG_LG4573
 	  Say Y here if you want to enable support for LG4573 RGB panel.
 	  To compile this driver as a module, choose M here.
 
+config DRM_PANEL_LG_SW43103
+	tristate "LG SW43103 panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	select DRM_DISPLAY_DSC_HELPER
+	select DRM_DISPLAY_HELPER
+	help
+	  Say Y here if you want to enable support for LG sw43103 cmd dsc amoled panel.
+	  The panel has a 1080x2460@60Hz resolution and uses 24 bit RGB per
+	  pixel. It provides a MIPI DSI interface to the host.
+
 config DRM_PANEL_LG_SW43408
 	tristate "LG SW43408 panel"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 1f8a69c6ddba..1e23d96eceb1 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -40,6 +40,7 @@ obj-$(CONFIG_DRM_PANEL_LINCOLNTECH_LCD197) += panel-lincolntech-lcd197.o
 obj-$(CONFIG_DRM_PANEL_LG_LB035Q02) += panel-lg-lb035q02.o
 obj-$(CONFIG_DRM_PANEL_LG_LG4573) += panel-lg-lg4573.o
 obj-$(CONFIG_DRM_PANEL_LG_SW43408) += panel-lg-sw43408.o
+obj-$(CONFIG_DRM_PANEL_LG_SW43103) += panel-lg-sw43103-a3.o
 obj-$(CONFIG_DRM_PANEL_MAGNACHIP_D53E6EA8966) += panel-magnachip-d53e6ea8966.o
 obj-$(CONFIG_DRM_PANEL_NEC_NL8048HL11) += panel-nec-nl8048hl11.o
 obj-$(CONFIG_DRM_PANEL_NEWVISION_NV3051D) += panel-newvision-nv3051d.o
diff --git a/drivers/gpu/drm/panel/panel-lg-sw43103-a3.c b/drivers/gpu/drm/panel/panel-lg-sw43103-a3.c
new file mode 100644
index 000000000000..2564a17bbf07
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-lg-sw43103-a3.c
@@ -0,0 +1,511 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 Kancy Joe
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved.
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+
+#include <drm/display/drm_dsc.h>
+#include <drm/display/drm_dsc_helper.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct sw43103_a3_dsc {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct drm_dsc_config dsc;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct sw43103_a3_dsc *to_sw43103_a3_dsc(struct drm_panel *panel)
+{
+	return container_of(panel, struct sw43103_a3_dsc, panel);
+}
+
+static void sw43103_a3_dsc_reset(struct sw43103_a3_dsc *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(2000, 3000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int sw43103_a3_dsc_on(struct sw43103_a3_dsc *ctx)
+{
+	struct mipi_dsi_multi_context dsi_ctx = { .dsi = ctx->dsi };
+
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb0, 0xa1);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x2a, 0x00, 0x00, 0x04, 0x37);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x2b, 0x00, 0x00, 0x09, 0x9b);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x55, 0x08);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x30, 0x00, 0x00, 0x09, 0x9b);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x31, 0x00, 0x00, 0x04, 0x37);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x35, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb0, 0xca);
+	mipi_dsi_dcs_exit_sleep_mode_multi(&dsi_ctx);
+	mipi_dsi_msleep(&dsi_ctx, 100);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb0, 0xa1);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb3,
+				     0x91, 0x49, 0x00, 0x0f, 0x0c, 0x00, 0x0f,
+				     0x0c, 0x28, 0x00, 0x02, 0x14);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb0, 0xa5);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb1,
+				     0x61, 0xc0, 0x00, 0x00, 0x00, 0x10, 0xff);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb2,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0xea, 0x6b, 0x60, 0x58, 0x50,
+				     0x49, 0x41, 0x3a, 0x33, 0x2c, 0x25, 0x1e,
+				     0x17, 0x11, 0x0b, 0x05, 0x6c, 0x61, 0x58,
+				     0x50, 0x48, 0x40, 0x38, 0x31, 0x29, 0x22,
+				     0x1b, 0x14, 0x0d, 0x06, 0x00, 0x62, 0x57,
+				     0x4d, 0x44, 0x3c);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb3,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0x34, 0x2d, 0x25, 0x1e, 0x16,
+				     0x0f, 0x08, 0x01, 0x00, 0x57, 0x4c, 0x42,
+				     0x3a, 0x31, 0x29, 0x22, 0x1a, 0x12, 0x0b,
+				     0x03, 0x00, 0x00, 0x4c, 0x42, 0x38, 0x2e,
+				     0x26, 0x1e, 0x16, 0x0e, 0x07, 0x00, 0x00,
+				     0x00, 0x45, 0x39);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb4,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0x2f, 0x25, 0x1c, 0x14, 0x0c,
+				     0x04, 0x00, 0x00, 0x00, 0x34, 0x2a, 0x21,
+				     0x19, 0x10, 0x09, 0x01, 0x00, 0x00, 0x00,
+				     0x2e, 0x23, 0x19, 0x10, 0x08, 0x00, 0x00,
+				     0x00, 0x00, 0x25, 0x1b, 0x11, 0x08, 0x00,
+				     0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb5,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x1f, 0x13, 0x09, 0x00, 0x00, 0x00, 0x00,
+				     0x16, 0x0c, 0x03, 0x00, 0x00, 0x00, 0x0e,
+				     0x06, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb6,
+				     0x44, 0x31, 0x10, 0x00, 0x00, 0x64, 0x00,
+				     0x59, 0xf3, 0x10, 0x80, 0x30, 0x20, 0x00,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xd1,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0xd0, 0x10, 0x02, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb0, 0xa3);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xee, 0x02, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb8,
+				     0x00, 0x00, 0x83, 0xff, 0x5c, 0x96, 0xf2,
+				     0x29, 0x84, 0xb4, 0xd2, 0x77, 0x70, 0xa3,
+				     0xcb, 0xe4);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb9,
+				     0x00, 0x00, 0x02, 0xff, 0x4d, 0xd7, 0xb4,
+				     0xfe, 0x66, 0xa0, 0xca, 0x6f, 0x6f, 0xa8,
+				     0xce, 0xe6);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xba,
+				     0x00, 0x00, 0x84, 0xff, 0x89, 0x3d, 0xec,
+				     0x28, 0x83, 0xae, 0xd2, 0x7e, 0x77, 0xa8,
+				     0xcb, 0xe0);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xbb,
+				     0x00, 0x13, 0x83, 0xff, 0x61, 0x66, 0xed,
+				     0x24, 0x81, 0xaf, 0xd4, 0x7b, 0x6b, 0xa8,
+				     0xce, 0xe4);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xbc,
+				     0x00, 0x13, 0x02, 0xff, 0x53, 0xb4, 0xad,
+				     0xf4, 0x5e, 0x9d, 0xc7, 0x71, 0x68, 0xaa,
+				     0xcf, 0xe6);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xbd,
+				     0x00, 0x13, 0x84, 0xff, 0x8a, 0x05, 0xea,
+				     0x23, 0x80, 0xaf, 0xd3, 0x82, 0x74, 0xab,
+				     0xce, 0xe3);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xbe,
+				     0x00, 0x37, 0x83, 0xff, 0x77, 0x5c, 0xdd,
+				     0x15, 0x79, 0xaf, 0xcf, 0x72, 0x6f, 0xa7,
+				     0xce, 0xe5);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xbf,
+				     0x00, 0x37, 0x02, 0xff, 0x65, 0xaa, 0xa0,
+				     0xe5, 0x52, 0x96, 0xc4, 0x64, 0x6b, 0xa9,
+				     0xcf, 0xe7);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc0,
+				     0x00, 0x37, 0x83, 0xff, 0x9d, 0xfd, 0xd8,
+				     0x1c, 0x7c, 0xac, 0xd0, 0x7b, 0x78, 0xac,
+				     0xce, 0xe4);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc1,
+				     0x02, 0x24, 0x82, 0xff, 0x7e, 0xf1, 0xcc,
+				     0x05, 0x6e, 0xa4, 0xca, 0x6f, 0x6e, 0xab,
+				     0xd2, 0xe8);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc2,
+				     0x02, 0x24, 0x02, 0xff, 0x6e, 0x58, 0xa3,
+				     0xd5, 0x3d, 0x8c, 0xbc, 0x59, 0x66, 0xaa,
+				     0xd2, 0xe8);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc3,
+				     0x02, 0x24, 0x83, 0xff, 0x9e, 0x7e, 0xc5,
+				     0x10, 0x72, 0xab, 0xcd, 0x78, 0x79, 0xb0,
+				     0xd5, 0xe9);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc4,
+				     0x04, 0x0f, 0x02, 0xff, 0x88, 0xa4, 0xc4,
+				     0xe9, 0x60, 0xa0, 0xc8, 0x64, 0x6b, 0xac,
+				     0xd3, 0xe9);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc5,
+				     0x04, 0x0f, 0x02, 0xff, 0x7a, 0x20, 0xac,
+				     0xca, 0x30, 0x7d, 0xb6, 0x4a, 0x5c, 0xa8,
+				     0xd2, 0xe9);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc6,
+				     0x04, 0x0f, 0x03, 0xff, 0xa8, 0x2e, 0xbd,
+				     0xfa, 0x65, 0xa3, 0xcc, 0x6e, 0x76, 0xb3,
+				     0xd6, 0xea);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc7,
+				     0x06, 0x12, 0x02, 0xff, 0x99, 0x7d, 0xbc,
+				     0xde, 0x51, 0x8e, 0xc6, 0x58, 0x63, 0xaa,
+				     0xd2, 0xe9);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc8,
+				     0x06, 0x12, 0x02, 0xff, 0x8d, 0x02, 0x9a,
+				     0xcf, 0x1e, 0x6b, 0xb0, 0x37, 0x50, 0xa3,
+				     0xd0, 0xe7);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc9,
+				     0x06, 0x12, 0x03, 0xff, 0xbc, 0x04, 0xb3,
+				     0xdb, 0x63, 0x8f, 0xc6, 0x67, 0x6f, 0xb1,
+				     0xd5, 0xea);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xca,
+				     0x08, 0x0a, 0x02, 0xff, 0xa3, 0x44, 0xca,
+				     0xda, 0x2d, 0x8d, 0xbc, 0x4c, 0x5a, 0xa7,
+				     0xd0, 0xea);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xcb,
+				     0x08, 0x0a, 0x01, 0xff, 0x97, 0xd5, 0xb4,
+				     0xdb, 0x21, 0x6f, 0xa1, 0x24, 0x42, 0x9d,
+				     0xcd, 0xe7);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xcc,
+				     0x08, 0x0a, 0x02, 0xff, 0xc6, 0xc5, 0xb8,
+				     0xc7, 0x46, 0x98, 0xbd, 0x5a, 0x68, 0xaf,
+				     0xd4, 0xea);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xcd,
+				     0x0c, 0x02, 0x01, 0xff, 0xb2, 0xfd, 0xac,
+				     0xd5, 0x25, 0x6d, 0xb7, 0x3b, 0x45, 0x9e,
+				     0xd0, 0xe6);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xce,
+				     0x0c, 0x02, 0x01, 0xff, 0xa5, 0x9a, 0xac,
+				     0xe2, 0x31, 0x68, 0xab, 0x0e, 0x2a, 0x90,
+				     0xc9, 0xe3);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xcf,
+				     0x0c, 0x02, 0x02, 0xff, 0xd5, 0x74, 0xad,
+				     0xe6, 0x2f, 0x7c, 0xbf, 0x43, 0x58, 0xa6,
+				     0xd3, 0xe9);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xd0,
+				     0x12, 0x00, 0x01, 0xff, 0xc8, 0x97, 0x01,
+				     0xb6, 0x0b, 0x82, 0xab, 0x0a, 0x26, 0x8d,
+				     0xc7, 0xe4);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xd1,
+				     0x12, 0x00, 0x01, 0xff, 0xbe, 0x4a, 0x01,
+				     0xc0, 0x44, 0x80, 0xb3, 0x03, 0x06, 0x76,
+				     0xba, 0xde);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xd2,
+				     0x12, 0x00, 0x02, 0xff, 0xf2, 0x00, 0x01,
+				     0xb1, 0x11, 0x5f, 0xa8, 0x16, 0x30, 0x94,
+				     0xc8, 0xe7);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xd3,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xd4,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xd5,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb0, 0xa5);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xcd,
+				     0x10, 0x12, 0x01, 0x5a, 0x90, 0x00, 0x00,
+				     0x00, 0x00, 0x00, 0x5d);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb0, 0xa1);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x55,
+				     0x08, 0x00, 0x82, 0xa8, 0x1c, 0x61, 0x0a,
+				     0x90, 0x04, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb0, 0xa3);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb3,
+				     0x1f, 0x63, 0x00, 0x00, 0x06);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x53, 0x84);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb0, 0xa4);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb4,
+				     0x00, 0x03, 0x05, 0xaf, 0x03, 0x05, 0xaf,
+				     0x03, 0x05, 0xaf);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb5,
+				     0x00, 0xff, 0x94, 0x1f, 0xae, 0x37, 0xae,
+				     0x1f, 0x94, 0x00, 0xfb, 0x94, 0x1e, 0xad,
+				     0x35, 0xab, 0x1c, 0x90, 0x00, 0xdd, 0x8f,
+				     0x16, 0x9f, 0x24, 0x97, 0x04, 0x75);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb7,
+				     0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+				     0x80, 0x80, 0x80, 0x80, 0x80);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb8,
+				     0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+				     0x80, 0x80, 0x80, 0x80, 0x80);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb9,
+				     0x35, 0x2d, 0x2d, 0x37, 0x34, 0x35, 0x36,
+				     0x36, 0x36, 0x2d, 0x35, 0x33);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xba,
+				     0x80, 0x80, 0x80, 0x80, 0x88, 0x80, 0x80,
+				     0x80, 0x80, 0x80, 0x80, 0x7d);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xbb,
+				     0x80, 0x5a, 0x7b, 0x95, 0x65, 0x70, 0x96,
+				     0x90, 0x90, 0x90, 0x83, 0x72);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb0, 0xa1);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc2,
+				     0xf3, 0x20, 0x00, 0x00, 0x1d);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb0, 0xa5);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xd1, 0x0a, 0x00, 0x01);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xd1, 0x02, 0x00, 0x01);
+	mipi_dsi_msleep(&dsi_ctx, 20);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xd1, 0x00, 0x00, 0x01);
+	mipi_dsi_dcs_set_display_on_multi(&dsi_ctx);
+	mipi_dsi_msleep(&dsi_ctx, 20);
+
+	return dsi_ctx.accum_err;
+}
+
+static int sw43103_a3_dsc_off(struct sw43103_a3_dsc *ctx)
+{
+	struct mipi_dsi_multi_context dsi_ctx = { .dsi = ctx->dsi };
+
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0x13);
+	mipi_dsi_msleep(&dsi_ctx, 70);
+	mipi_dsi_dcs_set_display_off_multi(&dsi_ctx);
+	mipi_dsi_dcs_enter_sleep_mode_multi(&dsi_ctx);
+	mipi_dsi_msleep(&dsi_ctx, 70);
+
+	return dsi_ctx.accum_err;
+}
+
+static int sw43103_a3_dsc_prepare(struct drm_panel *panel)
+{
+	struct sw43103_a3_dsc *ctx = to_sw43103_a3_dsc(panel);
+	struct device *dev = &ctx->dsi->dev;
+	struct drm_dsc_picture_parameter_set pps;
+	int ret;
+
+	sw43103_a3_dsc_reset(ctx);
+
+	ret = sw43103_a3_dsc_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		return ret;
+	}
+
+	drm_dsc_pps_payload_pack(&pps, &ctx->dsc);
+
+	ret = mipi_dsi_picture_parameter_set(ctx->dsi, &pps);
+	if (ret < 0) {
+		dev_err(panel->dev, "failed to transmit PPS: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_compression_mode(ctx->dsi, true);
+	if (ret < 0) {
+		dev_err(dev, "failed to enable compression mode: %d\n", ret);
+		return ret;
+	}
+
+	msleep(28); /* TODO: Is this panel-dependent? */
+
+	return 0;
+}
+
+static int sw43103_a3_dsc_unprepare(struct drm_panel *panel)
+{
+	struct sw43103_a3_dsc *ctx = to_sw43103_a3_dsc(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = sw43103_a3_dsc_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+	return 0;
+}
+
+static const struct drm_display_mode sw43103_a3_dsc_mode = {
+	.clock = (1080 + 50 + 30 + 50) * (2460 + 4 + 2 + 2) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 50,
+	.hsync_end = 1080 + 50 + 30,
+	.htotal = 1080 + 50 + 30 + 50,
+	.vdisplay = 2460,
+	.vsync_start = 2460 + 4,
+	.vsync_end = 2460 + 4 + 2,
+	.vtotal = 2460 + 4 + 2 + 2,
+	.width_mm = 69,
+	.height_mm = 158,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int sw43103_a3_dsc_get_modes(struct drm_panel *panel,
+				    struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &sw43103_a3_dsc_mode);
+}
+
+static const struct drm_panel_funcs sw43103_a3_dsc_panel_funcs = {
+	.prepare = sw43103_a3_dsc_prepare,
+	.unprepare = sw43103_a3_dsc_unprepare,
+	.get_modes = sw43103_a3_dsc_get_modes,
+};
+
+static int sw43103_a3_dsc_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness_large(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+// TODO: Check if /sys/class/backlight/.../actual_brightness actually returns
+// correct values. If not, remove this function.
+static int sw43103_a3_dsc_bl_get_brightness(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_get_display_brightness_large(dsi, &brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return brightness;
+}
+
+static const struct backlight_ops sw43103_a3_dsc_bl_ops = {
+	.update_status = sw43103_a3_dsc_bl_update_status,
+	.get_brightness = sw43103_a3_dsc_bl_get_brightness,
+};
+
+static struct backlight_device *
+sw43103_a3_dsc_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 2047,
+		.max_brightness = 2047,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &sw43103_a3_dsc_bl_ops, &props);
+}
+
+static int sw43103_a3_dsc_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct sw43103_a3_dsc *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &sw43103_a3_dsc_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = sw43103_a3_dsc_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	/* This panel only supports DSC; unconditionally enable it */
+	dsi->dsc = &ctx->dsc;
+
+	ctx->dsc.dsc_version_major = 1;
+	ctx->dsc.dsc_version_minor = 1;
+
+	/* TODO: Pass slice_per_pkt = 2 */
+	ctx->dsc.slice_height = 60;
+	ctx->dsc.slice_width = 540;
+	/*
+	 * TODO: hdisplay should be read from the selected mode once
+	 * it is passed back to drm_panel (in prepare?)
+	 */
+	WARN_ON(1080 % ctx->dsc.slice_width);
+	ctx->dsc.slice_count = 1080 / ctx->dsc.slice_width;
+	ctx->dsc.bits_per_component = 8;
+	ctx->dsc.bits_per_pixel = 8 << 4; /* 4 fractional bits */
+	ctx->dsc.block_pred_enable = true;
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void sw43103_a3_dsc_remove(struct mipi_dsi_device *dsi)
+{
+	struct sw43103_a3_dsc *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id sw43103_a3_dsc_of_match[] = {
+	{ .compatible = "lge,sw43103-a3-dsc" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sw43103_a3_dsc_of_match);
+
+static struct mipi_dsi_driver sw43103_a3_dsc_driver = {
+	.probe = sw43103_a3_dsc_probe,
+	.remove = sw43103_a3_dsc_remove,
+	.driver = {
+		.name = "panel-sw43103-a3-dsc",
+		.of_match_table = sw43103_a3_dsc_of_match,
+	},
+};
+module_mipi_dsi_driver(sw43103_a3_dsc_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator");
+MODULE_DESCRIPTION("DRM driver for SW43103 cmd mode dsc dsi panel");
+MODULE_LICENSE("GPL");
-- 
2.43.0


From 983fc6d1d77abc62e68cdfa66e5a8556aaad1979 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sat, 7 Dec 2024 13:43:37 +0000
Subject: [PATCH 18/39] arm64/config/q_defconfig: Add configs after merging.

---
 arch/arm64/configs/q_defconfig | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/arch/arm64/configs/q_defconfig b/arch/arm64/configs/q_defconfig
index 1f395edd5b33..b5c839535d20 100644
--- a/arch/arm64/configs/q_defconfig
+++ b/arch/arm64/configs/q_defconfig
@@ -35,6 +35,7 @@ CONFIG_PROFILING=y
 CONFIG_KEXEC=y
 CONFIG_KEXEC_FILE=y
 CONFIG_ARCH_QCOM=y
+# CONFIG_HISILICON_ERRATUM_162100801 is not set
 CONFIG_SCHED_MC=y
 CONFIG_SCHED_SMT=y
 CONFIG_NUMA=y
@@ -167,6 +168,7 @@ CONFIG_PCIEPORTBUS=y
 CONFIG_PCIEAER=y
 CONFIG_PCI_IOV=y
 CONFIG_PCI_PASID=y
+CONFIG_PCIE_TPH=y
 # CONFIG_VGA_ARB is not set
 CONFIG_HOTPLUG_PCI=y
 CONFIG_HOTPLUG_PCI_ACPI=y
@@ -458,9 +460,12 @@ CONFIG_PINCTRL_MSM8996=y
 CONFIG_PINCTRL_MSM8998=y
 CONFIG_PINCTRL_QCM2290=y
 CONFIG_PINCTRL_QCS404=y
+CONFIG_PINCTRL_QCS615=m
+CONFIG_PINCTRL_QCS8300=m
 CONFIG_PINCTRL_QDF2XXX=y
 CONFIG_PINCTRL_QDU1000=y
 CONFIG_PINCTRL_SA8775P=y
+CONFIG_PINCTRL_SAR2130P=m
 CONFIG_PINCTRL_SC7180=y
 CONFIG_PINCTRL_SC7280=y
 CONFIG_PINCTRL_SC8180X=y
@@ -532,6 +537,7 @@ CONFIG_SENSORS_INA3221=m
 CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
 CONFIG_CPU_THERMAL=y
 CONFIG_DEVFREQ_THERMAL=y
+CONFIG_PCIE_THERMAL=y
 CONFIG_THERMAL_EMULATION=y
 CONFIG_GENERIC_ADC_THERMAL=m
 CONFIG_QCOM_TSENS=y
@@ -611,6 +617,7 @@ CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=m
 CONFIG_DRM_PANEL_DSI_CM=m
 CONFIG_DRM_PANEL_LVDS=m
 CONFIG_DRM_PANEL_CSOT_MP42020B=m
+CONFIG_DRM_PANEL_LG_SW43103=m
 CONFIG_DRM_PANEL_EDP=m
 CONFIG_DRM_PANEL_SIMPLE=m
 CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA=m
@@ -808,6 +815,7 @@ CONFIG_TYPEC_MUX_FSA4480=m
 CONFIG_TYPEC_MUX_GPIO_SBU=m
 CONFIG_TYPEC_MUX_NB7VPQ904M=m
 CONFIG_TYPEC_MUX_PTN36502=m
+CONFIG_TYPEC_MUX_TUSB1046=m
 CONFIG_TYPEC_MUX_WCD939X_USBSS=m
 CONFIG_TYPEC_DP_ALTMODE=m
 CONFIG_MMC=y
@@ -889,7 +897,15 @@ CONFIG_VIRTIO_BALLOON=y
 CONFIG_VIRTIO_MMIO=y
 CONFIG_STAGING=y
 CONFIG_STAGING_MEDIA=y
+CONFIG_GPIB=m
+CONFIG_GPIB_AGILENT_82350B=m
+CONFIG_GPIB_AGILENT_82357A=m
+CONFIG_GPIB_CEC_PCI=m
+CONFIG_GPIB_NI_PCI_ISA=m
+CONFIG_GPIB_CB7210=m
+CONFIG_GPIB_NI_USB=m
 CONFIG_CHROME_PLATFORMS=y
+CONFIG_CHROMEOS_OF_HW_PROBER=m
 CONFIG_CROS_EC=y
 CONFIG_CROS_EC_I2C=y
 CONFIG_CROS_EC_RPMSG=m
@@ -1050,6 +1066,7 @@ CONFIG_RESET_GPIO=m
 CONFIG_RESET_QCOM_AOSS=y
 CONFIG_RESET_QCOM_PDC=m
 CONFIG_PHY_CAN_TRANSCEIVER=m
+CONFIG_PHY_NXP_PTN3222=m
 CONFIG_PHY_CADENCE_TORRENT=m
 CONFIG_PHY_CADENCE_DPHY_RX=m
 CONFIG_PHY_CADENCE_SIERRA=m
@@ -1095,8 +1112,11 @@ CONFIG_SLIM_QCOM_CTRL=m
 CONFIG_SLIM_QCOM_NGD_CTRL=m
 CONFIG_INTERCONNECT_QCOM=y
 CONFIG_INTERCONNECT_QCOM_OSM_L3=y
+CONFIG_INTERCONNECT_QCOM_QCS615=m
+CONFIG_INTERCONNECT_QCOM_QCS8300=m
 CONFIG_INTERCONNECT_QCOM_QDU1000=y
 CONFIG_INTERCONNECT_QCOM_SA8775P=y
+CONFIG_INTERCONNECT_QCOM_SAR2130P=m
 CONFIG_INTERCONNECT_QCOM_SC7180=y
 CONFIG_INTERCONNECT_QCOM_SC7280=y
 CONFIG_INTERCONNECT_QCOM_SC8180X=y
@@ -1181,4 +1201,5 @@ CONFIG_DEBUG_FS=y
 CONFIG_DEBUG_MEMORY_INIT=y
 # CONFIG_SCHED_DEBUG is not set
 # CONFIG_FTRACE is not set
+CONFIG_TEST_KALLSYMS=m
 CONFIG_MEMTEST=y
-- 
2.43.0


From 2d003a82cb8652607a6a48ee349e799be140ba1c Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sat, 7 Dec 2024 13:48:09 +0000
Subject: [PATCH 19/39] arm64/dts/qcom: sm8250-lge-v60.dts: Remove fsa4480.

---
 arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts | 355 ++++++++++++++++++--
 1 file changed, 334 insertions(+), 21 deletions(-)

diff --git a/arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts b/arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts
index 11a09c9b7351..444641886427 100644
--- a/arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts
+++ b/arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts
@@ -8,6 +8,7 @@
 #include <dt-bindings/regulator/qcom,rpmh-regulator.h>
 #include <dt-bindings/sound/qcom,q6afe.h>
 #include <dt-bindings/sound/qcom,q6asm.h>
+#include <dt-bindings/usb/pd.h>
 #include <dt-bindings/gpio/gpio.h>
 #include "sm8250.dtsi"
 #include "pm8150.dtsi"
@@ -35,7 +36,7 @@ chosen {
 		ranges;
 		// stdout-path = "serial0:115200n8";
 		stdout-path = "display0";
-		bootargs = "panic=30 loglevel=7 pd_ignore_unused clk_ignore_unused console=ttyS0,115200 console=tty1 root=/dev/sda27 rw";
+		bootargs = "panic=30 loglevel=7 pd_ignore_unused clk_ignore_unused console=ttyS0,115200 console=tty1 root=/dev/sda27 rw rootfs_part=sda27";
 
 		framebuffer: framebuffer@9c000000 {
 			compatible = "simple-framebuffer";
@@ -75,6 +76,67 @@ cont_splash_region@9c000000 {
 		};
 	};
 
+	qca6390-pmu {
+		compatible = "qcom,qca6390-pmu";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&bt_en_state>, <&wlan_en_state>;
+
+		vddaon-supply = <&vreg_s6a_0p95>;
+		vddpmu-supply = <&vreg_s6a_0p95>;
+		vddrfa0p95-supply = <&vreg_s6a_0p95>;
+		vddrfa1p3-supply = <&vreg_s8c_1p3>;
+		vddrfa1p9-supply = <&vreg_s5a_1p9>;
+		vddpcie1p3-supply = <&vreg_s8c_1p3>;
+		vddpcie1p9-supply = <&vreg_s5a_1p9>;
+		vddio-supply = <&vreg_s4a_1p8>;
+
+		wlan-enable-gpios = <&tlmm 20 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 21 GPIO_ACTIVE_HIGH>;
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p7: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p7";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
+
 	wcd938x: audio-codec {
 		compatible = "qcom,wcd9380-codec";
 
@@ -473,11 +535,11 @@ &cdsp {
 };
 
 &gmu {
-	status = "disabled";
+	status = "okay";
 };
 
 &gpu {
-	status = "disabled";
+	status = "okay";
 
 	zap-shader {
 		memory-region = <&gpu_mem>;
@@ -495,6 +557,23 @@ &pcie0_phy {
 	vdda-pll-supply = <&vreg_l9a_1p2>;
 };
 
+&pcieport0 {
+	wifi@0 {
+		compatible = "pci17cb,1101";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p7-supply = <&vreg_pmu_rfa_1p7>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
 &pcie2 {
 	status = "okay";
 };
@@ -506,7 +585,7 @@ &pcie2_phy {
 };
 
 &i2c1 {
-	status = "okay";
+	status = "disabled";
 	clock-frequency = <1000000>;
 	
 	pn547@28 {
@@ -521,7 +600,7 @@ pn547@28 {
 };
 
 &i2c13 {
-	status = "okay";
+	status = "disabled";
 	sw42902@28 {
 		compatible = "lge,sw42902";
 		reg = <0x28>;
@@ -580,20 +659,56 @@ sw42902@28 {
 	};
 };
 
-&i2c15 {
+&mdss {
 	status = "okay";
-	tfa9878_l: tfa9878@34 {
-		compatible = "nxp,tfa9879";
-		reg = <0x34>;
+};
+
+&mdss_dp {
+	status = "okay";
+};
+
+&mdss_dp_out {
+	data-lanes = <0 1>;
+	remote-endpoint = <&usb_1_qmpphy_dp_in>;
+};
+
+&mdss_dsi0_out {
+	remote-endpoint = <&panel_in_0>;
+	data-lanes = <0 1 2 3>;
+};
+
+&mdss_dsi0_phy {
+	vdds-supply = <&vreg_l5a_0p875>;
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	vdda-supply = <&vreg_l9a_1p2>;
+	status = "okay";
+
+	display_panel: panel@0 {
+		reg = <0>;
+		compatible = "lge,sw43103-a3-dsc";
+		vddio-supply = <&vreg_l14a_1p8>;
+		reset-gpios = <&tlmm 75 GPIO_ACTIVE_LOW>;
+
 		pinctrl-names = "default";
-		pinctrl-0 = <&tfa9878_reset_active>;
-		#sound-dai-cells = <0>;
-	};
-	
-	tfa9878_r: tfa9878@35 {
-		compatible = "nxp,tfa9879";
-		reg = <0x35>;
-		#sound-dai-cells = <0>;
+		pinctrl-0 = <&panel_default>, <&te_default>;
+
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				panel_in_0: endpoint {
+					remote-endpoint = <&mdss_dsi0_out>;
+				};
+			};
+		};
 	};
 };
 
@@ -713,6 +828,18 @@ channel@4f {
 	};
 };
 
+&gpi_dma0 {
+	status = "okay";
+};
+
+&gpi_dma1 {
+	status = "okay";
+};
+
+&gpi_dma2 {
+	status = "okay";
+};
+
 &qupv3_id_0 {
 	status = "okay";
 };
@@ -827,6 +954,28 @@ codec {
 	};
 };
 
+&q6afedai {
+	dai@20 {
+		reg = <SECONDARY_MI2S_RX>;
+		qcom,sd-lines = <0>;
+	};
+};
+
+&q6asmdai {
+	dai@0 {
+		reg = <0>;
+	};
+
+	dai@1 {
+		reg = <1>;
+	};
+
+	dai@2 {
+		reg = <2>;
+	};
+};
+
+
 &swr1 {
 	status = "okay";
 
@@ -937,6 +1086,72 @@ tfa9878_reset_active: tfa9878-reset-active {
 		drive-strength = <2>;
 		output-high;
 	};
+
+	sdc2_card_det_n: sd-card-det-n-state {
+		pins = "gpio77";
+		function = "gpio";
+		bias-pull-up;
+		drive-strength = <2>;
+	};
+
+	sdc2_default_state: sdc2-default-state {
+		clk-pins {
+			pins = "sdc2_clk";
+			drive-strength = <16>;
+			bias-disable;
+		};
+
+		cmd-pins {
+			pins = "sdc2_cmd";
+			drive-strength = <10>;
+			bias-pull-up;
+		};
+
+		data-pins {
+			pins = "sdc2_data";
+			drive-strength = <10>;
+			bias-pull-up;
+		};
+	};
+	
+	bt_en_state: bt-default-state {
+		pins = "gpio21";
+		function = "gpio";
+		drive-strength = <16>;
+		output-low;
+		bias-pull-up;
+	};
+
+	wlan_en_state: wlan-default-state {
+		pins = "gpio20";
+		function = "gpio";
+		drive-strength = <16>;
+		output-low;
+		bias-pull-up;
+	};
+
+	panel_default: panel-active-state {
+		pins = "gpio75";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	te_default: te-state {
+		pins = "gpio66";
+		function = "mdp_vsync";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+};
+
+&pon_pwrkey {
+	status = "okay";
+};
+
+&pon_resin {
+	status = "okay";
+	linux,code = <KEY_VOLUMEDOWN>;
 };
 
 &txmacro {
@@ -951,11 +1166,11 @@ &ufs_mem_hc {
 	status = "okay";
 
 	vcc-supply = <&vreg_l17a_3p0>;
-	vcc-max-microamp = <750000>;
+	vcc-max-microamp = <800000>;
 	vccq-supply = <&vreg_l6a_1p2>;
-	vccq-max-microamp = <700000>;
+	vccq-max-microamp = <800000>;
 	vccq2-supply = <&vreg_s4a_1p8>;
-	vccq2-max-microamp = <750000>;
+	vccq2-max-microamp = <800000>;
 };
 
 &ufs_mem_phy {
@@ -970,7 +1185,12 @@ &usb_1 {
 };
 
 &usb_1_dwc3 {
-	dr_mode = "host";
+	dr_mode = "otg";
+	usb-role-switch;
+};
+
+&usb_1_dwc3_hs_out {
+	remote-endpoint = <&pm8150b_hs_in>;
 };
 
 &usb_1_hsphy {
@@ -988,6 +1208,14 @@ &usb_1_qmpphy {
 	vdda-pll-supply = <&vreg_l18a_0p9>;
 };
 
+&usb_1_qmpphy_out {
+	remote-endpoint = <&pm8150b_typec_mux_in>;
+};
+
+&usb_1_qmpphy_dp_in {
+	remote-endpoint = <&mdss_dp_out>;
+};
+
 &usb_2 {
 	status = "okay";
 };
@@ -1013,6 +1241,20 @@ &usb_2_qmpphy {
 
 &venus {
 	status = "okay";
+	firmware-name = "qcom/sm8250/lge/timelm/venus.mbn";
+};
+
+&sdhc_2 {
+	status = "okay";
+	cd-gpios = <&tlmm 77 GPIO_ACTIVE_LOW>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc2_default_state &sdc2_card_det_n>;
+	pinctrl-1 = <&sdc2_sleep_state &sdc2_card_det_n>;
+	vmmc-supply = <&vreg_l9c_2p9>;
+	vqmmc-supply = <&vreg_l6c_2p9>;
+	bus-width = <4>;
+	no-sdio;
+	no-mmc;
 };
 
 &adsp_mem {
@@ -1026,3 +1268,74 @@ &spss_mem {
 &cdsp_secure_heap {
 	reg = <0x0 0x8c700000 0x0 0x4600000>;
 };
+
+&pm8150b_vbus {
+	regulator-min-microamp = <500000>;
+	regulator-max-microamp = <3000000>;
+	status = "okay";
+};
+
+&i2c15 {
+	status = "okay";
+
+	tfa9878_l: tfa9878@34 {
+		compatible = "nxp,tfa9879";
+		reg = <0x34>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&tfa9878_reset_active>;
+		#sound-dai-cells = <0>;
+	};
+	
+	tfa9878_r: tfa9878@35 {
+		compatible = "nxp,tfa9879";
+		reg = <0x35>;
+		#sound-dai-cells = <0>;
+	};
+};
+
+&pm8150b_typec {
+	status = "okay";
+
+	vdd-pdphy-supply = <&vreg_l2a_3p1>;
+
+	connector {
+		compatible = "usb-c-connector";
+		label = "USB-C";
+
+		power-role = "source";
+		data-role = "dual";
+		self-powered;
+		accessory-mode-audio = <1>;
+
+		source-pdos = <PDO_FIXED(5000, 3000,
+					 PDO_FIXED_DUAL_ROLE |
+					 PDO_FIXED_USB_COMM |
+					 PDO_FIXED_DATA_SWAP)>;
+
+		altmodes {
+			displayport {
+				svid = /bits/ 16 <0xff01>;
+				vdo = <0x00001c46>;
+			};
+		};
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				pm8150b_hs_in: endpoint {
+					remote-endpoint = <&usb_1_dwc3_hs_out>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				pm8150b_typec_mux_in: endpoint {
+					remote-endpoint = <&usb_1_qmpphy_out>;
+				};
+			};
+		};
+	};
+};
\ No newline at end of file
-- 
2.43.0


From 75df14aee4604d6c2b830efc875640f2eb6489af Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Wed, 8 Jan 2025 14:04:43 +0000
Subject: [PATCH 20/39] arm64: config: add 8550 clk in configs.

---
 arch/arm64/boot/dts/qcom/Makefile              |  3 +++
 arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts    |  2 +-
 arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts | 12 +++++++++++-
 arch/arm64/boot/dts/qcom/sm8250.dtsi           |  4 ++--
 arch/arm64/configs/q_defconfig                 |  4 ++++
 drivers/bus/mhi/host/pci_generic.c             |  3 ++-
 sound/soc/codecs/cs35l41-lib.c                 | 10 +++++++---
 7 files changed, 30 insertions(+), 8 deletions(-)

diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
index 6ca8db4b8afe..2d8a4672d5a1 100644
--- a/arch/arm64/boot/dts/qcom/Makefile
+++ b/arch/arm64/boot/dts/qcom/Makefile
@@ -254,6 +254,8 @@ dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-hdk.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-mtp.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-sony-xperia-edo-pdx203.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-sony-xperia-edo-pdx206.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-lge-v60.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-xiaomi-umi.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-xiaomi-elish-boe.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-xiaomi-elish-csot.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-xiaomi-pipa.dtb
@@ -266,6 +268,7 @@ dtb-$(CONFIG_ARCH_QCOM)	+= sm8450-hdk.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8450-qrd.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8450-sony-xperia-nagara-pdx223.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8450-sony-xperia-nagara-pdx224.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm8550-ayaneo-ps.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8550-hdk.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8550-mtp.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8550-qrd.dtb
diff --git a/arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts b/arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts
index 444641886427..57f028d3f543 100644
--- a/arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts
+++ b/arch/arm64/boot/dts/qcom/sm8250-lge-v60.dts
@@ -29,7 +29,7 @@ aliases {
 		serial0 = &uart12;
         display0 = &framebuffer;
 	};
-	
+
 	chosen {
 		#address-cells = <2>;
 		#size-cells = <2>;
diff --git a/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts b/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts
index 3b12c2b36dc8..dc9247828411 100644
--- a/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts
+++ b/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts
@@ -33,6 +33,16 @@ aliases {
 		serial0 = &uart12;
 		serial1 = &uart6;
 	};
+	
+	memory {
+        ddr_device_type = <0x08>;
+        device_type = "memory";
+		#address-cells = <2>;
+		#size-cells = <2>;
+        reg = <0x0 0x80000000 0x0 0x3b800000>,
+		<0x1 0x80000000 0x1 0x0>,
+		<0x0 0xc0000000 0x0 0xc0000000>;
+    };
 
 	wcd938x: audio-codec {
 		compatible = "qcom,wcd9380-codec";
@@ -951,7 +961,7 @@ display_panel: panel@0 {
 		pinctrl-names = "default";
 		pinctrl-0 = <&panel_default>, <&te_default>;
 
-		status = "okay";
+		status = "disabled";
 
 		ports {
 			#address-cells = <1>;
diff --git a/arch/arm64/boot/dts/qcom/sm8250.dtsi b/arch/arm64/boot/dts/qcom/sm8250.dtsi
index 48318ed1ce98..13268d1eceda 100644
--- a/arch/arm64/boot/dts/qcom/sm8250.dtsi
+++ b/arch/arm64/boot/dts/qcom/sm8250.dtsi
@@ -606,7 +606,7 @@ cpu7_opp8: opp-1632000000 {
 		};
 
 		cpu7_opp9: opp-1747200000 {
-			opp-hz = /bits/ 64 <1708800000>;
+			opp-hz = /bits/ 64 <1747200000>;
 			opp-peak-kBps = <5412000 42393600>;
 		};
 
@@ -2452,7 +2452,7 @@ pcie2: pcie@1c10000 {
 
 			status = "disabled";
 
-			pcie@0 {
+			pcieport2: pcie@0 {
 				device_type = "pci";
 				reg = <0x0 0x0 0x0 0x0 0x0>;
 				bus-range = <0x01 0xff>;
diff --git a/arch/arm64/configs/q_defconfig b/arch/arm64/configs/q_defconfig
index b5c839535d20..20b35697fa13 100644
--- a/arch/arm64/configs/q_defconfig
+++ b/arch/arm64/configs/q_defconfig
@@ -892,6 +892,7 @@ CONFIG_VFIO=y
 CONFIG_VFIO_PCI=y
 CONFIG_VIRT_DRIVERS=y
 CONFIG_ARM_PKVM_GUEST=y
+CONFIG_ARM_CCA_GUEST=m
 CONFIG_VIRTIO_PCI=y
 CONFIG_VIRTIO_BALLOON=y
 CONFIG_VIRTIO_MMIO=y
@@ -962,6 +963,8 @@ CONFIG_SDM_LPASSCC_845=m
 CONFIG_SDX_GCC_75=y
 CONFIG_SM_CAMCC_8150=m
 CONFIG_SM_CAMCC_8250=y
+CONFIG_SM_CAMCC_8450=m
+CONFIG_SM_CAMCC_8550=m
 CONFIG_SM_DISPCC_6115=m
 CONFIG_SM_DISPCC_8250=y
 CONFIG_SM_DISPCC_8450=m
@@ -982,6 +985,7 @@ CONFIG_SM_GPUCC_8650=m
 CONFIG_SM_TCSRCC_8550=y
 CONFIG_SM_TCSRCC_8650=y
 CONFIG_SM_VIDEOCC_8250=y
+CONFIG_SM_VIDEOCC_8550=m
 CONFIG_QCOM_HFPLL=y
 CONFIG_CLK_GFM_LPASS_SM8250=y
 CONFIG_SM_VIDEOCC_8450=m
diff --git a/drivers/bus/mhi/host/pci_generic.c b/drivers/bus/mhi/host/pci_generic.c
index 07645ce2119a..00a800d74203 100644
--- a/drivers/bus/mhi/host/pci_generic.c
+++ b/drivers/bus/mhi/host/pci_generic.c
@@ -723,7 +723,8 @@ static const struct pci_device_id mhi_pci_id_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_QCOM, 0x0304),
 		.driver_data = (kernel_ulong_t) &mhi_qcom_sdx24_info },
 	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_QCOM, 0x0306, PCI_VENDOR_ID_QCOM, 0x010c),
-		.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx55_info },
+		.driver_data = (kernel_ulong_t) &mhi_qcom_sdx55_info },
+//		.driver_data = (kernel_ulong_t) &mhi_foxconn_sdx55_info },
 	/* EM919x (sdx55), use the same vid:pid as qcom-sdx55m */
 	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_QCOM, 0x0306, 0x18d7, 0x0200),
 		.driver_data = (kernel_ulong_t) &mhi_sierra_em919x_info },
diff --git a/sound/soc/codecs/cs35l41-lib.c b/sound/soc/codecs/cs35l41-lib.c
index 1702f26049d3..5e67db81fe04 100644
--- a/sound/soc/codecs/cs35l41-lib.c
+++ b/sound/soc/codecs/cs35l41-lib.c
@@ -1266,11 +1266,15 @@ int cs35l41_global_enable(struct device *dev, struct regmap *regmap, enum cs35l4
 		if (ret || enable)
 			return ret;
 
-		ret = regmap_read_poll_timeout(regmap, CS35L41_IRQ1_STATUS1,
+//		ret = regmap_read_poll_timeout(regmap, CS35L41_IRQ1_STATUS1,
+//					int_status, int_status & pup_pdn_mask,
+//					1000, 100000);
+
+		regmap_read_poll_timeout(regmap, CS35L41_IRQ1_STATUS1,
 					int_status, int_status & pup_pdn_mask,
 					1000, 100000);
-		if (ret)
-			dev_err(dev, "Enable(%d) failed: %d\n", enable, ret);
+//		if (ret)
+//			dev_err(dev, "Enable(%d) failed: %d\n", enable, ret);
 
 		/* Clear PUP/PDN status */
 		regmap_write(regmap, CS35L41_IRQ1_STATUS1, pup_pdn_mask);
-- 
2.43.0


From df63e316d717e3661c3141eee5ec43c6801a5e9b Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Wed, 8 Jan 2025 14:46:22 +0000
Subject: [PATCH 21/39] arm64: dts: qcom: add config for ayaneo pocket s 2k.

---
 arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts | 1460 +++++++++++++++++
 1 file changed, 1460 insertions(+)
 create mode 100644 arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts

diff --git a/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts b/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts
new file mode 100644
index 000000000000..453189acd9c1
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts
@@ -0,0 +1,1460 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (c) 2024 Linaro Limited
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/regulator/qcom,rpmh-regulator.h>
+#include "sm8550.dtsi"
+#include "pm8010.dtsi"
+#include "pm8550.dtsi"
+#include "pm8550b.dtsi"
+#define PMK8550VE_SID 5
+#include "pm8550ve.dtsi"
+#include "pm8550vs.dtsi"
+#include "pmk8550.dtsi"
+#include "pmr735d_a.dtsi"
+#include "pmr735d_b.dtsi"
+
+/ {
+	model = "AYANEO Pocket S 2K";
+	compatible = "qcom,sm8550-hdk", "qcom,sm8550";
+	chassis-type = "tablet";
+
+	aliases {
+		serial0 = &uart7;
+		serial1 = &uart14;
+	};
+    
+	chosen {
+        #address-cells = <2>;
+        #size-cells = <2>;
+        ranges;
+
+        framebuffer: framebuffer@b8000000 {
+            compatible = "simple-framebuffer";
+            reg = <0 0xb8000000 0 0x2b00000>;
+            width = <1440>;
+            height = <2560>;
+            stride = <(1440 * 4)>;
+            format = "a8r8g8b8";
+        };
+    };
+
+	wcd938x: audio-codec {
+		compatible = "qcom,wcd9385-codec";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&wcd_default>;
+
+		qcom,micbias1-microvolt = <1800000>;
+		qcom,micbias2-microvolt = <1800000>;
+		qcom,micbias3-microvolt = <1800000>;
+		qcom,micbias4-microvolt = <1800000>;
+		qcom,mbhc-buttons-vthreshold-microvolt = <75000 150000 237000 500000 500000 500000 500000 500000>;
+		qcom,mbhc-headset-vthreshold-microvolt = <1700000>;
+		qcom,mbhc-headphone-vthreshold-microvolt = <50000>;
+		qcom,rx-device = <&wcd_rx>;
+		qcom,tx-device = <&wcd_tx>;
+
+		reset-gpios = <&tlmm 108 GPIO_ACTIVE_LOW>;
+
+		vdd-buck-supply = <&vreg_l15b_1p8>;
+		vdd-rxtx-supply = <&vreg_l15b_1p8>;
+		vdd-io-supply = <&vreg_l15b_1p8>;
+		vdd-mic-bias-supply = <&vreg_bob1>;
+
+		#sound-dai-cells = <1>;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&volume_up_n>;
+		pinctrl-names = "default";
+
+		key-volume-up {
+			label = "Volume Up";
+			linux,code = <KEY_VOLUMEUP>;
+			gpios = <&pm8550_gpios 6 GPIO_ACTIVE_LOW>;
+			debounce-interval = <15>;
+			linux,can-disable;
+			wakeup-source;
+		};
+
+		aya_key {
+			label = "Aya Key";
+			linux,code = <KEY_A>;
+			gpios = <&tlmm 85 GPIO_ACTIVE_LOW>;
+			debounce-interval = <15>;
+			linux,can-disable;
+			wakeup-source;
+		};
+
+		equal_key {
+			label = "Equal Key";
+			linux,code = <KEY_EQUAL>;
+			gpios = <&tlmm 169 GPIO_ACTIVE_LOW>;
+			debounce-interval = <15>;
+			linux,can-disable;
+			wakeup-source;
+		};
+
+		lc_key {
+			label = "LC Key";
+			linux,code = <KEY_LEFT>;
+			gpios = <&tlmm 91 GPIO_ACTIVE_LOW>;
+			debounce-interval = <15>;
+			linux,can-disable;
+			wakeup-source;
+		};
+
+		rc_key {
+			label = "RC Key";
+			linux,code = <KEY_RIGHT>;
+			gpios = <&tlmm 88 GPIO_ACTIVE_LOW>;
+			debounce-interval = <15>;
+			linux,can-disable;
+			wakeup-source;
+		};
+
+		rc2_key {
+			label = "RC2 Key";
+			linux,code = <KEY_RIGHTSHIFT>;
+			gpios = <&tlmm 170 GPIO_ACTIVE_LOW>;
+			debounce-interval = <15>;
+			linux,can-disable;
+			wakeup-source;
+		};
+
+		standard_key {
+			label = "Standard Key";
+			linux,code = <KEY_YELLOW>;
+			gpios = <&tlmm 109 GPIO_ACTIVE_LOW>;
+			debounce-interval = <15>;
+			linux,can-disable;
+			wakeup-source;
+		};
+	};
+
+	pmic-glink {
+		compatible = "qcom,sm8550-pmic-glink", "qcom,pmic-glink";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		orientation-gpios = <&tlmm 11 GPIO_ACTIVE_HIGH>;
+
+		connector@0 {
+			compatible = "usb-c-connector";
+			reg = <0>;
+			power-role = "dual";
+			data-role = "dual";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+
+					pmic_glink_hs_in: endpoint {
+						remote-endpoint = <&usb_1_dwc3_hs>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+
+					pmic_glink_ss_in: endpoint {
+						remote-endpoint = <&redriver_ss_out>;
+					};
+				};
+			};
+		};
+	};
+
+	vph_pwr: regulator-vph-pwr {
+		compatible = "regulator-fixed";
+		regulator-name = "vph_pwr";
+		regulator-min-microvolt = <3700000>;
+		regulator-max-microvolt = <3700000>;
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	fan0: pwm-fan {
+		compatible = "pwm-fan";
+		#cooling-cells = <2>;
+		interrupt-parent = <&tlmm>;
+		interrupts = <64 IRQ_TYPE_EDGE_FALLING>;
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&fan0_pwr_active>;
+		pinctrl-1 = <&fan0_pwr_sleep>;
+		pwms = <&pm8550_pwm 3 1000000>;
+		cooling-levels = <0 64 128 255>;
+	};
+
+	thermal-zones {
+		cpu7-top-thermal {
+			cooling-maps {
+				map0 {
+					trip = <&cpu7_top_alert0 0>;
+					cooling-device = <&fan0 THERMAL_NO_LIMIT 1>;
+				};
+
+				map1 {
+					trip = <&cpu7_top_alert1 0>;
+					cooling-device = <&fan0 2 3>;
+				};
+
+				map2 {
+					trip = <&cpu7_top_crit 0>;
+					cooling-device = <&fan0 4 THERMAL_NO_LIMIT>;
+				};
+			};
+		};
+	};
+
+	sound {
+		compatible = "qcom,sm8550-sndcard", "qcom,sm8450-sndcard";
+		model = "SM8550-HDK";
+		audio-routing = "SpkrLeft IN", "WSA_SPK1 OUT",
+				"SpkrRight IN", "WSA_SPK2 OUT",
+				"IN1_HPHL", "HPHL_OUT",
+				"IN2_HPHR", "HPHR_OUT",
+				"AMIC1", "MIC BIAS1",
+				"AMIC2", "MIC BIAS2",
+				"AMIC5", "MIC BIAS4",
+				"TX SWR_INPUT0", "ADC1_OUTPUT",
+				"TX SWR_INPUT1", "ADC2_OUTPUT",
+				"TX SWR_INPUT1", "ADC4_OUTPUT";
+
+		wcd-playback-dai-link {
+			link-name = "WCD Playback";
+
+			cpu {
+				sound-dai = <&q6apmbedai RX_CODEC_DMA_RX_0>;
+			};
+
+			codec {
+				sound-dai = <&wcd938x 0>, <&swr1 0>, <&lpass_rxmacro 0>;
+			};
+
+			platform {
+				sound-dai = <&q6apm>;
+			};
+		};
+
+		wcd-capture-dai-link {
+			link-name = "WCD Capture";
+
+			cpu {
+				sound-dai = <&q6apmbedai TX_CODEC_DMA_TX_3>;
+			};
+
+			codec {
+				sound-dai = <&wcd938x 1>, <&swr2 0>, <&lpass_txmacro 0>;
+			};
+
+			platform {
+				sound-dai = <&q6apm>;
+			};
+		};
+
+		wsa-dai-link {
+			link-name = "WSA Playback";
+
+			cpu {
+				sound-dai = <&q6apmbedai WSA_CODEC_DMA_RX_0>;
+			};
+
+			codec {
+				sound-dai = <&north_spkr>, <&south_spkr>, <&swr0 0>, <&lpass_wsamacro 0>;
+			};
+
+			platform {
+				sound-dai = <&q6apm>;
+			};
+		};
+
+		va-dai-link {
+			link-name = "VA Capture";
+
+			cpu {
+				sound-dai = <&q6apmbedai TX_CODEC_DMA_TX_3>;
+			};
+
+			codec {
+				sound-dai = <&lpass_vamacro 0>;
+			};
+
+			platform {
+				sound-dai = <&q6apm>;
+			};
+		};
+	};
+
+	wcn7850-pmu {
+		compatible = "qcom,wcn7850-pmu";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&wlan_en>, <&bt_default>, <&pmk8550_sleep_clk>;
+
+		wlan-enable-gpios = <&tlmm 80 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 81 GPIO_ACTIVE_HIGH>;
+
+		vdd-supply = <&vreg_s5g_0p85>;
+		vddio-supply = <&vreg_l15b_1p8>;
+		vddaon-supply = <&vreg_s2g_0p85>;
+		vdddig-supply = <&vreg_s4e_0p95>;
+		vddrfa1p2-supply = <&vreg_s4g_1p25>;
+		vddrfa1p8-supply = <&vreg_s6g_1p86>;
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p8: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p8";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
+};
+
+
+&apps_rsc {
+	regulators-0 {
+		compatible = "qcom,pm8550-rpmh-regulators";
+		qcom,pmic-id = "b";
+
+		vdd-bob1-supply = <&vph_pwr>;
+		vdd-bob2-supply = <&vph_pwr>;
+		vdd-l1-l4-l10-supply = <&vreg_s6g_1p86>;
+		vdd-l2-l13-l14-supply = <&vreg_bob1>;
+		vdd-l3-supply = <&vreg_s4g_1p25>;
+		vdd-l5-l16-supply = <&vreg_bob1>;
+		vdd-l6-l7-supply = <&vreg_bob1>;
+		vdd-l8-l9-supply = <&vreg_bob1>;
+		vdd-l11-supply = <&vreg_s4g_1p25>;
+		vdd-l12-supply = <&vreg_s6g_1p86>;
+		vdd-l15-supply = <&vreg_s6g_1p86>;
+		vdd-l17-supply = <&vreg_bob2>;
+
+		vreg_bob1: bob1 {
+			regulator-name = "vreg_bob1";
+			regulator-min-microvolt = <3296000>;
+			regulator-max-microvolt = <3960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_bob2: bob2 {
+			regulator-name = "vreg_bob2";
+			regulator-min-microvolt = <2720000>;
+			regulator-max-microvolt = <3960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l1b_1p8: ldo1 {
+			regulator-name = "vreg_l1b_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l2b_3p0: ldo2 {
+			regulator-name = "vreg_l2b_3p0";
+			regulator-min-microvolt = <3008000>;
+			regulator-max-microvolt = <3008000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l5b_3p1: ldo5 {
+			regulator-name = "vreg_l5b_3p1";
+			regulator-min-microvolt = <3104000>;
+			regulator-max-microvolt = <3104000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l6b_1p8: ldo6 {
+			regulator-name = "vreg_l6b_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3008000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7b_1p8: ldo7 {
+			regulator-name = "vreg_l7b_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3008000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l8b_1p8: ldo8 {
+			regulator-name = "vreg_l8b_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3008000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l9b_2p9: ldo9 {
+			regulator-name = "vreg_l9b_2p9";
+			regulator-min-microvolt = <2960000>;
+			regulator-max-microvolt = <3008000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l11b_1p2: ldo11 {
+			regulator-name = "vreg_l11b_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1504000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l12b_1p8: ldo12 {
+			regulator-name = "vreg_l12b_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l13b_3p0: ldo13 {
+			regulator-name = "vreg_l13b_3p0";
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l14b_3p2: ldo14 {
+			regulator-name = "vreg_l14b_3p2";
+			regulator-min-microvolt = <3200000>;
+			regulator-max-microvolt = <3200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l15b_1p8: ldo15 {
+			regulator-name = "vreg_l15b_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l16b_2p8: ldo16 {
+			regulator-name = "vreg_l16b_2p8";
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <2800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l17b_2p5: ldo17 {
+			regulator-name = "vreg_l17b_2p5";
+			regulator-min-microvolt = <2504000>;
+			regulator-max-microvolt = <2504000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+
+	regulators-1 {
+		compatible = "qcom,pm8550vs-rpmh-regulators";
+		qcom,pmic-id = "c";
+
+		vdd-l1-supply = <&vreg_s4g_1p25>;
+		vdd-l2-supply = <&vreg_s4e_0p95>;
+		vdd-l3-supply = <&vreg_s4e_0p95>;
+
+		vreg_l3c_0p9: ldo3 {
+			regulator-name = "vreg_l3c_0p9";
+			regulator-min-microvolt = <880000>;
+			regulator-max-microvolt = <912000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+
+	regulators-2 {
+		compatible = "qcom,pm8550vs-rpmh-regulators";
+		qcom,pmic-id = "d";
+
+		vdd-l1-supply = <&vreg_s4e_0p95>;
+		vdd-l2-supply = <&vreg_s4e_0p95>;
+		vdd-l3-supply = <&vreg_s4e_0p95>;
+
+		vreg_l1d_0p88: ldo1 {
+			regulator-name = "vreg_l1d_0p88";
+			regulator-min-microvolt = <880000>;
+			regulator-max-microvolt = <920000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		/* ldo2 supplies SM8550 VDD_LPI_MX */
+	};
+
+	regulators-3 {
+		compatible = "qcom,pm8550vs-rpmh-regulators";
+		qcom,pmic-id = "e";
+
+		vdd-l1-supply = <&vreg_s4e_0p95>;
+		vdd-l2-supply = <&vreg_s4e_0p95>;
+		vdd-l3-supply = <&vreg_s4g_1p25>;
+		vdd-s4-supply = <&vph_pwr>;
+		vdd-s5-supply = <&vph_pwr>;
+
+		vreg_s4e_0p95: smps4 {
+			regulator-name = "vreg_s4e_0p95";
+			regulator-min-microvolt = <904000>;
+			regulator-max-microvolt = <984000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_s5e_1p08: smps5 {
+			regulator-name = "vreg_s5e_1p08";
+			regulator-min-microvolt = <1080000>;
+			regulator-max-microvolt = <1120000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l1e_0p88: ldo1 {
+			regulator-name = "vreg_l1e_0p88";
+			regulator-min-microvolt = <880000>;
+			regulator-max-microvolt = <880000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l2e_0p9: ldo2 {
+			regulator-name = "vreg_l2e_0p9";
+			regulator-min-microvolt = <904000>;
+			regulator-max-microvolt = <970000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3e_1p2: ldo3 {
+			regulator-name = "vreg_l3e_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+
+	regulators-4 {
+		compatible = "qcom,pm8550ve-rpmh-regulators";
+		qcom,pmic-id = "f";
+
+		vdd-l1-supply = <&vreg_s4e_0p95>;
+		vdd-l2-supply = <&vreg_s4e_0p95>;
+		vdd-l3-supply = <&vreg_s4e_0p95>;
+		vdd-s4-supply = <&vph_pwr>;
+
+		vreg_s4f_0p5: smps4 {
+			regulator-name = "vreg_s4f_0p5";
+			regulator-min-microvolt = <500000>;
+			regulator-max-microvolt = <700000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l1f_0p9: ldo1 {
+			regulator-name = "vreg_l1f_0p9";
+			regulator-min-microvolt = <912000>;
+			regulator-max-microvolt = <912000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l2f_0p88: ldo2 {
+			regulator-name = "vreg_l2f_0p88";
+			regulator-min-microvolt = <880000>;
+			regulator-max-microvolt = <912000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3f_0p88: ldo3 {
+			regulator-name = "vreg_l3f_0p88";
+			regulator-min-microvolt = <880000>;
+			regulator-max-microvolt = <912000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+
+	regulators-5 {
+		compatible = "qcom,pm8550vs-rpmh-regulators";
+		qcom,pmic-id = "g";
+
+		vdd-l1-supply = <&vreg_s4g_1p25>;
+		vdd-l2-supply = <&vreg_s4g_1p25>;
+		vdd-l3-supply = <&vreg_s4g_1p25>;
+		vdd-s1-supply = <&vph_pwr>;
+		vdd-s2-supply = <&vph_pwr>;
+		vdd-s3-supply = <&vph_pwr>;
+		vdd-s4-supply = <&vph_pwr>;
+		vdd-s5-supply = <&vph_pwr>;
+		vdd-s6-supply = <&vph_pwr>;
+
+		vreg_s1g_1p25: smps1 {
+			regulator-name = "vreg_s1g_1p25";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1300000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_s2g_0p85: smps2 {
+			regulator-name = "vreg_s2g_0p85";
+			regulator-min-microvolt = <800000>;
+			regulator-max-microvolt = <1000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_s3g_0p8: smps3 {
+			regulator-name = "vreg_s3g_0p8";
+			regulator-min-microvolt = <300000>;
+			regulator-max-microvolt = <1004000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_s4g_1p25: smps4 {
+			regulator-name = "vreg_s4g_1p25";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1352000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_s5g_0p85: smps5 {
+			regulator-name = "vreg_s5g_0p85";
+			regulator-min-microvolt = <500000>;
+			regulator-max-microvolt = <1004000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_s6g_1p86: smps6 {
+			regulator-name = "vreg_s6g_1p86";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l1g_1p2: ldo1 {
+			regulator-name = "vreg_l1g_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3g_1p2: ldo3 {
+			regulator-name = "vreg_l3g_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+
+	regulators-6 {
+		compatible = "qcom,pm8010-rpmh-regulators";
+		qcom,pmic-id = "m";
+
+		vdd-l1-l2-supply = <&vreg_s4g_1p25>;
+		vdd-l3-l4-supply = <&vreg_bob2>;
+		vdd-l5-supply = <&vreg_s6g_1p86>;
+		vdd-l6-supply = <&vreg_s6g_1p86>;
+		vdd-l7-supply = <&vreg_bob1>;
+
+		vreg_l1m_1p056: ldo1 {
+			regulator-name = "vreg_l1m_1p056";
+			regulator-min-microvolt = <1056000>;
+			regulator-max-microvolt = <1056000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l2m_1p056: ldo2 {
+			regulator-name = "vreg_l2m_1p056";
+			regulator-min-microvolt = <1056000>;
+			regulator-max-microvolt = <1056000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3m_2p8: ldo3 {
+			regulator-name = "vreg_l3m_2p8";
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <2800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l4m_2p8: ldo4 {
+			regulator-name = "vreg_l4m_2p8";
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <2800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l5m_1p8: ldo5 {
+			regulator-name = "vreg_l5m_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l6m_1p8: ldo6 {
+			regulator-name = "vreg_l6m_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7m_2p9: ldo7 {
+			regulator-name = "vreg_l7m_2p9";
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <2904000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+
+	regulators-7 {
+		compatible = "qcom,pm8010-rpmh-regulators";
+		qcom,pmic-id = "n";
+
+		vdd-l1-l2-supply = <&vreg_s4g_1p25>;
+		vdd-l3-l4-supply = <&vreg_bob2>;
+		vdd-l5-supply = <&vreg_s6g_1p86>;
+		vdd-l6-supply = <&vreg_bob1>;
+		vdd-l7-supply = <&vreg_bob1>;
+
+		vreg_l1n_1p1: ldo1 {
+			regulator-name = "vreg_l1n_1p1";
+			regulator-min-microvolt = <1104000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l2n_1p1: ldo2 {
+			regulator-name = "vreg_l2n_1p1";
+			regulator-min-microvolt = <1104000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3n_2p8: ldo3 {
+			regulator-name = "vreg_l3n_2p8";
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <3000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l4n_2p8: ldo4 {
+			regulator-name = "vreg_l4n_2p8";
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l5n_1p8: ldo5 {
+			regulator-name = "vreg_l5n_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l6n_3p3: ldo6 {
+			regulator-name = "vreg_l6n_3p3";
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <3304000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7n_2p96: ldo7 {
+			regulator-name = "vreg_l7n_2p96";
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+};
+
+&i2c_master_hub_0 {
+	status = "okay";
+};
+
+&i2c_hub_2 {
+	status = "okay";
+
+	typec-retimer@1c {
+		compatible = "onnn,nb7vpq904m";
+		reg = <0x1c>;
+
+		vcc-supply = <&vreg_l15b_1p8>;
+
+		retimer-switch;
+		orientation-switch;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				redriver_ss_out: endpoint {
+					remote-endpoint = <&pmic_glink_ss_in>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+
+				redriver_ss_in: endpoint {
+					data-lanes = <3 2 1 0>;
+					remote-endpoint = <&usb_dp_qmpphy_out>;
+				};
+			};
+		};
+	};
+};
+
+&i2c0 {
+	status = "okay";
+	/* Screen power */
+	// sgm3804@3e
+
+	/* Backlight */
+	// sy7758vgs@2e
+};
+
+
+&i2c4 {
+	status = "okay";
+
+	touchscreen@5d {
+		reg = <0x5d>;
+		status = "okay";
+		compatible = "goodix,gt967";
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <25 IRQ_TYPE_LEVEL_LOW>;
+
+		reset-gpios = <&tlmm 24 GPIO_ACTIVE_HIGH>;
+		AVDD28-supply = <&vreg_l14b_3p2>;
+
+		touchscreen-size-x = <1440>;
+		touchscreen-size-y = <2560>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&ts_irq>, <&ts_reset>;
+	};
+};
+
+&ipa {
+	qcom,gsi-loader = "self";
+	memory-region = <&ipa_fw_mem>;
+	firmware-name = "qcom/sm8550/ayaneo/ipa_fws.mdt";
+	status = "okay";
+};
+
+&gpi_dma1 {
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+
+	zap-shader {
+		firmware-name = "qcom/sm8550/a740_zap.mbn";
+	};
+};
+
+&mdss {
+	status = "okay";
+};
+
+/* wt0600 60hz 2k dual dsi dphy panel */
+&mdss_dsi0 {
+	vdda-supply = <&vreg_l3e_1p2>;
+	qcom,dual-dsi-mode;
+	qcom,sync-dual-dsi;
+	qcom,master-dsi;
+	status = "disabled";
+
+	panel@0 {
+		compatible = "ayaneo,wt0600-2k";
+		reg = <0>;
+		// sy7758vgs not available currently
+		// backlight = <&sy7758vgs>;
+		pinctrl-0 = <&sde_dsi_active>, <&sde_te_active>;
+		pinctrl-1 = <&sde_dsi_suspend>, <&sde_te_suspend>;
+		pinctrl-names = "default", "sleep";
+
+		vci-supply = <&vreg_l13b_3p0>;
+		vdd-supply = <&vreg_l11b_1p2>;
+		vddio-supply = <&vreg_l12b_1p8>;
+
+		reset-gpios = <&tlmm 133 GPIO_ACTIVE_LOW>;
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+				reg = <0>;
+				panel0_in_0: endpoint {
+					remote-endpoint = <&mdss_dsi0_out>;
+				};
+			};
+			port@1{
+				reg = <1>;
+				panel0_in_1: endpoint {
+					remote-endpoint = <&mdss_dsi1_out>;
+				};
+			};
+		};
+	};
+};
+
+&mdss_dsi0 {
+	vdda-supply = <&vreg_l3e_1p2>;
+	status = "okay";
+};
+
+&mdss_dsi0_out {
+	remote-endpoint = <&panel0_in_0>;
+	data-lanes = <0 1 2 3>;
+};
+
+&mdss_dsi0_phy {
+	vdds-supply = <&vreg_l1e_0p88>;
+	status = "okay";
+};
+
+&mdss_dsi1 {
+	vdda-supply = <&vreg_l3e_1p2>;
+	qcom,dual-dsi-mode;
+	qcom,sync-dual-dsi;
+	assigned-clock-parents = <&mdss_dsi0_phy 0>, <&mdss_dsi0_phy 1>;
+	status = "okay";
+};
+
+&mdss_dsi1_out {
+	remote-endpoint = <&panel0_in_1>;
+	data-lanes = <0 1 2 3>;
+};
+
+&mdss_dsi1_phy {
+	vdds-supply = <&vreg_l1e_0p88>;
+	status = "okay";
+};
+
+&mdss_dp0 {
+	status = "okay";
+};
+
+&mdss_dp0_out {
+	data-lanes = <0 1>;
+};
+
+&pcie0 {
+	wake-gpios = <&tlmm 96 GPIO_ACTIVE_HIGH>;
+	perst-gpios = <&tlmm 94 GPIO_ACTIVE_LOW>;
+
+	pinctrl-0 = <&pcie0_default_state>;
+	pinctrl-names = "default";
+
+	status = "okay";
+};
+
+&pcieport0 {
+	wifi@0 {
+		compatible = "pci17cb,1107";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
+&pcie0_phy {
+	vdda-phy-supply = <&vreg_l1e_0p88>;
+	vdda-pll-supply = <&vreg_l3e_1p2>;
+
+	status = "okay";
+};
+
+&pcie1 {
+	wake-gpios = <&tlmm 99 GPIO_ACTIVE_HIGH>;
+	perst-gpios = <&tlmm 97 GPIO_ACTIVE_LOW>;
+
+	pinctrl-0 = <&pcie1_default_state>;
+	pinctrl-names = "default";
+
+	status = "okay";
+};
+
+&pcie1_phy {
+	vdda-phy-supply = <&vreg_l3c_0p9>;
+	vdda-pll-supply = <&vreg_l3e_1p2>;
+	vdda-qref-supply = <&vreg_l1e_0p88>;
+
+	status = "okay";
+};
+
+&pm8550_gpios {
+	sdc2_card_det_n: sdc2-card-det-state {
+		pins = "gpio12";
+		function = "normal";
+		input-enable;
+		output-disable;
+		bias-pull-up;
+		power-source = <1>; /* 1.8 V */
+	};
+
+	volume_up_n: volume-up-n-state {
+		pins = "gpio6";
+		function = "normal";
+		power-source = <1>;
+		bias-pull-up;
+		input-enable;
+	};
+};
+
+&pm8550_pwm {
+	status = "okay";
+
+	multi-led {
+		color = <LED_COLOR_ID_RGB>;
+		function = LED_FUNCTION_STATUS;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		led@1 {
+			reg = <1>;
+			color = <LED_COLOR_ID_RED>;
+		};
+
+		led@2 {
+			reg = <2>;
+			color = <LED_COLOR_ID_GREEN>;
+		};
+
+		led@3 {
+			reg = <3>;
+			color = <LED_COLOR_ID_BLUE>;
+		};
+	};
+};
+
+&pm8550b_eusb2_repeater {
+	vdd18-supply = <&vreg_l15b_1p8>;
+	vdd3-supply = <&vreg_l5b_3p1>;
+};
+
+&pon_pwrkey {
+	status = "okay";
+};
+
+&pon_resin {
+	linux,code = <KEY_VOLUMEDOWN>;
+
+	status = "okay";
+};
+
+&pmk8550_gpios {
+	pmk8550_sleep_clk: sleep-clk-state {
+		pins = "gpio3";
+		function = "func1";
+		input-disable;
+		output-enable;
+		bias-disable;
+		power-source = <0>;
+	};
+};
+
+&qupv3_id_0 {
+	status = "okay";
+	uart5: uart@a94000 {
+		compatible = "qcom,geni-uart";
+		reg = <0 0x00a94000 0 0x4000>;
+		clock-names = "se";
+		clocks = <&gcc GCC_QUPV3_WRAP1_S5_CLK>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&qup_uart5_default>;
+		interrupts = <GIC_SPI 358 IRQ_TYPE_LEVEL_HIGH>;
+		interconnects = <&clk_virt MASTER_QUP_CORE_1 0 &clk_virt SLAVE_QUP_CORE_1 0>,
+						<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_QUP_1 0>;
+		interconnect-names = "qup-core", "qup-config";
+		status = "disabled";
+	};
+};
+
+&qupv3_id_1 {
+	status = "okay";
+	uart11: uart@88c000 {
+		compatible = "qcom,geni-uart";
+		reg = <0 0x0088c000 0 0x4000>;
+		clock-names = "se";
+		clocks = <&gcc GCC_QUPV3_WRAP2_S3_CLK>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&qup_uart11_default>;
+		interrupts = <GIC_SPI 585 IRQ_TYPE_LEVEL_HIGH>;
+		interconnects = <&clk_virt MASTER_QUP_CORE_2 0 &clk_virt SLAVE_QUP_CORE_2 0>,
+						<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_QUP_2 0>;
+		interconnect-names = "qup-core", "qup-config";
+		status = "disabled";
+	};
+};
+
+&remoteproc_adsp {
+	firmware-name = "qcom/sm8550/ayaneo/adsp.mdt",
+			"qcom/sm8550/ayaneo/adsp_dtb.mdt";
+	status = "okay";
+};
+
+&remoteproc_cdsp {
+	firmware-name = "qcom/sm8550/ayaneo/cdsp.mdt",
+			"qcom/sm8550/ayaneo/cdsp_dtb.mdt";
+	status = "okay";
+};
+
+&remoteproc_mpss {
+	firmware-name = "qcom/sm8550/ayaneo/modem.mdt",
+			"qcom/sm8550/ayaneo/modem_dtb.mdt";
+	status = "okay";
+};
+
+&sdhc_2 {
+	cd-gpios = <&pm8550_gpios 12 GPIO_ACTIVE_HIGH>;
+
+	pinctrl-0 = <&sdc2_default>, <&sdc2_card_det_n>;
+	pinctrl-1 = <&sdc2_sleep>, <&sdc2_card_det_n>;
+	pinctrl-names = "default", "sleep";
+
+	vmmc-supply = <&vreg_l9b_2p9>;
+	vqmmc-supply = <&vreg_l8b_1p8>;
+
+	bus-width = <4>;
+	no-sdio;
+	no-mmc;
+
+	status = "okay";
+};
+
+&sleep_clk {
+	clock-frequency = <32000>;
+};
+
+&swr0 {
+	status = "okay";
+
+	/* WSA8845, Speaker North */
+	north_spkr: speaker@0,0 {
+		compatible = "sdw20217020400";
+		reg = <0 0>;
+
+		pinctrl-0 = <&spkr_1_sd_n_active>;
+		pinctrl-names = "default";
+
+		powerdown-gpios = <&tlmm 7 GPIO_ACTIVE_LOW>;
+
+		vdd-1p8-supply = <&vreg_l15b_1p8>;
+		vdd-io-supply = <&vreg_l15b_1p8>;
+
+		#sound-dai-cells = <0>;
+		sound-name-prefix = "SpkrLeft";
+		qcom,port-mapping = <1 2 3 7 10 13>;
+	};
+
+	/* WSA8845, Speaker South */
+	south_spkr: speaker@0,1 {
+		compatible = "sdw20217020400";
+		reg = <0 1>;
+
+		pinctrl-0 = <&spkr_2_sd_n_active>;
+		pinctrl-names = "default";
+
+		powerdown-gpios = <&tlmm 12 GPIO_ACTIVE_LOW>;
+
+		vdd-1p8-supply = <&vreg_l15b_1p8>;
+		vdd-io-supply = <&vreg_l15b_1p8>;
+
+		#sound-dai-cells = <0>;
+		sound-name-prefix = "SpkrRight";
+		qcom,port-mapping = <4 5 6 7 11 13>;
+	};
+};
+
+&swr1 {
+	status = "okay";
+
+	/* WCD9385 RX */
+	wcd_rx: codec@0,4 {
+		compatible = "sdw20217010d00";
+		reg = <0 4>;
+
+		/*
+		 * WCD9385 RX Port 1 (HPH_L/R)      <=> SWR1 Port 1 (HPH_L/R)
+		 * WCD9385 RX Port 2 (CLSH)         <=> SWR1 Port 2 (CLSH)
+		 * WCD9385 RX Port 3 (COMP_L/R)     <=> SWR1 Port 3 (COMP_L/R)
+		 * WCD9385 RX Port 4 (LO)           <=> SWR1 Port 4 (LO)
+		 * WCD9385 RX Port 5 (DSD_L/R)      <=> SWR1 Port 5 (DSD_L/R)
+		 */
+		qcom,rx-port-mapping = <1 2 3 4 5>;
+	};
+};
+
+&swr2 {
+	status = "okay";
+
+	/* WCD9385 TX */
+	wcd_tx: codec@0,3 {
+		compatible = "sdw20217010d00";
+		reg = <0 3>;
+
+		/*
+		 * WCD9385 TX Port 1 (ADC1,2)             <=> SWR2 Port 2 (TX SWR_INPUT 0,1,2,3)
+		 * WCD9385 TX Port 2 (ADC3,4)             <=> SWR2 Port 2 (TX SWR_INPUT 0,1,2,3)
+		 * WCD9385 TX Port 3 (DMIC0,1,2,3 & MBHC) <=> SWR2 Port 3 (TX SWR_INPUT 4,5,6,7)
+		 * WCD9385 TX Port 4 (DMIC4,5,6,7)        <=> SWR2 Port 4 (TX SWR_INPUT 8,9,10,11)
+		 */
+		qcom,tx-port-mapping = <2 2 3 4>;
+	};
+};
+
+&tlmm {
+	/* Reserved I/Os for NFC */
+	gpio-reserved-ranges = <32 8>;
+
+	bt_default: bt-default-state {
+		bt-en-pins {
+			pins = "gpio81";
+			function = "gpio";
+			drive-strength = <16>;
+			bias-disable;
+		};
+
+		sw-ctrl-pins {
+			pins = "gpio82";
+			function = "gpio";
+			bias-pull-down;
+		};
+	};
+
+	wcd_default: wcd-reset-n-active-state {
+		pins = "gpio108";
+		function = "gpio";
+		drive-strength = <16>;
+		bias-disable;
+		output-low;
+	};
+
+	wlan_en: wlan-en-state {
+		pins = "gpio80";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-pull-down;
+	};
+
+	
+	sde_dsi_active: sde-dsi-active-state {
+		pins = "gpio133";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	sde_dsi_suspend: sde-dsi-suspend-state {
+		pins = "gpio133";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	sde_te_active: sde-te-active-state {
+		pins = "gpio86";
+		function = "mdp_vsync";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	sde_te_suspend: sde-te-suspend-state {
+		pins = "gpio86";
+		function = "mdp_vsync";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	ts_irq: ts-irq-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+
+	ts_reset: ts-reset-state {
+		pins = "gpio24";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+
+	spkr_1_sd_n_active: spkr-1-sd-n-active-state {
+		pins = "gpio7";
+		function = "gpio";
+		drive-strength = <16>;
+		bias-disable;
+		output-low;
+	};
+
+	spkr_2_sd_n_active: spkr-2-sd-n-active-state {
+		pins = "gpio12";
+		function = "gpio";
+		drive-strength = <16>;
+		bias-disable;
+		output-low;
+	};
+
+	qup_uart5_default: qup-uart5-default-state {
+		/* TX, RX */
+		pins = "gpio54", "gpio55";
+		function = "qup1_se5";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	qup_uart11_default: qup-uart11-default-state {
+		/* TX, RX */
+		pins = "gpio70", "gpio71";
+		function = "qup2_se3";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	upd720201_active: upd720201-active {
+		pins = "gpio10", "gpio18", "gpio13";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+		output-high;
+	};
+
+	fan0_pwr_active: fan0-pwr-active-state {
+		pins = "gpio30","gpio31";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+		output-high;
+	};
+
+	fan0_pwr_sleep: fan0-pwr-sleep-state {
+		pins = "gpio30", "gpio31";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+		output-low;
+	};
+};
+
+&uart7 {
+	status = "okay";
+};
+
+&uart14 {
+	status = "okay";
+
+	bluetooth {
+		compatible = "qcom,wcn7850-bt";
+
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+
+		max-speed = <3200000>;
+	};
+};
+
+&ufs_mem_hc {
+	reset-gpios = <&tlmm 210 GPIO_ACTIVE_LOW>;
+
+	vcc-supply = <&vreg_l17b_2p5>;
+	vcc-max-microamp = <1300000>;
+	vccq-supply = <&vreg_l1g_1p2>;
+	vccq-max-microamp = <1200000>;
+	vdd-hba-supply = <&vreg_l3g_1p2>;
+
+	status = "okay";
+};
+
+&ufs_mem_phy {
+	vdda-phy-supply = <&vreg_l1d_0p88>;
+	vdda-pll-supply = <&vreg_l3e_1p2>;
+
+	status = "okay";
+};
+
+&usb_1 {
+	status = "okay";
+};
+
+&usb_1_dwc3_hs {
+	remote-endpoint = <&pmic_glink_hs_in>;
+};
+
+&usb_1_hsphy {
+	vdd-supply = <&vreg_l1e_0p88>;
+	vdda12-supply = <&vreg_l3e_1p2>;
+
+	phys = <&pm8550b_eusb2_repeater>;
+
+	status = "okay";
+};
+
+&usb_dp_qmpphy {
+	vdda-phy-supply = <&vreg_l3e_1p2>;
+	vdda-pll-supply = <&vreg_l3f_0p88>;
+
+	status = "okay";
+};
+
+&usb_dp_qmpphy_out {
+	remote-endpoint = <&redriver_ss_in>;
+};
+
+&xo_board {
+	clock-frequency = <76800000>;
+};
-- 
2.43.0


From 29af0506211fec9847ad2930f7855343f1ab7195 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sun, 2 Mar 2025 13:20:11 +0000
Subject: [PATCH 22/39] dts: optimize ayaneo pocket s devicetree

---
 arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts | 541 ++++++++----------
 1 file changed, 226 insertions(+), 315 deletions(-)

diff --git a/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts b/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts
index 453189acd9c1..c95b05d3dc69 100644
--- a/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts
+++ b/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts
@@ -8,20 +8,22 @@
 #include <dt-bindings/leds/common.h>
 #include <dt-bindings/regulator/qcom,rpmh-regulator.h>
 #include "sm8550.dtsi"
-#include "pm8010.dtsi"
+// #include "pm8010.dtsi"  // 0xc 0xd
 #include "pm8550.dtsi"
 #include "pm8550b.dtsi"
 #define PMK8550VE_SID 5
 #include "pm8550ve.dtsi"
 #include "pm8550vs.dtsi"
 #include "pmk8550.dtsi"
-#include "pmr735d_a.dtsi"
-#include "pmr735d_b.dtsi"
+// #include "pmr735d_a.dtsi" // 0xa
+// #include "pmr735d_b.dtsi" // 0xb
+
+/delete-node/ &hwfence_shbuf;
 
 / {
 	model = "AYANEO Pocket S 2K";
-	compatible = "qcom,sm8550-hdk", "qcom,sm8550";
-	chassis-type = "tablet";
+	compatible = "qcom,sm8550-qrd", "qcom,sm8550";
+	chassis-type = "handset";
 
 	aliases {
 		serial0 = &uart7;
@@ -40,35 +42,11 @@ framebuffer: framebuffer@b8000000 {
             height = <2560>;
             stride = <(1440 * 4)>;
             format = "a8r8g8b8";
-        };
+			clocks = <&gcc GCC_DISP_AHB_CLK>,
+				 <&gcc GCC_DISP_HF_AXI_CLK>;
+		};
     };
 
-	wcd938x: audio-codec {
-		compatible = "qcom,wcd9385-codec";
-
-		pinctrl-names = "default";
-		pinctrl-0 = <&wcd_default>;
-
-		qcom,micbias1-microvolt = <1800000>;
-		qcom,micbias2-microvolt = <1800000>;
-		qcom,micbias3-microvolt = <1800000>;
-		qcom,micbias4-microvolt = <1800000>;
-		qcom,mbhc-buttons-vthreshold-microvolt = <75000 150000 237000 500000 500000 500000 500000 500000>;
-		qcom,mbhc-headset-vthreshold-microvolt = <1700000>;
-		qcom,mbhc-headphone-vthreshold-microvolt = <50000>;
-		qcom,rx-device = <&wcd_rx>;
-		qcom,tx-device = <&wcd_tx>;
-
-		reset-gpios = <&tlmm 108 GPIO_ACTIVE_LOW>;
-
-		vdd-buck-supply = <&vreg_l15b_1p8>;
-		vdd-rxtx-supply = <&vreg_l15b_1p8>;
-		vdd-io-supply = <&vreg_l15b_1p8>;
-		vdd-mic-bias-supply = <&vreg_bob1>;
-
-		#sound-dai-cells = <1>;
-	};
-
 	chosen {
 		stdout-path = "serial0:115200n8";
 	};
@@ -76,12 +54,12 @@ chosen {
 	gpio-keys {
 		compatible = "gpio-keys";
 
-		pinctrl-0 = <&volume_up_n>;
+		pinctrl-0 = <&volume_down_n>, <&gamepad_key_n>;
 		pinctrl-names = "default";
 
-		key-volume-up {
-			label = "Volume Up";
-			linux,code = <KEY_VOLUMEUP>;
+		key-volume-down {
+			label = "Volume Down";
+			linux,code = <KEY_VOLUMEDOWN>;
 			gpios = <&pm8550_gpios 6 GPIO_ACTIVE_LOW>;
 			debounce-interval = <15>;
 			linux,can-disable;
@@ -193,78 +171,102 @@ fan0: pwm-fan {
 		interrupt-parent = <&tlmm>;
 		interrupts = <64 IRQ_TYPE_EDGE_FALLING>;
 		pinctrl-names = "default", "sleep";
-		pinctrl-0 = <&fan0_pwr_active>;
+		pinctrl-0 = <&fan0_pwr_active>, <&pwm_fan_ctrl_default>;
 		pinctrl-1 = <&fan0_pwr_sleep>;
 		pwms = <&pm8550_pwm 3 1000000>;
-		cooling-levels = <0 64 128 255>;
+		cooling-levels = <255 192 160 128 96 32 16 0>;
 	};
 
 	thermal-zones {
 		cpu7-top-thermal {
+			trips {
+				cpu7_top_trip0: trip-point2 {
+					temperature = <40000>;
+					hysteresis = <4000>;
+					type = "passive";
+				};
+
+				cpu7_top_trip1: trip-point3 {
+					temperature = <50000>;
+					hysteresis = <4000>;
+					type = "passive";
+				};
+				
+				cpu7_top_trip2: trip-point4 {
+					temperature = <60000>;
+					hysteresis = <4000>;
+					type = "passive";
+				};
+
+				cpu7_top_trip3: trip-point5 {
+					temperature = <70000>;
+					hysteresis = <4000>;
+					type = "passive";
+				};
+			};
+
 			cooling-maps {
 				map0 {
-					trip = <&cpu7_top_alert0 0>;
-					cooling-device = <&fan0 THERMAL_NO_LIMIT 1>;
+					trip = <&cpu7_top_trip0>;
+					cooling-device = <&fan0 1 1>;
 				};
 
 				map1 {
-					trip = <&cpu7_top_alert1 0>;
-					cooling-device = <&fan0 2 3>;
+					trip = <&cpu7_top_trip1>;
+					cooling-device = <&fan0 2 2>;
 				};
 
 				map2 {
-					trip = <&cpu7_top_crit 0>;
-					cooling-device = <&fan0 4 THERMAL_NO_LIMIT>;
+					trip = <&cpu7_top_trip2>;
+					cooling-device = <&fan0 3 3>;
 				};
-			};
-		};
-	};
 
-	sound {
-		compatible = "qcom,sm8550-sndcard", "qcom,sm8450-sndcard";
-		model = "SM8550-HDK";
-		audio-routing = "SpkrLeft IN", "WSA_SPK1 OUT",
-				"SpkrRight IN", "WSA_SPK2 OUT",
-				"IN1_HPHL", "HPHL_OUT",
-				"IN2_HPHR", "HPHR_OUT",
-				"AMIC1", "MIC BIAS1",
-				"AMIC2", "MIC BIAS2",
-				"AMIC5", "MIC BIAS4",
-				"TX SWR_INPUT0", "ADC1_OUTPUT",
-				"TX SWR_INPUT1", "ADC2_OUTPUT",
-				"TX SWR_INPUT1", "ADC4_OUTPUT";
-
-		wcd-playback-dai-link {
-			link-name = "WCD Playback";
+				map3 {
+					trip = <&cpu7_top_trip3>;
+					cooling-device = <&fan0 4 4>;
+				};
 
-			cpu {
-				sound-dai = <&q6apmbedai RX_CODEC_DMA_RX_0>;
-			};
+				map4 {
+					trip = <&cpu7_top_alert0>;
+					cooling-device = <&fan0 5 5>;
+				};
 
-			codec {
-				sound-dai = <&wcd938x 0>, <&swr1 0>, <&lpass_rxmacro 0>;
-			};
+				map5 {
+					trip = <&cpu7_top_alert1>;
+					cooling-device = <&fan0 6 6>;
+				};
 
-			platform {
-				sound-dai = <&q6apm>;
+				map6 {
+					trip = <&cpu7_top_crit>;
+					cooling-device = <&fan0 7 THERMAL_NO_LIMIT>;
+				};
 			};
 		};
+	};
 
-		wcd-capture-dai-link {
-			link-name = "WCD Capture";
-
-			cpu {
-				sound-dai = <&q6apmbedai TX_CODEC_DMA_TX_3>;
-			};
+	reserved-memory {
+		chipinfo_region: memory@81cf4000 {
+            reg = <0x00 0x81cf4000 0x00 0x1000>;
+            no-map;
+        };
 
-			codec {
-				sound-dai = <&wcd938x 1>, <&swr2 0>, <&lpass_txmacro 0>;
-			};
+		hwfence_shbuf: memory@e6440000 {
+			reg = <0x00 0xe6440000 0x00 0x2dd000>;
+            no-map;
+        };
 
-			platform {
-				sound-dai = <&q6apm>;
-			};
+		splash_region: splash_region@b8000000 { 
+			reg = <0x0 0xb8000000 0x0 0x2b00000>;
+			no-map;
 		};
+	};
+
+	sound {
+		status = "disabled";
+		compatible = "qcom,sm8550-sndcard", "qcom,sm8450-sndcard";
+		model = "SM8550-APS";
+		audio-routing = "SpkrLeft IN", "WSA_SPK1 OUT",
+				"SpkrRight IN", "WSA_SPK2 OUT";
 
 		wsa-dai-link {
 			link-name = "WSA Playback";
@@ -301,7 +303,7 @@ platform {
 
 	wcn7850-pmu {
 		compatible = "qcom,wcn7850-pmu";
-
+		status = "disabled";
 		pinctrl-names = "default";
 		pinctrl-0 = <&wlan_en>, <&bt_default>, <&pmk8550_sleep_clk>;
 
@@ -359,7 +361,6 @@ vreg_pmu_pcie_1p8: ldo9 {
 	};
 };
 
-
 &apps_rsc {
 	regulators-0 {
 		compatible = "qcom,pm8550-rpmh-regulators";
@@ -441,6 +442,13 @@ vreg_l9b_2p9: ldo9 {
 			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
 		};
 
+		vreg_l10b_1p8: ldo10 {
+			regulator-name = "vreg_l10b_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
 		vreg_l11b_1p2: ldo11 {
 			regulator-name = "vreg_l11b_1p2";
 			regulator-min-microvolt = <1200000>;
@@ -679,126 +687,6 @@ vreg_l3g_1p2: ldo3 {
 			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
 		};
 	};
-
-	regulators-6 {
-		compatible = "qcom,pm8010-rpmh-regulators";
-		qcom,pmic-id = "m";
-
-		vdd-l1-l2-supply = <&vreg_s4g_1p25>;
-		vdd-l3-l4-supply = <&vreg_bob2>;
-		vdd-l5-supply = <&vreg_s6g_1p86>;
-		vdd-l6-supply = <&vreg_s6g_1p86>;
-		vdd-l7-supply = <&vreg_bob1>;
-
-		vreg_l1m_1p056: ldo1 {
-			regulator-name = "vreg_l1m_1p056";
-			regulator-min-microvolt = <1056000>;
-			regulator-max-microvolt = <1056000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-
-		vreg_l2m_1p056: ldo2 {
-			regulator-name = "vreg_l2m_1p056";
-			regulator-min-microvolt = <1056000>;
-			regulator-max-microvolt = <1056000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-
-		vreg_l3m_2p8: ldo3 {
-			regulator-name = "vreg_l3m_2p8";
-			regulator-min-microvolt = <2800000>;
-			regulator-max-microvolt = <2800000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-
-		vreg_l4m_2p8: ldo4 {
-			regulator-name = "vreg_l4m_2p8";
-			regulator-min-microvolt = <2800000>;
-			regulator-max-microvolt = <2800000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-
-		vreg_l5m_1p8: ldo5 {
-			regulator-name = "vreg_l5m_1p8";
-			regulator-min-microvolt = <1800000>;
-			regulator-max-microvolt = <1800000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-
-		vreg_l6m_1p8: ldo6 {
-			regulator-name = "vreg_l6m_1p8";
-			regulator-min-microvolt = <1800000>;
-			regulator-max-microvolt = <1800000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-
-		vreg_l7m_2p9: ldo7 {
-			regulator-name = "vreg_l7m_2p9";
-			regulator-min-microvolt = <2800000>;
-			regulator-max-microvolt = <2904000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-	};
-
-	regulators-7 {
-		compatible = "qcom,pm8010-rpmh-regulators";
-		qcom,pmic-id = "n";
-
-		vdd-l1-l2-supply = <&vreg_s4g_1p25>;
-		vdd-l3-l4-supply = <&vreg_bob2>;
-		vdd-l5-supply = <&vreg_s6g_1p86>;
-		vdd-l6-supply = <&vreg_bob1>;
-		vdd-l7-supply = <&vreg_bob1>;
-
-		vreg_l1n_1p1: ldo1 {
-			regulator-name = "vreg_l1n_1p1";
-			regulator-min-microvolt = <1104000>;
-			regulator-max-microvolt = <1200000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-
-		vreg_l2n_1p1: ldo2 {
-			regulator-name = "vreg_l2n_1p1";
-			regulator-min-microvolt = <1104000>;
-			regulator-max-microvolt = <1200000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-
-		vreg_l3n_2p8: ldo3 {
-			regulator-name = "vreg_l3n_2p8";
-			regulator-min-microvolt = <2800000>;
-			regulator-max-microvolt = <3000000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-
-		vreg_l4n_2p8: ldo4 {
-			regulator-name = "vreg_l4n_2p8";
-			regulator-min-microvolt = <2800000>;
-			regulator-max-microvolt = <3300000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-
-		vreg_l5n_1p8: ldo5 {
-			regulator-name = "vreg_l5n_1p8";
-			regulator-min-microvolt = <1800000>;
-			regulator-max-microvolt = <1800000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-
-		vreg_l6n_3p3: ldo6 {
-			regulator-name = "vreg_l6n_3p3";
-			regulator-min-microvolt = <2800000>;
-			regulator-max-microvolt = <3304000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-
-		vreg_l7n_2p96: ldo7 {
-			regulator-name = "vreg_l7n_2p96";
-			regulator-min-microvolt = <2800000>;
-			regulator-max-microvolt = <2960000>;
-			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
-		};
-	};
 };
 
 &i2c_master_hub_0 {
@@ -848,28 +736,35 @@ &i2c0 {
 
 	/* Backlight */
 	// sy7758vgs@2e
+	sy7758vgs_bl: sy7758vgs@2e {
+		compatible = "silergy,sy7758vgs";
+		reg = <0x2e>;
+		status = "disabled";
+	};
 };
 
 
 &i2c4 {
-	status = "okay";
+	status = "disabled";
+	clock-frequency = <400000>;
 
 	touchscreen@5d {
 		reg = <0x5d>;
 		status = "okay";
-		compatible = "goodix,gt967";
+		compatible = "goodix,gt911";
 
 		interrupt-parent = <&tlmm>;
-		interrupts = <25 IRQ_TYPE_LEVEL_LOW>;
+		interrupts = <25 IRQ_TYPE_EDGE_FALLING>;
 
 		reset-gpios = <&tlmm 24 GPIO_ACTIVE_HIGH>;
+		VDDIO-supply = <&vreg_l14b_3p2>;
 		AVDD28-supply = <&vreg_l14b_3p2>;
 
 		touchscreen-size-x = <1440>;
 		touchscreen-size-y = <2560>;
 
 		pinctrl-names = "default";
-		pinctrl-0 = <&ts_irq>, <&ts_reset>;
+		pinctrl-0 = <&ts_reset>, <&ts_irq>;
 	};
 };
 
@@ -877,7 +772,7 @@ &ipa {
 	qcom,gsi-loader = "self";
 	memory-region = <&ipa_fw_mem>;
 	firmware-name = "qcom/sm8550/ayaneo/ipa_fws.mdt";
-	status = "okay";
+	status = "disabled";
 };
 
 &gpi_dma1 {
@@ -892,32 +787,63 @@ zap-shader {
 	};
 };
 
-&mdss {
-	status = "okay";
-};
+// &dispcc {
+// 	status = "disabled";
+// };
+
+// &mdss {
+// 	status = "disabled";
+// };
+
+// &mdss_dsi0 {
+// 	status = "disabled";
+// };
+
+// &mdss_dsi0_out {
+// 	status = "disabled";
+// };
+
+// &mdss_dsi0_phy {
+// 	status = "disabled";
+// };
+
+// &mdss_dsi1 {
+// 	status = "disabled";
+// };
+
+// &mdss_dsi1_out {
+// 	status = "disabled";
+// };
+
+// &mdss_dsi1_phy {
+// 	status = "disabled";
+// };
+
+// &mdss {
+// 	status = "okay";
+// };
 
 /* wt0600 60hz 2k dual dsi dphy panel */
 &mdss_dsi0 {
 	vdda-supply = <&vreg_l3e_1p2>;
-	qcom,dual-dsi-mode;
-	qcom,sync-dual-dsi;
-	qcom,master-dsi;
-	status = "disabled";
+	// qcom,dual-dsi-mode;
+	// qcom,sync-dual-dsi;
+	// qcom,master-dsi;
+	status = "okay";
 
 	panel@0 {
-		compatible = "ayaneo,wt0600-2k";
+		status = "disabled";
+		compatible = "ayaneo,wt0600-1080p";
 		reg = <0>;
-		// sy7758vgs not available currently
-		// backlight = <&sy7758vgs>;
-		pinctrl-0 = <&sde_dsi_active>, <&sde_te_active>;
+		backlight = <&sy7758vgs_bl>;
+		pinctrl-0 = <&sde_dsi_active>, <&sde_te_active>;//, <&panel_pwr_active>;
 		pinctrl-1 = <&sde_dsi_suspend>, <&sde_te_suspend>;
 		pinctrl-names = "default", "sleep";
 
-		vci-supply = <&vreg_l13b_3p0>;
-		vdd-supply = <&vreg_l11b_1p2>;
-		vddio-supply = <&vreg_l12b_1p8>;
+		vddio-supply = <&vreg_l11b_1p2>;
 
 		reset-gpios = <&tlmm 133 GPIO_ACTIVE_LOW>;
+
 		ports {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -937,11 +863,6 @@ panel0_in_1: endpoint {
 	};
 };
 
-&mdss_dsi0 {
-	vdda-supply = <&vreg_l3e_1p2>;
-	status = "okay";
-};
-
 &mdss_dsi0_out {
 	remote-endpoint = <&panel0_in_0>;
 	data-lanes = <0 1 2 3>;
@@ -985,7 +906,7 @@ &pcie0 {
 	pinctrl-0 = <&pcie0_default_state>;
 	pinctrl-names = "default";
 
-	status = "okay";
+	status = "disabled";
 };
 
 &pcieport0 {
@@ -1009,17 +930,17 @@ &pcie0_phy {
 	vdda-phy-supply = <&vreg_l1e_0p88>;
 	vdda-pll-supply = <&vreg_l3e_1p2>;
 
-	status = "okay";
+	status = "disabled";
 };
 
 &pcie1 {
 	wake-gpios = <&tlmm 99 GPIO_ACTIVE_HIGH>;
 	perst-gpios = <&tlmm 97 GPIO_ACTIVE_LOW>;
 
-	pinctrl-0 = <&pcie1_default_state>;
+	pinctrl-0 = <&pcie1_default_state>, <&upd720201_active>;
 	pinctrl-names = "default";
 
-	status = "okay";
+	status = "disabled";
 };
 
 &pcie1_phy {
@@ -1027,7 +948,7 @@ &pcie1_phy {
 	vdda-pll-supply = <&vreg_l3e_1p2>;
 	vdda-qref-supply = <&vreg_l1e_0p88>;
 
-	status = "okay";
+	status = "disabled";
 };
 
 &pm8550_gpios {
@@ -1040,13 +961,22 @@ sdc2_card_det_n: sdc2-card-det-state {
 		power-source = <1>; /* 1.8 V */
 	};
 
-	volume_up_n: volume-up-n-state {
+	volume_down_n: volume-down-n-state {
 		pins = "gpio6";
 		function = "normal";
 		power-source = <1>;
 		bias-pull-up;
 		input-enable;
 	};
+
+	pwm_fan_ctrl_default: pwm-fan-ctrl-default {
+		pins = "gpio9";
+		function = "func1";
+		output-high;
+		bias-disable;
+		power-source = <0>;
+		qcom,drive-strength = <3>; /* PMIC_GPIO_STRENGTH_LOW */
+	};
 };
 
 &pm8550_pwm {
@@ -1054,7 +984,7 @@ &pm8550_pwm {
 
 	multi-led {
 		color = <LED_COLOR_ID_RGB>;
-		function = LED_FUNCTION_STATUS;
+		function = LED_FUNCTION_DISK_ACTIVITY;
 
 		#address-cells = <1>;
 		#size-cells = <0>;
@@ -1086,7 +1016,8 @@ &pon_pwrkey {
 };
 
 &pon_resin {
-	linux,code = <KEY_VOLUMEDOWN>;
+	/* The text on button is reverted so we also reverted here. */
+	linux,code = <KEY_VOLUMEUP>;
 
 	status = "okay";
 };
@@ -1104,36 +1035,36 @@ pmk8550_sleep_clk: sleep-clk-state {
 
 &qupv3_id_0 {
 	status = "okay";
-	uart5: uart@a94000 {
-		compatible = "qcom,geni-uart";
-		reg = <0 0x00a94000 0 0x4000>;
-		clock-names = "se";
-		clocks = <&gcc GCC_QUPV3_WRAP1_S5_CLK>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&qup_uart5_default>;
-		interrupts = <GIC_SPI 358 IRQ_TYPE_LEVEL_HIGH>;
-		interconnects = <&clk_virt MASTER_QUP_CORE_1 0 &clk_virt SLAVE_QUP_CORE_1 0>,
-						<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_QUP_1 0>;
-		interconnect-names = "qup-core", "qup-config";
-		status = "disabled";
-	};
+	// uart5: uart@a94000 {
+	// 	compatible = "qcom,geni-uart";
+	// 	reg = <0 0x00a94000 0 0x4000>;
+	// 	clock-names = "se";
+	// 	clocks = <&gcc GCC_QUPV3_WRAP1_S5_CLK>;
+	// 	pinctrl-names = "default";
+	// 	pinctrl-0 = <&qup_uart5_default>;
+	// 	interrupts = <GIC_SPI 358 IRQ_TYPE_LEVEL_HIGH>;
+	// 	interconnects = <&clk_virt MASTER_QUP_CORE_1 0 &clk_virt SLAVE_QUP_CORE_1 0>,
+	// 					<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_QUP_1 0>;
+	// 	interconnect-names = "qup-core", "qup-config";
+	// 	status = "disabled";
+	// };
 };
 
 &qupv3_id_1 {
 	status = "okay";
-	uart11: uart@88c000 {
-		compatible = "qcom,geni-uart";
-		reg = <0 0x0088c000 0 0x4000>;
-		clock-names = "se";
-		clocks = <&gcc GCC_QUPV3_WRAP2_S3_CLK>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&qup_uart11_default>;
-		interrupts = <GIC_SPI 585 IRQ_TYPE_LEVEL_HIGH>;
-		interconnects = <&clk_virt MASTER_QUP_CORE_2 0 &clk_virt SLAVE_QUP_CORE_2 0>,
-						<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_QUP_2 0>;
-		interconnect-names = "qup-core", "qup-config";
-		status = "disabled";
-	};
+	// uart11: uart@88c000 {
+	// 	compatible = "qcom,geni-uart";
+	// 	reg = <0 0x0088c000 0 0x4000>;
+	// 	clock-names = "se";
+	// 	clocks = <&gcc GCC_QUPV3_WRAP2_S3_CLK>;
+	// 	pinctrl-names = "default";
+	// 	pinctrl-0 = <&qup_uart11_default>;
+	// 	interrupts = <GIC_SPI 585 IRQ_TYPE_LEVEL_HIGH>;
+	// 	interconnects = <&clk_virt MASTER_QUP_CORE_2 0 &clk_virt SLAVE_QUP_CORE_2 0>,
+	// 					<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_QUP_2 0>;
+	// 	interconnect-names = "qup-core", "qup-config";
+	// 	status = "disabled";
+	// };
 };
 
 &remoteproc_adsp {
@@ -1151,7 +1082,7 @@ &remoteproc_cdsp {
 &remoteproc_mpss {
 	firmware-name = "qcom/sm8550/ayaneo/modem.mdt",
 			"qcom/sm8550/ayaneo/modem_dtb.mdt";
-	status = "okay";
+	status = "disabled";
 };
 
 &sdhc_2 {
@@ -1188,8 +1119,8 @@ north_spkr: speaker@0,0 {
 
 		powerdown-gpios = <&tlmm 7 GPIO_ACTIVE_LOW>;
 
-		vdd-1p8-supply = <&vreg_l15b_1p8>;
-		vdd-io-supply = <&vreg_l15b_1p8>;
+		vdd-1p8-supply = <&vreg_l10b_1p8>;
+		vdd-io-supply = <&vreg_l10b_1p8>;
 
 		#sound-dai-cells = <0>;
 		sound-name-prefix = "SpkrLeft";
@@ -1206,8 +1137,8 @@ south_spkr: speaker@0,1 {
 
 		powerdown-gpios = <&tlmm 12 GPIO_ACTIVE_LOW>;
 
-		vdd-1p8-supply = <&vreg_l15b_1p8>;
-		vdd-io-supply = <&vreg_l15b_1p8>;
+		vdd-1p8-supply = <&vreg_l10b_1p8>;
+		vdd-io-supply = <&vreg_l10b_1p8>;
 
 		#sound-dai-cells = <0>;
 		sound-name-prefix = "SpkrRight";
@@ -1215,43 +1146,6 @@ south_spkr: speaker@0,1 {
 	};
 };
 
-&swr1 {
-	status = "okay";
-
-	/* WCD9385 RX */
-	wcd_rx: codec@0,4 {
-		compatible = "sdw20217010d00";
-		reg = <0 4>;
-
-		/*
-		 * WCD9385 RX Port 1 (HPH_L/R)      <=> SWR1 Port 1 (HPH_L/R)
-		 * WCD9385 RX Port 2 (CLSH)         <=> SWR1 Port 2 (CLSH)
-		 * WCD9385 RX Port 3 (COMP_L/R)     <=> SWR1 Port 3 (COMP_L/R)
-		 * WCD9385 RX Port 4 (LO)           <=> SWR1 Port 4 (LO)
-		 * WCD9385 RX Port 5 (DSD_L/R)      <=> SWR1 Port 5 (DSD_L/R)
-		 */
-		qcom,rx-port-mapping = <1 2 3 4 5>;
-	};
-};
-
-&swr2 {
-	status = "okay";
-
-	/* WCD9385 TX */
-	wcd_tx: codec@0,3 {
-		compatible = "sdw20217010d00";
-		reg = <0 3>;
-
-		/*
-		 * WCD9385 TX Port 1 (ADC1,2)             <=> SWR2 Port 2 (TX SWR_INPUT 0,1,2,3)
-		 * WCD9385 TX Port 2 (ADC3,4)             <=> SWR2 Port 2 (TX SWR_INPUT 0,1,2,3)
-		 * WCD9385 TX Port 3 (DMIC0,1,2,3 & MBHC) <=> SWR2 Port 3 (TX SWR_INPUT 4,5,6,7)
-		 * WCD9385 TX Port 4 (DMIC4,5,6,7)        <=> SWR2 Port 4 (TX SWR_INPUT 8,9,10,11)
-		 */
-		qcom,tx-port-mapping = <2 2 3 4>;
-	};
-};
-
 &tlmm {
 	/* Reserved I/Os for NFC */
 	gpio-reserved-ranges = <32 8>;
@@ -1286,6 +1180,13 @@ wlan_en: wlan-en-state {
 		bias-pull-down;
 	};
 
+	panel_pwr_active: panel-pwr-active-state {
+		pins = "gpio152", "gpio153","gpio42", "gpio72", "gpio41";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+		output-high;
+	};
 	
 	sde_dsi_active: sde-dsi-active-state {
 		pins = "gpio133";
@@ -1319,14 +1220,16 @@ ts_irq: ts-irq-state {
 		pins = "gpio25";
 		function = "gpio";
 		drive-strength = <8>;
-		bias-pull-up;
+		bias-disable;
+		input-enable;
 	};
 
 	ts_reset: ts-reset-state {
 		pins = "gpio24";
 		function = "gpio";
 		drive-strength = <8>;
-		bias-pull-up;
+		input-enable;
+		bias-pull-down;
 	};
 
 	spkr_1_sd_n_active: spkr-1-sd-n-active-state {
@@ -1334,7 +1237,7 @@ spkr_1_sd_n_active: spkr-1-sd-n-active-state {
 		function = "gpio";
 		drive-strength = <16>;
 		bias-disable;
-		output-low;
+		output-high;
 	};
 
 	spkr_2_sd_n_active: spkr-2-sd-n-active-state {
@@ -1342,7 +1245,7 @@ spkr_2_sd_n_active: spkr-2-sd-n-active-state {
 		function = "gpio";
 		drive-strength = <16>;
 		bias-disable;
-		output-low;
+		output-high;
 	};
 
 	qup_uart5_default: qup-uart5-default-state {
@@ -1362,7 +1265,7 @@ qup_uart11_default: qup-uart11-default-state {
 	};
 
 	upd720201_active: upd720201-active {
-		pins = "gpio10", "gpio18", "gpio13";
+		pins = "gpio10",  "gpio13", "gpio18", "gpio52";
 		function = "gpio";
 		drive-strength = <2>;
 		bias-pull-up;
@@ -1384,6 +1287,14 @@ fan0_pwr_sleep: fan0-pwr-sleep-state {
 		bias-disable;
 		output-low;
 	};
+
+	gamepad_key_n: gamepad-key-n-state {
+		pins = "gpio85", "gpio88", "gpio91", "gpio169", "gpio170";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+		input-enable;
+	};
 };
 
 &uart7 {
@@ -1391,7 +1302,7 @@ &uart7 {
 };
 
 &uart14 {
-	status = "okay";
+	status = "disabled";
 
 	bluetooth {
 		compatible = "qcom,wcn7850-bt";
@@ -1453,7 +1364,7 @@ &usb_dp_qmpphy {
 
 &usb_dp_qmpphy_out {
 	remote-endpoint = <&redriver_ss_in>;
-};
+}; 
 
 &xo_board {
 	clock-frequency = <76800000>;
-- 
2.43.0


From fca58da7d0aa70e49c0cb28b4adc90ec8ecbc91e Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sun, 2 Mar 2025 13:25:39 +0000
Subject: [PATCH 23/39] drm/panel: add dsi1 when panel initialize.

---
 drivers/gpu/drm/panel/panel-wt0600-60hz.c | 317 +++++++++++++---------
 1 file changed, 192 insertions(+), 125 deletions(-)

diff --git a/drivers/gpu/drm/panel/panel-wt0600-60hz.c b/drivers/gpu/drm/panel/panel-wt0600-60hz.c
index 1551b7dfa6c8..c87d0eab4451 100644
--- a/drivers/gpu/drm/panel/panel-wt0600-60hz.c
+++ b/drivers/gpu/drm/panel/panel-wt0600-60hz.c
@@ -1,30 +1,51 @@
 // SPDX-License-Identifier: GPL-2.0-only
-// Copyright (c) 2024 Kancy Joe
+// Copyright (c) 2025 FIXME
 // Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
-//   Copyright (c) 2013, The Linux Foundation. All rights reserved.
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
 
+#include <linux/backlight.h>
 #include <linux/delay.h>
 #include <linux/gpio/consumer.h>
+#include <linux/mod_devicetable.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_graph.h>
+#include <video/mipi_display.h>
 
 #include <drm/drm_mipi_dsi.h>
 #include <drm/drm_modes.h>
 #include <drm/drm_panel.h>
 #include <drm/drm_probe_helper.h>
 
-struct wt0600_60hz {
+struct wt0600 {
+    struct device *dev;
 	struct drm_panel panel;
-	struct mipi_dsi_device *dsi;
 	struct gpio_desc *reset_gpio;
+    struct mipi_dsi_device *dsi[2];
+    struct backlight_device *backlight;
+    struct regulator *vddio;
 };
 
-static inline struct wt0600_60hz *to_wt0600_60hz(struct drm_panel *panel)
+static inline struct wt0600 *panel_to_ctx(struct drm_panel *panel)
 {
-	return container_of(panel, struct wt0600_60hz, panel);
+	return container_of(panel, struct wt0600, panel);
 }
 
-static void wt0600_60hz_reset(struct wt0600_60hz *ctx)
+static int wt0600_dcs_write(struct wt0600 *ctx, u32 command)
+{
+    int i, ret;
+
+    for (i = 0; i < ARRAY_SIZE(ctx->dsi); i++) {
+        ret = mipi_dsi_dcs_write(ctx->dsi[i], command, NULL, 0);
+        if (ret < 0) {
+            dev_err(ctx->dev, "cmd 0x%x failed for dsi = %d\n", command, i);
+        }
+    }
+
+    return ret;
+}
+
+static void wt0600_reset(struct wt0600 *ctx)
 {
 	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
 	usleep_range(10000, 11000);
@@ -34,186 +55,232 @@ static void wt0600_60hz_reset(struct wt0600_60hz *ctx)
 	msleep(55);
 }
 
-static int wt0600_60hz_on(struct wt0600_60hz *ctx)
+static int wt0600_on(struct wt0600 *ctx)
 {
-	struct mipi_dsi_device *dsi = ctx->dsi;
-	struct device *dev = &dsi->dev;
-	int ret;
-
-	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
-
-	ret = mipi_dsi_dcs_set_display_on(dsi);
-	if (ret < 0) {
-		dev_err(dev, "Failed to set display on: %d\n", ret);
-		return ret;
-	}
-	msleep(150);
-
-	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
-	if (ret < 0) {
-		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
-		return ret;
-	}
-	msleep(50);
-
+    int ret = 0;
+
+    ctx->dsi[0]->mode_flags |= MIPI_DSI_MODE_LPM;
+    ctx->dsi[1]->mode_flags |= MIPI_DSI_MODE_LPM;
+
+    ret = wt0600_dcs_write(ctx, MIPI_DCS_SET_DISPLAY_ON);
+    if (ret < 0) {
+        dev_err(ctx->dev, "set_display_on cmd failed ret = %d\n", ret);
+        return ret;
+    }
+    msleep(150);
+
+    ret = wt0600_dcs_write(ctx, MIPI_DCS_EXIT_SLEEP_MODE);
+    if (ret < 0) {
+        dev_err(ctx->dev, "set_display_on cmd failed ret = %d\n", ret);
+        return ret;
+    }
+
+    msleep(50);
+    
 	return 0;
 }
 
-static int wt0600_60hz_off(struct wt0600_60hz *ctx)
+static int wt0600_off(struct wt0600 *ctx)
 {
-	struct mipi_dsi_device *dsi = ctx->dsi;
-	struct device *dev = &dsi->dev;
-	int ret;
+    int ret = 0;
 
-	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+	ctx->dsi[0]->mode_flags &= ~MIPI_DSI_MODE_LPM;
+    ctx->dsi[1]->mode_flags &= ~MIPI_DSI_MODE_LPM;
 
-	ret = mipi_dsi_dcs_set_display_off(dsi);
-	if (ret < 0) {
-		dev_err(dev, "Failed to set display off: %d\n", ret);
-		return ret;
-	}
-	msleep(50);
+    ret = wt0600_dcs_write(ctx, MIPI_DCS_SET_DISPLAY_OFF);
+    if (ret < 0) {
+        dev_err(ctx->dev, "set_display_off cmd failed ret = %d\n", ret);
+    }
 
-	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
-	if (ret < 0) {
-		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
-		return ret;
-	}
-	msleep(150);
+    msleep(50);
 
-	return 0;
+    ret =  wt0600_dcs_write(ctx, MIPI_DCS_ENTER_SLEEP_MODE);
+    if (ret < 0) {
+        dev_err(ctx->dev, "enter_sleep cmd failed ret = %d\n", ret);
+    }
+    msleep(150);
+
+	return ret;
 }
 
-static int wt0600_60hz_prepare(struct drm_panel *panel)
+static int wt0600_prepare(struct drm_panel *panel)
 {
-	struct wt0600_60hz *ctx = to_wt0600_60hz(panel);
-	struct device *dev = &ctx->dsi->dev;
+	struct wt0600 *ctx = panel_to_ctx(panel);
 	int ret;
 
-	wt0600_60hz_reset(ctx);
+	// ret = regulator_enable(ctx->vddio);
+	// if (ret) {
+	// 	dev_err(panel->dev, "failed to enable vddio regulator: %d\n", ret);
+	// 	return ret;
+	// }
+
+	wt0600_reset(ctx);
 
-	ret = wt0600_60hz_on(ctx);
+	ret = wt0600_on(ctx);
 	if (ret < 0) {
-		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		dev_err(ctx->dev, "Failed to initialize panel: %d\n", ret);
 		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+        // regulator_bulk_disable(ARRAY_SIZE(wt0600_supplies),
+        //               ctx->supplies);
 		return ret;
 	}
 
 	return 0;
 }
 
-static int wt0600_60hz_unprepare(struct drm_panel *panel)
+static int wt0600_unprepare(struct drm_panel *panel)
 {
-	struct wt0600_60hz *ctx = to_wt0600_60hz(panel);
-	struct device *dev = &ctx->dsi->dev;
+	struct wt0600 *ctx = panel_to_ctx(panel);
 	int ret;
 
-	ret = wt0600_60hz_off(ctx);
+	ret = wt0600_off(ctx);
 	if (ret < 0)
-		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+		dev_err(ctx->dev, "Failed to un-initialize panel: %d\n", ret);
 
 	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-
+    // regulator_bulk_disable(ARRAY_SIZE(wt0600_supplies),
+                    //   ctx->supplies);
 	return 0;
 }
 
-static const struct drm_display_mode wt0600_60hz_mode = {
-	.clock = (720 + 100 + 8 + 40) * (2560 + 8 + 2 + 7) * 60 / 1000,
-	.hdisplay = 720,
-	.hsync_start = 720 + 100,
-	.hsync_end = 720 + 100 + 8,
-	.htotal = 720 + 100 + 8 + 40,
-	.vdisplay = 2560,
-	.vsync_start = 2560 + 8,
-	.vsync_end = 2560 + 8 + 2,
-	.vtotal = 2560 + 8 + 2 + 7,
-	.width_mm = 0,
-	.height_mm = 0,
-	.type = DRM_MODE_TYPE_DRIVER,
+static const struct drm_display_mode wt0600_mode = {
+    .clock = (1440 + 100 + 8 + 40) * (2560 + 8 + 2 + 7) * 60 / 1000,
+    .hdisplay = 1440,
+    .hsync_start = 1440 + 100,
+    .hsync_end = 1440 + 100 + 8,
+    .htotal = 1440 + 100 + 8 + 40,
+    .vdisplay = 2560,
+    .vsync_start = 2560 + 8,
+    .vsync_end = 2560 + 8 + 2,
+    .vtotal = 2560 + 8 + 2 + 7,
+    .width_mm = 74,
+    .height_mm = 131,
+    .type = DRM_MODE_TYPE_DRIVER,
 };
 
-static int wt0600_60hz_get_modes(struct drm_panel *panel,
+static int wt0600_get_modes(struct drm_panel *panel,
 				 struct drm_connector *connector)
 {
-	return drm_connector_helper_get_modes_fixed(connector, &wt0600_60hz_mode);
+	return drm_connector_helper_get_modes_fixed(connector, &wt0600_mode);
 }
 
-static const struct drm_panel_funcs wt0600_60hz_panel_funcs = {
-	.prepare = wt0600_60hz_prepare,
-	.unprepare = wt0600_60hz_unprepare,
-	.get_modes = wt0600_60hz_get_modes,
+static const struct drm_panel_funcs wt0600_panel_funcs = {
+	.prepare = wt0600_prepare,
+	.unprepare = wt0600_unprepare,
+	.get_modes = wt0600_get_modes,
 };
 
-static int wt0600_60hz_probe(struct mipi_dsi_device *dsi)
+static int wt0600_probe(struct mipi_dsi_device *dsi)
 {
 	struct device *dev = &dsi->dev;
-	struct wt0600_60hz *ctx;
-	int ret;
+	struct wt0600 *ctx;
+    struct mipi_dsi_device *dsi1_device;
+    struct device_node *dsi1;
+    struct mipi_dsi_host *dsi1_host;
+
+	int ret,i;
+
+    const struct mipi_dsi_device_info info = {
+        .type = "wt0600panel",
+        .channel = 0,
+        .node = NULL,
+    };
+
+	pr_warn("panel: wt0600 1080p probe in\n");
 
 	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
-
-	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
-	if (IS_ERR(ctx->reset_gpio))
-		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
-				     "Failed to get reset-gpios\n");
-
-	ctx->dsi = dsi;
+    
+    ctx->vddio = devm_regulator_get(dev, "vddio");
+	if (IS_ERR(ctx->vddio))
+		return dev_err_probe(dev, PTR_ERR(ctx->vddio), "failed to get vddio regulator\n");
+
+    ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+    if (IS_ERR(ctx->reset_gpio)) {
+        return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio), "failed to get reset gpio\n");
+    }
+
+    /* Locate second dsi device */
+    dsi1 = of_graph_get_remote_node(dsi->dev.of_node, 1, -1);
+    if (!dsi1) {
+        dev_err(dev, "failed to get remote node for dsi1_device\n");
+        return -ENODEV;
+    }
+
+    dsi1_host = of_find_mipi_dsi_host_by_node(dsi1);
+    of_node_put(dsi1);
+    if (!dsi1_host)
+        return dev_err_probe(dev, -EPROBE_DEFER, "failed to find dsi host\n");
+
+    /* register the second DSI device */
+    ctx->dsi[1] = mipi_dsi_device_register_full(dsi1_host, &info);
+    if (IS_ERR(dsi1_device)) {
+        dev_err(dev, "failed to create dsi device\n");
+        return PTR_ERR(dsi1_device);
+    }
+
+    ctx->dev = dev;
+    ctx->dsi[0] = dsi;
 	mipi_dsi_set_drvdata(dsi, ctx);
 
-	dsi->lanes = 4;
-	dsi->format = MIPI_DSI_FMT_RGB888;
-	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
-			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
-
-	drm_panel_init(&ctx->panel, dev, &wt0600_60hz_panel_funcs,
-		       DRM_MODE_CONNECTOR_DSI);
+    drm_panel_init(&ctx->panel, dev, &wt0600_panel_funcs, DRM_MODE_CONNECTOR_DSI);
+	
 	ctx->panel.prepare_prev_first = true;
 
-	ret = drm_panel_of_backlight(&ctx->panel);
-	if (ret)
-		return dev_err_probe(dev, ret, "Failed to get backlight\n");
-
-	drm_panel_add(&ctx->panel);
-
-	ret = mipi_dsi_attach(dsi);
-	if (ret < 0) {
-		drm_panel_remove(&ctx->panel);
-		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+    ret = drm_panel_of_backlight(&ctx->panel);
+    if (ret) {
+        return dev_err_probe(dev, ret, "Failed to get backlight\n");
 	}
-
-	return 0;
+    
+    drm_panel_add(&ctx->panel);
+
+    for (i = 0; i < ARRAY_SIZE(ctx->dsi); i++) {
+        ctx->dsi[i]->lanes = 4;
+        ctx->dsi[i]->format = MIPI_DSI_FMT_RGB888;
+        ctx->dsi[i]->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+            MIPI_DSI_CLOCK_NON_CONTINUOUS;
+        ret = mipi_dsi_attach(ctx->dsi[i]);
+        if (ret < 0) {
+            return dev_err_probe(dev, ret, "dsi attach failed i = %d\n", i);
+        }
+    }
+
+	pr_warn("panel: wt0600 1080p probe out\n");
+
+    return 0;
 }
 
-static void wt0600_60hz_remove(struct mipi_dsi_device *dsi)
+static void wt0600_remove(struct mipi_dsi_device *dsi)
 {
-	struct wt0600_60hz *ctx = mipi_dsi_get_drvdata(dsi);
-	int ret;
+    struct wt0600 *ctx = mipi_dsi_get_drvdata(dsi);
 
-	ret = mipi_dsi_detach(dsi);
-	if (ret < 0)
-		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+    if (ctx->dsi[0])
+        mipi_dsi_detach(ctx->dsi[0]);
+    if (ctx->dsi[1]) {
+        mipi_dsi_detach(ctx->dsi[1]);
+        mipi_dsi_device_unregister(ctx->dsi[1]);
+    }
 
-	drm_panel_remove(&ctx->panel);
+    drm_panel_remove(&ctx->panel);
 }
 
-static const struct of_device_id wt0600_60hz_of_match[] = {
-	{ .compatible = "ayaneo,wt0600-2k" },
-	{ /* sentinel */ }
+static const struct of_device_id wt0600_of_match[] = {
+	{ .compatible = "ayaneo,wt0600-1080p" },
+	{ }
 };
-MODULE_DEVICE_TABLE(of, wt0600_60hz_of_match);
+MODULE_DEVICE_TABLE(of, wt0600_of_match);
 
-static struct mipi_dsi_driver wt0600_60hz_driver = {
-	.probe = wt0600_60hz_probe,
-	.remove = wt0600_60hz_remove,
+static struct mipi_dsi_driver wt0600_driver = {
+	.probe = wt0600_probe,
+	.remove = wt0600_remove,
 	.driver = {
-		.name = "panel-wt0600-2k60hz",
-		.of_match_table = wt0600_60hz_of_match,
+		.name = "panel-wt0600-60hz-1080p",
+		.of_match_table = wt0600_of_match,
 	},
 };
-module_mipi_dsi_driver(wt0600_60hz_driver);
+module_mipi_dsi_driver(wt0600_driver);
 
-MODULE_AUTHOR("Kancy Joe <sunflower2333@outlook.com>");
-MODULE_DESCRIPTION("DRM driver for wt0600 2k video mode dsi panel");
+MODULE_AUTHOR("Linux Panel Generator");
+MODULE_DESCRIPTION("DRM driver for wt0600 1080p video mode dsi panel");
 MODULE_LICENSE("GPL");
-- 
2.43.0


From d1fe49ca59b2db0c7f77dcc5bb688d09b9bceb66 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sun, 2 Mar 2025 13:32:22 +0000
Subject: [PATCH 24/39] backlight: add sy7758vgs driver.

---
 drivers/video/backlight/Kconfig     |   8 +
 drivers/video/backlight/Makefile    |   1 +
 drivers/video/backlight/sy7758vgs.c | 220 ++++++++++++++++++++++++++++
 3 files changed, 229 insertions(+)
 create mode 100644 drivers/video/backlight/sy7758vgs.c

diff --git a/drivers/video/backlight/Kconfig b/drivers/video/backlight/Kconfig
index 3614a5d29c71..fa86c6956da0 100644
--- a/drivers/video/backlight/Kconfig
+++ b/drivers/video/backlight/Kconfig
@@ -198,6 +198,14 @@ config BACKLIGHT_KTZ8866
 		Say Y to enable the backlight driver for the Kinetic KTZ8866
 		found in Xiaomi Mi Pad 5 series.
 
+config BACKLIGHT_SY7758VGS
+	tristate "Backlight Driver for Silergy SY7758VGS"
+	depends on I2C
+	select REGMAP_I2C
+	help
+		Say Y to enable the backlight driver for the Silergy SY7758VGS
+		backlight controller found in ayaneo pocket s.
+
 config BACKLIGHT_LM3533
 	tristate "Backlight Driver for LM3533"
 	depends on MFD_LM3533
diff --git a/drivers/video/backlight/Makefile b/drivers/video/backlight/Makefile
index 8fc98f760a8a..ec188051f935 100644
--- a/drivers/video/backlight/Makefile
+++ b/drivers/video/backlight/Makefile
@@ -54,6 +54,7 @@ obj-$(CONFIG_BACKLIGHT_PWM)		+= pwm_bl.o
 obj-$(CONFIG_BACKLIGHT_QCOM_WLED)	+= qcom-wled.o
 obj-$(CONFIG_BACKLIGHT_RT4831)		+= rt4831-backlight.o
 obj-$(CONFIG_BACKLIGHT_SAHARA)		+= kb3886_bl.o
+obj-$(CONFIG_BACKLIGHT_SY7758VGS)	+= sy7758vgs.o
 obj-$(CONFIG_BACKLIGHT_SKY81452)	+= sky81452-backlight.o
 obj-$(CONFIG_BACKLIGHT_TPS65217)	+= tps65217_bl.o
 obj-$(CONFIG_BACKLIGHT_WM831X)		+= wm831x_bl.o
diff --git a/drivers/video/backlight/sy7758vgs.c b/drivers/video/backlight/sy7758vgs.c
new file mode 100644
index 000000000000..a3dcf8d57d22
--- /dev/null
+++ b/drivers/video/backlight/sy7758vgs.c
@@ -0,0 +1,220 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Backlight driver for the Silergy sy7758vgs
+ *
+ * Copyright (C) 2025 Kancy Joe <kancy2333@outlook.com>
+ */
+
+#include <linux/backlight.h>
+#include <linux/err.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+
+#define DEFAULT_BRIGHTNESS 1500
+#define MAX_BRIGHTNESS 4080
+#define REG_MAX 0xa9
+
+/* reg */
+#define BL_BRT_L 0x10
+#define BL_BRT_H 0x11
+
+struct sy7758vgs {
+	struct i2c_client *client;
+	struct regmap *regmap;
+	bool led_on;
+};
+
+static void sy7758vgs_init(struct sy7758vgs *sydev);
+
+static const struct regmap_config sy7758vgs_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = REG_MAX,
+};
+
+static int sy7758vgs_write(struct sy7758vgs *sydev, unsigned int reg,
+			 unsigned int val)
+{
+	return regmap_write(sydev->regmap, reg, val);
+}
+
+static int sy7758vgs_read(struct sy7758vgs *sydev, unsigned int reg,
+			 unsigned int *val)
+{
+	return regmap_read(sydev->regmap, reg, val);
+}
+
+static int sy7758vgs_backlight_update_status(struct backlight_device *backlight_dev)
+{
+	struct sy7758vgs *sydev = bl_get_data(backlight_dev);
+	unsigned int brightness = backlight_get_brightness(backlight_dev);
+
+	if (!sydev->led_on && brightness > 0) {
+		// Init
+		sy7758vgs_init(sydev);
+		sydev->led_on = true;
+	} else if (brightness == 0) {
+		sydev->led_on = false;
+	}
+
+	/* Set brightness */
+	sy7758vgs_write(sydev, BL_BRT_L, brightness & 0xf0);
+	sy7758vgs_write(sydev, BL_BRT_H, (brightness >> 8) & 0xf);
+
+	return 0;
+}
+
+static const struct backlight_ops sy7758vgs_backlight_ops = {
+	.options = BL_CORE_SUSPENDRESUME,
+	.update_status = sy7758vgs_backlight_update_status,
+};
+
+static void sy7758vgs_init(struct sy7758vgs *sydev)
+{
+	unsigned int val = 0;
+	sydev->led_on = true;
+
+    sy7758vgs_read(sydev, 0x03, &val);
+    if(val != 0x63)
+		pr_warn("no.1 sy7758vgs init 0x63\n");
+
+	sy7758vgs_read(sydev, 0x01, &val);
+	if(val != 0x01)
+		pr_warn("no.2 sy7758vgs init 0x01\n");
+
+	sy7758vgs_read(sydev, 0xa5, &val);
+	if(val != 0x00)
+		pr_warn("no.3 sy7758vgs init 0x00\n");
+
+	sy7758vgs_write(sydev, 0x01, 0x85);
+	sy7758vgs_write(sydev, 0x10, 0x00);
+	sy7758vgs_write(sydev, 0x11, 0x00);
+	sy7758vgs_write(sydev, 0xa5, 0x64);
+	sy7758vgs_write(sydev, 0xa0, 0x55);
+	sy7758vgs_write(sydev, 0xa1, 0x9a);
+	sy7758vgs_write(sydev, 0xa9, 0x80);
+	sy7758vgs_write(sydev, 0xa2, 0x28);
+
+	sy7758vgs_read(sydev, 0x01, &val);
+	if(val != 0x85)
+		pr_warn("no.4 sy7758vgs init 0x85\n");
+
+	sy7758vgs_read(sydev, 0x10, &val);
+	if(val != 0x00)
+		pr_warn("no.5 sy7758vgs init 0x00\n");
+
+	sy7758vgs_read(sydev, 0x11, &val);
+	if(val != 0x00)
+		pr_warn("no.6 sy7758vgs init 0x00\n");
+
+	sy7758vgs_read(sydev, 0xa5, &val);
+	if(val != 0x64)
+		pr_warn("no.7 sy7758vgs init 0x64\n");
+
+	sy7758vgs_read(sydev, 0xa0, &val);
+	if(val != 0x55)
+		pr_warn("no.8 sy7758vgs init 0x55\n");
+
+	sy7758vgs_read(sydev, 0xa1, &val);
+	if(val != 0x9a)
+		pr_warn("no.9 sy7758vgs init 0x9a\n");
+
+	sy7758vgs_read(sydev, 0xa2, &val);
+	if(val != 0x28)
+		pr_warn("no.10 sy7758vgs init 0x28\n");
+
+	sy7758vgs_read(sydev, 0xa9, &val);
+	if(val != 0x80)
+		pr_warn("no.11 sy7758vgs init 0x80\n");
+
+	sy7758vgs_read(sydev, 0x02, &val);
+	if(val != 0x3c)
+		pr_warn("no.12 sy7758vgs init 0x3c\n");
+
+	sy7758vgs_write(sydev, 0x10, 0x00);
+	sy7758vgs_write(sydev, 0x11, 0x00);
+	sy7758vgs_write(sydev, 0x10, 0x80);
+	sy7758vgs_write(sydev, 0x11, 0x02);
+	// Max brightness
+	// 0x10: 0xf0 Low
+	// 0x11: 0x0f High
+
+	// Min brightness
+	// 0x10: 0x10  Low
+	// 0x11: 0x00  High
+}
+
+static int sy7758vgs_probe(struct i2c_client *client)
+{
+	struct backlight_device *backlight_dev;
+	struct backlight_properties props;
+	struct sy7758vgs *sydev;
+
+	sydev = devm_kzalloc(&client->dev, sizeof(*sydev), GFP_KERNEL);
+	if (!sydev)
+		return -ENOMEM;
+
+	sydev->client = client;
+	sydev->regmap = devm_regmap_init_i2c(client, &sy7758vgs_regmap_config);
+	if (IS_ERR(sydev->regmap))
+		return dev_err_probe(&client->dev, PTR_ERR(sydev->regmap), "failed to init regmap\n");
+
+	memset(&props, 0, sizeof(props));
+	props.type = BACKLIGHT_RAW;
+	props.max_brightness = MAX_BRIGHTNESS;
+	props.brightness = DEFAULT_BRIGHTNESS;
+	props.scale = BACKLIGHT_SCALE_LINEAR;
+
+	backlight_dev = devm_backlight_device_register(&client->dev, "sy7758vgs-backlight",
+					&client->dev, sydev, &sy7758vgs_backlight_ops, &props);
+	if (IS_ERR(backlight_dev))
+		return dev_err_probe(&client->dev, PTR_ERR(backlight_dev),
+				"failed to register backlight device\n");
+
+	sy7758vgs_init(sydev);
+
+	i2c_set_clientdata(client, backlight_dev);
+	backlight_update_status(backlight_dev);
+
+	return 0;
+}
+
+static void sy7758vgs_remove(struct i2c_client *client)
+{
+	struct backlight_device *backlight_dev = i2c_get_clientdata(client);
+	backlight_dev->props.brightness = 0;
+	backlight_update_status(backlight_dev);
+}
+
+static const struct i2c_device_id sy7758vgs_ids[] = {
+	{ "sy7758vgs" },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, sy7758vgs_ids);
+
+static const struct of_device_id sy7758vgs_match_table[] = {
+	{
+		.compatible = "silergy,sy7758vgs",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, sy7758vgs_match_table);
+
+static struct i2c_driver sy7758vgs_driver = {
+	.driver = {
+		.name = "sy7758vgs",
+		.of_match_table = sy7758vgs_match_table,
+	},
+	.probe = sy7758vgs_probe,
+	.remove = sy7758vgs_remove,
+	.id_table = sy7758vgs_ids,
+};
+
+module_i2c_driver(sy7758vgs_driver);
+
+MODULE_DESCRIPTION("Silergy sy7758vgs Backlight Driver");
+MODULE_AUTHOR("Kancy Joe <kancy2333@outlook.com>");
+MODULE_LICENSE("GPL");
-- 
2.43.0


From a0b08bf5187cfa53fc2581f96697e1bdaf01e9f5 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sun, 2 Mar 2025 14:00:29 +0000
Subject: [PATCH 25/39] arm64: config: update q_defconfig to enable vgs7758bl &
 android binder.

---
 arch/arm64/configs/q_defconfig | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/arch/arm64/configs/q_defconfig b/arch/arm64/configs/q_defconfig
index 20b35697fa13..0c97b696163e 100644
--- a/arch/arm64/configs/q_defconfig
+++ b/arch/arm64/configs/q_defconfig
@@ -651,6 +651,7 @@ CONFIG_FB_EFI=y
 CONFIG_FB_MODE_HELPERS=y
 CONFIG_BACKLIGHT_CLASS_DEVICE=m
 CONFIG_BACKLIGHT_KTZ8866=m
+CONFIG_BACKLIGHT_SY7758VGS=m
 CONFIG_BACKLIGHT_PWM=m
 CONFIG_BACKLIGHT_QCOM_WLED=m
 CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
@@ -1103,6 +1104,8 @@ CONFIG_ARM_DMC620_PMU=m
 CONFIG_HISI_PMU=y
 CONFIG_ARM_CORESIGHT_PMU_ARCH_SYSTEM_PMU=m
 CONFIG_NVIDIA_CORESIGHT_PMU_ARCH_SYSTEM_PMU=m
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_BINDERFS=y
 CONFIG_NVMEM_LAYOUT_SL28_VPD=m
 CONFIG_NVMEM_QCOM_QFPROM=y
 CONFIG_NVMEM_QCOM_SEC_QFPROM=m
@@ -1184,7 +1187,6 @@ CONFIG_CRYPTO_SHA3_ARM64=m
 CONFIG_CRYPTO_SM3_ARM64_CE=m
 CONFIG_CRYPTO_AES_ARM64_BS=m
 CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
-CONFIG_CRYPTO_CRCT10DIF_ARM64_CE=m
 CONFIG_CRYPTO_DEV_QCE=m
 CONFIG_CRYPTO_DEV_QCOM_RNG=m
 CONFIG_CRYPTO_DEV_CCREE=m
-- 
2.43.0


From 061f7f101e90972768aac452a1787b10d2961d62 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Fri, 30 May 2025 03:23:12 +0000
Subject: [PATCH 27/39] driver: dma: correct qcom gpi dma ee_offset data for
 sm8250.

---
 arch/arm64/boot/dts/qcom/sm8250.dtsi | 6 +++---
 drivers/dma/qcom/gpi.c               | 3 +++
 2 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/arch/arm64/boot/dts/qcom/sm8250.dtsi b/arch/arm64/boot/dts/qcom/sm8250.dtsi
index aa079c5af5d1..f4899b0f1f5c 100644
--- a/arch/arm64/boot/dts/qcom/sm8250.dtsi
+++ b/arch/arm64/boot/dts/qcom/sm8250.dtsi
@@ -987,7 +987,7 @@ rng: rng@793000 {
 		};
 
 		gpi_dma2: dma-controller@800000 {
-			compatible = "qcom,sm8250-gpi-dma", "qcom,sdm845-gpi-dma";
+			compatible = "qcom,sm8250-gpi-dma-1", "qcom,sdm845-gpi-dma";
 			reg = <0 0x00800000 0 0x70000>;
 			interrupts = <GIC_SPI 588 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 589 IRQ_TYPE_LEVEL_HIGH>,
@@ -1324,7 +1324,7 @@ spi19: spi@894000 {
 		};
 
 		gpi_dma0: dma-controller@900000 {
-			compatible = "qcom,sm8250-gpi-dma", "qcom,sdm845-gpi-dma";
+			compatible = "qcom,sm8250-gpi-dma-0", "qcom,sdm845-gpi-dma";
 			reg = <0 0x00900000 0 0x70000>;
 			interrupts = <GIC_SPI 244 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 245 IRQ_TYPE_LEVEL_HIGH>,
@@ -1754,7 +1754,7 @@ spi7: spi@99c000 {
 		};
 
 		gpi_dma1: dma-controller@a00000 {
-			compatible = "qcom,sm8250-gpi-dma", "qcom,sdm845-gpi-dma";
+			compatible = "qcom,sm8250-gpi-dma-1", "qcom,sdm845-gpi-dma";
 			reg = <0 0x00a00000 0 0x70000>;
 			interrupts = <GIC_SPI 279 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 280 IRQ_TYPE_LEVEL_HIGH>,
diff --git a/drivers/dma/qcom/gpi.c b/drivers/dma/qcom/gpi.c
index b1f0001cc99c..7b634185eee3 100644
--- a/drivers/dma/qcom/gpi.c
+++ b/drivers/dma/qcom/gpi.c
@@ -2307,6 +2307,9 @@ static const struct of_device_id gpi_of_match[] = {
 	{ .compatible = "qcom,sc7280-gpi-dma", .data = (void *)0x10000 },
 	{ .compatible = "qcom,sm8150-gpi-dma", .data = (void *)0x0 },
 	{ .compatible = "qcom,sm8250-gpi-dma", .data = (void *)0x0 },
+	{ .compatible = "qcom,sm8250-gpi-dma-0", .data = (void *)0x1000 },
+	{ .compatible = "qcom,sm8250-gpi-dma-1", .data = (void *)0x6000 },
+	{ .compatible = "qcom,sm8250-gpi-dma-1", .data = (void *)0x6000 },
 	{ .compatible = "qcom,sm8350-gpi-dma", .data = (void *)0x10000 },
 	{ .compatible = "qcom,sm8450-gpi-dma", .data = (void *)0x10000 },
 	{ },
-- 
2.43.0


From 9211d585eefdb726cf5cb1f04a40ef6b7e01dc85 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Fri, 30 May 2025 03:25:40 +0000
Subject: [PATCH 28/39] input: add ftsv521 drivers.

Co-authored-by: BigfootACA <bigfoot@classfun.cn>
Co-authored-by: XiaoYeZi <qaz6750@outlook.com>
---
 drivers/input/touchscreen/Kconfig             |     2 +
 drivers/input/touchscreen/Makefile            |     1 +
 drivers/input/touchscreen/stfts/Kconfig       |    25 +
 drivers/input/touchscreen/stfts/Makefile      |     6 +
 drivers/input/touchscreen/stfts/fts.c         |  6527 ++++++++
 drivers/input/touchscreen/stfts/fts.h         |   393 +
 drivers/input/touchscreen/stfts/fts_fw.h      | 12573 ++++++++++++++++
 .../input/touchscreen/stfts/fts_lib/Makefile  |     7 +
 .../stfts/fts_lib/ftsCompensation.c           |   790 +
 .../stfts/fts_lib/ftsCompensation.h           |   110 +
 .../input/touchscreen/stfts/fts_lib/ftsCore.c |  1365 ++
 .../input/touchscreen/stfts/fts_lib/ftsCore.h |   180 +
 .../touchscreen/stfts/fts_lib/ftsError.c      |   357 +
 .../touchscreen/stfts/fts_lib/ftsError.h      |   145 +
 .../touchscreen/stfts/fts_lib/ftsFlash.c      |  1032 ++
 .../touchscreen/stfts/fts_lib/ftsFlash.h      |   100 +
 .../touchscreen/stfts/fts_lib/ftsFrame.c      |   398 +
 .../touchscreen/stfts/fts_lib/ftsFrame.h      |    91 +
 .../touchscreen/stfts/fts_lib/ftsGesture.c    |   349 +
 .../touchscreen/stfts/fts_lib/ftsGesture.h    |    38 +
 .../touchscreen/stfts/fts_lib/ftsHardware.h   |   191 +
 .../input/touchscreen/stfts/fts_lib/ftsIO.c   |   911 ++
 .../input/touchscreen/stfts/fts_lib/ftsIO.h   |    59 +
 .../touchscreen/stfts/fts_lib/ftsSoftware.h   |   379 +
 .../input/touchscreen/stfts/fts_lib/ftsTest.c |  5938 ++++++++
 .../input/touchscreen/stfts/fts_lib/ftsTest.h |   293 +
 .../input/touchscreen/stfts/fts_lib/ftsTime.c |    79 +
 .../input/touchscreen/stfts/fts_lib/ftsTime.h |    55 +
 .../input/touchscreen/stfts/fts_lib/ftsTool.c |   650 +
 .../input/touchscreen/stfts/fts_lib/ftsTool.h |    56 +
 drivers/input/touchscreen/stfts/fts_limits.h  |  2109 +++
 drivers/input/touchscreen/stfts/fts_proc.c    |  2451 +++
 .../input/touchscreen/stfts/google/Kconfig    |    12 +
 .../input/touchscreen/stfts/google/Makefile   |     3 +
 drivers/input/touchscreen/stfts/google/fts.c  |  7104 +++++++++
 drivers/input/touchscreen/stfts/google/fts.h  |  1015 ++
 .../touchscreen/stfts/google/fts_lib/Makefile |     1 +
 .../stfts/google/fts_lib/ftsCompensation.c    |  1144 ++
 .../stfts/google/fts_lib/ftsCompensation.h    |   188 +
 .../stfts/google/fts_lib/ftsCore.c            |  1224 ++
 .../stfts/google/fts_lib/ftsCore.h            |    88 +
 .../stfts/google/fts_lib/ftsError.c           |   350 +
 .../stfts/google/fts_lib/ftsError.h           |   222 +
 .../stfts/google/fts_lib/ftsFlash.c           |  1181 ++
 .../stfts/google/fts_lib/ftsFlash.h           |   148 +
 .../stfts/google/fts_lib/ftsFrame.c           |   666 +
 .../stfts/google/fts_lib/ftsFrame.h           |   122 +
 .../stfts/google/fts_lib/ftsGesture.c         |   381 +
 .../stfts/google/fts_lib/ftsGesture.h         |    47 +
 .../stfts/google/fts_lib/ftsHardware.h        |   331 +
 .../touchscreen/stfts/google/fts_lib/ftsIO.c  |   847 ++
 .../touchscreen/stfts/google/fts_lib/ftsIO.h  |    78 +
 .../stfts/google/fts_lib/ftsSoftware.h        |   568 +
 .../stfts/google/fts_lib/ftsTest.c            |  7858 ++++++++++
 .../stfts/google/fts_lib/ftsTest.h            |   320 +
 .../stfts/google/fts_lib/ftsTime.c            |    87 +
 .../stfts/google/fts_lib/ftsTime.h            |    74 +
 .../stfts/google/fts_lib/ftsTool.c            |   805 +
 .../stfts/google/fts_lib/ftsTool.h            |    64 +
 .../touchscreen/stfts/google/fts_limits.h     |  2045 +++
 .../input/touchscreen/stfts/google/fts_proc.c |  3773 +++++
 61 files changed, 68406 insertions(+)
 create mode 100644 drivers/input/touchscreen/stfts/Kconfig
 create mode 100644 drivers/input/touchscreen/stfts/Makefile
 create mode 100644 drivers/input/touchscreen/stfts/fts.c
 create mode 100644 drivers/input/touchscreen/stfts/fts.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_fw.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/Makefile
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsCompensation.c
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsCompensation.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsCore.c
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsCore.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsError.c
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsError.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsFlash.c
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsFlash.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsFrame.c
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsFrame.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsGesture.c
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsGesture.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsHardware.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsIO.c
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsIO.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsSoftware.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsTest.c
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsTest.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsTime.c
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsTime.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsTool.c
 create mode 100644 drivers/input/touchscreen/stfts/fts_lib/ftsTool.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_limits.h
 create mode 100644 drivers/input/touchscreen/stfts/fts_proc.c
 create mode 100644 drivers/input/touchscreen/stfts/google/Kconfig
 create mode 100644 drivers/input/touchscreen/stfts/google/Makefile
 create mode 100644 drivers/input/touchscreen/stfts/google/fts.c
 create mode 100644 drivers/input/touchscreen/stfts/google/fts.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/Makefile
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsCompensation.c
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsCompensation.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsCore.c
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsCore.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsError.c
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsError.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsFlash.c
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsFlash.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsFrame.c
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsFrame.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsGesture.c
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsGesture.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsHardware.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsIO.c
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsIO.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsSoftware.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsTest.c
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsTest.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsTime.c
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsTime.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsTool.c
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_lib/ftsTool.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_limits.h
 create mode 100644 drivers/input/touchscreen/stfts/google/fts_proc.c

diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 91a2b584dab1..03844f1f5bb5 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -12,6 +12,8 @@ menuconfig INPUT_TOUCHSCREEN
 
 if INPUT_TOUCHSCREEN
 
+source "drivers/input/touchscreen/stfts/Kconfig"
+
 config TOUCHSCREEN_88PM860X
 	tristate "Marvell 88PM860x touchscreen"
 	depends on MFD_88PM860X
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 97a025c6a377..35b25e6119a3 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -82,6 +82,7 @@ obj-$(CONFIG_TOUCHSCREEN_SILEAD)	+= silead.o
 obj-$(CONFIG_TOUCHSCREEN_SIS_I2C)	+= sis_i2c.o
 obj-$(CONFIG_TOUCHSCREEN_ST1232)	+= st1232.o
 obj-$(CONFIG_TOUCHSCREEN_STMFTS)	+= stmfts.o
+obj-$(CONFIG_TOUCHSCREEN_ST_FTS)	+= stfts/
 obj-$(CONFIG_TOUCHSCREEN_STMPE)		+= stmpe-ts.o
 obj-$(CONFIG_TOUCHSCREEN_SUN4I)		+= sun4i-ts.o
 obj-$(CONFIG_TOUCHSCREEN_SUR40)		+= sur40.o
diff --git a/drivers/input/touchscreen/stfts/Kconfig b/drivers/input/touchscreen/stfts/Kconfig
new file mode 100644
index 000000000000..3a525eb9e9a1
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/Kconfig
@@ -0,0 +1,25 @@
+config TOUCHSCREEN_ST_FTS
+	tristate "ST FTS V521 I2C Touchscreen"
+	depends on I2C
+	help
+	  Say Y here if you have ST FTS series I2C touchscreen.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+
+config FTS_FOD_AREA_REPORT
+	tristate "FTS FOD area report"
+	depends on TOUCHSCREEN_ST_FTS
+	help
+          Say Y here to enable  fod area report functionality.
+
+          If unsure, say N.
+
+config TOUCHSCREEN_ST_DEBUG_FS
+	tristate "St core driver module"
+	depends on TOUCHSCREEN_ST_FTS
+	help
+          Say Y here to enable  touch debugfs functionality.
+
+          If unsure, say N.
diff --git a/drivers/input/touchscreen/stfts/Makefile b/drivers/input/touchscreen/stfts/Makefile
new file mode 100644
index 000000000000..84470d86c762
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the touchscreen drivers.
+#
+
+obj-$(CONFIG_TOUCHSCREEN_ST_FTS)		+= fts.o fts_proc.o fts_lib/
+
diff --git a/drivers/input/touchscreen/stfts/fts.c b/drivers/input/touchscreen/stfts/fts.c
new file mode 100644
index 000000000000..d4f13b3a8923
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts.c
@@ -0,0 +1,6527 @@
+/*
+ * fts.c
+ *
+ * FTS Capacitive touch screen controller (FingerTipS)
+ *
+ * Copyright (C) 2016, STMicroelectronics Limited.
+ * Authors: AMG(Analog Mems Group)
+ *
+ * 		marco.cali@st.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ * THIS SOFTWARE IS SPECIFICALLY DESIGNED FOR EXCLUSIVE USE WITH ST PARTS.
+ */
+
+/*!
+* \file fts.c
+* \brief It is the main file which contains all the most important functions generally used by a device driver the driver
+*/
+#include <linux/device.h>
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/interrupt.h>
+#include <linux/hrtimer.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/spi/spi.h>
+#include <linux/completion.h>
+#ifdef CONFIG_SECURE_TOUCH
+#include <linux/atomic.h>
+#include <linux/sysfs.h>
+#include <linux/hardirq.h>
+#endif
+
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+
+#include <linux/notifier.h>
+/*
+#ifdef CONFIG_DRM
+#include <linux/msm_drm_notify.h>
+#endif
+*/
+#include <linux/fb.h>
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+#include <linux/debugfs.h>
+
+#ifdef KERNEL_ABOVE_2_6_38
+#include <linux/input/mt.h>
+#endif
+#include <linux/pinctrl/consumer.h>
+
+#include "fts.h"
+#include "fts_lib/ftsCompensation.h"
+#include "fts_lib/ftsCore.h"
+#include "fts_lib/ftsIO.h"
+#include "fts_lib/ftsError.h"
+#include "fts_lib/ftsFlash.h"
+#include "fts_lib/ftsFrame.h"
+#include "fts_lib/ftsGesture.h"
+#include "fts_lib/ftsTest.h"
+#include "fts_lib/ftsTime.h"
+#include "fts_lib/ftsTool.h"
+
+#define PROC_SYMLINK_PATH "touchpanel"
+
+/**
+ * Event handler installer helpers
+ */
+#define event_id(_e)     (EVT_ID_##_e>>4)
+#define handler_name(_h) fts_##_h##_event_handler
+
+#define install_handler(_i, _evt, _hnd) \
+do { \
+	_i->event_dispatch_table[event_id(_evt)] = handler_name(_hnd); \
+} while (0)
+
+#ifdef KERNEL_ABOVE_2_6_38
+#define TYPE_B_PROTOCOL
+#endif
+
+#define INPUT_EVENT_START			0
+#define INPUT_EVENT_SENSITIVE_MODE_OFF		0
+#define INPUT_EVENT_SENSITIVE_MODE_ON		1
+#define INPUT_EVENT_STYLUS_MODE_OFF		2
+#define INPUT_EVENT_STYLUS_MODE_ON		3
+#define INPUT_EVENT_WAKUP_MODE_OFF		4
+#define INPUT_EVENT_WAKUP_MODE_ON		5
+#define INPUT_EVENT_COVER_MODE_OFF		6
+#define INPUT_EVENT_COVER_MODE_ON		7
+#define INPUT_EVENT_SLIDE_FOR_VOLUME		8
+#define INPUT_EVENT_DOUBLE_TAP_FOR_VOLUME		9
+#define INPUT_EVENT_SINGLE_TAP_FOR_VOLUME		10
+#define INPUT_EVENT_LONG_SINGLE_TAP_FOR_VOLUME		11
+#define INPUT_EVENT_PALM_OFF		12
+#define INPUT_EVENT_PALM_ON		13
+#define INPUT_EVENT_END				13
+
+extern SysInfo systemInfo;
+extern TestToDo tests;
+#ifdef GESTURE_MODE
+extern struct mutex gestureMask_mutex;
+#endif
+
+char tag[8] = "[ FTS ]\0";
+/* buffer which store the input device name assigned by the kernel  */
+char fts_ts_phys[64];
+/* buffer used to store the command sent from the MP device file node  */
+static u32 typeOfComand[CMD_STR_LEN] = { 0 };
+
+/* number of parameter passed through the MP device file node  */
+static int numberParameters;
+#ifdef USE_ONE_FILE_NODE
+static int feature_feasibility = ERROR_OP_NOT_ALLOW;
+#endif
+#ifdef GESTURE_MODE
+static u8 mask[GESTURE_MASK_SIZE + 2];
+extern u16 gesture_coordinates_x[GESTURE_MAX_COORDS_PAIRS_REPORT];
+extern u16 gesture_coordinates_y[GESTURE_MAX_COORDS_PAIRS_REPORT];
+extern int gesture_coords_reported;
+extern struct mutex gestureMask_mutex;
+#endif
+/* store the last update of the key mask published by the IC */
+#ifdef PHONE_KEY
+static u8 key_mask;
+#endif
+
+extern spinlock_t fts_int;
+struct fts_ts_info *fts_info;
+
+static int fts_init_sensing(struct fts_ts_info *info);
+static int fts_mode_handler(struct fts_ts_info *info, int force);
+static int fts_chip_initialization(struct fts_ts_info *info, int init_type);
+static const char *fts_get_limit(struct fts_ts_info *info);
+static irqreturn_t fts_event_handler(int irq, void *ts_info);
+
+/**
+* Release all the touches in the linux input subsystem
+* @param info pointer to fts_ts_info which contains info about the device and its hw setup
+*/
+static void release_all_touches(struct fts_ts_info *info)
+{
+	unsigned int type = MT_TOOL_FINGER;
+	int i;
+
+	for (i = 0; i < TOUCH_ID_MAX; i++) {
+#ifdef STYLUS_MODE
+		if (test_bit(i, &info->stylus_id))
+			type = MT_TOOL_PEN;
+		else
+			type = MT_TOOL_FINGER;
+#endif
+		info->coor[i][0] = -1;
+		info->coor[i][1] = -1;
+		input_mt_slot(info->input_dev, i);
+		input_mt_report_slot_state(info->input_dev, type, 0);
+		input_report_abs(info->input_dev, ABS_MT_TRACKING_ID, -1);
+	}
+	input_sync(info->input_dev);
+	info->touch_id = 0;
+	info->touch_skip = 0;
+	info->fod_id = 0;
+#ifdef STYLUS_MODE
+	info->stylus_id = 0;
+#endif
+}
+
+/**
+ * @defgroup file_nodes Driver File Nodes
+ * Driver publish a series of file nodes used to provide several utilities to the host and give him access to different API.
+ * @{
+ */
+
+/**
+ * @defgroup device_file_nodes Device File Nodes
+ * @ingroup file_nodes
+ * Device File Nodes \n
+ * There are several file nodes that are associated to the device and which are designed to be used by the host to enable/disable features or trigger some system specific actions \n
+ * Usually their final path depend on the definition of device tree node of the IC (e.g /sys/devices/soc.0/f9928000.i2c/i2c-6/6-0049)
+ * @{
+ */
+/***************************************** FW UPGGRADE ***************************************************/
+
+/**
+ * File node function to Update firmware from shell \n
+ * echo path_to_fw X Y > fwupdate   perform a fw update \n
+ * where: \n
+ * path_to_fw = file name or path of the the FW to burn, if "NULL" the default approach selected in the driver will be used\n
+ * X = 0/1 to force the FW update whichever fw_version and config_id; 0=perform a fw update only if the fw in the file is newer than the fw in the chip \n
+ * Y = 0/1 keep the initialization data; 0 = will erase the initialization data from flash, 1 = will keep the initialization data
+ * the string returned in the shell is made up as follow: \n
+ * { = start byte \n
+ * X1X2X3X4 = 4 bytes in HEX format which represent an error code (00000000 no error) \n
+ * } = end byte
+ */
+static ssize_t fts_fwupdate_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	int ret, mode[2];
+	char path[100];
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	/* by default(if not specified by the user) set the force = 0 and keep_cx to 1 */
+	mode[0] = 0;
+	mode[1] = 1;
+
+	/* reading out firmware upgrade parameters */
+	sscanf(buf, "%100s %d %d", path, &mode[0], &mode[1]);
+	logError(1, "%s fts_fwupdate_store: mode = %s \n", tag, path);
+
+	ret = flashProcedure(path, mode[0], mode[1]);
+
+	info->fwupdate_stat = ret;
+
+	if (ret < OK)
+		logError(1, "%s  %s Unable to upgrade firmware! ERROR %08X\n",
+			 tag, __func__, ret);
+	return count;
+}
+
+static ssize_t fts_fwupdate_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	/*fwupdate_stat: ERROR code Returned by flashProcedure. */
+	return snprintf(buf, PAGE_SIZE, "{ %08X }\n", info->fwupdate_stat);
+}
+
+/***************************************** UTILITIES (current fw_ver/conf_id, active mode, file fw_ver/conf_id)  ***************************************************/
+/**
+* File node to show on terminal external release version in Little Endian (first the less significant byte) \n
+* cat appid			show on the terminal external release version of the FW running in the IC
+*/
+static ssize_t fts_appid_show(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	int error;
+	char temp[100] = { 0x00, };
+
+	error = snprintf(buf, PAGE_SIZE, "%s\n",
+			 printHex("EXT Release = ", systemInfo.u8_releaseInfo,
+				  EXTERNAL_RELEASE_INFO_SIZE, temp));
+
+	return error;
+}
+
+/**
+ * File node to show on terminal the mode that is active on the IC \n
+ * cat mode_active		    to show the bitmask which indicate the modes/features which are running on the IC in a specific instant of time
+ * the string returned in the shell is made up as follow: \n
+ * { = start byte \n
+ * X1 = 1 byte in HEX format which represent the actual running scan mode (@link scan_opt Scan Mode Options @endlink) \n
+ * X2 = 1 byte in HEX format which represent the bitmask on which is running the actual scan mode \n
+ * X3X4 = 2 bytes in HEX format which represent a bitmask of the features that are enabled at this moment (@link feat_opt Feature Selection Options @endlink) \n
+ * } = end byte
+ * @see fts_mode_handler()
+ */
+static ssize_t fts_mode_active_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	logError(1, "%s Current mode active = %08X\n", tag, info->mode);
+	return snprintf(buf, PAGE_SIZE, "{ %08X }\n", info->mode);
+}
+
+/**
+ * File node to show the fw_ver and config_id of the FW file
+ * cat fw_file_test			show on the kernel log fw_version and config_id of the FW stored in the fw file/header file
+ */
+static ssize_t fts_fw_test_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	Firmware fw;
+	int ret;
+	char temp[100] = { 0x00, };
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	fw.data = NULL;
+	ret = readFwFile(info->board->default_fw_name, &fw, 0);
+
+	if (ret < OK) {
+		logError(1, "%s Error during reading FW file! ERROR %08X\n",
+			 tag, ret);
+	} else {
+		logError(1, "%s %s, size = %d bytes\n", tag,
+			 printHex("EXT Release = ", systemInfo.u8_releaseInfo,
+				  EXTERNAL_RELEASE_INFO_SIZE, temp),
+			 fw.data_size);
+	}
+
+	kfree(fw.data);
+	return 0;
+}
+
+/***************************************** FEATURES ***************************************************/
+
+/*TODO: edit this function according to the features policy to allow during the screen on/off, following is shown an example but check always with ST for more details*/
+/**
+ * Check if there is any conflict in enable/disable a particular feature considering the features already enabled and running
+ * @param info pointer to fts_ts_info which contains info about the device and its hw setup
+ * @param feature code of the feature that want to be tested
+ * @return OK if is possible to enable/disable feature, ERROR_OP_NOT_ALLOW in case of any other conflict
+ */
+static int check_feature_feasibility(struct fts_ts_info *info, unsigned int feature)
+{
+	int res = OK;
+
+	switch (feature) {
+	case FEAT_SEL_GESTURE:
+		if (info->cover_enabled == 1) {
+			res = ERROR_OP_NOT_ALLOW;
+			logError(1,
+				 "%s %s: Feature not allowed when in Cover mode! ERROR %08X \n",
+				 tag, __func__, res);
+			/*for example here can be placed a code for disabling the cover mode when gesture is activated */
+		}
+		break;
+
+	case FEAT_SEL_GLOVE:
+		if (info->gesture_enabled == 1) {
+			res = ERROR_OP_NOT_ALLOW;
+			logError(1,
+				 "%s %s: Feature not allowed when Gestures enabled! ERROR %08X \n",
+				 tag, __func__, res);
+			/*for example here can be placed a code for disabling the gesture mode when cover is activated (that means that cover mode has an higher priority on gesture mode) */
+		}
+		break;
+
+	default:
+		logError(1, "%s %s: Feature Allowed! \n", tag, __func__);
+
+	}
+
+	return res;
+
+}
+
+#ifdef USE_ONE_FILE_NODE
+/**
+ * File node to enable some feature
+ * echo XX 00/01 > feature_enable		to enable/disable XX (possible values @link feat_opt Feature Selection Options @endlink) feature \n
+ * cat feature_enable					to show the result of enabling/disabling process \n
+ * echo 01/00 > feature_enable; cat feature_enable 		to perform both actions stated before in just one call \n
+ * the string returned in the shell is made up as follow: \n
+ * { = start byte \n
+ * X1X2X3X4 = 4 bytes in HEX format which represent an error code (00000000 = no error) \n
+ * } = end byte
+ */
+static ssize_t fts_feature_enable_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	char *p = (char *)buf;
+	unsigned int temp;
+	int res = OK;
+
+	if ((count - 2 + 1) / 3 != 1) {
+		logError(1,
+			 "%s fts_feature_enable: Number of parameter wrong! %d > %d \n",
+			 tag, (count - 2 + 1) / 3, 1);
+	} else {
+		sscanf(p, "%02X ", &temp);
+		p += 9;
+		res = check_feature_feasibility(info, temp);
+		if (res >= OK) {
+			switch (temp) {
+
+#ifdef GESTURE_MODE
+			case FEAT_SEL_GESTURE:
+				sscanf(p, "%02X ", &info->gesture_enabled);
+				logError(1,
+					 "%s fts_feature_enable: Gesture Enabled = %d \n",
+					 tag, info->gesture_enabled);
+				break;
+#endif
+
+#ifdef GLOVE_MODE
+			case FEAT_SEL_GLOVE:
+				sscanf(p, "%02X ", &info->glove_enabled);
+				logError(1,
+					 "%s fts_feature_enable: Glove Enabled = %d \n",
+					 tag, info->glove_enabled);
+
+				break;
+#endif
+
+#ifdef STYLUS_MODE
+			case FEAT_SEL_STYLUS:
+				sscanf(p, "%02X ", &info->stylus_enabled);
+				logError(1,
+					 "%s fts_feature_enable: Stylus Enabled = %d \n",
+					 tag, info->stylus_enabled);
+
+				break;
+#endif
+
+#ifdef COVER_MODE
+			case FEAT_SEL_COVER:
+				sscanf(p, "%02X ", &info->cover_enabled);
+				logError(1,
+					 "%s fts_feature_enable: Cover Enabled = %d \n",
+					 tag, info->cover_enabled);
+
+				break;
+#endif
+
+#ifdef CHARGER_MODE
+			case FEAT_SEL_CHARGER:
+				sscanf(p, "%02X ", &info->charger_enabled);
+				logError(1,
+					 "%s fts_feature_enable: Charger Enabled = %d \n",
+					 tag, info->charger_enabled);
+
+				break;
+#endif
+
+#ifdef GRIP_MODE
+			case FEAT_SEL_GRIP:
+				sscanf(p, "%02X ", &info->grip_enabled);
+				logError(1,
+					 "%s fts_feature_enable: Grip Enabled = %d \n",
+					 tag, info->grip_enabled);
+
+				break;
+#endif
+			default:
+				logError(1,
+					 "%s fts_feature_enable: Feature %08X not valid! ERROR %08X\n",
+					 tag, temp, ERROR_OP_NOT_ALLOW);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			feature_feasibility = res;
+		}
+		if (feature_feasibility >= OK)
+			feature_feasibility = fts_mode_handler(info, 1);
+		else {
+			logError(1,
+				 "%s %s: Call echo XX 00/01 > feature_enable with a correct feature value (XX)! ERROR %08X \n",
+				 tag, __func__, res);
+		}
+
+	}
+	return count;
+}
+
+static ssize_t fts_feature_enable_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	int size = (6 * 2) + 1, index = 0;
+	u8 *all_strbuff = NULL;
+	int count = 0;
+
+	if (feature_feasibility < OK) {
+		logError(1,
+			 "%s %s: Call before echo XX 00/01 > feature_enable with a correct feature value (XX)! ERROR %08X \n",
+			 tag, __func__, feature_feasibility);
+	}
+
+	all_strbuff = (u8 *) kzalloc(size, GFP_KERNEL);
+	if (all_strbuff != NULL) {
+		index +=
+		    snprintf(&all_strbuff[index], 13, "{ %08X }",
+			     feature_feasibility);
+		count = snprintf(buf, TSP_BUF_SIZE, "%s\n", all_strbuff);
+		kfree(all_strbuff);
+	} else {
+		logError(1,
+			 "%s fts_feature_enable_show: Unable to allocate all_strbuff! ERROR %08X\n",
+			 tag, ERROR_ALLOC);
+	}
+
+	feature_feasibility = ERROR_OP_NOT_ALLOW;
+	return count;
+}
+#else
+
+#ifdef GRIP_MODE
+/**
+ * File node to set the grip mode
+ * echo 01/00 > grip_mode		to enable/disable glove mode \n
+ * cat grip_mode				to show the status of the grip_enabled switch \n
+ * echo 01/00 > grip_mode; cat grip_mode 		to enable/disable grip mode and see the switch status in just one call \n
+ * the string returned in the shell is made up as follow: \n
+ * { = start byte \n
+ * X1X2X3X4 = 4 bytes in HEX format which represent the value info->grip_enabled (1 = enabled; 0= disabled) \n
+ * } = end byte
+ */
+static ssize_t fts_grip_mode_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+
+	int size = (6 * 2) + 1, index = 0;
+	u8 *all_strbuff = NULL;
+	int count = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	logError(0, "%s %s: grip_enabled = %d \n", tag, __func__,
+		 info->grip_enabled);
+
+	all_strbuff = (u8 *) kzalloc(size, GFP_KERNEL);
+	if (all_strbuff != NULL) {
+
+		index +=
+		    snprintf(&all_strbuff[index], 13, "{ %08X }",
+			     info->grip_enabled);
+
+		count = snprintf(buf, TSP_BUF_SIZE, "%s\n", all_strbuff);
+		kfree(all_strbuff);
+	} else {
+		logError(1,
+			 "%s %s: Unable to allocate all_strbuff! ERROR %08X\n",
+			 tag, __func__, ERROR_ALLOC);
+	}
+
+	return count;
+}
+
+static ssize_t fts_grip_mode_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	char *p = (char *)buf;
+	unsigned int temp;
+	int res;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+/*in case of a different elaboration of the input, just modify this initial part of the code according to customer needs*/
+	if ((count + 1) / 3 != 1) {
+		logError(1,
+			 "%s %s: Number of bytes of parameter wrong! %d != %d byte\n",
+			 tag, __func__, (count + 1) / 3, 1);
+	} else {
+		sscanf(p, "%02X ", &temp);
+		p += 3;
+/*
+*this is a standard code that should be always used when a feature is enabled!
+*first step : check if the wanted feature can be enabled
+*second step: call fts_mode_handler to actually enable it
+*NOTE: Disabling a feature is always allowed by default
+*/
+		res = check_feature_feasibility(info, FEAT_SEL_GRIP);
+		if (res >= OK || temp == FEAT_DISABLE) {
+			info->grip_enabled = temp;
+			res = fts_mode_handler(info, 1);
+			if (res < OK) {
+				logError(1,
+					 "%s %s: Error during fts_mode_handler! ERROR %08X\n",
+					 tag, __func__, res);
+			}
+		}
+	}
+	return count;
+}
+#endif
+
+#ifdef CHARGER_MODE
+/**
+ * File node to set the glove mode
+ * echo XX/00 > charger_mode		to value >0 to enable (possible values: @link charger_opt Charger Options @endlink),00 to disable charger mode \n
+ * cat charger_mode				to show the status of the charger_enabled switch \n
+ * echo 01/00 > charger_mode; cat charger_mode 		to enable/disable charger mode and see the switch status in just one call \n
+ * the string returned in the shell is made up as follow: \n
+ * { = start byte \n
+ * X1X2X3X4 = 4 bytes in HEX format which represent the value info->charger_enabled (>0 = enabled; 0= disabled) \n
+ * } = end byte
+ */
+static ssize_t fts_charger_mode_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	int size = (6 * 2) + 1, index = 0;
+	u8 *all_strbuff = NULL;
+	int count = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	logError(0, "%s %s: charger_enabled = %d \n", tag, __func__,
+		 info->charger_enabled);
+
+	all_strbuff = (u8 *) kzalloc(size, GFP_KERNEL);
+	if (all_strbuff != NULL) {
+		index +=
+		    snprintf(&all_strbuff[index], 13, "{ %08X }",
+			     info->charger_enabled);
+		count = snprintf(buf, TSP_BUF_SIZE, "%s\n", all_strbuff);
+		kfree(all_strbuff);
+	} else {
+		logError(1,
+			 "%s %s: Unable to allocate all_strbuff! ERROR %08X\n",
+			 tag, __func__, ERROR_ALLOC);
+	}
+
+	return count;
+}
+
+static ssize_t fts_charger_mode_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	char *p = (char *)buf;
+	unsigned int temp;
+	int res;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+/*in case of a different elaboration of the input, just modify this initial part of the code according to customer needs*/
+	if ((count + 1) / 3 != 1) {
+		logError(1,
+			 "%s %s: Number of bytes of parameter wrong! %d != %d byte\n",
+			 tag, __func__, (count + 1) / 3, 1);
+	} else {
+		sscanf(p, "%02X ", &temp);
+		p += 3;
+/*
+*this is a standard code that should be always used when a feature is enabled!
+*first step : check if the wanted feature can be enabled
+*second step: call fts_mode_handler to actually enable it
+*NOTE: Disabling a feature is always allowed by default
+*/
+		res = check_feature_feasibility(info, FEAT_SEL_CHARGER);
+		if (res >= OK || temp == FEAT_DISABLE) {
+			info->charger_enabled = temp;
+			res = fts_mode_handler(info, 1);
+			if (res < OK) {
+				logError(1,
+					 "%s %s: Error during fts_mode_handler! ERROR %08X\n",
+					 tag, __func__, res);
+			}
+		}
+	}
+	return count;
+}
+#endif
+
+#ifdef GLOVE_MODE
+/**
+ * File node to set the glove mode
+ * echo 01/00 > glove_mode		to enable/disable glove mode \n
+ * cat glove_mode				to show the status of the glove_enabled switch \n
+ * echo 01/00 > glove_mode; cat glove_mode 		to enable/disable glove mode and see the switch status in just one call \n
+ * the string returned in the shell is made up as follow: \n
+ * { = start byte \n
+ * X1X2X3X4 = 4 bytes in HEX format which represent the of value info->glove_enabled (1 = enabled; 0= disabled) \n
+ * } = end byte
+ */
+static ssize_t fts_glove_mode_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	int size = (6 * 2) + 1, index = 0;
+	u8 *all_strbuff = NULL;
+	int count = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	logError(0, "%s %s: glove_enabled = %d \n", tag, __func__,
+		 info->glove_enabled);
+
+	all_strbuff = (u8 *) kzalloc(size, GFP_KERNEL);
+	if (all_strbuff != NULL) {
+
+		index +=
+		    snprintf(&all_strbuff[index], 13, "{ %08X }",
+			     info->glove_enabled);
+		count = snprintf(buf, TSP_BUF_SIZE, "%s\n", all_strbuff);
+		kfree(all_strbuff);
+	} else {
+		logError(1,
+			 "%s %s: Unable to allocate all_strbuff! ERROR %08X\n",
+			 tag, __func__, ERROR_ALLOC);
+	}
+
+	return count;
+}
+
+static ssize_t fts_glove_mode_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	char *p = (char *)buf;
+	unsigned int temp;
+	int res;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+/*in case of a different elaboration of the input, just modify this initial part of the code according to customer needs*/
+	if ((count + 1) / 3 != 1) {
+		logError(1,
+			 "%s %s: Number of bytes of parameter wrong! %d != %d byte\n",
+			 tag, __func__, (count + 1) / 3, 1);
+	} else {
+		sscanf(p, "%02X ", &temp);
+		p += 3;
+/*
+*this is a standard code that should be always used when a feature is enabled!
+*first step : check if the wanted feature can be enabled
+*second step: call fts_mode_handler to actually enable it
+*NOTE: Disabling a feature is always allowed by default
+*/
+		res = check_feature_feasibility(info, FEAT_SEL_GLOVE);
+		if (res >= OK || temp == FEAT_DISABLE) {
+			info->glove_enabled = temp;
+			res = fts_mode_handler(info, 1);
+			if (res < OK) {
+				logError(1,
+					 "%s %s: Error during fts_mode_handler! ERROR %08X\n",
+					 tag, __func__, res);
+			}
+		}
+	}
+
+	return count;
+}
+#endif
+
+#ifdef COVER_MODE
+/**
+ * File node to set the cover mode
+ * echo 01/00 > cover_mode		to enable/disable cover mode \n
+ * cat cover_mode				to show the status of the cover_enabled switch \n
+ * echo 01/00 > cover_mode; cat cover_mode 		to enable/disable cover mode and see the switch status in just one call \n
+ * the string returned in the shell is made up as follow: \n
+ * { = start byte \n
+ * X1X2X3X4 = 4 bytes in HEX format which is the value of info->cover_enabled (1 = enabled; 0= disabled)\n
+ * } = end byte\n
+ * NOTE: \n
+ * the cover can be handled also using a notifier, in this case the body of these functions should be copied in the notifier callback
+ */
+static ssize_t fts_cover_mode_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	int size = (6 * 2) + 1, index = 0;
+	u8 *all_strbuff = NULL;
+	int count = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	logError(0, "%s %s: cover_enabled = %d \n", tag, __func__,
+		 info->cover_enabled);
+
+	all_strbuff = (u8 *) kzalloc(size, GFP_KERNEL);
+	if (all_strbuff != NULL) {
+
+		index +=
+		    snprintf(&all_strbuff[index], 13, "{ %08X }",
+			     info->cover_enabled);
+		count = snprintf(buf, TSP_BUF_SIZE, "%s\n", all_strbuff);
+		kfree(all_strbuff);
+	} else {
+		logError(1,
+			 "%s %s: Unable to allocate all_strbuff! ERROR %08X\n",
+			 tag, __func__, ERROR_ALLOC);
+	}
+
+	return count;
+}
+
+static ssize_t fts_cover_mode_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	char *p = (char *)buf;
+	unsigned int temp;
+	int res;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+/*in case of a different elaboration of the input, just modify this initial part of the code according to customer needs*/
+	if ((count + 1) / 3 != 1) {
+		logError(1,
+			 "%s %s: Number of bytes of parameter wrong! %d != %d byte\n",
+			 tag, __func__, (count + 1) / 3, 1);
+	} else {
+		sscanf(p, "%02X ", &temp);
+		p += 3;
+/*
+*this is a standard code that should be always used when a feature is enabled!
+*first step : check if the wanted feature can be enabled
+*second step: call fts_mode_handler to actually enable it
+*NOTE: Disabling a feature is always allowed by default
+*/
+		res = check_feature_feasibility(info, FEAT_SEL_COVER);
+		if (res >= OK || temp == FEAT_DISABLE) {
+			info->cover_enabled = temp;
+			res = fts_mode_handler(info, 1);
+			if (res < OK) {
+				logError(1,
+					 "%s %s: Error during fts_mode_handler! ERROR %08X\n",
+					 tag, __func__, res);
+			}
+		}
+	}
+
+	return count;
+}
+#endif
+
+#ifdef STYLUS_MODE
+/**
+ * File node to enable the stylus report
+ * echo 01/00 > stylus_mode		to enable/disable stylus mode\n
+ * cat stylus_mode				to show the status of the stylus_enabled switch\n
+ * echo 01/00 > stylus_mode; cat stylus_mode 		to enable/disable stylus mode and see the switch status in just one call\n
+ * the string returned in the shell is made up as follow:\n
+ * { = start byte \n
+ * X1X2X3X4 = 4 bytes in HEX format which is the value of info->stylus_enabled (1 = enabled; 0= disabled)\n
+ * } = end byte
+ */
+static ssize_t fts_stylus_mode_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	int size = (6 * 2) + 1, index = 0;
+	u8 *all_strbuff = NULL;
+	int count = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	logError(0, "%s %s: stylus_enabled = %d \n", tag, __func__,
+		 info->stylus_enabled);
+
+	all_strbuff = (u8 *) kzalloc(size, GFP_KERNEL);
+	if (all_strbuff != NULL) {
+
+		index +=
+		    snprintf(&all_strbuff[index], 13, "{ %08X }",
+			     info->stylus_enabled);
+
+		count = snprintf(buf, TSP_BUF_SIZE, "%s\n", all_strbuff);
+		kfree(all_strbuff);
+	} else {
+		logError(1,
+			 "%s %s: Unable to allocate all_strbuff! ERROR %08X\n",
+			 tag, __func__, ERROR_ALLOC);
+	}
+
+	return count;
+}
+
+static ssize_t fts_stylus_mode_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	char *p = (char *)buf;
+	unsigned int temp;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+/*in case of a different elaboration of the input, just modify this initial part of the code according to customer needs*/
+	if ((count + 1) / 3 != 1) {
+		logError(1,
+			 "%s %s: Number of bytes of parameter wrong! %d != %d byte\n",
+			 tag, __func__, (count + 1) / 3, 1);
+	} else {
+		sscanf(p, "%02X ", &temp);
+		p += 3;
+		info->stylus_enabled = temp;
+
+	}
+	return count;
+}
+#endif
+
+#endif
+
+/***************************************** GESTURES ***************************************************/
+#ifdef GESTURE_MODE
+#ifdef USE_GESTURE_MASK
+/**
+ * File node used by the host to set the gesture mask to enable or disable
+ * echo EE X1 X2 ~~ > gesture_mask  set the gesture to disable/enable; EE = 00(disable) or 01(enable)\n
+ *                                  X1 ~~  = gesture mask (example 06 00 ~~ 00 this gesture mask represents the gestures with ID = 1 and 2) can be specified from 1 to GESTURE_MASK_SIZE bytes,\n
+ *                                  if less than GESTURE_MASK_SIZE bytes are passed as arguments, the omit bytes of the mask maintain the previous settings\n
+ *                                  if one or more gestures is enabled the driver will automatically enable the gesture mode, If all the gestures are disabled the driver automatically will disable the gesture mode\n
+ * cat gesture_mask                 set inside the specified mask and return an error code for the operation \n
+ * the string returned in the shell is made up as follow:\n
+ * { = start byte \n
+ * X1X2X3X4 = 4 bytes in HEX format which represent an error code for enabling the mask (00000000 = no error)\n
+ * } = end byte \n\n
+ * if USE_GESTURE_MASK is not define the usage of the function become: \n\n
+ * echo EE X1 X2 ~~ > gesture_mask   set the gesture to disable/enable; EE = 00(disable) or 01(enable)\n
+ *                                   X1 ~~ = gesture IDs (example 01 02 05 represent the gestures with ID = 1, 2 and 5) there is no limit of the IDs passed as arguments, (@link gesture_opt Gesture IDs @endlink)\n
+ *                                   if one or more gestures is enabled the driver will automatically enable the gesture mode. If all the gestures are disabled the driver automatically will disable the gesture mode.\n
+ * cat gesture_mask                  to show the status of the gesture enabled switch \n
+ * the string returned in the shell is made up as follow:\n
+ * { = start byte \n
+ * X1X2X3X4 = 4 bytes in HEX format which is the value of info->gesture_enabled (1 = enabled; 0= disabled)\n
+ * } = end byte
+ */
+static ssize_t fts_gesture_mask_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	int size = (6 * 2) + 1, index = 0;
+	u8 *all_strbuff = NULL;
+	int count = 0, res, temp;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	if (mask[0] == 0) {
+		res = ERROR_OP_NOT_ALLOW;
+		logError(1,
+			 "%s %s: Call before echo enable/disable xx xx .... > gesture_mask with a correct number of parameters! ERROR %08X \n",
+			 tag, __func__, res);
+	} else {
+
+		if (mask[1] == FEAT_ENABLE || mask[1] == FEAT_DISABLE)
+			res = updateGestureMask(&mask[2], mask[0], mask[1]);
+		else
+			res = ERROR_OP_NOT_ALLOW;
+
+		if (res < OK) {
+			logError(1, "%s fts_gesture_mask_store: ERROR %08X \n",
+				 tag, res);
+		}
+	}
+	res |= check_feature_feasibility(info, FEAT_SEL_GESTURE);
+	temp = isAnyGestureActive();
+	if (res >= OK || temp == FEAT_DISABLE) {
+		info->gesture_enabled = temp;
+	}
+
+	logError(1, "%s fts_gesture_mask_store: Gesture Enabled = %d \n", tag,
+		 info->gesture_enabled);
+
+	all_strbuff = (u8 *) kzalloc(size, GFP_KERNEL);
+	if (all_strbuff != NULL) {
+
+		index += snprintf(&all_strbuff[index], 13, "{ %08X }", res);
+
+		count = snprintf(buf, TSP_BUF_SIZE, "%s\n", all_strbuff);
+		kfree(all_strbuff);
+	} else {
+		logError(1,
+			 "%s fts_gesture_mask_show: Unable to allocate all_strbuff! ERROR %08X\n",
+			 tag, ERROR_ALLOC);
+	}
+
+	mask[0] = 0;
+	return count;
+}
+
+static ssize_t fts_gesture_mask_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	char *p = (char *)buf;
+	int n;
+	unsigned int temp;
+
+	if ((count + 1) / 3 > GESTURE_MASK_SIZE + 1) {
+		logError(1,
+			 "%s fts_gesture_mask_store: Number of bytes of parameter wrong! %d > (enable/disable + %d )\n",
+			 tag, (count + 1) / 3, GESTURE_MASK_SIZE);
+		mask[0] = 0;
+	} else {
+		mask[0] = ((count + 1) / 3) - 1;
+		for (n = 1; n <= (count + 1) / 3; n++) {
+			sscanf(p, "%02X ", &temp);
+			p += 3;
+			mask[n] = (u8) temp;
+			logError(0, "%s mask[%d] = %02X \n", tag, n, mask[n]);
+
+		}
+	}
+
+	return count;
+}
+
+#else
+/**
+ * File node used by the host to set the gesture mask to enable or disable
+ * echo EE X1 X2 ~~ > gesture_mask	set the gesture to disable/enable; EE = 00(disable) or 01(enable)\n
+ *									X1 ~ = gesture IDs (example 01 02 05 represent the gestures with ID = 1, 2 and 5) there is no limit of the IDs passed as arguments, (@link gesture_opt Gesture IDs @endlink) \n
+ *									if one or more gestures is enabled the driver will automatically enable the gesture mode, If all the gestures are disabled the driver automatically will disable the gesture mode \n
+ * cat gesture_mask					to show the status of the gesture enabled switch \n
+ * the string returned in the shell is made up as follow: \n
+ * { = start byte \n
+ * X1X2X3X4 = 4 bytes in HEX format which is the value of info->gesture_enabled (1 = enabled; 0= disabled)\n
+ * } = end byte
+ */
+static ssize_t fts_gesture_mask_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	int size = (6 * 2) + 1, index = 0;
+	u8 *all_strbuff = NULL;
+	int count = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	logError(0, "%s fts_gesture_mask_show: gesture_enabled = %d \n", tag,
+		 info->gesture_enabled);
+
+	all_strbuff = (u8 *) kzalloc(size, GFP_KERNEL);
+	if (all_strbuff != NULL) {
+
+		index +=
+		    snprintf(&all_strbuff[index], 13, "{ %08X }",
+			     info->gesture_enabled);
+
+		count = snprintf(buf, TSP_BUF_SIZE, "%s\n", all_strbuff);
+		kfree(all_strbuff);
+	} else {
+		logError(1,
+			 "%s fts_gesture_mask_show: Unable to allocate all_strbuff! ERROR %08X\n",
+			 tag, ERROR_ALLOC);
+	}
+
+	return count;
+}
+
+static ssize_t fts_gesture_mask_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	char *p = (char *)buf;
+	int n;
+	unsigned int temp;
+	int res;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	if ((count + 1) / 3 < 2 || (count + 1) / 3 > GESTURE_MASK_SIZE + 1) {
+		logError(1,
+			 "%s fts_gesture_mask_store: Number of bytes of parameter wrong! %d < or > (enable/disable + at least one gestureID or max %d bytes)\n",
+			 tag, (count + 1) / 3, GESTURE_MASK_SIZE);
+		mask[0] = 0;
+	} else {
+		memset(mask, 0, GESTURE_MASK_SIZE + 2);
+		mask[0] = ((count + 1) / 3) - 1;
+		sscanf(p, "%02X ", &temp);
+		p += 3;
+		mask[1] = (u8) temp;
+		for (n = 1; n < (count + 1) / 3; n++) {
+			sscanf(p, "%02X ", &temp);
+			p += 3;
+			fromIDtoMask((u8) temp, &mask[2], GESTURE_MASK_SIZE);
+
+		}
+
+		for (n = 0; n < GESTURE_MASK_SIZE + 2; n++) {
+			logError(1, "%s mask[%d] = %02X \n", tag, n, mask[n]);
+
+		}
+
+	}
+
+	if (mask[0] == 0) {
+		res = ERROR_OP_NOT_ALLOW;
+		logError(1,
+			 "%s %s: Call before echo enable/disable xx xx .... > gesture_mask with a correct number of parameters! ERROR %08X \n",
+			 tag, __func__, res);
+	} else {
+
+		if (mask[1] == FEAT_ENABLE || mask[1] == FEAT_DISABLE)
+			res = updateGestureMask(&mask[2], mask[0], mask[1]);
+		else
+			res = ERROR_OP_NOT_ALLOW;
+
+		if (res < OK) {
+			logError(1, "%s fts_gesture_mask_store: ERROR %08X \n",
+				 tag, res);
+		}
+
+	}
+
+	res = check_feature_feasibility(info, FEAT_SEL_GESTURE);
+	temp = isAnyGestureActive();
+	if (res >= OK || temp == FEAT_DISABLE) {
+		info->gesture_enabled = temp;
+	}
+	res = fts_mode_handler(info, 0);
+
+	return count;
+}
+
+#endif
+
+/**
+ * File node to read the coordinates of the last gesture drawn by the user \n
+ * cat gesture_coordinates			to obtain the gesture coordinates \n
+ * the string returned in the shell follow this up as follow: \n
+ * { = start byte \n
+ * X1X2X3X4 = 4 bytes in HEX format which represent an error code (00000000 no error) \n
+ * \n if error code = 00000000 \n
+ * CC = 1 byte in HEX format number of coords (pair of x,y) returned \n
+ * XXiYYi ... = XXi 2 bytes in HEX format for x[i] and YYi 2 bytes in HEX format for y[i] (big endian) \n
+ * \n
+ * } = end byte
+ */
+static ssize_t fts_gesture_coordinates_show(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	int size = (6 * 2) + 1, index = 0;
+	u8 *all_strbuff = NULL;
+	int count = 0, res, i = 0;
+
+	logError(0, "%s %s: Getting gestures coordinates... \n", tag, __func__);
+
+	if (gesture_coords_reported < OK) {
+		logError(1, "%s %s: invalid coordinates! ERROR %08X \n", tag,
+			 __func__, gesture_coords_reported);
+		res = gesture_coords_reported;
+	} else {
+		size += gesture_coords_reported * 2 * 4 + 2;
+		res = OK;
+	}
+
+	all_strbuff = (u8 *) kzalloc(size, GFP_KERNEL);
+	if (all_strbuff != NULL) {
+
+		snprintf(&all_strbuff[index], 11, "{ %08X", res);
+		index += 10;
+
+		if (res >= OK) {
+			snprintf(&all_strbuff[index], 3, "%02X",
+				 gesture_coords_reported);
+			index += 2;
+
+			for (i = 0; i < gesture_coords_reported; i++) {
+				snprintf(&all_strbuff[index], 5, "%04X",
+					 gesture_coordinates_x[i]);
+				index += 4;
+				snprintf(&all_strbuff[index], 5, "%04X",
+					 gesture_coordinates_y[i]);
+				index += 4;
+			}
+		}
+
+		index += snprintf(&all_strbuff[index], 3, " }");
+
+		count = snprintf(buf, TSP_BUF_SIZE, "%s\n", all_strbuff);
+		kfree(all_strbuff);
+		logError(0, "%s %s: Getting gestures coordinates FINISHED! \n",
+			 tag, __func__);
+
+	} else {
+		logError(1,
+			 "%s %s: Unable to allocate all_strbuff! ERROR %08X\n",
+			 tag, ERROR_ALLOC);
+	}
+
+	return count;
+}
+#endif
+
+/***************************************** PRODUCTION TEST ***************************************************/
+
+/**
+ * File node to execute the Mass Production Test or to get data from the IC (raw or ms/ss init data)
+ * echo cmd > stm_fts_cmd		to execute a command \n
+ * cat stm_fts_cmd				to show the result of the command \n
+ * echo cmd > stm_fts_cmd; cat stm_fts_cmd 		to execute and show the result in just one call \n
+ * the string returned in the shell is made up as follow: \n
+ * { = start byte \n
+ * X1X2X3X4 = 4 bytes in HEX format which represent an error_code (00000000 = OK)\n
+ * (optional) data = data coming from the command executed represented as HEX string \n
+ *                   Not all the command return additional data \n
+ * } = end byte
+ * \n
+ * Possible commands (cmd): \n
+ * - 00 = MP Test -> return erro_code \n
+ * - 01 = ITO Test -> return error_code \n
+ * - 03 = MS Raw Test -> return error_code \n
+ * - 04 = MS Init Data Test -> return error_code \n
+ * - 05 = SS Raw Test -> return error_code \n
+ * - 06 = SS Init Data Test -> return error_code \n
+ * - 13 = Read 1 MS Raw Frame -> return additional data: MS frame row after row \n
+ * - 14 = Read MS Init Data -> return additional data: MS init data row after row \n
+ * - 15 = Read 1 SS Raw Frame -> return additional data: SS frame, force channels followed by sense channels \n
+ * - 16 = Read SS Init Data -> return additional data: SS Init data, first IX for force and sense channels and then CX for force and sense channels \n
+ * - F0 = Perform a system reset -> return error_code \n
+ * - F1 = Perform a system reset and reenable the sensing and the interrupt
+ */
+static ssize_t stm_fts_cmd_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	int n;
+	char *p = (char *)buf;
+
+	memset(typeOfComand, 0, CMD_STR_LEN * sizeof(u32));
+
+	logError(1, "%s \n", tag);
+	for (n = 0; n < (count + 1) / 3; n++) {
+		sscanf(p, "%02X ", &typeOfComand[n]);
+		p += 3;
+		logError(1, "%s typeOfComand[%d] = %02X \n", tag, n,
+			 typeOfComand[n]);
+
+	}
+
+	numberParameters = n;
+	logError(1, "%s Number of Parameters = %d \n", tag, numberParameters);
+	return count;
+}
+
+static ssize_t stm_fts_cmd_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int res, j, doClean = 0, count = 0, index = 0;
+	char buff[CMD_STR_LEN] = { 0 };
+
+	int size = (6 * 2) + 1;
+	int init_type = SPECIAL_PANEL_INIT;
+	u8 *all_strbuff = NULL;
+	const char *limit_file_name = NULL;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	MutualSenseData compData;
+	SelfSenseData comData;
+	MutualSenseFrame frameMS;
+	SelfSenseFrame frameSS;
+
+	if (numberParameters >= 1) {
+		res = fts_disableInterrupt();
+		if (res < 0) {
+			logError(0, "%s fts_disableInterrupt: ERROR %08X \n",
+				 tag, res);
+			res = (res | ERROR_DISABLE_INTER);
+			goto END;
+		}
+/*		
+#ifdef CONFIG_DRM
+		res = msm_drm_unregister_client(&info->notifier);
+		if (res < 0) {
+			logError(1, "%s ERROR: unregister notifier failed!\n",
+				 tag);
+			goto END;
+		}
+#endif
+*/
+		switch (typeOfComand[0]) {
+			/*ITO TEST */
+		case 0x01:
+			res = production_test_ito(LIMITS_FILE, &tests);
+			break;
+			/*PRODUCTION TEST */
+		case 0x00:
+
+			if (systemInfo.u8_cfgAfeVer != systemInfo.u8_cxAfeVer) {
+				res = ERROR_OP_NOT_ALLOW;
+				logError(0,
+					 "%s Miss match in CX version! MP test not allowed with wrong CX memory! ERROR %08X \n",
+					 tag, res);
+				break;
+			}
+
+			limit_file_name = fts_get_limit(info);
+			res =
+			    production_test_main(LIMITS_FILE, 1, init_type,
+						 &tests);
+			break;
+			/*read mutual raw */
+		case 0x13:
+			logError(0, "%s Get 1 MS Frame \n", tag);
+			setScanMode(SCAN_MODE_ACTIVE, 0x01);
+			mdelay(WAIT_FOR_FRESH_FRAMES);
+			setScanMode(SCAN_MODE_ACTIVE, 0x00);
+			mdelay(WAIT_AFTER_SENSEOFF);
+			flushFIFO();
+			res = getMSFrame3(MS_RAW, &frameMS);
+			if (res < 0) {
+				logError(0,
+					 "%s Error while taking the MS frame... ERROR %08X \n",
+					 tag, res);
+
+			} else {
+				logError(0, "%s The frame size is %d words\n",
+					 tag, res);
+				size = (res * (sizeof(short) * 2 + 1)) + 10;
+				res = OK;
+				print_frame_short("MS frame =",
+						  array1dTo2d_short
+						  (frameMS.node_data,
+						   frameMS.node_data_size,
+						   frameMS.header.sense_node),
+						  frameMS.header.force_node,
+						  frameMS.header.sense_node);
+			}
+			break;
+			/*read self raw */
+		case 0x15:
+			logError(0, "%s Get 1 SS Frame \n", tag);
+			setScanMode(SCAN_MODE_ACTIVE, 0x01);
+			mdelay(WAIT_FOR_FRESH_FRAMES);
+			setScanMode(SCAN_MODE_ACTIVE, 0x00);
+			mdelay(WAIT_AFTER_SENSEOFF);
+			flushFIFO();
+			res = getSSFrame3(SS_RAW, &frameSS);
+
+			if (res < OK) {
+				logError(0,
+					 "%s Error while taking the SS frame... ERROR %08X \n",
+					 tag, res);
+
+			} else {
+				logError(0, "%s The frame size is %d words\n",
+					 tag, res);
+				size = (res * (sizeof(short) * 2 + 1)) + 10;
+				res = OK;
+				print_frame_short("SS force frame =",
+						  array1dTo2d_short
+						  (frameSS.force_data,
+						   frameSS.header.force_node,
+						   1),
+						  frameSS.header.force_node, 1);
+				print_frame_short("SS sense frame =",
+						  array1dTo2d_short
+						  (frameSS.sense_data,
+						   frameSS.header.sense_node,
+						   frameSS.header.sense_node),
+						  1, frameSS.header.sense_node);
+			}
+
+			break;
+
+		case 0x14:
+			logError(0, "%s Get MS Compensation Data \n", tag);
+			res =
+			    readMutualSenseCompensationData(LOAD_CX_MS_TOUCH,
+							    &compData);
+
+			if (res < 0) {
+				logError(0,
+					 "%s Error reading MS compensation data ERROR %08X \n",
+					 tag, res);
+			} else {
+				logError(0,
+					 "%s MS Compensation Data Reading Finished! \n",
+					 tag);
+				size =
+				    (compData.node_data_size * sizeof(u8)) * 3 +
+				    1;
+				print_frame_i8("MS Data (Cx2) =",
+					       array1dTo2d_i8
+					       (compData.node_data,
+						compData.node_data_size,
+						compData.header.sense_node),
+					       compData.header.force_node,
+					       compData.header.sense_node);
+			}
+			break;
+
+		case 0x16:
+			logError(0, "%s Get SS Compensation Data... \n", tag);
+			res =
+			    readSelfSenseCompensationData(LOAD_CX_SS_TOUCH,
+							  &comData);
+			if (res < 0) {
+				logError(0,
+					 "%s Error reading SS compensation data ERROR %08X\n",
+					 tag, res);
+			} else {
+				logError(0,
+					 "%s SS Compensation Data Reading Finished! \n",
+					 tag);
+				size =
+				    ((comData.header.force_node +
+				      comData.header.sense_node) * 2 +
+				     12) * sizeof(u8) * 2 + 1;
+				print_frame_u8("SS Data Ix2_fm = ",
+					       array1dTo2d_u8(comData.ix2_fm,
+							      comData.
+							      header.force_node,
+							      1),
+					       comData.header.force_node, 1);
+				print_frame_i8("SS Data Cx2_fm = ",
+					       array1dTo2d_i8(comData.cx2_fm,
+							      comData.
+							      header.force_node,
+							      1),
+					       comData.header.force_node, 1);
+				print_frame_u8("SS Data Ix2_sn = ",
+					       array1dTo2d_u8(comData.ix2_sn,
+							      comData.
+							      header.sense_node,
+							      comData.
+							      header.sense_node),
+					       1, comData.header.sense_node);
+				print_frame_i8("SS Data Cx2_sn = ",
+					       array1dTo2d_i8(comData.cx2_sn,
+							      comData.
+							      header.sense_node,
+							      comData.
+							      header.sense_node),
+					       1, comData.header.sense_node);
+			}
+			break;
+
+		case 0x03:
+			res = fts_system_reset();
+			if (res >= OK)
+				res =
+				    production_test_ms_raw(LIMITS_FILE, 1,
+							   &tests);
+			break;
+
+		case 0x04:
+			res = fts_system_reset();
+			if (res >= OK)
+				res =
+				    production_test_ms_cx(LIMITS_FILE, 1,
+							  &tests);
+			break;
+
+		case 0x05:
+			res = fts_system_reset();
+			if (res >= OK)
+				res =
+				    production_test_ss_raw(LIMITS_FILE, 1,
+							   &tests);
+			break;
+
+		case 0x06:
+			res = fts_system_reset();
+			if (res >= OK)
+				res =
+				    production_test_ss_ix_cx(LIMITS_FILE, 1,
+							     &tests);
+			break;
+
+		case 0xF0:
+		case 0xF1:
+			doClean = (int)(typeOfComand[0] & 0x01);
+			res = cleanUp(doClean);
+			break;
+
+		default:
+			logError(1,
+				 "%s COMMAND NOT VALID!! Insert a proper value ...\n",
+				 tag);
+			res = ERROR_OP_NOT_ALLOW;
+			break;
+		}
+
+		doClean = fts_mode_handler(info, 1);
+		if (typeOfComand[0] != 0xF0)
+			doClean |= fts_enableInterrupt();
+		if (doClean < 0) {
+			logError(0, "%s %s: ERROR %08X \n", tag, __func__,
+				 (doClean | ERROR_ENABLE_INTER));
+		}
+	} else {
+		logError(1,
+			 "%s NO COMMAND SPECIFIED!!! do: 'echo [cmd_code] [args] > stm_fts_cmd' before looking for result!\n",
+			 tag);
+		res = ERROR_OP_NOT_ALLOW;
+
+	}
+/*
+#ifdef CONFIG_DRM
+	if (msm_drm_register_client(&info->notifier) < 0) {
+		logError(1, "%s ERROR: register notifier failed!\n", tag);
+	}
+#endif
+*/
+END:
+	all_strbuff = (u8 *) kzalloc(size, GFP_KERNEL);
+
+	if (res >= OK) {
+		/*all the other cases are already fine printing only the res. */
+		switch (typeOfComand[0]) {
+		case 0x13:
+			snprintf(all_strbuff, size, "ms_frame\n");
+			for (j = 0; j < frameMS.node_data_size; j++) {
+				if ((j + 1) % frameMS.header.sense_node)
+					snprintf(buff, sizeof(buff), "%04d ",
+						 frameMS.node_data[j]);
+				else
+					snprintf(buff, sizeof(buff), "%04d\n",
+						 frameMS.node_data[j]);
+
+				strlcat(all_strbuff, buff, size);
+			}
+
+			kfree(frameMS.node_data);
+			frameMS.node_data = NULL;
+			break;
+
+		case 0x15:
+			snprintf(all_strbuff, size, "ss_frame\n");
+			for (j = 0; j < frameSS.header.force_node - 1; j++) {
+				snprintf(buff, sizeof(buff), "%04d ",
+					 frameSS.force_data[j]);
+				strlcat(all_strbuff, buff, size);
+			}
+
+			if (j == frameSS.header.force_node - 1) {
+				snprintf(buff, sizeof(buff), "%04d\n",
+					 frameSS.force_data[j]);
+				strlcat(all_strbuff, buff, size);
+			}
+
+			for (j = 0; j < frameSS.header.sense_node - 1; j++) {
+				snprintf(buff, sizeof(buff), "%04d ",
+					 frameSS.sense_data[j]);
+				strlcat(all_strbuff, buff, size);
+			}
+
+			if (j == frameSS.header.sense_node - 1) {
+				snprintf(buff, sizeof(buff), "%04d\n",
+					 frameSS.sense_data[j]);
+				strlcat(all_strbuff, buff, size);
+			}
+
+			kfree(frameSS.force_data);
+			kfree(frameSS.sense_data);
+
+			break;
+
+		case 0x14:
+			snprintf(buff, sizeof(buff), "%02X",
+				 (u8) compData.header.force_node);
+			strlcat(all_strbuff, buff, size);
+			snprintf(buff, sizeof(buff), "%02X",
+				 (u8) compData.header.sense_node);
+			strlcat(all_strbuff, buff, size);
+			snprintf(buff, sizeof(buff), "%02X", compData.cx1);
+			strlcat(all_strbuff, buff, size);
+
+			for (j = 0; j < compData.node_data_size; j++) {
+				snprintf(buff, sizeof(buff), "%02X",
+					 *(compData.node_data + j));
+				strlcat(all_strbuff, buff, size);
+			}
+
+			kfree(compData.node_data);
+			compData.node_data = NULL;
+
+			break;
+
+		case 0x16:
+			snprintf(buff, sizeof(buff), "%02X",
+				 comData.header.force_node);
+			strlcat(all_strbuff, buff, size);
+			snprintf(buff, sizeof(buff), "%02X",
+				 comData.header.sense_node);
+			strlcat(all_strbuff, buff, size);
+			snprintf(buff, sizeof(buff), "%02X", comData.f_ix1);
+			strlcat(all_strbuff, buff, size);
+			snprintf(buff, sizeof(buff), "%02X", comData.s_ix1);
+			strlcat(all_strbuff, buff, size);
+			snprintf(buff, sizeof(buff), "%02X", comData.f_cx1);
+			strlcat(all_strbuff, buff, size);
+			snprintf(buff, sizeof(buff), "%02X", comData.s_cx1);
+			strlcat(all_strbuff, buff, size);
+
+			for (j = 0; j < comData.header.force_node; j++) {
+				snprintf(buff, sizeof(buff), "%02X",
+					 comData.ix2_fm[j]);
+				strlcat(all_strbuff, buff, size);
+			}
+
+			for (j = 0; j < comData.header.sense_node; j++) {
+				snprintf(buff, sizeof(buff), "%02X",
+					 comData.ix2_sn[j]);
+				strlcat(all_strbuff, buff, size);
+			}
+
+			for (j = 0; j < comData.header.force_node; j++) {
+				snprintf(buff, sizeof(buff), "%02X",
+					 comData.cx2_fm[j]);
+				strlcat(all_strbuff, buff, size);
+			}
+
+			for (j = 0; j < comData.header.sense_node; j++) {
+				snprintf(buff, sizeof(buff), "%02X",
+					 comData.cx2_sn[j]);
+				strlcat(all_strbuff, buff, size);
+			}
+
+			kfree(comData.ix2_fm);
+			kfree(comData.ix2_sn);
+			kfree(comData.cx2_fm);
+			kfree(comData.cx2_sn);
+
+			break;
+
+		default:
+			snprintf(&all_strbuff[index], 11, "{ %08X", res);
+			index += 10;
+			snprintf(&all_strbuff[index], 3, " }");
+			index += 2;
+
+			break;
+
+		}
+	} else {
+		snprintf(&all_strbuff[index], 11, "{ %08X", res);
+		index += 10;
+		snprintf(&all_strbuff[index], 3, " }");
+		index += 2;
+	}
+
+	count = snprintf(buf, TSP_BUF_SIZE, "%s\n", all_strbuff);
+	numberParameters = 0;
+	kfree(all_strbuff);
+
+	return count;
+}
+
+static ssize_t fts_panel_color_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%c\n", info->lockdown_info[2]);
+}
+
+static ssize_t fts_panel_vendor_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%c\n", info->lockdown_info[6]);
+}
+
+static ssize_t fts_panel_display_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%c\n", info->lockdown_info[1]);
+}
+
+static ssize_t fts_lockdown_info_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	int ret;
+	ret = fts_get_lockdown_info(info->lockdown_info, info);
+
+	if (ret != OK) {
+		logError(1, "%s get lockdown info error\n", tag);
+		return 0;
+	}
+
+	return snprintf(buf, PAGE_SIZE,
+			"0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x\n",
+			info->lockdown_info[0], info->lockdown_info[1],
+			info->lockdown_info[2], info->lockdown_info[3],
+			info->lockdown_info[4], info->lockdown_info[5],
+			info->lockdown_info[6], info->lockdown_info[7]);
+}
+
+static ssize_t fts_lockdown_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	int n, i, ret;
+	char *p = (char *)buf;
+	u8 *typecomand = NULL;
+
+	memset(typeOfComand, 0, CMD_STR_LEN * sizeof(u32));
+	logError(1, "%s \n", tag);
+	for (n = 0; n < (count + 1) / 3; n++) {
+		sscanf(p, "%02X ", &typeOfComand[n]);
+		p += 3;
+		logError(1, "%s command_sequence[%d] = %02X\n", tag, n,
+			 typeOfComand[n]);
+	}
+	numberParameters = n;
+	if (numberParameters < 3)
+		goto END;
+	logError(1, "%s %d = %d \n", tag, n, numberParameters);
+
+	typecomand =
+	    (u8 *) kmalloc((numberParameters - 2) * sizeof(u8), GFP_KERNEL);
+	if (typecomand != NULL) {
+		for (i = 0; i < numberParameters - 2; i++) {
+			typecomand[i] = (u8) typeOfComand[i + 2];
+			logError(1, "%s typecomand[%d] = %X \n", tag, i,
+				 typecomand[i]);
+		}
+	} else {
+		goto END;
+	}
+
+	ret =
+	    writeLockDownInfo(typecomand, numberParameters - 2,
+			      typeOfComand[0]);
+	if (ret < 0) {
+		logError(1, "%s fts_lockdown_store failed\n", tag);
+	}
+	kfree(typecomand);
+END:
+	logError(1, "%s Number of Parameters = %d \n", tag, numberParameters);
+
+	return count;
+}
+
+static ssize_t fts_lockdown_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int i, ret;
+	int size = 0, count = 0;
+	u8 type;
+	u8 *temp_buffer = NULL;
+
+	temp_buffer = (u8 *) kmalloc(LOCKDOWN_LENGTH * sizeof(u8), GFP_KERNEL);
+	if (temp_buffer == NULL || numberParameters < 2) {
+		count +=
+		    snprintf(&buf[count], PAGE_SIZE, "prepare read lockdown failded\n");
+		return count;
+	}
+	type = typeOfComand[0];
+	size = (int)(typeOfComand[1]);
+	count += snprintf(&buf[count], PAGE_SIZE, "read lock down code:\n");
+	ret = readLockDownInfo(temp_buffer, type, size);
+	if (ret < OK) {
+		count += snprintf(&buf[count], PAGE_SIZE, "read lockdown failded\n");
+		goto END;
+	}
+	for (i = 0; i < size; i++) {
+		count += snprintf(&buf[count], PAGE_SIZE, "%02X ", temp_buffer[i]);
+	}
+	count += snprintf(&buf[count], PAGE_SIZE, "\n");
+
+END:
+	numberParameters = 0;
+	kfree(temp_buffer);
+	return count;
+}
+
+static ssize_t fts_selftest_info_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	int res = 0, i = 0, count = 0, force_node = 0, sense_node = 0, pos =
+	    0, last_pos = 0;
+	MutualSenseFrame frameMS;
+	char buff[80];
+	struct i2c_client *client = to_i2c_client(dev);
+	struct fts_ts_info *info = i2c_get_clientdata(client);
+
+	res = fts_disableInterrupt();
+	if (res < OK)
+		goto END;
+
+	setScanMode(SCAN_MODE_ACTIVE, 0x01);
+	mdelay(WAIT_FOR_FRESH_FRAMES);
+	setScanMode(SCAN_MODE_ACTIVE, 0x00);
+	mdelay(WAIT_AFTER_SENSEOFF);
+	flushFIFO();
+	res = getMSFrame3(MS_RAW, &frameMS);
+	if (res < 0) {
+		logError(0,
+			 "%s Error while taking the MS frame... ERROR %08X \n",
+			 tag, res);
+		goto END;
+	}
+	fts_mode_handler(info, 1);
+
+	sense_node = frameMS.header.sense_node;
+	force_node = frameMS.header.force_node;
+
+	for (i = 0; i < RELEASE_INFO_SIZE; i++) {
+		if (i == 0) {
+			pos +=
+			    snprintf(buff + last_pos, PAGE_SIZE, "0x%02x",
+				     systemInfo.u8_releaseInfo[i]);
+			last_pos = pos;
+		} else {
+			pos +=
+			    snprintf(buff + last_pos, PAGE_SIZE, "%02x",
+				     systemInfo.u8_releaseInfo[i]);
+			last_pos = pos;
+		}
+	}
+	count =
+	    snprintf(buf, PAGE_SIZE,
+		     "Device address:,0x49\nChip Id:,0x%04x\nFw version:,0x%04x\nConfig version:,0x%04x\nChip serial number:,%s\nForce lines count:,%02d\nSense lines count:,%02d\n\n",
+		     systemInfo.u16_chip0Id, systemInfo.u16_fwVer,
+		     systemInfo.u16_cfgVer, buff, force_node, sense_node);
+END:
+	fts_enableInterrupt();
+	return count;
+
+}
+
+/*
+static ssize_t fts_ms_raw_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int res = 0, count = 0, j = 0, sense_node = 0, force_node = 0, pos =
+	    0, last_pos = 0;
+	char *all_strbuff = NULL;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct fts_ts_info *info = i2c_get_clientdata(client);
+	MutualSenseFrame frameMS;
+
+	res = fts_disableInterrupt();
+	if (res < OK)
+		goto END;
+	all_strbuff = key_alloc(PAGE_SIZE);
+	if (!all_strbuff) {
+		logError(1, "%s %s alloc all_strbuff fail\n", tag, __func__);
+		goto END;
+	} else
+		memset(all_strbuff, 0, PAGE_SIZE);
+
+	setScanMode(SCAN_MODE_ACTIVE, 0x01);
+	mdelay(WAIT_FOR_FRESH_FRAMES);
+	setScanMode(SCAN_MODE_ACTIVE, 0x00);
+	mdelay(WAIT_AFTER_SENSEOFF);
+	flushFIFO();
+	res = getMSFrame3(MS_RAW, &frameMS);
+
+	fts_mode_handler(info, 1);
+	sense_node = frameMS.header.sense_node;
+	force_node = frameMS.header.force_node;
+	pos +=
+	    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+		     "MsTouchRaw,%2d,%2d\n ,", force_node, sense_node);
+	last_pos = pos;
+	if (res >= OK) {
+		for (j = 0; j < sense_node; j++)
+			if ((j + 1) % sense_node) {
+				pos +=
+				    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+					     "C%02d,", j);
+				last_pos = pos;
+			} else {
+				pos +=
+				    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+					     "C%02d\nR00,", j);
+				last_pos = pos;
+			}
+		for (j = 0; j < sense_node * force_node; j++) {
+			if ((j + 1) % sense_node) {
+				pos +=
+				    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+					     "%4d,", frameMS.node_data[j]);
+				last_pos = pos;
+			} else {
+				if ((j + 1) / sense_node != force_node)
+					pos +=
+					    snprintf(all_strbuff + last_pos,
+						     PAGE_SIZE, "%4d\nR%02d,",
+						     frameMS.node_data[j],
+						     (j + 1) / sense_node);
+				else
+					pos +=
+					    snprintf(all_strbuff + last_pos,
+						     PAGE_SIZE, "%4d\n",
+						     frameMS.node_data[j]);
+				last_pos = pos;
+			}
+		}
+		if (frameMS.node_data) {
+			kfree(frameMS.node_data);
+			frameMS.node_data = NULL;
+		}
+	}
+
+	count = snprintf(buf, PAGE_SIZE, "%s\n", all_strbuff);
+	kvfree(all_strbuff);
+END:
+	fts_enableInterrupt();
+	return count;
+}
+
+static ssize_t fts_ms_cx_total_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	int res = 0, pos = 0, last_pos = 0, count = 0, j = 0, sense_node =
+	    0, force_node = 0;
+	char *all_strbuff = NULL;
+	TotMutualSenseData totCompData;
+
+	res = fts_disableInterrupt();
+	if (res < OK)
+		goto END;
+	all_strbuff = kvmalloc(PAGE_SIZE);
+	if (!all_strbuff) {
+		logError(1, "%s %s alloc all_strbuff fail\n", tag, __func__);
+		goto END;
+	} else
+		memset(all_strbuff, 0, PAGE_SIZE);
+
+	res =
+	    readTotMutualSenseCompensationData(LOAD_PANEL_CX_TOT_MS_TOUCH,
+					       &totCompData);
+	if (res >= OK) {
+		sense_node = totCompData.header.sense_node;
+		force_node = totCompData.header.force_node;
+		pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+			     "MsTouchTotalCx,%2d,%2d\n ,", force_node,
+			     sense_node);
+		last_pos = pos;
+		for (j = 0; j < sense_node; j++)
+			if ((j + 1) % sense_node) {
+				pos +=
+				    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+					     "C%02d,", j);
+				last_pos = pos;
+			} else {
+				pos +=
+				    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+					     "C%02d\nR00,", j);
+				last_pos = pos;
+			}
+		for (j = 0; j < sense_node * force_node; j++) {
+			if ((j + 1) % sense_node) {
+				pos +=
+				    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+					     "%4d,", totCompData.node_data[j]);
+				last_pos = pos;
+			} else {
+				if ((j + 1) / sense_node != force_node)
+					pos +=
+					    snprintf(all_strbuff + last_pos,
+						     PAGE_SIZE, "%4d\nR%02d,",
+						     totCompData.node_data[j],
+						     (j + 1) / sense_node);
+				else
+					pos +=
+					    snprintf(all_strbuff + last_pos,
+						     PAGE_SIZE, "%4d\n",
+						     totCompData.node_data[j]);
+				last_pos = pos;
+			}
+		}
+		if (totCompData.node_data) {
+			kfree(totCompData.node_data);
+			totCompData.node_data = NULL;
+		}
+	}
+
+	count = snprintf(buf, PAGE_SIZE, "%s\n", all_strbuff);
+	kvfree(all_strbuff);
+END:
+	fts_enableInterrupt();
+	return count;
+
+}
+
+static ssize_t fts_ss_ix_total_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	int ret = 0, pos = 0, last_pos = 0, count = 0, j = 0, sense_node =
+	    0, force_node = 0;
+	char *all_strbuff = NULL;
+	TotSelfSenseData totCompData;
+
+	ret = fts_disableInterrupt();
+	if (ret < OK)
+		goto END;
+	all_strbuff = vmalloc(PAGE_SIZE);
+	if (!all_strbuff) {
+		logError(1, "%s %s alloc all_strbuff fail\n", tag, __func__);
+		goto END;
+	} else {
+		memset(all_strbuff, 0, PAGE_SIZE);
+	}
+	ret =
+	    readTotSelfSenseCompensationData(LOAD_PANEL_CX_TOT_SS_TOUCH,
+					     &totCompData);
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: readTotSelfSenseCompensationData failed... ERROR %08X \n",
+			 tag, ERROR_PROD_TEST_DATA);
+		goto END;
+	}
+
+	sense_node = 1;
+	force_node = totCompData.header.force_node;
+
+	pos +=
+	    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+		     "SsTouchForceTotalIx,%2d,1\n ,C00\n", force_node);
+	last_pos = pos;
+	for (j = 0; j < force_node; j++) {
+		pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE, "R%02d,%4d\n",
+			     j, totCompData.ix_fm[j]);
+		last_pos = pos;
+	}
+
+	pos +=
+	    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+		     "SsTouchForceTotalCx,%2d,1\n ,C00\n", force_node);
+	last_pos = pos;
+	for (j = 0; j < force_node; j++) {
+		pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE, "R%02d,%4d\n",
+			     j, totCompData.cx_fm[j]);
+		last_pos = pos;
+	}
+
+	sense_node = totCompData.header.sense_node;
+	force_node = 1;
+
+	pos +=
+	    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+		     "SsTouchsenseTotalIx,%2d,1\n ,C00\n", sense_node);
+	last_pos = pos;
+	for (j = 0; j < sense_node; j++) {
+		pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE, "R%02d,%4d\n",
+			     j, totCompData.ix_sn[j]);
+		last_pos = pos;
+	}
+
+	pos +=
+	    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+		     "SsTouchsenseTotalCx,%2d,1\n ,C00\n", sense_node);
+	last_pos = pos;
+	for (j = 0; j < sense_node; j++) {
+		pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE, "R%02d,%4d\n",
+			     j, totCompData.cx_sn[j]);
+		last_pos = pos;
+	}
+
+	if (totCompData.ix_fm != NULL) {
+		kfree(totCompData.ix_fm);
+		totCompData.ix_fm = NULL;
+	}
+
+	if (totCompData.cx_fm != NULL) {
+		kfree(totCompData.cx_fm);
+		totCompData.cx_fm = NULL;
+	}
+
+	if (totCompData.ix_sn != NULL) {
+		kfree(totCompData.ix_sn);
+		totCompData.ix_sn = NULL;
+	}
+
+	if (totCompData.cx_sn != NULL) {
+		kfree(totCompData.cx_sn);
+		totCompData.cx_sn = NULL;
+	}
+
+	count = snprintf(buf, PAGE_SIZE, "%s\n", all_strbuff);
+	vfree(all_strbuff);
+END:
+	fts_enableInterrupt();
+	return count;
+}
+
+static ssize_t fts_ss_raw_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int res = 0, count = 0, j = 0, sense_node = 0, force_node = 0, pos =
+	    0, last_pos = 0;
+	char *all_strbuff = NULL;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct fts_ts_info *info = i2c_get_clientdata(client);
+	SelfSenseFrame frameSS;
+
+	res = fts_disableInterrupt();
+	if (res < OK)
+		goto END;
+	all_strbuff = vmalloc(PAGE_SIZE * 4);
+	if (!all_strbuff) {
+		logError(1, "%s %s alloc all_strbuff fail\n", tag, __func__);
+		goto END;
+	} else
+		memset(all_strbuff, 0, PAGE_SIZE);
+	setScanMode(SCAN_MODE_ACTIVE, 0x01);
+	mdelay(WAIT_FOR_FRESH_FRAMES);
+	setScanMode(SCAN_MODE_ACTIVE, 0x00);
+	mdelay(WAIT_AFTER_SENSEOFF);
+	flushFIFO();
+	res = getSSFrame3(SS_RAW, &frameSS);
+
+	fts_mode_handler(info, 1);
+	sense_node = frameSS.header.sense_node;
+	force_node = frameSS.header.force_node;
+	pos +=
+	    snprintf(all_strbuff + last_pos, PAGE_SIZE, "SsTouchRaw,%2d,%2d\n",
+		     force_node, sense_node);
+	last_pos = pos;
+	if (res >= OK) {
+		pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+			     "SS force frame\n ,");
+		last_pos = pos;
+
+		for (j = 0; j < frameSS.header.force_node - 1; j++) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE, "%04d,",
+				     frameSS.force_data[j]);
+			last_pos = pos;
+		}
+
+		if (j == frameSS.header.force_node - 1) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+				     "%04d\n", frameSS.force_data[j]);
+			last_pos = pos;
+		}
+
+		pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+			     "SS sense frame\n ,");
+		last_pos = pos;
+
+		for (j = 0; j < frameSS.header.sense_node - 1; j++) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE, "%04d,",
+				     frameSS.sense_data[j]);
+			last_pos = pos;
+		}
+
+		if (j == frameSS.header.sense_node - 1) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+				     "%04d\n", frameSS.sense_data[j]);
+			last_pos = pos;
+		}
+
+		if (frameSS.force_data) {
+			kfree(frameSS.force_data);
+			frameSS.force_data = NULL;
+		}
+		if (frameSS.sense_data) {
+			kfree(frameSS.sense_data);
+			frameSS.sense_data = NULL;
+		}
+
+	}
+
+	count = snprintf(buf, PAGE_SIZE, "%s\n", all_strbuff);
+	vfree(all_strbuff);
+END:
+	fts_enableInterrupt();
+	return count;
+}
+*/
+static ssize_t fts_strength_frame_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	MutualSenseFrame frame;
+	int res = 0, count = 0, j = 0, size = 0;
+	char *all_strbuff = NULL;
+	char buff[CMD_STR_LEN] = { 0 };
+	struct i2c_client *client = to_i2c_client(dev);
+	struct fts_ts_info *info = i2c_get_clientdata(client);
+	frame.node_data = NULL;
+
+	res = fts_disableInterrupt();
+	if (res < OK)
+		goto END;
+
+	res = getMSFrame3(MS_STRENGTH, &frame);
+
+	if (res < OK) {
+		logError(1, "%s %s: could not get the frame! ERROR %08X \n",
+			 tag, __func__, res);
+		goto END;
+	}
+	size = (res * 5) + 11;
+
+	/*
+	   flushFIFO();
+	 */
+	fts_mode_handler(info, 1);
+	all_strbuff = (char *)kmalloc(PAGE_SIZE * sizeof(char), GFP_KERNEL);
+
+	if (all_strbuff != NULL) {
+		memset(all_strbuff, 0, size);
+		snprintf(all_strbuff, size, "ms_differ\n");
+		if (res >= OK) {
+			for (j = 0; j < frame.node_data_size; j++) {
+				if ((j + 1) % frame.header.sense_node)
+					snprintf(buff, sizeof(buff), "%4d,",
+						 frame.node_data[j]);
+				else
+					snprintf(buff, sizeof(buff), "%4d\n",
+						 frame.node_data[j]);
+
+				strlcat(all_strbuff, buff, size);
+			}
+
+			kfree(frame.node_data);
+			frame.node_data = NULL;
+		}
+
+		count = snprintf(buf, PAGE_SIZE, "%s\n", all_strbuff);
+		kfree(all_strbuff);
+	} else {
+		logError(1,
+			 "%s %s: Unable to allocate all_strbuff! ERROR %08X\n",
+			 tag, __func__, ERROR_ALLOC);
+	}
+
+END:
+	fts_enableInterrupt();
+
+	return count;
+}
+
+static int fts_hover_auto_tune(struct fts_ts_info *info) {
+	int res=OK;
+	u8 sett[2];
+	logError(0, "%s start...\n", tag, __func__);
+
+	fts_disableInterrupt();
+
+	sett[0] = 0x02;
+	sett[1] = 0x00;
+	res = writeSysCmd(SYS_CMD_SPECIAL_TUNING, sett, 2);
+	if (res < OK) {
+		logError(1, "%s fts_hover_autotune Ioffset tuning 02 00 failed ERROR %08X\n",
+				tag, (res | ERROR_PROD_TEST_INITIALIZATION));
+		return res | ERROR_PROD_TEST_INITIALIZATION;
+	}
+	sett[0] = 0x00;
+	sett[1] = 0x01;
+	res = writeSysCmd(SYS_CMD_CX_TUNING, sett, 2);
+	if (res < OK) {
+		logError(1, "%s fts_hover_autotune autotune hover 00 01 failed ERROR %08X\n",
+				tag, (res | ERROR_PROD_TEST_INITIALIZATION));
+		return res | ERROR_PROD_TEST_INITIALIZATION;
+	}
+	sett[0] = 0x06;
+	res = writeSysCmd(SYS_CMD_SAVE_FLASH, sett, 1);
+	if (res < OK) {
+		logError(1, "%s fts_hover_autotune save flash 06  failed ERROR %08X\n",
+				tag, (res | ERROR_PROD_TEST_INITIALIZATION));
+		return res | ERROR_PROD_TEST_INITIALIZATION;
+	}
+	logError(0, "%s end...\n", tag, __func__);
+
+	fts_enableInterrupt();
+
+	return res;
+}
+
+static ssize_t fts_hover_autotune_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	int on;
+	int ret = 0;
+
+	sscanf(buf, "%u", &on);
+	logError(1, " %s %s\n", tag, __func__);
+	if (on)
+		ret = fts_hover_auto_tune(info);
+	if (ret < OK)
+		return -1;
+
+	return count;
+}
+
+/*
+static ssize_t fts_hover_raw_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int res = 0, count = 0, j = 0, sense_node = 0, force_node = 0, pos =
+	    0, last_pos = 0;
+	char *all_strbuff = NULL;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct fts_ts_info *info = i2c_get_clientdata(client);
+	SelfSenseFrame frameSS;
+	TotSelfSenseData ssHoverCompData;
+	u8 hover_cnt[4] = {0xa8, 0x0b, 0x01, 0x00};
+
+	res = fts_disableInterrupt();
+	if (res < OK)
+		goto END;
+	all_strbuff = vmalloc(PAGE_SIZE * 4);
+	if (!all_strbuff) {
+		logError(1, "%s %s alloc all_strbuff fail\n", tag, __func__);
+		goto END;
+	} else {
+		memset(all_strbuff, 0, PAGE_SIZE);
+	}
+	res = fts_write_dma_safe(hover_cnt, sizeof(hover_cnt));
+	if (res != OK) {
+		logError(1,
+			 "%s hover clear count ERROR = %d\n",tag, res);
+		goto END;
+	}
+
+	setScanMode(SCAN_MODE_ACTIVE, 0xFF);
+
+	res = getSSFrame3(SS_HVR_RAW, &frameSS);
+
+	sense_node = frameSS.header.sense_node;
+	force_node = frameSS.header.force_node;
+	pos +=
+	    snprintf(all_strbuff + last_pos, PAGE_SIZE, "SsHoverTouchRaw,%2d,%2d\n",
+		     force_node, sense_node);
+	last_pos = pos;
+
+	pos +=
+	    snprintf(all_strbuff + last_pos, PAGE_SIZE, "TxRaw\n");
+	last_pos = pos;
+
+
+	if (res >= OK) {
+		pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+			     "SS Hover force frame\n ,");
+		last_pos = pos;
+
+		for (j = 0; j < frameSS.header.force_node - 1; j++) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE, "%04d,",
+				     frameSS.force_data[j]);
+			last_pos = pos;
+		}
+
+		if (j == frameSS.header.force_node - 1) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+				     "%04d\n", frameSS.force_data[j]);
+			last_pos = pos;
+		}
+
+		pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+			     "SS Hover sense frame\n ,");
+		last_pos = pos;
+
+		for (j = 0; j < frameSS.header.sense_node - 1; j++) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE, "%04d,",
+				     frameSS.sense_data[j]);
+			last_pos = pos;
+		}
+
+		if (j == frameSS.header.sense_node - 1) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+				     "%04d\n", frameSS.sense_data[j]);
+			last_pos = pos;
+		}
+
+		if (frameSS.force_data) {
+			kfree(frameSS.force_data);
+			frameSS.force_data = NULL;
+		}
+		if (frameSS.sense_data) {
+			kfree(frameSS.sense_data);
+			frameSS.sense_data = NULL;
+		}
+
+	}
+
+	res = getSSFrame3(SS_HVR_FILTER, &frameSS);
+
+	sense_node = frameSS.header.sense_node;
+	force_node = frameSS.header.force_node;
+
+	pos +=
+	    snprintf(all_strbuff + last_pos, PAGE_SIZE, "TxFilter\n");
+	last_pos = pos;
+
+
+	if (res >= OK) {
+		pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+			     "SS Hover force frame\n ,");
+		last_pos = pos;
+
+		for (j = 0; j < frameSS.header.force_node - 1; j++) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE, "%04d,",
+				     frameSS.force_data[j]);
+			last_pos = pos;
+		}
+
+		if (j == frameSS.header.force_node - 1) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+				     "%04d\n", frameSS.force_data[j]);
+			last_pos = pos;
+		}
+
+		pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+			     "SS Hover sense frame\n ,");
+		last_pos = pos;
+
+		for (j = 0; j < frameSS.header.sense_node - 1; j++) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE, "%04d,",
+				     frameSS.sense_data[j]);
+			last_pos = pos;
+		}
+
+		if (j == frameSS.header.sense_node - 1) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+				     "%04d\n", frameSS.sense_data[j]);
+			last_pos = pos;
+		}
+
+		if (frameSS.force_data) {
+			kfree(frameSS.force_data);
+			frameSS.force_data = NULL;
+		}
+		if (frameSS.sense_data) {
+			kfree(frameSS.sense_data);
+			frameSS.sense_data = NULL;
+		}
+
+	}
+
+	res = getSSFrame3(SS_HVR_BASELINE, &frameSS);
+
+	sense_node = frameSS.header.sense_node;
+	force_node = frameSS.header.force_node;
+
+	pos +=
+	    snprintf(all_strbuff + last_pos, PAGE_SIZE, "TxBaseline\n");
+	last_pos = pos;
+
+
+	if (res >= OK) {
+		pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+			     "SS Hover force frame\n ,");
+		last_pos = pos;
+
+		for (j = 0; j < frameSS.header.force_node - 1; j++) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE, "%04d,",
+				     frameSS.force_data[j]);
+			last_pos = pos;
+		}
+
+		if (j == frameSS.header.force_node - 1) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+				     "%04d\n", frameSS.force_data[j]);
+			last_pos = pos;
+		}
+
+		pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+			     "SS Hover sense frame\n ,");
+		last_pos = pos;
+
+		for (j = 0; j < frameSS.header.sense_node - 1; j++) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE, "%04d,",
+				     frameSS.sense_data[j]);
+			last_pos = pos;
+		}
+
+		if (j == frameSS.header.sense_node - 1) {
+			pos +=
+			    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+				     "%04d\n", frameSS.sense_data[j]);
+			last_pos = pos;
+		}
+
+		if (frameSS.force_data) {
+			kfree(frameSS.force_data);
+			frameSS.force_data = NULL;
+		}
+
+		if (frameSS.sense_data) {
+			kfree(frameSS.sense_data);
+			frameSS.sense_data = NULL;
+		}
+
+	}
+	pos +=
+		    snprintf(all_strbuff + last_pos, PAGE_SIZE,
+			     "SS Hover IX Data\n ,");
+	last_pos = pos;
+
+	res = readTotSelfSenseCompensationData(STAPI_HOST_DATA_ID_PANEL_CX_SS_HVR, &ssHoverCompData);
+
+	pos +=
+		snprintf(all_strbuff + last_pos, PAGE_SIZE,
+			 "SS Hover IX force frame\n ,");
+	last_pos = pos;
+	for (j = 0; j < ssHoverCompData.header.force_node - 1; j++) {
+		pos +=
+			snprintf(all_strbuff + last_pos, PAGE_SIZE, "%04d,",
+				 ssHoverCompData.ix_fm[j]);
+		last_pos = pos;
+	}
+
+	pos +=
+		snprintf(all_strbuff + last_pos, PAGE_SIZE,
+			 "\nSS Hover IX sense frame\n ,");
+	last_pos = pos;
+
+	for (j = 0; j < ssHoverCompData.header.sense_node - 1; j++) {
+		pos +=
+			snprintf(all_strbuff + last_pos, PAGE_SIZE, "%04d,",
+				 ssHoverCompData.ix_sn[j]);
+		last_pos = pos;
+	}
+
+	if (ssHoverCompData.ix_fm != NULL)
+		kfree(ssHoverCompData.ix_fm);
+	if (ssHoverCompData.ix_sn != NULL)
+		kfree(ssHoverCompData.ix_sn);
+	if (ssHoverCompData.cx_fm != NULL)
+		kfree(ssHoverCompData.cx_fm);
+	if (ssHoverCompData.cx_sn != NULL)
+		kfree(ssHoverCompData.cx_sn);
+
+	count = snprintf(buf, PAGE_SIZE, "%s\n", all_strbuff);
+	vfree(all_strbuff);
+END:
+	fts_mode_handler(info, 1);
+	fts_enableInterrupt();
+	return count;
+}
+*/
+
+#ifdef CONFIG_FTS_TOUCH_COUNT_DUMP
+static ssize_t fts_touch_suspend_notify_show(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", fts_info->sensor_sleep);
+}
+#endif
+
+static ssize_t fts_doze_time_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	return snprintf(buf, TSP_BUF_SIZE, "%u\n", info->doze_time);
+}
+
+static ssize_t fts_doze_time_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	u8 cmd[4] = {FTS_CMD_CUSTOM, 0x00, 0x00, 0x00};
+	int ret = 0;
+	u16 reg_val = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	pr_info("%s,buf:%s,count:%zu\n", __func__, buf, count);
+	sscanf(buf, "%u", &info->doze_time);
+	/*reg value * 10 represents of the num of frames ,one frame is about 8ms, the input value is ms*/
+	reg_val = (info->doze_time / 8 - 1) / 10;
+	cmd[3] = reg_val;
+	ret = fts_write_dma_safe(cmd, ARRAY_SIZE(cmd));
+	if (ret < OK) {
+		logError(1, "%s %s: write failed...ERROR %08X !\n", tag,
+			 __func__, ret);
+		return -EPERM;
+	}
+	return count;
+}
+
+static ssize_t fts_grip_enable_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	return snprintf(buf, TSP_BUF_SIZE, "%d\n", info->grip_enabled);
+}
+
+static ssize_t fts_grip_enable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	u8 cmd[3] = {FTS_CMD_FEATURE, 0x04, 0x01};
+	int ret = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	pr_info("%s,buf:%s,count:%zu\n", __func__, buf, count);
+	sscanf(buf, "%u", &info->grip_enabled);
+	cmd[2] = info->grip_enabled;
+	ret = fts_write_dma_safe(cmd, ARRAY_SIZE(cmd));
+	if (ret < OK) {
+		logError(1, "%s %s: write failed...ERROR %08X !\n", tag,
+			 __func__, ret);
+		return -EPERM;
+	}
+	return count;
+}
+
+static ssize_t fts_grip_area_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	return snprintf(buf, TSP_BUF_SIZE, "%d\n", info->grip_pixel);
+}
+
+static ssize_t fts_grip_area_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	u8 cmd[4] = {FTS_CMD_CUSTOM, 0x01, 0x01, 0x00};
+	int ret = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	logError(1, " %s %s,buf:%s,count:%zu\n", tag, __func__, buf, count);
+	sscanf(buf, "%u", &info->grip_pixel);
+	cmd[3] = info->grip_pixel;
+	if (atomic_read(&info->system_is_resetting)) {
+		logError(1, "%s %s system is resetting ,wait reset done\n", tag, __func__);
+		ret = wait_for_completion_timeout(&info->tp_reset_completion, msecs_to_jiffies(40));
+		if (!ret) {
+			logError(1, "%s %s wait tp reset timeout, wrtie grip area error\n", tag, __func__);
+			return count;
+		}
+	}
+	ret = fts_write_dma_safe(cmd, ARRAY_SIZE(cmd));
+	if (ret < OK) {
+		logError(1, "%s %s: write failed...ERROR %08X !\n", tag,
+			 __func__, ret);
+		return -EPERM;
+	}
+	return count;
+}
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+static ssize_t fts_fod_status_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	return snprintf(buf, TSP_BUF_SIZE, "%d\n", info->fod_status);
+}
+
+static ssize_t fts_fod_status_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	logError(1, " %s %s buf:%c,count:%zu\n", tag, __func__, buf[0], count);
+	sscanf(buf, "%u", &info->fod_status);
+	queue_work(info->event_wq, &info->mode_handler_work);
+	logError(1, " %s %s end\n", tag, __func__);
+
+	return count;
+}
+
+static ssize_t fts_fod_test_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	int value = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	logError(1, " %s %s,buf:%s,count:%zu\n", tag, __func__, buf, count);
+	sscanf(buf, "%u", &value);
+	if (value) {
+		input_report_key(info->input_dev, BTN_INFO, 1);
+		input_report_key(info->input_dev, KEY_INFO, 1);
+		info->fod_pressed = true;
+		input_sync(info->input_dev);
+		input_mt_slot(info->input_dev, 0);
+		input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 1);
+		input_report_key(info->input_dev, BTN_TOUCH, 1);
+		input_report_key(info->input_dev, BTN_TOOL_FINGER, 1);
+		input_report_abs(info->input_dev, ABS_MT_TRACKING_ID, 0);
+		input_report_abs(info->input_dev, ABS_MT_WIDTH_MINOR, 1);
+		input_report_abs(info->input_dev, ABS_MT_POSITION_X, CENTER_X);
+		input_report_abs(info->input_dev, ABS_MT_POSITION_Y, CENTER_Y);
+		input_sync(info->input_dev);
+	} else {
+		input_mt_slot(info->input_dev, 0);
+		input_report_abs(info->input_dev, ABS_MT_WIDTH_MINOR, 0);
+		input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);
+		input_report_abs(info->input_dev, ABS_MT_TRACKING_ID, -1);
+		input_report_key(info->input_dev, BTN_INFO, 0);
+		input_report_key(info->input_dev, KEY_INFO, 0);
+		input_sync(info->input_dev);
+	}
+	return count;
+}
+#endif
+
+#ifdef CONFIG_SECURE_TOUCH
+static void fts_secure_touch_notify (struct fts_ts_info *info)
+{
+	/*might sleep*/
+	sysfs_notify(&info->dev->kobj, NULL, "secure_touch");
+	logError(1, "%s %s SECURE_NOTIFY:notify secure_touch\n", tag, __func__);
+}
+
+static int fts_secure_stop(struct fts_ts_info *info, bool block)
+{
+	struct fts_secure_info *scr_info = info->secure_info;
+
+	logError(1, "%s %s SECURE_STOP: block = %d\n", tag, __func__, (int)block);
+	if (atomic_read(&scr_info->st_enabled) == 0) {
+		logError(1, "%s %s secure touch is already disabled\n", tag, __func__);
+		return OK;
+	}
+
+	atomic_set(&scr_info->st_pending_irqs, -1);
+	fts_secure_touch_notify(info);
+	if (block) {
+		if (wait_for_completion_interruptible(&scr_info->st_powerdown) == -ERESTARTSYS) {
+			logError(1, "%s %s SECURE_STOP:st_powerdown be interrupted\n",
+				tag, __func__);
+		} else {
+			logError(1, "%s %s SECURE_STOP:st_powerdown be completed\n", tag, __func__);
+		}
+	}
+	return OK;
+}
+
+static void fts_secure_work(struct fts_secure_info *scr_info)
+{
+	struct fts_ts_info *info = (struct fts_ts_info *)scr_info->fts_info;
+
+
+	fts_secure_touch_notify(info);
+	atomic_set(&scr_info->st_1st_complete, 1);
+	if (wait_for_completion_interruptible(&scr_info->st_irq_processed) == -ERESTARTSYS) {
+		logError(1, "%s %s SECURE_FILTER:st_irq_processed be interrupted\n", tag, __func__);
+	} else {
+		logError(1, "%s %s SECURE_FILTER:st_irq_processed be completed\n", tag, __func__);
+	}
+
+	fts_enableInterrupt();
+	logError(1, "%s %s SECURE_FILTER:enable irq\n", tag, __func__);
+}
+
+static void fts_flush_delay_task(struct fts_secure_info *scr_info)
+{
+	if (scr_info->scr_delay.palm_pending) {
+		scr_info->scr_delay.palm_pending = false;
+	}
+}
+
+static int fts_secure_filter_interrupt(struct fts_ts_info *info)
+{
+	struct fts_secure_info *scr_info = info->secure_info;
+
+	/*inited and enable first*/
+	if (!scr_info->secure_inited || atomic_read(&scr_info->st_enabled) == 0) {
+		return -EPERM;
+	}
+
+	fts_disableInterruptNoSync();
+	logError(1, "%s %s SECURE_FILTER:disable irq\n", tag, __func__);
+	/*check and change irq pending state
+	 *change irq pending here, secure_touch_show, secure_touch_enable_store
+	 *completion st_irq_processed at secure_touch_show, secure_touch_enable_stroe
+	 */
+	logError(1, "%s %s SECURE_FILTER:st_pending_irqs = %d\n",
+		tag, __func__, atomic_read(&scr_info->st_pending_irqs));
+	if (atomic_cmpxchg(&scr_info->st_pending_irqs, 0, 1) == 0) {
+		fts_secure_work(scr_info);
+		logError(1, "%s %s SECURE_FILTER:secure_work return\n", tag, __func__);
+	}
+
+	return 0;
+}
+
+static ssize_t fts_secure_touch_enable_show (struct device *dev,
+										struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	struct fts_secure_info *scr_info = info->secure_info;
+
+	logError(1, "%s %s SECURE_TOUCH_ENABLE[R]:st_enabled = %d\n", tag, __func__, atomic_read(&scr_info->st_enabled));
+	return scnprintf(buf, PAGE_SIZE, "%d", atomic_read(&scr_info->st_enabled));
+}
+
+/* 	echo 0 > secure_touch_enable to disable secure touch
+ * 	echo 1 > secure_touch_enable to enable secure touch
+ */
+static ssize_t fts_secure_touch_enable_store (struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	unsigned long value;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	struct fts_secure_info *scr_info = info->secure_info;
+
+	atomic_set(&scr_info->st_1st_complete, 0);
+	logError(1, "%s %s SECURE_TOUCH_ENABLE[W]:st_1st_complete=0\n", tag, __func__);
+	logError(1, "%s %s SECURE_TOUCH_ENABLE[W]:parse parameter\n", tag, __func__);
+	/*check and get cmd*/
+	if (count > 2)
+		return -EINVAL;
+	ret = kstrtoul(buf, 10, &value);
+	if (ret != 0)
+		return ret;
+
+	if (!scr_info->secure_inited)
+		return -EIO;
+
+	ret = count;
+
+	logError(1, "%s %s SECURE_TOUCH_ENABLE[W]:st_enabled = %d\n", tag, __func__, value);
+	switch (value) {
+	case 0:
+		if (atomic_read(&scr_info->st_enabled) == 0) {
+			logError(1, "%s %s secure touch is already disabled\n",
+				tag, __func__);
+			return ret;
+		}
+		mutex_lock(&scr_info->palm_lock);
+		atomic_set(&scr_info->st_enabled, 0);
+		fts_secure_touch_notify(info);
+		complete(&scr_info->st_irq_processed);
+		fts_event_handler(info->client->irq, info);
+		complete(&scr_info->st_powerdown);
+		fts_flush_delay_task(scr_info);
+		mutex_unlock(&scr_info->palm_lock);
+		logError(1, "%s %s SECURE_TOUCH_ENABLE[W]:disable secure touch successful\n",
+			tag, __func__);
+	break;
+	case 1:
+		if (atomic_read(&scr_info->st_enabled) == 1) {
+			logError(1, "%s %s secure touch is already enabled\n",
+				tag, __func__);
+			return ret;
+		}
+		mutex_lock(&scr_info->palm_lock);
+		/*wait until finish process all normal irq*/
+		synchronize_irq(info->client->irq);
+
+		/*enable secure touch*/
+		reinit_completion(&scr_info->st_powerdown);
+		reinit_completion(&scr_info->st_irq_processed);
+		atomic_set(&scr_info->st_pending_irqs, 0);
+		atomic_set(&scr_info->st_enabled, 1);
+		mutex_unlock(&scr_info->palm_lock);
+		logError(1, "%s %s SECURE_TOUCH_ENABLE[W]:enable secure touch successful\n",
+			tag, __func__);
+	break;
+	default:
+		logError(1, "%s %s %d in secure_touch_enable is not support\n",
+			tag, __func__, value);
+	break;
+	}
+	return ret;
+}
+
+static ssize_t fts_secure_touch_show (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	struct fts_secure_info *scr_info = info->secure_info;
+	int value = 0;
+
+	logError(1, "%s %s SECURE_TOUCH[R]:st_1st_complete = %d\n",
+		tag, __func__, atomic_read(&scr_info->st_1st_complete));
+	logError(1, "%s %s SECURE_TOUCH[R]:st_pending_irqs = %d\n",
+		tag, __func__, atomic_read(&scr_info->st_pending_irqs));
+
+	if (atomic_read(&scr_info->st_enabled) == 0) {
+		return -EBADF;
+	}
+
+	if (atomic_cmpxchg(&scr_info->st_pending_irqs, -1, 0) == -1)
+		return -EINVAL;
+
+	if (atomic_cmpxchg(&scr_info->st_pending_irqs, 1, 0) == 1) {
+		value = 1;
+	} else if (atomic_cmpxchg(&scr_info->st_1st_complete, 1, 0) == 1) {
+		complete(&scr_info->st_irq_processed);
+		logError(1, "%s %s SECURE_TOUCH[R]:comlpetion st_irq_processed\n", tag, __func__);
+	}
+	return scnprintf(buf, PAGE_SIZE, "%d", value);
+}
+#endif
+
+static ssize_t fts_wake_gesture_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	unsigned int input = 0;
+	static const char *fts_gesture_on = "01 20";
+	static const char *fts_gesture_off = "00 20";
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	char *gesture_result;
+	int size = 6 * 2 + 1;
+	if (sscanf(buf, "%u", &input) != 1)
+		return -EINVAL;
+
+	if (input == 1) {
+		gesture_result = (u8 *) kzalloc(size, GFP_KERNEL);
+		fts_gesture_mask_store(info->dev, NULL,
+				fts_gesture_on, strlen(fts_gesture_on));
+		fts_gesture_mask_show(info->dev, NULL,
+				gesture_result);
+	} else {
+		gesture_result = (u8 *) kzalloc(size, GFP_KERNEL);
+		fts_gesture_mask_store(info->dev, NULL,
+				fts_gesture_off, strlen(fts_gesture_off));
+		fts_gesture_mask_show(info->dev, NULL,
+				gesture_result);
+	}
+
+	if (strncmp("{ 00000000 }", gesture_result, size - 1))
+		logError(1, "%s %s: store gesture mask error\n", tag, __func__);
+
+	kfree(gesture_result);
+	gesture_result = NULL;
+
+	return count;
+}
+
+static DEVICE_ATTR(fts_lockdown, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   fts_lockdown_show, fts_lockdown_store);
+static DEVICE_ATTR(fwupdate, (S_IRUGO | S_IWUSR | S_IWGRP), fts_fwupdate_show,
+		   fts_fwupdate_store);
+static DEVICE_ATTR(panel_vendor, (S_IRUGO), fts_panel_vendor_show, NULL);
+static DEVICE_ATTR(panel_color, (S_IRUGO), fts_panel_color_show, NULL);
+static DEVICE_ATTR(panel_display, (S_IRUGO), fts_panel_display_show, NULL);
+static DEVICE_ATTR(ms_strength, (S_IRUGO), fts_strength_frame_show, NULL);
+static DEVICE_ATTR(lockdown_info, (S_IRUGO), fts_lockdown_info_show, NULL);
+static DEVICE_ATTR(appid, (S_IRUGO), fts_appid_show, NULL);
+static DEVICE_ATTR(mode_active, (S_IRUGO), fts_mode_active_show, NULL);
+static DEVICE_ATTR(fw_file_test, (S_IRUGO), fts_fw_test_show, NULL);
+static DEVICE_ATTR(selftest_info, (S_IRUGO), fts_selftest_info_show, NULL);
+// static DEVICE_ATTR(ms_raw, (S_IRUGO), fts_ms_raw_show, NULL);
+// static DEVICE_ATTR(ss_raw, (S_IRUGO), fts_ss_raw_show, NULL);
+// static DEVICE_ATTR(ms_cx_total, (S_IRUGO), fts_ms_cx_total_show, NULL);
+//static DEVICE_ATTR(ss_ix_total, (S_IRUGO), fts_ss_ix_total_show, NULL);
+// static DEVICE_ATTR(ss_hover, (S_IRUGO), fts_hover_raw_show, NULL);
+static DEVICE_ATTR(stm_fts_cmd, (S_IRUGO | S_IWUSR | S_IWGRP), stm_fts_cmd_show,
+		   stm_fts_cmd_store);
+#ifdef USE_ONE_FILE_NODE
+static DEVICE_ATTR(feature_enable, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   fts_feature_enable_show, fts_feature_enable_store);
+#else
+
+#ifdef GRIP_MODE
+static DEVICE_ATTR(grip_mode, (S_IRUGO | S_IWUSR | S_IWGRP), fts_grip_mode_show,
+		   fts_grip_mode_store);
+#endif
+
+#ifdef CHARGER_MODE
+static DEVICE_ATTR(charger_mode, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   fts_charger_mode_show, fts_charger_mode_store);
+#endif
+
+#ifdef GLOVE_MODE
+static DEVICE_ATTR(glove_mode, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   fts_glove_mode_show, fts_glove_mode_store);
+#endif
+
+#ifdef COVER_MODE
+static DEVICE_ATTR(cover_mode, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   fts_cover_mode_show, fts_cover_mode_store);
+#endif
+
+#ifdef STYLUS_MODE
+static DEVICE_ATTR(stylus_mode, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   fts_stylus_mode_show, fts_stylus_mode_store);
+#endif
+
+#endif
+
+#ifdef GESTURE_MODE
+static DEVICE_ATTR(gesture_mask, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   fts_gesture_mask_show, fts_gesture_mask_store);
+static DEVICE_ATTR(gesture_coordinates, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   fts_gesture_coordinates_show, NULL);
+#endif
+static DEVICE_ATTR(doze_time, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   fts_doze_time_show, fts_doze_time_store);
+static DEVICE_ATTR(grip_enable, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   fts_grip_enable_show, fts_grip_enable_store);
+static DEVICE_ATTR(grip_area, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   fts_grip_area_show, fts_grip_area_store);
+
+static DEVICE_ATTR(hover_tune, (S_IRUGO | S_IWUSR | S_IWGRP), NULL, fts_hover_autotune_store);
+
+static DEVICE_ATTR(wake_gesture, (S_IRUGO | S_IWUSR),
+		   fts_gesture_mask_show, fts_wake_gesture_store);
+
+static struct attribute *fts_attr_group[] = {
+	&dev_attr_fwupdate.attr,
+	&dev_attr_appid.attr,
+	&dev_attr_mode_active.attr,
+	&dev_attr_fw_file_test.attr,
+	&dev_attr_stm_fts_cmd.attr,
+#ifdef USE_ONE_FILE_NODE
+	&dev_attr_feature_enable.attr,
+#else
+
+#ifdef GRIP_MODE
+	&dev_attr_grip_mode.attr,
+#endif
+#ifdef CHARGER_MODE
+	&dev_attr_charger_mode.attr,
+#endif
+#ifdef GLOVE_MODE
+	&dev_attr_glove_mode.attr,
+#endif
+#ifdef COVER_MODE
+	&dev_attr_cover_mode.attr,
+#endif
+#ifdef STYLUS_MODE
+	&dev_attr_stylus_mode.attr,
+#endif
+#endif
+	&dev_attr_fts_lockdown.attr,
+	&dev_attr_panel_vendor.attr,
+	&dev_attr_panel_color.attr,
+	&dev_attr_panel_display.attr,
+	&dev_attr_lockdown_info.attr,
+#ifdef GESTURE_MODE
+	&dev_attr_gesture_mask.attr,
+	&dev_attr_gesture_coordinates.attr,
+#endif
+	&dev_attr_selftest_info.attr,
+//	&dev_attr_ms_raw.attr,
+//	&dev_attr_ss_raw.attr,
+//	&dev_attr_ms_cx_total.attr,
+//	&dev_attr_ss_ix_total.attr,
+	&dev_attr_ms_strength.attr,
+//	&dev_attr_ss_hover.attr,
+	&dev_attr_hover_tune.attr,
+	&dev_attr_doze_time.attr,
+	&dev_attr_grip_enable.attr,
+	&dev_attr_grip_area.attr,
+	&dev_attr_wake_gesture.attr,
+	NULL,
+};
+
+#ifdef CONFIG_FTS_TOUCH_COUNT_DUMP
+static DEVICE_ATTR(touch_suspend_notify, (S_IRUGO | S_IRGRP),
+		   fts_touch_suspend_notify_show, NULL);
+#endif
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+static DEVICE_ATTR(fod_status, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   fts_fod_status_show, fts_fod_status_store);
+
+static DEVICE_ATTR(fod_test, (S_IRUGO | S_IWUSR | S_IWGRP), NULL, fts_fod_test_store);
+#endif
+
+#ifdef CONFIG_SECURE_TOUCH
+DEVICE_ATTR(secure_touch_enable, (S_IRUGO | S_IWUSR | S_IWGRP), fts_secure_touch_enable_show,  fts_secure_touch_enable_store);
+DEVICE_ATTR(secure_touch, (S_IRUGO | S_IWUSR | S_IWGRP), fts_secure_touch_show,  NULL);
+#endif
+/**@}*/
+/**@}*/
+
+/**
+ * @defgroup isr Interrupt Service Routine (Event Handler)
+ * The most important part of the driver is the ISR (Interrupt Service Routine) called also as Event Handler \n
+ * As soon as the interrupt pin goes low, fts_interrupt_handler() is called and the chain to read and parse the event read from the FIFO start.\n
+ * For any different kind of EVT_ID there is a specific event handler which will take the correct action to report the proper info to the host. \n
+ * The most important events are the one related to touch informations, status update or user report.
+ * @{
+ */
+
+/**
+ * Report to the linux input system the pressure and release of a button handling concurrency
+ * @param info pointer to fts_ts_info which contains info about the device and its hw setup
+ * @param key_code	button value
+ */
+static void fts_input_report_key(struct fts_ts_info *info, int key_code)
+{
+	mutex_lock(&info->input_report_mutex);
+	input_report_key(info->input_dev, key_code, 1);
+	input_sync(info->input_dev);
+	input_report_key(info->input_dev, key_code, 0);
+	input_sync(info->input_dev);
+	mutex_unlock(&info->input_report_mutex);
+}
+
+/**
+* Event Handler for no events (EVT_ID_NOEVENT)
+*/
+static void fts_nop_event_handler(struct fts_ts_info *info,
+				  unsigned char *event)
+{
+	logError(1,
+		 "%s %s Doing nothing for event = %02X %02X %02X %02X %02X %02X %02X %02X\n",
+		 tag, __func__, event[0], event[1], event[2], event[3],
+		 event[4], event[5], event[6], event[7]);
+}
+
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+static bool fts_is_in_fodarea(int x, int y)
+{
+	if ((x > FOD_LX && x < FOD_LX + FOD_SIDE) && (y > FOD_LY && y < FOD_LY +
+	FOD_SIDE))
+		return true;
+	else
+		return false;
+}
+
+static bool finger_report_flag;
+
+#endif
+/**
+* Event handler for enter and motion events (EVT_ID_ENTER_POINT, EVT_ID_MOTION_POINT )
+* report to the linux input system touches with their coordinated and additional informations
+*/
+static void fts_enter_pointer_event_handler(struct fts_ts_info *info,
+					    unsigned char *event)
+{
+	unsigned char touchId;
+	unsigned int touch_condition = 1, tool = MT_TOOL_FINGER;
+	int x, y, z, distance;
+	u8 touchType;
+	int area_size;
+#ifndef CONFIG_FTS_FOD_AREA_REPORT
+	if (!info->resume_bit)
+		goto no_report;
+#endif
+	if (info->sensor_sleep) {
+		logError(1, "%s %s sensor sleep, skip touch down event\n", tag, __func__);
+		return;
+	}
+	touchType = event[1] & 0x0F;
+	touchId = (event[1] & 0xF0) >> 4;
+
+	x = (((int)event[3] & 0x0F) << 8) | (event[2]);
+	y = ((int)event[4] << 4) | ((event[3] & 0xF0) >> 4);
+
+	z = 1;
+	distance = 0;
+
+	if (event[0] == EVT_ID_MOTION_POINT) {
+		area_size = (event[5] << 8) | event[6];
+	} else {
+		area_size = 1;
+	}
+
+	if (x >= info->board->x_max)
+		x = info->board->x_max;
+
+	if (y >= info->board->y_max)
+		y = info->board->y_max;
+
+	input_mt_slot(info->input_dev, touchId);
+	switch (touchType) {
+
+#ifdef STYLUS_MODE
+	case TOUCH_TYPE_STYLUS:
+		logError(0, "%s  %s : It is a stylus!\n", tag, __func__);
+		if (info->stylus_enabled == 1) {
+			tool = MT_TOOL_PEN;
+			touch_condition = 1;
+			__set_bit(touchId, &info->stylus_id);
+			break;
+		}
+#endif
+	case TOUCH_TYPE_FINGER:
+		/*logError(0, "%s  %s : It is a finger!\n",tag,__func__); */
+	case TOUCH_TYPE_GLOVE:
+		/*logError(0, "%s  %s : It is a glove!\n",tag,__func__); */
+	case TOUCH_TYPE_PALM:
+		/*logError(0, "%s  %s : It is a palm!\n",tag,__func__); */
+		tool = MT_TOOL_FINGER;
+		touch_condition = 1;
+		__set_bit(touchId, &info->touch_id);
+		break;
+
+	case TOUCH_TYPE_HOVER:
+		tool = MT_TOOL_FINGER;
+		touch_condition = 0;
+		z = 0;
+		__set_bit(touchId, &info->touch_id);
+		distance = DISTANCE_MAX;
+		break;
+
+	case TOUCH_TYPE_INVALID:
+	default:
+		logError(1, "%s  %s : Invalid touch type = %d ! No Report...\n",
+			 tag, __func__, touchType);
+#ifndef CONFIG_FTS_FOD_AREA_REPORT
+		goto no_report;
+#endif
+
+	}
+
+	input_mt_report_slot_state(info->input_dev, tool, 1);
+	input_report_key(info->input_dev, BTN_TOUCH, touch_condition);
+	if (touch_condition)
+		input_report_key(info->input_dev, BTN_TOOL_FINGER, 1);
+
+	/*input_report_abs(info->input_dev, ABS_MT_TRACKING_ID, touchId); */
+		input_report_abs(info->input_dev, ABS_MT_POSITION_X, x);
+		input_report_abs(info->input_dev, ABS_MT_POSITION_Y, y);
+		input_report_abs(info->input_dev, ABS_MT_TOUCH_MINOR, z);
+		input_report_abs(info->input_dev, ABS_MT_DISTANCE, distance);
+		input_report_abs(info->input_dev, ABS_MT_TOUCH_MAJOR, area_size);
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+		if (fts_is_in_fodarea(x, y) && !(info->fod_id & ~(1 << touchId))) {
+			__set_bit(touchId, &info->sleep_finger);
+			if (info->fod_status) {
+				info->fod_x = x;
+				info->fod_y = y;
+				info->fod_coordinate_update = true;
+				__set_bit(touchId, &info->fod_id);
+				input_report_abs(info->input_dev, ABS_MT_WIDTH_MINOR, info->fod_overlap);
+				input_report_key(info->input_dev, BTN_INFO, 1);
+				input_report_key(info->input_dev, KEY_INFO, 1);
+				logError(1,	"%s  %s :  FOD Press :%d, fod_id:%08x\n", tag, __func__,
+				touchId, info->fod_id);
+			}
+		} else if (__test_and_clear_bit(touchId, &info->fod_id)) {
+			input_report_abs(info->input_dev, ABS_MT_WIDTH_MINOR, 0);
+			input_report_key(info->input_dev, BTN_INFO, 0);
+			input_report_key(info->input_dev, KEY_INFO, 0);
+			info->fod_coordinate_update = false;
+			info->fod_overlap = 0;
+			logError(1, "%s  %s :  FOD Release :%d\n", tag, __func__,
+					touchId);
+			__clear_bit(touchId, &info->sleep_finger);
+		}
+#endif
+		input_sync(info->input_dev);
+	dev_dbg(info->dev,
+		"%s  %s :  Event 0x%02x - ID[%d], (x, y, z) = (%3d, %3d, %3d) type = %d, size = %d, overlap:%d\n",
+		tag, __func__, *event, touchId, x, y, z, touchType, area_size,
+		info->fod_overlap);
+
+#ifndef CONFIG_FTS_FOD_AREA_REPORT
+no_report:
+	return;
+#endif
+}
+
+/**
+* Event handler for leave event (EVT_ID_LEAVE_POINT )
+* Report to the linux input system that one touch left the display
+*/
+static void fts_leave_pointer_event_handler(struct fts_ts_info *info,
+					    unsigned char *event)
+{
+	unsigned char touchId = 0;
+	unsigned int tool = MT_TOOL_FINGER;
+	unsigned int touch_condition = 0;
+	u8 touchType;
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	int x, y;
+	bool fod_up = false;
+#endif
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	if (event[1] == 0xb5) {
+		touchType = TOUCH_TYPE_FINGER;
+		info->sleep_finger = 0;
+		if (!info->fod_id) {
+			logError(1, "%s  %s :  FOD Release without FOD press\n", tag, __func__);
+			goto exit;
+		}
+		if (info->touch_id) {
+			logError(1, "%s  %s :  FOD Release in active mode\n", tag, __func__);
+			goto exit;
+		}
+		touchId = ffs(info->fod_id) - 1;
+		info->fod_overlap = 0;
+
+		logError(1,	"%s  %s :  FOD Release :%d, fod_id:%08x\n", tag, __func__,
+			touchId, info->fod_id);
+
+
+		__clear_bit(touchId, &info->fod_id);
+		fod_up = true;
+
+	} else {
+#endif
+		touchType = event[1] & 0x0F;
+		touchId = (event[1] & 0xF0) >> 4;
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	}
+	x = (event[2] << 4) | (event[4] & 0xF0) >> 4;
+	y = (event[3] << 4) | (event[4] & 0x0F);
+#endif
+	input_mt_slot(info->input_dev, touchId);
+	switch (touchType) {
+
+#ifdef STYLUS_MODE
+	case TOUCH_TYPE_STYLUS:
+		logError(0, "%s  %s : It is a stylus!\n", tag, __func__);
+		if (info->stylus_enabled == 1) {
+			tool = MT_TOOL_PEN;
+			__clear_bit(touchId, &info->stylus_id);
+			break;
+		}
+#endif
+
+	case TOUCH_TYPE_FINGER:
+		/*logError(0, "%s  %s : It is a finger!\n",tag,__func__); */
+	case TOUCH_TYPE_GLOVE:
+		/*logError(0, "%s  %s : It is a glove!\n",tag,__func__); */
+	case TOUCH_TYPE_PALM:
+		/*logError(0, "%s  %s : It is a palm!\n",tag,__func__); */
+		tool = MT_TOOL_FINGER;
+		touch_condition = 0;
+		__clear_bit(touchId, &info->touch_id);
+		break;
+	case TOUCH_TYPE_HOVER:
+		tool = MT_TOOL_FINGER;
+		touch_condition = 1;
+		__clear_bit(touchId, &info->touch_id);
+		break;
+
+	case TOUCH_TYPE_INVALID:
+	default:
+		logError(1, "%s  %s : Invalid touch type = %d ! No Report...\n",
+			 tag, __func__, touchType);
+		return;
+
+	}
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	__clear_bit(touchId, &info->sleep_finger);
+	if (__test_and_clear_bit(touchId, &info->fod_id)) {
+			input_report_abs(info->input_dev, ABS_MT_WIDTH_MINOR, 0);
+			input_report_key(info->input_dev, BTN_INFO, 0);
+			input_report_key(info->input_dev, KEY_INFO, 0);
+			info->fod_coordinate_update = false;
+	}
+#endif
+	input_mt_report_slot_state(info->input_dev, tool, 0);
+	if (info->touch_id == 0) {
+		input_report_key(info->input_dev, BTN_TOUCH, touch_condition);
+		if (!touch_condition)
+			input_report_key(info->input_dev, BTN_TOOL_FINGER, 0);
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+		info->fod_pressed = false;
+		info->fod_overlap = 0;
+		input_report_key(info->input_dev, BTN_INFO, 0);
+		input_report_key(info->input_dev, KEY_INFO, 0);
+		finger_report_flag = false;
+#endif
+
+		info->touch_skip = 0;
+		info->sleep_finger = 0;
+		info->fod_id = 0;
+	}
+	input_report_abs(info->input_dev, ABS_MT_TRACKING_ID, -1);
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	if (fod_up)
+		logError(1,
+			"%s  %s :  Event FOD - release ID[%d] type = %d\n", tag,
+			__func__, touchId, touchType);
+	else
+#endif
+
+	input_sync(info->input_dev);
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+exit:
+#endif
+	return;
+}
+
+/* EventId : EVT_ID_MOTION_POINT */
+#define fts_motion_pointer_event_handler fts_enter_pointer_event_handler
+
+/**
+* Event handler for error events (EVT_ID_ERROR)
+* Handle unexpected error events implementing recovery strategy and restoring the sensing status that the IC had before the error occured
+*/
+static void fts_error_event_handler(struct fts_ts_info *info,
+				    unsigned char *event)
+{
+	int error = 0;
+	logError(1,
+		 "%s %s Received event %02X %02X %02X %02X %02X %02X %02X %02X\n",
+		 tag, __func__, event[0], event[1], event[2], event[3],
+		 event[4], event[5], event[6], event[7]);
+
+	switch (event[1]) {
+	case EVT_TYPE_ERROR_ESD:
+		{
+			release_all_touches(info);
+
+			fts_chip_powercycle(info);
+
+			error = fts_system_reset();
+			error |= fts_mode_handler(info, 0);
+			error |= fts_enableInterrupt();
+			if (error < OK) {
+				logError(1,
+					 "%s %s Cannot restore the device ERROR %08X\n",
+					 tag, __func__, error);
+			}
+		}
+		break;
+	case EVT_TYPE_ERROR_WATCHDOG:
+		{
+			dumpErrorInfo(NULL, 0);
+			release_all_touches(info);
+			error = fts_system_reset();
+			error |= fts_mode_handler(info, 0);
+			error |= fts_enableInterrupt();
+			if (error < OK) {
+				logError(1,
+					 "%s %s Cannot reset the device ERROR %08X\n",
+					 tag, __func__, error);
+			}
+		}
+		break;
+
+	}
+}
+
+/**
+* Event handler for controller ready event (EVT_ID_CONTROLLER_READY)
+* Handle controller events received after unexpected reset of the IC updating the resets flag and restoring the proper sensing status
+*/
+static void fts_controller_ready_event_handler(struct fts_ts_info *info,
+					       unsigned char *event)
+{
+	int error;
+	logError(1,
+		 "%s %s Received event %02X %02X %02X %02X %02X %02X %02X %02X\n",
+		 tag, __func__, event[0], event[1], event[2], event[3],
+		 event[4], event[5], event[6], event[7]);
+	release_all_touches(info);
+	setSystemResetedUp(1);
+	setSystemResetedDown(1);
+	error = fts_mode_handler(info, 0);
+	if (error < OK) {
+		logError(1,
+			 "%s %s Cannot restore the device status ERROR %08X\n",
+			 tag, __func__, error);
+	}
+}
+
+/**
+* Event handler for status events (EVT_ID_STATUS_UPDATE)
+* Handle status update events
+*/
+static void fts_status_event_handler(struct fts_ts_info *info,
+				     unsigned char *event)
+{
+	switch (event[1]) {
+
+	case EVT_TYPE_STATUS_ECHO:
+		logError(0,
+			 "%s %s Echo event of command = %02X %02X %02X %02X %02X %02X\n",
+			 tag, __func__, event[2], event[3], event[4], event[5],
+			 event[6], event[7]);
+		break;
+
+	case EVT_TYPE_STATUS_FORCE_CAL:
+		switch (event[2]) {
+		case 0x00:
+			logError(1,
+				 "%s %s Continuous frame drop Force cal = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		case 0x01:
+			logError(1,
+				 "%s %s Mutual negative detect Force cal = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		case 0x02:
+			logError(1,
+				 "%s %s Mutual calib deviation Force cal = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		case 0x11:
+			logError(1,
+				 "%s %s SS negative detect Force cal = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		case 0x12:
+			logError(1,
+				 "%s %s SS negative detect Force cal in Low Power mode = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		case 0x13:
+			logError(1,
+				 "%s %s SS negative detect Force cal in Idle mode = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		case 0x20:
+			logError(1,
+				 "%s %s SS invalid Mutual Strength soft Force cal = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		case 0x21:
+			logError(1,
+				 "%s %s SS invalid Self Strength soft Force cal = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		case 0x22:
+			logError(1,
+				 "%s %s SS invalid Self Island soft Force cal = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		case 0x30:
+			logError(1,
+				 "%s %s MS invalid Mutual Strength soft Force cal = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		case 0x31:
+			logError(1,
+				 "%s %s MS invalid Self Strength soft Force cal = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		default:
+			logError(1,
+				 "%s %s Force cal = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+
+		}
+		break;
+
+	case EVT_TYPE_STATUS_FRAME_DROP:
+		switch (event[2]) {
+		case 0x01:
+			logError(1,
+				 "%s %s Frame drop noisy frame = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		case 0x02:
+			logError(1,
+				 "%s %s Frame drop bad R = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		case 0x03:
+			logError(1,
+				 "%s %s Frame drop invalid processing state = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+			break;
+
+		default:
+			logError(1,
+				 "%s %s Frame drop = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+
+		}
+		break;
+
+	case EVT_TYPE_STATUS_SS_RAW_SAT:
+		if (event[2] == 1)
+			logError(1,
+				 "%s %s SS Raw Saturated = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+		else
+			logError(1,
+				 "%s %s SS Raw No more Saturated = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+		break;
+
+	case EVT_TYPE_STATUS_WATER:
+		if (event[2] == 1)
+			logError(1,
+				 "%s %s Enter Water mode = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+		else
+			logError(1,
+				 "%s %s Exit Water mode = %02X %02X %02X %02X %02X %02X\n",
+				 tag, __func__, event[2], event[3], event[4],
+				 event[5], event[6], event[7]);
+		break;
+	default:
+		logError(1,
+			 "%s %s Received unhandled status event = %02X %02X %02X %02X %02X %02X %02X %02X\n",
+			 tag, __func__, event[0], event[1], event[2], event[3],
+			 event[4], event[5], event[6], event[7]);
+		break;
+	}
+
+}
+
+#ifdef PHONE_KEY
+/**
+ * Event handler for status events (EVT_TYPE_USER_KEY)
+ * Handle keys update events, the third byte of the event is a bitmask where if the bit set means that the corresponding key is pressed.
+ */
+static void fts_key_event_handler(struct fts_ts_info *info,
+				  unsigned char *event)
+{
+
+	logError(0,
+		 "%s %s Received event %02X %02X %02X %02X %02X %02X %02X %02X\n",
+		 tag, __func__, event[0], event[1], event[2], event[3],
+		 event[4], event[5], event[6], event[7]);
+
+	if (event[0] == EVT_ID_USER_REPORT && event[1] == EVT_TYPE_USER_KEY) {
+
+		if ((event[2] & FTS_KEY_0) == 0 && (key_mask & FTS_KEY_0) > 0) {
+			logError(0,
+				 "%s %s: Button HOME pressed and released! \n",
+				 tag, __func__);
+			fts_input_report_key(info, KEY_HOMEPAGE);
+		}
+
+		if ((event[2] & FTS_KEY_1) == 0 && (key_mask & FTS_KEY_1) > 0) {
+			logError(0,
+				 "%s %s: Button Back pressed and released! \n",
+				 tag, __func__);
+			fts_input_report_key(info, KEY_BACK);
+		}
+
+		if ((event[2] & FTS_KEY_2) == 0 && (key_mask & FTS_KEY_2) > 0) {
+			logError(0, "%s %s: Button Menu pressed! \n", tag,
+				 __func__);
+			fts_input_report_key(info, KEY_MENU);
+		}
+
+		key_mask = event[2];
+	} else {
+		logError(1, "%s %s: Invalid event passed as argument! \n", tag,
+			 __func__);
+	}
+
+}
+#endif
+
+#ifdef GESTURE_MODE
+/**
+ * Event handler for gesture events (EVT_TYPE_USER_GESTURE)
+ * Handle gesture events and simulate the click on a different button for any gesture detected (@link gesture_opt Gesture IDs @endlink)
+ */
+static void fts_gesture_event_handler(struct fts_ts_info *info,
+				      unsigned char *event)
+{
+	int value;
+	int needCoords = 0;
+	char ch[64] = { 0x0, };
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	int touch_area;
+	int fod_overlap;
+	int fod_id = 0;
+	int x = (event[4] << 8) | (event[3]);
+	int y = (event[6] << 8) | (event[5]);
+#endif
+
+	logError(1,
+		 "%s  gesture event data: %02X %02X %02X %02X %02X %02X %02X %02X\n",
+		 tag, event[0], event[1], event[2], event[3], event[4],
+		 event[5], event[6], event[7]);
+	if (event[0] == EVT_ID_USER_REPORT && event[1] == EVT_TYPE_USER_GESTURE) {
+		needCoords = 1;
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+		if (event[2] == GEST_ID_LONG_PRESS && info->fod_status) {
+			touch_area = (event[9] << 8) | (event[8]);
+			fod_overlap = (event[11] << 8) | (event[10]);
+			if ((!info->sensor_sleep && info->fod_coordinate_update &&
+			info->fod_id && fts_is_in_fodarea(info->fod_x, info->fod_y)) ||
+				(info->sensor_sleep && fts_is_in_fodarea(x, y))) {
+				if (!finger_report_flag) {
+					logError(1, "%s  %s finger down in the fod area\n", tag, __func__);
+					finger_report_flag = true;
+				}
+				info->fod_overlap = fod_overlap;
+
+				if ((info->sensor_sleep && !info->sleep_finger) || !info->sensor_sleep) {
+					info->fod_pressed = true;
+					input_report_key(info->input_dev, BTN_INFO, 1);
+					input_report_key(info->input_dev, KEY_INFO, 1);
+					input_sync(info->input_dev);
+					if (info->fod_id) {
+						fod_id = ffs(info->fod_id) - 1;
+						if (info->fod_id & ~(1 << fod_id))
+							logError(1, "%s  %s multi fingers on fod area:%08x\n", tag,
+							__func__, info->fod_id);
+					} else if (info->sensor_sleep) {
+						__set_bit(0, &info->fod_id);
+					}
+
+					if (info->fod_coordinate_update || info->sensor_sleep) {
+						input_mt_slot(info->input_dev, fod_id);
+						input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 1);
+						input_report_key(info->input_dev, BTN_TOUCH, 1);
+						input_report_key(info->input_dev, BTN_TOOL_FINGER, 1);
+						if (info->sensor_sleep) {
+							input_report_abs(info->input_dev, ABS_MT_POSITION_X, x);
+							input_report_abs(info->input_dev, ABS_MT_POSITION_Y, y);
+						} else {
+							input_report_abs(info->input_dev, ABS_MT_POSITION_X, info->fod_x);
+							input_report_abs(info->input_dev, ABS_MT_POSITION_Y, info->fod_y);
+							info->fod_coordinate_update = false;
+						}
+						input_report_abs(info->input_dev, ABS_MT_WIDTH_MAJOR, touch_area);
+						input_report_abs(info->input_dev, ABS_MT_WIDTH_MINOR, fod_overlap);
+						logError(1, "%s %s id:%d, fod_id:%08x, touch_area:%d, overlap:%d,fod report\n",
+										tag, __func__, fod_id, info->fod_id, touch_area, fod_overlap);
+					}
+					input_sync(info->input_dev);
+				}
+			}
+				goto gesture_done;
+		} else if (event[2] == GEST_ID_SINGTAP && info->fod_status) {
+			input_report_key(info->input_dev, KEY_GOTO, 1);
+			input_sync(info->input_dev);
+			input_report_key(info->input_dev, KEY_GOTO, 0);
+			input_sync(info->input_dev);
+			info->sleep_finger = 0;
+			info->fod_overlap = 0;
+			info->fod_pressed = false;
+			goto gesture_done;
+		}
+#endif
+		switch (event[2]) {
+		case GEST_ID_DBLTAP:
+			if (!info->gesture_enabled)
+				goto gesture_done;
+			value = KEY_WAKEUP;
+			logError(0, "%s %s: double tap ! \n", tag, __func__);
+			info->dbclick_count++;
+			snprintf(ch, sizeof(ch), "%d", info->dbclick_count);
+			needCoords = 0;
+			break;
+
+		case GEST_ID_AT:
+			value = KEY_WWW;
+			logError(0, "%s %s: @ ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_C:
+			value = KEY_C;
+			logError(0, "%s %s: C ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_E:
+			value = KEY_E;
+			logError(0, "%s %s: e ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_F:
+			value = KEY_F;
+			logError(0, "%s %s: F ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_L:
+			value = KEY_L;
+			logError(0, "%s %s: L ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_M:
+			value = KEY_M;
+			logError(0, "%s %s: M ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_O:
+			value = KEY_O;
+			logError(0, "%s %s: O ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_S:
+			value = KEY_S;
+			logError(0, "%s %s: S ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_V:
+			value = KEY_V;
+			logError(0, "%s %s:  V ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_W:
+			value = KEY_W;
+			logError(0, "%s %s:  W ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_Z:
+			value = KEY_Z;
+			logError(0, "%s %s:  Z ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_RIGHT_1F:
+			value = KEY_RIGHT;
+			logError(0, "%s %s:  -> ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_LEFT_1F:
+			value = KEY_LEFT;
+			logError(0, "%s %s:  <- ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_UP_1F:
+			value = KEY_UP;
+			logError(0, "%s %s:  UP ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_DOWN_1F:
+			value = KEY_DOWN;
+			logError(0, "%s %s:  DOWN ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_CARET:
+			value = KEY_APOSTROPHE;
+			logError(0, "%s %s:  ^ ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_LEFTBRACE:
+			value = KEY_LEFTBRACE;
+			logError(0, "%s %s:  < ! \n", tag, __func__);
+			break;
+
+		case GEST_ID_RIGHTBRACE:
+			value = KEY_RIGHTBRACE;
+			logError(0, "%s %s:  > ! \n", tag, __func__);
+			break;
+
+		default:
+			logError(0, "%s %s:  No valid GestureID! \n", tag,
+				 __func__);
+			goto gesture_done;
+
+		}
+
+		if (needCoords == 1)
+			readGestureCoords(event);
+
+		fts_input_report_key(info, value);
+
+gesture_done:
+		return;
+	} else {
+		logError(1, "%s %s: Invalid event passed as argument! \n", tag,
+			 __func__);
+	}
+
+}
+#endif
+
+/**
+ * Event handler for user report events (EVT_ID_USER_REPORT)
+ * Handle user events reported by the FW due to some interaction triggered by an external user (press keys, perform gestures, etc.)
+ */
+static void fts_user_report_event_handler(struct fts_ts_info *info,
+					  unsigned char *event)
+{
+
+	switch (event[1]) {
+
+#ifdef PHONE_KEY
+	case EVT_TYPE_USER_KEY:
+		fts_key_event_handler(info, event);
+		break;
+#endif
+
+	case EVT_TYPE_USER_PROXIMITY:
+		if (event[2] == 0) {
+			logError(1, "%s %s No proximity!\n", tag, __func__);
+		} else {
+			logError(1, "%s %s Proximity Detected!\n", tag,
+				 __func__);
+		}
+		break;
+
+#ifdef GESTURE_MODE
+	case EVT_TYPE_USER_GESTURE:
+		fts_gesture_event_handler(info, event);
+		break;
+#endif
+	default:
+		logError(1,
+			 "%s %s Received unhandled user report event = %02X %02X %02X %02X %02X %02X %02X %02X\n",
+			 tag, __func__, event[0], event[1], event[2], event[3],
+			 event[4], event[5], event[6], event[7]);
+		break;
+	}
+
+}
+
+/*
+static void buffDump(unsigned char *buf, unsigned int buflength, char *tag)
+{
+	unsigned char *tmp, *back;
+	unsigned int i;
+	unsigned int to_read;
+	unsigned int remain = buflength;
+	unsigned int chunk = 10;
+
+	logError(1, "%s BUFFDUMP IN:", tag);
+
+	tmp = kmalloc(300, GFP_ATOMIC);
+	if (!tmp) {
+		logError(1, "alloc tmp=%04d byte failed", 300);
+		return;
+	}
+	back = tmp;
+
+	memcpy(tmp, buf, buflength);
+
+	while (remain > 0) {
+		if (remain > chunk) {
+			remain -= chunk;
+			to_read = chunk;
+		} else {
+			to_read = remain;
+			for (i = to_read; i < chunk; i++) {
+				tmp[i] = 0xED;
+			}
+			remain = 0;
+		}
+
+		logError(1, "%s %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x",
+				tag, tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], tmp[9]);
+
+		tmp += to_read;
+	}
+	kfree(back);
+}
+*/
+
+static void fts_ts_sleep_work(struct work_struct *work)
+{
+	struct fts_ts_info *info = container_of(work, struct fts_ts_info, sleep_work);
+	int error = 0, count = 0;
+	unsigned char regAdd = FIFO_CMD_READALL;
+	unsigned char data[FIFO_EVENT_SIZE * FIFO_DEPTH] = {0};
+	unsigned char eventId;
+	const unsigned char EVENTS_REMAINING_POS = 7;
+	const unsigned char EVENTS_REMAINING_MASK = 0x1F;
+	unsigned char events_remaining = 0;
+	unsigned char *evt_data;
+	static char pre_id[3];
+	event_dispatch_handler_t event_handler;
+	int r;
+	fts_disableInterrupt();
+	if (info->tp_pm_suspend) {
+		r = wait_for_completion_timeout(&info->pm_resume_completion, msecs_to_jiffies(500));
+		if (!r) {
+			logError(1, "%s pm_resume_completion timeout, i2c is closed", tag);
+			pm_relax(info->dev);
+			fts_enableInterrupt();
+			return;
+		} else {
+			logError(1, "%s pm_resume_completion be completed, handling irq", tag);
+		}
+	}
+
+	info->irq_status = true;
+	error = fts_writeReadU8UX(regAdd, 0, 0, data, FIFO_EVENT_SIZE,
+				  DUMMY_FIFO);
+	events_remaining = data[EVENTS_REMAINING_POS] & EVENTS_REMAINING_MASK;
+	events_remaining = (events_remaining > FIFO_DEPTH - 1) ?
+				FIFO_DEPTH - 1 : events_remaining;
+
+	/*Drain the rest of the FIFO, up to 31 events*/
+	if (error == OK && events_remaining > 0) {
+		error = fts_writeReadU8UX(regAdd, 0, 0, &data[FIFO_EVENT_SIZE],
+					  FIFO_EVENT_SIZE * events_remaining,
+					  DUMMY_FIFO);
+	}
+	if (error != OK) {
+		logError(1,
+			"Error (%d) while reading from FIFO in fts_event_handler",
+			error);
+	} else {
+		for (count = 0; count < events_remaining + 1; count++) {
+			evt_data = &data[count * FIFO_EVENT_SIZE];
+			if (pre_id[0] == EVT_ID_USER_REPORT &&
+				pre_id[1] == 0x02 &&
+				pre_id[2] == 0x18) {
+				pre_id[0] = 0;
+				pre_id[1] = 0;
+				pre_id[2] = 0;
+				continue;
+			}
+			if (evt_data[0] == EVT_ID_NOEVENT)
+				break;
+			eventId = evt_data[0] >> 4;
+			/*Ensure event ID is within bounds*/
+			if (eventId < NUM_EVT_ID) {
+				event_handler = info->event_dispatch_table[eventId];
+				event_handler(info, (evt_data));
+				pre_id[0] = evt_data[0];
+				pre_id[1] = evt_data[1];
+				pre_id[2] = evt_data[2];
+			}
+		}
+	}
+	input_sync(info->input_dev);
+	info->irq_status = false;
+	pm_relax(info->dev);
+	fts_enableInterrupt();
+	return;
+}
+
+/**
+ * Bottom Half Interrupt Handler function
+ * This handler is called each time there is at least one new event in the FIFO and the interrupt pin of the IC goes low.
+ * It will read all the events from the FIFO and dispatch them to the proper event handler according the event ID
+ */
+static irqreturn_t fts_event_handler(int irq, void *ts_info)
+{
+	struct fts_ts_info *info = ts_info;
+	int error = 0, count = 0;
+	unsigned char regAdd = FIFO_CMD_READALL;
+	unsigned char data[FIFO_EVENT_SIZE * FIFO_DEPTH] = {0};
+	unsigned char eventId;
+	const unsigned char EVENTS_REMAINING_POS = 7;
+	const unsigned char EVENTS_REMAINING_MASK = 0x1F;
+	unsigned char events_remaining = 0;
+	unsigned char *evt_data;
+	static char pre_id[3];
+	event_dispatch_handler_t event_handler;
+
+	if (info->tp_pm_suspend) {
+		logError(1, "%s device in suspend, schedue to work", tag);
+		pm_wakeup_event(info->dev, 0);
+		if (!work_pending(&info->sleep_work)) {
+			pm_stay_awake(info->dev);
+			queue_work(info->irq_wq, &info->sleep_work);
+		}
+		return IRQ_HANDLED;
+	}
+
+#ifdef CONFIG_SECURE_TOUCH
+	if (!fts_secure_filter_interrupt(info)) {
+		return IRQ_HANDLED;
+	}
+#endif
+
+	info->irq_status = true;
+	error = fts_writeReadU8UX(regAdd, 0, 0, data, FIFO_EVENT_SIZE,
+				  DUMMY_FIFO);
+	events_remaining = data[EVENTS_REMAINING_POS] & EVENTS_REMAINING_MASK;
+	events_remaining = (events_remaining > FIFO_DEPTH - 1) ?
+				FIFO_DEPTH - 1 : events_remaining;
+
+	/*Drain the rest of the FIFO, up to 31 events*/
+	if (error == OK && events_remaining > 0) {
+		error = fts_writeReadU8UX(regAdd, 0, 0, &data[FIFO_EVENT_SIZE],
+					  FIFO_EVENT_SIZE * events_remaining,
+					  DUMMY_FIFO);
+	}
+	if (error != OK) {
+		logError(1,
+		    "Error (%d) while reading from FIFO in fts_event_handler",
+		    error);
+	} else {
+		for (count = 0; count < events_remaining + 1; count++) {
+			evt_data = &data[count * FIFO_EVENT_SIZE];
+			if (pre_id[0] == EVT_ID_USER_REPORT	&&
+				pre_id[1] == 0x02 &&
+				pre_id[2] == 0x18) {
+				pre_id[0] = 0;
+				pre_id[1] = 0;
+				pre_id[2] = 0;
+				continue;
+			}
+			if (evt_data[0] == EVT_ID_NOEVENT)
+				break;
+			eventId = evt_data[0] >> 4;
+			/*Ensure event ID is within bounds*/
+			if (eventId < NUM_EVT_ID) {
+				event_handler = info->event_dispatch_table[eventId];
+				event_handler(info, (evt_data));
+				pre_id[0] = evt_data[0];
+				pre_id[1] = evt_data[1];
+				pre_id[2] = evt_data[2];
+			}
+		}
+	}
+	input_sync(info->input_dev);
+	info->irq_status = false;
+	return IRQ_HANDLED;
+}
+
+/**@}*/
+
+static const char *fts_get_config(struct fts_ts_info *info)
+{
+	struct fts_hw_platform_data *pdata = info->board;
+	int i = 0, ret = 0;
+
+	ret = fts_get_lockdown_info(info->lockdown_info, info);
+
+	if (ret < OK) {
+		logError(1, "%s can't read lockdown info", tag);
+		return pdata->default_fw_name;
+	}
+
+	ret |= fts_enableInterrupt();
+
+	for (i = 0; i < pdata->config_array_size; i++) {
+		if (info->lockdown_info[0] == pdata->config_array[i].tp_vendor)
+			break;
+	}
+
+	if (i >= pdata->config_array_size) {
+		logError(1, "%s can't find right config", tag);
+		return pdata->default_fw_name;
+	}
+
+	logError(1, "%s Choose config %d: %s", tag, i,
+		 pdata->config_array[i].fts_cfg_name);
+	pdata->current_index = i;
+#ifdef CONFIG_FTS_TOUCH_COUNT_DUMP
+	if (pdata->dump_click_count) {
+		info->current_clicknum_file =
+		    kzalloc(TOUCH_COUNT_FILE_MAXSIZE, GFP_KERNEL);
+		strlcpy(info->current_clicknum_file,
+			pdata->config_array[i].clicknum_file_name,
+			TOUCH_COUNT_FILE_MAXSIZE);
+	}
+#endif
+	return pdata->config_array[i].fts_cfg_name;
+}
+
+static const char *fts_get_limit(struct fts_ts_info *info)
+{
+	struct fts_hw_platform_data *pdata = info->board;
+	int i = 0, ret = 0;
+
+	ret = fts_get_lockdown_info(info->lockdown_info, info);
+
+	if (ret < OK) {
+		logError(1, "%s can't read lockdown info", tag);
+		return LIMITS_FILE;
+	}
+
+	ret |= fts_enableInterrupt();
+
+	for (i = 0; i < pdata->config_array_size; i++) {
+		if (info->lockdown_info[0] == pdata->config_array[i].tp_vendor)
+			break;
+	}
+
+	if (i >= pdata->config_array_size) {
+		logError(1, "%s can't find right limit", tag);
+		return LIMITS_FILE;
+	}
+
+	logError(1, "%s Choose limit file %d: %s", tag, i,
+		 pdata->config_array[i].fts_limit_name);
+	pdata->current_index = i;
+	return pdata->config_array[i].fts_limit_name;
+}
+
+/**
+*	Implement the fw update and initialization flow of the IC that should be executed at every boot up.
+*	The function perform a fw update of the IC in case of crc error or a new fw version and then understand if the IC need to be re-initialized again.
+*	@return  OK if success or an error code which specify the type of error encountered
+*/
+static int fts_fw_update(struct fts_ts_info *info, const char *fw_name, int force)
+{
+
+	u8 error_to_search[4] = {EVT_TYPE_ERROR_CRC_CX_HEAD, EVT_TYPE_ERROR_CRC_CX,
+		EVT_TYPE_ERROR_CRC_CX_SUB_HEAD, EVT_TYPE_ERROR_CRC_CX_SUB
+	};
+/*
+	int retval = 0;
+	int retval1 = 0;
+*/
+	int ret;
+	int crc_status = 0;
+	int error = 0;
+	int init_type = NO_INIT;
+/*
+#ifdef PRE_SAVED_METHOD
+	int keep_cx = 1;
+#else
+	int keep_cx = 0;
+#endif
+*/
+	logError(1, "%s Fw Auto Update is starting... \n", tag);
+
+	ret = fts_crc_check();
+	if (ret > OK) {
+		logError(1, "%s %s: CRC Error or NO FW!\n", tag, __func__);
+		crc_status = ret;
+	} else {
+		crc_status = 0;
+		logError(1,
+			 "%s %s: NO CRC Error or Impossible to read CRC register! \n",
+			 tag, __func__);
+	}
+
+	if (fw_name == NULL) {
+		fw_name = fts_get_config(info);
+		if (fw_name == NULL)
+			logError(1, "%s not found mached config!", tag);
+	}
+
+	if (fw_name) {
+		/*
+		if (force)
+			retval = flashProcedure(fw_name, 1, keep_cx);
+		else
+			retval = flashProcedure(fw_name, crc_status, keep_cx);
+
+		if ((retval & 0xFF000000) == ERROR_FLASH_PROCEDURE) {
+			logError(1,
+				 "%s %s: firmware update failed and retry! ERROR %08X\n",
+				 tag, __func__, retval);
+			fts_chip_powercycle(info);
+			retval1 = flashProcedure(info->board->default_fw_name, crc_status, keep_cx);
+			if ((retval1 & 0xFF000000) == ERROR_FLASH_PROCEDURE) {
+				logError(1,
+					 "%s %s: firmware update failed again!  ERROR %08X\n",
+					 tag, __func__, retval1);
+				logError(1, "%s Fw Auto Update Failed!\n", tag);
+			}
+		}
+		*/
+	}
+
+	logError(1, "%s %s: Verifying if CX CRC Error...\n", tag, __func__,
+		 ret);
+	ret = fts_system_reset();
+	if (ret >= OK) {
+		ret = pollForErrorType(error_to_search, 4);
+		if (ret < OK) {
+			logError(1, "%s %s: No Cx CRC Error Found! \n", tag,
+				 __func__);
+			logError(1, "%s %s: Verifying if Panel CRC Error... \n",
+				 tag, __func__);
+			error_to_search[0] = EVT_TYPE_ERROR_CRC_PANEL_HEAD;
+			error_to_search[1] = EVT_TYPE_ERROR_CRC_PANEL;
+			ret = pollForErrorType(error_to_search, 2);
+			if (ret < OK) {
+				logError(1,
+					 "%s %s: No Panel CRC Error Found! \n",
+					 tag, __func__);
+				init_type = NO_INIT;
+			} else {
+				logError(1,
+					 "%s %s: Panel CRC Error FOUND! CRC ERROR = %02X\n",
+					 tag, __func__, ret);
+				init_type = SPECIAL_PANEL_INIT;
+			}
+		} else {
+			logError(1,
+				 "%s %s: Cx CRC Error FOUND! CRC ERROR = %02X\n",
+				 tag, __func__, ret);
+
+			logError(1,
+				 "%s %s: Try to recovery with CX in fw file...\n",
+				 tag, __func__, ret);
+			flashProcedure(info->board->default_fw_name, CRC_CX, 0);
+			logError(1, "%s %s: Refresh panel init data... \n", tag,
+				 __func__, ret);
+		}
+	} else {
+		logError(1,
+			 "%s %s: Error while executing system reset! ERROR %08X\n",
+			 tag, __func__, ret);
+	}
+
+	if (init_type == NO_INIT) {
+#ifdef PRE_SAVED_METHOD
+		if (systemInfo.u8_cfgAfeVer != systemInfo.u8_cxAfeVer) {
+			init_type = SPECIAL_FULL_PANEL_INIT;
+			logError(0,
+				 "%s %s: Different CX AFE Ver: %02X != %02X... Execute FULL Panel Init! \n",
+				 tag, __func__, systemInfo.u8_cfgAfeVer,
+				 systemInfo.u8_cxAfeVer);
+		} else
+#endif
+
+		if (systemInfo.u8_cfgAfeVer != systemInfo.u8_panelCfgAfeVer) {
+			init_type = SPECIAL_PANEL_INIT;
+			logError(0,
+				 "%s %s: Different Panel AFE Ver: %02X != %02X... Execute Panel Init! \n",
+				 tag, __func__, systemInfo.u8_cfgAfeVer,
+				 systemInfo.u8_panelCfgAfeVer);
+		} else {
+			init_type = NO_INIT;
+		}
+	}
+
+	if (init_type != NO_INIT) {
+		error = fts_chip_initialization(info, init_type);
+		if (error < OK) {
+			logError(1,
+				 "%s %s Cannot initialize the chip ERROR %08X\n",
+				 tag, __func__, error);
+		}
+	}
+
+	error = fts_init_sensing(info);
+	if (error < OK) {
+		logError(1,
+			 "%s Cannot initialize the hardware device ERROR %08X\n",
+			 tag, error);
+	}
+
+	logError(1, "%s Fw Update Finished! error = %08X\n", tag, error);
+	return error;
+}
+
+#ifndef FW_UPDATE_ON_PROBE
+
+/**
+*	Function called by the delayed workthread executed after the probe in order to perform the fw update flow
+*	@see  fts_fw_update()
+*/
+static void fts_fw_update_auto(struct work_struct *work)
+{
+	struct delayed_work *fwu_work =
+	    container_of(work, struct delayed_work, work);
+	struct fts_ts_info *info =
+	    container_of(fwu_work, struct fts_ts_info, fwu_work);
+	fts_fw_update(info, NULL, 0);
+}
+#endif
+
+/**
+*	Execute the initialization of the IC (supporting a retry mechanism), checking also the resulting data
+*	@see  production_test_main()
+*/
+static int fts_chip_initialization(struct fts_ts_info *info, int init_type)
+{
+	int ret2 = 0;
+	int retry;
+	int initretrycnt = 0;
+
+	for (retry = 0; retry <= RETRY_INIT_BOOT; retry++) {
+		ret2 = production_test_initialization(init_type);
+		if (ret2 == OK)
+			break;
+		initretrycnt++;
+		logError(1,
+			 "%s initialization cycle count = %04d - ERROR %08X \n",
+			 tag, initretrycnt, ret2);
+		fts_chip_powercycle(info);
+	}
+
+	if (ret2 < OK) {
+		logError(1, "%s fts initialization failed 3 times \n", tag);
+	}
+
+	return ret2;
+}
+
+/**
+ * @addtogroup isr
+ * @{
+ */
+/**
+*	Top half Interrupt handler function
+*	Respond to the interrupt and schedule the bottom half interrupt handler in its work queue
+*	@see fts_event_handler()
+*/
+/*
+static irqreturn_t fts_interrupt_handler(int irq, void *handle)
+{
+	struct fts_ts_info *info = handle;
+#ifdef CONFIG_SECURE_TOUCH
+	if (!fts_secure_filter_interrupt(info)) {
+		return IRQ_HANDLED;
+	}
+#endif
+	disable_irq_nosync(info->client->irq);
+	queue_work(info->event_wq, &info->work);
+
+	return IRQ_HANDLED;
+}
+*/
+/**
+*	Initialize the dispatch table with the event handlers for any possible event ID and the interrupt routine behavior (triggered when the IRQ pin is low and associating the top half interrupt handler function).
+*	@see fts_interrupt_handler()
+*/
+static int fts_interrupt_install(struct fts_ts_info *info)
+{
+	int i, error = 0;
+
+	info->event_dispatch_table =
+	    kzalloc(sizeof(event_dispatch_handler_t) * NUM_EVT_ID, GFP_KERNEL);
+
+	if (!info->event_dispatch_table) {
+		logError(1, "%s OOM allocating event dispatch table\n", tag);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < NUM_EVT_ID; i++)
+		info->event_dispatch_table[i] = fts_nop_event_handler;
+
+	install_handler(info, ENTER_POINT, enter_pointer);
+	install_handler(info, LEAVE_POINT, leave_pointer);
+	install_handler(info, MOTION_POINT, motion_pointer);
+	install_handler(info, ERROR, error);
+	install_handler(info, CONTROLLER_READY, controller_ready);
+	install_handler(info, STATUS_UPDATE, status);
+	install_handler(info, USER_REPORT, user_report);
+
+	/* disable interrupts in any case */
+	error = fts_disableInterrupt();
+	logError(1, "%s Interrupt Mode\n", tag);
+	if (request_threaded_irq(info->client->irq, NULL, fts_event_handler, info->board->irq_flags,
+			 FTS_TS_DRV_NAME, info)) {
+		logError(1, "%s Request irq failed\n", tag);
+		kfree(info->event_dispatch_table);
+		error = -EBUSY;
+	} else {
+		disable_irq(info->client->irq);
+	}
+
+	return error;
+}
+
+/**
+*	Clean the dispatch table and the free the IRQ.
+*	This function is called when the driver need to be removed
+*/
+static void fts_interrupt_uninstall(struct fts_ts_info *info)
+{
+
+	fts_disableInterrupt();
+
+	kfree(info->event_dispatch_table);
+
+	free_irq(info->client->irq, info);
+
+}
+
+/**@}*/
+
+/**
+* This function try to attempt to communicate with the IC for the first time during the boot up process in order to acquire the necessary info for the following stages.
+* The function execute a system reset, read fundamental info (system info) from the IC and install the interrupt
+* @return OK if success or an error code which specify the type of error encountered
+*/
+static int fts_init(struct fts_ts_info *info)
+{
+	int error;
+
+	error = fts_system_reset();
+	if (error < OK && isI2cError(error)) {
+		logError(1, "%s Cannot reset the device! ERROR %08X\n", tag,
+			 error);
+		return error;
+	} else {
+		if (error == (ERROR_TIMEOUT | ERROR_SYSTEM_RESET_FAIL)) {
+			logError(1, "%s Setting default Sys INFO! \n", tag);
+			error = defaultSysInfo(0);
+		} else {
+			error = readSysInfo(0);
+			if (error < OK) {
+				if (!isI2cError(error))
+					error = OK;
+				logError(1,
+					 "%s Cannot read Sys Info! ERROR %08X\n",
+					 tag, error);
+			}
+		}
+	}
+
+	return error;
+}
+
+/**
+* Execute a power cycle in the IC, toggling the power lines (AVDD and DVDD)
+* @param info pointer to fts_ts_info struct which contain information of the regulators
+* @return 0 if success or another value if fail
+*/
+int fts_chip_powercycle(struct fts_ts_info *info)
+{
+	int error = 0;
+
+	logError(1, "%s %s: Power Cycle Starting... \n", tag, __func__);
+	logError(1, "%s %s: Disabling IRQ... \n", tag, __func__);
+
+	fts_disableInterruptNoSync();
+
+	if (info->vdd_reg) {
+		error = regulator_disable(info->vdd_reg);
+		if (error < 0) {
+			logError(1, "%s %s: Failed to disable DVDD regulator\n",
+				 tag, __func__);
+		}
+	}
+
+	if (info->avdd_reg) {
+		error = regulator_disable(info->avdd_reg);
+		if (error < 0) {
+			logError(1, "%s %s: Failed to disable AVDD regulator\n",
+				 tag, __func__);
+		}
+	}
+
+	if (info->board->reset_gpio != GPIO_NOT_DEFINED)
+		gpio_set_value(info->board->reset_gpio, 0);
+	else
+		mdelay(300);
+
+	if (info->vdd_reg) {
+		error = regulator_enable(info->vdd_reg);
+		if (error < 0) {
+			logError(1, "%s %s: Failed to enable DVDD regulator\n",
+				 tag, __func__);
+		}
+	}
+
+	mdelay(1);
+
+	if (info->avdd_reg) {
+		error = regulator_enable(info->avdd_reg);
+		if (error < 0) {
+			logError(1, "%s %s: Failed to enable AVDD regulator\n",
+				 tag, __func__);
+		}
+	}
+
+	mdelay(5);
+
+	if (info->board->reset_gpio != GPIO_NOT_DEFINED) {
+		mdelay(10);
+		gpio_set_value(info->board->reset_gpio, 1);
+	}
+
+	release_all_touches(info);
+
+	logError(1, "%s %s: Power Cycle Finished! ERROR CODE = %08x\n", tag,
+		 __func__, error);
+	setSystemResetedUp(1);
+	setSystemResetedDown(1);
+	return error;
+}
+
+/**
+ * Complete the boot up process, initializing the sensing of the IC according to the current setting chosen by the host and register the notifier for the suspend/resume actions and the event handler
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+static int fts_init_sensing(struct fts_ts_info *info)
+{
+	int error = 0;
+/*
+#ifdef CONFIG_DRM
+	error |= msm_drm_register_client(&info->notifier);
+#endif
+*/
+	error |= fts_interrupt_install(info);
+	error |= fts_mode_handler(info, 0);
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	error |= setScanMode(SCAN_MODE_ACTIVE, 0x00);
+	mdelay(WAIT_AFTER_SENSEOFF);
+	error |= setScanMode(SCAN_MODE_ACTIVE, 0x01);
+#endif
+	error |= fts_enableInterrupt();
+
+	if (error < OK)
+		logError(1, "%s %s Init after Probe error (ERROR = %08X)\n",
+			 tag, __func__, error);
+
+	return error;
+}
+
+/**
+ * @ingroup mode_section
+ * @{
+ */
+/**
+ * The function handle the switching of the mode in the IC enabling/disabling the sensing and the features set from the host
+ * @param info pointer to fts_ts_info which contains info about the device and its hw setup
+ * @param force if 1, the enabling/disabling command will be send even if the feature was alredy enabled/disabled otherwise it will judge if the feature changed status or the IC had s system reset and therefore the features need to be restored
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+static int fts_mode_handler(struct fts_ts_info *info, int force)
+{
+	int res = OK;
+	int ret = OK;
+	u8 settings[4] = { 0 };
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	u8 gesture_cmd[6] = {0xA2, 0x03, 0x20, 0x00, 0x00, 0x01};
+	u8 single_only_cmd[4] = {0xC0, 0x02, 0x00, 0x00};
+	u8 single_double_cmd[4] = {0xC0, 0x02, 0x01, 0x1E};
+#endif
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	mutex_lock(&info->fod_mutex);
+#endif
+	info->mode = MODE_NOTHING;
+	logError(0, "%s %s: Mode Handler starting... \n", tag, __func__);
+	switch (info->resume_bit) {
+	case 0:
+		logError(0, "%s %s: Screen OFF... \n", tag, __func__);
+
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+		if (info->fod_status) {
+			logError(1, "%s %s: Sense OFF by FOD \n", tag, __func__);
+			logError(1, "%s %s,send long press and gesture cmd\n", tag, __func__);
+			res = fts_write_dma_safe(gesture_cmd, ARRAY_SIZE(gesture_cmd));
+			if (res < OK)
+					logError(1, "%s %s: enter gesture and longpress failed! ERROR %08X recovery in senseOff...\n",
+						 tag, __func__, res);
+			res = setScanMode(SCAN_MODE_LOW_POWER, 0);
+			res |= ret;
+			if (info->gesture_enabled == 1) {
+				res = fts_write_dma_safe(single_double_cmd, ARRAY_SIZE(single_double_cmd));
+				if (res < OK)
+						logError(1, "%s %s: set single and double tap delay time failed! ERROR %08X\n", tag, __func__, res);
+			} else {
+				res = fts_write_dma_safe(single_only_cmd, ARRAY_SIZE(single_only_cmd));
+				if (res < OK)
+						logError(1, "%s %s: set single only delay time failed! ERROR %08X\n", tag, __func__, res);
+			}
+			info->fod_status_set = true;
+		} else {
+#endif
+			logError(1, "%s %s: Sense OFF! \n", tag, __func__);
+			ret = setScanMode(SCAN_MODE_ACTIVE, 0x00);
+			res |= ret;
+
+			if (info->gesture_enabled == 1) {
+				logError(1, "%s %s: enter in gesture mode ! \n", tag,
+					 __func__);
+				res = enterGestureMode(isSystemResettedDown());
+				if (res >= OK) {
+					fromIDtoMask(FEAT_SEL_GESTURE,
+						     (u8 *)&info->mode,
+						     sizeof(info->mode));
+					MODE_LOW_POWER(info->mode, 0);
+				} else {
+					logError(1,
+						 "%s %s: enterGestureMode failed! ERROR %08X recovery in senseOff...\n",
+						 tag, __func__, res);
+				}
+			}
+			info->fod_status_set = false;
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+		}
+#endif
+		setSystemResetedDown(0);
+		break;
+
+	case 1:
+		logError(1, "%s %s: Screen ON... \n", tag, __func__);
+
+#ifdef GLOVE_MODE
+		if ((info->glove_enabled == FEAT_ENABLE && isSystemResettedUp())
+		    || force == 1) {
+			logError(0, "%s %s: Glove Mode setting... \n", tag,
+				 __func__);
+			settings[0] = info->glove_enabled;
+			ret = setFeatures(FEAT_SEL_GLOVE, settings, 1);
+			if (ret < OK) {
+				logError(1,
+					 "%s %s: error during setting GLOVE_MODE! ERROR %08X\n",
+					 tag, __func__, ret);
+			}
+			res |= ret;
+
+			if (ret >= OK && info->glove_enabled == FEAT_ENABLE) {
+				fromIDtoMask(FEAT_SEL_GLOVE,
+					     (u8 *)&info->mode,
+					     sizeof(info->mode));
+				logError(1, "%s %s: GLOVE_MODE Enabled! \n",
+					 tag, __func__);
+			} else {
+				logError(1, "%s %s: GLOVE_MODE Disabled! \n",
+					 tag, __func__);
+			}
+
+		}
+#endif
+
+#ifdef COVER_MODE
+		if ((info->cover_enabled == FEAT_ENABLE && isSystemResettedUp())
+		    || force == 1) {
+			logError(0, "%s %s: Cover Mode setting... \n", tag,
+				 __func__);
+			settings[0] = info->cover_enabled;
+			ret = setFeatures(FEAT_SEL_COVER, settings, 1);
+			if (ret < OK) {
+				logError(1,
+					 "%s %s: error during setting COVER_MODE! ERROR %08X\n",
+					 tag, __func__, ret);
+			}
+			res |= ret;
+
+			if (ret >= OK && info->cover_enabled == FEAT_ENABLE) {
+				fromIDtoMask(FEAT_SEL_COVER,
+					     (u8 *)&info->mode,
+					     sizeof(info->mode));
+				logError(1, "%s %s: COVER_MODE Enabled! \n",
+					 tag, __func__);
+			} else {
+				logError(1, "%s %s: COVER_MODE Disabled! \n",
+					 tag, __func__);
+			}
+
+		}
+#endif
+#ifdef CHARGER_MODE
+		if ((info->charger_enabled > 0 && isSystemResettedUp())
+		    || force == 1) {
+			logError(0, "%s %s: Charger Mode setting... \n", tag,
+				 __func__);
+
+			settings[0] = info->charger_enabled;
+			ret = setFeatures(FEAT_SEL_CHARGER, settings, 1);
+			if (ret < OK) {
+				logError(1,
+					 "%s %s: error during setting CHARGER_MODE! ERROR %08X\n",
+					 tag, __func__, ret);
+			}
+			res |= ret;
+
+			if (ret >= OK && info->charger_enabled == FEAT_ENABLE) {
+				fromIDtoMask(FEAT_SEL_CHARGER,
+					     (u8 *)&info->mode,
+					     sizeof(info->mode));
+				logError(1, "%s %s: CHARGER_MODE Enabled! \n",
+					 tag, __func__);
+			} else {
+				logError(1, "%s %s: CHARGER_MODE Disabled! \n",
+					 tag, __func__);
+			}
+
+		}
+#endif
+
+#ifdef GRIP_MODE
+		if ((info->grip_enabled == FEAT_ENABLE && isSystemResettedUp())
+		    || force == 1) {
+			logError(0, "%s %s: Grip Mode setting... \n", tag,
+				 __func__);
+			settings[0] = info->grip_enabled;
+			ret = setFeatures(FEAT_SEL_GRIP, settings, 1);
+			if (ret < OK) {
+				logError(1,
+					 "%s %s: error during setting GRIP_MODE! ERROR %08X\n",
+					 tag, __func__, ret);
+			}
+			res |= ret;
+
+			if (ret >= OK && info->grip_enabled == FEAT_ENABLE) {
+				fromIDtoMask(FEAT_SEL_GRIP, (u8 *)&info->mode,
+					     sizeof(info->mode));
+				logError(1, "%s %s: GRIP_MODE Enabled! \n", tag,
+					 __func__);
+			} else {
+				logError(1, "%s %s: GRIP_MODE Disabled! \n",
+					 tag, __func__);
+			}
+
+		}
+#endif
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+		if (info->fod_pressed) {
+			logError(1, "%s %s: Sense OFF \n", tag, __func__);
+			res |= setScanMode(SCAN_MODE_ACTIVE, 0x00);
+			logError(1, "%s %s: Sense ON without cal \n", tag, __func__);
+			res |= setScanMode(SCAN_MODE_ACTIVE, 0x20);
+		} else {
+			logError(1, "%s %s: Sense ON\n", tag, __func__);
+			res |= setScanMode(SCAN_MODE_ACTIVE, 0x01);
+		}
+		info->sensor_scan = true;
+		if (info->fod_status) {
+			res = fts_write_dma_safe(gesture_cmd, ARRAY_SIZE(gesture_cmd));
+			if (res < OK)
+					logError(1, "%s %s: enter gesture and longpress failed! ERROR %08X recovery in senseOff...\n",
+						 tag, __func__, res);
+			info->fod_status_set = true;
+		}
+#else
+		settings[0] = 0x01;
+		logError(1, "%s %s: Sense ON! \n", tag, __func__);
+		res |= setScanMode(SCAN_MODE_ACTIVE, settings[0]);
+		info->mode |= (SCAN_MODE_ACTIVE << 24);
+		MODE_ACTIVE(info->mode, settings[0]);
+#endif
+		setSystemResetedUp(0);
+		break;
+
+	default:
+		logError(1,
+			 "%s %s: invalid resume_bit value = %d! ERROR %08X \n",
+			 tag, __func__, info->resume_bit, ERROR_OP_NOT_ALLOW);
+		res = ERROR_OP_NOT_ALLOW;
+	}
+
+	logError(0, "%s %s: Mode Handler finished! res = %08X mode = %08X \n",
+		 tag, __func__, res, info->mode);
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	mutex_unlock(&info->fod_mutex);
+#endif
+	return res;
+
+}
+
+static void fts_mode_handler_work(struct work_struct *work)
+{
+	struct fts_ts_info *info;
+
+	info = container_of(work, struct fts_ts_info, mode_handler_work);
+
+	fts_mode_handler(info, 0);
+}
+
+/**
+ * Resume work function which perform a system reset, clean all the touches from the linux input system and prepare the ground for enabling the sensing
+ */
+static void fts_resume_work(struct work_struct *work)
+{
+	struct fts_ts_info *info;
+
+	info = container_of(work, struct fts_ts_info, resume_work);
+	fts_disableInterrupt();
+#ifdef CONFIG_SECURE_TOUCH
+	fts_secure_stop(info, true);
+#endif
+	info->resume_bit = 1;
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	if (!info->fod_pressed) {
+#endif
+	fts_system_reset();
+	release_all_touches(info);
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	}
+#endif
+	info->fod_status_set = false;
+	fts_mode_handler(info, 0);
+	info->sensor_sleep = false;
+	info->sleep_finger = 0;
+
+	fts_enableInterrupt();
+}
+
+/**
+ * Suspend work function which clean all the touches from Linux input system and prepare the ground to disabling the sensing or enter in gesture mode
+ */
+static void fts_suspend_work(struct work_struct *work)
+{
+	struct fts_ts_info *info;
+
+	info = container_of(work, struct fts_ts_info, suspend_work);
+#ifdef CONFIG_SECURE_TOUCH
+	fts_secure_stop(info, true);
+#endif
+	fts_disableInterrupt();
+	info->resume_bit = 0;
+	fts_mode_handler(info, 0);
+	release_all_touches(info);
+
+	info->sensor_sleep = true;
+
+	if (info->gesture_enabled || info->fod_status)
+		fts_enableInterrupt();
+#ifdef CONFIG_FTS_TOUCH_COUNT_DUMP
+	sysfs_notify(&fts_info->fts_touch_dev->kobj, NULL,
+		     "touch_suspend_notify");
+#endif
+}
+/*
+#ifdef CONFIG_DRM
+
+ * Callback function used to detect the suspend/resume events generated by clicking the power button.
+ * This function schedule a suspend or resume work according to the event received.
+
+static int fts_drm_state_chg_callback(struct notifier_block *nb,
+				      unsigned long val, void *data)
+{
+	struct fts_ts_info *info =
+	    container_of(nb, struct fts_ts_info, notifier);
+	struct msm_drm_notifier *evdata = data;
+	unsigned int blank;
+
+	logError(0, "%s %s: fts notifier begin!\n", tag, __func__);
+
+	if (evdata && evdata->data && info) {
+
+		blank = *(int *)(evdata->data);
+		logError(1, "%s %s: val:%lu,blank:%u\n", tag, __func__, val, blank);
+
+		if (val == MSM_DRM_EARLY_EVENT_BLANK && (blank == MSM_DRM_BLANK_POWERDOWN ||
+				blank == MSM_DRM_BLANK_LP)) {
+			if (info->sensor_sleep)
+				return NOTIFY_OK;
+
+			logError(1, "%s %s: FB_BLANK %s\n", tag,
+				 __func__, blank == MSM_DRM_BLANK_POWERDOWN ? "POWER DOWN" : "LP");
+
+			flush_workqueue(info->event_wq);
+			queue_work(info->event_wq, &info->suspend_work);
+		} else if (val == MSM_DRM_EVENT_BLANK && blank == MSM_DRM_BLANK_UNBLANK) {
+			if (!info->sensor_sleep)
+				return NOTIFY_OK;
+
+			logError(1, "%s %s: FB_BLANK_UNBLANK\n", tag,
+				 __func__);
+
+			flush_workqueue(info->event_wq);
+			queue_work(info->event_wq, &info->resume_work);
+		}
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block fts_noti_block = {
+	.notifier_call = fts_drm_state_chg_callback,
+};
+#endif
+*/
+/**
+ * From the name of the power regulator get/put the actual regulator structs (copying their references into fts_ts_info variable)
+ * @param info pointer to fts_ts_info which contains info about the device and its hw setup
+ * @param get if 1, the regulators are get otherwise they are put (released) back to the system
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+static int fts_get_reg(struct fts_ts_info *info, bool get)
+{
+	int retval;
+	const struct fts_hw_platform_data *bdata = info->board;
+
+	if (!get) {
+		retval = 0;
+		goto regulator_put;
+	}
+
+	if ((bdata->vdd_reg_name != NULL) && (*bdata->vdd_reg_name != 0)) {
+		info->vdd_reg = regulator_get(info->dev, bdata->vdd_reg_name);
+		if (IS_ERR(info->vdd_reg)) {
+			logError(1, "%s %s: Failed to get power regulator\n",
+				 tag, __func__);
+			retval = PTR_ERR(info->vdd_reg);
+			goto regulator_put;
+		}
+	}
+
+	if ((bdata->avdd_reg_name != NULL) && (*bdata->avdd_reg_name != 0)) {
+		info->avdd_reg = regulator_get(info->dev, bdata->avdd_reg_name);
+		if (IS_ERR(info->avdd_reg)) {
+			logError(1,
+				 "%s %s: Failed to get bus pullup regulator\n",
+				 tag, __func__);
+			retval = PTR_ERR(info->avdd_reg);
+			goto regulator_put;
+		}
+	}
+
+	return OK;
+
+regulator_put:
+	if (info->vdd_reg) {
+		regulator_put(info->vdd_reg);
+		info->vdd_reg = NULL;
+	}
+
+	if (info->avdd_reg) {
+		regulator_put(info->avdd_reg);
+		info->avdd_reg = NULL;
+	}
+
+	return retval;
+}
+
+/**
+ * Enable or disable the power regulators
+ * @param info pointer to fts_ts_info which contains info about the device and its hw setup
+ * @param enable if 1, the power regulators are turned on otherwise they are turned off
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+static int fts_enable_reg(struct fts_ts_info *info, bool enable)
+{
+	int retval;
+
+	if (!enable) {
+		retval = 0;
+		goto disable_pwr_reg;
+	}
+
+	if (info->vdd_reg) {
+		retval = regulator_enable(info->vdd_reg);
+		if (retval < 0) {
+			logError(1, "%s %s: Failed to enable bus regulator\n",
+				 tag, __func__);
+			goto exit;
+		}
+	}
+
+	if (info->avdd_reg) {
+		retval = regulator_enable(info->avdd_reg);
+		if (retval < 0) {
+			logError(1, "%s %s: Failed to enable power regulator\n",
+				 tag, __func__);
+			goto disable_bus_reg;
+		}
+	}
+
+	return OK;
+
+disable_pwr_reg:
+	if (info->avdd_reg)
+		regulator_disable(info->vdd_reg);
+
+disable_bus_reg:
+	if (info->vdd_reg)
+		regulator_disable(info->avdd_reg);
+
+exit:
+	return retval;
+}
+
+/**
+ * Configure a GPIO according to the parameters
+ * @param gpio gpio number
+ * @param config if true, the gpio is set up otherwise it is free
+ * @param dir direction of the gpio, 0 = in, 1 = out
+ * @param state initial value (if the direction is in, this parameter is ignored)
+ * return error code
+ */
+static int fts_gpio_setup(int gpio, bool config, int dir, int state)
+{
+	int retval = 0;
+	unsigned char buf[16];
+
+	if (config) {
+		snprintf(buf, 16, "fts_gpio_%u\n", gpio);
+
+		retval = gpio_request(gpio, buf);
+		if (retval) {
+			logError(1, "%s %s: Failed to get gpio %d (code: %d)",
+				 tag, __func__, gpio, retval);
+			return retval;
+		}
+
+		if (dir == 0)
+			retval = gpio_direction_input(gpio);
+		else
+			retval = gpio_direction_output(gpio, state);
+		if (retval) {
+			logError(1, "%s %s: Failed to set gpio %d direction",
+				 tag, __func__, gpio);
+			return retval;
+		}
+	} else {
+		gpio_free(gpio);
+	}
+
+	return retval;
+}
+
+/**
+ * Setup the IRQ and RESET (if present) gpios.
+ * If the Reset Gpio is present it will perform a cycle HIGH-LOW-HIGH in order to assure that the IC has been reset properly
+ */
+static int fts_set_gpio(struct fts_ts_info *info)
+{
+	int retval;
+	struct fts_hw_platform_data *bdata = info->board;
+
+	retval = fts_gpio_setup(bdata->irq_gpio, true, 0, 0);
+	if (retval < 0) {
+		logError(1, "%s %s: Failed to configure irq GPIO\n", tag,
+			 __func__);
+		goto err_gpio_irq;
+	}
+
+	if (bdata->reset_gpio >= 0) {
+		retval = fts_gpio_setup(bdata->reset_gpio, true, 1, 0);
+		if (retval < 0) {
+			logError(1, "%s %s: Failed to configure reset GPIO\n",
+				 tag, __func__);
+			goto err_gpio_reset;
+		}
+	}
+	if (bdata->reset_gpio >= 0) {
+		gpio_set_value(bdata->reset_gpio, 0);
+		mdelay(10);
+		gpio_set_value(bdata->reset_gpio, 1);
+	}
+
+	return OK;
+
+err_gpio_reset:
+	fts_gpio_setup(bdata->irq_gpio, false, 0, 0);
+	bdata->reset_gpio = GPIO_NOT_DEFINED;
+err_gpio_irq:
+	return retval;
+}
+
+static int fts_pinctrl_init(struct fts_ts_info *info)
+{
+	int retval = 0;
+	/* Get pinctrl if target uses pinctrl */
+	info->ts_pinctrl = devm_pinctrl_get(info->dev);
+
+	if (IS_ERR_OR_NULL(info->ts_pinctrl)) {
+		retval = PTR_ERR(info->ts_pinctrl);
+		dev_err(info->dev, "Target does not use pinctrl %d\n", retval);
+		goto err_pinctrl_get;
+	}
+
+	info->pinctrl_state_active
+	    = pinctrl_lookup_state(info->ts_pinctrl, PINCTRL_STATE_ACTIVE);
+
+	if (IS_ERR_OR_NULL(info->pinctrl_state_active)) {
+		retval = PTR_ERR(info->pinctrl_state_active);
+		dev_err(info->dev, "Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_ACTIVE, retval);
+		goto err_pinctrl_lookup;
+	}
+
+	info->pinctrl_state_suspend
+	    = pinctrl_lookup_state(info->ts_pinctrl, PINCTRL_STATE_SUSPEND);
+
+	if (IS_ERR_OR_NULL(info->pinctrl_state_suspend)) {
+		retval = PTR_ERR(info->pinctrl_state_suspend);
+		dev_dbg(info->dev, "Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_SUSPEND, retval);
+		goto err_pinctrl_lookup;
+	}
+
+	return 0;
+err_pinctrl_lookup:
+	devm_pinctrl_put(info->ts_pinctrl);
+err_pinctrl_get:
+	info->ts_pinctrl = NULL;
+	return retval;
+}
+
+/**
+ * Retrieve and parse the hw information from the device tree node defined in the system.
+ * the most important information to obtain are: IRQ and RESET gpio numbers, power regulator names
+ * In the device file node is possible to define additional optional information that can be parsed here.
+ */
+static int parse_dt(struct device *dev, struct fts_hw_platform_data *bdata)
+{
+	int retval;
+	const char *name;
+	struct device_node *temp, *np = dev->of_node;
+	struct fts_config_info *config_info;
+	u32 temp_val;
+
+	bdata->irq_gpio = of_get_named_gpio(np, "fts,irq-gpio", 0);
+
+	logError(0, "%s irq_gpio = %d\n", tag, bdata->irq_gpio);
+
+	retval = of_property_read_string(np, "fts,pwr-reg-name", &name);
+	if (retval == -EINVAL)
+		bdata->vdd_reg_name = NULL;
+	else if (retval < 0)
+		return retval;
+	else {
+		bdata->vdd_reg_name = name;
+		logError(0, "%s pwr_reg_name = %s\n", tag, name);
+	}
+
+	retval = of_property_read_string(np, "fts,bus-reg-name", &name);
+	if (retval == -EINVAL)
+		bdata->avdd_reg_name = NULL;
+	else if (retval < 0)
+		return retval;
+	else {
+		bdata->avdd_reg_name = name;
+		logError(0, "%s bus_reg_name = %s\n", tag, name);
+	}
+
+	if (of_property_read_bool(np, "fts,reset-gpio-enable")) {
+		bdata->reset_gpio = of_get_named_gpio(np,
+							    "fts,reset-gpio", 0);
+
+		logError(0, "%s reset_gpio =%d\n", tag, bdata->reset_gpio);
+	} else {
+		bdata->reset_gpio = GPIO_NOT_DEFINED;
+	}
+
+	retval = of_property_read_u32(np, "fts,irq-flags", &temp_val);
+	if (retval < 0)
+		return retval;
+	else
+		bdata->irq_flags = temp_val;
+	retval = of_property_read_u32(np, "fts,x-max", &temp_val);
+	if (retval < 0)
+		bdata->x_max = X_AXIS_MAX;
+	else
+		bdata->x_max = temp_val;
+
+	retval = of_property_read_u32(np, "fts,y-max", &temp_val);
+	if (retval < 0)
+		bdata->y_max = Y_AXIS_MAX;
+	else
+		bdata->y_max = temp_val;
+	retval = of_property_read_string(np, "fts,default-fw-name",
+					 &bdata->default_fw_name);
+
+#ifdef CONFIG_FTS_TOUCH_COUNT_DUMP
+	bdata->dump_click_count =
+	    of_property_read_bool(np, "fts,dump-click-count");
+#endif
+	retval =
+	    of_property_read_u32(np, "fts,config-array-size",
+				 (u32 *)&bdata->config_array_size);
+
+	if (retval) {
+		logError(1, "%s Unable to get array size\n", tag);
+		return retval;
+	}
+
+	bdata->config_array = devm_kzalloc(dev, bdata->config_array_size *
+					   sizeof(struct fts_config_info),
+					   GFP_KERNEL);
+
+	if (!bdata->config_array) {
+		logError(1, "%s Unable to allocate memory\n", tag);
+		return -ENOMEM;
+	}
+
+	config_info = bdata->config_array;
+	for_each_child_of_node(np, temp) {
+		retval = of_property_read_u32(temp, "fts,tp-vendor", &temp_val);
+
+		if (retval) {
+			logError(1, "%s Unable to read tp vendor\n", tag);
+		} else {
+			config_info->tp_vendor = (u8) temp_val;
+			logError(1, "%s %s:tp vendor: %u", tag, __func__,
+				 config_info->tp_vendor);
+		}
+		retval = of_property_read_u32(temp, "fts,tp-color", &temp_val);
+		if (retval) {
+			logError(1, "%s Unable to read tp color\n", tag);
+		} else {
+			config_info->tp_color = (u8) temp_val;
+			logError(1, "%s %s:tp color: %u", tag, __func__,
+				 config_info->tp_color);
+		}
+
+		retval =
+		    of_property_read_u32(temp, "fts,tp-hw-version", &temp_val);
+
+		if (retval) {
+			logError(1, "%s Unable to read tp hw version\n", tag);
+		} else {
+			config_info->tp_hw_version = (u8) temp_val;
+			logError(1, "%s %s:tp color: %u", tag, __func__,
+				 config_info->tp_hw_version);
+		}
+
+		retval = of_property_read_string(temp, "fts,fw-name",
+						 &config_info->fts_cfg_name);
+
+		if (retval && (retval != -EINVAL)) {
+			logError(1, "%s Unable to read cfg name\n", tag);
+		} else {
+			logError(1, "%s %s:fw_name: %s", tag, __func__,
+				 config_info->fts_cfg_name);
+		}
+		retval = of_property_read_string(temp, "fts,limit-name",
+						 &config_info->fts_limit_name);
+
+		if (retval && (retval != -EINVAL)) {
+			logError(1, "%s Unable to read limit name\n", tag);
+		} else {
+			logError(1, "%s %s:limit_name: %s", tag, __func__,
+				 config_info->fts_limit_name);
+		}
+#ifdef CONFIG_FTS_TOUCH_COUNT_DUMP
+		if (bdata->dump_click_count) {
+			retval =
+			    of_property_read_string(temp,
+						    "fts,clicknum-file-name",
+						    &config_info->clicknum_file_name);
+			if (retval && (retval != -EINVAL)) {
+				dev_err(dev,
+					"Unable to read click count file name\n");
+			} else
+				dev_err(dev, "%s\n",
+					config_info->clicknum_file_name);
+		}
+#endif
+
+		config_info++;
+	}
+	return OK;
+}
+
+static void fts_switch_mode_work(struct work_struct *work)
+{
+	struct fts_mode_switch *ms =
+	    container_of(work, struct fts_mode_switch, switch_mode_work);
+
+	struct fts_ts_info *info = ms->info;
+	unsigned char value = ms->mode;
+	static const char *fts_gesture_on = "01 20";
+	char *gesture_result;
+	int size = 6 * 2 + 1;
+	char ch[16] = { 0x0, };
+
+	logError(1, "%s %s mode:%d\n", tag, __func__, value);
+
+	if (value >= INPUT_EVENT_WAKUP_MODE_OFF
+	    && value <= INPUT_EVENT_WAKUP_MODE_ON) {
+		info->gesture_enabled = value - INPUT_EVENT_WAKUP_MODE_OFF;
+		if (info->gesture_enabled) {
+			gesture_result = (u8 *) kzalloc(size, GFP_KERNEL);
+			if (gesture_result != NULL) {
+				fts_gesture_mask_store(info->dev, NULL,
+						       fts_gesture_on,
+						       strlen(fts_gesture_on));
+				fts_gesture_mask_show(info->dev, NULL,
+						      gesture_result);
+				if (strncmp
+				    ("{ 00000000 }", gesture_result, size - 1))
+					logError(1,
+						 "%s %s:store gesture mask error\n",
+						 tag, __func__);
+				kfree(gesture_result);
+				gesture_result = NULL;
+			}
+		}
+		snprintf(ch, sizeof(ch), "%s",
+			 (value -
+			  INPUT_EVENT_WAKUP_MODE_OFF) ? "enabled" : "disabled");
+	} else if (value >= INPUT_EVENT_COVER_MODE_OFF
+		   && value <= INPUT_EVENT_COVER_MODE_ON) {
+		info->glove_enabled = value - INPUT_EVENT_COVER_MODE_OFF;
+		fts_mode_handler(info, 1);
+	}
+#ifdef EDGEHOVER_FOR_VOLUME
+	if (value >= INPUT_EVENT_SLIDE_FOR_VOLUME
+	    && value <= INPUT_EVENT_LONG_SINGLE_TAP_FOR_VOLUME) {
+		info->volume_type = value;
+		if (fts_info->volume_type == INPUT_EVENT_SINGLE_TAP_FOR_VOLUME) {
+			fts_info->single_press_time_low = 30;
+			fts_info->single_press_time_hi = 800;
+		} else if (fts_info->volume_type ==
+			   INPUT_EVENT_LONG_SINGLE_TAP_FOR_VOLUME) {
+			fts_info->single_press_time_low = 300;
+			fts_info->single_press_time_hi = 800;
+		}
+	}
+#endif
+#ifdef PHONE_PALM
+	if (value >= INPUT_EVENT_PALM_OFF && value <= INPUT_EVENT_PALM_ON)
+		info->palm_enabled = value - INPUT_EVENT_PALM_OFF;
+#endif
+	if (ms != NULL) {
+		kfree(ms);
+		ms = NULL;
+	}
+}
+
+static ssize_t fts_input_symlink(struct fts_ts_info *info) {
+	char *driver_path;
+	int ret = 0;
+
+	if (info->input_proc) {
+		proc_remove(info->input_proc);
+		info->input_proc = NULL;
+	}
+
+	driver_path = kzalloc(PATH_MAX, GFP_KERNEL);
+	if (!driver_path) {
+		return -ENOMEM;
+	}
+
+	sprintf(driver_path, "/sys%s",
+			kobject_get_path(&info->input_dev->dev.kobj, GFP_KERNEL));
+
+	pr_info("%s: driver_path=%s\n", __func__, driver_path);
+	info->input_proc = proc_symlink(PROC_SYMLINK_PATH, NULL, driver_path);
+	if (!info->input_proc) {
+		ret = -ENOMEM;
+	}
+
+	kfree(driver_path);
+
+	return ret;
+}
+
+static int fts_input_event(struct input_dev *dev, unsigned int type,
+			   unsigned int code, int value)
+{
+	struct fts_ts_info *info = input_get_drvdata(dev);
+	struct fts_mode_switch *ms;
+
+	logError(1, "%s %s:set input event value = %d\n", tag, __func__, value);
+
+	if (!info) {
+		printk("%s fts_ts_info is NULL\n", __func__);
+		return 0;
+	}
+
+	if (type == EV_SYN && code == SYN_CONFIG) {
+		if (value >= INPUT_EVENT_START && value <= INPUT_EVENT_END) {
+			ms = (struct fts_mode_switch *)
+			    kmalloc(sizeof(struct fts_mode_switch), GFP_ATOMIC);
+
+			if (ms != NULL) {
+				ms->info = info;
+				ms->mode = (unsigned char)value;
+				INIT_WORK(&ms->switch_mode_work,
+					  fts_switch_mode_work);
+				schedule_work(&ms->switch_mode_work);
+			} else {
+				logError(1,
+					 "%s %s:failed in allocating memory for switching mode\n",
+					 tag, __func__);
+				return -ENOMEM;
+			}
+		} else {
+			logError(1, "%s %s:Invalid event value\n", tag,
+				 __func__);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int fts_short_open_test(void)
+{
+	TestToDo selftests;
+	int res = -1;
+	int init_type = SPECIAL_PANEL_INIT;
+
+	memset(&selftests, 0x00, sizeof(TestToDo));
+
+/* Hover Test */
+	selftests.SelfHoverForceRaw = 0;		/*  SS Hover Force Raw min/Max test */
+	selftests.SelfHoverSenceRaw = 0;		/*  SS Hover Sence Raw min/Max test */
+	selftests.SelfHoverForceIxTotal = 0;	/*  SS Hover Total Force Ix min/Max (for each node)* test */
+	selftests.SelfHoverSenceIxTotal = 0;
+
+	selftests.MutualRawAdjITO = 0;
+	selftests.MutualRaw = 0;
+	selftests.MutualRawEachNode = 1;
+	selftests.MutualRawGap = 0;
+	selftests.MutualRawAdj = 0;
+	selftests.MutualRawLP = 0;
+	selftests.MutualRawGapLP = 0;
+	selftests.MutualRawAdjLP = 0;
+	selftests.MutualCx1 = 0;
+	selftests.MutualCx2 = 0;
+	selftests.MutualCx2Adj = 0;
+	selftests.MutualCxTotal = 0;
+	selftests.MutualCxTotalAdj = 0;
+	selftests.MutualCx1LP = 0;
+	selftests.MutualCx2LP = 0;
+	selftests.MutualCx2AdjLP = 0;
+	selftests.MutualCxTotalLP = 0;
+	selftests.MutualCxTotalAdjLP = 0;
+#ifdef PHONE_KEY
+	selftests.MutualKeyRaw = 0;
+#else
+	selftests.MutualKeyRaw = 0;
+#endif
+	selftests.MutualKeyCx1 = 0;
+	selftests.MutualKeyCx2 = 0;
+#ifdef PHONE_KEY
+	selftests.MutualKeyCxTotal = 0;
+#else
+	selftests.MutualKeyCxTotal = 0;
+#endif
+	selftests.SelfForceRaw= 1;
+	selftests.SelfForceRawGap = 0;
+	selftests.SelfForceRawLP = 0;
+	selftests.SelfForceRawGapLP = 0;
+	selftests.SelfForceIx1 = 0;
+	selftests.SelfForceIx2 = 0;
+	selftests.SelfForceIx2Adj = 0;
+	selftests.SelfForceIxTotal = 0;
+	selftests.SelfForceIxTotalAdj = 0;
+	selftests.SelfForceCx1 = 0;
+	selftests.SelfForceCx2 = 0;
+	selftests.SelfForceCx2Adj = 0;
+	selftests.SelfForceCxTotal = 0;
+	selftests.SelfForceCxTotalAdj = 0;
+	selftests.SelfSenseRaw = 1;
+	selftests.SelfSenseRawGap = 0;
+	selftests.SelfSenseRawLP = 0;
+	selftests.SelfSenseRawGapLP = 0;
+	selftests.SelfSenseIx1 = 0;
+	selftests.SelfSenseIx2 = 0;
+	selftests.SelfSenseIx2Adj = 0;
+	selftests.SelfSenseIxTotal = 0;
+	selftests.SelfSenseIxTotalAdj = 0;
+	selftests.SelfSenseCx1 = 0;
+	selftests.SelfSenseCx2 = 0;
+	selftests.SelfSenseCx2Adj = 0;
+	selftests.SelfSenseCxTotal = 0;
+	selftests.SelfSenseCxTotalAdj = 0;
+
+	res = fts_disableInterrupt();
+	if (res < 0) {
+		logError(0, "%s fts_disableInterrupt: ERROR %08X \n",
+			 tag, res);
+		res = (res | ERROR_DISABLE_INTER);
+		goto END;
+	}
+	res = production_test_main(LIMITS_FILE, 1, init_type, &selftests);
+END:
+	fts_mode_handler(fts_info, 1);
+	fts_enableInterrupt();
+	if (res == OK)
+		return FTS_RESULT_PASS;
+	else
+		return FTS_RESULT_FAIL;
+}
+
+static int fts_i2c_test(void)
+{
+	int ret = 0;
+	u8 data[SYS_INFO_SIZE] = { 0 };
+
+	logError(0, "%s %s: Reading System Info...\n", tag, __func__);
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, ADDR_FRAMEBUFFER,
+			      data, SYS_INFO_SIZE, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		logError(1,
+			 "%s %s: error while reading the system data ERROR %08X\n",
+			 tag, __func__, ret);
+		return FTS_RESULT_FAIL;
+	}
+
+	return FTS_RESULT_PASS;
+}
+
+static ssize_t fts_selftest_read(struct file *file, char __user *buf,
+				 size_t count, loff_t *pos)
+{
+	char tmp[5] = { 0 };
+	int cnt;
+
+	if (*pos != 0)
+		return 0;
+	cnt =
+	    snprintf(tmp, sizeof(fts_info->result_type), "%d\n",
+		     fts_info->result_type);
+	if (copy_to_user(buf, tmp, strlen(tmp))) {
+		return -EFAULT;
+	}
+	*pos += cnt;
+	return cnt;
+}
+
+static ssize_t fts_selftest_write(struct file *file, const char __user *buf,
+				  size_t count, loff_t *pos)
+{
+	int retval = 0;
+	char tmp[6];
+
+	if (copy_from_user(tmp, buf, count)) {
+		retval = -EFAULT;
+		goto out;
+	}
+
+	if (!strncmp("short", tmp, 5) || !strncmp("open", tmp, 4)) {
+		retval = fts_short_open_test();
+	} else if (!strncmp("i2c", tmp, 3))
+		retval = fts_i2c_test();
+
+	fts_info->result_type = retval;
+out:
+	if (retval >= 0)
+		retval = count;
+
+	return retval;
+}
+
+static const struct proc_ops fts_selftest_ops = {
+	.proc_read = fts_selftest_read,
+	.proc_write = fts_selftest_write,
+};
+
+static ssize_t fts_datadump_read(struct file *file, char __user *buf,
+				 size_t count, loff_t *pos)
+{
+	int ret = 0, cnt1 = 0, cnt2 = 0, cnt3 = 0;
+	char *tmp;
+
+	if (*pos != 0)
+		return 0;
+
+	tmp = kvmalloc(PAGE_SIZE * 2, GFP_KERNEL);
+	if (tmp == NULL)
+		return 0;
+	else
+		memset(tmp, 0, PAGE_SIZE * 2);
+
+	cnt1 = fts_strength_frame_show(fts_info->dev, NULL, tmp);
+	if (cnt1 == 0) {
+		ret = 0;
+		goto out;
+	}
+
+	ret = stm_fts_cmd_store(fts_info->dev, NULL, "13", 2);
+	if (ret == 0)
+		goto out;
+	cnt2 = stm_fts_cmd_show(fts_info->dev, NULL, tmp + cnt1);
+	if (cnt2 == 0) {
+		ret = 0;
+		goto out;
+	}
+
+	ret = stm_fts_cmd_store(fts_info->dev, NULL, "15", 2);
+	if (ret == 0)
+		goto out;
+	cnt3 = stm_fts_cmd_show(fts_info->dev, NULL, tmp + cnt1 + cnt2);
+	if (cnt3 == 0) {
+		ret = 0;
+		goto out;
+	}
+
+	if (copy_to_user(buf, tmp, cnt1 + cnt2 + cnt3))
+		ret = -EFAULT;
+
+out:
+	if (tmp) {
+		kvfree(tmp);
+		tmp = NULL;
+	}
+	*pos += (cnt1 + cnt2 + cnt3);
+	if (ret <= 0)
+		return ret;
+	return cnt1 + cnt2 + cnt3;
+}
+
+static const struct proc_ops fts_datadump_ops = {
+	.proc_read = fts_datadump_read,
+};
+
+#define TP_INFO_MAX_LENGTH 50
+
+static ssize_t fts_fw_version_read(struct file *file, char __user *buf,
+				   size_t count, loff_t *pos)
+{
+	int cnt = 0, ret = 0;
+	char tmp[TP_INFO_MAX_LENGTH];
+
+	if (*pos != 0)
+		return 0;
+
+	cnt =
+	    snprintf(tmp, TP_INFO_MAX_LENGTH, "%x.%x\n", systemInfo.u16_fwVer,
+		     systemInfo.u16_cfgVer);
+	ret = copy_to_user(buf, tmp, cnt);
+	*pos += cnt;
+	if (ret != 0)
+		return 0;
+	else
+		return cnt;
+}
+
+static const struct proc_ops fts_fw_version_ops = {
+	.proc_read = fts_fw_version_read,
+};
+
+static ssize_t fts_lockdown_info_read(struct file *file, char __user *buf,
+				      size_t count, loff_t *pos)
+{
+	int cnt = 0, ret = 0;
+	char tmp[TP_INFO_MAX_LENGTH];
+
+	if (*pos != 0)
+		return 0;
+
+	ret = fts_get_lockdown_info(fts_info->lockdown_info, fts_info);
+	if (ret != OK) {
+		logError(1, "%s %s get lockdown info error\n", tag, __func__);
+		goto out;
+	}
+
+	cnt =
+	    snprintf(tmp, TP_INFO_MAX_LENGTH,
+		     "0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x\n",
+		     fts_info->lockdown_info[0], fts_info->lockdown_info[1],
+		     fts_info->lockdown_info[2], fts_info->lockdown_info[3],
+		     fts_info->lockdown_info[4], fts_info->lockdown_info[5],
+		     fts_info->lockdown_info[6], fts_info->lockdown_info[7]);
+	ret = copy_to_user(buf, tmp, cnt);
+out:
+	*pos += cnt;
+	if (ret != 0)
+		return 0;
+	else
+		return cnt;
+}
+
+static const struct proc_ops fts_lockdown_info_ops = {
+	.proc_read = fts_lockdown_info_read,
+};
+
+#ifdef CONFIG_PM
+static int fts_pm_suspend(struct device *dev)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+#ifndef CONFIG_FTS_FOD_AREA_REPORT
+	if (device_may_wakeup(dev) && info->gesture_enabled) {
+		logError(1, "%s enable touch irq wake\n", tag);
+		enable_irq_wake(info->client->irq);
+	}
+#else
+	enable_irq_wake(info->client->irq);
+#endif
+	info->tp_pm_suspend = true;
+	reinit_completion(&info->pm_resume_completion);
+
+	return 0;
+
+}
+
+static int fts_pm_resume(struct device *dev)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+#ifndef CONFIG_FTS_FOD_AREA_REPORT
+	if (device_may_wakeup(dev) && info->gesture_enabled) {
+		logError(1, "%s disable touch irq wake\n", tag);
+		disable_irq_wake(info->client->irq);
+	}
+#else
+	disable_irq_wake(info->client->irq);
+#endif
+	info->tp_pm_suspend = false;
+	complete(&info->pm_resume_completion);
+
+	return 0;
+}
+
+static const struct dev_pm_ops fts_dev_pm_ops = {
+	.suspend = fts_pm_suspend,
+	.resume = fts_pm_resume,
+};
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_ST_DEBUG_FS
+static void tpdbg_shutdown(struct fts_ts_info *info, bool sleep)
+{
+	u8 settings[4] = { 0 };
+	info->mode = MODE_NOTHING;
+
+	if (sleep) {
+		logError(0, "%s %s: Sense OFF! \n", tag, __func__);
+		setScanMode(SCAN_MODE_ACTIVE, 0x00);
+	} else {
+		settings[0] = 0x01;
+		logError(0, "%s %s: Sense ON! \n", tag, __func__);
+		setScanMode(SCAN_MODE_ACTIVE, settings[0]);
+		info->mode |= (SCAN_MODE_ACTIVE << 24);
+		MODE_ACTIVE(info->mode, settings[0]);
+	}
+}
+
+static void tpdbg_suspend(struct fts_ts_info *info, bool enable)
+{
+	if (enable)
+		queue_work(info->event_wq, &info->suspend_work);
+	else
+		queue_work(info->event_wq, &info->resume_work);
+}
+
+static int tpdbg_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+
+	return 0;
+}
+
+static ssize_t tpdbg_read(struct file *file, char __user *buf, size_t size,
+			  loff_t *ppos)
+{
+	const char *str = "cmd support as below:\n \
+				\necho \"irq-disable\" or \"irq-enable\" to ctrl irq\n \
+				\necho \"tp-sd-en\" of \"tp-sd-off\" to ctrl panel in or off sleep mode\n \
+				\necho \"tp-suspend-en\" or \"tp-suspend-off\" to ctrl panel in or off suspend status\n";
+
+	loff_t pos = *ppos;
+	int len = strlen(str);
+
+	if (pos < 0)
+		return -EINVAL;
+	if (pos >= len)
+		return 0;
+
+	if (copy_to_user(buf, str, len))
+		return -EFAULT;
+
+	*ppos = pos + len;
+
+	return len;
+}
+
+static ssize_t tpdbg_write(struct file *file, const char __user *buf,
+			   size_t size, loff_t *ppos)
+{
+	struct fts_ts_info *info = file->private_data;
+	char *cmd = kzalloc(size + 1, GFP_KERNEL);
+	int ret = size;
+
+	if (!cmd)
+		return -ENOMEM;
+
+	if (copy_from_user(cmd, buf, size)) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	cmd[size] = '\0';
+
+	if (!strncmp(cmd, "irq-disable", 11))
+		disable_irq(info->client->irq);
+	else if (!strncmp(cmd, "irq-enable", 10))
+		enable_irq(info->client->irq);
+	else if (!strncmp(cmd, "tp-sd-en", 8))
+		tpdbg_shutdown(info, true);
+	else if (!strncmp(cmd, "tp-sd-off", 9))
+		tpdbg_shutdown(info, false);
+	else if (!strncmp(cmd, "tp-suspend-en", 13))
+		tpdbg_suspend(info, true);
+	else if (!strncmp(cmd, "tp-suspend-off", 14))
+		tpdbg_suspend(info, false);
+out:
+	kfree(cmd);
+
+	return ret;
+}
+
+static int tpdbg_release(struct inode *inode, struct file *file)
+{
+	file->private_data = NULL;
+
+	return 0;
+}
+
+static const struct file_operations tpdbg_operations = {
+	.owner = THIS_MODULE,
+	.open = tpdbg_open,
+	.read = tpdbg_read,
+	.write = tpdbg_write,
+	.release = tpdbg_release,
+};
+#endif
+
+#ifdef CONFIG_SECURE_TOUCH
+int fts_secure_init(struct fts_ts_info *info)
+{
+	int ret;
+	struct fts_secure_info *scr_info = kmalloc(sizeof(*scr_info), GFP_KERNEL);
+	if (!scr_info) {
+		logError(1, "%s %s alloc fts_secure_info failed\n", tag, __func__);
+		return -ENOMEM;
+	}
+
+	logError(1, "%s fts_secure_init\n", tag);
+
+	mutex_init(&scr_info->palm_lock);
+
+	init_completion(&scr_info->st_powerdown);
+	init_completion(&scr_info->st_irq_processed);
+
+	atomic_set(&scr_info->st_enabled, 0);
+	atomic_set(&scr_info->st_pending_irqs, 0);
+
+	info->secure_info = scr_info;
+
+	ret = sysfs_create_file(&info->dev->kobj, &dev_attr_secure_touch_enable.attr);
+	if (ret < 0) {
+		logError(1, "%s %s create sysfs attribute secure_touch_enable failed\n", tag, __func__);
+		goto err;
+	}
+
+	ret = sysfs_create_file(&info->dev->kobj, &dev_attr_secure_touch.attr);
+	if (ret < 0) {
+		logError(1, "%s %s create sysfs attribute secure_touch failed\n", tag, __func__);
+		goto err;
+	}
+
+	scr_info->fts_info = info;
+	scr_info->secure_inited = true;
+
+	return 0;
+
+err:
+	kfree(scr_info);
+	info->secure_info = NULL;
+	return ret;
+}
+
+void fts_secure_remove(struct fts_ts_info *info)
+{
+	struct fts_secure_info *scr_info = info->secure_info;
+
+	sysfs_remove_file(&info->dev->kobj, &dev_attr_secure_touch_enable.attr);
+	sysfs_remove_file(&info->dev->kobj, &dev_attr_secure_touch.attr);
+	kfree(scr_info);
+}
+
+#endif
+
+
+/**
+ * Probe function, called when the driver it is matched with a device with the same name compatible name
+ * This function allocate, initialize and define all the most important function and flow that are used by the driver to operate with the IC.
+ * It allocates device variables, initialize queues and schedule works, registers the IRQ handler, suspend/resume callbacks, registers the device to the linux input subsystem etc.
+ */
+#ifdef I2C_INTERFACE
+static int fts_probe(struct i2c_client *client)
+{
+#else
+static int fts_probe(struct spi_device *client)
+{
+#endif
+
+	struct fts_ts_info *info = NULL;
+	int error = 0;
+	struct device_node *dp = client->dev.of_node;
+	int retval;
+	int skip_5_1 = 0;
+	u16 bus_type;
+	u8 *tp_maker;
+
+	logError(1, "%s %s: driver ver: %s\n", tag, __func__,
+		 FTS_TS_DRV_VERSION);
+
+#ifdef I2C_INTERFACE
+	logError(0, "%s I2C interface... \n", tag);
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		logError(1, "%s Unsupported I2C functionality\n", tag);
+		error = -EIO;
+		goto ProbeErrorExit_0;
+	}
+
+	logError(0, "%s i2c address: %x \n", tag, client->addr);
+	bus_type = BUS_I2C;
+#else
+	logError(0, "%s SPI interface... \n", tag);
+	client->mode = SPI_MODE_0;
+#ifndef SPI4_WIRE
+	client->mode |= SPI_3WIRE;
+#endif
+	client->max_speed_hz = SPI_CLOCK_FREQ;
+	client->bits_per_word = 8;
+	if (spi_setup(client) < 0) {
+		logError(1, "%s Unsupported SPI functionality\n", tag);
+		error = -EIO;
+		goto ProbeErrorExit_0;
+	}
+	bus_type = BUS_SPI;
+#endif
+
+	logError(0, "%s SET Device driver INFO: \n", tag);
+
+	info = kzalloc(sizeof(struct fts_ts_info), GFP_KERNEL);
+	if (!info) {
+		logError(1,
+			 "%s Out of memory... Impossible to allocate struct info!\n",
+			 tag);
+		error = -ENOMEM;
+		goto ProbeErrorExit_0;
+	}
+
+	fts_info = info;
+	info->client = client;
+	info->dev = &info->client->dev;
+	dev_set_drvdata(info->dev, info);
+
+	if (dp) {
+		info->board =
+		    devm_kzalloc(&client->dev,
+				 sizeof(struct fts_hw_platform_data),
+				 GFP_KERNEL);
+		if (!info->board) {
+			logError(1, "%s ERROR:info.board kzalloc failed \n",
+				 tag);
+			error = -ENOMEM;
+			goto ProbeErrorExit_1;
+		}
+		parse_dt(&client->dev, info->board);
+	}
+
+	logError(0, "%s SET Regulators: \n", tag);
+	retval = fts_get_reg(info, true);
+	if (retval < 0) {
+		logError(1, "%s ERROR: %s: Failed to get regulators\n", tag,
+			 __func__);
+		error = retval;
+		goto ProbeErrorExit_1;
+	}
+
+	retval = fts_enable_reg(info, true);
+	if (retval < 0) {
+		logError(1, "%s %s: ERROR Failed to enable regulators\n", tag,
+			 __func__);
+		error = retval;
+		goto ProbeErrorExit_2;
+	}
+
+	logError(0, "%s SET GPIOS: \n", tag);
+	retval = fts_set_gpio(info);
+	if (retval < 0) {
+		logError(1, "%s %s: ERROR Failed to set up GPIO's\n", tag,
+			 __func__);
+		error = retval;
+		goto ProbeErrorExit_2;
+	}
+
+	error = fts_pinctrl_init(info);
+
+	if (!error && info->ts_pinctrl) {
+		error =
+		    pinctrl_select_state(info->ts_pinctrl,
+					 info->pinctrl_state_active);
+
+		if (error < 0) {
+			dev_err(&client->dev,
+				"%s: Failed to select %s pinstate %d\n",
+				__func__, PINCTRL_STATE_ACTIVE, error);
+		}
+	} else {
+		dev_err(&client->dev, "%s: Failed to init pinctrl\n", __func__);
+	}
+
+	info->client->irq = gpio_to_irq(info->board->irq_gpio);
+
+	logError(0, "%s SET Event Handler: \n", tag);
+
+	info->event_wq =
+	    alloc_workqueue("fts-event-queue",
+			    WQ_UNBOUND | WQ_HIGHPRI | WQ_CPU_INTENSIVE, 1);
+	if (!info->event_wq) {
+		logError(1, "%s ERROR: Cannot create work thread\n", tag);
+		error = -ENOMEM;
+		goto ProbeErrorExit_4;
+	}
+
+	info->irq_wq =
+	    alloc_workqueue("fts-irq-queue",
+			    WQ_UNBOUND | WQ_HIGHPRI | WQ_CPU_INTENSIVE, 1);
+	if (!info->irq_wq) {
+		logError(1, "%s ERROR: Cannot create irq work thread\n", tag);
+		error = -ENOMEM;
+		goto ProbeErrorExit_4;
+	}
+
+	INIT_WORK(&info->resume_work, fts_resume_work);
+	INIT_WORK(&info->suspend_work, fts_suspend_work);
+	INIT_WORK(&info->sleep_work, fts_ts_sleep_work);
+	INIT_WORK(&info->mode_handler_work, fts_mode_handler_work);
+	init_completion(&info->tp_reset_completion);
+	logError(0, "%s SET Input Device Property: \n", tag);
+	info->dev = &info->client->dev;
+	info->input_dev = input_allocate_device();
+	if (!info->input_dev) {
+		logError(1, "%s ERROR: No such input device defined! \n", tag);
+		error = -ENODEV;
+		goto ProbeErrorExit_5;
+	}
+	info->input_dev->dev.parent = &client->dev;
+	info->input_dev->name = FTS_TS_DRV_NAME;
+	snprintf(fts_ts_phys, sizeof(fts_ts_phys), "%s/input0",
+		 info->input_dev->name);
+	info->input_dev->phys = fts_ts_phys;
+	info->input_dev->id.bustype = bus_type;
+	info->input_dev->id.vendor = 0x0001;
+	info->input_dev->id.product = 0x0002;
+	info->input_dev->id.version = 0x0100;
+	info->input_dev->event = fts_input_event;
+	input_set_drvdata(info->input_dev, info);
+
+	info->input_proc = NULL;
+
+	__set_bit(EV_SYN, info->input_dev->evbit);
+	__set_bit(EV_KEY, info->input_dev->evbit);
+	__set_bit(EV_ABS, info->input_dev->evbit);
+	__set_bit(BTN_TOUCH, info->input_dev->keybit);
+	__set_bit(BTN_TOOL_FINGER, info->input_dev->keybit);
+	/*__set_bit(BTN_TOOL_PEN, info->input_dev->keybit);*/
+
+	input_mt_init_slots(info->input_dev, TOUCH_ID_MAX, INPUT_MT_DIRECT);
+
+	/*input_mt_init_slots(info->input_dev, TOUCH_ID_MAX); */
+
+	input_set_abs_params(info->input_dev, ABS_MT_POSITION_X, X_AXIS_MIN,
+		     info->board->x_max - 1, 0, 0);
+	input_set_abs_params(info->input_dev, ABS_MT_POSITION_Y, Y_AXIS_MIN,
+		     info->board->y_max - 1, 0, 0);
+	input_set_abs_params(info->input_dev, ABS_MT_TOUCH_MAJOR, AREA_MIN,
+			     AREA_MAX, 0, 0);
+	input_set_abs_params(info->input_dev, ABS_MT_TOUCH_MINOR, AREA_MIN,
+			     AREA_MAX, 0, 0);
+	input_set_abs_params(info->input_dev, ABS_MT_WIDTH_MINOR, AREA_MIN,
+			     AREA_MAX, 0, 0);
+	input_set_abs_params(info->input_dev, ABS_MT_WIDTH_MAJOR, AREA_MIN,
+			     AREA_MAX, 0, 0);
+
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	/*input_set_abs_params(info->input_dev, ABS_MT_PRESSURE, PRESSURE_MIN, PRESSURE_MAX, 0, 0);*/
+#endif
+	input_set_abs_params(info->input_dev, ABS_MT_DISTANCE, DISTANCE_MIN,
+			     DISTANCE_MAX, 0, 0);
+
+#ifdef GESTURE_MODE
+	input_set_capability(info->input_dev, EV_KEY, KEY_WAKEUP);
+
+	input_set_capability(info->input_dev, EV_KEY, KEY_M);
+	input_set_capability(info->input_dev, EV_KEY, KEY_O);
+	input_set_capability(info->input_dev, EV_KEY, KEY_E);
+	input_set_capability(info->input_dev, EV_KEY, KEY_W);
+	input_set_capability(info->input_dev, EV_KEY, KEY_C);
+	input_set_capability(info->input_dev, EV_KEY, KEY_L);
+	input_set_capability(info->input_dev, EV_KEY, KEY_F);
+	input_set_capability(info->input_dev, EV_KEY, KEY_V);
+	input_set_capability(info->input_dev, EV_KEY, KEY_S);
+	input_set_capability(info->input_dev, EV_KEY, KEY_Z);
+	input_set_capability(info->input_dev, EV_KEY, KEY_WWW);
+
+	input_set_capability(info->input_dev, EV_KEY, KEY_LEFT);
+	input_set_capability(info->input_dev, EV_KEY, KEY_RIGHT);
+	input_set_capability(info->input_dev, EV_KEY, KEY_UP);
+	input_set_capability(info->input_dev, EV_KEY, KEY_DOWN);
+
+	input_set_capability(info->input_dev, EV_KEY, KEY_F1);
+	input_set_capability(info->input_dev, EV_KEY, KEY_F2);
+	input_set_capability(info->input_dev, EV_KEY, KEY_F3);
+	input_set_capability(info->input_dev, EV_KEY, KEY_F4);
+	input_set_capability(info->input_dev, EV_KEY, KEY_F5);
+
+	input_set_capability(info->input_dev, EV_KEY, KEY_LEFTBRACE);
+	input_set_capability(info->input_dev, EV_KEY, KEY_RIGHTBRACE);
+#endif
+
+#ifdef PHONE_KEY
+	/*KEY associated to the touch screen buttons */
+	input_set_capability(info->input_dev, EV_KEY, KEY_HOMEPAGE);
+	input_set_capability(info->input_dev, EV_KEY, KEY_BACK);
+	input_set_capability(info->input_dev, EV_KEY, KEY_MENU);
+#endif
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	input_set_capability(info->input_dev, EV_KEY, BTN_INFO);
+	input_set_capability(info->input_dev, EV_KEY, KEY_INFO);
+	input_set_capability(info->input_dev, EV_KEY, KEY_GOTO);
+#endif
+	mutex_init(&(info->input_report_mutex));
+#ifdef GESTURE_MODE
+	mutex_init(&gestureMask_mutex);
+#endif
+
+	spin_lock_init(&fts_int);
+
+	/* register the multi-touch input device */
+	error = input_register_device(info->input_dev);
+	if (error) {
+		logError(1, "%s ERROR: No such input device\n", tag);
+		error = -ENODEV;
+		goto ProbeErrorExit_5_1;
+	}
+
+	retval = fts_input_symlink(info);
+	if (retval < 0) {
+		logError(1, "%s ERROR: fts_ts_info is NULL\n", tag);
+	}
+
+	skip_5_1 = 1;
+	/* track slots */
+	info->touch_id = 0;
+#ifdef STYLUS_MODE
+	info->stylus_id = 0;
+#endif
+
+	/* init feature switches (by default all the features are disable, if one feature want to be enabled from the start, set the corresponding value to 1) */
+	info->gesture_enabled = 0;
+	info->glove_enabled = 0;
+	info->charger_enabled = 0;
+	info->cover_enabled = 0;
+	info->grip_enabled = 0;
+	info->grip_pixel_def = 30;
+	info->grip_pixel = info->grip_pixel_def;
+
+	info->resume_bit = 1;
+	info->lockdown_is_ok = false;
+/*
+#ifdef CONFIG_DRM
+	info->notifier = fts_noti_block;
+#endif
+*/
+	logError(0, "%s Init Core Lib: \n", tag);
+	initCore(info);
+	/* init hardware device */
+	logError(0, "%s Device Initialization: \n", tag);
+	error = fts_init(info);
+	if (error < OK) {
+		logError(1, "%s Cannot initialize the device ERROR %08X\n", tag,
+			 error);
+		error = -ENODEV;
+		goto ProbeErrorExit_6;
+	}
+	/*update_hardware_info(TYPE_TOUCH, 4);*/
+
+#ifdef CONFIG_SECURE_TOUCH
+	logError(1, "%s %s create secure touch file...\n", tag, __func__);
+	error = fts_secure_init(info);
+	if (error < 0) {
+		logError(1, "%s %s init secure touch failed\n", tag, __func__);
+		goto ProbeErrorExit_7;
+	}
+	logError(1, "%s %s create secure touch file successful\n", tag, __func__);
+	fts_secure_stop(info, 1);
+#endif
+
+#ifdef CONFIG_I2C_BY_DMA
+	/*dma buf init*/
+	info->dma_buf = (struct fts_dma_buf *)kzalloc(sizeof(*info->dma_buf), GFP_KERNEL);
+	if (!info->dma_buf) {
+		logError(1, "%s %s:ERROR alloc mem failed!", tag, __func__);
+		goto ProbeErrorExit_7;
+	}
+	mutex_init(&info->dma_buf->dmaBufLock);
+	info->dma_buf->rdBuf = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!info->dma_buf->rdBuf) {
+		logError(1, "%s %s:ERROR alloc mem failed!", tag, __func__);
+		goto ProbeErrorExit_7;
+	}
+	info->dma_buf->wrBuf = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!info->dma_buf->wrBuf) {
+		logError(1, "%s %s:ERROR alloc mem failed!", tag, __func__);
+		goto ProbeErrorExit_7;
+	}
+#endif
+
+	error = fts_get_lockdown_info(info->lockdown_info, info);
+
+	if (error < OK)
+		logError(1, "%s can't get lockdown info", tag);
+	else {
+		logError(1,
+			 "%s Lockdown:0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x\n",
+			 tag, info->lockdown_info[0], info->lockdown_info[1],
+			 info->lockdown_info[2], info->lockdown_info[3],
+			 info->lockdown_info[4], info->lockdown_info[5],
+			 info->lockdown_info[6], info->lockdown_info[7]);
+		info->lockdown_is_ok = true;
+		/*update_hardware_info(TYPE_TP_MAKER, info->lockdown_info[0] - 0x30); */
+	}
+
+#ifdef FW_UPDATE_ON_PROBE
+	logError(1, "%s FW Update and Sensing Initialization: \n", tag);
+	error = fts_fw_update(info, NULL, 0);
+	if (error < OK) {
+		logError(1,
+			 "%s Cannot execute fw upgrade the device ERROR %08X\n",
+			 tag, error);
+		error = -ENODEV;
+		goto ProbeErrorExit_7;
+	}
+#else
+	logError(0, "%s SET Auto Fw Update: \n", tag);
+	info->fwu_workqueue =
+	    alloc_workqueue("fts-fwu-queue",
+			    WQ_UNBOUND | WQ_HIGHPRI | WQ_CPU_INTENSIVE, 1);
+	if (!info->fwu_workqueue) {
+		logError(1, "%s ERROR: Cannot create fwu work thread\n", tag);
+		goto ProbeErrorExit_7;
+	}
+	INIT_DELAYED_WORK(&info->fwu_work, fts_fw_update_auto);
+#endif
+	info->sensor_scan = true;
+
+	logError(0, "%s SET Device File Nodes: \n", tag);
+	/* sysfs stuff */
+	info->attrs.attrs = fts_attr_group;
+	error = sysfs_create_group(&info->input_dev->dev.kobj, &info->attrs);
+	if (error) {
+		logError(1, "%s ERROR: Cannot create sysfs structure!\n", tag);
+		error = -ENODEV;
+		goto ProbeErrorExit_7;
+	}
+
+	error = fts_proc_init();
+	if (error < OK)
+		logError(1, "%s Error: can not create /proc file! \n", tag);
+	info->dbclick_count = 0;
+
+	tp_maker = kzalloc(20, GFP_KERNEL);
+	if (tp_maker == NULL)
+		logError(1, "%s fail to alloc vendor name memory\n", tag);
+	else {
+		kfree(tp_maker);
+		tp_maker = NULL;
+	}
+	device_init_wakeup(&client->dev, 1);
+
+	init_completion(&info->pm_resume_completion);
+#ifdef CONFIG_TOUCHSCREEN_ST_DEBUG_FS
+	info->debugfs = debugfs_create_dir("tp_debug", NULL);
+	if (info->debugfs) {
+		debugfs_create_file("switch_state", 0660, info->debugfs, info,
+				    &tpdbg_operations);
+	}
+#endif
+
+	if (info->fts_tp_class == NULL)
+		info->fts_tp_class = class_create("touch");
+	info->fts_touch_dev =
+	    device_create(info->fts_tp_class, NULL, 0x49, info, "tp_dev");
+
+	if (IS_ERR(info->fts_touch_dev)) {
+		logError(1,
+			 "%s ERROR: Failed to create device for the sysfs!\n",
+			 tag);
+		goto ProbeErrorExit_8;
+	}
+
+	dev_set_drvdata(info->fts_touch_dev, info);
+#ifdef CONFIG_FTS_TOUCH_COUNT_DUMP
+	error =
+	    sysfs_create_file(&info->fts_touch_dev->kobj,
+			      &dev_attr_touch_suspend_notify.attr);
+
+	if (error) {
+		logError(1, "%s ERROR: Failed to create sysfs group!\n", tag);
+		goto ProbeErrorExit_8;
+	}
+#endif
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+	mutex_init(&(info->fod_mutex));
+
+	error =
+	    sysfs_create_file(&info->fts_touch_dev->kobj,
+			      &dev_attr_fod_status.attr);
+	if (error) {
+		logError(1, "%s ERROR: Failed to create fod_status sysfs group!\n", tag);
+	}
+	error =
+	    sysfs_create_file(&info->fts_touch_dev->kobj,
+			      &dev_attr_fod_test.attr);
+	if (error) {
+		logError(1, "%s ERROR: Failed to create fod_test sysfs group!\n", tag);
+	}
+#endif
+	info->tp_lockdown_info_proc =
+	    proc_create("tp_lockdown_info", 0444, NULL, &fts_lockdown_info_ops);
+	info->tp_selftest_proc =
+	    proc_create("tp_selftest", 0644, NULL, &fts_selftest_ops);
+	info->tp_data_dump_proc =
+	    proc_create("tp_data_dump", 0444, NULL, &fts_datadump_ops);
+	info->tp_fw_version_proc =
+	    proc_create("tp_fw_version", 0444, NULL, &fts_fw_version_ops);
+
+#ifndef FW_UPDATE_ON_PROBE
+	queue_delayed_work(info->fwu_workqueue, &info->fwu_work,
+			   msecs_to_jiffies(EXP_FN_WORK_DELAY_MS));
+#endif
+
+	logError(1, "%s Probe Finished! \n", tag);
+	return OK;
+ProbeErrorExit_8:
+	device_destroy(info->fts_tp_class, 0x49);
+	class_destroy(info->fts_tp_class);
+	info->fts_tp_class = NULL;
+ProbeErrorExit_7:
+#ifdef CONFIG_SECURE_TOUCH
+	fts_secure_remove(info);
+#endif
+#ifdef CONFIG_I2C_BY_DMA
+	if (info->dma_buf)
+		kfree(info->dma_buf);
+	if (info->dma_buf->rdBuf)
+		kfree(info->dma_buf->rdBuf);
+	if (info->dma_buf->wrBuf)
+		kfree(info->dma_buf->wrBuf);
+#endif
+/*
+#ifdef CONFIG_DRM
+	msm_drm_unregister_client(&info->notifier);
+#endif
+*/
+ProbeErrorExit_6:
+	input_unregister_device(info->input_dev);
+
+ProbeErrorExit_5_1:
+	if (skip_5_1 != 1)
+		input_free_device(info->input_dev);
+
+ProbeErrorExit_5:
+	destroy_workqueue(info->event_wq);
+
+ProbeErrorExit_4:
+	fts_enable_reg(info, false);
+
+ProbeErrorExit_2:
+	fts_get_reg(info, false);
+
+ProbeErrorExit_1:
+	kfree(info);
+
+ProbeErrorExit_0:
+	logError(1, "%s Probe Failed!\n", tag);
+
+	return error;
+}
+
+/**
+ * Clear and free all the resources associated to the driver.
+ * This function is called when the driver need to be removed.
+ */
+#ifdef I2C_INTERFACE
+static void fts_remove(struct i2c_client *client)
+{
+#else
+static int fts_remove(struct spi_device *client)
+{
+#endif
+
+	struct fts_ts_info *info = dev_get_drvdata(&(client->dev));
+
+	fts_proc_remove();
+	/* sysfs stuff */
+	sysfs_remove_group(&client->dev.kobj, &info->attrs);
+	/* remove interrupt and event handlers */
+	fts_interrupt_uninstall(info);
+/*
+#ifdef CONFIG_DRM
+	msm_drm_unregister_client(&info->notifier);
+#endif
+*/
+	/* unregister the device */
+	input_unregister_device(info->input_dev);
+
+	/* Remove the work thread */
+	destroy_workqueue(info->event_wq);
+#ifndef FW_UPDATE_ON_PROBE
+	destroy_workqueue(info->fwu_workqueue);
+#endif
+#ifdef CONFIG_FTS_TOUCH_COUNT_DUMP
+	if (info->board->dump_click_count && !info->current_clicknum_file) {
+		kfree(info->current_clicknum_file);
+		info->current_clicknum_file = NULL;
+	}
+	sysfs_remove_file(&info->fts_touch_dev->kobj,
+			  &dev_attr_touch_suspend_notify.attr);
+#endif
+
+	device_destroy(info->fts_tp_class, DCHIP_ID_0);
+	class_destroy(info->fts_tp_class);
+	info->fts_tp_class = NULL;
+
+	fts_enable_reg(info, false);
+	fts_get_reg(info, false);
+	fts_info = NULL;
+#ifdef CONFIG_SECURE_TOUCH
+	fts_secure_remove(info);
+#endif
+	/* free all */
+	kfree(info);
+
+	return ((void)0x00000000);
+}
+
+/**
+* Struct which contains the compatible names that need to match with the definition of the device in the device tree node
+*/
+static struct of_device_id fts_of_match_table[] = {
+	{
+	 .compatible = "st,fts",
+	 },
+	{},
+};
+
+#ifdef I2C_INTERFACE
+static const struct i2c_device_id fts_device_id[] = {
+	{FTS_TS_DRV_NAME, 0},
+	{}
+};
+
+static struct i2c_driver fts_i2c_driver = {
+	.driver = {
+		   .name = FTS_TS_DRV_NAME,
+		   .of_match_table = fts_of_match_table,
+#ifdef CONFIG_PM
+		   .pm = &fts_dev_pm_ops,
+#endif
+		   },
+	.probe = fts_probe,
+	.remove = fts_remove,
+	.id_table = fts_device_id,
+};
+#else
+static struct spi_driver fts_spi_driver = {
+	.driver = {
+		   .name = FTS_TS_DRV_NAME,
+		   .of_match_table = fts_of_match_table,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = fts_probe,
+	.remove = fts_remove,
+};
+#endif
+
+static int __init fts_driver_init(void)
+{
+#ifdef I2C_INTERFACE
+	return i2c_add_driver(&fts_i2c_driver);
+#else
+	return spi_register_driver(&fts_spi_driver);
+#endif
+}
+
+static void __exit fts_driver_exit(void)
+{
+#ifdef I2C_INTERFACE
+	i2c_del_driver(&fts_i2c_driver);
+#else
+	spi_unregister_driver(&fts_spi_driver);
+#endif
+
+}
+
+MODULE_DESCRIPTION("STMicroelectronics MultiTouch IC Driver");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL");
+
+late_initcall(fts_driver_init);
+module_exit(fts_driver_exit);
diff --git a/drivers/input/touchscreen/stfts/fts.h b/drivers/input/touchscreen/stfts/fts.h
new file mode 100644
index 000000000000..6a17085da88b
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts.h
@@ -0,0 +1,393 @@
+/*
+ * fts.c
+ *
+ * FTS Capacitive touch screen controller (FingerTipS)
+ *
+ * Copyright (C) 2017, STMicroelectronics
+ * Authors: AMG(Analog Mems Group)
+ *
+ * 		marco.cali@st.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ * THIS SOFTWARE IS SPECIFICALLY DESIGNED FOR EXCLUSIVE USE WITH ST PARTS.
+ */
+
+/*!
+* \file fts.h
+* \brief Contains all the definitions and structs used generally by the driver
+*/
+
+#ifndef _LINUX_FTS_I2C_H_
+#define _LINUX_FTS_I2C_H_
+
+#include <linux/workqueue.h>
+#include <linux/sysfs.h>
+#include <linux/notifier.h>
+#include <linux/mutex.h>
+#include "fts_lib/ftsSoftware.h"
+#include "fts_lib/ftsHardware.h"
+#include <linux/completion.h>
+/****************** CONFIGURATION SECTION ******************/
+/** @defgroup conf_section	 Driver Configuration Section
+* Settings of the driver code in order to suit the HW set up and the application behavior
+* @{
+*/
+
+/**** CODE CONFIGURATION ****/
+#define FTS_TS_DRV_NAME                     "fts"			/*driver name*/
+#define FTS_TS_DRV_VERSION                  "5.2.4"			/*driver version string format*/
+#define FTS_TS_DRV_VER						0x05020400		/*driver version u32 format*/
+
+#define PINCTRL_STATE_ACTIVE		"pmx_ts_active"
+#define PINCTRL_STATE_SUSPEND		"pmx_ts_suspend"
+#define PINCTRL_STATE_RELEASE		"pmx_ts_release"
+
+
+#define DRIVER_TEST
+
+#define PRE_SAVED_METHOD
+
+/*#define FW_H_FILE*/
+#define FW_UPDATE_ON_PROBE
+#ifdef FW_H_FILE
+#define FW_SIZE_NAME myArray_size
+#define FW_ARRAY_NAME myArray
+#endif
+
+/*#define LIMITS_H_FILE*/
+#ifdef LIMITS_H_FILE
+#define LIMITS_SIZE_NAME myArray2_size
+#define LIMITS_ARRAY_NAME myArray2
+#endif
+
+
+/*#define USE_ONE_FILE_NODE*/
+
+#ifndef FW_UPDATE_ON_PROBE
+#define EXP_FN_WORK_DELAY_MS				1000
+#endif
+
+/**** END ****/
+
+/**** FEATURES USED IN THE IC ****/
+
+/*#define PHONE_KEY*/
+
+#define GESTURE_MODE
+#ifdef GESTURE_MODE
+#define USE_GESTURE_MASK
+#endif
+
+#define CHARGER_MODE
+
+#define GLOVE_MODE
+
+#define COVER_MODE
+
+#define STYLUS_MODE
+
+
+/**** END ****/
+
+/**** PANEL SPECIFICATION ****/
+#define X_AXIS_MAX                          1080
+#define X_AXIS_MIN                          0
+#define Y_AXIS_MAX                          2340
+#define Y_AXIS_MIN                          0
+
+#define PRESSURE_MIN                        0
+#ifdef CONFIG_INPUT_PRESS_NDT
+#define PRESSURE_MAX                        2048
+#else
+#define PRESSURE_MAX                        127
+#endif
+
+#define DISTANCE_MIN						0
+#define DISTANCE_MAX						127
+
+#define TOUCH_ID_MAX                        10
+
+#define AREA_MIN                            PRESSURE_MIN
+#define AREA_MAX                            PRESSURE_MAX
+/**** END ****/
+/**@}*/
+/*********************************************************/
+
+/*
+ * Configuration mode
+ *
+ * bitmask which can assume the value defined as features in ftsSoftware.h or the following values
+ */
+
+/** @defgroup mode_section	 IC Status Mode
+* Bitmask which keeps track of the features and working mode enabled in the IC.
+* The meaning of the the LSB of the bitmask must be interpreted considering that the value defined in @link feat_opt Feature Selection Option @endlink correspond to the position of the corresponding bit in the mask
+* @{
+*/
+#define MODE_NOTHING						0x00000000
+#define MODE_ACTIVE(_mask, _sett)\
+do {\
+	_mask |= (SCAN_MODE_ACTIVE << 24)|(_sett << 16);\
+} while (0)
+#define MODE_LOW_POWER(_mask, _sett)\
+do {\
+	_mask |= (SCAN_MODE_LOW_POWER << 24)|(_sett << 16);\
+} while (0)
+/** @}*/
+
+#define CMD_STR_LEN							32
+
+#define TSP_BUF_SIZE						PAGE_SIZE
+
+#ifdef CONFIG_FTS_TOUCH_COUNT_DUMP
+#define TOUCH_COUNT_FILE_MAXSIZE 50
+#endif
+
+/**
+ * Struct which contains information about the HW platform and set up
+ */
+#define FTS_LOCKDOWN_SIZE 8
+#define FTS_RESULT_INVALID 0
+#define FTS_RESULT_PASS 2
+#define FTS_RESULT_FAIL 1
+
+struct fts_config_info {
+	u8 tp_vendor;
+	u8 tp_color;
+	u8 tp_hw_version;
+	const char *fts_cfg_name;
+	const char *fts_limit_name;
+#ifdef CONFIG_FTS_TOUCH_COUNT_DUMP
+		const char *clicknum_file_name;
+#endif
+};
+
+struct fts_hw_platform_data {
+	int (*power) (bool on);
+	int irq_gpio;
+	int reset_gpio;
+	unsigned long irq_flags;
+	unsigned int x_max;
+	unsigned int y_max;
+	const char *vdd_reg_name;
+	const char *avdd_reg_name;
+	const char *default_fw_name;
+	size_t config_array_size;
+	struct fts_config_info *config_array;
+	int current_index;
+#ifdef PHONE_KEY
+	size_t nbuttons;
+	int *key_code;
+#endif
+#ifdef CONFIG_FTS_TOUCH_COUNT_DUMP
+	bool dump_click_count;
+#endif
+	unsigned long keystates;
+};
+
+/*
+ * Forward declaration
+ */
+struct fts_ts_info;
+extern char tag[8];
+
+/*
+ * Dispatch event handler
+ */
+typedef void (*event_dispatch_handler_t)
+ (struct fts_ts_info *info, unsigned char *data);
+
+#ifdef CONFIG_SECURE_TOUCH
+struct fts_secure_delay {
+	bool palm_pending;
+	int palm_value;
+};
+
+struct fts_secure_info {
+	bool secure_inited;
+	atomic_t st_1st_complete;
+	atomic_t st_enabled;
+	atomic_t st_pending_irqs;
+	struct completion st_irq_processed;
+	struct completion st_powerdown;
+	struct fts_secure_delay scr_delay;
+	struct mutex palm_lock;
+	void *fts_info;
+};
+#endif
+
+#ifdef CONFIG_I2C_BY_DMA
+struct fts_dma_buf {
+	struct mutex dmaBufLock;
+	u8 *rdBuf;
+	u8 *wrBuf;
+};
+#endif
+
+
+/**
+ * FTS capacitive touch screen device information
+ * - dev             Pointer to the structure device \n
+ * - client          client structure \n
+ * - input_dev       Input device structure \n
+ * - work            Work thread \n
+ * - event_wq        Event queue for work thread \n
+ * - event_dispatch_table  Event dispatch table handlers \n
+ * - attrs           SysFS attributes \n
+ * - mode            Device operating mode (bitmask) \n
+ * - touch_id        Bitmask for touch id (mapped to input slots) \n
+ * - stylus_id       Bitmask for tracking the stylus touches (mapped using the touchId) \n
+ * - timer           Timer when operating in polling mode \n
+ * - power           Power on/off routine \n
+ * - board           HW info retrieved from device tree \n
+ * - vdd_reg         DVDD power regulator \n
+ * - avdd_reg        AVDD power regulator \n
+ * - resume_bit      Indicate if screen off/on \n
+ * - fwupdate_stat   Store the result of a fw update triggered by the host \n
+ * - notifier        Used for be notified from a suspend/resume event \n
+ * - sensor_sleep    true suspend was called, false resume was called \n
+ * - wakelock        Wake Lock struct \n
+ * - input_report_mutex  mutex for handling the pressure of keys \n
+ * - series_of_switches  to store the enabling status of a particular feature from the host \n
+ */
+struct fts_ts_info {
+	struct device *dev;
+#ifdef I2C_INTERFACE
+	struct i2c_client *client;
+#else
+	struct spi_device *client;
+#endif
+	struct input_dev *input_dev;
+
+	struct work_struct work;
+	struct work_struct suspend_work;
+	struct work_struct resume_work;
+	struct work_struct mode_handler_work;
+	struct work_struct cmd_update_work;
+	struct work_struct sleep_work;
+	struct workqueue_struct *event_wq;
+	struct workqueue_struct *irq_wq;
+	struct workqueue_struct *touch_feature_wq;
+
+#ifndef FW_UPDATE_ON_PROBE
+	struct delayed_work fwu_work;
+	struct workqueue_struct *fwu_workqueue;
+#endif
+	event_dispatch_handler_t *event_dispatch_table;
+
+	struct attribute_group attrs;
+
+	unsigned int mode;
+	unsigned long touch_id;
+	unsigned long sleep_finger;
+	unsigned long touch_skip;
+	int coor[TOUCH_ID_MAX][2];
+#ifdef STYLUS_MODE
+	unsigned long stylus_id;
+#endif
+	struct fts_hw_platform_data *board;
+	struct regulator *vdd_reg;
+	struct regulator *avdd_reg;
+
+	int resume_bit;
+	int fwupdate_stat;
+
+	struct notifier_block notifier;
+	struct notifier_block bl_notifier;
+	bool sensor_sleep;
+	bool sensor_scan;
+	struct pinctrl *ts_pinctrl;
+	struct pinctrl_state *pinctrl_state_active;
+	struct pinctrl_state *pinctrl_state_suspend;
+	u8 lockdown_info[FTS_LOCKDOWN_SIZE];
+	int result_type;
+	struct proc_dir_entry *tp_selftest_proc;
+	struct proc_dir_entry *tp_data_dump_proc;
+	struct proc_dir_entry *tp_fw_version_proc;
+	struct proc_dir_entry *tp_lockdown_info_proc;
+
+	/* input lock */
+	struct mutex input_report_mutex;
+	int gesture_enabled;
+	int glove_enabled;
+	int charger_enabled;
+	int stylus_enabled;
+	int cover_enabled;
+	unsigned int grip_enabled;
+	unsigned int grip_pixel;
+	unsigned int doze_time;
+	unsigned int grip_pixel_def;
+	unsigned int doze_time_def;
+#ifdef CONFIG_TOUCHSCREEN_ST_DEBUG_FS
+	struct dentry *debugfs;
+#endif
+	int dbclick_count;
+	struct class *fts_tp_class;
+	struct device *fts_touch_dev;
+	char *current_clicknum_file;
+#ifdef CONFIG_SECURE_TOUCH
+	struct fts_secure_info *secure_info;
+#endif
+#ifdef CONFIG_I2C_BY_DMA
+	struct fts_dma_buf *dma_buf;
+#endif
+	bool lockdown_is_ok;
+	bool irq_status;
+	wait_queue_head_t 	wait_queue;
+	struct completion tp_reset_completion;
+	atomic_t system_is_resetting;
+	unsigned int fod_status;
+	unsigned int fod_overlap;
+	unsigned long fod_id;
+	unsigned long fod_x;
+	unsigned long fod_y;
+	struct mutex fod_mutex;
+	struct mutex cmd_update_mutex;
+	bool fod_coordinate_update;
+	bool fod_status_set;
+	bool fod_pressed;
+	bool p_sensor_changed;
+	bool p_sensor_switch;
+	bool palm_sensor_changed;
+	bool palm_sensor_switch;
+	bool tp_pm_suspend;
+	struct completion pm_resume_completion;
+	struct proc_dir_entry *input_proc;
+};
+
+struct fts_mode_switch {
+	struct fts_ts_info *info;
+	unsigned char mode;
+	struct work_struct switch_mode_work;
+};
+
+int fts_chip_powercycle(struct fts_ts_info *info);
+extern int input_register_notifier_client(struct notifier_block *nb);
+extern int input_unregister_notifier_client(struct notifier_block *nb);
+
+extern int fts_proc_init(void);
+extern int fts_proc_remove(void);
+#ifdef CONFIG_FTS_FOD_AREA_REPORT
+#define CENTER_X 540
+#define CENTER_Y 2005
+#define CIRCLE_R 87
+#define FOD_LX 420
+#define FOD_LY 1885
+#define FOD_SIDE 242
+bool fts_is_infod(void);
+void fts_get_pointer(int *touch_flag, int *x, int *y);
+#endif
+void fts_restore_regvalues(void);
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/fts_fw.h b/drivers/input/touchscreen/stfts/fts_fw.h
new file mode 100644
index 000000000000..6821f3945a7b
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_fw.h
@@ -0,0 +1,12573 @@
+/*!
+* \file fts_fw.h
+* \brief Contains the size and the byte array of the fw file to burn into the IC
+*/
+#ifndef FTS_FW_H
+#define FTS_FW_H
+/*This is an auto generated header file*/
+/*--->Remember to change the name of the two variables!<---*/
+const uint32_t myArray_size = 100476;
+
+const uint8_t myArray[] = {
+	0x55, 0xAA, 0x55, 0xAA, 0x01, 0x00, 0x00, 0x00, 0x36, 0x39, 0x00, 0x00,
+	0x33, 0xA2, 0x00, 0x00,
+	0x33, 0xA2, 0x00, 0x00, 0xA1, 0x00, 0xA1, 0x00, 0xA1, 0x00, 0xA1, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xE8, 0x7D, 0x01, 0x00,
+	0x50, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xF3, 0xB0, 0x4F, 0xDA,
+	0x69, 0xDA, 0x63, 0x91, 0x79, 0x5F, 0x00, 0x00, 0x96, 0x25, 0x9C, 0x6E,
+	0x86, 0xA0, 0xFF, 0xFF,
+	0x00, 0x04, 0x10, 0x00, 0xB5, 0x02, 0x00, 0x00, 0x0D, 0x03, 0x00, 0x00,
+	0x27, 0x03, 0x00, 0x00,
+	0x41, 0x03, 0x00, 0x00, 0x5B, 0x03, 0x00, 0x00, 0x75, 0x03, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x85, 0x6E, 0x01, 0x00,
+	0x8D, 0x6E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x03, 0x00, 0x00,
+	0x95, 0x6E, 0x01, 0x00,
+	0x9D, 0x6E, 0x01, 0x00, 0xAB, 0x6E, 0x01, 0x00, 0xB9, 0x6E, 0x01, 0x00,
+	0xC7, 0x6E, 0x01, 0x00,
+	0xD5, 0x6E, 0x01, 0x00, 0xE3, 0x6E, 0x01, 0x00, 0xF1, 0x6E, 0x01, 0x00,
+	0xFF, 0x6E, 0x01, 0x00,
+	0x0D, 0x6F, 0x01, 0x00, 0x9D, 0x03, 0x00, 0x00, 0x1B, 0x6F, 0x01, 0x00,
+	0x29, 0x6F, 0x01, 0x00,
+	0x37, 0x6F, 0x01, 0x00, 0x3F, 0x6F, 0x01, 0x00, 0x47, 0x6F, 0x01, 0x00,
+	0x4F, 0x6F, 0x01, 0x00,
+	0x5D, 0x6F, 0x01, 0x00, 0x65, 0x6F, 0x01, 0x00, 0x6D, 0x6F, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x75, 0x6F, 0x01, 0x00,
+	0x7D, 0x6F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x6F, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x33, 0xA2, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0xF0, 0x02, 0xF8, 0x00, 0xF0, 0x68, 0xF8, 0x0A, 0xA0, 0x90, 0xE8,
+	0x00, 0x0C, 0x82, 0x44,
+	0x83, 0x44, 0xAA, 0xF1, 0x01, 0x07, 0xDA, 0x45, 0x01, 0xD1, 0x00, 0xF0,
+	0x5D, 0xF8, 0xAF, 0xF2,
+	0x09, 0x0E, 0xBA, 0xE8, 0x0F, 0x00, 0x13, 0xF0, 0x01, 0x0F, 0x18, 0xBF,
+	0xFB, 0x1A, 0x43, 0xF0,
+	0x01, 0x03, 0x18, 0x47, 0x1C, 0x7C, 0x01, 0x00, 0x4C, 0x7C, 0x01, 0x00,
+	0x0A, 0x44, 0x4F, 0xF0,
+	0x00, 0x0C, 0x10, 0xF8, 0x01, 0x3B, 0x13, 0xF0, 0x07, 0x04, 0x08, 0xBF,
+	0x10, 0xF8, 0x01, 0x4B,
+	0x1D, 0x11, 0x08, 0xBF, 0x10, 0xF8, 0x01, 0x5B, 0x64, 0x1E, 0x05, 0xD0,
+	0x10, 0xF8, 0x01, 0x6B,
+	0x64, 0x1E, 0x01, 0xF8, 0x01, 0x6B, 0xF9, 0xD1, 0x13, 0xF0, 0x08, 0x0F,
+	0x1E, 0xBF, 0x10, 0xF8,
+	0x01, 0x4B, 0xAD, 0x1C, 0x0C, 0x1B, 0x09, 0xD1, 0x6D, 0x1E, 0x58, 0xBF,
+	0x01, 0xF8, 0x01, 0xCB,
+	0xFA, 0xD5, 0x05, 0xE0, 0x14, 0xF8, 0x01, 0x6B, 0x01, 0xF8, 0x01, 0x6B,
+	0x6D, 0x1E, 0xF9, 0xD5,
+	0x91, 0x42, 0xD6, 0xD3, 0x70, 0x47, 0x00, 0x00, 0x10, 0x3A, 0x24, 0xBF,
+	0x78, 0xC8, 0x78, 0xC1,
+	0xFA, 0xD8, 0x52, 0x07, 0x24, 0xBF, 0x30, 0xC8, 0x30, 0xC1, 0x44, 0xBF,
+	0x04, 0x68, 0x0C, 0x60,
+	0x70, 0x47, 0x00, 0x00, 0x00, 0x23, 0x00, 0x24, 0x00, 0x25, 0x00, 0x26,
+	0x10, 0x3A, 0x28, 0xBF,
+	0x78, 0xC1, 0xFB, 0xD8, 0x52, 0x07, 0x28, 0xBF, 0x30, 0xC1, 0x48, 0xBF,
+	0x0B, 0x60, 0x70, 0x47,
+	0x1F, 0xB5, 0x1F, 0xBD, 0x10, 0xB5, 0x10, 0xBD, 0xDF, 0xF8, 0x0C, 0xD0,
+	0xFF, 0xF7, 0xF8, 0xFF,
+	0x16, 0xF0, 0xE4, 0xFE, 0x17, 0xF0, 0x69, 0xF8, 0x00, 0x04, 0x10, 0x00,
+	0x03, 0xB4, 0xFF, 0xF7,
+	0xF1, 0xFF, 0x03, 0xBC, 0x17, 0xF0, 0x68, 0xF8, 0x0A, 0x48, 0x4F, 0xF0,
+	0xFF, 0x01, 0x01, 0x70,
+	0x4F, 0xF0, 0x00, 0x00, 0x80, 0xF3, 0x11, 0x88, 0x4F, 0xF0, 0x00, 0x00,
+	0x80, 0xF3, 0x09, 0x88,
+	0x05, 0x48, 0x4F, 0xF0, 0x02, 0x01, 0x01, 0x70, 0x62, 0xB6, 0x04, 0x48,
+	0x4F, 0xF0, 0x80, 0x51,
+	0x01, 0x60, 0x70, 0x47, 0x22, 0xED, 0x00, 0xE0, 0x00, 0x04, 0x10, 0x00,
+	0x04, 0xED, 0x00, 0xE0,
+	0x02, 0x48, 0x4F, 0xF0, 0x80, 0x51, 0x01, 0x60, 0x70, 0x47, 0x00, 0x00,
+	0x04, 0xED, 0x00, 0xE0,
+	0x4F, 0xF0, 0x20, 0x00, 0x80, 0xF3, 0x11, 0x88, 0xEF, 0xF3, 0x09, 0x80,
+	0x98, 0xB1, 0x12, 0x48,
+	0x00, 0x68, 0x12, 0x49, 0x09, 0x68, 0x88, 0x42, 0x17, 0xD0, 0xEF, 0xF3,
+	0x09, 0x80, 0x0E, 0x49,
+	0x09, 0x68, 0x20, 0xE9, 0xF0, 0x0F, 0x88, 0x60, 0x00, 0xB5, 0x0B, 0x48,
+	0x00, 0x68, 0x00, 0xF0,
+	0x2F, 0xF9, 0x5D, 0xF8, 0x04, 0xEB, 0x08, 0x48, 0x08, 0x49, 0x0A, 0x68,
+	0x02, 0x60, 0x00, 0x68,
+	0x81, 0x68, 0xB1, 0xE8, 0xF0, 0x0F, 0x81, 0xF3, 0x09, 0x88, 0x4E, 0xF0,
+	0x04, 0x0E, 0x4F, 0xF0,
+	0x00, 0x00, 0x80, 0xF3, 0x11, 0x88, 0x70, 0x47, 0x04, 0x04, 0x10, 0x00,
+	0x08, 0x04, 0x10, 0x00,
+	0xEF, 0xF3, 0x11, 0x80, 0x4F, 0xF0, 0x20, 0x01, 0x81, 0xF3, 0x11, 0x88,
+	0x70, 0x47, 0x00, 0x00,
+	0x4F, 0xF0, 0x00, 0x00, 0x80, 0xF3, 0x11, 0x88, 0x70, 0x47, 0x00, 0x00,
+	0x62, 0xB6, 0x70, 0x47,
+	0x72, 0xB6, 0x70, 0x47, 0x40, 0x1E, 0xFD, 0xD1, 0x70, 0x47, 0x00, 0x00,
+	0x40, 0xBA, 0x70, 0x47,
+	0xC0, 0xBA, 0x70, 0x47, 0x12, 0x48, 0x13, 0x49, 0xA1, 0xEB, 0x00, 0x01,
+	0x4F, 0xF0, 0x20, 0x03,
+	0x91, 0xFB, 0xF3, 0xF2, 0x02, 0xFB, 0x13, 0x11, 0x4F, 0xF0, 0xCC, 0x33,
+	0x4F, 0xF0, 0xCC, 0x34,
+	0x4F, 0xF0, 0xCC, 0x35, 0x4F, 0xF0, 0xCC, 0x36, 0x4F, 0xF0, 0xCC, 0x37,
+	0x4F, 0xF0, 0xCC, 0x38,
+	0x4F, 0xF0, 0xCC, 0x39, 0x4F, 0xF0, 0xCC, 0x3A, 0xA0, 0xE8, 0xF8, 0x07,
+	0x01, 0x3A, 0xFB, 0xD1,
+	0x19, 0xB1, 0x40, 0xF8, 0x04, 0xAB, 0x04, 0x39, 0xFB, 0xD1, 0x03, 0x48,
+	0x00, 0x47, 0x00, 0x00,
+	0x00, 0x00, 0x10, 0x00, 0x00, 0x04, 0x10, 0x00, 0xE1, 0x00, 0x00, 0x00,
+	0x1E, 0xF0, 0x04, 0x0F,
+	0x0C, 0xBF, 0xEF, 0xF3, 0x08, 0x80, 0xEF, 0xF3, 0x09, 0x80, 0x4F, 0xF0,
+	0x01, 0x01, 0x4F, 0xF0,
+	0x00, 0x02, 0x12, 0xF0, 0xBB, 0xB8, 0x1E, 0xF0, 0x04, 0x0F, 0x0C, 0xBF,
+	0xEF, 0xF3, 0x08, 0x80,
+	0xEF, 0xF3, 0x09, 0x80, 0x4F, 0xF0, 0x02, 0x01, 0x4F, 0xF0, 0x00, 0x02,
+	0x12, 0xF0, 0xAE, 0xB8,
+	0x1E, 0xF0, 0x04, 0x0F, 0x0C, 0xBF, 0xEF, 0xF3, 0x08, 0x80, 0xEF, 0xF3,
+	0x09, 0x80, 0x4F, 0xF0,
+	0x03, 0x01, 0x4F, 0xF0, 0x00, 0x02, 0x12, 0xF0, 0xA1, 0xB8, 0x1E, 0xF0,
+	0x04, 0x0F, 0x0C, 0xBF,
+	0xEF, 0xF3, 0x08, 0x80, 0xEF, 0xF3, 0x09, 0x80, 0x4F, 0xF0, 0x04, 0x01,
+	0x4F, 0xF0, 0x00, 0x02,
+	0x12, 0xF0, 0x94, 0xB8, 0x1E, 0xF0, 0x04, 0x0F, 0x0C, 0xBF, 0xEF, 0xF3,
+	0x08, 0x80, 0xEF, 0xF3,
+	0x09, 0x80, 0x4F, 0xF0, 0x05, 0x01, 0x4F, 0xF0, 0x00, 0x02, 0x12, 0xF0,
+	0x87, 0xB8, 0x00, 0xB5,
+	0x16, 0xF0, 0x72, 0xFD, 0x5D, 0xF8, 0x04, 0xEB, 0xFF, 0xF7, 0x42, 0xBF,
+	0x1E, 0xF0, 0x04, 0x0F,
+	0x0C, 0xBF, 0xEF, 0xF3, 0x08, 0x80, 0xEF, 0xF3, 0x09, 0x80, 0x4F, 0xF0,
+	0x06, 0x01, 0x4F, 0xF0,
+	0x00, 0x02, 0x12, 0xF0, 0x73, 0xB8, 0x00, 0x00, 0x19, 0x49, 0x10, 0xB5,
+	0x01, 0x20, 0x08, 0x70,
+	0x18, 0x49, 0x00, 0x20, 0x08, 0x60, 0x18, 0x49, 0x08, 0x60, 0x18, 0x49,
+	0x08, 0x60, 0x18, 0x49,
+	0x08, 0x60, 0x00, 0xF0, 0xBF, 0xF9, 0x00, 0xF0, 0x59, 0xF9, 0x00, 0xF0,
+	0x7D, 0xF8, 0x00, 0x20,
+	0x10, 0xBD, 0x10, 0xB5, 0x11, 0x48, 0x00, 0xF0, 0x38, 0xF9, 0x0F, 0x49,
+	0x08, 0x60, 0x0D, 0x49,
+	0x09, 0x68, 0x88, 0x42, 0x07, 0xD0, 0x0A, 0x48, 0x00, 0x78, 0x02, 0x28,
+	0x03, 0xD1, 0xBD, 0xE8,
+	0x10, 0x40, 0xFF, 0xF7, 0x05, 0xBF, 0x10, 0xBD, 0x10, 0xB5, 0xFF, 0xF7,
+	0xEA, 0xFF, 0x04, 0x49,
+	0x02, 0x20, 0x08, 0x70, 0xFF, 0xF7, 0xE0, 0xFE, 0x4F, 0xF0, 0xFF, 0x30,
+	0x10, 0xBD, 0x00, 0x00,
+	0x00, 0x04, 0x10, 0x00, 0x04, 0x04, 0x10, 0x00, 0x08, 0x04, 0x10, 0x00,
+	0x0C, 0x04, 0x10, 0x00,
+	0x10, 0x04, 0x10, 0x00, 0x70, 0xB5, 0x0D, 0x46, 0x04, 0x46, 0xC1, 0x69,
+	0x80, 0x68, 0xCC, 0x22,
+	0x16, 0xF0, 0xDA, 0xFE, 0xE1, 0x69, 0xA0, 0x68, 0x08, 0x44, 0x4F, 0xF0,
+	0x80, 0x71, 0x40, 0xF8,
+	0x04, 0x1C, 0x21, 0x6A, 0x40, 0xF8, 0x08, 0x1C, 0x00, 0x21, 0x40, 0xF8,
+	0x0C, 0x1C, 0x40, 0xF8,
+	0x10, 0x1C, 0x40, 0xF8, 0x14, 0x1C, 0x40, 0xF8, 0x18, 0x1C, 0x40, 0xE9,
+	0x08, 0x51, 0x4F, 0xF0,
+	0x0B, 0x31, 0x40, 0xF8, 0x24, 0x1C, 0x4F, 0xF0, 0x0A, 0x31, 0x40, 0xF8,
+	0x28, 0x1C, 0x4F, 0xF0,
+	0x09, 0x31, 0x40, 0xF8, 0x2C, 0x1C, 0x4F, 0xF0, 0x08, 0x31, 0x40, 0xF8,
+	0x30, 0x1C, 0x4F, 0xF0,
+	0x07, 0x31, 0x40, 0xF8, 0x34, 0x1C, 0x4F, 0xF0, 0x06, 0x31, 0x40, 0xF8,
+	0x38, 0x1C, 0x4F, 0xF0,
+	0x05, 0x31, 0x40, 0xF8, 0x3C, 0x1C, 0x4F, 0xF0, 0x04, 0x31, 0x40, 0xF8,
+	0x40, 0x1D, 0x70, 0xBD,
+	0x81, 0x69, 0x4F, 0xF0, 0xCC, 0x32, 0x0B, 0x68, 0x93, 0x42, 0x08, 0xD1,
+	0x4B, 0x68, 0x93, 0x42,
+	0x05, 0xD1, 0x8B, 0x68, 0x93, 0x42, 0x02, 0xD1, 0xC9, 0x68, 0x91, 0x42,
+	0x02, 0xD0, 0x40, 0x68,
+	0x12, 0xF0, 0xD9, 0xBB, 0x70, 0x47, 0x00, 0x00, 0x10, 0xB5, 0xA0, 0x21,
+	0x49, 0x48, 0x16, 0xF0,
+	0xB5, 0xFE, 0x00, 0x20, 0x10, 0xBD, 0x70, 0xB5, 0x05, 0x46, 0x46, 0x48,
+	0x00, 0xEB, 0x05, 0x14,
+	0xFF, 0xF7, 0xC6, 0xFE, 0x06, 0x46, 0x20, 0x78, 0x28, 0xB1, 0x30, 0x46,
+	0xFF, 0xF7, 0xC8, 0xFE,
+	0x6F, 0xF0, 0x01, 0x00, 0x70, 0xBD, 0x03, 0x20, 0x20, 0x70, 0x00, 0x20,
+	0x65, 0x60, 0xE0, 0x60,
+	0x04, 0xF1, 0x08, 0x00, 0x00, 0xF0, 0x7A, 0xF8, 0x30, 0x46, 0xFF, 0xF7,
+	0xB9, 0xFE, 0x00, 0x20,
+	0x70, 0xBD, 0x2D, 0xE9, 0xF0, 0x41, 0x0F, 0x46, 0x36, 0x49, 0x00, 0x25,
+	0x01, 0xEB, 0x00, 0x14,
+	0x2E, 0x46, 0xFF, 0xF7, 0xA5, 0xFE, 0x80, 0x46, 0xE0, 0x68, 0x38, 0x43,
+	0xE0, 0x60, 0x04, 0xF1,
+	0x08, 0x00, 0x07, 0x46, 0x00, 0xF0, 0x89, 0xF8, 0x0C, 0xE0, 0xE1, 0x68,
+	0xC2, 0x6A, 0x11, 0x42,
+	0x03, 0xD0, 0x00, 0xF0, 0x4F, 0xF9, 0x01, 0x26, 0x00, 0xE0, 0x6D, 0x1C,
+	0x29, 0x46, 0x38, 0x46,
+	0x00, 0xF0, 0x71, 0xF8, 0x00, 0x28, 0xF0, 0xD1, 0x0E, 0xB1, 0xFF, 0xF7,
+	0x3A, 0xFF, 0x40, 0x46,
+	0xFF, 0xF7, 0x8E, 0xFE, 0x00, 0x20, 0xBD, 0xE8, 0xF0, 0x81, 0x70, 0xB5,
+	0x0D, 0x46, 0x21, 0x49,
+	0x01, 0xEB, 0x00, 0x14, 0xFF, 0xF7, 0x7C, 0xFE, 0xE1, 0x68, 0xA9, 0x43,
+	0xE1, 0x60, 0xFF, 0xF7,
+	0x7F, 0xFE, 0x00, 0x20, 0x70, 0xBD, 0x70, 0xB5, 0x0C, 0x46, 0x1A, 0x49,
+	0x01, 0xEB, 0x00, 0x15,
+	0x00, 0x20, 0x20, 0x60, 0xFF, 0xF7, 0x6C, 0xFE, 0xE9, 0x68, 0x21, 0x60,
+	0xFF, 0xF7, 0x70, 0xFE,
+	0x00, 0x20, 0x70, 0xBD, 0x2D, 0xE9, 0xF0, 0x41, 0x0D, 0x46, 0x12, 0x49,
+	0x1E, 0x46, 0x90, 0x46,
+	0x01, 0xEB, 0x00, 0x14, 0xFF, 0xF7, 0x5C, 0xFE, 0x07, 0x46, 0x0F, 0x48,
+	0x00, 0x68, 0xC5, 0x62,
+	0xE1, 0x68, 0x29, 0x42, 0x03, 0xD1, 0x04, 0xF1, 0x08, 0x01, 0x00, 0xF0,
+	0x1D, 0xF9, 0x38, 0x46,
+	0xFF, 0xF7, 0x56, 0xFE, 0xFF, 0xF7, 0x4C, 0xFE, 0xE1, 0x68, 0x29, 0x40,
+	0x31, 0x60, 0xB8, 0xF1,
+	0x01, 0x0F, 0x02, 0xD1, 0xE1, 0x68, 0xA9, 0x43, 0xE1, 0x60, 0xFF, 0xF7,
+	0x49, 0xFE, 0x00, 0x20,
+	0xB9, 0xE7, 0x00, 0x00, 0x0C, 0x08, 0x10, 0x00, 0x04, 0x04, 0x10, 0x00,
+	0x00, 0x21, 0x01, 0x60,
+	0x08, 0x46, 0x70, 0x47, 0x30, 0xB5, 0x0A, 0x68, 0x12, 0xB1, 0x0B, 0x46,
+	0x84, 0x6A, 0x09, 0xE0,
+	0x00, 0x22, 0x08, 0x60, 0xC0, 0xE9, 0x03, 0x21, 0x0B, 0xE0, 0x00, 0xBF,
+	0x02, 0xF1, 0x0C, 0x03,
+	0xD2, 0x68, 0x12, 0xB1, 0x95, 0x6A, 0xA5, 0x42, 0xF8, 0xDC, 0x1A, 0x68,
+	0xC0, 0xE9, 0x03, 0x21,
+	0x18, 0x60, 0x00, 0x20, 0x30, 0xBD, 0x00, 0x68, 0x00, 0x22, 0x01, 0xE0,
+	0xC0, 0x68, 0x52, 0x1C,
+	0x8A, 0x42, 0x01, 0xD0, 0x00, 0x28, 0xF9, 0xD1, 0x70, 0x47, 0x00, 0x68,
+	0x70, 0x47, 0x02, 0x69,
+	0x0A, 0xB1, 0x11, 0x68, 0x31, 0xB9, 0x6F, 0xF0, 0x04, 0x00, 0x70, 0x47,
+	0x01, 0xF1, 0x0C, 0x02,
+	0xC9, 0x68, 0x39, 0xB1, 0x81, 0x42, 0xF9, 0xD1, 0xC9, 0x68, 0x11, 0x60,
+	0x00, 0x21, 0x01, 0x61,
+	0x08, 0x46, 0x70, 0x47, 0x6F, 0xF0, 0x03, 0x00, 0x70, 0x47, 0x00, 0x00,
+	0x10, 0xB5, 0xC8, 0x21,
+	0x2E, 0x48, 0x16, 0xF0, 0xDB, 0xFD, 0x00, 0x20, 0x10, 0xBD, 0x2D, 0xE9,
+	0xF0, 0x41, 0x05, 0x46,
+	0x2A, 0x49, 0x00, 0xEB, 0x85, 0x00, 0x17, 0x46, 0x01, 0xEB, 0x80, 0x04,
+	0xFF, 0xF7, 0xE8, 0xFD,
+	0x06, 0x46, 0x20, 0x78, 0x30, 0xB1, 0x30, 0x46, 0xFF, 0xF7, 0xEA, 0xFD,
+	0x6F, 0xF0, 0x01, 0x00,
+	0xBD, 0xE8, 0xF0, 0x81, 0x02, 0x20, 0x20, 0x70, 0x00, 0x20, 0x65, 0x60,
+	0xC4, 0xE9, 0x02, 0x70,
+	0x04, 0xF1, 0x10, 0x00, 0xFF, 0xF7, 0x9A, 0xFF, 0x30, 0x46, 0xFF, 0xF7,
+	0xD9, 0xFD, 0x00, 0x20,
+	0xEE, 0xE7, 0x70, 0xB5, 0x19, 0x49, 0x00, 0xEB, 0x80, 0x00, 0x01, 0xEB,
+	0x80, 0x04, 0xFF, 0xF7,
+	0xC7, 0xFD, 0x05, 0x46, 0xD4, 0xE9, 0x02, 0x01, 0x81, 0x42, 0x05, 0xDB,
+	0x14, 0x48, 0x04, 0xF1,
+	0x10, 0x01, 0x00, 0x68, 0x00, 0xF0, 0x88, 0xF8, 0xE0, 0x68, 0x40, 0x1C,
+	0xE0, 0x60, 0x28, 0x46,
+	0xFF, 0xF7, 0xBE, 0xFD, 0x00, 0x20, 0x70, 0xBD, 0x70, 0xB5, 0x0C, 0x49,
+	0x00, 0xEB, 0x80, 0x00,
+	0x01, 0xEB, 0x80, 0x04, 0xFF, 0xF7, 0xAC, 0xFD, 0x05, 0x46, 0xE0, 0x68,
+	0x08, 0xB1, 0x40, 0x1E,
+	0xE0, 0x60, 0x04, 0xF1, 0x10, 0x00, 0xFF, 0xF7, 0x90, 0xFF, 0x10, 0xB1,
+	0x20, 0x69, 0x00, 0xF0,
+	0x11, 0xF8, 0x28, 0x46, 0xFF, 0xF7, 0xA4, 0xFD, 0x00, 0x20, 0x70, 0xBD,
+	0xAC, 0x08, 0x10, 0x00,
+	0x04, 0x04, 0x10, 0x00, 0x10, 0xB5, 0x4F, 0xF4, 0xF0, 0x71, 0x3C, 0x48,
+	0x16, 0xF0, 0x76, 0xFD,
+	0x00, 0x20, 0x10, 0xBD, 0x10, 0xB5, 0x04, 0x46, 0x90, 0xF8, 0x24, 0x00,
+	0x02, 0x28, 0x0B, 0xD0,
+	0x20, 0x46, 0xFF, 0xF7, 0x74, 0xFF, 0x02, 0x20, 0x84, 0xF8, 0x24, 0x00,
+	0x34, 0x49, 0x20, 0x46,
+	0xFF, 0xF7, 0x48, 0xFF, 0xFF, 0xF7, 0x2D, 0xFE, 0x00, 0x20, 0x10, 0xBD,
+	0x2D, 0xE9, 0xF0, 0x5F,
+	0x06, 0x46, 0x0A, 0xA8, 0x06, 0xEB, 0x46, 0x01, 0x90, 0xE8, 0x00, 0x0E,
+	0x2B, 0x48, 0x1D, 0x46,
+	0x00, 0xEB, 0x01, 0x14, 0x90, 0x46, 0x20, 0x78, 0x18, 0xB1, 0x6F, 0xF0,
+	0x01, 0x00, 0xBD, 0xE8,
+	0xF0, 0x9F, 0xFF, 0xF7, 0x65, 0xFD, 0x07, 0x46, 0x01, 0x20, 0x20, 0x70,
+	0xC4, 0xF8, 0x14, 0x80,
+	0xC4, 0xE9, 0x01, 0x65, 0x04, 0xF1, 0x18, 0x01, 0x00, 0x20, 0x81, 0xE8,
+	0x20, 0x06, 0x84, 0xF8,
+	0x24, 0x00, 0xE0, 0x60, 0x20, 0x61, 0xC4, 0xE9, 0x0A, 0x80, 0x59, 0x46,
+	0x20, 0x46, 0xFF, 0xF7,
+	0x29, 0xFE, 0xA0, 0x60, 0x20, 0x46, 0xFF, 0xF7, 0xBD, 0xFF, 0x38, 0x46,
+	0xFF, 0xF7, 0x50, 0xFD,
+	0x00, 0x20, 0xDC, 0xE7, 0x10, 0xB5, 0x04, 0x46, 0x90, 0xF8, 0x24, 0x00,
+	0x02, 0x28, 0x09, 0xD0,
+	0x20, 0x46, 0xFF, 0xF7, 0x2C, 0xFF, 0x02, 0x20, 0x84, 0xF8, 0x24, 0x00,
+	0x10, 0x49, 0x20, 0x46,
+	0xFF, 0xF7, 0x00, 0xFF, 0x00, 0x20, 0x10, 0xBD, 0x70, 0xB5, 0x04, 0x46,
+	0x90, 0xF8, 0x24, 0x00,
+	0x0D, 0x46, 0x02, 0x28, 0x0B, 0xD1, 0x20, 0x46, 0xFF, 0xF7, 0x19, 0xFF,
+	0x03, 0x20, 0x84, 0xF8,
+	0x24, 0x00, 0x29, 0x46, 0x20, 0x46, 0xFF, 0xF7, 0xED, 0xFE, 0xFF, 0xF7,
+	0xD2, 0xFD, 0x00, 0x20,
+	0x70, 0xBD, 0x04, 0x48, 0x00, 0x68, 0x40, 0x68, 0x70, 0x47, 0x00, 0x00,
+	0x74, 0x09, 0x10, 0x00,
+	0x0C, 0x04, 0x10, 0x00, 0x04, 0x04, 0x10, 0x00, 0xA4, 0x22, 0x4F, 0x49,
+	0x16, 0xF0, 0x55, 0xBC,
+	0x70, 0x47, 0x10, 0xB5, 0x04, 0x46, 0x80, 0x07, 0x02, 0xD0, 0x02, 0x20,
+	0x16, 0xF0, 0xA3, 0xF8,
+	0x4F, 0xF4, 0x80, 0x30, 0x20, 0x44, 0xC0, 0xF3, 0x4F, 0x00, 0x10, 0xBD,
+	0x01, 0x46, 0xAC, 0x22,
+	0x46, 0x48, 0x16, 0xF0, 0x87, 0xBC, 0x45, 0x4A, 0x5F, 0xF0, 0x00, 0x01,
+	0x42, 0xF8, 0x21, 0x00,
+	0x49, 0x1C, 0x26, 0x29, 0xFA, 0xDB, 0x70, 0x47, 0x00, 0xF0, 0xF6, 0xBE,
+	0x00, 0xF0, 0x1B, 0xBF,
+	0x1D, 0x20, 0x70, 0x47, 0x26, 0x20, 0x70, 0x47, 0x3D, 0x48, 0x10, 0xB5,
+	0x00, 0x68, 0x10, 0xB1,
+	0xBD, 0xE8, 0x10, 0x40, 0x00, 0x47, 0x00, 0x20, 0x16, 0xF0, 0x7D, 0xF8,
+	0x10, 0xBD, 0x01, 0x29,
+	0x12, 0xD0, 0x02, 0x29, 0x24, 0xD0, 0x03, 0x29, 0x0E, 0xD0, 0x04, 0x29,
+	0x1D, 0xD1, 0x01, 0x78,
+	0x21, 0xF0, 0x12, 0x01, 0x00, 0xF8, 0x35, 0x1B, 0x01, 0x7E, 0x21, 0xF0,
+	0x03, 0x01, 0x01, 0x76,
+	0xC1, 0x7F, 0x21, 0xF0, 0x80, 0x01, 0x22, 0xE0, 0x02, 0x78, 0x01, 0x29,
+	0x42, 0xF0, 0x12, 0x02,
+	0x02, 0x70, 0x0B, 0xD0, 0x5F, 0xF0, 0x03, 0x02, 0x10, 0xF8, 0x4D, 0x1F,
+	0x62, 0xF3, 0x01, 0x01,
+	0x01, 0x70, 0xC1, 0x79, 0x41, 0xF0, 0x80, 0x01, 0xC1, 0x71, 0x70, 0x47,
+	0x01, 0x22, 0xF3, 0xE7,
+	0x01, 0x78, 0x21, 0xF0, 0x02, 0x01, 0x41, 0xF0, 0x10, 0x01, 0x00, 0xF8,
+	0x35, 0x1B, 0x01, 0x7E,
+	0x21, 0xF0, 0x03, 0x01, 0x89, 0x1C, 0x01, 0x76, 0xC1, 0x7F, 0x41, 0xF0,
+	0x80, 0x01, 0xC1, 0x77,
+	0x70, 0x47, 0x90, 0xF8, 0x29, 0x20, 0x02, 0x29, 0x04, 0xD0, 0x03, 0x29,
+	0x22, 0xF0, 0x40, 0x01,
+	0x02, 0xD1, 0x04, 0xE0, 0x42, 0xF0, 0x40, 0x01, 0x21, 0xF0, 0x80, 0x01,
+	0x01, 0xE0, 0x41, 0xF0,
+	0x80, 0x01, 0x80, 0xF8, 0x29, 0x10, 0x70, 0x47, 0x90, 0xF8, 0x29, 0x20,
+	0x01, 0x29, 0x04, 0xD0,
+	0x02, 0x29, 0x07, 0xD0, 0x22, 0xF0, 0x10, 0x01, 0x01, 0xE0, 0x42, 0xF0,
+	0x10, 0x01, 0x21, 0xF0,
+	0x20, 0x01, 0x01, 0xE0, 0x42, 0xF0, 0x30, 0x01, 0x80, 0xF8, 0x29, 0x10,
+	0x70, 0x47, 0xC2, 0x78,
+	0x00, 0x29, 0x61, 0xF3, 0x03, 0x02, 0xC2, 0x70, 0x04, 0xD0, 0x10, 0xF8,
+	0x5E, 0x1F, 0x41, 0xF0,
+	0x04, 0x01, 0x01, 0x70, 0x70, 0x47, 0x00, 0x00, 0x48, 0x74, 0x01, 0x00,
+	0xA4, 0x00, 0x03, 0x20,
+	0x18, 0x04, 0x10, 0x00, 0x01, 0xEB, 0x81, 0x01, 0x02, 0xEB, 0xC1, 0x01,
+	0x40, 0x5C, 0x01, 0x06,
+	0x02, 0xD5, 0x00, 0xF0, 0x7F, 0x00, 0x40, 0x42, 0x70, 0x47, 0x00, 0x2B,
+	0x04, 0xDA, 0x5B, 0x42,
+	0xDB, 0xB2, 0x43, 0xF0, 0x80, 0x03, 0x01, 0xE0, 0x03, 0xF0, 0x7F, 0x03,
+	0x01, 0xEB, 0x81, 0x01,
+	0x02, 0xEB, 0xC1, 0x01, 0x43, 0x54, 0x70, 0x47, 0x2D, 0xE9, 0xF0, 0x5F,
+	0x00, 0x25, 0x17, 0x46,
+	0x98, 0x46, 0x89, 0x46, 0x83, 0x46, 0x2E, 0x46, 0x4F, 0xF0, 0x01, 0x0A,
+	0x0A, 0xFA, 0x05, 0xF0,
+	0x10, 0xEA, 0x09, 0x0F, 0x14, 0xD0, 0x00, 0x24, 0x22, 0x46, 0x01, 0x20,
+	0x00, 0x21, 0x16, 0xF0,
+	0x4D, 0xFB, 0x38, 0x40, 0x01, 0xEA, 0x08, 0x01, 0x08, 0x43, 0x05, 0xD0,
+	0x00, 0x23, 0x22, 0x46,
+	0x31, 0x46, 0x58, 0x46, 0xFF, 0xF7, 0xD1, 0xFF, 0x64, 0x1C, 0x26, 0x2C,
+	0xEC, 0xDB, 0x76, 0x1C,
+	0x6D, 0x1C, 0x1D, 0x2D, 0xE2, 0xDB, 0xBD, 0xE8, 0xF0, 0x9F, 0x40, 0x5C,
+	0x01, 0x06, 0x02, 0xD5,
+	0x00, 0xF0, 0x7F, 0x00, 0x40, 0x42, 0x70, 0x47, 0x00, 0x2A, 0x04, 0xDA,
+	0x52, 0x42, 0xD2, 0xB2,
+	0x42, 0xF0, 0x80, 0x02, 0x01, 0xE0, 0x02, 0xF0, 0x7F, 0x02, 0x42, 0x54,
+	0x70, 0x47, 0xF0, 0xB5,
+	0x00, 0x24, 0x16, 0x46, 0x0F, 0x46, 0x84, 0x46, 0x23, 0x46, 0x01, 0x25,
+	0x10, 0xE0, 0x00, 0xBF,
+	0x07, 0xEB, 0xE3, 0x00, 0x03, 0xF0, 0x07, 0x02, 0x01, 0x78, 0x05, 0xFA,
+	0x02, 0xF0, 0x08, 0x42,
+	0x05, 0xD0, 0x00, 0x22, 0x19, 0x46, 0x60, 0x46, 0xFF, 0xF7, 0xDE, 0xFF,
+	0x64, 0x1C, 0x5B, 0x1C,
+	0xB4, 0x42, 0xED, 0xDB, 0xF0, 0xBD, 0x40, 0x5C, 0x70, 0x47, 0x42, 0x54,
+	0x70, 0x47, 0x00, 0x00,
+	0x2D, 0xE9, 0xF0, 0x47, 0x34, 0x4C, 0x54, 0xF8, 0x3C, 0x8F, 0x67, 0x68,
+	0xE6, 0x68, 0x25, 0x7C,
+	0xDF, 0xF8, 0xC8, 0x90, 0x01, 0x21, 0xC9, 0xF8, 0x00, 0x10, 0x4F, 0xF4,
+	0x20, 0x70, 0xFF, 0xF7,
+	0xF9, 0xFB, 0x00, 0x21, 0xC9, 0xF8, 0x00, 0x10, 0xC4, 0xF8, 0x00, 0x80,
+	0x67, 0x60, 0xE6, 0x60,
+	0x25, 0x74, 0xBD, 0xE8, 0xF0, 0x87, 0x28, 0x48, 0x00, 0x21, 0xC1, 0x63,
+	0x01, 0x64, 0x81, 0x64,
+	0x80, 0xF8, 0x4C, 0x10, 0x70, 0x47, 0x10, 0xB5, 0x02, 0x46, 0x00, 0x24,
+	0x4F, 0xF0, 0x01, 0x00,
+	0x49, 0xB3, 0x00, 0x21, 0x16, 0xF0, 0xDA, 0xFA, 0x1F, 0x4A, 0x48, 0x32,
+	0x10, 0x60, 0x11, 0x71,
+	0xFF, 0xF7, 0xCE, 0xFF, 0x00, 0x20, 0x00, 0xF0, 0x25, 0xF8, 0x00, 0xB1,
+	0x01, 0x24, 0xFF, 0xF7,
+	0xC7, 0xFF, 0x01, 0x20, 0x00, 0xF0, 0x1E, 0xF8, 0x08, 0xB1, 0x44, 0xF0,
+	0x02, 0x04, 0xFF, 0xF7,
+	0xBF, 0xFF, 0x02, 0x20, 0x00, 0xF0, 0x16, 0xF8, 0x08, 0xB1, 0x44, 0xF0,
+	0x04, 0x04, 0xFF, 0xF7,
+	0xB7, 0xFF, 0x03, 0x20, 0x00, 0xF0, 0x0E, 0xF8, 0x08, 0xB1, 0x44, 0xF0,
+	0x08, 0x04, 0xFF, 0xF7,
+	0xAF, 0xFF, 0x20, 0x46, 0x10, 0xBD, 0x90, 0x40, 0x0B, 0x4A, 0x00, 0x21,
+	0x3C, 0x32, 0xC2, 0xE9,
+	0x00, 0x01, 0xD5, 0xE7, 0x40, 0xF0, 0x20, 0x01, 0x07, 0x48, 0x10, 0xB5,
+	0x80, 0xF8, 0xA3, 0x10,
+	0xE5, 0x21, 0x81, 0x71, 0x4F, 0xF4, 0x20, 0x70, 0xFF, 0xF7, 0xA4, 0xFB,
+	0x04, 0x48, 0xD0, 0xF8,
+	0xC0, 0x02, 0xC0, 0xB2, 0x10, 0xBD, 0x00, 0x00, 0x00, 0x00, 0x03, 0x20,
+	0x68, 0x14, 0x60, 0x22,
+	0x00, 0x10, 0x60, 0x22, 0x01, 0x49, 0x01, 0x20, 0x09, 0x68, 0x08, 0x47,
+	0x1C, 0x04, 0x10, 0x00,
+	0x10, 0xB5, 0xFF, 0xF7, 0x8B, 0xFE, 0x05, 0x49, 0x02, 0x20, 0x08, 0x70,
+	0x04, 0x49, 0x00, 0x20,
+	0x08, 0x60, 0x04, 0x49, 0x09, 0x68, 0xBD, 0xE8, 0x10, 0x40, 0x08, 0x47,
+	0x14, 0x04, 0x10, 0x00,
+	0x18, 0x04, 0x10, 0x00, 0x1C, 0x04, 0x10, 0x00, 0x37, 0xB5, 0x04, 0x46,
+	0x37, 0x49, 0x01, 0x98,
+	0x15, 0x46, 0x08, 0x40, 0x01, 0x90, 0x04, 0x21, 0x01, 0xA8, 0x00, 0xF0,
+	0xFC, 0xFA, 0x01, 0x2D,
+	0x02, 0xD0, 0x02, 0x2D, 0x04, 0xD0, 0x06, 0xE0, 0xC0, 0x1C, 0x20, 0xF0,
+	0x01, 0x00, 0x02, 0xE0,
+	0xC0, 0x1D, 0x20, 0xF0, 0x03, 0x00, 0x01, 0x99, 0x44, 0xF8, 0x3C, 0x1F,
+	0x00, 0x21, 0x61, 0x60,
+	0x21, 0x7A, 0x60, 0xF3, 0x06, 0x01, 0x21, 0x72, 0x3E, 0xBD, 0x01, 0x23,
+	0x40, 0xF8, 0x3C, 0x3F,
+	0x00, 0x23, 0x43, 0x60, 0x51, 0x43, 0x02, 0x7A, 0x61, 0xF3, 0x06, 0x02,
+	0x02, 0x72, 0x70, 0x47,
+	0x1F, 0xB5, 0x04, 0x46, 0x03, 0x99, 0x02, 0xA8, 0x01, 0xF0, 0x3F, 0x01,
+	0x03, 0x91, 0x08, 0x21,
+	0x00, 0xF0, 0xD1, 0xFA, 0xDD, 0xE9, 0x02, 0x12, 0xA1, 0x64, 0x84, 0xF8,
+	0x4C, 0x20, 0x14, 0xF8,
+	0x70, 0x1F, 0x60, 0xF3, 0x05, 0x01, 0x04, 0xF8, 0x1E, 0x19, 0xE1, 0x7F,
+	0x60, 0xF3, 0x05, 0x01,
+	0xE1, 0x77, 0x1F, 0xBD, 0x08, 0xB5, 0x16, 0xA2, 0x12, 0x68, 0x00, 0x92,
+	0x1D, 0xF8, 0x01, 0x20,
+	0x10, 0xF8, 0x5D, 0x1F, 0x62, 0xF3, 0x01, 0x01, 0x01, 0x70, 0x08, 0xBD,
+	0x10, 0xB5, 0x82, 0x79,
+	0x22, 0xF0, 0x0D, 0x02, 0x42, 0xF0, 0xE0, 0x02, 0x82, 0x71, 0x0E, 0x4A,
+	0x11, 0x60, 0x0E, 0x4A,
+	0x03, 0x21, 0x11, 0x70, 0x0E, 0x4A, 0x0D, 0x49, 0x11, 0x60, 0x01, 0x46,
+	0xA4, 0x22, 0x0D, 0x48,
+	0x16, 0xF0, 0x4B, 0xFA, 0x0C, 0x49, 0x01, 0x20, 0xC1, 0xF8, 0xC0, 0x00,
+	0xBD, 0xE8, 0x10, 0x40,
+	0x0A, 0x49, 0x4F, 0xF4, 0xFA, 0x70, 0xFF, 0xF7, 0x07, 0xBE, 0x00, 0x00,
+	0xFF, 0xFF, 0x03, 0x1C,
+	0x00, 0x01, 0x02, 0x00, 0x1C, 0x04, 0x10, 0x00, 0x14, 0x04, 0x10, 0x00,
+	0x81, 0x0B, 0x00, 0x00,
+	0x18, 0x04, 0x10, 0x00, 0x00, 0x00, 0x03, 0x20, 0x00, 0x00, 0x60, 0x22,
+	0x75, 0x0B, 0x00, 0x00,
+	0x16, 0x48, 0x01, 0x78, 0x01, 0x29, 0x08, 0xD1, 0x02, 0x21, 0x01, 0x70,
+	0x14, 0x48, 0x01, 0x68,
+	0x19, 0xB1, 0x00, 0x22, 0x02, 0x60, 0x10, 0x46, 0x08, 0x47, 0x01, 0x20,
+	0x15, 0xF0, 0x73, 0xBE,
+	0x0E, 0x4A, 0x01, 0x21, 0x11, 0x70, 0x0E, 0x49, 0x08, 0x60, 0x0E, 0x49,
+	0xE8, 0x20, 0x88, 0x71,
+	0x0D, 0x49, 0x02, 0x20, 0xFF, 0xF7, 0xD8, 0xBD, 0x0A, 0x49, 0x08, 0x20,
+	0x88, 0x71, 0x0B, 0x49,
+	0x00, 0x20, 0x08, 0x62, 0x05, 0x49, 0x08, 0x70, 0x05, 0x49, 0x08, 0x60,
+	0x70, 0x47, 0x03, 0x48,
+	0x00, 0x78, 0x00, 0x28, 0x00, 0xD0, 0x01, 0x20, 0x70, 0x47, 0x00, 0x00,
+	0x14, 0x04, 0x10, 0x00,
+	0x20, 0x04, 0x10, 0x00, 0x00, 0x00, 0x03, 0x20, 0xB1, 0x0C, 0x00, 0x00,
+	0x00, 0x00, 0x60, 0x22,
+	0x53, 0x49, 0x01, 0x20, 0x09, 0x68, 0x08, 0x47, 0x10, 0xB5, 0xFF, 0xF7,
+	0xB7, 0xFD, 0x51, 0x49,
+	0x02, 0x20, 0x08, 0x70, 0x50, 0x49, 0x00, 0x20, 0x08, 0x60, 0x4D, 0x49,
+	0x09, 0x68, 0xBD, 0xE8,
+	0x10, 0x40, 0x08, 0x47, 0x13, 0xB5, 0x04, 0x46, 0x4C, 0x49, 0x01, 0x98,
+	0x08, 0x40, 0x01, 0x90,
+	0x04, 0x21, 0x01, 0xA8, 0x00, 0xF0, 0x2F, 0xFA, 0x01, 0x99, 0x44, 0xF8,
+	0x3C, 0x1F, 0x00, 0x21,
+	0x61, 0x60, 0x14, 0xF8, 0x08, 0x1F, 0x60, 0xF3, 0x06, 0x01, 0x04, 0xF8,
+	0x11, 0x1B, 0x61, 0x7F,
+	0x60, 0xF3, 0x05, 0x01, 0x61, 0x77, 0xA1, 0x7F, 0x60, 0xF3, 0x05, 0x01,
+	0xA1, 0x77, 0xE0, 0x7F,
+	0x20, 0xF0, 0x08, 0x00, 0xE0, 0x77, 0x1C, 0xBD, 0x1F, 0xB5, 0x04, 0x46,
+	0x03, 0x99, 0x02, 0xA8,
+	0x01, 0xF0, 0x3F, 0x01, 0x03, 0x91, 0x08, 0x21, 0x00, 0xF0, 0x0D, 0xFA,
+	0xDD, 0xE9, 0x02, 0x12,
+	0xA1, 0x64, 0x84, 0xF8, 0x4C, 0x20, 0x14, 0xF8, 0x70, 0x1F, 0x60, 0xF3,
+	0x05, 0x01, 0x04, 0xF8,
+	0x1E, 0x19, 0xE1, 0x7F, 0x60, 0xF3, 0x05, 0x01, 0xE1, 0x77, 0x1F, 0xBD,
+	0x10, 0xB5, 0x30, 0xA3,
+	0x89, 0xB0, 0x1C, 0xCB, 0x8D, 0xE8, 0x1C, 0x00, 0x30, 0xA4, 0x0D, 0xF1,
+	0x0C, 0x0C, 0x1C, 0xCC,
+	0x8C, 0xE8, 0x1C, 0x00, 0x30, 0xA4, 0x0D, 0xF1, 0x18, 0x0C, 0x1C, 0xCC,
+	0x8C, 0xE8, 0x1C, 0x00,
+	0x03, 0xAA, 0x53, 0x5C, 0x42, 0x7E, 0x63, 0xF3, 0x05, 0x02, 0x42, 0x76,
+	0x1D, 0xF8, 0x01, 0x30,
+	0x02, 0x7E, 0x63, 0xF3, 0x42, 0x02, 0x02, 0x76, 0x06, 0xAA, 0x52, 0x5C,
+	0x81, 0x79, 0x62, 0xF3,
+	0x83, 0x01, 0x81, 0x71, 0x09, 0xB0, 0x10, 0xBD, 0x1A, 0x49, 0x04, 0x20,
+	0x08, 0x70, 0x1A, 0x49,
+	0x24, 0x48, 0x08, 0x60, 0x24, 0x49, 0x01, 0x20, 0xC1, 0xF8, 0xC0, 0x00,
+	0x23, 0x49, 0x4F, 0xF4,
+	0xFA, 0x70, 0xFF, 0xF7, 0x39, 0xBD, 0x10, 0xB5, 0xB0, 0xF8, 0x56, 0x20,
+	0x42, 0xF0, 0x01, 0x02,
+	0xA0, 0xF8, 0x56, 0x20, 0x82, 0x79, 0x22, 0xF0, 0x01, 0x02, 0x42, 0xF0,
+	0xE0, 0x02, 0x82, 0x71,
+	0x0B, 0x4A, 0x11, 0x60, 0x0B, 0x4A, 0x04, 0x21, 0x11, 0x70, 0x0B, 0x4A,
+	0x15, 0x49, 0x11, 0x60,
+	0x01, 0x46, 0xA4, 0x22, 0x16, 0x48, 0x16, 0xF0, 0x58, 0xF9, 0x13, 0x49,
+	0x01, 0x20, 0xC1, 0xF8,
+	0xC0, 0x00, 0xBD, 0xE8, 0x10, 0x40, 0x11, 0x49, 0x4F, 0xF4, 0xFA, 0x70,
+	0xFF, 0xF7, 0x14, 0xBD,
+	0x24, 0x04, 0x10, 0x00, 0x14, 0x04, 0x10, 0x00, 0x18, 0x04, 0x10, 0x00,
+	0xFF, 0xFF, 0x03, 0x1C,
+	0x00, 0x00, 0x02, 0x02, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00,
+	0x02, 0x02, 0x02, 0x02,
+	0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00, 0x02, 0x03, 0x02, 0x03,
+	0x02, 0x03, 0x02, 0x03,
+	0x02, 0x03, 0x00, 0x00, 0x29, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x60, 0x22,
+	0x21, 0x0D, 0x00, 0x00,
+	0x00, 0x00, 0x03, 0x20, 0x35, 0x49, 0x01, 0x20, 0x08, 0x60, 0x17, 0x22,
+	0x41, 0x07, 0x01, 0xF8,
+	0x27, 0x2F, 0x0B, 0x22, 0x81, 0xF8, 0x41, 0x20, 0x30, 0x49, 0x18, 0x39,
+	0x08, 0x60, 0x4F, 0xF0,
+	0x08, 0x51, 0xC1, 0xF8, 0xC4, 0x03, 0x2D, 0x4A, 0x00, 0x21, 0xB0, 0x32,
+	0x11, 0x60, 0x2C, 0x49,
+	0x08, 0x60, 0x09, 0x1D, 0x08, 0x60, 0x29, 0x49, 0x94, 0x39, 0x08, 0x60,
+	0x70, 0x47, 0x4F, 0xF0,
+	0x00, 0x50, 0x00, 0x88, 0x70, 0x47, 0x4F, 0xF0, 0x00, 0x50, 0x80, 0x78,
+	0x70, 0x47, 0x4F, 0xF0,
+	0x00, 0x51, 0x88, 0x80, 0x70, 0x47, 0x21, 0x49, 0x01, 0x20, 0x30, 0x39,
+	0x08, 0x60, 0x70, 0x47,
+	0x4F, 0xF0, 0x00, 0x50, 0x10, 0xF8, 0x22, 0x1F, 0x21, 0xF0, 0x03, 0x01,
+	0x01, 0x70, 0x70, 0x47,
+	0x4F, 0xF0, 0x00, 0x53, 0x03, 0xF8, 0x1F, 0x0F, 0x59, 0x70, 0x98, 0x78,
+	0x62, 0xF3, 0x03, 0x00,
+	0x98, 0x70, 0x70, 0x47, 0x17, 0x48, 0x00, 0x68, 0x70, 0x47, 0x16, 0x49,
+	0x08, 0x60, 0x70, 0x47,
+	0x10, 0xB5, 0x4F, 0xF0, 0x00, 0x54, 0xE2, 0x7E, 0x22, 0xF0, 0xAF, 0x03,
+	0x20, 0x22, 0x02, 0xEA,
+	0x40, 0x12, 0x1A, 0x43, 0x04, 0x23, 0x03, 0xEA, 0x80, 0x00, 0x02, 0x43,
+	0x01, 0xF0, 0x03, 0x00,
+	0x02, 0x43, 0xE2, 0x76, 0x10, 0xBD, 0x4F, 0xF0, 0x00, 0x50, 0x90, 0xF8,
+	0x22, 0x00, 0x10, 0xF0,
+	0x03, 0x00, 0x05, 0xD0, 0x01, 0x28, 0x05, 0xD0, 0x02, 0x28, 0x05, 0xD0,
+	0x06, 0x48, 0x70, 0x47,
+	0x06, 0x48, 0x70, 0x47, 0x06, 0x48, 0x70, 0x47, 0x06, 0x48, 0x70, 0x47,
+	0xCC, 0x04, 0x00, 0x22,
+	0x80, 0x1E, 0x00, 0x22, 0x28, 0x04, 0x10, 0x00, 0x00, 0x12, 0x7A, 0x00,
+	0x00, 0x90, 0xD0, 0x03,
+	0x00, 0x48, 0xE8, 0x01, 0x00, 0x24, 0xF4, 0x00, 0x30, 0xB5, 0x6C, 0x4C,
+	0x01, 0x25, 0x25, 0x60,
+	0xE5, 0x06, 0x03, 0xF0, 0x1F, 0x03, 0x85, 0xF8, 0x6B, 0x30, 0x00, 0x23,
+	0x05, 0xE0, 0x00, 0xBF,
+	0x51, 0xF8, 0x23, 0x50, 0x40, 0xF8, 0x23, 0x50, 0x5B, 0x1C, 0x93, 0x42,
+	0xF8, 0xDB, 0x00, 0x20,
+	0x20, 0x60, 0x30, 0xBD, 0xF0, 0xB5, 0x06, 0x46, 0x00, 0x20, 0x04, 0x46,
+	0xDF, 0xF8, 0x80, 0xC1,
+	0x14, 0xE0, 0x56, 0xF8, 0x24, 0x70, 0x03, 0x23, 0xDD, 0x00, 0x47, 0xFA,
+	0x05, 0xF2, 0x80, 0xEA,
+	0x02, 0x60, 0x08, 0x25, 0x00, 0x28, 0x02, 0xDA, 0x8C, 0xEA, 0x40, 0x00,
+	0x00, 0xE0, 0x40, 0x00,
+	0x6D, 0x1E, 0x00, 0x2D, 0xF6, 0xDC, 0x5B, 0x1E, 0xEE, 0xD5, 0x64, 0x1C,
+	0x8C, 0x42, 0xE8, 0xDB,
+	0xF0, 0xBD, 0xF0, 0xB5, 0xB1, 0xB0, 0x07, 0x46, 0x6D, 0x46, 0x52, 0x4E,
+	0x01, 0x24, 0xC0, 0x21,
+	0x28, 0x46, 0x16, 0xF0, 0x13, 0xF9, 0x00, 0x20, 0x56, 0xF8, 0x20, 0x10,
+	0x45, 0xF8, 0x20, 0x10,
+	0x40, 0x1C, 0x30, 0x28, 0xF8, 0xD3, 0x4C, 0x49, 0x00, 0x98, 0x88, 0x42,
+	0x10, 0xD1, 0x02, 0x98,
+	0x81, 0xB2, 0x05, 0xA8, 0x04, 0x46, 0xFF, 0xF7, 0xC5, 0xFF, 0x01, 0x99,
+	0x81, 0x42, 0x06, 0xD1,
+	0xAC, 0x22, 0x21, 0x46, 0x38, 0x46, 0x16, 0xF0, 0x9D, 0xF8, 0x00, 0x24,
+	0x00, 0xE0, 0x03, 0x24,
+	0x31, 0xB0, 0x20, 0x46, 0xF0, 0xBD, 0x2D, 0xE9, 0xF0, 0x41, 0x41, 0x4D,
+	0x07, 0x46, 0x3F, 0x4E,
+	0x01, 0x24, 0x4F, 0xF4, 0x58, 0x71, 0x28, 0x46, 0x16, 0xF0, 0xE8, 0xF8,
+	0x5F, 0xF0, 0x00, 0x00,
+	0x56, 0xF8, 0x20, 0x10, 0x45, 0xF8, 0x20, 0x10, 0x40, 0x1C, 0xD8, 0x28,
+	0xF8, 0xD3, 0x38, 0x4D,
+	0x38, 0x49, 0x28, 0x68, 0x88, 0x42, 0x12, 0xD1, 0x28, 0x89, 0x81, 0xB2,
+	0x05, 0xF1, 0x14, 0x00,
+	0xFF, 0xF7, 0x98, 0xFF, 0x69, 0x68, 0x81, 0x42, 0x08, 0xD1, 0x4F, 0xF4,
+	0x52, 0x72, 0x05, 0xF1,
+	0x18, 0x01, 0x38, 0x46, 0x16, 0xF0, 0x29, 0xF8, 0x00, 0x24, 0x00, 0xE0,
+	0x03, 0x24, 0x20, 0x46,
+	0xBD, 0xE8, 0xF0, 0x81, 0x70, 0xB5, 0x94, 0xB0, 0x04, 0x46, 0x6D, 0x46,
+	0x2A, 0x4E, 0x50, 0x21,
+	0x28, 0x46, 0x16, 0xF0, 0xBB, 0xF8, 0x00, 0x20, 0x56, 0xF8, 0x20, 0x10,
+	0x45, 0xF8, 0x20, 0x10,
+	0x40, 0x1C, 0x14, 0x28, 0xF8, 0xD3, 0x25, 0x49, 0x00, 0x98, 0x6F, 0xF0,
+	0x02, 0x05, 0x88, 0x42,
+	0x2E, 0xD1, 0xA8, 0x10, 0x20, 0x60, 0x60, 0x60, 0xA0, 0x60, 0xE0, 0x60,
+	0x20, 0x61, 0x02, 0x98,
+	0x81, 0xB2, 0x05, 0xA8, 0xFF, 0xF7, 0x66, 0xFF, 0x01, 0x99, 0x81, 0x42,
+	0x20, 0xD1, 0xBD, 0xF8,
+	0x38, 0x10, 0x45, 0xF2, 0xAA, 0x50, 0x81, 0x42, 0x0C, 0xD1, 0x9D, 0xF8,
+	0x1D, 0x10, 0x21, 0x60,
+	0x9D, 0xF8, 0x1C, 0x10, 0x01, 0xF0, 0x0F, 0x01, 0x61, 0x60, 0x9D, 0xF8,
+	0x1E, 0x10, 0x01, 0xF0,
+	0x0F, 0x01, 0xA1, 0x60, 0xBD, 0xF8, 0x3C, 0x10, 0x81, 0x42, 0x01, 0xD1,
+	0x08, 0x99, 0xE1, 0x60,
+	0xBD, 0xF8, 0x40, 0x10, 0x81, 0x42, 0x01, 0xD1, 0x09, 0x98, 0x20, 0x61,
+	0x14, 0xB0, 0x70, 0xBD,
+	0x25, 0x60, 0x65, 0x60, 0xA5, 0x60, 0xE5, 0x60, 0x25, 0x61, 0xF7, 0xE7,
+	0xC4, 0x1B, 0x00, 0x22,
+	0x1B, 0x00, 0x00, 0x80, 0x48, 0x1D, 0x04, 0x00, 0xB2, 0x57, 0x0E, 0x70,
+	0xE8, 0x19, 0x04, 0x00,
+	0x54, 0x0B, 0x10, 0x00, 0xA1, 0x46, 0x0D, 0x60, 0xAC, 0x1E, 0x04, 0x00,
+	0x5C, 0x00, 0x0D, 0x60,
+	0xF0, 0xB5, 0x07, 0x46, 0x00, 0x20, 0x03, 0x46, 0x2F, 0x4E, 0x11, 0xE0,
+	0x57, 0xF8, 0x23, 0x50,
+	0x03, 0x22, 0x00, 0xBF, 0x4F, 0xEA, 0xC2, 0x0C, 0x45, 0xFA, 0x0C, 0xF4,
+	0x84, 0xEA, 0x20, 0x64,
+	0xE4, 0xB2, 0x52, 0x1E, 0x56, 0xF8, 0x24, 0x40, 0x84, 0xEA, 0x00, 0x20,
+	0xF2, 0xD5, 0x5B, 0x1C,
+	0x8B, 0x42, 0xEB, 0xDB, 0xF0, 0xBD, 0x30, 0xB5, 0x02, 0x46, 0x23, 0x4B,
+	0x00, 0x20, 0x10, 0x3B,
+	0x08, 0xE0, 0x54, 0x5C, 0x04, 0xF0, 0x0F, 0x05, 0x03, 0xEB, 0x14, 0x14,
+	0x5D, 0x5D, 0x24, 0x78,
+	0x28, 0x44, 0x20, 0x44, 0x49, 0x1E, 0xF4, 0xD2, 0x30, 0xBD, 0x10, 0xB5,
+	0x84, 0x68, 0x03, 0x68,
+	0xE4, 0x43, 0xA3, 0x42, 0x0A, 0xD1, 0xC4, 0x68, 0x43, 0x68, 0xE4, 0x43,
+	0xA3, 0x42, 0x05, 0xD1,
+	0x5B, 0x1C, 0x0B, 0x60, 0x00, 0x68, 0x10, 0x60, 0x01, 0x20, 0x10, 0xBD,
+	0x00, 0x20, 0x10, 0xBD,
+	0x3C, 0xB5, 0x04, 0x46, 0x00, 0x25, 0x01, 0xAA, 0x69, 0x46, 0xFF, 0xF7,
+	0xE6, 0xFF, 0x01, 0x28,
+	0x09, 0xD1, 0x00, 0x99, 0x04, 0xF1, 0x10, 0x00, 0x09, 0x1F, 0xFF, 0xF7,
+	0xB1, 0xFF, 0x01, 0x99,
+	0x88, 0x42, 0x00, 0xD1, 0x01, 0x25, 0x28, 0x46, 0x3C, 0xBD, 0x30, 0xB5,
+	0x0D, 0x46, 0x04, 0x46,
+	0x09, 0x1F, 0x10, 0x30, 0xFF, 0xF7, 0xA4, 0xFF, 0x6D, 0x1E, 0x65, 0x60,
+	0xE9, 0x43, 0xE1, 0x60,
+	0x20, 0x60, 0xC0, 0x43, 0xA0, 0x60, 0x30, 0xBD, 0xFC, 0x74, 0x01, 0x00,
+	0x4F, 0xF0, 0x00, 0x50,
+	0x00, 0x21, 0x80, 0xF8, 0x3D, 0x10, 0x80, 0xF8, 0x3E, 0x10, 0x80, 0xF8,
+	0x3F, 0x10, 0x3F, 0x22,
+	0x80, 0xF8, 0x32, 0x20, 0x00, 0xF8, 0x30, 0x1F, 0x02, 0x71, 0x41, 0x71,
+	0x42, 0x70, 0x01, 0x72,
+	0x41, 0x72, 0x81, 0x72, 0xC1, 0x72, 0xC1, 0x71, 0x70, 0x47, 0x28, 0x4A,
+	0x10, 0x60, 0x27, 0x48,
+	0x0C, 0x30, 0x01, 0x60, 0x70, 0x47, 0x30, 0xB5, 0x01, 0x24, 0x84, 0x40,
+	0x4F, 0xF0, 0x00, 0x50,
+	0x00, 0x29, 0x03, 0x9D, 0x90, 0xF8, 0x32, 0x10, 0xE4, 0xB2, 0x01, 0xD0,
+	0x21, 0x43, 0x00, 0xE0,
+	0xA1, 0x43, 0x80, 0xF8, 0x32, 0x10, 0x90, 0xF8, 0x30, 0x10, 0x0A, 0xB1,
+	0x21, 0x43, 0x00, 0xE0,
+	0xA1, 0x43, 0x80, 0xF8, 0x30, 0x10, 0x90, 0xF8, 0x34, 0x10, 0x0B, 0xB1,
+	0x21, 0x43, 0x00, 0xE0,
+	0xA1, 0x43, 0x80, 0xF8, 0x34, 0x10, 0x10, 0xF8, 0x35, 0x1F, 0x0D, 0xB1,
+	0x21, 0x43, 0x00, 0xE0,
+	0xA1, 0x43, 0x01, 0x70, 0x30, 0xBD, 0x4F, 0xF0, 0x00, 0x52, 0x06, 0x28,
+	0x17, 0xD2, 0xDF, 0xE8,
+	0x00, 0xF0, 0x03, 0x06, 0x09, 0x0F, 0x17, 0x1A, 0x12, 0xF8, 0x3D, 0x0F,
+	0x04, 0xE0, 0x12, 0xF8,
+	0x3D, 0x0F, 0x07, 0xE0, 0x12, 0xF8, 0x3E, 0x0F, 0x20, 0xF0, 0x0F, 0x00,
+	0x08, 0x43, 0x05, 0xE0,
+	0x12, 0xF8, 0x3E, 0x0F, 0x20, 0xF0, 0xF0, 0x00, 0x40, 0xEA, 0x01, 0x10,
+	0x10, 0x70, 0x70, 0x47,
+	0x12, 0xF8, 0x3F, 0x0F, 0xF0, 0xE7, 0x12, 0xF8, 0x3F, 0x0F, 0xF3, 0xE7,
+	0x38, 0x05, 0x00, 0x22,
+	0xF0, 0xB5, 0x63, 0x4C, 0xD0, 0xE9, 0x00, 0x25, 0x01, 0x21, 0xE3, 0x1D,
+	0x06, 0x7A, 0xFF, 0x27,
+	0x48, 0x07, 0x80, 0xF8, 0xE5, 0x70, 0x80, 0xF8, 0xE4, 0x70, 0x00, 0x27,
+	0xC0, 0xF8, 0xC0, 0x70,
+	0xC0, 0xF8, 0xE8, 0x70, 0x80, 0xF8, 0xE1, 0x70, 0x80, 0xF8, 0xE3, 0x70,
+	0x8E, 0x46, 0x58, 0xE0,
+	0x17, 0x78, 0x04, 0xF8, 0x01, 0x7B, 0x2F, 0x88, 0x23, 0xF8, 0x02, 0x7B,
+	0xD7, 0x78, 0x01, 0x2F,
+	0x02, 0xD0, 0x02, 0x2F, 0x09, 0xD0, 0x10, 0xE0, 0x90, 0xF8, 0xE4, 0x70,
+	0x0E, 0xFA, 0x01, 0xFC,
+	0x27, 0xEA, 0x0C, 0x07, 0x80, 0xF8, 0xE4, 0x70, 0x07, 0xE0, 0x90, 0xF8,
+	0xE5, 0x70, 0x0E, 0xFA,
+	0x01, 0xFC, 0x27, 0xEA, 0x0C, 0x07, 0x80, 0xF8, 0xE5, 0x70, 0x4F, 0x1E,
+	0x07, 0xEB, 0x47, 0x0C,
+	0x27, 0xF0, 0x01, 0x07, 0xBC, 0x44, 0x57, 0x78, 0x07, 0xF0, 0x07, 0x07,
+	0x07, 0xFA, 0x0C, 0xF7,
+	0xD0, 0xF8, 0xC0, 0xC0, 0x47, 0xEA, 0x0C, 0x07, 0xC0, 0xF8, 0xC0, 0x70,
+	0x97, 0x78, 0x4F, 0xEA,
+	0x81, 0x0C, 0x07, 0xF0, 0x0F, 0x07, 0xAC, 0xF1, 0x04, 0x0C, 0x07, 0xFA,
+	0x0C, 0xF7, 0xD0, 0xF8,
+	0xE8, 0xC0, 0x47, 0xEA, 0x0C, 0x07, 0xC0, 0xF8, 0xE8, 0x70, 0x17, 0x79,
+	0xFF, 0x07, 0x07, 0xD0,
+	0x90, 0xF8, 0xE1, 0xC0, 0x0E, 0xFA, 0x01, 0xF7, 0x4C, 0xEA, 0x07, 0x0C,
+	0x80, 0xF8, 0xE1, 0xC0,
+	0x17, 0x79, 0xFF, 0x06, 0x07, 0xD5, 0x90, 0xF8, 0xE3, 0x70, 0x0E, 0xFA,
+	0x01, 0xFC, 0x47, 0xEA,
+	0x0C, 0x07, 0x80, 0xF8, 0xE3, 0x70, 0x49, 0x1C, 0x08, 0x29, 0x04, 0xD2,
+	0x52, 0x1D, 0xAD, 0x1C,
+	0x76, 0x1E, 0x00, 0x2E, 0xA4, 0xD1, 0xD0, 0xF8, 0xE8, 0x10, 0x41, 0x64,
+	0xF0, 0xBD, 0xF0, 0xB5,
+	0x27, 0x4D, 0x28, 0x49, 0x01, 0x26, 0xEC, 0x1D, 0xC3, 0x79, 0x00, 0x22,
+	0x07, 0x68, 0x4A, 0x60,
+	0x09, 0x04, 0x4F, 0xF0, 0xFF, 0x0E, 0x81, 0xF8, 0xE5, 0xE0, 0x81, 0xF8,
+	0xE4, 0x60, 0xC1, 0xF8,
+	0xC0, 0x20, 0x81, 0xF8, 0xE1, 0x20, 0x81, 0xF8, 0xE3, 0x20, 0x18, 0xE0,
+	0x97, 0xF8, 0x00, 0xC0,
+	0x05, 0xF8, 0x01, 0xCB, 0xB0, 0xF8, 0x04, 0xC0, 0x24, 0xF8, 0x02, 0xCB,
+	0x90, 0xF8, 0x06, 0xC0,
+	0x4F, 0xEA, 0x86, 0x0E, 0x0C, 0xF0, 0x0F, 0x0C, 0xAE, 0xF1, 0x04, 0x0E,
+	0x0C, 0xFA, 0x0E, 0xFC,
+	0x76, 0x1C, 0x4C, 0xEA, 0x02, 0x02, 0x08, 0x2E, 0x03, 0xD2, 0x5B, 0x1E,
+	0x7F, 0x1C, 0x00, 0x2B,
+	0xE4, 0xD1, 0xC1, 0xF8, 0xE8, 0x20, 0x4A, 0x64, 0xF0, 0xBD, 0x0D, 0x4A,
+	0xD2, 0x1D, 0x22, 0xF8,
+	0x10, 0x10, 0x70, 0x47, 0x10, 0xB5, 0x04, 0x46, 0x0B, 0x48, 0x00, 0x68,
+	0x38, 0xB1, 0xA0, 0x68,
+	0xFF, 0xF7, 0x46, 0xFF, 0x20, 0x68, 0xBD, 0xE8, 0x10, 0x40, 0x00, 0xF0,
+	0x0F, 0xB8, 0xE0, 0x68,
+	0xFF, 0xF7, 0x3E, 0xFF, 0x60, 0x68, 0xBD, 0xE8, 0x10, 0x40, 0x00, 0xF0,
+	0xAB, 0xB8, 0x00, 0x00,
+	0xAB, 0x00, 0x00, 0x20, 0x00, 0x20, 0x00, 0x22, 0xBC, 0x05, 0x00, 0x22,
+	0x10, 0xB5, 0x4F, 0x49,
+	0x02, 0x68, 0x00, 0x24, 0x8A, 0x60, 0x82, 0x88, 0x4A, 0x80, 0x03, 0x89,
+	0x8B, 0x80, 0x0C, 0x70,
+	0x4F, 0xF0, 0x00, 0x51, 0xA1, 0xF8, 0x1A, 0x31, 0xA1, 0xF8, 0x1E, 0x21,
+	0xC0, 0x88, 0xA1, 0xF8,
+	0x20, 0x01, 0x47, 0x48, 0x01, 0x21, 0xC0, 0xF8, 0xD8, 0x11, 0xC0, 0xF8,
+	0xDC, 0x11, 0xC0, 0xF8,
+	0xC4, 0x11, 0xC0, 0xF8, 0xCC, 0x11, 0xC0, 0xF8, 0xD4, 0x11, 0xC0, 0xF8,
+	0x80, 0x11, 0x72, 0xB6,
+	0xD0, 0xF8, 0x08, 0x22, 0x00, 0x2A, 0xFB, 0xD1, 0x41, 0x60, 0x62, 0xB6,
+	0x10, 0xBD, 0x2D, 0xE9,
+	0xF0, 0x41, 0x3B, 0x4C, 0xD4, 0xF8, 0x5C, 0x01, 0x38, 0x4E, 0x25, 0x04,
+	0x01, 0x27, 0xB2, 0x68,
+	0x50, 0xB3, 0xB5, 0xF8, 0x1C, 0x81, 0x5F, 0xEA, 0x08, 0x00, 0x0F, 0xD0,
+	0xD4, 0xF8, 0x54, 0x01,
+	0x10, 0xB9, 0xD4, 0xF8, 0x00, 0x01, 0x48, 0xB1, 0x41, 0x46, 0x01, 0x20,
+	0x90, 0x47, 0xC4, 0xF8,
+	0xD8, 0x72, 0xD4, 0xF8, 0x54, 0x01, 0x08, 0xB1, 0xC4, 0xF8, 0xD4, 0x72,
+	0xB2, 0x68, 0x41, 0x46,
+	0x02, 0x20, 0x90, 0x47, 0x01, 0x78, 0x02, 0x29, 0x02, 0xD0, 0x03, 0x29,
+	0x02, 0xD0, 0x08, 0xE0,
+	0x41, 0x88, 0x00, 0xE0, 0x71, 0x88, 0xA5, 0xF8, 0x1E, 0x11, 0x80, 0x88,
+	0xA5, 0xF8, 0x1A, 0x01,
+	0x37, 0x70, 0xC4, 0xF8, 0xDC, 0x72, 0x38, 0xE0, 0xD4, 0xF8, 0x44, 0x01,
+	0x80, 0xB1, 0xB5, 0xF8,
+	0x1C, 0x11, 0x03, 0x20, 0x90, 0x47, 0x30, 0x78, 0x38, 0xB1, 0x70, 0x88,
+	0xA5, 0xF8, 0x1E, 0x01,
+	0xB0, 0x88, 0xA5, 0xF8, 0x1A, 0x01, 0x00, 0x20, 0x30, 0x70, 0xC4, 0xF8,
+	0xC4, 0x72, 0x24, 0xE0,
+	0xD4, 0xF8, 0x58, 0x01, 0x30, 0xB1, 0xB5, 0xF8, 0x1C, 0x11, 0x01, 0x20,
+	0x90, 0x47, 0xC4, 0xF8,
+	0xD8, 0x72, 0x1A, 0xE0, 0xD4, 0xF8, 0x4C, 0x01, 0x28, 0xB9, 0xD4, 0xF8,
+	0x54, 0x01, 0x10, 0xB9,
+	0xD4, 0xF8, 0x00, 0x01, 0x88, 0xB1, 0xB5, 0xF8, 0x1C, 0x11, 0x19, 0xB1,
+	0x01, 0x20, 0x90, 0x47,
+	0xC4, 0xF8, 0xD8, 0x72, 0xD4, 0xF8, 0x4C, 0x01, 0x10, 0xB1, 0xC4, 0xF8,
+	0xCC, 0x72, 0x04, 0xE0,
+	0xD4, 0xF8, 0x54, 0x01, 0x08, 0xB1, 0xC4, 0xF8, 0xD4, 0x72, 0xD4, 0xF8,
+	0x00, 0x01, 0x00, 0x28,
+	0x01, 0xD0, 0xC4, 0xF8, 0x80, 0x72, 0xBD, 0xE8, 0xF0, 0x81, 0x00, 0x00,
+	0x2C, 0x04, 0x10, 0x00,
+	0x00, 0x20, 0x00, 0x22, 0xC1, 0x7D, 0x01, 0x29, 0x05, 0xD1, 0x49, 0x07,
+	0x11, 0xF8, 0x2D, 0x2F,
+	0x42, 0xF0, 0x02, 0x02, 0x0A, 0x70, 0x04, 0x49, 0x02, 0x68, 0x4A, 0x60,
+	0x42, 0x68, 0x8A, 0x60,
+	0x80, 0x7D, 0x08, 0x70, 0x70, 0x47, 0x00, 0x00, 0x38, 0x04, 0x10, 0x00,
+	0xE9, 0x49, 0x00, 0x20,
+	0x08, 0x60, 0x09, 0x1D, 0x08, 0x60, 0x09, 0x1D, 0x08, 0x60, 0x09, 0x1D,
+	0x08, 0x60, 0x09, 0x1D,
+	0x08, 0x60, 0x09, 0x1D, 0x08, 0x60, 0x09, 0x1D, 0x08, 0x60, 0x09, 0x1D,
+	0x08, 0x60, 0xE2, 0x49,
+	0x01, 0x22, 0x0A, 0x60, 0xE0, 0x49, 0x14, 0x31, 0x08, 0x60, 0x51, 0x07,
+	0x01, 0xF8, 0x50, 0x0F,
+	0xF0, 0x23, 0x4B, 0x70, 0x0F, 0x23, 0x01, 0xF8, 0x05, 0x3C, 0x10, 0x23,
+	0x4B, 0x80, 0x8A, 0x80,
+	0xDA, 0x49, 0x08, 0x60, 0x48, 0x60, 0x88, 0x60, 0xC8, 0x60, 0x08, 0x61,
+	0x48, 0x61, 0x88, 0x61,
+	0xC8, 0x61, 0x08, 0x62, 0x70, 0x47, 0x70, 0x47, 0xD4, 0x4A, 0x11, 0x60,
+	0xD1, 0x49, 0x00, 0x22,
+	0x0A, 0x60, 0x00, 0xEB, 0xC0, 0x02, 0x02, 0xEB, 0x00, 0x10, 0x4F, 0xF6,
+	0xFF, 0x72, 0x02, 0xEA,
+	0x80, 0x00, 0x4F, 0xF0, 0x00, 0x52, 0xA2, 0xF8, 0x58, 0x00, 0x01, 0x20,
+	0x08, 0x60, 0x70, 0x47,
+	0x4F, 0xF0, 0x00, 0x50, 0x90, 0xF8, 0x22, 0x00, 0xC0, 0xF3, 0x81, 0x00,
+	0x28, 0xB1, 0x01, 0x28,
+	0x05, 0xD0, 0x02, 0x28, 0x05, 0xD0, 0xC6, 0x48, 0x70, 0x47, 0xC6, 0x48,
+	0x70, 0x47, 0xC6, 0x48,
+	0x70, 0x47, 0xC6, 0x48, 0x70, 0x47, 0x70, 0xB5, 0x4F, 0xF0, 0x00, 0x54,
+	0x72, 0xB6, 0x65, 0x69,
+	0x60, 0x69, 0x40, 0xF0, 0x04, 0x00, 0x60, 0x61, 0xBA, 0x49, 0x00, 0x20,
+	0x08, 0x60, 0xB4, 0xF8,
+	0x58, 0x10, 0x09, 0xB1, 0xA4, 0xF8, 0x58, 0x00, 0xFF, 0xF7, 0x35, 0xFC,
+	0x01, 0x46, 0xFF, 0xF7,
+	0xD7, 0xFF, 0xB1, 0xFB, 0xF0, 0xF0, 0xFE, 0xF7, 0xCD, 0xFD, 0x65, 0x61,
+	0x02, 0x20, 0x00, 0xF0,
+	0x56, 0xF9, 0x62, 0xB6, 0x70, 0xBD, 0xB1, 0x48, 0x10, 0xB5, 0x00, 0x21,
+	0x04, 0x68, 0x01, 0x60,
+	0xFF, 0xF7, 0xD9, 0xFF, 0x1C, 0xB1, 0xA4, 0x46, 0xBD, 0xE8, 0x10, 0x40,
+	0x60, 0x47, 0x00, 0x20,
+	0xFF, 0xF7, 0xA9, 0xFF, 0x10, 0xBD, 0xA9, 0x4A, 0x51, 0x60, 0xA6, 0x49,
+	0x00, 0x22, 0x09, 0x1D,
+	0x0A, 0x60, 0x00, 0xEB, 0xC0, 0x02, 0x02, 0xEB, 0x00, 0x10, 0x4F, 0xF6,
+	0xFF, 0x72, 0x02, 0xEA,
+	0x80, 0x00, 0xCA, 0x06, 0xA2, 0xF8, 0x5A, 0x00, 0x01, 0x20, 0x08, 0x60,
+	0x70, 0x47, 0x70, 0xB5,
+	0x4F, 0xF0, 0x00, 0x54, 0x72, 0xB6, 0x65, 0x69, 0x60, 0x69, 0x40, 0xF0,
+	0x08, 0x00, 0x60, 0x61,
+	0x98, 0x49, 0x00, 0x20, 0x09, 0x1D, 0x08, 0x60, 0xB4, 0xF8, 0x5A, 0x10,
+	0x09, 0xB1, 0xA4, 0xF8,
+	0x5A, 0x00, 0xFF, 0xF7, 0xF0, 0xFB, 0x01, 0x46, 0xFF, 0xF7, 0x92, 0xFF,
+	0xB1, 0xFB, 0xF0, 0xF0,
+	0xFE, 0xF7, 0x88, 0xFD, 0x65, 0x61, 0x03, 0x20, 0x00, 0xF0, 0x11, 0xF9,
+	0x62, 0xB6, 0x70, 0xBD,
+	0x8E, 0x48, 0x10, 0xB5, 0x00, 0x21, 0x44, 0x68, 0x41, 0x60, 0xFF, 0xF7,
+	0xD8, 0xFF, 0x1C, 0xB1,
+	0xA4, 0x46, 0xBD, 0xE8, 0x10, 0x40, 0x60, 0x47, 0x01, 0x20, 0xFF, 0xF7,
+	0x64, 0xFF, 0x10, 0xBD,
+	0x70, 0xB5, 0x4F, 0xF0, 0x00, 0x54, 0x72, 0xB6, 0x65, 0x69, 0x60, 0x69,
+	0x40, 0xF0, 0x10, 0x00,
+	0x60, 0x61, 0x80, 0x49, 0x00, 0x20, 0x08, 0x31, 0x08, 0x60, 0xB4, 0xF8,
+	0x5C, 0x10, 0x09, 0xB1,
+	0xA4, 0xF8, 0x5C, 0x00, 0xFF, 0xF7, 0xBF, 0xFB, 0x01, 0x46, 0xFF, 0xF7,
+	0x61, 0xFF, 0xB1, 0xFB,
+	0xF0, 0xF0, 0xFE, 0xF7, 0x57, 0xFD, 0x65, 0x61, 0x04, 0x20, 0x00, 0xF0,
+	0xE0, 0xF8, 0x62, 0xB6,
+	0x70, 0xBD, 0x76, 0x48, 0x10, 0xB5, 0x00, 0x21, 0x84, 0x68, 0x81, 0x60,
+	0xFF, 0xF7, 0xD8, 0xFF,
+	0x1C, 0xB1, 0xA4, 0x46, 0xBD, 0xE8, 0x10, 0x40, 0x60, 0x47, 0x02, 0x20,
+	0xFF, 0xF7, 0x33, 0xFF,
+	0x10, 0xBD, 0x70, 0xB5, 0x4F, 0xF0, 0x00, 0x54, 0x72, 0xB6, 0x65, 0x69,
+	0x60, 0x69, 0x40, 0xF0,
+	0x20, 0x00, 0x60, 0x61, 0x67, 0x49, 0x00, 0x20, 0x0C, 0x31, 0x08, 0x60,
+	0xB4, 0xF8, 0x5E, 0x10,
+	0x09, 0xB1, 0xA4, 0xF8, 0x5E, 0x00, 0xFF, 0xF7, 0x8E, 0xFB, 0x01, 0x46,
+	0xFF, 0xF7, 0x30, 0xFF,
+	0xB1, 0xFB, 0xF0, 0xF0, 0xFE, 0xF7, 0x26, 0xFD, 0x65, 0x61, 0x05, 0x20,
+	0x00, 0xF0, 0xAF, 0xF8,
+	0x62, 0xB6, 0x70, 0xBD, 0x5D, 0x48, 0x10, 0xB5, 0x00, 0x21, 0xC4, 0x68,
+	0xC1, 0x60, 0xFF, 0xF7,
+	0xD8, 0xFF, 0x1C, 0xB1, 0xA4, 0x46, 0xBD, 0xE8, 0x10, 0x40, 0x60, 0x47,
+	0x03, 0x20, 0xFF, 0xF7,
+	0x02, 0xFF, 0x10, 0xBD, 0x4F, 0xF0, 0x00, 0x50, 0xB0, 0xF8, 0x60, 0x00,
+	0x70, 0x47, 0x53, 0x49,
+	0x10, 0xB5, 0x00, 0x22, 0x08, 0x69, 0x0A, 0x61, 0x4E, 0x49, 0x10, 0x31,
+	0x0A, 0x60, 0x10, 0xB1,
+	0xBD, 0xE8, 0x10, 0x40, 0x00, 0x47, 0x04, 0x20, 0xFF, 0xF7, 0xED, 0xFE,
+	0x10, 0xBD, 0x4B, 0x4A,
+	0x00, 0x23, 0x51, 0x61, 0x47, 0x49, 0x14, 0x31, 0x0B, 0x60, 0x12, 0x6A,
+	0x50, 0x43, 0x4F, 0xF0,
+	0x00, 0x52, 0x80, 0x09, 0xA2, 0xF8, 0x62, 0x00, 0x01, 0x20, 0x08, 0x60,
+	0x70, 0x47, 0x41, 0x49,
+	0x00, 0x20, 0x14, 0x31, 0x08, 0x60, 0x70, 0x47, 0x40, 0x49, 0x10, 0xB5,
+	0x00, 0x22, 0x48, 0x69,
+	0x4A, 0x61, 0x3C, 0x49, 0x14, 0x31, 0x0A, 0x60, 0x10, 0xB1, 0xBD, 0xE8,
+	0x10, 0x40, 0x00, 0x47,
+	0x05, 0x20, 0xFF, 0xF7, 0xC8, 0xFE, 0x10, 0xBD, 0x38, 0x49, 0x10, 0xB5,
+	0x00, 0x22, 0x88, 0x69,
+	0x8A, 0x61, 0x34, 0x49, 0x18, 0x31, 0x0A, 0x60, 0x10, 0xB1, 0xBD, 0xE8,
+	0x10, 0x40, 0x00, 0x47,
+	0x06, 0x20, 0xFF, 0xF7, 0xB8, 0xFE, 0x10, 0xBD, 0x10, 0xB5, 0xFF, 0xF7,
+	0x0B, 0xFB, 0x4F, 0xF0,
+	0x00, 0x51, 0x91, 0xF8, 0x22, 0x20, 0x42, 0xF2, 0x10, 0x73, 0xB0, 0xFB,
+	0xF3, 0xF0, 0xC2, 0xF3,
+	0x81, 0x02, 0x52, 0x1C, 0xD0, 0x40, 0xB1, 0xF8, 0x54, 0x20, 0xC9, 0x6C,
+	0x51, 0x43, 0x89, 0x09,
+	0xB0, 0xFB, 0xF1, 0xF0, 0x10, 0xBD, 0x25, 0x49, 0xC8, 0x61, 0x22, 0x49,
+	0x01, 0x20, 0xB8, 0x31,
+	0x08, 0x60, 0x09, 0x1D, 0x08, 0x60, 0x70, 0x47, 0x20, 0x48, 0x10, 0xB5,
+	0x00, 0x22, 0xC1, 0x69,
+	0xC2, 0x61, 0x51, 0xB1, 0x1B, 0x48, 0xB8, 0x30, 0x02, 0x60, 0x4F, 0xF0,
+	0x00, 0x50, 0xC0, 0x6C,
+	0xBD, 0xE8, 0x10, 0x40, 0x20, 0xF0, 0x7F, 0x40, 0x08, 0x47, 0xFF, 0x20,
+	0xFF, 0xF7, 0x83, 0xFE,
+	0x10, 0xBD, 0x10, 0xB5, 0x04, 0x46, 0xFF, 0xF7, 0xD5, 0xFA, 0x4F, 0xF0,
+	0x00, 0x51, 0x91, 0xF8,
+	0x22, 0x10, 0x42, 0xF2, 0x10, 0x72, 0xB0, 0xFB, 0xF2, 0xF0, 0xC1, 0xF3,
+	0x81, 0x01, 0x49, 0x1C,
+	0xC8, 0x40, 0x00, 0x03, 0xB0, 0xFB, 0xF4, 0xF0, 0x0C, 0x49, 0x08, 0x62,
+	0x10, 0xBD, 0x4F, 0xF0,
+	0x00, 0x50, 0x90, 0xF8, 0x4A, 0x00, 0x00, 0x07, 0x00, 0xD0, 0x01, 0x20,
+	0x70, 0x47, 0x00, 0xF0,
+	0x1F, 0x02, 0x01, 0x21, 0x91, 0x40, 0x40, 0x09, 0x80, 0x00, 0x00, 0xF1,
+	0xE0, 0x20, 0xC0, 0xF8,
+	0x80, 0x12, 0x70, 0x47, 0x40, 0x09, 0x00, 0x22, 0xC0, 0x04, 0x00, 0x22,
+	0x44, 0x04, 0x10, 0x00,
+	0x00, 0x09, 0x3D, 0x00, 0x00, 0x48, 0xE8, 0x01, 0x00, 0x24, 0xF4, 0x00,
+	0x00, 0x12, 0x7A, 0x00,
+	0x10, 0xB5, 0x01, 0x46, 0x34, 0x22, 0xF6, 0x48, 0x15, 0xF0, 0xCC, 0xFB,
+	0x01, 0x21, 0xBD, 0xE8,
+	0x10, 0x40, 0x00, 0x20, 0xFE, 0xF7, 0x8D, 0xBD, 0x38, 0xB5, 0x04, 0x46,
+	0xF1, 0x48, 0xF0, 0x4D,
+	0x20, 0x60, 0x20, 0x46, 0x15, 0xF0, 0x03, 0xF8, 0x00, 0x22, 0x6B, 0x46,
+	0x01, 0x21, 0x10, 0x46,
+	0xFE, 0xF7, 0xC8, 0xFD, 0x01, 0x21, 0x00, 0x20, 0xFE, 0xF7, 0xA7, 0xFD,
+	0x28, 0x78, 0x00, 0x28,
+	0x02, 0xD0, 0x10, 0xF0, 0x8A, 0xFD, 0xEC, 0xE7, 0x38, 0xBD, 0xE7, 0x48,
+	0x02, 0x68, 0x92, 0xF8,
+	0xB0, 0x00, 0xC1, 0x07, 0x0E, 0xD0, 0xE2, 0x49, 0x01, 0x23, 0x34, 0x31,
+	0x4B, 0x73, 0xC0, 0xF3,
+	0xC1, 0x03, 0x02, 0x2B, 0x01, 0xD1, 0x00, 0x23, 0x4B, 0x73, 0x80, 0x07,
+	0x02, 0xD5, 0x92, 0xF8,
+	0xBB, 0x00, 0x08, 0x73, 0x70, 0x47, 0xDC, 0x48, 0x10, 0xB5, 0x03, 0x68,
+	0x93, 0xF8, 0xB0, 0x20,
+	0xD0, 0x07, 0x16, 0xD0, 0x90, 0x07, 0x14, 0xD5, 0xD8, 0x48, 0x40, 0x78,
+	0x00, 0x28, 0x10, 0xD1,
+	0xD3, 0x48, 0x34, 0x30, 0x00, 0x21, 0x04, 0x7B, 0x0C, 0xB1, 0x41, 0x73,
+	0x08, 0xE0, 0x01, 0x24,
+	0xC2, 0xF3, 0xC1, 0x02, 0x44, 0x73, 0x02, 0x2A, 0x00, 0xD1, 0x41, 0x73,
+	0x93, 0xF8, 0xBB, 0x10,
+	0x01, 0x73, 0x10, 0xBD, 0x2D, 0xE9, 0xF0, 0x47, 0xDF, 0xF8, 0x2C, 0x83,
+	0x82, 0x46, 0x01, 0x27,
+	0xD8, 0xF8, 0x00, 0x00, 0xCA, 0x4D, 0x90, 0xF8, 0x31, 0x40, 0x10, 0xF8,
+	0x30, 0x1F, 0x90, 0xF8,
+	0x31, 0x00, 0x4C, 0x43, 0x00, 0xF0, 0x03, 0x00, 0x87, 0x40, 0xA1, 0x00,
+	0x28, 0x46, 0x15, 0xF0,
+	0xBD, 0xFB, 0xFF, 0xF7, 0xB2, 0xFF, 0x00, 0x26, 0xDF, 0xF8, 0xF4, 0x92,
+	0x15, 0xE0, 0xBC, 0x48,
+	0x34, 0x30, 0xFF, 0xF7, 0x91, 0xFF, 0x00, 0x20, 0xD9, 0xF8, 0x08, 0x10,
+	0x08, 0xE0, 0x00, 0xBF,
+	0x55, 0xF8, 0x20, 0x20, 0x31, 0xF9, 0x10, 0x30, 0x1A, 0x44, 0x45, 0xF8,
+	0x20, 0x20, 0x40, 0x1C,
+	0xA0, 0x42, 0xF5, 0xDB, 0xFF, 0xF7, 0xAF, 0xFF, 0x76, 0x1C, 0xBE, 0x42,
+	0xE7, 0xDB, 0x40, 0x46,
+	0x0A, 0xE0, 0x00, 0xBF, 0x02, 0x68, 0x55, 0xF8, 0x24, 0x10, 0x92, 0xF8,
+	0x61, 0x20, 0x02, 0xF0,
+	0x03, 0x02, 0x11, 0x41, 0x2A, 0xF8, 0x14, 0x10, 0x64, 0x1E, 0xF3, 0xD2,
+	0xBD, 0xE8, 0xF0, 0x87,
+	0x2D, 0xE9, 0xF0, 0x4F, 0xDF, 0xF8, 0xA0, 0xB2, 0x4F, 0xF0, 0x01, 0x09,
+	0xA8, 0x4E, 0xDB, 0xF8,
+	0x00, 0x00, 0x9F, 0xB0, 0x90, 0xF8, 0x61, 0x10, 0x90, 0xF8, 0x31, 0x40,
+	0xC1, 0xF3, 0x81, 0x08,
+	0x90, 0xF8, 0x30, 0x50, 0x09, 0xFA, 0x08, 0xFA, 0x60, 0x19, 0x81, 0x00,
+	0x06, 0xEB, 0x84, 0x07,
+	0x30, 0x46, 0x15, 0xF0, 0x73, 0xFB, 0x9A, 0x48, 0x34, 0x30, 0x14, 0xF0,
+	0x33, 0xFF, 0x98, 0x48,
+	0x34, 0x30, 0x80, 0xF8, 0x06, 0x90, 0xDB, 0xF8, 0x00, 0x10, 0x91, 0xF8,
+	0x60, 0x20, 0x92, 0x07,
+	0x01, 0xD5, 0x80, 0xF8, 0x04, 0x90, 0x91, 0xF8, 0x62, 0x10, 0x01, 0x73,
+	0xFF, 0xF7, 0x55, 0xFF,
+	0xDB, 0xF8, 0x00, 0x00, 0x90, 0xF8, 0x60, 0x00, 0xC0, 0x07, 0x05, 0xD0,
+	0x8C, 0x48, 0x34, 0x30,
+	0xFF, 0xF7, 0x32, 0xFF, 0xFF, 0xF7, 0x5F, 0xFF, 0x00, 0x20, 0x2E, 0xE0,
+	0x88, 0x48, 0x34, 0x30,
+	0xFF, 0xF7, 0x2A, 0xFF, 0xDF, 0xF8, 0x18, 0xB2, 0x62, 0x00, 0x13, 0xA8,
+	0xDB, 0xF8, 0x18, 0x10,
+	0x15, 0xF0, 0xA3, 0xFA, 0x6A, 0x00, 0x68, 0x46, 0xDB, 0xF8, 0x1C, 0x10,
+	0x15, 0xF0, 0x9D, 0xFA,
+	0x20, 0x46, 0x13, 0xA9, 0x07, 0xE0, 0x00, 0xBF, 0x56, 0xF8, 0x20, 0x20,
+	0x31, 0xF9, 0x10, 0x30,
+	0x1A, 0x44, 0x46, 0xF8, 0x20, 0x20, 0x40, 0x1E, 0xF6, 0xD2, 0x28, 0x46,
+	0x69, 0x46, 0x06, 0xE0,
+	0x57, 0xF8, 0x20, 0x20, 0x31, 0xF9, 0x10, 0x30, 0x1A, 0x44, 0x47, 0xF8,
+	0x20, 0x20, 0x40, 0x1E,
+	0xF6, 0xD2, 0xFF, 0xF7, 0x30, 0xFF, 0x09, 0xF1, 0x01, 0x00, 0x81, 0x46,
+	0x50, 0x45, 0xCD, 0xDB,
+	0x74, 0x49, 0x05, 0xE0, 0x56, 0xF8, 0x24, 0x00, 0x40, 0xFA, 0x08, 0xF0,
+	0x21, 0xF8, 0x14, 0x00,
+	0x64, 0x1E, 0xF7, 0xD2, 0x70, 0x49, 0x05, 0xE0, 0x57, 0xF8, 0x25, 0x00,
+	0x40, 0xFA, 0x08, 0xF0,
+	0x21, 0xF8, 0x15, 0x00, 0x6D, 0x1E, 0xF7, 0xD2, 0x1F, 0xB0, 0xBD, 0xE8,
+	0xF0, 0x8F, 0x2D, 0xE9,
+	0xFF, 0x5F, 0xDF, 0xF8, 0x94, 0x81, 0x66, 0x4F, 0xD8, 0xF8, 0x00, 0x00,
+	0x90, 0xF8, 0x31, 0x40,
+	0x90, 0xF8, 0x30, 0x50, 0x07, 0xEB, 0x84, 0x0A, 0x60, 0x19, 0x81, 0x00,
+	0x04, 0xFB, 0x05, 0xFB,
+	0x0A, 0xEB, 0x85, 0x06, 0x38, 0x46, 0x15, 0xF0, 0xF1, 0xFA, 0x4F, 0xEA,
+	0x8B, 0x01, 0x30, 0x46,
+	0x15, 0xF0, 0xEC, 0xFA, 0x56, 0x48, 0x34, 0x30, 0x14, 0xF0, 0xAC, 0xFE,
+	0x54, 0x48, 0x4F, 0xF0,
+	0x01, 0x09, 0x34, 0x30, 0x80, 0xF8, 0x06, 0x90, 0x80, 0xF8, 0x04, 0x90,
+	0xD8, 0xF8, 0x00, 0x10,
+	0x91, 0xF8, 0x62, 0x10, 0x01, 0x73, 0xFF, 0xF7, 0xD0, 0xFE, 0xD8, 0xF8,
+	0x00, 0x00, 0x90, 0xF8,
+	0x60, 0x00, 0xC0, 0x07, 0x05, 0xD0, 0x4A, 0x48, 0x34, 0x30, 0xFF, 0xF7,
+	0xAD, 0xFE, 0xFF, 0xF7,
+	0xDA, 0xFE, 0xD8, 0xF8, 0x00, 0x00, 0x90, 0xF8, 0x61, 0x00, 0xC0, 0xF3,
+	0x81, 0x01, 0x02, 0x91,
+	0x00, 0xF0, 0x03, 0x01, 0x03, 0x91, 0x02, 0x99, 0x48, 0x46, 0x09, 0xFA,
+	0x01, 0xF9, 0x03, 0x99,
+	0x88, 0x40, 0x01, 0x90, 0x00, 0x20, 0x32, 0xE0, 0x3D, 0x48, 0x34, 0x30,
+	0xFF, 0xF7, 0x94, 0xFE,
+	0x3B, 0x48, 0xD0, 0xE9, 0x06, 0x32, 0x81, 0x68, 0x20, 0x46, 0x06, 0xE0,
+	0x57, 0xF8, 0x20, 0xC0,
+	0x33, 0xF9, 0x10, 0x80, 0xC4, 0x44, 0x47, 0xF8, 0x20, 0xC0, 0x40, 0x1E,
+	0xF6, 0xD2, 0x28, 0x46,
+	0x07, 0xE0, 0x00, 0xBF, 0x5A, 0xF8, 0x20, 0x30, 0x32, 0xF9, 0x10, 0xC0,
+	0x9C, 0x44, 0x4A, 0xF8,
+	0x20, 0xC0, 0x40, 0x1E, 0xF6, 0xD2, 0xDD, 0xE9, 0x00, 0x02, 0x90, 0x42,
+	0x0B, 0xDA, 0x58, 0x46,
+	0x07, 0xE0, 0x00, 0xBF, 0x56, 0xF8, 0x20, 0x20, 0x31, 0xF9, 0x10, 0x30,
+	0x1A, 0x44, 0x46, 0xF8,
+	0x20, 0x20, 0x40, 0x1E, 0xF6, 0xD2, 0xFF, 0xF7, 0x96, 0xFE, 0x00, 0x98,
+	0x40, 0x1C, 0x00, 0x90,
+	0x48, 0x45, 0xC9, 0xDB, 0x01, 0x98, 0x48, 0x45, 0x1F, 0xDD, 0x21, 0x48,
+	0x00, 0x21, 0x34, 0x30,
+	0x88, 0x46, 0x81, 0x71, 0x01, 0x99, 0xA1, 0xEB, 0x09, 0x09, 0x14, 0xE0,
+	0x1C, 0x48, 0x34, 0x30,
+	0xFF, 0xF7, 0x52, 0xFE, 0x1A, 0x48, 0x81, 0x68, 0x58, 0x46, 0x06, 0xE0,
+	0x56, 0xF8, 0x20, 0x20,
+	0x31, 0xF9, 0x10, 0x30, 0x1A, 0x44, 0x46, 0xF8, 0x20, 0x20, 0x40, 0x1E,
+	0xF6, 0xD2, 0xFF, 0xF7,
+	0x72, 0xFE, 0x08, 0xF1, 0x01, 0x08, 0xC1, 0x45, 0xE8, 0xDC, 0x16, 0x49,
+	0x06, 0xE0, 0x00, 0xBF,
+	0x57, 0xF8, 0x24, 0x00, 0x02, 0x9A, 0x10, 0x41, 0x21, 0xF8, 0x14, 0x00,
+	0x64, 0x1E, 0xF7, 0xD2,
+	0x11, 0x49, 0x05, 0xE0, 0x5A, 0xF8, 0x25, 0x00, 0x02, 0x9A, 0x10, 0x41,
+	0x21, 0xF8, 0x15, 0x00,
+	0x6D, 0x1E, 0xF7, 0xD2, 0x58, 0x46, 0x0D, 0x4A, 0x06, 0xE0, 0x00, 0xBF,
+	0x56, 0xF8, 0x20, 0x10,
+	0x03, 0x9B, 0x19, 0x41, 0x22, 0xF8, 0x10, 0x10, 0x40, 0x1E, 0xF7, 0xD2,
+	0xBD, 0xE8, 0xFF, 0x9F,
+	0xF4, 0x0E, 0x10, 0x00, 0xF1, 0x19, 0x00, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x74, 0x07, 0x10, 0x00,
+	0xD4, 0x56, 0x10, 0x00, 0x7E, 0x4A, 0x01, 0x20, 0xA8, 0x4A, 0x01, 0x20,
+	0x42, 0x44, 0x01, 0x20,
+	0x2D, 0xE9, 0xF8, 0x43, 0x14, 0xF0, 0x53, 0xFE, 0x00, 0x90, 0x04, 0x21,
+	0x68, 0x46, 0xFF, 0xF7,
+	0xDA, 0xF9, 0xDF, 0xF8, 0xA0, 0x82, 0xC6, 0xB2, 0x01, 0x27, 0xD8, 0xF8,
+	0x00, 0x00, 0xA6, 0x4C,
+	0x90, 0xF8, 0x61, 0x00, 0x80, 0x09, 0x07, 0xFA, 0x00, 0xF5, 0xB1, 0x00,
+	0x20, 0x46, 0x15, 0xF0,
+	0x15, 0xFA, 0xA2, 0x48, 0x14, 0xF0, 0xD6, 0xFD, 0xA0, 0x48, 0xA0, 0xF1,
+	0x34, 0x09, 0x87, 0x72,
+	0x00, 0x27, 0x12, 0xE0, 0x9D, 0x48, 0xFF, 0xF7, 0xE7, 0xFD, 0x00, 0x20,
+	0xD9, 0xF8, 0x2C, 0x10,
+	0x08, 0xE0, 0x00, 0xBF, 0x54, 0xF8, 0x20, 0x20, 0x31, 0xF9, 0x10, 0x30,
+	0x1A, 0x44, 0x44, 0xF8,
+	0x20, 0x20, 0x40, 0x1C, 0xB0, 0x42, 0xF5, 0xDB, 0x7F, 0x1C, 0xAF, 0x42,
+	0xEA, 0xDB, 0x00, 0x20,
+	0x93, 0x4B, 0xD8, 0xF8, 0x00, 0x10, 0x08, 0xE0, 0x91, 0xF8, 0x61, 0x50,
+	0x54, 0xF8, 0x20, 0x20,
+	0xAD, 0x09, 0x2A, 0x41, 0x23, 0xF8, 0x10, 0x20, 0x40, 0x1C, 0xB0, 0x42,
+	0xF4, 0xDB, 0xBD, 0xE8,
+	0xF8, 0x83, 0x2D, 0xE9, 0xF0, 0x47, 0x05, 0x46, 0x00, 0x20, 0xFE, 0xF7,
+	0x2A, 0xFC, 0x02, 0x20,
+	0xFE, 0xF7, 0x27, 0xFC, 0x03, 0x20, 0xFE, 0xF7, 0x24, 0xFC, 0x86, 0x4E,
+	0x00, 0x20, 0x30, 0x70,
+	0x82, 0x48, 0x14, 0xF0, 0x97, 0xFD, 0x84, 0x48, 0x01, 0x24, 0x04, 0x70,
+	0x7D, 0x4F, 0xDF, 0xF8,
+	0x0C, 0x82, 0xDF, 0xF8, 0x0C, 0x92, 0x38, 0x68, 0x90, 0xF8, 0x60, 0x00,
+	0x80, 0x07, 0x4F, 0xEA,
+	0x05, 0x70, 0x0B, 0xD5, 0x00, 0x28, 0x11, 0xDA, 0xA8, 0x07, 0x09, 0xD5,
+	0x34, 0x70, 0xFF, 0xF7,
+	0xB6, 0xFE, 0x88, 0xF8, 0x00, 0x40, 0x89, 0xF8, 0x00, 0x40, 0x01, 0xE0,
+	0x00, 0x28, 0x05, 0xDA,
+	0x30, 0x78, 0x18, 0xB9, 0xFF, 0xF7, 0x24, 0xFE, 0x88, 0xF8, 0x00, 0x40,
+	0x28, 0x06, 0x08, 0xD5,
+	0x38, 0x68, 0x90, 0xF8, 0x2F, 0x0A, 0xC0, 0x07, 0x03, 0xD0, 0x72, 0x48,
+	0x04, 0x70, 0xFF, 0xF7,
+	0x77, 0xFF, 0xDF, 0xF8, 0xA8, 0x81, 0xA8, 0x07, 0x11, 0xD5, 0x30, 0x78,
+	0xD0, 0xB9, 0x40, 0x46,
+	0x14, 0xF0, 0x60, 0xFD, 0x88, 0xF8, 0x04, 0x40, 0x6B, 0x48, 0xFF, 0xF7,
+	0xC3, 0xFD, 0x6A, 0x48,
+	0x00, 0xF0, 0x23, 0xF8, 0x69, 0x49, 0x08, 0x70, 0x89, 0xF8, 0x00, 0x40,
+	0x0A, 0xE0, 0x68, 0x07,
+	0x08, 0xD5, 0x5E, 0x48, 0x14, 0xF0, 0x4E, 0xFD, 0x04, 0x21, 0x88, 0xF8,
+	0x04, 0x10, 0x62, 0x48,
+	0xFF, 0xF7, 0xB0, 0xFD, 0x38, 0x68, 0x90, 0xF8, 0x61, 0x04, 0x18, 0xB1,
+	0xE8, 0x06, 0x01, 0xD5,
+	0x00, 0xF0, 0x5E, 0xF8, 0x03, 0x20, 0xFE, 0xF7, 0xDF, 0xFB, 0x02, 0x20,
+	0xFE, 0xF7, 0xDC, 0xFB,
+	0xBD, 0xE8, 0xF0, 0x47, 0x00, 0x20, 0xFE, 0xF7, 0xD7, 0xBB, 0x2D, 0xE9,
+	0xF0, 0x43, 0x4D, 0x49,
+	0x4F, 0xF0, 0x00, 0x09, 0xCC, 0x46, 0x0F, 0x68, 0x4B, 0x46, 0x97, 0xF8,
+	0x31, 0x20, 0x97, 0xF8,
+	0x30, 0x60, 0x97, 0xF8, 0x60, 0x40, 0x02, 0xFB, 0x06, 0xF1, 0x09, 0xB2,
+	0x64, 0x07, 0x37, 0xD5,
+	0x4F, 0x4C, 0x24, 0x68, 0x25, 0x8E, 0x8D, 0x42, 0x32, 0xD1, 0x32, 0x34,
+	0x28, 0xE0, 0x35, 0x46,
+	0x20, 0xE0, 0x00, 0xBF, 0x34, 0xF8, 0x15, 0x10, 0x30, 0xF8, 0x15, 0x80,
+	0xA1, 0xEB, 0x08, 0x01,
+	0x09, 0xB2, 0x00, 0x29, 0x01, 0xDB, 0x88, 0x46, 0x01, 0xE0, 0xC1, 0xF1,
+	0x00, 0x08, 0xE0, 0x45,
+	0x07, 0xDD, 0x00, 0x29, 0x01, 0xDB, 0x8C, 0x46, 0x01, 0xE0, 0xC1, 0xF1,
+	0x00, 0x0C, 0x0F, 0xFA,
+	0x8C, 0xFC, 0x00, 0x29, 0x00, 0xDA, 0x49, 0x42, 0xB7, 0xF8, 0x63, 0x80,
+	0x41, 0x45, 0x01, 0xDD,
+	0x5B, 0x1C, 0x9B, 0xB2, 0x6D, 0x1E, 0xDD, 0xD1, 0x04, 0xEB, 0x46, 0x04,
+	0x00, 0xEB, 0x46, 0x00,
+	0x52, 0x1E, 0xD4, 0xD2, 0x97, 0xF8, 0x65, 0x00, 0x98, 0x42, 0x01, 0xD2,
+	0x4F, 0xF0, 0x01, 0x09,
+	0x34, 0x48, 0xA0, 0xF8, 0x00, 0xC0, 0x34, 0x48, 0x03, 0x80, 0x48, 0x46,
+	0xBD, 0xE8, 0xF0, 0x83,
+	0x2D, 0xE9, 0xF0, 0x47, 0xDF, 0xF8, 0x8C, 0x80, 0x01, 0x21, 0x45, 0x46,
+	0xD8, 0xF8, 0x00, 0x00,
+	0x00, 0xF2, 0x61, 0x40, 0xFF, 0xF7, 0xC7, 0xF8, 0x04, 0x46, 0x28, 0x68,
+	0x01, 0x27, 0x1E, 0x4D,
+	0x90, 0xF8, 0x61, 0x00, 0xC0, 0xF3, 0x01, 0x10, 0x07, 0xFA, 0x00, 0xF6,
+	0xA1, 0x00, 0x28, 0x46,
+	0x15, 0xF0, 0x04, 0xF9, 0x19, 0x48, 0x14, 0xF0, 0xC5, 0xFC, 0x18, 0x48,
+	0xA0, 0xF1, 0x34, 0x09,
+	0x47, 0x72, 0x00, 0x27, 0x11, 0xE0, 0x15, 0x48, 0xFF, 0xF7, 0xD6, 0xFC,
+	0x00, 0x20, 0xD9, 0xF8,
+	0x14, 0x10, 0x07, 0xE0, 0x55, 0xF8, 0x20, 0x20, 0x31, 0xF9, 0x10, 0x30,
+	0x1A, 0x44, 0x45, 0xF8,
+	0x20, 0x20, 0x40, 0x1C, 0xA0, 0x42, 0xF5, 0xDB, 0x7F, 0x1C, 0xB7, 0x42,
+	0xEB, 0xDB, 0x00, 0x20,
+	0x16, 0x4B, 0xD8, 0xF8, 0x00, 0x10, 0x09, 0xE0, 0x91, 0xF8, 0x61, 0x60,
+	0x55, 0xF8, 0x20, 0x20,
+	0xC6, 0xF3, 0x01, 0x16, 0x32, 0x41, 0x23, 0xF8, 0x10, 0x20, 0x40, 0x1C,
+	0xA0, 0x42, 0xF3, 0xDB,
+	0x44, 0xE5, 0x00, 0x00, 0x4C, 0x07, 0x10, 0x00, 0xD4, 0x56, 0x10, 0x00,
+	0x28, 0x0F, 0x10, 0x00,
+	0xFC, 0x4A, 0x01, 0x20, 0x68, 0x04, 0x10, 0x00, 0x78, 0x07, 0x10, 0x00,
+	0x7A, 0x07, 0x10, 0x00,
+	0x79, 0x07, 0x10, 0x00, 0x7C, 0x07, 0x10, 0x00, 0x42, 0x44, 0x01, 0x20,
+	0x7D, 0x07, 0x10, 0x00,
+	0x50, 0x07, 0x10, 0x00, 0x7E, 0x07, 0x10, 0x00, 0x80, 0x07, 0x10, 0x00,
+	0xF4, 0x4A, 0x01, 0x20,
+	0x10, 0xB5, 0x01, 0x46, 0x34, 0x22, 0xFE, 0x48, 0x15, 0xF0, 0x54, 0xF8,
+	0x01, 0x21, 0xBD, 0xE8,
+	0x10, 0x40, 0x00, 0x20, 0xFE, 0xF7, 0x15, 0xBA, 0x38, 0xB5, 0x04, 0x46,
+	0xF9, 0x48, 0xF8, 0x4D,
+	0x20, 0x60, 0x20, 0x46, 0x14, 0xF0, 0x8B, 0xFC, 0x00, 0x22, 0x6B, 0x46,
+	0x01, 0x21, 0x10, 0x46,
+	0xFE, 0xF7, 0x50, 0xFA, 0x01, 0x21, 0x00, 0x20, 0xFE, 0xF7, 0x2F, 0xFA,
+	0x28, 0x78, 0x00, 0x28,
+	0x02, 0xD0, 0x10, 0xF0, 0x12, 0xFA, 0xEC, 0xE7, 0x38, 0xBD, 0x2D, 0xE9,
+	0xFF, 0x41, 0x00, 0x24,
+	0xDD, 0xE9, 0x0A, 0x76, 0x04, 0x21, 0x68, 0x46, 0xFF, 0xF7, 0x3D, 0xF8,
+	0x05, 0x46, 0x08, 0x21,
+	0x02, 0xA8, 0xFF, 0xF7, 0x38, 0xF8, 0x02, 0x46, 0x00, 0x20, 0x6F, 0xF0,
+	0x7E, 0x0E, 0x14, 0xE0,
+	0x00, 0x21, 0x00, 0xFB, 0x02, 0xF3, 0x0D, 0xE0, 0x07, 0xEB, 0x01, 0x0C,
+	0x13, 0xF9, 0x0C, 0xC0,
+	0xB4, 0x44, 0xF4, 0x45, 0x01, 0xDA, 0x01, 0x24, 0x03, 0xE0, 0xBC, 0xF1,
+	0x7F, 0x0F, 0x00, 0xDD,
+	0x02, 0x24, 0x49, 0x1C, 0x91, 0x42, 0xEF, 0xDB, 0x40, 0x1C, 0xA8, 0x42,
+	0xE8, 0xDB, 0x20, 0x46,
+	0x04, 0xB0, 0xBD, 0xE8, 0xF0, 0x81, 0x2D, 0xE9, 0xFF, 0x41, 0x0A, 0xA9,
+	0x00, 0x24, 0x91, 0xE8,
+	0xC0, 0x01, 0x04, 0x21, 0x68, 0x46, 0xFF, 0xF7, 0x0E, 0xF8, 0x05, 0x46,
+	0x08, 0x21, 0x02, 0xA8,
+	0xFF, 0xF7, 0x09, 0xF8, 0x01, 0x46, 0x00, 0x20, 0x08, 0xE0, 0x32, 0x56,
+	0xD2, 0x19, 0x01, 0xD5,
+	0x01, 0x24, 0x02, 0xE0, 0xFF, 0x2A, 0x00, 0xDD, 0x02, 0x24, 0x40, 0x1C,
+	0xA8, 0x42, 0xF4, 0xDB,
+	0x00, 0x20, 0x0A, 0xE0, 0x2A, 0x18, 0xB2, 0x56, 0x12, 0xEB, 0x08, 0x02,
+	0x01, 0xD5, 0x01, 0x24,
+	0x02, 0xE0, 0xFF, 0x2A, 0x00, 0xDD, 0x02, 0x24, 0x40, 0x1C, 0x88, 0x42,
+	0xF2, 0xDB, 0x20, 0x46,
+	0xCE, 0xE7, 0x2D, 0xE9, 0xF0, 0x4F, 0x8D, 0xB0, 0x14, 0xF0, 0x51, 0xFC,
+	0x0C, 0x90, 0x14, 0xF0,
+	0x50, 0xFC, 0xBD, 0x4E, 0x04, 0x46, 0x0D, 0x46, 0x30, 0x68, 0x90, 0xF8,
+	0xE7, 0x00, 0x10, 0xF0,
+	0x60, 0x0F, 0x03, 0xD0, 0x0C, 0x98, 0x11, 0xF0, 0x67, 0xF9, 0x0C, 0x90,
+	0xDF, 0xF8, 0xD8, 0xA2,
+	0x01, 0x21, 0xDA, 0xF8, 0x00, 0x00, 0x90, 0xF8, 0x31, 0x60, 0x90, 0xF8,
+	0x30, 0x80, 0x06, 0xFB,
+	0x08, 0xF0, 0x0B, 0x90, 0x06, 0xA8, 0x0E, 0xF0, 0x42, 0xFC, 0xB0, 0x4F,
+	0x4F, 0xF0, 0x00, 0x0B,
+	0xDF, 0xF8, 0xBC, 0x92, 0x39, 0x68, 0x06, 0x9B, 0x22, 0x46, 0x91, 0xF9,
+	0x1B, 0x10, 0xCD, 0xF8,
+	0x0C, 0xB0, 0xCD, 0xF8, 0x00, 0x90, 0xCD, 0xE9, 0x01, 0x31, 0x2B, 0x46,
+	0x0C, 0x98, 0x11, 0xF0,
+	0xC5, 0xF9, 0x06, 0x9B, 0x01, 0x20, 0xCD, 0xE9, 0x00, 0x93, 0xCD, 0xE9,
+	0x02, 0xB0, 0x22, 0x46,
+	0x2B, 0x46, 0x0C, 0x98, 0x11, 0xF0, 0xBA, 0xF9, 0x9D, 0x48, 0x34, 0x30,
+	0x14, 0xF0, 0xB2, 0xFB,
+	0x9B, 0x49, 0x05, 0x20, 0x34, 0x31, 0x08, 0x71, 0x08, 0x46, 0xFF, 0xF7,
+	0x3D, 0xFF, 0x98, 0x48,
+	0x02, 0x21, 0x80, 0x68, 0x00, 0x90, 0x0A, 0xA8, 0x0E, 0xF0, 0x11, 0xFC,
+	0xDA, 0xF8, 0x00, 0x00,
+	0xB0, 0xF9, 0xC2, 0xA1, 0xB0, 0xF9, 0xC4, 0x91, 0x0A, 0xEB, 0x09, 0x01,
+	0x49, 0x10, 0x02, 0x91,
+	0x90, 0xF8, 0xE8, 0x00, 0x80, 0x07, 0x09, 0xD4, 0xA8, 0xF1, 0x01, 0x00,
+	0x70, 0x43, 0x00, 0x99,
+	0x0B, 0x90, 0x43, 0x46, 0x32, 0x46, 0x08, 0x46, 0x00, 0xF0, 0x76, 0xFB,
+	0xDD, 0xE9, 0x0A, 0x12,
+	0x00, 0x98, 0x11, 0xF0, 0x8C, 0xFF, 0x80, 0x46, 0x02, 0x21, 0x0A, 0xA8,
+	0x0E, 0xF0, 0x82, 0xFC,
+	0x00, 0x26, 0xD0, 0x45, 0x01, 0xDC, 0xC8, 0x45, 0x09, 0xDA, 0x83, 0x48,
+	0x02, 0x99, 0x00, 0x68,
+	0xA8, 0xEB, 0x01, 0x01, 0xB0, 0xF8, 0xC6, 0x01, 0x91, 0xFB, 0xF0, 0xF0,
+	0x46, 0xB2, 0x06, 0x98,
+	0xCD, 0xE9, 0x00, 0x06, 0x22, 0x46, 0x2B, 0x46, 0x0C, 0x98, 0xFF, 0xF7,
+	0x16, 0xFF, 0x01, 0x28,
+	0x18, 0xD0, 0x02, 0x28, 0x1C, 0xD0, 0x38, 0x68, 0x79, 0x49, 0x2B, 0x46,
+	0xC6, 0x76, 0x01, 0x20,
+	0x06, 0x9A, 0x03, 0x90, 0x8D, 0xE8, 0x46, 0x00, 0x22, 0x46, 0x0C, 0x98,
+	0x11, 0xF0, 0x5E, 0xF9,
+	0x39, 0x68, 0xA5, 0x20, 0x88, 0x76, 0x01, 0x21, 0x06, 0xA8, 0x0E, 0xF0,
+	0x53, 0xFC, 0x0D, 0xB0,
+	0xBD, 0xE8, 0xF0, 0x8F, 0x39, 0x68, 0x81, 0xF8, 0x1B, 0xB0, 0x01, 0x21,
+	0xB0, 0x20, 0x04, 0xE0,
+	0x39, 0x68, 0xB1, 0x20, 0x81, 0xF8, 0x1B, 0xB0, 0x01, 0x21, 0x10, 0xF0,
+	0xEF, 0xF8, 0xE7, 0xE7,
+	0x2D, 0xE9, 0xF0, 0x4F, 0x64, 0x4F, 0x8D, 0xB0, 0x38, 0x68, 0x90, 0xF8,
+	0x31, 0x60, 0x90, 0xF8,
+	0x30, 0x80, 0x14, 0xF0, 0x94, 0xFB, 0x0B, 0x90, 0x14, 0xF0, 0x93, 0xFB,
+	0x04, 0x46, 0x38, 0x68,
+	0x0D, 0x46, 0x90, 0xF8, 0xE7, 0x00, 0x10, 0xF0, 0x60, 0x0F, 0x03, 0xD0,
+	0x0B, 0x98, 0x11, 0xF0,
+	0xAB, 0xF8, 0x0B, 0x90, 0x01, 0x21, 0x04, 0xA8, 0x0E, 0xF0, 0x91, 0xFB,
+	0x57, 0x4F, 0x4F, 0xF0,
+	0x00, 0x0A, 0xDF, 0xF8, 0x60, 0x91, 0x38, 0x68, 0x04, 0x9B, 0x90, 0xF9,
+	0x1D, 0x20, 0xCD, 0xF8,
+	0x0C, 0xA0, 0xCD, 0xF8, 0x00, 0x90, 0xCD, 0xE9, 0x01, 0x32, 0x22, 0x46,
+	0x2B, 0x46, 0x0B, 0x98,
+	0x11, 0xF0, 0x14, 0xF9, 0x04, 0x9B, 0x01, 0x21, 0xCD, 0xE9, 0x00, 0x93,
+	0xCD, 0xE9, 0x02, 0xA1,
+	0x22, 0x46, 0x2B, 0x46, 0x0B, 0x98, 0x11, 0xF0, 0x09, 0xF9, 0x45, 0x48,
+	0x34, 0x30, 0x14, 0xF0,
+	0x01, 0xFB, 0x43, 0x49, 0x06, 0x20, 0x34, 0x31, 0x08, 0x71, 0x08, 0x46,
+	0xFF, 0xF7, 0x8C, 0xFE,
+	0x3F, 0x48, 0x02, 0x21, 0x80, 0x68, 0x00, 0x90, 0x0A, 0xA8, 0x0E, 0xF0,
+	0x60, 0xFB, 0x3E, 0x48,
+	0x06, 0xFB, 0x08, 0xFB, 0x00, 0x68, 0xB0, 0xF9, 0xC8, 0x11, 0xB0, 0xF9,
+	0xCA, 0x21, 0x11, 0x44,
+	0x49, 0x10, 0x01, 0x91, 0x90, 0xF8, 0xE8, 0x00, 0x80, 0x07, 0x09, 0xD4,
+	0xA8, 0xF1, 0x01, 0x00,
+	0x00, 0x99, 0x06, 0xFB, 0x00, 0xFB, 0x43, 0x46, 0x32, 0x46, 0x08, 0x46,
+	0x00, 0xF0, 0xC4, 0xFA,
+	0x5A, 0x46, 0x0A, 0x99, 0x00, 0x98, 0x11, 0xF0, 0xDA, 0xFE, 0x80, 0x46,
+	0x02, 0x21, 0x0A, 0xA8,
+	0x0E, 0xF0, 0xD0, 0xFB, 0x2C, 0x48, 0x00, 0x26, 0x00, 0x68, 0xB0, 0xF9,
+	0xC8, 0x21, 0x42, 0x45,
+	0x03, 0xDB, 0xB0, 0xF9, 0xCA, 0x21, 0x42, 0x45, 0x07, 0xDD, 0x01, 0x9A,
+	0xB0, 0xF8, 0xCC, 0x01,
+	0xA8, 0xEB, 0x02, 0x01, 0x91, 0xFB, 0xF0, 0xF0, 0x46, 0xB2, 0x04, 0x98,
+	0xCD, 0xE9, 0x00, 0x06,
+	0x22, 0x46, 0x2B, 0x46, 0x0B, 0x98, 0xFF, 0xF7, 0x60, 0xFE, 0x4F, 0xF4,
+	0x80, 0x71, 0x01, 0x28,
+	0x17, 0xD0, 0x02, 0x28, 0x1A, 0xD0, 0x38, 0x68, 0x2B, 0x46, 0x46, 0x77,
+	0x01, 0x20, 0x04, 0x9A,
+	0xCD, 0xF8, 0x00, 0x90, 0x03, 0x90, 0xCD, 0xE9, 0x01, 0x26, 0x22, 0x46,
+	0x0B, 0x98, 0x11, 0xF0,
+	0xA5, 0xF8, 0x39, 0x68, 0xA5, 0x20, 0x08, 0x77, 0x01, 0x21, 0x04, 0xA8,
+	0x0E, 0xF0, 0x9A, 0xFB,
+	0x45, 0xE7, 0x3A, 0x68, 0xB0, 0x20, 0x82, 0xF8, 0x1D, 0xA0, 0x03, 0xE0,
+	0x3A, 0x68, 0xB1, 0x20,
+	0x82, 0xF8, 0x1D, 0xA0, 0x10, 0xF0, 0x3A, 0xF8, 0xEB, 0xE7, 0x2D, 0xE9,
+	0xF0, 0x4F, 0x87, 0xB0,
+	0x14, 0xF0, 0xE9, 0xFA, 0x05, 0x90, 0x14, 0xF0, 0xE8, 0xFA, 0x04, 0x46,
+	0x0D, 0x46, 0x01, 0x21,
+	0x04, 0xA8, 0x0E, 0xF0, 0xEC, 0xFA, 0x4F, 0xF0, 0x00, 0x0A, 0x56, 0x46,
+	0x03, 0x4F, 0x0B, 0xE0,
+	0x38, 0x0F, 0x10, 0x00, 0xE1, 0x20, 0x00, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x50, 0x07, 0x10, 0x00,
+	0x78, 0x8B, 0x01, 0x20, 0x08, 0x92, 0x01, 0x20, 0x38, 0x68, 0xDF, 0xF8,
+	0x2C, 0x94, 0x04, 0x9A,
+	0x90, 0xF9, 0x25, 0x10, 0xCD, 0xF8, 0x0C, 0xA0, 0xCD, 0xF8, 0x00, 0x90,
+	0xCD, 0xE9, 0x01, 0x21,
+	0x22, 0x46, 0x2B, 0x46, 0x05, 0x98, 0x11, 0xF0, 0x61, 0xF8, 0x01, 0x21,
+	0x04, 0x9A, 0xCD, 0xF8,
+	0x00, 0x90, 0x03, 0x91, 0xCD, 0xE9, 0x01, 0x26, 0x22, 0x46, 0x2B, 0x46,
+	0x05, 0x98, 0x11, 0xF0,
+	0x55, 0xF8, 0xFE, 0x48, 0x14, 0xF0, 0x4E, 0xFA, 0xFC, 0x48, 0x02, 0x21,
+	0x41, 0x72, 0xFF, 0xF7,
+	0xDB, 0xFD, 0xFA, 0x48, 0x02, 0x21, 0x34, 0x38, 0x46, 0x69, 0x06, 0xA8,
+	0x0E, 0xF0, 0xAF, 0xFA,
+	0xDF, 0xF8, 0xDC, 0xB3, 0x01, 0x21, 0xDB, 0xF8, 0x00, 0x00, 0x00, 0xF2,
+	0x61, 0x40, 0xFE, 0xF7,
+	0x2A, 0xFE, 0x02, 0x46, 0x30, 0x46, 0x06, 0x99, 0x11, 0xF0, 0x39, 0xFE,
+	0x80, 0x46, 0x02, 0x21,
+	0x06, 0xA8, 0x0E, 0xF0, 0x2F, 0xFB, 0xDB, 0xF8, 0x00, 0x10, 0x00, 0x26,
+	0xB1, 0xF9, 0xDC, 0x21,
+	0xB1, 0xF9, 0xDE, 0x31, 0xD0, 0x18, 0x4F, 0xEA, 0x60, 0x0C, 0x90, 0x45,
+	0x01, 0xDC, 0x98, 0x45,
+	0x06, 0xDA, 0xB1, 0xF8, 0xE0, 0x11, 0xA8, 0xEB, 0x0C, 0x00, 0x90, 0xFB,
+	0xF1, 0xF0, 0x46, 0xB2,
+	0x04, 0x98, 0xCD, 0xE9, 0x00, 0x06, 0x22, 0x46, 0x2B, 0x46, 0x05, 0x98,
+	0xFF, 0xF7, 0xBD, 0xFD,
+	0x01, 0x28, 0x1A, 0xD0, 0x02, 0x28, 0x1E, 0xD0, 0x38, 0x68, 0x2B, 0x46,
+	0x80, 0xF8, 0x25, 0x60,
+	0x01, 0x20, 0x04, 0x9A, 0xCD, 0xF8, 0x00, 0x90, 0x03, 0x90, 0xCD, 0xE9,
+	0x01, 0x26, 0x22, 0x46,
+	0x05, 0x98, 0x11, 0xF0, 0x03, 0xF8, 0x39, 0x68, 0xA5, 0x20, 0x81, 0xF8,
+	0x24, 0x00, 0x01, 0x21,
+	0x04, 0xA8, 0x0E, 0xF0, 0xF7, 0xFA, 0x07, 0xB0, 0xA2, 0xE6, 0x39, 0x68,
+	0x81, 0xF8, 0x25, 0xA0,
+	0x02, 0x21, 0xB0, 0x20, 0x04, 0xE0, 0x39, 0x68, 0xB1, 0x20, 0x81, 0xF8,
+	0x25, 0xA0, 0x02, 0x21,
+	0x0F, 0xF0, 0x94, 0xFF, 0xE7, 0xE7, 0x2D, 0xE9, 0xF0, 0x4F, 0xC9, 0x48,
+	0x89, 0xB0, 0x00, 0x68,
+	0x90, 0xF8, 0x31, 0x60, 0x90, 0xF8, 0x30, 0xB0, 0x14, 0xF0, 0x39, 0xFA,
+	0x07, 0x90, 0x14, 0xF0,
+	0x38, 0xFA, 0x04, 0x46, 0x0D, 0x46, 0x01, 0x21, 0x06, 0xA8, 0x0E, 0xF0,
+	0x40, 0xFA, 0xDF, 0xF8,
+	0x04, 0xA3, 0x02, 0xAB, 0x00, 0x27, 0xDA, 0xF8, 0x00, 0x00, 0x06, 0x9A,
+	0x90, 0xF9, 0x20, 0x10,
+	0x90, 0xF9, 0x1F, 0x00, 0x83, 0xE8, 0x83, 0x00, 0xB7, 0x48, 0x2B, 0x46,
+	0xA0, 0x30, 0xCD, 0xE9,
+	0x00, 0x02, 0x08, 0x90, 0x22, 0x46, 0x07, 0x98, 0x11, 0xF0, 0x0C, 0xF8,
+	0x06, 0x99, 0xCD, 0xE9,
+	0x01, 0x17, 0x01, 0x20, 0xCD, 0xE9, 0x03, 0x70, 0x08, 0x98, 0x00, 0x90,
+	0x22, 0x46, 0x2B, 0x46,
+	0x07, 0x98, 0x10, 0xF0, 0xFF, 0xFF, 0xAD, 0x48, 0x14, 0xF0, 0xAC, 0xF9,
+	0xAB, 0x48, 0x03, 0x21,
+	0x81, 0x71, 0xFF, 0xF7, 0x39, 0xFD, 0xA9, 0x48, 0x02, 0x21, 0x34, 0x38,
+	0xD0, 0xE9, 0x06, 0x70,
+	0x00, 0x90, 0xA7, 0x48, 0x00, 0x68, 0xB0, 0xF9, 0xCE, 0x91, 0xB0, 0xF9,
+	0xD0, 0x81, 0x05, 0xA8,
+	0x0E, 0xF0, 0x05, 0xFA, 0x09, 0xEB, 0x08, 0x00, 0x40, 0x10, 0x01, 0x90,
+	0xA0, 0x48, 0x00, 0x68,
+	0x90, 0xF8, 0x34, 0x01, 0x80, 0x07, 0x05, 0xD4, 0x39, 0x46, 0x32, 0x46,
+	0x08, 0x46, 0x00, 0xF0,
+	0x87, 0xF9, 0x76, 0x1E, 0x32, 0x46, 0x38, 0x46, 0x05, 0x99, 0x11, 0xF0,
+	0x88, 0xFD, 0x00, 0x27,
+	0x48, 0x45, 0x01, 0xDC, 0x40, 0x45, 0x08, 0xDA, 0x01, 0x99, 0x09, 0x1A,
+	0x94, 0x48, 0x00, 0x68,
+	0xB0, 0xF8, 0xD2, 0x01, 0x91, 0xFB, 0xF0, 0xF0, 0x47, 0xB2, 0x91, 0x48,
+	0x00, 0x68, 0x90, 0xF8,
+	0x34, 0x01, 0x80, 0x07, 0x06, 0xD4, 0x00, 0x99, 0x5A, 0x46, 0x08, 0x46,
+	0x00, 0xF0, 0x68, 0xF9,
+	0xAB, 0xF1, 0x01, 0x0B, 0x5A, 0x46, 0x05, 0x99, 0x00, 0x98, 0x11, 0xF0,
+	0x68, 0xFD, 0x00, 0x26,
+	0x48, 0x45, 0x01, 0xDC, 0x40, 0x45, 0x08, 0xDA, 0x01, 0x99, 0x09, 0x1A,
+	0x84, 0x48, 0x00, 0x68,
+	0xB0, 0xF8, 0xD4, 0x01, 0x91, 0xFB, 0xF0, 0xF0, 0x46, 0xB2, 0x02, 0x21,
+	0x05, 0xA8, 0x0E, 0xF0,
+	0x51, 0xFA, 0x06, 0x98, 0xCD, 0xE9, 0x00, 0x07, 0x02, 0x96, 0x22, 0x46,
+	0x2B, 0x46, 0x07, 0x98,
+	0xFF, 0xF7, 0x21, 0xFD, 0x01, 0x28, 0x1D, 0xD0, 0x02, 0x28, 0x24, 0xD0,
+	0xDA, 0xF8, 0x00, 0x00,
+	0x22, 0x46, 0x2B, 0x46, 0xC7, 0x77, 0x80, 0xF8, 0x20, 0x60, 0x01, 0x20,
+	0x06, 0x99, 0xCD, 0xE9,
+	0x03, 0x60, 0xCD, 0xE9, 0x01, 0x17, 0x08, 0x98, 0x00, 0x90, 0x07, 0x98,
+	0x10, 0xF0, 0x82, 0xFF,
+	0xDA, 0xF8, 0x00, 0x00, 0xA5, 0x21, 0x81, 0x77, 0x01, 0x21, 0x06, 0xA8,
+	0x0E, 0xF0, 0x2A, 0xFA,
+	0x09, 0xB0, 0xD5, 0xE5, 0xDA, 0xF8, 0x00, 0x10, 0x00, 0x20, 0xC8, 0x77,
+	0x81, 0xF8, 0x20, 0x00,
+	0x10, 0x21, 0xB2, 0x20, 0x07, 0xE0, 0xDA, 0xF8, 0x00, 0x10, 0x00, 0x20,
+	0xC8, 0x77, 0x81, 0xF8,
+	0x20, 0x00, 0x10, 0x21, 0xB3, 0x20, 0x0F, 0xF0, 0xC1, 0xFE, 0xE1, 0xE7,
+	0x2D, 0xE9, 0xF0, 0x4F,
+	0x87, 0xB0, 0x14, 0xF0, 0x6C, 0xF9, 0x83, 0x46, 0x14, 0xF0, 0x6B, 0xF9,
+	0xDF, 0xF8, 0x70, 0x91,
+	0x01, 0x21, 0xC8, 0x46, 0xD9, 0xF8, 0x00, 0x00, 0x90, 0xF8, 0x31, 0x60,
+	0x05, 0xA8, 0x0E, 0xF0,
+	0x6E, 0xF9, 0x58, 0x4D, 0x58, 0x4F, 0x05, 0x9A, 0x28, 0x68, 0x00, 0x24,
+	0x23, 0x46, 0x90, 0xF9,
+	0x23, 0x10, 0x90, 0xF9, 0x22, 0x00, 0x00, 0x97, 0xCD, 0xE9, 0x01, 0x20,
+	0xCD, 0xE9, 0x03, 0x14,
+	0x22, 0x46, 0x58, 0x46, 0x10, 0xF0, 0x3E, 0xFF, 0x05, 0x99, 0xCD, 0xE9,
+	0x01, 0x14, 0x4F, 0xF0,
+	0x01, 0x0A, 0x00, 0x97, 0xCD, 0xE9, 0x03, 0x4A, 0x00, 0x22, 0x13, 0x46,
+	0x58, 0x46, 0x10, 0xF0,
+	0x31, 0xFF, 0x46, 0x48, 0x14, 0xF0, 0xDE, 0xF8, 0x44, 0x49, 0x03, 0x20,
+	0x08, 0x72, 0x08, 0x46,
+	0xFF, 0xF7, 0x6A, 0xFC, 0x41, 0x48, 0x02, 0x21, 0x34, 0x38, 0x87, 0x6A,
+	0x06, 0xA8, 0x0E, 0xF0,
+	0x3E, 0xF9, 0xD8, 0xF8, 0x00, 0x00, 0xB0, 0xF9, 0xD6, 0x11, 0xB0, 0xF9,
+	0xD8, 0x21, 0x90, 0xF8,
+	0x84, 0x09, 0x11, 0x44, 0x01, 0xEB, 0xD1, 0x71, 0x4F, 0xEA, 0x61, 0x08,
+	0x80, 0x07, 0x05, 0xD4,
+	0x76, 0x1E, 0x39, 0x46, 0x32, 0x46, 0x08, 0x46, 0x00, 0xF0, 0xBA, 0xF8,
+	0x32, 0x46, 0x38, 0x46,
+	0x06, 0x99, 0x11, 0xF0, 0xBC, 0xFC, 0xD9, 0xF8, 0x00, 0x10, 0x00, 0x26,
+	0x37, 0x46, 0xB1, 0xF9,
+	0xD6, 0x21, 0x82, 0x42, 0x03, 0xDB, 0xB1, 0xF9, 0xD8, 0x21, 0x82, 0x42,
+	0x06, 0xDD, 0xB1, 0xF8,
+	0xDA, 0x11, 0xA8, 0xEB, 0x00, 0x00, 0x90, 0xFB, 0xF1, 0xF0, 0x46, 0xB2,
+	0x02, 0x21, 0x06, 0xA8,
+	0x0E, 0xF0, 0xA0, 0xF9, 0x05, 0x98, 0x00, 0x22, 0x8D, 0xE8, 0xC1, 0x00,
+	0x13, 0x46, 0x58, 0x46,
+	0xFF, 0xF7, 0x71, 0xFC, 0x01, 0x28, 0x1A, 0xD0, 0x02, 0x28, 0x28, 0x68,
+	0x1E, 0xD0, 0x00, 0xF8,
+	0x22, 0x6F, 0x00, 0x22, 0x44, 0x70, 0x20, 0x48, 0x05, 0x99, 0x98, 0x38,
+	0x8D, 0xE8, 0x43, 0x00,
+	0xCD, 0xE9, 0x03, 0x4A, 0x13, 0x46, 0x58, 0x46, 0x10, 0xF0, 0xD4, 0xFE,
+	0x29, 0x68, 0xA5, 0x20,
+	0x81, 0xF8, 0x21, 0x00, 0x01, 0x21, 0x05, 0xA8, 0x0E, 0xF0, 0x7C, 0xF9,
+	0x83, 0xE6, 0x28, 0x68,
+	0x40, 0x21, 0x00, 0xF8, 0x22, 0x4F, 0x44, 0x70, 0xB2, 0x20, 0x04, 0xE0,
+	0x00, 0xF8, 0x22, 0x4F,
+	0x40, 0x21, 0x44, 0x70, 0xB3, 0x20, 0x0F, 0xF0, 0x19, 0xFE, 0xE7, 0xE7,
+	0x70, 0xB5, 0x04, 0x46,
+	0x00, 0x20, 0xFD, 0xF7, 0xEE, 0xFE, 0x02, 0x20, 0xFD, 0xF7, 0xEB, 0xFE,
+	0x0B, 0x49, 0x01, 0x20,
+	0x08, 0x70, 0x07, 0x4D, 0x28, 0x68, 0x90, 0xF8, 0xC0, 0x01, 0x20, 0x40,
+	0xC0, 0x07, 0x01, 0xD0,
+	0xFF, 0xF7, 0x5F, 0xFC, 0x28, 0x68, 0x0B, 0xE0, 0x98, 0x98, 0x01, 0x20,
+	0x6C, 0x0F, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x50, 0x07, 0x10, 0x00, 0xD0, 0x99, 0x01, 0x20,
+	0x78, 0x07, 0x10, 0x00,
+	0x90, 0xF8, 0xC0, 0x01, 0x80, 0x07, 0x03, 0xD5, 0xA0, 0x07, 0x01, 0xD5,
+	0xFF, 0xF7, 0x00, 0xFD,
+	0x28, 0x68, 0x90, 0xF8, 0xC0, 0x11, 0xC9, 0x06, 0x06, 0xD5, 0x90, 0xF8,
+	0x61, 0x04, 0x18, 0xB1,
+	0xE0, 0x06, 0x01, 0xD5, 0xFF, 0xF7, 0xA9, 0xFD, 0x28, 0x68, 0x90, 0xF8,
+	0xC0, 0x01, 0x40, 0x07,
+	0x03, 0xD5, 0x60, 0x07, 0x01, 0xD5, 0xFF, 0xF7, 0x46, 0xFE, 0x28, 0x68,
+	0x90, 0xF8, 0xC0, 0x01,
+	0x00, 0x07, 0x03, 0xD5, 0x20, 0x07, 0x01, 0xD5, 0xFF, 0xF7, 0x10, 0xFF,
+	0x00, 0x20, 0xFD, 0xF7,
+	0xC3, 0xFE, 0x02, 0x20, 0xFD, 0xF7, 0xC0, 0xFE, 0xE0, 0x07, 0x04, 0xD0,
+	0xBD, 0xE8, 0x70, 0x40,
+	0x01, 0x20, 0x01, 0xF0, 0x75, 0xBA, 0x70, 0xBD, 0xF0, 0xB5, 0x00, 0x26,
+	0x35, 0x46, 0x0C, 0xE0,
+	0x01, 0x24, 0x07, 0xE0, 0x05, 0xFB, 0x03, 0x47, 0x64, 0x1C, 0x31, 0xF8,
+	0x17, 0x70, 0x20, 0xF8,
+	0x16, 0x70, 0x76, 0x1C, 0x9C, 0x42, 0xF5, 0xDB, 0x6D, 0x1C, 0x95, 0x42,
+	0xF0, 0xDB, 0xF0, 0xBD,
+	0x30, 0xB5, 0x00, 0x24, 0x01, 0x23, 0x05, 0xE0, 0x31, 0xF8, 0x13, 0x50,
+	0x20, 0xF8, 0x14, 0x50,
+	0x5B, 0x1C, 0x64, 0x1C, 0x93, 0x42, 0xF7, 0xDB, 0x30, 0xBD, 0x00, 0x00,
+	0x70, 0xB5, 0x7E, 0x4D,
+	0x4F, 0xF4, 0x25, 0x74, 0x21, 0x46, 0x28, 0x68, 0xFE, 0xF7, 0x17, 0xFC,
+	0x00, 0x21, 0x1F, 0x20,
+	0x0D, 0xF1, 0xFE, 0xF8, 0x22, 0x46, 0x29, 0x68, 0xBD, 0xE8, 0x70, 0x40,
+	0x1F, 0x23, 0x77, 0x48,
+	0xFE, 0xF7, 0xCA, 0xBA, 0x70, 0xB5, 0x76, 0x4D, 0x40, 0xF2, 0xAF, 0x14,
+	0x21, 0x46, 0x28, 0x68,
+	0xFE, 0xF7, 0x03, 0xFC, 0x00, 0x21, 0x1A, 0x20, 0x0D, 0xF1, 0xEA, 0xF8,
+	0x22, 0x46, 0x29, 0x68,
+	0xBD, 0xE8, 0x70, 0x40, 0x1A, 0x23, 0x6F, 0x48, 0xFE, 0xF7, 0xB6, 0xBA,
+	0x2D, 0xE9, 0xF0, 0x41,
+	0xDF, 0xF8, 0xB4, 0x81, 0x05, 0x1D, 0x0E, 0x46, 0x29, 0x46, 0x40, 0x46,
+	0xFE, 0xF7, 0xED, 0xFB,
+	0x30, 0x68, 0x6A, 0x4A, 0x00, 0xEB, 0x85, 0x03, 0x93, 0x42, 0x01, 0xD2,
+	0x1B, 0x23, 0x13, 0xE0,
+	0x67, 0x49, 0x8B, 0x42, 0x13, 0xD2, 0x90, 0x42, 0x0D, 0xD2, 0x44, 0x46,
+	0x11, 0x1A, 0x8F, 0x08,
+	0x90, 0x46, 0x1B, 0x23, 0x3A, 0x46, 0x21, 0x46, 0xFE, 0xF7, 0x96, 0xFA,
+	0xEA, 0x1B, 0x04, 0xEB,
+	0x87, 0x01, 0x1C, 0x23, 0x15, 0xE0, 0x1C, 0x23, 0x2A, 0x46, 0x41, 0x46,
+	0x12, 0xE0, 0x5D, 0x4A,
+	0x93, 0x42, 0x19, 0xD2, 0x88, 0x42, 0x15, 0xD2, 0x44, 0x46, 0x88, 0x46,
+	0x09, 0x1A, 0x8F, 0x08,
+	0x1C, 0x23, 0x3A, 0x46, 0x21, 0x46, 0xFE, 0xF7, 0x7F, 0xFA, 0xEA, 0x1B,
+	0x04, 0xEB, 0x87, 0x01,
+	0x1D, 0x23, 0x40, 0x46, 0xFE, 0xF7, 0x78, 0xFA, 0x30, 0x68, 0x00, 0xEB,
+	0x85, 0x00, 0x30, 0x60,
+	0xBD, 0xE8, 0xF0, 0x81, 0x1D, 0x23, 0xDF, 0xE7, 0x90, 0x42, 0x0D, 0xD2,
+	0x47, 0x46, 0x11, 0x1A,
+	0x8C, 0x08, 0x90, 0x46, 0x1D, 0x23, 0x22, 0x46, 0x39, 0x46, 0xFE, 0xF7,
+	0x65, 0xFA, 0x2A, 0x1B,
+	0x07, 0xEB, 0x84, 0x01, 0x1E, 0x23, 0xE4, 0xE7, 0x1E, 0x23, 0xCD, 0xE7,
+	0xF8, 0xB5, 0x42, 0x4C,
+	0x45, 0x48, 0x00, 0x90, 0x10, 0x34, 0x02, 0x20, 0xFD, 0xF7, 0xF3, 0xFD,
+	0x00, 0x21, 0x1B, 0x20,
+	0x0D, 0xF1, 0x7E, 0xF8, 0x00, 0x21, 0x1C, 0x20, 0x0D, 0xF1, 0x7A, 0xF8,
+	0x00, 0x21, 0x1D, 0x20,
+	0x0D, 0xF1, 0x76, 0xF8, 0x00, 0x21, 0x1E, 0x20, 0x0D, 0xF1, 0x72, 0xF8,
+	0x10, 0x21, 0x20, 0x46,
+	0x14, 0xF0, 0x72, 0xFB, 0x00, 0x20, 0x20, 0x80, 0xA0, 0x70, 0x2F, 0x4D,
+	0x01, 0x20, 0xE0, 0x70,
+	0x28, 0x68, 0xC1, 0x8A, 0xA1, 0x80, 0x80, 0x8A, 0xE0, 0x80, 0x04, 0x20,
+	0x69, 0x46, 0xFF, 0xF7,
+	0x7D, 0xFF, 0x01, 0x23, 0x00, 0x22, 0x21, 0x46, 0x10, 0x20, 0x11, 0xF0,
+	0x37, 0xF8, 0x06, 0x46,
+	0x69, 0x46, 0xFF, 0xF7, 0x73, 0xFF, 0x01, 0x23, 0x00, 0x22, 0x21, 0x46,
+	0x11, 0x20, 0x11, 0xF0,
+	0x2D, 0xF8, 0x69, 0x46, 0x30, 0x46, 0xFF, 0xF7, 0x69, 0xFF, 0x28, 0x68,
+	0x90, 0xF8, 0x61, 0x04,
+	0x48, 0xB1, 0x01, 0x23, 0x00, 0x22, 0x21, 0x46, 0x14, 0x20, 0x11, 0xF0,
+	0x1F, 0xF8, 0x69, 0x46,
+	0x30, 0x46, 0xFF, 0xF7, 0x5B, 0xFF, 0x28, 0x68, 0x90, 0xF8, 0x50, 0x12,
+	0xC9, 0x07, 0x03, 0xD1,
+	0x90, 0xF8, 0x80, 0x02, 0xC0, 0x07, 0x09, 0xD0, 0x01, 0x23, 0x00, 0x22,
+	0x21, 0x46, 0x12, 0x20,
+	0x11, 0xF0, 0x0C, 0xF8, 0x69, 0x46, 0x30, 0x46, 0xFF, 0xF7, 0x48, 0xFF,
+	0x01, 0x23, 0x00, 0x22,
+	0x21, 0x46, 0x13, 0x20, 0x11, 0xF0, 0x02, 0xF8, 0x69, 0x46, 0x30, 0x46,
+	0xFF, 0xF7, 0x3E, 0xFF,
+	0x28, 0x68, 0x90, 0xF8, 0x2F, 0x0A, 0xC0, 0x07, 0x09, 0xD0, 0x01, 0x23,
+	0x00, 0x22, 0x21, 0x46,
+	0x17, 0x20, 0x10, 0xF0, 0xF3, 0xFF, 0x69, 0x46, 0x30, 0x46, 0xFF, 0xF7,
+	0x2F, 0xFF, 0x02, 0x20,
+	0xFD, 0xF7, 0x9A, 0xFD, 0xF8, 0xBD, 0x00, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0xF0, 0xEF, 0x01, 0x00,
+	0x50, 0x07, 0x10, 0x00, 0xF0, 0x9F, 0x01, 0x00, 0xD4, 0x56, 0x10, 0x00,
+	0xF0, 0xBF, 0x01, 0x00,
+	0xF0, 0xCF, 0x01, 0x00, 0xF0, 0xDF, 0x01, 0x00, 0xF0, 0xAF, 0x01, 0x00,
+	0x10, 0xB5, 0x01, 0x46,
+	0x34, 0x22, 0xFE, 0x48, 0x14, 0xF0, 0xBE, 0xFA, 0x01, 0x21, 0xBD, 0xE8,
+	0x10, 0x40, 0x00, 0x20,
+	0xFD, 0xF7, 0x7F, 0xBC, 0x70, 0xB5, 0x86, 0xB0, 0x06, 0x46, 0x68, 0x46,
+	0x13, 0xF0, 0xD2, 0xFE,
+	0xF7, 0x48, 0x00, 0x90, 0x02, 0x2E, 0x15, 0xD0, 0x07, 0x20, 0x8D, 0xF8,
+	0x04, 0x00, 0xF3, 0x4C,
+	0x68, 0x46, 0x13, 0xF0, 0xEC, 0xFE, 0x00, 0x22, 0x04, 0xAB, 0x01, 0x21,
+	0x10, 0x46, 0xFD, 0xF7,
+	0xB1, 0xFC, 0x01, 0x21, 0x00, 0x20, 0xFD, 0xF7, 0x90, 0xFC, 0x20, 0x78,
+	0x30, 0xB1, 0x0F, 0xF0,
+	0x74, 0xFC, 0xED, 0xE7, 0x03, 0x20, 0x8D, 0xF8, 0x09, 0x00, 0xE8, 0xE7,
+	0xE9, 0x4D, 0x02, 0x2E,
+	0x09, 0xD0, 0x13, 0xF0, 0x0C, 0xFF, 0xA8, 0x61, 0x13, 0xF0, 0x0B, 0xFF,
+	0xC5, 0xE9, 0x10, 0x01,
+	0xA0, 0x68, 0x06, 0xB0, 0x70, 0xBD, 0x13, 0xF0, 0x06, 0xFF, 0xA8, 0x61,
+	0x13, 0xF0, 0x05, 0xFF,
+	0xC5, 0xE9, 0x10, 0x01, 0x60, 0x69, 0xF4, 0xE7, 0x2D, 0xE9, 0xF0, 0x41,
+	0xDD, 0x4C, 0x01, 0x25,
+	0x60, 0x38, 0xD4, 0xE9, 0x10, 0x23, 0xA6, 0x69, 0x09, 0x28, 0x6F, 0xD2,
+	0xDF, 0xE8, 0x00, 0xF0,
+	0x05, 0x0F, 0x1E, 0x28, 0x37, 0x41, 0x50, 0x5A, 0x6A, 0x00, 0x32, 0x46,
+	0x00, 0x23, 0x08, 0x46,
+	0x00, 0xF0, 0x51, 0xFA, 0x85, 0x40, 0x60, 0x68, 0x05, 0x43, 0x65, 0x60,
+	0x5E, 0xE0, 0x08, 0x46,
+	0x00, 0xF0, 0x49, 0xFA, 0x02, 0x46, 0x01, 0x20, 0x00, 0x21, 0x14, 0xF0,
+	0xDF, 0xF9, 0xD4, 0xE9,
+	0x08, 0x23, 0x10, 0x43, 0x19, 0x43, 0xC4, 0xE9, 0x08, 0x01, 0x4F, 0xE0,
+	0x32, 0x46, 0x00, 0x23,
+	0x08, 0x46, 0x00, 0xF0, 0x38, 0xFA, 0x85, 0x40, 0xE0, 0x68, 0x05, 0x43,
+	0xE5, 0x60, 0x45, 0xE0,
+	0x08, 0x46, 0x00, 0xF0, 0x30, 0xFA, 0x02, 0x46, 0x01, 0x20, 0x00, 0x21,
+	0x14, 0xF0, 0xC6, 0xF9,
+	0xD4, 0xE9, 0x0C, 0x23, 0x10, 0x43, 0x19, 0x43, 0xC4, 0xE9, 0x0C, 0x01,
+	0x36, 0xE0, 0x32, 0x46,
+	0x00, 0x23, 0x08, 0x46, 0x00, 0xF0, 0x1F, 0xFA, 0x85, 0x40, 0xA0, 0x68,
+	0x05, 0x43, 0xA5, 0x60,
+	0x2C, 0xE0, 0x08, 0x46, 0x00, 0xF0, 0x17, 0xFA, 0x02, 0x46, 0x01, 0x20,
+	0x00, 0x21, 0x14, 0xF0,
+	0xAD, 0xF9, 0xD4, 0xE9, 0x0A, 0x23, 0x10, 0x43, 0x19, 0x43, 0xC4, 0xE9,
+	0x0A, 0x01, 0x1D, 0xE0,
+	0x32, 0x46, 0x00, 0x23, 0x08, 0x46, 0x00, 0xF0, 0x06, 0xFA, 0x85, 0x40,
+	0x20, 0x69, 0x05, 0x43,
+	0x25, 0x61, 0x13, 0xE0, 0x08, 0x46, 0x00, 0xF0, 0xFE, 0xF9, 0x01, 0x23,
+	0x02, 0x46, 0x00, 0x21,
+	0x18, 0x46, 0x14, 0xF0, 0x93, 0xF9, 0xD4, 0xE9, 0x0E, 0x23, 0x10, 0x43,
+	0x19, 0x43, 0xC4, 0xE9,
+	0x0E, 0x01, 0x03, 0xE0, 0x60, 0x69, 0x8D, 0x40, 0x05, 0x43, 0x65, 0x61,
+	0x20, 0x68, 0x40, 0x1C,
+	0x20, 0x60, 0xBD, 0xE8, 0xF0, 0x81, 0x2D, 0xE9, 0xF0, 0x41, 0x17, 0x46,
+	0x04, 0x46, 0x0D, 0x46,
+	0x00, 0x26, 0x09, 0xE0, 0xE0, 0x07, 0x03, 0xD0, 0x31, 0x46, 0x38, 0x46,
+	0x0F, 0xF0, 0xBE, 0xFB,
+	0x76, 0x1C, 0x6D, 0x08, 0x4F, 0xEA, 0x34, 0x04, 0x54, 0xEA, 0x05, 0x00,
+	0xF2, 0xD1, 0xE8, 0xE7,
+	0x70, 0xB5, 0x94, 0x4C, 0xE1, 0x68, 0x60, 0x68, 0xD4, 0xE9, 0x0C, 0x65,
+	0x40, 0xEA, 0x01, 0x03,
+	0xD4, 0xE9, 0x08, 0x21, 0x29, 0x43, 0x25, 0x69, 0x32, 0x43, 0x9D, 0x43,
+	0x25, 0x61, 0xD4, 0xE9,
+	0x0E, 0x35, 0x93, 0x43, 0x8D, 0x43, 0xC4, 0xE9, 0x0E, 0x35, 0x21, 0x68,
+	0x00, 0x29, 0x2C, 0xD0,
+	0x60, 0x22, 0x00, 0x21, 0xFF, 0xF7, 0xCF, 0xFF, 0xD4, 0xE9, 0x08, 0x01,
+	0x61, 0x22, 0xFF, 0xF7,
+	0xCA, 0xFF, 0x62, 0x22, 0x00, 0x21, 0xE0, 0x68, 0xFF, 0xF7, 0xC5, 0xFF,
+	0xD4, 0xE9, 0x0C, 0x01,
+	0x63, 0x22, 0xFF, 0xF7, 0xC0, 0xFF, 0x64, 0x22, 0x00, 0x21, 0xA0, 0x68,
+	0xFF, 0xF7, 0xBB, 0xFF,
+	0xD4, 0xE9, 0x0A, 0x01, 0x65, 0x22, 0xFF, 0xF7, 0xB6, 0xFF, 0x66, 0x22,
+	0x00, 0x21, 0x20, 0x69,
+	0xFF, 0xF7, 0xB1, 0xFF, 0xD4, 0xE9, 0x0E, 0x01, 0x67, 0x22, 0xFF, 0xF7,
+	0xAC, 0xFF, 0x60, 0x69,
+	0xBD, 0xE8, 0x70, 0x40, 0x68, 0x22, 0x00, 0x21, 0xA5, 0xE7, 0x70, 0xBD,
+	0x2D, 0xE9, 0xF0, 0x5F,
+	0x83, 0x46, 0x4F, 0xF0, 0x00, 0x0A, 0x13, 0xF0, 0x1A, 0xFE, 0x04, 0x46,
+	0x13, 0xF0, 0x1B, 0xFE,
+	0x40, 0xEA, 0x04, 0x06, 0x13, 0xF0, 0x15, 0xFE, 0x07, 0x46, 0x88, 0x46,
+	0x13, 0xF0, 0x15, 0xFE,
+	0x41, 0xEA, 0x08, 0x05, 0x67, 0x49, 0x40, 0xEA, 0x07, 0x04, 0x8E, 0x61,
+	0xC1, 0xE9, 0x10, 0x45,
+	0xFD, 0xF7, 0x0E, 0xFD, 0x00, 0xF0, 0xFF, 0x08, 0xFD, 0xF7, 0x0C, 0xFD,
+	0x00, 0xF0, 0xFF, 0x09,
+	0xFD, 0xF7, 0x19, 0xFE, 0x00, 0x27, 0x26, 0xE0, 0x01, 0x20, 0xB8, 0x40,
+	0x30, 0x42, 0x21, 0xD0,
+	0xF8, 0xB2, 0x00, 0x21, 0xFD, 0xF7, 0x17, 0xFE, 0x41, 0x07, 0x05, 0xD5,
+	0x5F, 0xEA, 0xCB, 0x61,
+	0x02, 0xD5, 0x51, 0x46, 0x62, 0x20, 0x0F, 0xE0, 0xC1, 0x07, 0x05, 0xD0,
+	0x5F, 0xEA, 0x4B, 0x71,
+	0x02, 0xD5, 0x51, 0x46, 0x60, 0x20, 0x07, 0xE0, 0x1B, 0xF0, 0xC0, 0x0F,
+	0x06, 0xD0, 0x10, 0xF0,
+	0x0A, 0x0F, 0x03, 0xD0, 0x51, 0x46, 0x64, 0x20, 0xFF, 0xF7, 0xDE, 0xFE,
+	0x0A, 0xF1, 0x01, 0x00,
+	0x00, 0xF0, 0xFF, 0x0A, 0x7F, 0x1C, 0x47, 0x45, 0xD6, 0xDB, 0xFD, 0xF7,
+	0xEC, 0xFD, 0x00, 0x27,
+	0x3E, 0x46, 0x29, 0xE0, 0x32, 0x46, 0x01, 0x20, 0x00, 0x21, 0x14, 0xF0,
+	0xCF, 0xF8, 0x20, 0x40,
+	0x29, 0x40, 0x08, 0x43, 0x1F, 0xD0, 0xF0, 0xB2, 0x01, 0x21, 0xFD, 0xF7,
+	0xE4, 0xFD, 0x41, 0x07,
+	0x05, 0xD5, 0x5F, 0xEA, 0x8B, 0x61, 0x02, 0xD5, 0x39, 0x46, 0x63, 0x20,
+	0x0F, 0xE0, 0xC1, 0x07,
+	0x05, 0xD0, 0x5F, 0xEA, 0x0B, 0x71, 0x02, 0xD5, 0x39, 0x46, 0x61, 0x20,
+	0x07, 0xE0, 0x1B, 0xF4,
+	0xC0, 0x7F, 0x06, 0xD0, 0x10, 0xF0, 0x0A, 0x0F, 0x03, 0xD0, 0x39, 0x46,
+	0x65, 0x20, 0xFF, 0xF7,
+	0xAB, 0xFE, 0x7F, 0x1C, 0xFF, 0xB2, 0x76, 0x1C, 0x4E, 0x45, 0xD3, 0xDD,
+	0xBD, 0xE8, 0xF0, 0x5F,
+	0xFD, 0xF7, 0xB9, 0xBD, 0x30, 0x48, 0x02, 0x68, 0x12, 0xF8, 0xD3, 0x1F,
+	0xD0, 0x78, 0x00, 0xF0,
+	0x1F, 0x00, 0x40, 0x1C, 0x41, 0x43, 0x48, 0x00, 0xC0, 0xEB, 0x40, 0x20,
+	0x40, 0x10, 0x70, 0x47,
+	0x2D, 0xE9, 0xFC, 0x5F, 0x07, 0x46, 0x00, 0x20, 0xCD, 0xE9, 0x00, 0x00,
+	0x1C, 0x46, 0x92, 0x46,
+	0x0E, 0x46, 0xFF, 0xF7, 0xE7, 0xFF, 0x00, 0xEB, 0x04, 0x08, 0x0C, 0x98,
+	0x80, 0x07, 0x50, 0xD5,
+	0x00, 0x24, 0x4C, 0xE0, 0x4F, 0xF0, 0x00, 0x09, 0x4F, 0xF0, 0xFF, 0x3B,
+	0x4D, 0x46, 0x27, 0xE0,
+	0x05, 0xFB, 0x06, 0x40, 0x3A, 0xF9, 0x10, 0x20, 0x42, 0x45, 0x20, 0xD2,
+	0x09, 0xF1, 0x01, 0x09,
+	0xBB, 0xF1, 0xFF, 0x3F, 0x00, 0xD1, 0xAB, 0x46, 0x79, 0x1E, 0x8D, 0x42,
+	0x17, 0xD1, 0xB9, 0xF1,
+	0x01, 0x0F, 0x14, 0xD1, 0x71, 0x1E, 0x8C, 0x42, 0x04, 0xD1, 0x29, 0x46,
+	0x66, 0x20, 0xFF, 0xF7,
+	0x63, 0xFE, 0x0C, 0xE0, 0x0A, 0xEB, 0x40, 0x00, 0xB0, 0xF9, 0x02, 0x20,
+	0x42, 0x45, 0x04, 0xD3,
+	0x2C, 0xB1, 0x30, 0xF9, 0x02, 0x1C, 0x41, 0x45, 0x01, 0xD2, 0x4F, 0xF0,
+	0x00, 0x09, 0x6D, 0x1C,
+	0xBD, 0x42, 0xD5, 0xD3, 0xA7, 0xEB, 0x0B, 0x01, 0x49, 0x45, 0x17, 0xD8,
+	0x21, 0x46, 0x67, 0x20,
+	0xFF, 0xF7, 0x4A, 0xFE, 0x01, 0x20, 0x22, 0x46, 0x00, 0x21, 0x07, 0xE0,
+	0x7C, 0x0F, 0x10, 0x00,
+	0x0D, 0x2C, 0x00, 0x00, 0x70, 0x04, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x14, 0xF0, 0x3E, 0xF8,
+	0xDD, 0xE9, 0x00, 0x23, 0x10, 0x43, 0x19, 0x43, 0xCD, 0xE9, 0x00, 0x01,
+	0x64, 0x1C, 0xB4, 0x42,
+	0xB0, 0xD3, 0x0C, 0x98, 0xC0, 0x07, 0x25, 0xD0, 0x00, 0x25, 0x21, 0xE0,
+	0x4F, 0xF0, 0x00, 0x09,
+	0x4C, 0x46, 0x13, 0xE0, 0x05, 0xFB, 0x06, 0x41, 0x3A, 0xF9, 0x11, 0x10,
+	0x41, 0x45, 0x0C, 0xD2,
+	0x22, 0x46, 0x01, 0x20, 0x00, 0x21, 0x14, 0xF0, 0x21, 0xF8, 0xDD, 0xE9,
+	0x00, 0x23, 0x10, 0x40,
+	0x19, 0x40, 0x08, 0x43, 0x01, 0xD1, 0x09, 0xF1, 0x01, 0x09, 0x64, 0x1C,
+	0xB4, 0x42, 0xE9, 0xD3,
+	0xB9, 0xF1, 0x00, 0x0F, 0x03, 0xD0, 0x29, 0x46, 0x66, 0x20, 0xFF, 0xF7,
+	0x0D, 0xFE, 0x6D, 0x1C,
+	0xBD, 0x42, 0xDB, 0xD3, 0xBD, 0xE8, 0xFC, 0x9F, 0x2D, 0xE9, 0xFF, 0x47,
+	0x04, 0x46, 0x00, 0x20,
+	0xFD, 0xF7, 0x27, 0xFB, 0x4C, 0x49, 0x4F, 0xF0, 0x01, 0x09, 0x81, 0xF8,
+	0x00, 0x90, 0x00, 0xF0,
+	0x7D, 0xF8, 0x14, 0xF0, 0x0C, 0x0F, 0x09, 0xD1, 0xE0, 0x06, 0x07, 0xD4,
+	0xA0, 0x06, 0x05, 0xD4,
+	0x60, 0x06, 0x03, 0xD4, 0xE0, 0x05, 0x01, 0xD4, 0x20, 0x06, 0x02, 0xD5,
+	0x20, 0x46, 0xFF, 0xF7,
+	0xC5, 0xFE, 0x42, 0x4E, 0xA0, 0x07, 0x1C, 0xD0, 0x01, 0x20, 0xFF, 0xF7,
+	0xAB, 0xFD, 0x05, 0x46,
+	0x13, 0xF0, 0xDD, 0xFC, 0x01, 0x90, 0x13, 0xF0, 0xDC, 0xFC, 0xCD, 0xE9,
+	0x02, 0x01, 0x04, 0x21,
+	0x01, 0xA8, 0xFE, 0xF7, 0x68, 0xF8, 0x07, 0x46, 0x08, 0x21, 0x02, 0xA8,
+	0xFE, 0xF7, 0x63, 0xF8,
+	0x01, 0x46, 0x00, 0x94, 0x30, 0x68, 0x2A, 0x46, 0x90, 0xF8, 0xDA, 0x30,
+	0x38, 0x46, 0xFF, 0xF7,
+	0x37, 0xFF, 0x14, 0xF4, 0xC0, 0x6F, 0x26, 0xD0, 0x30, 0x68, 0x90, 0xF8,
+	0x61, 0x04, 0x10, 0xB3,
+	0x00, 0x25, 0xFF, 0xF7, 0x1F, 0xFF, 0x31, 0x68, 0xB0, 0x46, 0x91, 0xF8,
+	0xDB, 0x10, 0x0F, 0x18,
+	0x02, 0x20, 0xFF, 0xF7, 0x7F, 0xFD, 0x06, 0x46, 0x5F, 0xF0, 0x00, 0x04,
+	0xD8, 0xF8, 0x00, 0x00,
+	0x90, 0xF8, 0x61, 0x14, 0x09, 0xFA, 0x04, 0xF0, 0x01, 0x42, 0x09, 0xD0,
+	0x6D, 0x1C, 0x36, 0xF9,
+	0x14, 0x00, 0xED, 0xB2, 0xB8, 0x42, 0x03, 0xD2, 0x29, 0x46, 0x68, 0x20,
+	0xFF, 0xF7, 0xA4, 0xFD,
+	0x64, 0x1C, 0x04, 0x2C, 0xEA, 0xDB, 0xFF, 0xF7, 0x33, 0xFE, 0x04, 0xB0,
+	0x00, 0x20, 0xBD, 0xE8,
+	0xF0, 0x47, 0xFD, 0xF7, 0xD9, 0xBA, 0x2D, 0xE9, 0xF0, 0x41, 0x16, 0x46,
+	0x1F, 0x46, 0x80, 0x46,
+	0x4F, 0xF0, 0xFF, 0x35, 0x00, 0x24, 0x22, 0x46, 0x01, 0x20, 0x00, 0x21,
+	0x13, 0xF0, 0x8E, 0xFF,
+	0x30, 0x40, 0x39, 0x40, 0x08, 0x43, 0x04, 0xD0, 0x6D, 0x1C, 0x45, 0x45,
+	0x01, 0xD1, 0x20, 0x46,
+	0xFF, 0xE5, 0x64, 0x1C, 0x40, 0x2C, 0xEE, 0xD3, 0x00, 0x20, 0xFA, 0xE5,
+	0x0C, 0x48, 0x00, 0x21,
+	0x01, 0x61, 0x41, 0x60, 0x81, 0x60, 0xC1, 0x60, 0xC0, 0xE9, 0x0E, 0x11,
+	0xC0, 0xE9, 0x08, 0x11,
+	0xC0, 0xE9, 0x0A, 0x11, 0x41, 0x61, 0x01, 0x60, 0xC0, 0xE9, 0x0C, 0x11,
+	0x41, 0xF2, 0xC8, 0x11,
+	0x04, 0x48, 0x14, 0xF0, 0x43, 0xB8, 0x00, 0x00, 0x78, 0x07, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0x70, 0x04, 0x10, 0x00, 0x78, 0x8B, 0x01, 0x20, 0x11, 0x49, 0x08, 0x60,
+	0x4F, 0xF4, 0x00, 0x51,
+	0x00, 0x20, 0xFD, 0xF7, 0x9E, 0xB9, 0x38, 0xB5, 0xAF, 0xF2, 0x13, 0x00,
+	0xFE, 0xF7, 0xAB, 0xFB,
+	0x00, 0x22, 0x4F, 0xF4, 0x00, 0x54, 0x6B, 0x46, 0x21, 0x46, 0x10, 0x46,
+	0xFD, 0xF7, 0xDA, 0xF9,
+	0x21, 0x46, 0x00, 0x20, 0xFD, 0xF7, 0xB9, 0xF9, 0x06, 0x48, 0xA5, 0x22,
+	0x01, 0x68, 0x04, 0x48,
+	0x0A, 0x74, 0x00, 0x68, 0x20, 0xF0, 0x7F, 0x42, 0x4A, 0x61, 0xFE, 0xF7,
+	0xB2, 0xFB, 0x38, 0xBD,
+	0xB8, 0x04, 0x10, 0x00, 0x50, 0x07, 0x10, 0x00, 0x02, 0x00, 0x04, 0xD0,
+	0x01, 0x2A, 0x04, 0xD0,
+	0x02, 0x28, 0x03, 0xD1, 0x04, 0xE0, 0x01, 0x20, 0x00, 0xE0, 0x04, 0x20,
+	0x13, 0xF0, 0x32, 0xBB,
+	0x01, 0x20, 0x12, 0xF0, 0xD1, 0xBC, 0x10, 0xB5, 0x01, 0x46, 0x34, 0x22,
+	0xFA, 0x48, 0x13, 0xF0,
+	0xA1, 0xFF, 0x01, 0x21, 0xBD, 0xE8, 0x10, 0x40, 0x00, 0x20, 0xFD, 0xF7,
+	0x62, 0xB9, 0x30, 0xB5,
+	0x85, 0xB0, 0x04, 0x46, 0x68, 0x46, 0x13, 0xF0, 0xB5, 0xFB, 0xF4, 0x48,
+	0x00, 0x90, 0xAC, 0xB1,
+	0x01, 0x2C, 0x15, 0xD0, 0x02, 0x2C, 0x15, 0xD0, 0x03, 0x2C, 0x31, 0xD1,
+	0x5F, 0xF0, 0x08, 0x00,
+	0x8D, 0xF8, 0x04, 0x00, 0x01, 0x20, 0x8D, 0xF8, 0x0D, 0x00, 0xED, 0x48,
+	0x00, 0x68, 0x90, 0xF8,
+	0xB0, 0x00, 0xC0, 0xF3, 0xC1, 0x00, 0x02, 0x28, 0x08, 0xD0, 0x0A, 0xE0,
+	0x05, 0x20, 0xEF, 0xE7,
+	0x06, 0x20, 0xED, 0xE7, 0x02, 0x20, 0x8D, 0xF8, 0x09, 0x00, 0xEB, 0xE7,
+	0x00, 0x20, 0x8D, 0xF8,
+	0x0D, 0x00, 0xE1, 0x4D, 0x03, 0x24, 0x68, 0x46, 0x13, 0xF0, 0xB1, 0xFB,
+	0x00, 0x22, 0x04, 0xAB,
+	0x01, 0x21, 0x10, 0x46, 0xFD, 0xF7, 0x76, 0xF9, 0x01, 0x21, 0x00, 0x20,
+	0xFD, 0xF7, 0x55, 0xF9,
+	0x28, 0x78, 0x00, 0x28, 0x04, 0xD0, 0x0F, 0xF0, 0x38, 0xF9, 0x64, 0x1E,
+	0x00, 0x2C, 0xEA, 0xDC,
+	0x05, 0xB0, 0x30, 0xBD, 0x2D, 0xE9, 0xF1, 0x4F, 0x88, 0xB0, 0x13, 0xF0,
+	0xD0, 0xFB, 0x01, 0x90,
+	0x13, 0xF0, 0xCF, 0xFB, 0x06, 0x46, 0xD2, 0x4C, 0x08, 0x98, 0x88, 0x46,
+	0x00, 0x28, 0x20, 0x68,
+	0x07, 0xD0, 0xB0, 0xF8, 0x7A, 0x11, 0x08, 0x98, 0xFF, 0xF7, 0x8E, 0xFF,
+	0x03, 0x90, 0xCD, 0x48,
+	0x10, 0xE0, 0x90, 0xF8, 0xE7, 0x00, 0x10, 0xF0, 0x60, 0x0F, 0x03, 0xD0,
+	0x01, 0x98, 0x10, 0xF0,
+	0xDB, 0xF8, 0x01, 0x90, 0x20, 0x68, 0xB0, 0xF8, 0x72, 0x11, 0x08, 0x98,
+	0xFF, 0xF7, 0x7C, 0xFF,
+	0x03, 0x90, 0xC5, 0x48, 0x02, 0x90, 0x20, 0x20, 0x06, 0x90, 0xBF, 0x48,
+	0x4F, 0xF0, 0x40, 0x0A,
+	0xB8, 0x21, 0xD0, 0x38, 0x13, 0xF0, 0x82, 0xFF, 0x00, 0x20, 0x00, 0x90,
+	0x08, 0x98, 0xFF, 0xF7,
+	0x86, 0xFF, 0xB9, 0x48, 0x00, 0x27, 0xB9, 0x46, 0x80, 0x68, 0x4F, 0xF0,
+	0x01, 0x0B, 0x3C, 0x46,
+	0x05, 0x90, 0x01, 0x20, 0x01, 0x99, 0xA0, 0x40, 0x08, 0x42, 0x40, 0xD0,
+	0x00, 0x25, 0x2A, 0x46,
+	0x01, 0x20, 0x00, 0x21, 0x13, 0xF0, 0x92, 0xFE, 0x02, 0x46, 0x0B, 0x46,
+	0x30, 0x40, 0x01, 0xEA,
+	0x08, 0x01, 0x08, 0x43, 0x21, 0xD0, 0xAC, 0x48, 0xD0, 0x38, 0x00, 0xEB,
+	0xC4, 0x01, 0x04, 0x91,
+	0xD1, 0xE9, 0x00, 0x01, 0x8E, 0x46, 0x00, 0xEA, 0x02, 0x0C, 0x19, 0x40,
+	0x5C, 0xEA, 0x01, 0x0C,
+	0x12, 0xD1, 0x05, 0x99, 0x31, 0xF9, 0x17, 0xC0, 0x03, 0x99, 0x8C, 0x45,
+	0x06, 0xDC, 0x10, 0x43,
+	0x04, 0x9A, 0x4E, 0xEA, 0x03, 0x01, 0xC2, 0xE9, 0x00, 0x01, 0x05, 0xE0,
+	0x2A, 0x46, 0x49, 0x46,
+	0x00, 0x9B, 0x02, 0x98, 0xFD, 0xF7, 0xF9, 0xFA, 0x7F, 0x1C, 0x6D, 0x1C,
+	0x55, 0x45, 0xCE, 0xDB,
+	0x99, 0x48, 0xD0, 0x38, 0x00, 0xEB, 0xC4, 0x01, 0xD1, 0xE9, 0x00, 0x01,
+	0x70, 0x40, 0x81, 0xEA,
+	0x08, 0x01, 0x08, 0x43, 0x01, 0xD0, 0x4F, 0xF0, 0x00, 0x0B, 0x09, 0xF1,
+	0x01, 0x09, 0x06, 0x98,
+	0x64, 0x1C, 0x84, 0x42, 0xB5, 0xDB, 0xBB, 0xF1, 0x01, 0x0F, 0x04, 0xD0,
+	0x00, 0x98, 0x40, 0x1C,
+	0x00, 0x90, 0x7F, 0x28, 0xA2, 0xDD, 0x09, 0xB0, 0x58, 0x46, 0xBD, 0xE8,
+	0xF0, 0x8F, 0x2D, 0xE9,
+	0xF1, 0x4F, 0x8A, 0xB0, 0x13, 0xF0, 0x3B, 0xFB, 0x06, 0x90, 0x13, 0xF0,
+	0x38, 0xFB, 0x00, 0x21,
+	0xCD, 0xE9, 0x02, 0x01, 0x0A, 0x98, 0x86, 0x4C, 0x00, 0x28, 0x56, 0xD0,
+	0x20, 0x68, 0xB0, 0xF8,
+	0x7A, 0x11, 0x0A, 0x98, 0xFF, 0xF7, 0xF8, 0xFE, 0x01, 0x90, 0x82, 0x48,
+	0x05, 0x90, 0x20, 0x20,
+	0x09, 0x90, 0x4F, 0xF0, 0x40, 0x0A, 0x04, 0x21, 0x06, 0xA8, 0xFD, 0xF7,
+	0xB4, 0xFE, 0x04, 0x46,
+	0x08, 0x21, 0x02, 0xA8, 0xFD, 0xF7, 0xAF, 0xFE, 0x44, 0x43, 0x7C, 0x48,
+	0x00, 0x90, 0x00, 0xF5,
+	0xE6, 0x60, 0x21, 0x46, 0x04, 0x90, 0x13, 0xF0, 0xCF, 0xFE, 0x61, 0x00,
+	0x00, 0x98, 0x13, 0xF0,
+	0xCB, 0xFE, 0x71, 0x48, 0xB8, 0x21, 0xD0, 0x38, 0x13, 0xF0, 0xE8, 0xFE,
+	0x00, 0x25, 0x0A, 0x98,
+	0xFF, 0xF7, 0xED, 0xFE, 0x6C, 0x48, 0x4F, 0xF0, 0x00, 0x09, 0x4C, 0x46,
+	0x80, 0x68, 0x07, 0x90,
+	0x68, 0x42, 0x4F, 0xF0, 0x01, 0x0B, 0x4E, 0x46, 0x08, 0x90, 0x01, 0x20,
+	0x06, 0x99, 0xB0, 0x40,
+	0x08, 0x42, 0x79, 0xD0, 0x00, 0x27, 0x3A, 0x46, 0x01, 0x20, 0x00, 0x21,
+	0x13, 0xF0, 0xF6, 0xFD,
+	0xDD, 0xE9, 0x02, 0x8C, 0x02, 0x46, 0x0B, 0x46, 0x00, 0xEA, 0x08, 0x00,
+	0x01, 0xEA, 0x0C, 0x01,
+	0x08, 0x43, 0x6A, 0xD0, 0x5C, 0x48, 0xD0, 0x38, 0x00, 0xEB, 0xC6, 0x0C,
+	0xDC, 0xE9, 0x00, 0x01,
+	0x10, 0x40, 0x19, 0x40, 0x08, 0x43, 0x0D, 0xD0, 0x89, 0xE0, 0x06, 0x98,
+	0x0F, 0xF0, 0xFC, 0xFF,
+	0x06, 0x90, 0x20, 0x68, 0xB0, 0xF8, 0x72, 0x11, 0x0A, 0x98, 0xFF, 0xF7,
+	0x9D, 0xFE, 0x01, 0x90,
+	0x55, 0x48, 0xA3, 0xE7, 0x00, 0x2D, 0x0A, 0xDA, 0x07, 0x98, 0x30, 0xF9,
+	0x14, 0x10, 0x01, 0x98,
+	0x81, 0x42, 0x01, 0xDB, 0x00, 0x21, 0x00, 0xE0, 0x01, 0x21, 0x04, 0x98,
+	0x01, 0x55, 0x07, 0x98,
+	0x01, 0x99, 0x30, 0xF9, 0x14, 0x00, 0x88, 0x42, 0x2A, 0xDD, 0x04, 0x99,
+	0x09, 0x5D, 0x11, 0xB1,
+	0x01, 0x29, 0x07, 0xD0, 0x63, 0xE0, 0x7F, 0x2D, 0x61, 0xDA, 0x00, 0x99,
+	0x6B, 0x1C, 0x21, 0xF8,
+	0x14, 0x00, 0x4C, 0xE0, 0xDC, 0xE9, 0x00, 0x10, 0x11, 0x43, 0x18, 0x43,
+	0xCC, 0xE9, 0x00, 0x10,
+	0x00, 0x98, 0x30, 0xF9, 0x14, 0x10, 0x01, 0x98, 0x08, 0x1A, 0x07, 0x99,
+	0x31, 0xF9, 0x14, 0x20,
+	0x01, 0x99, 0xA2, 0xEB, 0x01, 0x01, 0x00, 0xD5, 0x40, 0x42, 0x00, 0x29,
+	0x00, 0xDA, 0x49, 0x42,
+	0x88, 0x42, 0x3A, 0xDC, 0x08, 0x9B, 0x3A, 0x46, 0x49, 0x46, 0x5B, 0x1C,
+	0x05, 0x98, 0x31, 0xE0,
+	0x37, 0xDA, 0x04, 0x99, 0x09, 0x5D, 0x01, 0x29, 0x01, 0xD0, 0x79, 0xB1,
+	0x37, 0xE0, 0x08, 0x99,
+	0x11, 0xF1, 0x7F, 0x0F, 0x33, 0xDD, 0x00, 0x99, 0x3A, 0x46, 0x21, 0xF8,
+	0x14, 0x00, 0x08, 0x9B,
+	0x49, 0x46, 0x5B, 0x1E, 0x05, 0x98, 0x1D, 0xE0, 0x3E, 0xE0, 0x29, 0xE0,
+	0xDC, 0xE9, 0x00, 0x10,
+	0x11, 0x43, 0x18, 0x43, 0xCC, 0xE9, 0x00, 0x10, 0x00, 0x98, 0x30, 0xF9,
+	0x14, 0x10, 0x01, 0x98,
+	0x08, 0x1A, 0x07, 0x99, 0x31, 0xF9, 0x14, 0x20, 0x01, 0x99, 0xA2, 0xEB,
+	0x01, 0x01, 0x00, 0xD5,
+	0x40, 0x42, 0x00, 0x29, 0x00, 0xDA, 0x49, 0x42, 0x88, 0x42, 0x06, 0xDC,
+	0x6B, 0x1E, 0x3A, 0x46,
+	0x49, 0x46, 0x05, 0x98, 0xFD, 0xF7, 0xF1, 0xF9, 0x09, 0xE0, 0x00, 0x98,
+	0x20, 0xF8, 0x14, 0x20,
+	0x05, 0xE0, 0xDC, 0xE9, 0x00, 0x10, 0x11, 0x43, 0x18, 0x43, 0xCC, 0xE9,
+	0x00, 0x10, 0x64, 0x1C,
+	0x7F, 0x1C, 0x57, 0x45, 0xFF, 0xF6, 0x57, 0xAF, 0x0F, 0x48, 0xD0, 0x38,
+	0x00, 0xEB, 0xC6, 0x01,
+	0xD1, 0xE9, 0x00, 0x01, 0xDD, 0xE9, 0x02, 0x23, 0x50, 0x40, 0x59, 0x40,
+	0x08, 0x43, 0x01, 0xD0,
+	0x4F, 0xF0, 0x00, 0x0B, 0x09, 0xF1, 0x01, 0x09, 0x09, 0x98, 0x76, 0x1C,
+	0x86, 0x42, 0xFF, 0xF6,
+	0x3C, 0xAF, 0x58, 0x46, 0xBB, 0xF1, 0x01, 0x0F, 0x03, 0xD0, 0x6D, 0x1C,
+	0x7F, 0x2D, 0x7F, 0xF7,
+	0x26, 0xAF, 0x0B, 0xB0, 0xE9, 0xE6, 0x00, 0x00, 0x80, 0x10, 0x10, 0x00,
+	0x47, 0x32, 0x00, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x08, 0x92, 0x01, 0x20, 0x78, 0x8B, 0x01, 0x20,
+	0xD4, 0x56, 0x10, 0x00,
+	0x2D, 0xE9, 0xF1, 0x4F, 0x96, 0xB0, 0x4F, 0xF0, 0x00, 0x0A, 0x13, 0xF0,
+	0x18, 0xFA, 0x0D, 0x90,
+	0x13, 0xF0, 0x17, 0xFA, 0xCD, 0xE9, 0x0E, 0x01, 0x16, 0x98, 0x48, 0xB1,
+	0xFE, 0x48, 0x00, 0x68,
+	0xB0, 0xF8, 0x7A, 0x11, 0x16, 0x98, 0xFF, 0xF7, 0xD7, 0xFD, 0x11, 0x90,
+	0xFB, 0x48, 0x12, 0xE0,
+	0xF9, 0x4C, 0x20, 0x68, 0x90, 0xF8, 0xE7, 0x00, 0x10, 0xF0, 0x60, 0x0F,
+	0x03, 0xD0, 0x0D, 0x98,
+	0x0F, 0xF0, 0x22, 0xFF, 0x0D, 0x90, 0x20, 0x68, 0xB0, 0xF8, 0x72, 0x11,
+	0x16, 0x98, 0xFF, 0xF7,
+	0xC3, 0xFD, 0x11, 0x90, 0xF2, 0x48, 0x01, 0x90, 0x40, 0x20, 0x0A, 0x90,
+	0x20, 0x26, 0x04, 0x21,
+	0x0D, 0xA8, 0xFD, 0xF7, 0x80, 0xFD, 0x0C, 0x90, 0x08, 0x21, 0x0E, 0xA8,
+	0xFD, 0xF7, 0x7B, 0xFD,
+	0x07, 0x90, 0xB8, 0x21, 0xEB, 0x48, 0x13, 0xF0, 0xC1, 0xFD, 0x01, 0x20,
+	0x10, 0x90, 0x00, 0x20,
+	0x04, 0x46, 0x05, 0x90, 0x22, 0x46, 0x01, 0x20, 0x00, 0x21, 0x13, 0xF0,
+	0xDF, 0xFC, 0xDD, 0xE9,
+	0x0E, 0x23, 0x81, 0x46, 0x8B, 0x46, 0x10, 0x40, 0x19, 0x40, 0x08, 0x43,
+	0x78, 0xD0, 0xDE, 0x48,
+	0x00, 0x68, 0x90, 0xF8, 0x70, 0x01, 0x40, 0x07, 0x13, 0xD5, 0x05, 0x98,
+	0x80, 0xB1, 0x00, 0x25,
+	0x0B, 0xE0, 0xDD, 0xE9, 0x01, 0x02, 0x29, 0x46, 0xFD, 0xF7, 0x4C, 0xF9,
+	0x03, 0x46, 0x22, 0x46,
+	0x29, 0x46, 0x01, 0x98, 0xFD, 0xF7, 0x51, 0xF9, 0x6D, 0x1C, 0x0C, 0x98,
+	0x85, 0x42, 0xF0, 0xDB,
+	0x02, 0x94, 0x16, 0x98, 0xFF, 0xF7, 0x9B, 0xFD, 0xD2, 0x48, 0x4F, 0xF0,
+	0x01, 0x08, 0xD0, 0x30,
+	0x00, 0x25, 0x80, 0x68, 0x2F, 0x46, 0x14, 0x90, 0x01, 0x20, 0x0D, 0x99,
+	0xB8, 0x40, 0x08, 0x42,
+	0x45, 0xD0, 0xCC, 0x48, 0x00, 0xEB, 0xC7, 0x01, 0x15, 0x91, 0xD1, 0xE9,
+	0x00, 0x01, 0x00, 0xEA,
+	0x09, 0x00, 0x01, 0xEA, 0x0B, 0x01, 0x08, 0x43, 0x2E, 0xD1, 0x22, 0x46,
+	0x29, 0x46, 0x01, 0x98,
+	0xFD, 0xF7, 0x20, 0xF9, 0x07, 0x9A, 0x05, 0x99, 0x05, 0xFB, 0x02, 0x12,
+	0x14, 0x99, 0x31, 0xF9,
+	0x12, 0x20, 0x11, 0x99, 0x8A, 0x42, 0x0A, 0xDA, 0x15, 0x98, 0x15, 0x99,
+	0xD0, 0xE9, 0x00, 0x20,
+	0x42, 0xEA, 0x09, 0x02, 0x40, 0xEA, 0x0B, 0x00, 0xC1, 0xE9, 0x00, 0x20,
+	0x14, 0xE0, 0x7F, 0x28,
+	0x06, 0xDA, 0x43, 0x1C, 0x22, 0x46, 0x29, 0x46, 0x01, 0x98, 0xFD, 0xF7,
+	0x0E, 0xF9, 0x0B, 0xE0,
+	0x15, 0x98, 0x15, 0x9A, 0xD0, 0xE9, 0x00, 0x10, 0x41, 0xEA, 0x09, 0x01,
+	0x40, 0xEA, 0x0B, 0x00,
+	0xC2, 0xE9, 0x00, 0x10, 0x00, 0x20, 0x10, 0x90, 0x15, 0x99, 0x6D, 0x1C,
+	0xD1, 0xE9, 0x00, 0x01,
+	0x00, 0xEA, 0x09, 0x00, 0x01, 0xEA, 0x0B, 0x01, 0x08, 0x43, 0x00, 0xD1,
+	0x80, 0x46, 0x7F, 0x1C,
+	0xB7, 0x42, 0xB1, 0xDB, 0xB8, 0xF1, 0x00, 0x0F, 0xA3, 0xD0, 0x05, 0x98,
+	0x40, 0x1C, 0x05, 0x90,
+	0x0A, 0x98, 0x64, 0x1C, 0x84, 0x42, 0xFF, 0xF6, 0x75, 0xAF, 0x00, 0x20,
+	0xB4, 0xE0, 0x00, 0xBF,
+	0x4F, 0xF0, 0x00, 0x08, 0x45, 0x46, 0x2A, 0x46, 0x01, 0x20, 0x00, 0x21,
+	0x13, 0xF0, 0x4E, 0xFC,
+	0xDD, 0xE9, 0x0E, 0x23, 0x83, 0x46, 0x06, 0x91, 0x10, 0x40, 0x19, 0x40,
+	0x08, 0x43, 0x6E, 0xD0,
+	0xB8, 0xF1, 0x00, 0x0F, 0x01, 0xD1, 0x4F, 0xF0, 0x01, 0x0A, 0x16, 0x98,
+	0xFF, 0xF7, 0x1F, 0xFD,
+	0x94, 0x48, 0x4F, 0xF0, 0x01, 0x09, 0xD0, 0x30, 0x00, 0x27, 0x80, 0x68,
+	0x3C, 0x46, 0x14, 0x90,
+	0x01, 0x20, 0x0D, 0x99, 0xA0, 0x40, 0x08, 0x42, 0x78, 0xD0, 0xB8, 0xF1,
+	0x00, 0x0F, 0x0E, 0xDD,
+	0x2A, 0x46, 0x39, 0x46, 0x01, 0x98, 0xFD, 0xF7, 0xAD, 0xF8, 0x8A, 0x49,
+	0x2A, 0x46, 0xB8, 0x31,
+	0x09, 0x57, 0x0B, 0x18, 0x39, 0x46, 0x01, 0x98, 0xFD, 0xF7, 0xAF, 0xF8,
+	0x65, 0xE0, 0xBA, 0xF1,
+	0x01, 0x0F, 0x12, 0xD1, 0x2A, 0x46, 0x39, 0x46, 0x01, 0x98, 0xFD, 0xF7,
+	0x9B, 0xF8, 0x81, 0x49,
+	0xB8, 0x31, 0x08, 0x55, 0x7F, 0x48, 0x00, 0xEB, 0xC4, 0x03, 0xD3, 0xE9,
+	0x00, 0x01, 0x06, 0x9A,
+	0x20, 0xEA, 0x0B, 0x00, 0x91, 0x43, 0xC3, 0xE9, 0x00, 0x01, 0x7A, 0x48,
+	0x06, 0x9B, 0x00, 0xEB,
+	0xC4, 0x00, 0x0C, 0x90, 0xD0, 0xE9, 0x00, 0x10, 0x01, 0xEA, 0x0B, 0x01,
+	0x18, 0x40, 0x01, 0x43,
+	0x39, 0xD1, 0x2A, 0x46, 0x39, 0x46, 0x01, 0x98, 0xFD, 0xF7, 0x7C, 0xF8,
+	0x07, 0x9A, 0x14, 0x99,
+	0x07, 0xFB, 0x02, 0x82, 0x31, 0xF9, 0x12, 0x20, 0x11, 0x99, 0x8A, 0x42,
+	0x0E, 0xDA, 0x0C, 0x99,
+	0x06, 0x9B, 0xD1, 0xE9, 0x00, 0xC2, 0x4C, 0xEA, 0x0B, 0x0C, 0x1A, 0x43,
+	0xC1, 0xE9, 0x00, 0xC2,
+	0x68, 0x49, 0xB8, 0x31, 0x0A, 0x5D, 0x80, 0x1A, 0x08, 0x55, 0x1C, 0xE0,
+	0x7F, 0x28, 0x07, 0xDA,
+	0x43, 0x1C, 0x2A, 0x46, 0x39, 0x46, 0x01, 0x98, 0xFD, 0xF7, 0x67, 0xF8,
+	0x13, 0xE0, 0x29, 0xE0,
+	0x0C, 0x99, 0xDD, 0xF8, 0x18, 0xC0, 0x0C, 0x9B, 0xD1, 0xE9, 0x00, 0x21,
+	0x42, 0xEA, 0x0B, 0x02,
+	0x41, 0xEA, 0x0C, 0x01, 0xC3, 0xE9, 0x00, 0x21, 0x5A, 0x49, 0xB8, 0x31,
+	0x0A, 0x5D, 0x80, 0x1A,
+	0x08, 0x55, 0x00, 0x20, 0x10, 0x90, 0x0C, 0x98, 0x06, 0x9A, 0xD0, 0xE9,
+	0x00, 0x10, 0x01, 0xEA,
+	0x0B, 0x01, 0x10, 0x40, 0x01, 0x43, 0x00, 0xD1, 0x89, 0x46, 0x7F, 0x1C,
+	0x64, 0x1C, 0xB4, 0x42,
+	0xFF, 0xF6, 0x7E, 0xAF, 0x4F, 0xF0, 0x00, 0x0A, 0xB9, 0xF1, 0x00, 0x0F,
+	0x3F, 0xF4, 0x6D, 0xAF,
+	0x08, 0xF1, 0x01, 0x08, 0x0A, 0x98, 0x6D, 0x1C, 0x85, 0x42, 0xFF, 0xF6,
+	0x54, 0xAF, 0x16, 0x98,
+	0xFF, 0xF7, 0x85, 0xFC, 0x0B, 0x98, 0x40, 0x1C, 0x0B, 0x90, 0x43, 0x48,
+	0x00, 0x68, 0x90, 0xF8,
+	0x70, 0x11, 0x0B, 0x98, 0xB0, 0xEB, 0x11, 0x1F, 0xFF, 0xF6, 0x42, 0xAF,
+	0x10, 0x98, 0x17, 0xB0,
+	0x4B, 0xE5, 0x2D, 0xE9, 0xF0, 0x4F, 0x8B, 0xB0, 0x13, 0xF0, 0x8D, 0xF8,
+	0x09, 0x90, 0x13, 0xF0,
+	0x8C, 0xF8, 0x8A, 0x46, 0x38, 0x49, 0x81, 0x46, 0x00, 0x20, 0x0A, 0x68,
+	0x01, 0x46, 0x16, 0x46,
+	0x92, 0xF8, 0x61, 0x54, 0x01, 0x24, 0x02, 0xF2, 0x72, 0x42, 0x00, 0xBF,
+	0x04, 0xFA, 0x01, 0xF3,
+	0x1D, 0x42, 0x03, 0xD0, 0x57, 0x5C, 0x04, 0xFA, 0x07, 0xF3, 0x18, 0x43,
+	0x49, 0x1C, 0x04, 0x29,
+	0xF4, 0xDB, 0x01, 0x90, 0x00, 0x20, 0x00, 0x90, 0x20, 0x20, 0x08, 0x90,
+	0x40, 0x20, 0x07, 0x90,
+	0xB6, 0xF8, 0x82, 0x11, 0x02, 0x20, 0xFF, 0xF7, 0x2F, 0xFC, 0x03, 0x90,
+	0x2A, 0x48, 0x05, 0x90,
+	0x2A, 0x48, 0x00, 0x21, 0x02, 0x90, 0x01, 0x60, 0x0D, 0x46, 0x41, 0x60,
+	0x02, 0x20, 0xFF, 0xF7,
+	0x3E, 0xFC, 0x24, 0x48, 0x00, 0x24, 0xD0, 0x30, 0xA3, 0x46, 0x40, 0x69,
+	0x06, 0x90, 0x01, 0x20,
+	0x27, 0x46, 0x04, 0x90, 0x01, 0x20, 0x09, 0x99, 0xB8, 0x40, 0x08, 0x42,
+	0x63, 0xD0, 0x00, 0x26,
+	0x32, 0x46, 0x01, 0x20, 0x00, 0x21, 0x13, 0xF0, 0x49, 0xFB, 0x80, 0x46,
+	0x0A, 0x46, 0x00, 0xEA,
+	0x09, 0x00, 0x01, 0xEA, 0x0A, 0x01, 0x08, 0x43, 0x4F, 0xD0, 0x16, 0x48,
+	0x00, 0xEB, 0xC7, 0x01,
+	0xD1, 0xE9, 0x00, 0x01, 0x00, 0xEA, 0x08, 0x00, 0x11, 0x40, 0x08, 0x43,
+	0x44, 0xD1, 0x01, 0x20,
+	0x01, 0x99, 0x00, 0xFA, 0x04, 0xF8, 0x18, 0xEA, 0x01, 0x0F, 0x3D, 0xD0,
+	0x06, 0x98, 0x30, 0xF9,
+	0x14, 0x20, 0x03, 0x98, 0x82, 0x42, 0x2C, 0xDC, 0x00, 0x2D, 0x2A, 0xDD,
+	0x02, 0x98, 0x30, 0xF9,
+	0x14, 0x10, 0x03, 0x98, 0x08, 0x1A, 0x03, 0x99, 0xA2, 0xEB, 0x01, 0x01,
+	0x00, 0xD5, 0x40, 0x42,
+	0x00, 0x29, 0x00, 0xDA, 0x49, 0x42, 0x0B, 0xE0, 0x4C, 0x07, 0x10, 0x00,
+	0x08, 0x92, 0x01, 0x20,
+	0x78, 0x8B, 0x01, 0x20, 0xB0, 0x0F, 0x10, 0x00, 0x98, 0x98, 0x01, 0x20,
+	0xD4, 0x56, 0x10, 0x00,
+	0x88, 0x42, 0x06, 0xDC, 0x6B, 0x1E, 0x32, 0x46, 0x59, 0x46, 0x05, 0x98,
+	0xFC, 0xF7, 0x95, 0xFF,
+	0x02, 0xE0, 0x02, 0x98, 0x20, 0xF8, 0x14, 0x20, 0x00, 0x99, 0x48, 0xEA,
+	0x01, 0x00, 0x00, 0x90,
+	0x0A, 0xE0, 0x7F, 0x2D, 0x08, 0xDA, 0x02, 0x98, 0x6B, 0x1C, 0x59, 0x46,
+	0x20, 0xF8, 0x14, 0x20,
+	0x32, 0x46, 0x05, 0x98, 0xFC, 0xF7, 0x81, 0xFF, 0x64, 0x1C, 0x07, 0x98,
+	0x76, 0x1C, 0x86, 0x42,
+	0x9E, 0xDB, 0x0B, 0xF1, 0x01, 0x0B, 0x08, 0x98, 0x7F, 0x1C, 0x87, 0x42,
+	0x92, 0xDB, 0xDD, 0xE9,
+	0x00, 0x01, 0x88, 0x42, 0x05, 0xD0, 0x00, 0x20, 0x6D, 0x1C, 0x04, 0x90,
+	0x7F, 0x2D, 0x7F, 0xF7,
+	0x7D, 0xAF, 0x04, 0x98, 0xA5, 0xE5, 0x2D, 0xE9, 0xFF, 0x5F, 0x04, 0x46,
+	0x01, 0x25, 0x12, 0xF0,
+	0xD0, 0xFF, 0xCD, 0xE9, 0x02, 0x01, 0xC5, 0x48, 0x40, 0x27, 0x08, 0x21,
+	0x00, 0x68, 0x00, 0xF2,
+	0x02, 0x60, 0x01, 0x90, 0xC2, 0x48, 0x00, 0x90, 0x02, 0xA8, 0xFD, 0xF7,
+	0x54, 0xFB, 0x06, 0x46,
+	0x01, 0x2C, 0x6E, 0xD1, 0xDD, 0xE9, 0x02, 0x23, 0x29, 0x46, 0x00, 0x98,
+	0xFC, 0xF7, 0x5C, 0xFF,
+	0xDF, 0xF8, 0xF0, 0x92, 0x00, 0x20, 0x09, 0xEB, 0x46, 0x0B, 0x47, 0xF6,
+	0xFF, 0x72, 0x6F, 0xF0,
+	0x7E, 0x01, 0x04, 0xE0, 0x29, 0xF8, 0x10, 0x20, 0x0B, 0xF8, 0x00, 0x10,
+	0x40, 0x1C, 0xB0, 0x42,
+	0xF8, 0xDB, 0x6F, 0xF0, 0x7F, 0x08, 0x03, 0x20, 0xFF, 0xF7, 0x89, 0xFB,
+	0xB2, 0x48, 0x00, 0x24,
+	0x25, 0x46, 0xD0, 0xF8, 0x08, 0xA0, 0x2A, 0x46, 0x01, 0x20, 0x00, 0x21,
+	0x13, 0xF0, 0x9E, 0xFA,
+	0xDD, 0xE9, 0x02, 0x23, 0x10, 0x40, 0x19, 0x40, 0x08, 0x43, 0x1D, 0xD0,
+	0x3A, 0xF9, 0x14, 0x10,
+	0x39, 0xF9, 0x14, 0x00, 0x00, 0x29, 0x00, 0xDA, 0x49, 0x42, 0x00, 0x28,
+	0x00, 0xDA, 0x40, 0x42,
+	0x81, 0x42, 0x0A, 0xDA, 0x2A, 0x46, 0x00, 0x21, 0x00, 0x98, 0xFC, 0xF7,
+	0x0B, 0xFF, 0x0B, 0xF8,
+	0x04, 0x00, 0x3A, 0xF8, 0x14, 0x10, 0x29, 0xF8, 0x14, 0x10, 0x43, 0x46,
+	0x2A, 0x46, 0x00, 0x21,
+	0x00, 0x98, 0xFC, 0xF7, 0x0A, 0xFF, 0x64, 0x1C, 0x6D, 0x1C, 0xBD, 0x42,
+	0xD3, 0xDB, 0x08, 0xF1,
+	0x01, 0x08, 0xB8, 0xF1, 0x7F, 0x0F, 0xC6, 0xDD, 0x00, 0x25, 0x2C, 0x46,
+	0x22, 0x46, 0x01, 0x20,
+	0x00, 0x21, 0x13, 0xF0, 0x6B, 0xFA, 0xDD, 0xE9, 0x02, 0x23, 0x10, 0x40,
+	0x19, 0x40, 0x08, 0x43,
+	0x07, 0xD0, 0x1B, 0xF9, 0x05, 0x30, 0x22, 0x46, 0x00, 0x21, 0x00, 0x98,
+	0xFC, 0xF7, 0xED, 0xFE,
+	0x6D, 0x1C, 0x64, 0x1C, 0xBC, 0x42, 0xE9, 0xDB, 0xDD, 0xE9, 0x00, 0x10,
+	0x26, 0x22, 0x13, 0xF0,
+	0x8C, 0xFA, 0x00, 0x25, 0xDF, 0xF8, 0x24, 0x82, 0x2C, 0x46, 0x22, 0x46,
+	0x01, 0x20, 0x00, 0x21,
+	0x13, 0xF0, 0x4C, 0xFA, 0xDD, 0xE9, 0x02, 0x23, 0x10, 0x40, 0x19, 0x40,
+	0x08, 0x43, 0x07, 0xD0,
+	0x22, 0x46, 0x00, 0x21, 0x00, 0x98, 0xFC, 0xF7, 0xC5, 0xFE, 0x28, 0xF8,
+	0x15, 0x00, 0x6D, 0x1C,
+	0x64, 0x1C, 0xBC, 0x42, 0xE9, 0xDB, 0x03, 0x20, 0xFF, 0xF7, 0x19, 0xFB,
+	0x7A, 0x48, 0x42, 0x46,
+	0x81, 0x68, 0x00, 0x20, 0x06, 0xE0, 0x00, 0xBF, 0x31, 0xF8, 0x10, 0x30,
+	0x34, 0x18, 0x40, 0x1C,
+	0x22, 0xF8, 0x14, 0x30, 0xB0, 0x42, 0xF7, 0xDB, 0xBD, 0xE8, 0xFF, 0x9F,
+	0x2D, 0xE9, 0xF0, 0x5F,
+	0x07, 0x46, 0x01, 0x24, 0x00, 0x20, 0xFC, 0xF7, 0x44, 0xFD, 0x02, 0x20,
+	0xFC, 0xF7, 0x41, 0xFD,
+	0x6F, 0x49, 0x01, 0x20, 0x08, 0x70, 0x69, 0x4E, 0xF8, 0x07, 0x4F, 0xF0,
+	0x00, 0x08, 0x4F, 0xF0,
+	0xA5, 0x09, 0x09, 0xD0, 0x00, 0xF0, 0x55, 0xF8, 0x10, 0xF0, 0x01, 0x04,
+	0x04, 0xD0, 0x30, 0x68,
+	0x80, 0xF8, 0x1B, 0x80, 0x80, 0xF8, 0x1A, 0x90, 0xB8, 0x07, 0x09, 0xD5,
+	0x00, 0xF0, 0x8F, 0xF8,
+	0x20, 0x40, 0x04, 0x00, 0x04, 0xD0, 0x30, 0x68, 0x80, 0xF8, 0x1D, 0x80,
+	0x80, 0xF8, 0x1C, 0x90,
+	0xDF, 0xF8, 0x80, 0xA1, 0xDA, 0xF8, 0x00, 0x00, 0x90, 0xF8, 0x61, 0x04,
+	0x58, 0xB3, 0xF8, 0x06,
+	0x29, 0xD5, 0x01, 0x25, 0x12, 0xF0, 0xEF, 0xFE, 0x83, 0x46, 0x12, 0xF0,
+	0xEE, 0xFE, 0xDA, 0xF8,
+	0x00, 0x20, 0x92, 0xF8, 0x80, 0x21, 0xD2, 0x07, 0x13, 0xD0, 0x02, 0x46,
+	0x0B, 0x46, 0x59, 0x46,
+	0x55, 0x48, 0xFC, 0xF7, 0x81, 0xFE, 0xDA, 0xF8, 0x00, 0x00, 0x90, 0xF8,
+	0x80, 0x01, 0xC0, 0x07,
+	0x07, 0xD0, 0xFF, 0xF7, 0x46, 0xFE, 0x05, 0x00, 0x03, 0xD1, 0x02, 0x21,
+	0x74, 0x20, 0x0E, 0xF0,
+	0x1D, 0xFC, 0x02, 0x20, 0xFF, 0xF7, 0xB3, 0xFA, 0x2C, 0x40, 0x04, 0xD0,
+	0x30, 0x68, 0x80, 0xF8,
+	0x25, 0x80, 0x80, 0xF8, 0x24, 0x90, 0x00, 0x20, 0xFC, 0xF7, 0x06, 0xFD,
+	0x02, 0x20, 0xFC, 0xF7,
+	0x03, 0xFD, 0xF8, 0x07, 0x02, 0xD0, 0x01, 0x20, 0x00, 0xF0, 0xBA, 0xF8,
+	0x20, 0x46, 0xBD, 0xE8,
+	0xF0, 0x9F, 0x2D, 0xE9, 0xF0, 0x41, 0x01, 0x24, 0x12, 0xF0, 0xB1, 0xFE,
+	0x80, 0x46, 0x12, 0xF0,
+	0xB0, 0xFE, 0x3C, 0x4D, 0x06, 0x46, 0x0F, 0x46, 0x28, 0x68, 0x90, 0xF8,
+	0xE7, 0x00, 0x10, 0xF0,
+	0x60, 0x0F, 0x03, 0xD0, 0x40, 0x46, 0x0F, 0xF0, 0xC7, 0xFB, 0x80, 0x46,
+	0x28, 0x68, 0x90, 0xF8,
+	0x70, 0x01, 0xC0, 0x07, 0x25, 0xD0, 0x32, 0x46, 0x3B, 0x46, 0x41, 0x46,
+	0x33, 0x48, 0xFC, 0xF7,
+	0x3B, 0xFE, 0x28, 0x68, 0x90, 0xF8, 0x70, 0x11, 0xC9, 0x07, 0x1A, 0xD0,
+	0x90, 0xF8, 0xE8, 0x10,
+	0x89, 0x07, 0x03, 0xD4, 0x00, 0x20, 0xFF, 0xF7, 0x6B, 0xFC, 0x0C, 0xE0,
+	0x90, 0xF8, 0xE7, 0x00,
+	0xC0, 0xF3, 0x41, 0x10, 0x02, 0x28, 0x4F, 0xF0, 0x00, 0x00, 0x02, 0xD3,
+	0xFF, 0xF7, 0x3F, 0xFB,
+	0x01, 0xE0, 0xFF, 0xF7, 0xA7, 0xFA, 0x04, 0x00, 0x03, 0xD1, 0x01, 0x21,
+	0x74, 0x20, 0x0E, 0xF0,
+	0xC5, 0xFB, 0x00, 0x20, 0xFF, 0xF7, 0x5B, 0xFA, 0x20, 0x46, 0xBD, 0xE8,
+	0xF0, 0x81, 0x70, 0xB5,
+	0x01, 0x24, 0x12, 0xF0, 0x6C, 0xFE, 0x06, 0x46, 0x12, 0xF0, 0x6B, 0xFE,
+	0x19, 0x4D, 0x2A, 0x68,
+	0x92, 0xF8, 0x78, 0x21, 0xD2, 0x07, 0x1B, 0xD0, 0x02, 0x46, 0x0B, 0x46,
+	0x31, 0x46, 0x18, 0x48,
+	0xFC, 0xF7, 0x02, 0xFE, 0x28, 0x68, 0x90, 0xF8, 0x78, 0x11, 0xC9, 0x07,
+	0x10, 0xD0, 0x90, 0xF8,
+	0xE8, 0x00, 0x80, 0x07, 0x20, 0x46, 0x02, 0xD4, 0xFF, 0xF7, 0x32, 0xFC,
+	0x01, 0xE0, 0xFF, 0xF7,
+	0x79, 0xFA, 0x04, 0x00, 0x04, 0xD1, 0x4F, 0xF4, 0x80, 0x71, 0x74, 0x20,
+	0x0E, 0xF0, 0x96, 0xFB,
+	0x01, 0x20, 0xFF, 0xF7, 0x2C, 0xFA, 0x20, 0x46, 0x70, 0xBD, 0x00, 0x00,
+	0x50, 0x07, 0x10, 0x00,
+	0xE4, 0x9F, 0x01, 0x20, 0xD4, 0x56, 0x10, 0x00, 0x80, 0x10, 0x10, 0x00,
+	0x04, 0x4B, 0x01, 0x20,
+	0x78, 0x07, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00, 0x98, 0x98, 0x01, 0x20,
+	0x78, 0x8B, 0x01, 0x20,
+	0x08, 0x92, 0x01, 0x20, 0x10, 0xB5, 0xFF, 0xF7, 0xD6, 0xF9, 0x53, 0x20,
+	0xFF, 0xF7, 0x06, 0xFF,
+	0x00, 0x28, 0x12, 0xD0, 0x4F, 0xF4, 0xD6, 0x70, 0x00, 0xF0, 0x7B, 0xFF,
+	0x00, 0x28, 0x0C, 0xD0,
+	0x24, 0x48, 0x25, 0x49, 0x00, 0x68, 0x09, 0x68, 0x90, 0xF8, 0xDE, 0x00,
+	0x08, 0x76, 0xFE, 0xF7,
+	0x45, 0xFE, 0xBD, 0xE8, 0x10, 0x40, 0xFE, 0xF7, 0xD5, 0xBD, 0x10, 0xBD,
+	0x10, 0xB5, 0xFF, 0xF7,
+	0xBA, 0xF9, 0x40, 0xF2, 0xFF, 0x10, 0xFE, 0xF7, 0x41, 0xFD, 0x1A, 0x48,
+	0x1A, 0x49, 0x00, 0x68,
+	0x09, 0x68, 0x90, 0xF8, 0xDE, 0x00, 0x08, 0x76, 0xBD, 0xE8, 0x10, 0x40,
+	0xFE, 0xF7, 0xC2, 0xBD,
+	0x2D, 0xE9, 0xF0, 0x41, 0x13, 0x49, 0x09, 0x68, 0x91, 0xF8, 0xC1, 0x21,
+	0xD2, 0x07, 0x1F, 0xD0,
+	0x01, 0x28, 0x1D, 0xD1, 0x10, 0x4F, 0x91, 0xF8, 0x31, 0x20, 0x91, 0xF8,
+	0x30, 0x10, 0x3D, 0x68,
+	0x4A, 0x43, 0x02, 0x20, 0x0D, 0x4E, 0x14, 0xB2, 0x32, 0x35, 0xFD, 0xF7,
+	0xE2, 0xFF, 0x03, 0x20,
+	0xFC, 0xF7, 0x0F, 0xFC, 0x38, 0x68, 0x62, 0x00, 0x31, 0x46, 0x04, 0x86,
+	0x28, 0x46, 0x13, 0xF0,
+	0x1C, 0xF9, 0x03, 0x20, 0xFC, 0xF7, 0x20, 0xFC, 0xBD, 0xE8, 0xF0, 0x41,
+	0xFE, 0xF7, 0x9A, 0xBD,
+	0xBD, 0xE8, 0xF0, 0x81, 0x4C, 0x07, 0x10, 0x00, 0x50, 0x07, 0x10, 0x00,
+	0x42, 0x44, 0x01, 0x20,
+	0x10, 0xB5, 0x01, 0x46, 0x34, 0x22, 0xFB, 0x48, 0x13, 0xF0, 0x4C, 0xF9,
+	0x01, 0x21, 0xBD, 0xE8,
+	0x10, 0x40, 0x00, 0x20, 0xFC, 0xF7, 0x0D, 0xBB, 0x30, 0xB5, 0x85, 0xB0,
+	0x68, 0x46, 0x12, 0xF0,
+	0x61, 0xFD, 0xF5, 0x48, 0x02, 0x22, 0x00, 0x78, 0xE0, 0xB1, 0x03, 0x21,
+	0x01, 0x28, 0x0D, 0xD0,
+	0x03, 0x28, 0x0E, 0xD0, 0x02, 0x28, 0x18, 0xD0, 0x04, 0x22, 0x05, 0x28,
+	0x0C, 0xD0, 0x04, 0x28,
+	0x0D, 0xD0, 0x06, 0x28, 0x0E, 0xD0, 0x07, 0x28, 0x0F, 0xD0, 0x10, 0xE0,
+	0x8D, 0xF8, 0x06, 0x10,
+	0x0D, 0xE0, 0x8D, 0xF8, 0x08, 0x10, 0x0A, 0xE0, 0x8D, 0xF8, 0x0A, 0x20,
+	0x07, 0xE0, 0x8D, 0xF8,
+	0x0A, 0x10, 0x04, 0xE0, 0x8D, 0xF8, 0x06, 0x20, 0x01, 0xE0, 0x8D, 0xF8,
+	0x08, 0x20, 0xE3, 0x48,
+	0x00, 0x90, 0xE3, 0x48, 0x00, 0x68, 0x90, 0xF8, 0xB0, 0x10, 0xC9, 0x07,
+	0x0B, 0xD0, 0x01, 0x21,
+	0x8D, 0xF8, 0x0D, 0x10, 0x90, 0xF8, 0xB0, 0x00, 0xC0, 0xF3, 0xC1, 0x00,
+	0x02, 0x28, 0x02, 0xD1,
+	0x00, 0x20, 0x8D, 0xF8, 0x0D, 0x00, 0xD7, 0x4D, 0x03, 0x24, 0x68, 0x46,
+	0x12, 0xF0, 0x47, 0xFD,
+	0x00, 0x22, 0x04, 0xAB, 0x01, 0x21, 0x10, 0x46, 0xFC, 0xF7, 0x0C, 0xFB,
+	0x01, 0x21, 0x00, 0x20,
+	0xFC, 0xF7, 0xEB, 0xFA, 0x28, 0x78, 0x00, 0x28, 0x04, 0xD0, 0x0E, 0xF0,
+	0xCE, 0xFA, 0x64, 0x1E,
+	0x00, 0x2C, 0xEA, 0xDC, 0x05, 0xB0, 0x30, 0xBD, 0x2D, 0xE9, 0xF0, 0x4F,
+	0xCA, 0x4E, 0x04, 0x46,
+	0x87, 0xB0, 0x06, 0x20, 0x89, 0x46, 0x30, 0x70, 0x12, 0xF0, 0x61, 0xFD,
+	0x00, 0x21, 0x20, 0x27,
+	0xCD, 0xE9, 0x04, 0x01, 0x1D, 0x20, 0xC7, 0x4D, 0x02, 0x90, 0x24, 0xB1,
+	0x01, 0x2C, 0x0E, 0xD0,
+	0x02, 0x2C, 0x21, 0xD0, 0x2F, 0xE0, 0xC4, 0x48, 0x00, 0x90, 0xDF, 0xF8,
+	0xF8, 0x82, 0x28, 0x68,
+	0x08, 0xF1, 0x18, 0x08, 0xDF, 0xF8, 0x04, 0xA3, 0x00, 0xF5, 0xC5, 0x60,
+	0x22, 0xE0, 0x12, 0xF0,
+	0x48, 0xFD, 0xCD, 0xE9, 0x04, 0x01, 0xBC, 0x48, 0x40, 0x27, 0x20, 0x30,
+	0x00, 0x90, 0x28, 0x68,
+	0xDF, 0xF8, 0xD0, 0x82, 0x00, 0xF2, 0x5E, 0x60, 0x01, 0x90, 0x26, 0x20,
+	0x08, 0xF1, 0x1C, 0x08,
+	0xDF, 0xF8, 0xDC, 0xA2, 0x02, 0x90, 0x0E, 0xE0, 0x07, 0x20, 0x30, 0x70,
+	0xB2, 0x48, 0xDF, 0xF8,
+	0xB4, 0x82, 0x48, 0x30, 0x00, 0x90, 0x28, 0x68, 0xDF, 0xF8, 0xC8, 0xA2,
+	0x08, 0xF1, 0x28, 0x08,
+	0x00, 0xF2, 0x84, 0x60, 0x01, 0x90, 0x08, 0x21, 0x04, 0xA8, 0xFD, 0xF7,
+	0xB4, 0xF8, 0x04, 0x46,
+	0xB9, 0xF1, 0x01, 0x0F, 0x74, 0xD1, 0x22, 0x46, 0x04, 0xA9, 0x00, 0x98,
+	0xFC, 0xF7, 0xF7, 0xFC,
+	0xDF, 0xF8, 0xA4, 0xB2, 0x47, 0xF6, 0xFF, 0x71, 0x0B, 0xEB, 0x44, 0x00,
+	0x03, 0x90, 0x00, 0x20,
+	0x6F, 0xF0, 0x7E, 0x02, 0x05, 0xE0, 0x00, 0xBF, 0x2B, 0xF8, 0x10, 0x10,
+	0x03, 0x9B, 0x1A, 0x54,
+	0x40, 0x1C, 0xA0, 0x42, 0xF8, 0xDB, 0x6F, 0xF0, 0x7F, 0x09, 0x00, 0xBF,
+	0xFF, 0xF7, 0x3C, 0xFF,
+	0xD8, 0xF8, 0x00, 0x00, 0x00, 0x25, 0x2E, 0x46, 0x06, 0x90, 0x2B, 0xE0,
+	0x32, 0x46, 0x01, 0x20,
+	0x00, 0x21, 0x12, 0xF0, 0xFB, 0xFF, 0xDD, 0xE9, 0x04, 0x23, 0x10, 0x40,
+	0x19, 0x40, 0x08, 0x43,
+	0x1D, 0xD0, 0x06, 0x98, 0x30, 0xF9, 0x15, 0x10, 0x3B, 0xF9, 0x15, 0x00,
+	0x00, 0x29, 0x00, 0xDA,
+	0x49, 0x42, 0x00, 0x28, 0x00, 0xDA, 0x40, 0x42, 0x81, 0x42, 0x0A, 0xDA,
+	0x31, 0x46, 0x00, 0x98,
+	0xFC, 0xF7, 0xAB, 0xFC, 0x03, 0x99, 0x48, 0x55, 0x06, 0x98, 0x30, 0xF8,
+	0x15, 0x10, 0x2B, 0xF8,
+	0x15, 0x10, 0x4A, 0x46, 0x31, 0x46, 0x00, 0x98, 0xFC, 0xF7, 0xA6, 0xFC,
+	0x6D, 0x1C, 0xA5, 0x42,
+	0x02, 0xD0, 0x76, 0x1C, 0xBE, 0x42, 0xD1, 0xDB, 0x09, 0xF1, 0x01, 0x09,
+	0xB9, 0xF1, 0x7F, 0x0F,
+	0xC4, 0xDD, 0x00, 0x26, 0x35, 0x46, 0x14, 0xE0, 0x2A, 0x46, 0x01, 0x20,
+	0x00, 0x21, 0x12, 0xF0,
+	0xC5, 0xFF, 0xDD, 0xE9, 0x04, 0x23, 0x10, 0x40, 0x19, 0x40, 0x08, 0x43,
+	0x06, 0xD0, 0x03, 0x98,
+	0x29, 0x46, 0x82, 0x57, 0x00, 0x98, 0xFC, 0xF7, 0x87, 0xFC, 0x76, 0x1C,
+	0xA6, 0x42, 0x02, 0xD0,
+	0x6D, 0x1C, 0xBD, 0x42, 0xE8, 0xDB, 0xDD, 0xE9, 0x00, 0x10, 0x02, 0x9A,
+	0x12, 0xF0, 0xE5, 0xFF,
+	0x00, 0x26, 0x35, 0x46, 0x14, 0xE0, 0x2A, 0x46, 0x01, 0x20, 0x00, 0x21,
+	0x12, 0xF0, 0xA6, 0xFF,
+	0xDD, 0xE9, 0x04, 0x23, 0x10, 0x40, 0x19, 0x40, 0x08, 0x43, 0x06, 0xD0,
+	0x29, 0x46, 0x00, 0x98,
+	0xFC, 0xF7, 0x63, 0xFC, 0x2A, 0xF8, 0x16, 0x00, 0x76, 0x1C, 0xA6, 0x42,
+	0x02, 0xD0, 0x6D, 0x1C,
+	0xBD, 0x42, 0xE8, 0xDB, 0xFF, 0xF7, 0xC8, 0xFE, 0x00, 0x20, 0xD8, 0xF8,
+	0x00, 0x10, 0x05, 0xE0,
+	0x31, 0xF8, 0x10, 0x30, 0x25, 0x18, 0x40, 0x1C, 0x2A, 0xF8, 0x15, 0x30,
+	0xA0, 0x42, 0xF7, 0xDB,
+	0x07, 0xB0, 0xBD, 0xE8, 0xF0, 0x8F, 0x70, 0xB5, 0x55, 0x4C, 0x05, 0x46,
+	0x20, 0x68, 0x90, 0xF8,
+	0x88, 0x01, 0xC0, 0x06, 0x07, 0xD5, 0x29, 0x46, 0x00, 0x20, 0xFF, 0xF7,
+	0x05, 0xFF, 0x29, 0x46,
+	0x01, 0x20, 0xFF, 0xF7, 0x01, 0xFF, 0x20, 0x68, 0x90, 0xF8, 0xA0, 0x01,
+	0xC0, 0x06, 0x04, 0xD5,
+	0x29, 0x46, 0xBD, 0xE8, 0x70, 0x40, 0x02, 0x20, 0xF6, 0xE6, 0x70, 0xBD,
+	0x2D, 0xE9, 0xF0, 0x47,
+	0x45, 0x49, 0x00, 0x25, 0x2C, 0x46, 0x0E, 0x69, 0xD1, 0xF8, 0x38, 0x30,
+	0x28, 0x46, 0x01, 0x27,
+	0x07, 0xFA, 0x00, 0xF2, 0x32, 0x42, 0x03, 0xD0, 0x1A, 0x5C, 0xAA, 0x42,
+	0x00, 0xD9, 0x15, 0x46,
+	0x40, 0x1C, 0x20, 0x28, 0xF4, 0xD3, 0xD1, 0xE9, 0x14, 0x78, 0xD1, 0xF8,
+	0x3C, 0x90, 0x00, 0x26,
+	0x8A, 0x46, 0x32, 0x46, 0x01, 0x20, 0x00, 0x21, 0x12, 0xF0, 0x48, 0xFF,
+	0x38, 0x40, 0x01, 0xEA,
+	0x08, 0x01, 0x08, 0x43, 0x04, 0xD0, 0x19, 0xF8, 0x06, 0x00, 0xA0, 0x42,
+	0x00, 0xD9, 0x04, 0x46,
+	0x76, 0x1C, 0x40, 0x2E, 0xED, 0xD3, 0xDA, 0xF8, 0x48, 0x20, 0x50, 0x46,
+	0x15, 0x70, 0xDA, 0xF8,
+	0x4C, 0x10, 0x0C, 0x70, 0xDA, 0xF8, 0x30, 0x30, 0xDA, 0xF8, 0x28, 0x70,
+	0xDA, 0xF8, 0x34, 0x60,
+	0x1B, 0x78, 0x3F, 0x78, 0x2B, 0x44, 0x3B, 0x44, 0xDA, 0xF8, 0x2C, 0x70,
+	0x36, 0x78, 0x3F, 0x78,
+	0x26, 0x44, 0x3E, 0x44, 0x07, 0x69, 0x6F, 0xB1, 0xD0, 0xE9, 0x14, 0x7C,
+	0x57, 0xEA, 0x0C, 0x07,
+	0x0A, 0xD0, 0xFF, 0x27, 0xB3, 0x42, 0x13, 0xD2, 0xF3, 0x1A, 0x2B, 0x44,
+	0xFF, 0x2B, 0x07, 0xD8,
+	0x13, 0x70, 0x0B, 0xE0, 0x14, 0x70, 0x09, 0xE0, 0x15, 0x70, 0x0D, 0x70,
+	0xBD, 0xE8, 0xF0, 0x87,
+	0x17, 0x70, 0xC2, 0x69, 0x42, 0xF4, 0x00, 0x72, 0xCA, 0xF8, 0x1C, 0x20,
+	0x0C, 0x70, 0xF5, 0xE7,
+	0x9E, 0x42, 0x0D, 0xD2, 0x9B, 0x1B, 0x23, 0x44, 0xFF, 0x2B, 0x01, 0xD8,
+	0x0B, 0x70, 0x05, 0xE0,
+	0x0F, 0x70, 0xC1, 0x69, 0x41, 0xF4, 0x00, 0x71, 0xCA, 0xF8, 0x1C, 0x10,
+	0x15, 0x70, 0xE5, 0xE7,
+	0x15, 0x70, 0xEB, 0xE7, 0x2D, 0xE9, 0xF0, 0x41, 0x1F, 0x46, 0x0D, 0x46,
+	0x00, 0x2A, 0x34, 0xDD,
+	0x09, 0x4C, 0x77, 0xB1, 0xB4, 0xF9, 0x0A, 0x60, 0x11, 0x46, 0x0F, 0xF0,
+	0xD6, 0xFF, 0xB0, 0x42,
+	0x28, 0x78, 0x27, 0xDA, 0xFF, 0x28, 0x1C, 0xD2, 0x40, 0x1C, 0x28, 0x70,
+	0x00, 0x20, 0xBD, 0xE8,
+	0xF0, 0x81, 0x13, 0xE0, 0xB4, 0x10, 0x10, 0x00, 0xC0, 0x04, 0x10, 0x00,
+	0xF1, 0x3E, 0x00, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x50, 0x07, 0x10, 0x00, 0x0C, 0xA0, 0x01, 0x20,
+	0x9C, 0x4B, 0x01, 0x20,
+	0xF0, 0x4B, 0x01, 0x20, 0x88, 0x4C, 0x01, 0x20, 0xD4, 0x56, 0x10, 0x00,
+	0xB4, 0xF9, 0x08, 0x60,
+	0xDA, 0xE7, 0xE0, 0x69, 0x1F, 0xB1, 0x40, 0xF0, 0x02, 0x00, 0xE0, 0x61,
+	0x05, 0xE0, 0x40, 0xF4,
+	0x00, 0x60, 0xFA, 0xE7, 0x08, 0xB1, 0x40, 0x1E, 0x28, 0x70, 0x01, 0x20,
+	0xD7, 0xE7, 0x2D, 0xE9,
+	0xF0, 0x41, 0x1E, 0x46, 0x0D, 0x46, 0x00, 0x2A, 0x1A, 0xDD, 0xFE, 0x4C,
+	0x66, 0xB1, 0xB4, 0xF9,
+	0x0A, 0x70, 0x11, 0x46, 0x0F, 0xF0, 0x99, 0xFF, 0xB8, 0x42, 0x11, 0xDD,
+	0x28, 0x78, 0x50, 0xB1,
+	0x10, 0x28, 0x04, 0xD3, 0x10, 0x38, 0x03, 0xE0, 0xB4, 0xF9, 0x08, 0x70,
+	0xF1, 0xE7, 0x00, 0x20,
+	0x28, 0x70, 0x00, 0x20, 0xBB, 0xE7, 0xE0, 0x69, 0x26, 0xB1, 0x40, 0xF0,
+	0x01, 0x00, 0xE0, 0x61,
+	0x01, 0x20, 0xB4, 0xE7, 0x40, 0xF4, 0x80, 0x60, 0xF9, 0xE7, 0x2D, 0xE9,
+	0xF1, 0x4F, 0x82, 0xB0,
+	0x00, 0x25, 0xEC, 0x48, 0x02, 0x9A, 0x2C, 0x46, 0xFF, 0x21, 0x02, 0xB3,
+	0xD0, 0xF8, 0x30, 0x90,
+	0x02, 0x26, 0x4F, 0xF0, 0x18, 0x0B, 0x89, 0xF8, 0x00, 0x10, 0xD0, 0xF8,
+	0x34, 0x80, 0x88, 0xF8,
+	0x00, 0x10, 0xB0, 0xF9, 0x0A, 0x70, 0x31, 0x46, 0x00, 0x91, 0x41, 0x69,
+	0x00, 0x29, 0x00, 0xDC,
+	0x01, 0x25, 0xE0, 0x48, 0x80, 0x69, 0x00, 0x28, 0x00, 0xDC, 0x01, 0x24,
+	0xFF, 0xF7, 0x06, 0xFF,
+	0xFF, 0xF7, 0xA2, 0xFD, 0x00, 0x98, 0x00, 0xF0, 0xFD, 0xFC, 0x85, 0xB1,
+	0x21, 0xE0, 0xD0, 0xF8,
+	0x28, 0x90, 0x4F, 0xF4, 0x00, 0x66, 0x4F, 0xF0, 0x18, 0x0B, 0x89, 0xF8,
+	0x00, 0x10, 0xD0, 0xF8,
+	0x2C, 0x80, 0x88, 0xF8, 0x00, 0x10, 0xB0, 0xF9, 0x08, 0x70, 0x01, 0x21,
+	0xDC, 0xE7, 0xDF, 0xF8,
+	0x44, 0xA3, 0x3A, 0x46, 0xDA, 0xF8, 0x20, 0x00, 0xDA, 0xF8, 0x14, 0x10,
+	0x00, 0x68, 0x00, 0xF0,
+	0xF6, 0xFC, 0x01, 0x28, 0x05, 0xD1, 0xDA, 0xF8, 0x1C, 0x10, 0x31, 0x43,
+	0x01, 0x25, 0xCA, 0xF8,
+	0x1C, 0x10, 0x8C, 0xB9, 0xDF, 0xF8, 0x1C, 0xA3, 0x3A, 0x46, 0xDA, 0xF8,
+	0x24, 0x00, 0xDA, 0xF8,
+	0x18, 0x10, 0x00, 0x68, 0x00, 0xF0, 0xE3, 0xFC, 0x01, 0x28, 0x05, 0xD1,
+	0xDA, 0xF8, 0x1C, 0x10,
+	0x31, 0x43, 0x01, 0x24, 0xCA, 0xF8, 0x1C, 0x10, 0x0D, 0xB1, 0x00, 0x2C,
+	0x4E, 0xD1, 0x2F, 0x46,
+	0x26, 0x46, 0x4F, 0xF0, 0x17, 0x0A, 0x4F, 0xB9, 0xBA, 0x48, 0x02, 0x9B,
+	0x01, 0x6A, 0x42, 0x69,
+	0x0F, 0x68, 0x49, 0x46, 0x38, 0x46, 0xFF, 0xF7, 0x6A, 0xFF, 0x07, 0x46,
+	0x4E, 0xB9, 0xB5, 0x48,
+	0x02, 0x9B, 0x41, 0x6A, 0x82, 0x69, 0x0E, 0x68, 0x41, 0x46, 0x30, 0x46,
+	0xFF, 0xF7, 0x5F, 0xFF,
+	0x06, 0x46, 0xFF, 0xF7, 0xAB, 0xFE, 0xFF, 0xF7, 0x47, 0xFD, 0x00, 0x98,
+	0x00, 0xF0, 0xA2, 0xFC,
+	0x07, 0xB1, 0x16, 0xB9, 0xBA, 0xF1, 0x01, 0x0A, 0xDD, 0xD2, 0x2F, 0x46,
+	0xA9, 0x4D, 0xAB, 0xF1,
+	0x01, 0x06, 0x3F, 0xB9, 0x28, 0x6A, 0x02, 0x9B, 0x49, 0x46, 0x00, 0x68,
+	0x6A, 0x69, 0xFF, 0xF7,
+	0x09, 0xFF, 0x07, 0x46, 0x3C, 0xB9, 0x68, 0x6A, 0x02, 0x9B, 0x41, 0x46,
+	0x00, 0x68, 0xAA, 0x69,
+	0xFF, 0xF7, 0x00, 0xFF, 0x04, 0x46, 0xFF, 0xF7, 0x89, 0xFE, 0xFF, 0xF7,
+	0x25, 0xFD, 0x00, 0x98,
+	0x00, 0xF0, 0x80, 0xFC, 0x07, 0xB1, 0x0C, 0xB9, 0x76, 0x1E, 0xE2, 0xD2,
+	0x01, 0x2F, 0x05, 0xD1,
+	0x01, 0x2C, 0x03, 0xD1, 0xE8, 0x69, 0x20, 0xF4, 0x00, 0x70, 0xE8, 0x61,
+	0xBD, 0xE8, 0xFE, 0x8F,
+	0x2D, 0xE9, 0xF0, 0x4F, 0x9A, 0x46, 0x91, 0x46, 0x00, 0x22, 0x92, 0x4B,
+	0x83, 0x46, 0x14, 0x46,
+	0xB3, 0xF9, 0x0C, 0x70, 0x10, 0x46, 0x01, 0x23, 0x90, 0x46, 0x14, 0xE0,
+	0x09, 0xEB, 0xE4, 0x05,
+	0x04, 0xF0, 0x07, 0x0C, 0x2E, 0x78, 0x03, 0xFA, 0x0C, 0xF5, 0x35, 0x42,
+	0x0A, 0xD0, 0x3B, 0xF9,
+	0x12, 0x50, 0xBD, 0x42, 0x03, 0xDC, 0x0A, 0xF8, 0x02, 0x30, 0x01, 0x20,
+	0x01, 0xE0, 0x0A, 0xF8,
+	0x02, 0x80, 0x52, 0x1C, 0x64, 0x1C, 0x8A, 0x42, 0xE8, 0xDB, 0x32, 0xE6,
+	0x2D, 0xE9, 0xFF, 0x5F,
+	0x00, 0x24, 0x4F, 0xF0, 0x01, 0x08, 0x9A, 0x46, 0x17, 0x46, 0x25, 0x46,
+	0xDF, 0xF8, 0xF4, 0x91,
+	0x46, 0x46, 0xDD, 0xF8, 0x3C, 0xB0, 0x4E, 0xE0, 0x0A, 0xEB, 0xE5, 0x00,
+	0x05, 0xF0, 0x07, 0x01,
+	0x00, 0x78, 0x06, 0xFA, 0x01, 0xF2, 0x02, 0x42, 0x44, 0xD0, 0x1B, 0xF8,
+	0x04, 0x00, 0x01, 0x28,
+	0x3F, 0xD0, 0x00, 0x98, 0xB9, 0xF9, 0x0C, 0x10, 0x30, 0xF9, 0x14, 0x20,
+	0x8A, 0x42, 0x1D, 0xDA,
+	0x29, 0x46, 0x01, 0x98, 0xFC, 0xF7, 0x87, 0xFA, 0xFF, 0x28, 0x0E, 0xDA,
+	0x40, 0x1C, 0xC2, 0xB2,
+	0x4F, 0xF0, 0x00, 0x08, 0x29, 0x46, 0x01, 0x98, 0xFC, 0xF7, 0x7F, 0xFA,
+	0x00, 0x98, 0x30, 0xF8,
+	0x14, 0x10, 0x0E, 0x98, 0x20, 0xF8, 0x14, 0x10, 0x23, 0xE0, 0x0B, 0xF8,
+	0x04, 0x60, 0xD9, 0xF8,
+	0x1C, 0x10, 0x41, 0xF0, 0x08, 0x01, 0xC9, 0xF8, 0x1C, 0x10, 0x1A, 0xE0,
+	0x0E, 0x98, 0x30, 0xF9,
+	0x14, 0x00, 0x00, 0x28, 0x13, 0xDD, 0x40, 0x1A, 0xA2, 0xEB, 0x01, 0x01,
+	0x00, 0xD5, 0x40, 0x42,
+	0x00, 0x29, 0x00, 0xDA, 0x49, 0x42, 0x88, 0x42, 0x09, 0xDC, 0x29, 0x46,
+	0x01, 0x98, 0xFC, 0xF7,
+	0x5A, 0xFA, 0x40, 0x1E, 0xC2, 0xB2, 0x29, 0x46, 0x01, 0x98, 0xFC, 0xF7,
+	0x56, 0xFA, 0x0B, 0xF8,
+	0x04, 0x60, 0x64, 0x1C, 0x6D, 0x1C, 0xBC, 0x42, 0xAE, 0xDB, 0x40, 0x46,
+	0x04, 0xB0, 0xBD, 0xE8,
+	0xF0, 0x9F, 0x2D, 0xE9, 0xFF, 0x5F, 0x00, 0x24, 0x4F, 0xF0, 0x01, 0x08,
+	0x9A, 0x46, 0x17, 0x46,
+	0x25, 0x46, 0x46, 0x46, 0xDF, 0xF8, 0x2C, 0x91, 0xDD, 0xF8, 0x38, 0xB0,
+	0x31, 0xE0, 0x00, 0xBF,
+	0x0A, 0xEB, 0xE5, 0x00, 0x05, 0xF0, 0x07, 0x02, 0x01, 0x78, 0x06, 0xFA,
+	0x02, 0xF0, 0x08, 0x42,
+	0x26, 0xD0, 0x1B, 0xF8, 0x04, 0x00, 0x01, 0x28, 0x21, 0xD0, 0x00, 0x98,
+	0x30, 0xF9, 0x14, 0x10,
+	0xB9, 0xF9, 0x0C, 0x00, 0x81, 0x42, 0x1A, 0xDD, 0x29, 0x46, 0x01, 0x98,
+	0xFC, 0xF7, 0x23, 0xFA,
+	0x00, 0x28, 0x0C, 0xDD, 0x4F, 0xF0, 0x00, 0x08, 0x04, 0x28, 0x01, 0xDB,
+	0x00, 0x1F, 0x00, 0xE0,
+	0x00, 0x20, 0xC2, 0xB2, 0x29, 0x46, 0x01, 0x98, 0xFC, 0xF7, 0x17, 0xFA,
+	0x07, 0xE0, 0x0B, 0xF8,
+	0x04, 0x60, 0xD9, 0xF8, 0x1C, 0x10, 0x41, 0xF0, 0x04, 0x01, 0xC9, 0xF8,
+	0x1C, 0x10, 0x64, 0x1C,
+	0x6D, 0x1C, 0xBC, 0x42, 0xCC, 0xDB, 0x40, 0x46, 0xB8, 0xE7, 0x2D, 0xE9,
+	0xF0, 0x4F, 0x93, 0xB0,
+	0x00, 0x24, 0x25, 0x46, 0x18, 0x21, 0x0C, 0xA8, 0x12, 0xF0, 0xE0, 0xFD,
+	0x28, 0x21, 0x02, 0xA8,
+	0x12, 0xF0, 0xDC, 0xFD, 0x27, 0x48, 0x41, 0x69, 0x00, 0x29, 0x00, 0xDC,
+	0x01, 0x24, 0x82, 0x69,
+	0x00, 0x2A, 0x00, 0xDC, 0x01, 0x25, 0x23, 0x4A, 0x81, 0x46, 0x06, 0x46,
+	0xFF, 0x23, 0x10, 0x32,
+	0x80, 0x6B, 0x00, 0xF0, 0xA6, 0xFB, 0x1F, 0x4A, 0xFF, 0x23, 0x50, 0x32,
+	0xB1, 0x69, 0xF0, 0x6B,
+	0x00, 0xF0, 0x9F, 0xFB, 0xFF, 0xF7, 0x82, 0xFD, 0xFF, 0xF7, 0x1E, 0xFC,
+	0x04, 0x20, 0x00, 0xF0,
+	0x79, 0xFB, 0x8C, 0xB1, 0xD9, 0xF8, 0x20, 0x00, 0x16, 0x4A, 0x4E, 0x46,
+	0x00, 0x68, 0x0C, 0xAB,
+	0x10, 0x32, 0xD9, 0xF8, 0x14, 0x10, 0xFF, 0xF7, 0xFB, 0xFE, 0x01, 0x28,
+	0x04, 0xD1, 0xF0, 0x69,
+	0x01, 0x24, 0x40, 0xF0, 0x08, 0x00, 0xF0, 0x61, 0x8D, 0xB1, 0xD9, 0xF8,
+	0x24, 0x00, 0x0D, 0x4A,
+	0x4E, 0x46, 0x00, 0x68, 0x02, 0xAB, 0x50, 0x32, 0xD9, 0xF8, 0x18, 0x10,
+	0xFF, 0xF7, 0xE8, 0xFE,
+	0x01, 0x28, 0x04, 0xD1, 0xF0, 0x69, 0x01, 0x25, 0x40, 0xF0, 0x08, 0x00,
+	0xF0, 0x61, 0x0C, 0xB1,
+	0x00, 0x2D, 0x7A, 0xD1, 0x26, 0x46, 0xA8, 0x46, 0x00, 0x27, 0x0D, 0xF1,
+	0x30, 0x0B, 0x86, 0xB9,
+	0x02, 0xE0, 0x00, 0x00, 0xC0, 0x04, 0x10, 0x00, 0xCD, 0xF8, 0x00, 0xB0,
+	0xD9, 0xF8, 0x20, 0x00,
+	0xFE, 0x4B, 0xD9, 0xF8, 0x14, 0x20, 0x00, 0x68, 0xD9, 0xF8, 0x38, 0x10,
+	0xFF, 0xF7, 0x51, 0xFF,
+	0x06, 0x46, 0xB8, 0xF1, 0x00, 0x0F, 0x0D, 0xD1, 0x02, 0xA8, 0x00, 0x90,
+	0xD9, 0xF8, 0x24, 0x10,
+	0xF6, 0x4B, 0xD9, 0xF8, 0x18, 0x20, 0x08, 0x68, 0x40, 0x33, 0xD9, 0xF8,
+	0x3C, 0x10, 0xFF, 0xF7,
+	0x40, 0xFF, 0x80, 0x46, 0xFF, 0xF7, 0x2A, 0xFD, 0xFF, 0xF7, 0xC6, 0xFB,
+	0x04, 0x20, 0x00, 0xF0,
+	0x21, 0xFB, 0x16, 0xB1, 0xB8, 0xF1, 0x00, 0x0F, 0x02, 0xD1, 0x7F, 0x1C,
+	0x60, 0x2F, 0xCE, 0xDB,
+	0xDF, 0xF8, 0xAC, 0xA3, 0xD9, 0xF8, 0x14, 0x00, 0x26, 0x46, 0x41, 0x00,
+	0x0A, 0xF5, 0xE6, 0x68,
+	0x4C, 0x46, 0x50, 0x46, 0x12, 0xF0, 0x30, 0xFD, 0xA0, 0x69, 0x41, 0x00,
+	0x40, 0x46, 0x12, 0xF0,
+	0x2B, 0xFD, 0x00, 0x27, 0xFF, 0xF7, 0xA8, 0xFB, 0x04, 0x20, 0x00, 0xF0,
+	0x03, 0xFB, 0x4E, 0xB9,
+	0xCD, 0xE9, 0x00, 0xAB, 0x20, 0x6A, 0xDD, 0x4B, 0x62, 0x69, 0x00, 0x68,
+	0xA1, 0x6B, 0xFF, 0xF7,
+	0xAD, 0xFE, 0x06, 0x46, 0x5D, 0xB9, 0x02, 0xA8, 0xCD, 0xE9, 0x00, 0x80,
+	0x60, 0x6A, 0xD7, 0x4B,
+	0xA2, 0x69, 0x00, 0x68, 0x40, 0x33, 0xE1, 0x6B, 0xFF, 0xF7, 0xA0, 0xFE,
+	0x05, 0x46, 0xFF, 0xF7,
+	0xED, 0xFC, 0xFF, 0xF7, 0x89, 0xFB, 0x04, 0x20, 0x00, 0xF0, 0xE4, 0xFA,
+	0x06, 0xB1, 0x15, 0xB9,
+	0x7F, 0x1C, 0x60, 0x2F, 0xD6, 0xDB, 0x01, 0x2E, 0x07, 0xD1, 0x01, 0x2D,
+	0x05, 0xD1, 0xE0, 0x69,
+	0x81, 0x05, 0x02, 0xD5, 0x20, 0xF4, 0x00, 0x70, 0xE0, 0x61, 0x13, 0xB0,
+	0xB9, 0xE4, 0x2D, 0xE9,
+	0xF0, 0x41, 0x0F, 0x46, 0xC5, 0x49, 0x16, 0x46, 0x02, 0x46, 0x10, 0x39,
+	0xDD, 0xE9, 0x06, 0x05,
+	0xB1, 0xF9, 0x0E, 0xC0, 0x01, 0x24, 0x62, 0x45, 0x11, 0xDD, 0x1D, 0x68,
+	0xA0, 0xF1, 0x7F, 0x02,
+	0x95, 0x42, 0x07, 0xDD, 0x2A, 0x1A, 0x31, 0x46, 0x38, 0x46, 0x1A, 0x60,
+	0xFC, 0xF7, 0xF4, 0xF8,
+	0x00, 0x24, 0x11, 0xE0, 0xC8, 0x69, 0x40, 0xF0, 0x40, 0x00, 0xC8, 0x61,
+	0x0C, 0xE0, 0x01, 0x21,
+	0x29, 0x70, 0x19, 0x68, 0xC0, 0xF1, 0x7F, 0x02, 0x91, 0x42, 0x05, 0xDA,
+	0x0A, 0x18, 0x31, 0x46,
+	0x38, 0x46, 0x1A, 0x60, 0xFC, 0xF7, 0xE0, 0xF8, 0x20, 0x46, 0x30, 0xE5,
+	0x2D, 0xE9, 0xFF, 0x4F,
+	0x00, 0x24, 0x85, 0xB0, 0x91, 0x46, 0x06, 0x46, 0x25, 0x46, 0xA2, 0x46,
+	0x78, 0xE0, 0x08, 0x98,
+	0x05, 0xF0, 0x07, 0x03, 0x00, 0xEB, 0xE5, 0x00, 0x7F, 0x22, 0x01, 0x78,
+	0x01, 0x20, 0x98, 0x40,
+	0x08, 0x42, 0x03, 0x92, 0x6B, 0xD0, 0x29, 0x46, 0x06, 0x98, 0xFC, 0xF7,
+	0xC5, 0xF8, 0x00, 0x20,
+	0x8D, 0xF8, 0x08, 0x00, 0x80, 0x46, 0x4F, 0xF0, 0x10, 0x0B, 0x00, 0xBF,
+	0xFF, 0xF7, 0x24, 0xFB,
+	0x08, 0x20, 0x00, 0xF0, 0x7F, 0xFA, 0x02, 0xAF, 0xCD, 0xE9, 0x00, 0xB7,
+	0x36, 0xF9, 0x14, 0x00,
+	0x03, 0xAB, 0x2A, 0x46, 0x06, 0x99, 0xFF, 0xF7, 0xA2, 0xFF, 0x20, 0xB9,
+	0x08, 0xF1, 0x01, 0x08,
+	0xB8, 0xF1, 0x18, 0x0F, 0xEA, 0xDB, 0x9D, 0xF8, 0x08, 0x00, 0xE0, 0xB3,
+	0x00, 0x20, 0x8D, 0xF8,
+	0x08, 0x00, 0x80, 0x46, 0x4F, 0xF0, 0x04, 0x0B, 0xFF, 0xF7, 0x06, 0xFB,
+	0x08, 0x20, 0x00, 0xF0,
+	0x61, 0xFA, 0xCD, 0xE9, 0x00, 0xB7, 0x36, 0xF9, 0x14, 0x00, 0x03, 0xAB,
+	0x2A, 0x46, 0x06, 0x99,
+	0xFF, 0xF7, 0x85, 0xFF, 0x20, 0xB9, 0x08, 0xF1, 0x01, 0x08, 0xB8, 0xF1,
+	0x18, 0x0F, 0xEB, 0xDB,
+	0x9D, 0xF8, 0x08, 0x00, 0xF8, 0xB1, 0x00, 0x20, 0x8D, 0xF8, 0x08, 0x00,
+	0x80, 0x46, 0x4F, 0xF0,
+	0x01, 0x0B, 0x00, 0xBF, 0xFF, 0xF7, 0xE8, 0xFA, 0x08, 0x20, 0x00, 0xF0,
+	0x43, 0xFA, 0xCD, 0xE9,
+	0x00, 0xB7, 0x36, 0xF9, 0x14, 0x00, 0x03, 0xAB, 0x2A, 0x46, 0x06, 0x99,
+	0xFF, 0xF7, 0x67, 0xFF,
+	0x78, 0xB1, 0x9D, 0xF8, 0x08, 0x00, 0x01, 0x28, 0x10, 0xD0, 0x03, 0x9A,
+	0x29, 0x46, 0x52, 0x1E,
+	0x03, 0x92, 0x06, 0x98, 0x00, 0xE0, 0x09, 0xE0, 0xFC, 0xF7, 0x66, 0xF8,
+	0x0A, 0xF1, 0x01, 0x0A,
+	0x04, 0xE0, 0x08, 0xF1, 0x01, 0x08, 0xB8, 0xF1, 0x18, 0x0F, 0xDB, 0xDB,
+	0x64, 0x1C, 0x6D, 0x1C,
+	0x4C, 0x45, 0x84, 0xDB, 0xCA, 0x45, 0x02, 0xD0, 0x00, 0x20, 0x09, 0xB0,
+	0xCD, 0xE5, 0x01, 0x20,
+	0xFB, 0xE7, 0x70, 0xB5, 0x69, 0x4C, 0x01, 0x25, 0x10, 0x3C, 0xA2, 0x69,
+	0x00, 0x2A, 0x08, 0xDD,
+	0x60, 0x6A, 0x04, 0xF1, 0x50, 0x03, 0x61, 0x6C, 0x00, 0x68, 0xFF, 0xF7,
+	0x67, 0xFF, 0x00, 0xF0,
+	0x01, 0x05, 0x62, 0x69, 0x00, 0x2A, 0x06, 0xDD, 0x20, 0x6A, 0x60, 0x4B,
+	0x21, 0x6C, 0x00, 0x68,
+	0xFF, 0xF7, 0x5C, 0xFF, 0x05, 0x40, 0x28, 0x46, 0x70, 0xBD, 0x70, 0xB5,
+	0x5B, 0x4C, 0x00, 0x26,
+	0x10, 0x3C, 0x05, 0x46, 0xE6, 0x61, 0x01, 0x28, 0x5B, 0xD0, 0x02, 0x2D,
+	0x5B, 0xD0, 0x01, 0x20,
+	0x20, 0x70, 0x60, 0x79, 0x60, 0xB1, 0x00, 0x23, 0x54, 0x4A, 0x61, 0x69,
+	0xA0, 0x6B, 0x00, 0xF0,
+	0x08, 0xFA, 0x52, 0x4A, 0x00, 0x23, 0x40, 0x32, 0xA1, 0x69, 0xE0, 0x6B,
+	0x00, 0xF0, 0x01, 0xFA,
+	0xA0, 0x79, 0x50, 0xB1, 0x4D, 0x49, 0x62, 0x69, 0x20, 0x6C, 0xFC, 0xF7,
+	0x20, 0xF8, 0x4B, 0x49,
+	0xA2, 0x69, 0x40, 0x31, 0x60, 0x6C, 0xFC, 0xF7, 0x1A, 0xF8, 0xE0, 0x78,
+	0x10, 0xB1, 0x00, 0x20,
+	0xFF, 0xF7, 0xAB, 0xFC, 0x20, 0x79, 0x60, 0xB1, 0xE0, 0x78, 0x38, 0xB1,
+	0x61, 0x78, 0xA0, 0x6A,
+	0x00, 0xF0, 0xD5, 0xF9, 0x61, 0x78, 0xE0, 0x6A, 0x00, 0xF0, 0xD1, 0xF9,
+	0x01, 0x20, 0xFF, 0xF7,
+	0x9C, 0xFC, 0x60, 0x79, 0x08, 0xB1, 0xFF, 0xF7, 0x18, 0xFE, 0x01, 0x2D,
+	0x25, 0xD0, 0x02, 0x2D,
+	0x25, 0xD0, 0x26, 0x70, 0xFF, 0xF7, 0x58, 0xFA, 0xA0, 0x79, 0x60, 0xB1,
+	0x20, 0x79, 0x38, 0xB1,
+	0xA1, 0x78, 0x20, 0x6B, 0x00, 0xF0, 0xBB, 0xF9, 0xA1, 0x78, 0x60, 0x6B,
+	0x00, 0xF0, 0xB7, 0xF9,
+	0xE0, 0x79, 0xFF, 0xF7, 0x8E, 0xFF, 0xFF, 0xF7, 0x47, 0xFA, 0x01, 0x2D,
+	0x12, 0xD0, 0x02, 0x2D,
+	0x12, 0xD0, 0x10, 0x21, 0xE0, 0x69, 0x00, 0xF0, 0xD1, 0xF9, 0xE0, 0x69,
+	0x78, 0xB1, 0x00, 0x20,
+	0x70, 0xBD, 0x03, 0x20, 0xA4, 0xE7, 0x05, 0x20, 0xA2, 0xE7, 0x02, 0x20,
+	0x00, 0xE0, 0x04, 0x20,
+	0x20, 0x70, 0xD7, 0xE7, 0x40, 0x21, 0xED, 0xE7, 0x4F, 0xF4, 0x00, 0x71,
+	0xEA, 0xE7, 0x01, 0x20,
+	0x70, 0xBD, 0x70, 0xB5, 0x21, 0x4D, 0x0C, 0x46, 0x10, 0x3D, 0x02, 0x28,
+	0x26, 0xD0, 0x11, 0xF0,
+	0xE6, 0xFF, 0x28, 0x61, 0x11, 0xF0, 0xE5, 0xFF, 0xC5, 0xE9, 0x14, 0x01,
+	0x04, 0x21, 0x1B, 0x48,
+	0xFC, 0xF7, 0x71, 0xFB, 0x68, 0x61, 0x19, 0x48, 0x08, 0x21, 0x40, 0x30,
+	0xFC, 0xF7, 0x6B, 0xFB,
+	0xA8, 0x61, 0x04, 0xF1, 0x90, 0x00, 0xA8, 0x62, 0x40, 0x1C, 0xE8, 0x62,
+	0x40, 0x1C, 0x28, 0x63,
+	0x40, 0x1C, 0x68, 0x63, 0x4B, 0x38, 0xA8, 0x63, 0x20, 0x30, 0xC5, 0xE9,
+	0x0F, 0x04, 0x48, 0x38,
+	0x68, 0x64, 0x74, 0x30, 0x95, 0x34, 0xC5, 0xE9, 0x12, 0x04, 0x70, 0xBD,
+	0x11, 0xF0, 0xC7, 0xFF,
+	0x28, 0x61, 0x11, 0xF0, 0xC6, 0xFF, 0xD7, 0xE7, 0x10, 0xB5, 0x0A, 0x49,
+	0x00, 0x20, 0xFF, 0xF7,
+	0xC8, 0xFF, 0x06, 0x48, 0x08, 0x49, 0x10, 0x38, 0x08, 0x4A, 0x01, 0x62,
+	0x09, 0x1D, 0x41, 0x62,
+	0x13, 0x68, 0x93, 0xF8, 0x88, 0x11, 0x11, 0xF0, 0x01, 0x04, 0x09, 0xE0,
+	0xD0, 0x04, 0x10, 0x00,
+	0xD4, 0x56, 0x10, 0x00, 0x38, 0x99, 0x01, 0x20, 0xCC, 0x10, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0xC4, 0x70, 0x4F, 0xF0, 0x00, 0x01, 0x04, 0xD0, 0x83, 0x6A, 0x19, 0x70,
+	0xC3, 0x6A, 0x19, 0x70,
+	0x08, 0xE0, 0x84, 0x6A, 0x93, 0xF8, 0x92, 0x31, 0x23, 0x70, 0x13, 0x68,
+	0xC4, 0x6A, 0x93, 0xF8,
+	0x93, 0x31, 0x23, 0x70, 0x13, 0x68, 0x93, 0xF8, 0x88, 0x41, 0xC4, 0xF3,
+	0x40, 0x04, 0x04, 0x71,
+	0x14, 0xB1, 0x03, 0x6B, 0x19, 0x70, 0x06, 0xE0, 0x93, 0xF8, 0x94, 0x11,
+	0x03, 0x6B, 0x19, 0x70,
+	0x11, 0x68, 0x91, 0xF8, 0x95, 0x11, 0x43, 0x6B, 0x19, 0x70, 0x11, 0x68,
+	0x91, 0xF8, 0x88, 0x21,
+	0xC2, 0xF3, 0x80, 0x03, 0x43, 0x71, 0xC2, 0xF3, 0xC0, 0x02, 0x82, 0x71,
+	0xB1, 0xF8, 0x8A, 0x21,
+	0x02, 0x81, 0xB1, 0xF8, 0x8C, 0x21, 0x42, 0x81, 0xB1, 0xF8, 0x8E, 0x21,
+	0x82, 0x81, 0xB1, 0xF8,
+	0x90, 0x21, 0xC2, 0x81, 0x91, 0xF8, 0x96, 0x21, 0x42, 0x70, 0x91, 0xF8,
+	0x97, 0x21, 0x82, 0x70,
+	0x91, 0xF8, 0x34, 0x11, 0xC1, 0xF3, 0x40, 0x01, 0xC1, 0x71, 0xBD, 0xE8,
+	0x10, 0x40, 0x00, 0x20,
+	0xF3, 0xE6, 0x10, 0xB5, 0xAC, 0x49, 0x01, 0x20, 0xFF, 0xF7, 0x63, 0xFF,
+	0xAC, 0x48, 0xAB, 0x49,
+	0x01, 0x62, 0x00, 0x21, 0xC0, 0xE9, 0x14, 0x11, 0x0A, 0x46, 0x81, 0x61,
+	0xA9, 0x49, 0x0B, 0x68,
+	0x93, 0xF8, 0xA0, 0x41, 0x14, 0xF0, 0x01, 0x04, 0xC4, 0x70, 0x04, 0xD0,
+	0x83, 0x6A, 0x1A, 0x70,
+	0xC3, 0x6A, 0x1A, 0x70, 0x08, 0xE0, 0x84, 0x6A, 0x93, 0xF8, 0xAA, 0x31,
+	0x23, 0x70, 0x0B, 0x68,
+	0xC4, 0x6A, 0x93, 0xF8, 0xAB, 0x31, 0x23, 0x70, 0x0B, 0x68, 0x93, 0xF8,
+	0xA0, 0x41, 0xC4, 0xF3,
+	0x40, 0x04, 0x04, 0x71, 0x14, 0xB1, 0x03, 0x6B, 0x1A, 0x70, 0x06, 0xE0,
+	0x93, 0xF8, 0xAC, 0x21,
+	0x03, 0x6B, 0x1A, 0x70, 0x0A, 0x68, 0x92, 0xF8, 0xAD, 0x21, 0x43, 0x6B,
+	0x1A, 0x70, 0x09, 0x68,
+	0x91, 0xF8, 0xA0, 0x21, 0xC2, 0xF3, 0x80, 0x03, 0x43, 0x71, 0xC2, 0xF3,
+	0xC0, 0x02, 0x82, 0x71,
+	0xB1, 0xF8, 0xA2, 0x21, 0x02, 0x81, 0xB1, 0xF8, 0xA4, 0x21, 0x42, 0x81,
+	0xB1, 0xF8, 0xA6, 0x21,
+	0x82, 0x81, 0xB1, 0xF8, 0xA8, 0x21, 0xC2, 0x81, 0x91, 0xF8, 0xAE, 0x21,
+	0x42, 0x70, 0x91, 0xF8,
+	0xAF, 0x21, 0x82, 0x70, 0x91, 0xF8, 0x84, 0x19, 0xC1, 0xF3, 0x40, 0x01,
+	0xC1, 0x71, 0xBD, 0xE8,
+	0x10, 0x40, 0x01, 0x20, 0x99, 0xE6, 0x80, 0x49, 0x10, 0xB5, 0x98, 0x31,
+	0x02, 0x20, 0xFF, 0xF7,
+	0x08, 0xFF, 0x7E, 0x49, 0x7E, 0x48, 0x09, 0x1D, 0x01, 0x62, 0x7E, 0x49,
+	0x0B, 0x68, 0x93, 0xF8,
+	0xB0, 0x21, 0x12, 0xF0, 0x01, 0x04, 0xC4, 0x70, 0x4F, 0xF0, 0x00, 0x02,
+	0x04, 0xD0, 0x83, 0x6A,
+	0x1A, 0x70, 0xC3, 0x6A, 0x1A, 0x70, 0x08, 0xE0, 0x84, 0x6A, 0x93, 0xF8,
+	0xBA, 0x31, 0x23, 0x70,
+	0x0B, 0x68, 0xC4, 0x6A, 0x93, 0xF8, 0xBB, 0x31, 0x23, 0x70, 0x0C, 0x68,
+	0x94, 0xF8, 0xB0, 0x31,
+	0xC3, 0xF3, 0x40, 0x03, 0x03, 0x71, 0x13, 0xB1, 0x03, 0x6B, 0x1A, 0x70,
+	0x06, 0xE0, 0x03, 0x6B,
+	0x94, 0xF8, 0xBC, 0x21, 0x1A, 0x70, 0x0A, 0x68, 0x92, 0xF8, 0xBD, 0x21,
+	0x43, 0x6B, 0x1A, 0x70,
+	0x09, 0x68, 0x91, 0xF8, 0xB0, 0x21, 0xC2, 0xF3, 0x80, 0x03, 0x43, 0x71,
+	0xC2, 0xF3, 0xC0, 0x02,
+	0x82, 0x71, 0xB1, 0xF8, 0xB2, 0x21, 0x02, 0x81, 0xB1, 0xF8, 0xB4, 0x21,
+	0x42, 0x81, 0xB1, 0xF8,
+	0xB6, 0x21, 0x82, 0x81, 0xB1, 0xF8, 0xB8, 0x21, 0xC2, 0x81, 0x91, 0xF8,
+	0xBE, 0x21, 0x42, 0x70,
+	0x91, 0xF8, 0xBF, 0x11, 0x81, 0x70, 0x01, 0x21, 0xC1, 0x71, 0xBD, 0xE8,
+	0x10, 0x40, 0x02, 0x20,
+	0x43, 0xE6, 0x2D, 0xE9, 0xF0, 0x41, 0x07, 0x46, 0x01, 0x24, 0x00, 0x20,
+	0xFB, 0xF7, 0xC9, 0xFC,
+	0x02, 0x20, 0xFB, 0xF7, 0xC6, 0xFC, 0x54, 0x49, 0x01, 0x20, 0x08, 0x70,
+	0x53, 0x4E, 0x78, 0x07,
+	0x4F, 0xF0, 0x00, 0x05, 0x4F, 0xF0, 0xA5, 0x08, 0x0A, 0xD5, 0xFF, 0xF7,
+	0xD5, 0xFE, 0x10, 0xF0,
+	0x01, 0x04, 0x05, 0xD0, 0x30, 0x68, 0xC5, 0x77, 0x80, 0xF8, 0x20, 0x50,
+	0x80, 0xF8, 0x1E, 0x80,
+	0x38, 0x07, 0x0A, 0xD5, 0xFF, 0xF7, 0x2D, 0xFF, 0x20, 0x40, 0x04, 0x00,
+	0x05, 0xD0, 0x30, 0x68,
+	0x00, 0xF8, 0x22, 0x5F, 0x45, 0x70, 0x00, 0xF8, 0x01, 0x8C, 0x38, 0x06,
+	0x0A, 0xD5, 0xFF, 0xF7,
+	0x7A, 0xFF, 0x20, 0x40, 0x04, 0x00, 0x05, 0xD0, 0x30, 0x68, 0x00, 0xF8,
+	0x27, 0x5F, 0x45, 0x70,
+	0x00, 0xF8, 0x01, 0x8C, 0x02, 0x20, 0xFB, 0xF7, 0xAF, 0xFC, 0x00, 0x20,
+	0xFB, 0xF7, 0xAC, 0xFC,
+	0x20, 0x46, 0x5A, 0xE5, 0x3A, 0x49, 0x4A, 0x78, 0x02, 0x42, 0x07, 0xD0,
+	0x08, 0x78, 0xAA, 0x28,
+	0x04, 0xD1, 0x08, 0x78, 0xAA, 0x28, 0xFC, 0xD0, 0xAA, 0x20, 0x08, 0x70,
+	0x70, 0x47, 0x02, 0x78,
+	0x8A, 0x42, 0x01, 0xD9, 0x51, 0x1A, 0x00, 0xE0, 0x00, 0x21, 0x01, 0x70,
+	0x70, 0x47, 0x10, 0xB5,
+	0x14, 0x46, 0x0F, 0xF0, 0x42, 0xFA, 0xA0, 0x42, 0x01, 0xDC, 0x01, 0x20,
+	0x10, 0xBD, 0x00, 0x20,
+	0x10, 0xBD, 0xF0, 0xB5, 0x00, 0x25, 0x2C, 0x46, 0x01, 0x26, 0x0C, 0xE0,
+	0x02, 0xEB, 0xE4, 0x07,
+	0x04, 0xF0, 0x07, 0x0C, 0x3F, 0x78, 0x06, 0xFA, 0x0C, 0xFE, 0x1E, 0xEA,
+	0x07, 0x0F, 0x01, 0xD0,
+	0x03, 0x55, 0x6D, 0x1C, 0x64, 0x1C, 0x8D, 0x42, 0xF0, 0xDB, 0xF0, 0xBD,
+	0x70, 0xB5, 0x04, 0x46,
+	0x0D, 0x46, 0xC0, 0x07, 0x02, 0xD0, 0x83, 0x20, 0x0D, 0xF0, 0x78, 0xFB,
+	0xA0, 0x07, 0x03, 0xD5,
+	0x29, 0x46, 0x84, 0x20, 0x0D, 0xF0, 0x72, 0xFB, 0x60, 0x07, 0x03, 0xD5,
+	0x29, 0x46, 0x85, 0x20,
+	0x0D, 0xF0, 0x6C, 0xFB, 0x20, 0x07, 0x03, 0xD5, 0x29, 0x46, 0x86, 0x20,
+	0x0D, 0xF0, 0x66, 0xFB,
+	0x60, 0x06, 0x03, 0xD5, 0x29, 0x46, 0x8B, 0x20, 0x0D, 0xF0, 0x60, 0xFB,
+	0x20, 0x06, 0x03, 0xD5,
+	0x29, 0x46, 0x8C, 0x20, 0x0D, 0xF0, 0x5A, 0xFB, 0xE0, 0x05, 0x03, 0xD5,
+	0x29, 0x46, 0x87, 0x20,
+	0x0D, 0xF0, 0x54, 0xFB, 0xA0, 0x05, 0x05, 0xD5, 0x29, 0x46, 0xBD, 0xE8,
+	0x70, 0x40, 0x88, 0x20,
+	0x0D, 0xF0, 0x4C, 0xBB, 0x70, 0xBD, 0x00, 0x00, 0xD0, 0x99, 0x01, 0x20,
+	0xDC, 0x10, 0x10, 0x00,
+	0xC0, 0x04, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00, 0x78, 0x07, 0x10, 0x00,
+	0x50, 0x07, 0x10, 0x00,
+	0x08, 0x00, 0x00, 0x20, 0x08, 0xB5, 0x4E, 0x4E, 0x4E, 0x4D, 0x00, 0x24,
+	0x00, 0x22, 0x6B, 0x46,
+	0x31, 0x46, 0x10, 0x46, 0xFB, 0xF7, 0x76, 0xFB, 0x00, 0x98, 0x81, 0x07,
+	0x32, 0xD5, 0xFB, 0xF7,
+	0xE7, 0xF9, 0x49, 0x48, 0x07, 0x68, 0x04, 0x60, 0xFB, 0xF7, 0xE0, 0xF9,
+	0x17, 0xF0, 0x53, 0x0F,
+	0x02, 0xD0, 0x38, 0x46, 0xFE, 0xF7, 0xB2, 0xFE, 0x17, 0xF4, 0xD6, 0x7F,
+	0x02, 0xD0, 0x38, 0x46,
+	0xFF, 0xF7, 0x27, 0xFF, 0xB8, 0x05, 0x13, 0xD5, 0x28, 0x68, 0x90, 0xF8,
+	0x70, 0x01, 0x80, 0x07,
+	0x02, 0xD5, 0x01, 0x20, 0xFE, 0xF7, 0xEF, 0xFD, 0x28, 0x68, 0x90, 0xF8,
+	0x88, 0x11, 0xC9, 0x06,
+	0x03, 0xD4, 0x90, 0xF8, 0xA0, 0x01, 0xC0, 0x06, 0x02, 0xD5, 0x01, 0x20,
+	0xFF, 0xF7, 0x3B, 0xF9,
+	0x78, 0x05, 0x05, 0xD5, 0x00, 0x20, 0xFE, 0xF7, 0xDE, 0xFD, 0x00, 0x20,
+	0xFF, 0xF7, 0x33, 0xF9,
+	0x02, 0x21, 0x58, 0xE0, 0xC1, 0x05, 0x0C, 0xD5, 0xFB, 0xF7, 0xB2, 0xF9,
+	0x2F, 0x48, 0x07, 0x68,
+	0x04, 0x60, 0xFB, 0xF7, 0xAB, 0xF9, 0x38, 0x46, 0xFC, 0xF7, 0x9B, 0xFF,
+	0x4F, 0xF4, 0x80, 0x71,
+	0x49, 0xE0, 0x81, 0x05, 0x04, 0xD5, 0xFE, 0xF7, 0x46, 0xF9, 0x4F, 0xF4,
+	0x00, 0x71, 0x42, 0xE0,
+	0x41, 0x05, 0x15, 0xD5, 0xFB, 0xF7, 0x9C, 0xF9, 0x25, 0x48, 0x07, 0x68,
+	0x04, 0x60, 0xFB, 0xF7,
+	0x95, 0xF9, 0xF8, 0x07, 0x01, 0xD0, 0xFD, 0xF7, 0x39, 0xFD, 0xB8, 0x07,
+	0x01, 0xD5, 0xFD, 0xF7,
+	0xB5, 0xFD, 0x78, 0x07, 0x01, 0xD5, 0xFD, 0xF7, 0x45, 0xFD, 0x4F, 0xF4,
+	0x80, 0x61, 0x2A, 0xE0,
+	0x01, 0x06, 0x0B, 0xD5, 0xFB, 0xF7, 0x84, 0xF9, 0x1A, 0x48, 0x07, 0x68,
+	0x04, 0x60, 0xFB, 0xF7,
+	0x7D, 0xF9, 0x38, 0x46, 0xFE, 0xF7, 0x70, 0xF8, 0x80, 0x21, 0x1C, 0xE0,
+	0x81, 0x02, 0x0C, 0xD5,
+	0xFB, 0xF7, 0x76, 0xF9, 0x14, 0x48, 0x07, 0x68, 0x04, 0x60, 0xFB, 0xF7,
+	0x6F, 0xF9, 0x38, 0x46,
+	0xFD, 0xF7, 0x9C, 0xFC, 0x4F, 0xF4, 0x00, 0x11, 0x0D, 0xE0, 0xC1, 0x04,
+	0x04, 0xD5, 0xFE, 0xF7,
+	0x31, 0xFF, 0x4F, 0xF4, 0x80, 0x51, 0x06, 0xE0, 0x00, 0x05, 0x7F, 0xF5,
+	0x6F, 0xAF, 0xFE, 0xF7,
+	0x45, 0xFF, 0x4F, 0xF4, 0x00, 0x61, 0x00, 0x20, 0xFB, 0xF7, 0xC7, 0xFA,
+	0x66, 0xE7, 0x00, 0x00,
+	0x83, 0x9F, 0x30, 0x00, 0x4C, 0x07, 0x10, 0x00, 0x58, 0x07, 0x10, 0x00,
+	0x54, 0x07, 0x10, 0x00,
+	0x60, 0x07, 0x10, 0x00, 0x64, 0x07, 0x10, 0x00, 0x5C, 0x07, 0x10, 0x00,
+	0x20, 0x48, 0x10, 0xB5,
+	0x01, 0x68, 0x20, 0x48, 0x02, 0x68, 0x13, 0x46, 0x92, 0xEA, 0x01, 0x0F,
+	0x28, 0xD0, 0x1E, 0x4A,
+	0xCC, 0x07, 0x12, 0x68, 0x25, 0xD0, 0x92, 0xF8, 0x21, 0x43, 0xE4, 0x07,
+	0x02, 0xD0, 0x43, 0xF0,
+	0x01, 0x03, 0x03, 0x60, 0x8B, 0x07, 0x1F, 0xD5, 0x92, 0xF8, 0x40, 0x33,
+	0xDB, 0x07, 0x03, 0xD0,
+	0x03, 0x68, 0x43, 0xF0, 0x02, 0x03, 0x03, 0x60, 0x0B, 0x07, 0x19, 0xD5,
+	0x92, 0xF8, 0x60, 0x33,
+	0xDB, 0x07, 0x03, 0xD0, 0x03, 0x68, 0x43, 0xF0, 0x08, 0x03, 0x03, 0x60,
+	0x49, 0x06, 0x13, 0xD5,
+	0x92, 0xF8, 0x60, 0x13, 0xC9, 0x07, 0x03, 0xD0, 0x01, 0x68, 0x41, 0xF0,
+	0x40, 0x01, 0x01, 0x60,
+	0x10, 0xBD, 0x23, 0xF0, 0x01, 0x03, 0xDC, 0xE7, 0x03, 0x68, 0x23, 0xF0,
+	0x02, 0x03, 0xE2, 0xE7,
+	0x03, 0x68, 0x23, 0xF0, 0x08, 0x03, 0xE8, 0xE7, 0x01, 0x68, 0x21, 0xF0,
+	0x40, 0x01, 0xEE, 0xE7,
+	0x70, 0x07, 0x10, 0x00, 0x48, 0x05, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x2D, 0xE9, 0xF0, 0x47,
+	0xDF, 0xF8, 0x60, 0x92, 0x98, 0x4C, 0x00, 0x25, 0xD9, 0xF8, 0x00, 0x10,
+	0x91, 0xF8, 0x31, 0x00,
+	0x84, 0xF8, 0x30, 0x00, 0x91, 0xF8, 0x30, 0x20, 0x94, 0x49, 0x84, 0xF8,
+	0x31, 0x20, 0x50, 0x43,
+	0x09, 0x78, 0x84, 0xF8, 0x33, 0x10, 0x92, 0x49, 0x21, 0x60, 0x34, 0x39,
+	0x06, 0xB2, 0x8B, 0x7B,
+	0x84, 0xF8, 0x2D, 0x30, 0x88, 0x46, 0x77, 0x00, 0x0F, 0xE0, 0x2A, 0x46,
+	0x31, 0x46, 0xD8, 0xF8,
+	0x08, 0x00, 0x0E, 0xF0, 0x32, 0xF9, 0x01, 0x46, 0x22, 0x68, 0x06, 0xFB,
+	0x05, 0xF0, 0x02, 0xEB,
+	0x40, 0x00, 0x3A, 0x46, 0x12, 0xF0, 0x09, 0xF8, 0x6D, 0x1C, 0x94, 0xF8,
+	0x2D, 0x00, 0xA8, 0x42,
+	0xEB, 0xDC, 0x84, 0x48, 0x84, 0x49, 0x00, 0x78, 0x09, 0x78, 0x08, 0x43,
+	0x40, 0x07, 0x11, 0xD5,
+	0x82, 0x48, 0x60, 0x60, 0xD9, 0xF8, 0x00, 0x10, 0x91, 0xF8, 0xF1, 0x11,
+	0x89, 0x07, 0x4A, 0x0F,
+	0x94, 0xF8, 0x31, 0x10, 0x92, 0x1C, 0x4A, 0x43, 0xD8, 0xF8, 0x10, 0x10,
+	0xBD, 0xE8, 0xF0, 0x47,
+	0x11, 0xF0, 0xEB, 0xBF, 0xBD, 0xE8, 0xF0, 0x87, 0x2D, 0xE9, 0xF8, 0x43,
+	0x75, 0x48, 0xDF, 0xF8,
+	0xD8, 0x81, 0x00, 0x27, 0x05, 0x68, 0xD8, 0xF8, 0x00, 0x00, 0x05, 0x43,
+	0x01, 0x20, 0xFB, 0xF7,
+	0xC8, 0xFA, 0x38, 0x21, 0x6C, 0x48, 0x12, 0xF0, 0x79, 0xF8, 0xE8, 0x07,
+	0x06, 0xD0, 0xFF, 0xF7,
+	0x9D, 0xFF, 0xE8, 0x06, 0x01, 0xD5, 0x00, 0xF0, 0x9B, 0xF8, 0x01, 0x27,
+	0x68, 0x4E, 0x66, 0x4C,
+	0xA8, 0x07, 0xA6, 0xF1, 0x34, 0x06, 0x0A, 0xD5, 0x69, 0x48, 0xA0, 0x60,
+	0x68, 0x49, 0x70, 0x69,
+	0x89, 0x1E, 0x01, 0x27, 0x02, 0x68, 0x41, 0xF8, 0x02, 0x2F, 0x40, 0x68,
+	0x48, 0x60, 0xA8, 0x05,
+	0x11, 0xD5, 0x62, 0x4F, 0xCA, 0x3F, 0xA7, 0x61, 0x11, 0xF0, 0x81, 0xFC,
+	0x00, 0x90, 0x04, 0x21,
+	0x68, 0x46, 0xFC, 0xF7, 0x08, 0xF8, 0x84, 0xF8, 0x32, 0x00, 0xF0, 0x6A,
+	0x01, 0x68, 0x39, 0x60,
+	0x40, 0x68, 0x78, 0x60, 0x01, 0x27, 0x5B, 0x48, 0x00, 0x68, 0xC4, 0xE9,
+	0x07, 0x05, 0xD8, 0xF8,
+	0x00, 0x00, 0x60, 0x62, 0x70, 0x68, 0xA0, 0x62, 0xF0, 0x7B, 0x84, 0xF8,
+	0x35, 0x00, 0x96, 0xF8,
+	0x30, 0x00, 0x55, 0x4E, 0x84, 0xF8, 0x36, 0x00, 0x30, 0x78, 0x84, 0xF8,
+	0x2C, 0x00, 0xE8, 0x07,
+	0x1A, 0xD0, 0xE8, 0x06, 0x18, 0xD5, 0x47, 0x4D, 0x28, 0x68, 0x90, 0xF8,
+	0x50, 0x02, 0xC0, 0x07,
+	0x06, 0xD0, 0x00, 0xF0, 0xF4, 0xFD, 0x18, 0xB9, 0xE0, 0x69, 0x40, 0xF0,
+	0x10, 0x00, 0xE0, 0x61,
+	0x28, 0x68, 0x90, 0xF8, 0x80, 0x02, 0xC0, 0x07, 0x06, 0xD0, 0x00, 0xF0,
+	0xE8, 0xFD, 0x18, 0xB9,
+	0xE0, 0x69, 0x40, 0xF0, 0x20, 0x00, 0xE0, 0x61, 0x01, 0x20, 0xFB, 0xF7,
+	0x7D, 0xFA, 0x00, 0x2F,
+	0x0C, 0xD0, 0x30, 0x78, 0x05, 0x28, 0x07, 0xD0, 0x06, 0x28, 0x05, 0xD0,
+	0x01, 0x21, 0xBD, 0xE8,
+	0xF8, 0x43, 0x02, 0x20, 0xFB, 0xF7, 0x75, 0xB9, 0x02, 0x21, 0xF8, 0xE7,
+	0xBD, 0xE8, 0xF8, 0x83,
+	0x3A, 0x48, 0x10, 0xB5, 0x00, 0x78, 0x00, 0x28, 0x29, 0xD1, 0x31, 0x4C,
+	0x34, 0x3C, 0xD4, 0xE9,
+	0x06, 0x01, 0x00, 0xF0, 0xC7, 0xFD, 0x94, 0xF8, 0x31, 0x10, 0xA0, 0x6A,
+	0x00, 0xF0, 0xC3, 0xFC,
+	0xFF, 0xF7, 0x6A, 0xFF, 0x27, 0x48, 0x00, 0x68, 0x90, 0xF8, 0x60, 0x03,
+	0xC1, 0x07, 0x16, 0xD0,
+	0x81, 0x07, 0x14, 0xD5, 0x00, 0x24, 0x40, 0x09, 0x12, 0xF0, 0x6C, 0xF8,
+	0x00, 0xB1, 0x01, 0x24,
+	0x27, 0x48, 0x80, 0x1E, 0x01, 0x78, 0x8C, 0x42, 0x09, 0xD0, 0x04, 0x70,
+	0x0C, 0xB1, 0x08, 0x21,
+	0x00, 0xE0, 0x10, 0x21, 0xBD, 0xE8, 0x10, 0x40, 0x03, 0x20, 0xFB, 0xF7,
+	0x42, 0xB9, 0x10, 0xBD,
+	0x2D, 0xE9, 0xF0, 0x41, 0x17, 0x48, 0x1A, 0x4E, 0x17, 0x4C, 0x00, 0x68,
+	0x34, 0x3E, 0x90, 0xF8,
+	0x31, 0x50, 0x90, 0xF8, 0x30, 0x70, 0xB1, 0x69, 0x39, 0xB1, 0x18, 0x48,
+	0x84, 0xF8, 0x30, 0x50,
+	0xC2, 0x38, 0x6A, 0x00, 0x20, 0x61, 0x11, 0xF0, 0x20, 0xFF, 0xF1, 0x69,
+	0x39, 0xB1, 0x13, 0x48,
+	0x84, 0xF8, 0x31, 0x70, 0x98, 0x38, 0x7A, 0x00, 0x60, 0x61, 0x11, 0xF0,
+	0x16, 0xFF, 0x0D, 0x48,
+	0x0D, 0x49, 0x00, 0x78, 0x09, 0x78, 0x08, 0x43, 0x80, 0x06, 0x08, 0xD5,
+	0x0B, 0x48, 0x4C, 0x38,
+	0xE0, 0x60, 0x6A, 0x00, 0x71, 0x6A, 0xBD, 0xE8, 0xF0, 0x41, 0x11, 0xF0,
+	0x06, 0xBF, 0xBD, 0xE8,
+	0xF0, 0x81, 0x00, 0x00, 0x4C, 0x07, 0x10, 0x00, 0xCC, 0x68, 0x10, 0x00,
+	0x54, 0x05, 0x10, 0x00,
+	0x1C, 0x11, 0x10, 0x00, 0x4C, 0x05, 0x10, 0x00, 0x50, 0x05, 0x10, 0x00,
+	0xCC, 0x07, 0x01, 0x20,
+	0x1A, 0x05, 0x10, 0x00, 0x48, 0x05, 0x10, 0x00, 0x40, 0x05, 0x10, 0x00,
+	0x41, 0x05, 0x10, 0x00,
+	0x10, 0xB5, 0x00, 0x24, 0xC1, 0x07, 0x0B, 0xD0, 0x3F, 0x49, 0x03, 0x24,
+	0x09, 0x68, 0x91, 0xF8,
+	0x50, 0x22, 0xD2, 0x07, 0x03, 0xD1, 0x91, 0xF8, 0x80, 0x12, 0xC9, 0x07,
+	0x00, 0xD0, 0x0B, 0x24,
+	0x82, 0x07, 0x4F, 0xF0, 0x01, 0x01, 0x03, 0xD5, 0x38, 0x4A, 0x44, 0xF0,
+	0x10, 0x04, 0x11, 0x70,
+	0x40, 0x06, 0x03, 0xD5, 0x36, 0x48, 0x44, 0xF0, 0x80, 0x04, 0x01, 0x70,
+	0x00, 0x2C, 0x12, 0xD0,
+	0xFA, 0xF7, 0x96, 0xFF, 0x33, 0x48, 0x01, 0x68, 0x21, 0x43, 0x01, 0x60,
+	0xFA, 0xF7, 0x8E, 0xFF,
+	0x01, 0x21, 0x05, 0x20, 0x0D, 0xF0, 0xCF, 0xFA, 0xBD, 0xE8, 0x10, 0x40,
+	0x4F, 0xF4, 0x80, 0x71,
+	0x00, 0x20, 0xFB, 0xF7, 0xC6, 0xB8, 0x10, 0xBD, 0x10, 0xB5, 0x00, 0xF0,
+	0xDE, 0xFD, 0x02, 0x21,
+	0x01, 0x20, 0xFB, 0xF7, 0xEA, 0xF8, 0x01, 0x20, 0xFB, 0xF7, 0x9B, 0xF9,
+	0x38, 0x21, 0x26, 0x48,
+	0x11, 0xF0, 0x4C, 0xFF, 0x24, 0x49, 0x01, 0x20, 0x81, 0xF8, 0x2C, 0x00,
+	0xFB, 0xF7, 0xAC, 0xF9,
+	0x01, 0x21, 0x02, 0x20, 0xFB, 0xF7, 0xAD, 0xF8, 0xBD, 0xE8, 0x10, 0x40,
+	0x00, 0xF0, 0x2D, 0xBB,
+	0x70, 0xB5, 0x1E, 0x48, 0x1E, 0x4E, 0x05, 0x68, 0x30, 0x68, 0x90, 0xEA,
+	0x05, 0x04, 0x1F, 0xD0,
+	0x35, 0xB1, 0x40, 0xB1, 0x04, 0xEA, 0x05, 0x00, 0xFF, 0xF7, 0xA2, 0xFF,
+	0x35, 0x60, 0x70, 0xBD,
+	0xFF, 0xF7, 0xD2, 0xFF, 0xFA, 0xE7, 0x00, 0xF0, 0xB0, 0xFD, 0x02, 0x21,
+	0x01, 0x20, 0xFB, 0xF7,
+	0xBC, 0xF8, 0x00, 0xF0, 0xD8, 0xF8, 0x00, 0xF0, 0x08, 0xFB, 0x04, 0xEA,
+	0x05, 0x00, 0xFF, 0xF7,
+	0x8F, 0xFF, 0x00, 0xF0, 0xF1, 0xFA, 0x02, 0x21, 0x01, 0x20, 0xFB, 0xF7,
+	0x82, 0xF8, 0xE5, 0xE7,
+	0x00, 0x2D, 0xE4, 0xD1, 0x0B, 0x48, 0x00, 0x78, 0x05, 0x28, 0x01, 0xD0,
+	0x06, 0x28, 0xDE, 0xD1,
+	0x35, 0x60, 0xBD, 0xE8, 0x70, 0x40, 0xAF, 0xE7, 0x4C, 0x07, 0x10, 0x00,
+	0x7B, 0x07, 0x10, 0x00,
+	0x7C, 0x07, 0x10, 0x00, 0x54, 0x07, 0x10, 0x00, 0xCC, 0x68, 0x10, 0x00,
+	0x6C, 0x07, 0x10, 0x00,
+	0x44, 0x05, 0x10, 0x00, 0x40, 0x05, 0x10, 0x00, 0x70, 0xB5, 0xFF, 0x49,
+	0x00, 0x20, 0x03, 0x46,
+	0x09, 0x68, 0x91, 0xF8, 0x40, 0x20, 0xD2, 0x07, 0x38, 0xD0, 0xFC, 0x4A,
+	0x15, 0x78, 0x02, 0x2D,
+	0x16, 0xD0, 0x04, 0x2D, 0x03, 0xD0, 0x05, 0x2D, 0x0F, 0xD0, 0x06, 0x2D,
+	0x0D, 0xD0, 0x91, 0xF8,
+	0x41, 0x20, 0xF7, 0x49, 0x0C, 0x68, 0x64, 0x1C, 0x0C, 0x60, 0x94, 0x42,
+	0x26, 0xDD, 0xF5, 0x4A,
+	0x00, 0x20, 0x14, 0x78, 0x64, 0xB1, 0x08, 0x60, 0x0C, 0xE0, 0x91, 0xF8,
+	0x43, 0x20, 0xF0, 0xE7,
+	0x91, 0xF8, 0x42, 0x20, 0x91, 0xF8, 0x90, 0x10, 0xC9, 0x06, 0xEA, 0xD5,
+	0x01, 0x23, 0xE8, 0xE7,
+	0x13, 0xB1, 0x01, 0x20, 0x10, 0x70, 0x00, 0xE0, 0x08, 0x60, 0x05, 0x2D,
+	0x0F, 0xD0, 0x00, 0xF0,
+	0x11, 0xF9, 0x04, 0x46, 0x00, 0xF0, 0x14, 0xF9, 0x04, 0x43, 0x00, 0xF0,
+	0x1F, 0xF9, 0x04, 0x43,
+	0x00, 0xF0, 0x2B, 0xF9, 0x04, 0x43, 0x00, 0xF0, 0x35, 0xF9, 0x20, 0x43,
+	0x70, 0xBD, 0x01, 0x20,
+	0x70, 0xBD, 0x10, 0xB5, 0x01, 0x46, 0x34, 0x22, 0xDF, 0x48, 0x11, 0xF0,
+	0x53, 0xFE, 0x01, 0x21,
+	0xBD, 0xE8, 0x10, 0x40, 0x08, 0x46, 0xFB, 0xF7, 0x14, 0xB8, 0x2D, 0xE9,
+	0xFF, 0x41, 0x80, 0x46,
+	0xD6, 0x48, 0x00, 0x78, 0x02, 0x28, 0x24, 0xD0, 0x03, 0x28, 0x1E, 0xD0,
+	0x04, 0x24, 0xD7, 0x4D,
+	0xD7, 0x4E, 0x01, 0x27, 0x05, 0x28, 0x20, 0xD0, 0x06, 0x28, 0x68, 0x46,
+	0x30, 0xD0, 0x00, 0xF0,
+	0xB5, 0xF9, 0xD4, 0x48, 0x00, 0x90, 0xCC, 0x48, 0x00, 0x68, 0x90, 0xF8,
+	0xB0, 0x00, 0xC0, 0x07,
+	0x01, 0xD0, 0x8D, 0xF8, 0x0D, 0x80, 0x68, 0x46, 0x11, 0xF0, 0x71, 0xFA,
+	0xCE, 0x49, 0xCF, 0x4A,
+	0xC9, 0x78, 0x11, 0x70, 0x04, 0xB0, 0xBD, 0xE8, 0xF0, 0x81, 0x68, 0x46,
+	0x00, 0xF0, 0x4A, 0xF9,
+	0xE7, 0xE7, 0x68, 0x46, 0x00, 0xF0, 0x05, 0xF9, 0xE3, 0xE7, 0x68, 0x46,
+	0x11, 0xF0, 0x3A, 0xFA,
+	0xFF, 0xF7, 0x7A, 0xFF, 0x40, 0x21, 0xC2, 0x07, 0x01, 0xD0, 0x8D, 0xF8,
+	0x04, 0x40, 0xC2, 0x06,
+	0x01, 0xD5, 0x8D, 0xF8, 0x06, 0x70, 0x8D, 0xF8, 0x08, 0x70, 0x28, 0x60,
+	0x31, 0x60, 0xD0, 0xE7,
+	0x00, 0x27, 0x11, 0xF0, 0x27, 0xFA, 0x8D, 0xF8, 0x04, 0x40, 0x01, 0x20,
+	0x2F, 0x60, 0x30, 0x60,
+	0xC7, 0xE7, 0x10, 0xB5, 0x00, 0xF0, 0xE1, 0xFC, 0x02, 0x21, 0xBD, 0xE8,
+	0x10, 0x40, 0x01, 0x20,
+	0xFA, 0xF7, 0xBF, 0xBF, 0x10, 0xB5, 0x00, 0xF0, 0xDD, 0xFC, 0x20, 0x21,
+	0xBD, 0xE8, 0x10, 0x40,
+	0x01, 0x20, 0xFA, 0xF7, 0xB6, 0xBF, 0xAA, 0x49, 0x00, 0x20, 0x08, 0x60,
+	0x70, 0x47, 0xA8, 0x49,
+	0x00, 0x20, 0x08, 0x60, 0x70, 0x47, 0xF8, 0xB5, 0x00, 0x24, 0x20, 0x46,
+	0xFB, 0xF7, 0x89, 0xF8,
+	0x00, 0xF0, 0x32, 0xFA, 0xA1, 0x4E, 0x30, 0x78, 0x00, 0xF0, 0x93, 0xF9,
+	0xAF, 0xF2, 0x4D, 0x01,
+	0x00, 0xF0, 0xB3, 0xFC, 0x9C, 0x4F, 0xA6, 0x4D, 0x38, 0x68, 0x90, 0xF8,
+	0xB0, 0x00, 0xC1, 0x07,
+	0x09, 0xD0, 0x01, 0x24, 0xC0, 0xF3, 0xC1, 0x01, 0x02, 0x29, 0x00, 0xD1,
+	0x00, 0x24, 0x80, 0x07,
+	0x01, 0xD5, 0x00, 0x20, 0x28, 0x70, 0x20, 0x46, 0xFF, 0xF7, 0x77, 0xFF,
+	0x96, 0x4C, 0x01, 0x28,
+	0x0D, 0xD1, 0x01, 0x21, 0x6B, 0x46, 0x00, 0x22, 0x08, 0x46, 0xFA, 0xF7,
+	0xCB, 0xFF, 0x01, 0x21,
+	0x08, 0x46, 0xFA, 0xF7, 0xAA, 0xFF, 0x20, 0x78, 0x90, 0xB1, 0x0C, 0xF0,
+	0x8E, 0xFF, 0x00, 0x20,
+	0xFB, 0xF7, 0x72, 0xF8, 0x38, 0x68, 0x90, 0xF8, 0xB0, 0x10, 0xCA, 0x07,
+	0x51, 0xD0, 0x89, 0x07,
+	0x4F, 0xD5, 0x8D, 0x49, 0x49, 0x78, 0x00, 0x29, 0x4B, 0xD1, 0x29, 0x78,
+	0x19, 0xB1, 0x28, 0xE0,
+	0xFF, 0xF7, 0xF6, 0xFD, 0xEB, 0xE7, 0x32, 0x78, 0x8A, 0x49, 0x02, 0x2A,
+	0x02, 0xD1, 0x83, 0x4A,
+	0x12, 0x68, 0x2A, 0xB1, 0x09, 0x78, 0x49, 0x06, 0x0B, 0xD5, 0x90, 0xF8,
+	0xC1, 0x00, 0x0A, 0xE0,
+	0x09, 0x78, 0x49, 0x06, 0x02, 0xD5, 0x90, 0xF8, 0xC2, 0x00, 0x04, 0xE0,
+	0x90, 0xF8, 0xBC, 0x00,
+	0x01, 0xE0, 0x90, 0xF8, 0xBB, 0x00, 0xAF, 0xF2, 0xE3, 0x01, 0x00, 0xF0,
+	0x68, 0xFC, 0x6B, 0x46,
+	0x00, 0x22, 0x20, 0x21, 0x01, 0x20, 0xFA, 0xF7, 0x8D, 0xFF, 0x20, 0x21,
+	0x01, 0x20, 0xFA, 0xF7,
+	0x6C, 0xFF, 0x28, 0x78, 0x00, 0x28, 0x1C, 0xD1, 0xFB, 0xF7, 0x1B, 0xF8,
+	0x00, 0x20, 0xFF, 0xF7,
+	0x24, 0xFF, 0x01, 0x28, 0x0D, 0xD1, 0x01, 0x21, 0x6B, 0x46, 0x00, 0x22,
+	0x08, 0x46, 0xFA, 0xF7,
+	0x79, 0xFF, 0x01, 0x21, 0x08, 0x46, 0xFA, 0xF7, 0x58, 0xFF, 0x20, 0x78,
+	0x30, 0xB1, 0x0C, 0xF0,
+	0x3C, 0xFF, 0xBD, 0xE8, 0xF8, 0x40, 0x00, 0x20, 0xFB, 0xF7, 0x1E, 0xB8,
+	0xFF, 0xF7, 0xB0, 0xFD,
+	0xF7, 0xE7, 0xF8, 0xBD, 0x67, 0x48, 0x00, 0x78, 0xC0, 0x07, 0x00, 0xD0,
+	0x01, 0x20, 0x70, 0x47,
+	0x64, 0x48, 0x00, 0x78, 0xC0, 0x07, 0x07, 0xD0, 0x57, 0x48, 0x00, 0x68,
+	0x90, 0xF8, 0x50, 0x02,
+	0xC0, 0x07, 0x01, 0xD0, 0x10, 0x20, 0x70, 0x47, 0x00, 0x20, 0x70, 0x47,
+	0x5D, 0x48, 0x00, 0x78,
+	0xC1, 0x07, 0x51, 0x48, 0x00, 0x68, 0x90, 0xF8, 0x80, 0x02, 0x03, 0xD0,
+	0xC1, 0x07, 0x01, 0xD0,
+	0x10, 0x20, 0x70, 0x47, 0x00, 0xF0, 0x01, 0x00, 0x70, 0x47, 0x56, 0x48,
+	0x00, 0x78, 0x80, 0x07,
+	0x06, 0xD5, 0x49, 0x48, 0x00, 0x68, 0x90, 0xF8, 0x61, 0x04, 0x08, 0xB1,
+	0x02, 0x20, 0x70, 0x47,
+	0x00, 0x20, 0x70, 0x47, 0x4F, 0x48, 0x00, 0x78, 0x40, 0x06, 0x08, 0xD5,
+	0x42, 0x48, 0x00, 0x68,
+	0x90, 0xF8, 0x2F, 0x0A, 0xC0, 0x07, 0x02, 0xD0, 0x4F, 0xF4, 0x00, 0x70,
+	0x70, 0x47, 0x00, 0x20,
+	0x70, 0x47, 0x2D, 0xE9, 0xF0, 0x41, 0x06, 0x46, 0x00, 0x27, 0x11, 0xF0,
+	0x33, 0xF9, 0xFF, 0xF7,
+	0x73, 0xFE, 0x05, 0x46, 0x43, 0x48, 0x00, 0x78, 0xC0, 0x07, 0x00, 0xD0,
+	0x40, 0x27, 0xFF, 0xF7,
+	0xD4, 0xFF, 0x40, 0xEA, 0x07, 0x04, 0x6D, 0xB1, 0x33, 0x48, 0x00, 0x68,
+	0x90, 0xF8, 0x90, 0x00,
+	0x00, 0x07, 0x07, 0xD5, 0x00, 0xF0, 0xE4, 0xF8, 0x40, 0xEA, 0x04, 0x07,
+	0x00, 0xF0, 0xEE, 0xF8,
+	0x40, 0xEA, 0x07, 0x04, 0x45, 0xEA, 0x04, 0x07, 0xF8, 0x07, 0x02, 0xD0,
+	0x00, 0xF0, 0xF4, 0xF8,
+	0x30, 0x71, 0x61, 0x07, 0x4F, 0xF0, 0x01, 0x00, 0x00, 0xD5, 0x70, 0x71,
+	0xE9, 0x06, 0x00, 0xD5,
+	0xB0, 0x71, 0x61, 0x06, 0x00, 0xD5, 0x30, 0x72, 0xA1, 0x06, 0x00, 0xD5,
+	0xF0, 0x71, 0xB9, 0x07,
+	0x00, 0xD5, 0x70, 0x72, 0xA9, 0x05, 0x00, 0xD5, 0xB0, 0x72, 0x24, 0x48,
+	0x05, 0x60, 0x24, 0x48,
+	0x04, 0x60, 0xB0, 0xE6, 0x2D, 0xE9, 0xF0, 0x41, 0x05, 0x46, 0x11, 0xF0,
+	0xF3, 0xF8, 0xFF, 0xF7,
+	0x33, 0xFE, 0x07, 0x46, 0xFF, 0xF7, 0x76, 0xFF, 0x04, 0x46, 0xFF, 0xF7,
+	0x79, 0xFF, 0x04, 0x43,
+	0xFF, 0xF7, 0x84, 0xFF, 0x04, 0x43, 0x00, 0xF0, 0xAB, 0xF8, 0x04, 0x43,
+	0xFF, 0xF7, 0x8D, 0xFF,
+	0x04, 0x43, 0xFF, 0xF7, 0x97, 0xFF, 0x04, 0x43, 0x00, 0xF0, 0xB0, 0xF8,
+	0x40, 0xEA, 0x04, 0x06,
+	0x47, 0xEA, 0x06, 0x04, 0xE0, 0x07, 0x02, 0xD0, 0x00, 0xF0, 0xB6, 0xF8,
+	0x28, 0x71, 0x71, 0x07,
+	0x4F, 0xF0, 0x01, 0x00, 0x00, 0xD5, 0x68, 0x71, 0xE1, 0x06, 0x00, 0xD5,
+	0xA8, 0x71, 0xB1, 0x06,
+	0x00, 0xD5, 0xE8, 0x71, 0xA1, 0x07, 0x00, 0xD5, 0x68, 0x72, 0xA1, 0x05,
+	0x00, 0xD5, 0xA8, 0x72,
+	0x06, 0x48, 0x07, 0x60, 0x06, 0x48, 0x17, 0xE0, 0x4C, 0x07, 0x10, 0x00,
+	0x40, 0x05, 0x10, 0x00,
+	0x24, 0x05, 0x10, 0x00, 0x41, 0x05, 0x10, 0x00, 0xE8, 0x10, 0x10, 0x00,
+	0x50, 0x05, 0x10, 0x00,
+	0x4C, 0x05, 0x10, 0x00, 0xE3, 0x54, 0x00, 0x00, 0x74, 0x07, 0x10, 0x00,
+	0x54, 0x05, 0x10, 0x00,
+	0x78, 0x07, 0x10, 0x00, 0x44, 0x05, 0x10, 0x00, 0x06, 0x60, 0x5C, 0xE6,
+	0x2D, 0xE9, 0xF0, 0x41,
+	0x05, 0x46, 0x11, 0xF0, 0x9F, 0xF8, 0xFF, 0xF7, 0xDF, 0xFD, 0x06, 0x46,
+	0xFF, 0xF7, 0x22, 0xFF,
+	0x04, 0x46, 0xFF, 0xF7, 0x25, 0xFF, 0x04, 0x43, 0xFF, 0xF7, 0x30, 0xFF,
+	0x04, 0x43, 0x00, 0xF0,
+	0x57, 0xF8, 0x04, 0x43, 0xFF, 0xF7, 0x39, 0xFF, 0x04, 0x43, 0xFF, 0xF7,
+	0x43, 0xFF, 0x04, 0x43,
+	0x00, 0xF0, 0x5C, 0xF8, 0x40, 0xEA, 0x04, 0x07, 0x46, 0xEA, 0x07, 0x04,
+	0xE0, 0x07, 0x02, 0xD0,
+	0x00, 0xF0, 0x62, 0xF8, 0x28, 0x71, 0x61, 0x07, 0x4F, 0xF0, 0x01, 0x00,
+	0x00, 0xD5, 0x68, 0x71,
+	0xE1, 0x06, 0x00, 0xD5, 0xA8, 0x71, 0xB9, 0x06, 0x00, 0xD5, 0xE8, 0x71,
+	0xA1, 0x07, 0x00, 0xD5,
+	0x68, 0x72, 0xA1, 0x05, 0x00, 0xD5, 0xA8, 0x72, 0x2E, 0x48, 0x06, 0x60,
+	0x2E, 0x48, 0x07, 0x60,
+	0x21, 0xE6, 0x38, 0xB5, 0x2D, 0x49, 0x80, 0x1E, 0x05, 0x28, 0x09, 0x68,
+	0x13, 0xD2, 0xDF, 0xE8,
+	0x00, 0xF0, 0x03, 0x06, 0x09, 0x0C, 0x0F, 0x00, 0x91, 0xF8, 0x73, 0x40,
+	0x0C, 0xE0, 0x91, 0xF8,
+	0x72, 0x40, 0x09, 0xE0, 0x91, 0xF8, 0x71, 0x40, 0x06, 0xE0, 0x91, 0xF8,
+	0x74, 0x40, 0x03, 0xE0,
+	0x91, 0xF8, 0x75, 0x40, 0x00, 0xE0, 0x01, 0x24, 0x00, 0x25, 0x0C, 0xF0,
+	0x53, 0xFA, 0x00, 0xB1,
+	0x01, 0x25, 0x69, 0x46, 0x03, 0x20, 0xFA, 0xF7, 0x26, 0xFE, 0x00, 0x98,
+	0x00, 0xB9, 0x1D, 0xB1,
+	0x14, 0x2C, 0x01, 0xD2, 0x14, 0x24, 0x01, 0xE0, 0x04, 0xB9, 0x01, 0x24,
+	0x20, 0x46, 0x38, 0xBD,
+	0x17, 0x48, 0x00, 0x78, 0xC0, 0x07, 0x07, 0xD0, 0x14, 0x48, 0x00, 0x68,
+	0x90, 0xF8, 0xF0, 0x01,
+	0xC0, 0x07, 0x01, 0xD0, 0x04, 0x20, 0x70, 0x47, 0x00, 0x20, 0x70, 0x47,
+	0x10, 0x48, 0x00, 0x78,
+	0xC0, 0x07, 0x07, 0xD0, 0x0D, 0x48, 0x00, 0x68, 0x90, 0xF8, 0x10, 0x02,
+	0xC0, 0x07, 0x01, 0xD0,
+	0x20, 0x20, 0x70, 0x47, 0x00, 0x20, 0x70, 0x47, 0x08, 0x49, 0x01, 0x20,
+	0x09, 0x68, 0x91, 0xF8,
+	0xE7, 0x10, 0x09, 0x06, 0x03, 0xD5, 0x07, 0x48, 0x40, 0x78, 0x08, 0xB1,
+	0x03, 0x20, 0x70, 0x47,
+	0x02, 0x20, 0x70, 0x47, 0x50, 0x05, 0x10, 0x00, 0x4C, 0x05, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0x44, 0x05, 0x10, 0x00, 0x74, 0x07, 0x10, 0x00, 0x10, 0xB5, 0x00, 0xF0,
+	0x8B, 0xF9, 0x00, 0xF0,
+	0x00, 0xFA, 0x5B, 0x49, 0x00, 0x20, 0x48, 0x60, 0x5A, 0x49, 0x02, 0x20,
+	0x08, 0x70, 0x10, 0xBD,
+	0x10, 0xB5, 0x00, 0xF0, 0x7F, 0xF9, 0x00, 0xF0, 0xF4, 0xF9, 0x55, 0x49,
+	0x00, 0x20, 0x48, 0x60,
+	0x54, 0x49, 0x03, 0x20, 0x08, 0x70, 0x10, 0xBD, 0x10, 0xB5, 0x00, 0xF0,
+	0x73, 0xF9, 0x00, 0xF0,
+	0xE8, 0xF9, 0x4F, 0x49, 0x00, 0x20, 0x48, 0x60, 0x4E, 0x49, 0x04, 0x20,
+	0x08, 0x70, 0x4E, 0x49,
+	0x01, 0x20, 0x08, 0x70, 0x4D, 0x49, 0x08, 0x70, 0x10, 0xBD, 0x49, 0x49,
+	0x00, 0x20, 0x48, 0x60,
+	0x70, 0x47, 0x47, 0x49, 0x00, 0x20, 0x48, 0x60, 0x70, 0x47, 0x45, 0x49,
+	0x00, 0x20, 0x48, 0x60,
+	0x44, 0x49, 0x01, 0x20, 0x08, 0x70, 0x70, 0x47, 0x70, 0xB5, 0x42, 0x4D,
+	0x00, 0x26, 0x40, 0x4C,
+	0x28, 0x78, 0x80, 0x1E, 0x04, 0x28, 0x10, 0xD2, 0xDF, 0xE8, 0x00, 0xF0,
+	0x30, 0x1F, 0x02, 0x3E,
+	0x00, 0xF0, 0x45, 0xF8, 0x01, 0x28, 0x07, 0xD0, 0x60, 0x68, 0x40, 0x1C,
+	0x60, 0x60, 0x00, 0xF0,
+	0x46, 0xF8, 0x01, 0x28, 0x02, 0xD0, 0x0B, 0xE0, 0x66, 0x60, 0x70, 0xBD,
+	0x38, 0x48, 0x61, 0x68,
+	0x00, 0x68, 0x90, 0xF8, 0x77, 0x00, 0x88, 0x42, 0x02, 0xD2, 0xBD, 0xE8,
+	0x70, 0x40, 0xAF, 0xE7,
+	0x00, 0xF0, 0x47, 0xF8, 0x01, 0x28, 0x0E, 0xD0, 0x70, 0xBD, 0x00, 0xF0,
+	0x28, 0xF8, 0x01, 0x28,
+	0x17, 0xD0, 0x60, 0x68, 0x40, 0x1C, 0x60, 0x60, 0x00, 0xF0, 0x3B, 0xF8,
+	0x01, 0x28, 0x02, 0xD0,
+	0x00, 0xF0, 0x25, 0xF8, 0x0B, 0xE0, 0xBD, 0xE8, 0x70, 0x40, 0x8D, 0xE7,
+	0x00, 0xF0, 0x17, 0xF8,
+	0x01, 0x28, 0x06, 0xD0, 0x60, 0x68, 0x40, 0x1C, 0x60, 0x60, 0x00, 0xF0,
+	0x22, 0xF8, 0x01, 0x28,
+	0xE2, 0xD0, 0xBD, 0xE8, 0x70, 0x40, 0x97, 0xE7, 0x00, 0xF0, 0x09, 0xF9,
+	0x08, 0xB1, 0x21, 0x78,
+	0x09, 0xB1, 0x20, 0x70, 0x70, 0xBD, 0x20, 0x70, 0x06, 0x20, 0x28, 0x70,
+	0x70, 0xBD, 0x10, 0xB5,
+	0x00, 0xF0, 0xFD, 0xF8, 0x04, 0x46, 0x0B, 0xF0, 0x43, 0xFD, 0x20, 0x43,
+	0x10, 0xBD, 0x18, 0x48,
+	0x00, 0x68, 0x90, 0xF8, 0x70, 0x00, 0x80, 0x07, 0x01, 0xD5, 0x01, 0x20,
+	0x70, 0x47, 0x00, 0x20,
+	0x70, 0x47, 0x13, 0x48, 0x00, 0x68, 0x90, 0xF8, 0x70, 0x00, 0xC0, 0x07,
+	0x00, 0xD0, 0x01, 0x20,
+	0x70, 0x47, 0x10, 0xB5, 0xFF, 0xF7, 0xF5, 0xFF, 0x01, 0x28, 0x0F, 0xD1,
+	0x00, 0xF0, 0x5F, 0xF9,
+	0x60, 0xB9, 0x0B, 0x48, 0x06, 0x49, 0x00, 0x68, 0x49, 0x68, 0x90, 0xF8,
+	0x78, 0x00, 0x00, 0xEB,
+	0x80, 0x00, 0xB1, 0xEB, 0x40, 0x0F, 0x01, 0xD9, 0x01, 0x20, 0x10, 0xBD,
+	0x00, 0x20, 0x10, 0xBD,
+	0x28, 0x05, 0x10, 0x00, 0x40, 0x05, 0x10, 0x00, 0x79, 0x07, 0x10, 0x00,
+	0x7A, 0x07, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x2D, 0xE9, 0xF0, 0x41, 0x8E, 0x4C, 0x07, 0x46,
+	0x0E, 0x46, 0x20, 0x68,
+	0x00, 0x25, 0x90, 0xF8, 0x98, 0x20, 0x8C, 0x48, 0x0E, 0xF0, 0xBD, 0xFA,
+	0x02, 0x00, 0x8B, 0x48,
+	0x29, 0x46, 0x34, 0xD0, 0x02, 0x78, 0x01, 0x25, 0x52, 0x1C, 0xD2, 0xB2,
+	0x02, 0x70, 0x23, 0x68,
+	0x93, 0xF8, 0x99, 0x30, 0x93, 0x42, 0x2B, 0xD2, 0x01, 0x70, 0x83, 0x48,
+	0x76, 0x00, 0x32, 0x46,
+	0x39, 0x46, 0x54, 0x38, 0x11, 0xF0, 0xB9, 0xFA, 0x7F, 0x48, 0x32, 0x46,
+	0x39, 0x46, 0x2A, 0x38,
+	0x11, 0xF0, 0xB3, 0xFA, 0x20, 0x68, 0x03, 0x26, 0x90, 0xF8, 0x50, 0x12,
+	0xC9, 0x07, 0x03, 0xD1,
+	0x90, 0xF8, 0x80, 0x02, 0xC0, 0x07, 0x00, 0xD0, 0x0B, 0x26, 0xFA, 0xF7,
+	0x71, 0xFB, 0x78, 0x48,
+	0x01, 0x68, 0x31, 0x43, 0x01, 0x60, 0xFA, 0xF7, 0x69, 0xFB, 0x20, 0x21,
+	0x05, 0x20, 0x0C, 0xF0,
+	0xAA, 0xFE, 0x4F, 0xF4, 0x80, 0x71, 0x00, 0x20, 0xFA, 0xF7, 0xA3, 0xFC,
+	0x00, 0xE0, 0x01, 0x70,
+	0x28, 0x46, 0xBD, 0xE8, 0xF0, 0x81, 0x2D, 0xE9, 0xF0, 0x47, 0x88, 0x46,
+	0x00, 0x28, 0x6B, 0xD0,
+	0xDF, 0xF8, 0xB0, 0xA1, 0x00, 0x21, 0x69, 0x4C, 0x9A, 0xF8, 0x00, 0x20,
+	0x89, 0x46, 0x02, 0x2A,
+	0x03, 0xD0, 0x03, 0x2A, 0x01, 0xD0, 0x05, 0x2A, 0x5D, 0xD1, 0x00, 0x21,
+	0xB8, 0xF1, 0x00, 0x0F,
+	0x00, 0xD0, 0x01, 0x21, 0xA2, 0x88, 0x00, 0xEB, 0x41, 0x00, 0x52, 0x1A,
+	0x15, 0xB2, 0x07, 0x46,
+	0xA2, 0x78, 0x29, 0x46, 0x00, 0xF0, 0x71, 0xF8, 0x5A, 0x4E, 0xA0, 0x70,
+	0x30, 0x68, 0x90, 0xF8,
+	0x90, 0x00, 0x80, 0x07, 0x04, 0xD5, 0x38, 0x46, 0x29, 0x46, 0xFF, 0xF7,
+	0x8B, 0xFF, 0x81, 0x46,
+	0x00, 0x22, 0x01, 0x21, 0xB8, 0xF1, 0x00, 0x0F, 0x1A, 0xD0, 0x00, 0x27,
+	0xDF, 0xF8, 0x48, 0xC1,
+	0x38, 0x46, 0x36, 0x68, 0x10, 0xE0, 0x00, 0xBF, 0x3C, 0xF9, 0x10, 0x30,
+	0x00, 0x2B, 0x00, 0xDA,
+	0x5B, 0x42, 0xB6, 0xF8, 0x92, 0x80, 0x43, 0x45, 0x04, 0xDD, 0x96, 0xF8,
+	0x91, 0x30, 0x7F, 0x1C,
+	0xBB, 0x42, 0x1B, 0xDD, 0x40, 0x1C, 0xC0, 0xB2, 0xA8, 0x42, 0xED, 0xDB,
+	0x11, 0x46, 0x22, 0xE0,
+	0x00, 0x23, 0x45, 0x4F, 0x18, 0x46, 0x36, 0x68, 0x0D, 0xE0, 0x00, 0xBF,
+	0x37, 0xF9, 0x10, 0xC0,
+	0xB6, 0xF8, 0x92, 0x80, 0xC4, 0x45, 0x04, 0xDD, 0x96, 0xF8, 0x91, 0xC0,
+	0x5B, 0x1C, 0x9C, 0x45,
+	0x04, 0xDD, 0x40, 0x1C, 0xC0, 0xB2, 0xA8, 0x42, 0xF0, 0xDB, 0xE7, 0xE7,
+	0x9A, 0xF8, 0x00, 0x00,
+	0x02, 0x28, 0x0B, 0xD0, 0x03, 0x28, 0x09, 0xD0, 0x05, 0x28, 0x04, 0xD1,
+	0x60, 0x78, 0x10, 0xB9,
+	0xB9, 0xF1, 0x00, 0x0F, 0x02, 0xD0, 0x61, 0x70, 0xBD, 0xE8, 0xF0, 0x87,
+	0x61, 0x70, 0x00, 0xF0,
+	0x44, 0xF9, 0xBD, 0xE8, 0xF0, 0x47, 0x02, 0x21, 0x01, 0x20, 0xFA, 0xF7,
+	0x22, 0xBC, 0x2F, 0x48,
+	0x40, 0x78, 0x70, 0x47, 0x2D, 0x48, 0x00, 0x21, 0x01, 0x22, 0x01, 0x70,
+	0x82, 0x70, 0x29, 0x4A,
+	0x12, 0x68, 0x92, 0xF8, 0x31, 0x20, 0x82, 0x80, 0x2A, 0x4A, 0x12, 0x78,
+	0x05, 0x2A, 0x02, 0xD0,
+	0x06, 0x2A, 0x00, 0xD0, 0x41, 0x70, 0x70, 0x47, 0xEC, 0xE7, 0x2D, 0xE9,
+	0xFC, 0x41, 0x80, 0x46,
+	0x22, 0x48, 0x14, 0x46, 0x0D, 0x46, 0x40, 0x78, 0x16, 0x46, 0x40, 0xB9,
+	0x1E, 0x48, 0x0A, 0x46,
+	0x7F, 0x23, 0x41, 0x46, 0x54, 0x38, 0x00, 0x94, 0x0E, 0xF0, 0x22, 0xFA,
+	0x00, 0x26, 0x19, 0x4F,
+	0x38, 0x68, 0x90, 0xF8, 0x90, 0x10, 0xC9, 0x07, 0x00, 0xD0, 0xEC, 0xB1,
+	0x16, 0x48, 0x6A, 0x00,
+	0x41, 0x46, 0x2A, 0x38, 0x11, 0xF0, 0xE1, 0xF9, 0x13, 0x4A, 0x2B, 0x46,
+	0x54, 0x3A, 0x02, 0xF1,
+	0x2A, 0x01, 0x11, 0x48, 0x0E, 0xF0, 0xE5, 0xF9, 0x38, 0x68, 0x90, 0xF8,
+	0x90, 0x10, 0x49, 0x07,
+	0x07, 0xD5, 0x90, 0xF8, 0x9A, 0x30, 0x23, 0xB1, 0x0B, 0x49, 0x2A, 0x46,
+	0x08, 0x46, 0x0E, 0xF0,
+	0x18, 0xFA, 0x30, 0x46, 0xBD, 0xE8, 0xFC, 0x81, 0xB0, 0xF9, 0x96, 0x10,
+	0xCD, 0xE9, 0x00, 0x15,
+	0x05, 0x4A, 0xB0, 0xF9, 0x94, 0x30, 0x54, 0x3A, 0x41, 0x46, 0x02, 0xF1,
+	0x2A, 0x00, 0x0E, 0xF0,
+	0x4F, 0xF9, 0xD9, 0xE7, 0x4C, 0x07, 0x10, 0x00, 0x50, 0x09, 0x01, 0x20,
+	0x30, 0x05, 0x10, 0x00,
+	0x54, 0x07, 0x10, 0x00, 0x40, 0x05, 0x10, 0x00, 0x70, 0xB5, 0x00, 0x28,
+	0x04, 0x9E, 0x0D, 0xD0,
+	0x00, 0x24, 0x06, 0xE0, 0x30, 0xF9, 0x11, 0x50, 0x9D, 0x42, 0x01, 0xDD,
+	0x95, 0x42, 0x00, 0xDB,
+	0x64, 0x1C, 0x49, 0x1E, 0xF6, 0xD2, 0xB4, 0x42, 0x01, 0xDD, 0x01, 0x20,
+	0x70, 0xBD, 0x00, 0x20,
+	0x70, 0xBD, 0x3F, 0x48, 0x00, 0x21, 0x01, 0x70, 0x41, 0x60, 0x70, 0x47,
+	0xF9, 0xE7, 0x3C, 0x48,
+	0x00, 0x78, 0x70, 0x47, 0x2D, 0xE9, 0xF3, 0x4F, 0xDF, 0xF8, 0xE8, 0xA0,
+	0x84, 0x46, 0x4F, 0xF0,
+	0x00, 0x08, 0xDA, 0xF8, 0x00, 0x00, 0xDF, 0xF8, 0xD8, 0xB0, 0x81, 0xB0,
+	0x90, 0xF8, 0x80, 0x10,
+	0x47, 0x46, 0xC9, 0x07, 0xC1, 0x46, 0x2B, 0xD0, 0x33, 0x49, 0x09, 0x78,
+	0x03, 0x29, 0x2D, 0xD0,
+	0x04, 0x29, 0x2B, 0xD0, 0x05, 0x29, 0x36, 0xD1, 0xB0, 0xF8, 0x88, 0x60,
+	0xB0, 0xF8, 0x8A, 0x50,
+	0x90, 0xF8, 0x87, 0x40, 0xBC, 0xF1, 0x00, 0x0F, 0x08, 0xD0, 0x00, 0x94,
+	0x90, 0xF8, 0x31, 0x10,
+	0x2B, 0xB2, 0x32, 0xB2, 0x60, 0x46, 0xFF, 0xF7, 0xB7, 0xFF, 0x80, 0x46,
+	0x02, 0x98, 0x50, 0xB1,
+	0x00, 0x94, 0xDA, 0xF8, 0x00, 0x00, 0x2B, 0xB2, 0x32, 0xB2, 0x90, 0xF8,
+	0x30, 0x10, 0x02, 0x98,
+	0xFF, 0xF7, 0xAA, 0xFF, 0x07, 0x46, 0xB8, 0xF1, 0x01, 0x0F, 0x0E, 0xD0,
+	0x01, 0x2F, 0x0C, 0xD0,
+	0x9B, 0xF8, 0x00, 0x10, 0x58, 0x46, 0x01, 0x29, 0x1D, 0xD0, 0x0A, 0xE0,
+	0xB0, 0xF8, 0x82, 0x60,
+	0xB0, 0xF8, 0x84, 0x50, 0x90, 0xF8, 0x86, 0x40, 0xD4, 0xE7, 0x9B, 0xF8,
+	0x00, 0x10, 0x58, 0x46,
+	0x19, 0xB1, 0xCB, 0xF8, 0x04, 0x90, 0xBD, 0xE8, 0xFE, 0x8F, 0x41, 0x68,
+	0x49, 0x1C, 0x41, 0x60,
+	0xDA, 0xF8, 0x00, 0x20, 0x92, 0xF8, 0x81, 0x20, 0x8A, 0x42, 0xF4, 0xDA,
+	0x01, 0x21, 0x01, 0x70,
+	0xCB, 0xF8, 0x04, 0x90, 0x0D, 0xE0, 0x41, 0x68, 0x49, 0x1C, 0x41, 0x60,
+	0xDA, 0xF8, 0x00, 0x20,
+	0x92, 0xF8, 0x81, 0x20, 0x8A, 0x42, 0xE6, 0xDA, 0x80, 0xF8, 0x00, 0x90,
+	0x00, 0x21, 0xCB, 0xF8,
+	0x04, 0x90, 0x03, 0xB0, 0x07, 0x20, 0xBD, 0xE8, 0xF0, 0x4F, 0x0C, 0xF0,
+	0x2C, 0xBD, 0x00, 0x00,
+	0x38, 0x05, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00, 0x40, 0x05, 0x10, 0x00,
+	0x22, 0x49, 0x08, 0xB5,
+	0x00, 0x20, 0x48, 0x60, 0x01, 0x22, 0x88, 0x60, 0x0A, 0x70, 0x48, 0x70,
+	0x1F, 0x49, 0x08, 0x70,
+	0x1F, 0x49, 0x08, 0x70, 0xFF, 0xF7, 0x08, 0xFF, 0xFF, 0xF7, 0x70, 0xFF,
+	0xFF, 0xF7, 0x5F, 0xFB,
+	0xFF, 0xF7, 0x8F, 0xFD, 0x6B, 0x46, 0x00, 0x22, 0x1E, 0x21, 0x01, 0x20,
+	0xFA, 0xF7, 0x52, 0xFB,
+	0x00, 0x98, 0x41, 0x07, 0x03, 0xD5, 0xFF, 0xF7, 0x5B, 0xFA, 0x04, 0x21,
+	0x08, 0xE0, 0x01, 0x07,
+	0x03, 0xD5, 0xFF, 0xF7, 0x73, 0xF8, 0x08, 0x21, 0x02, 0xE0, 0xC1, 0x06,
+	0x04, 0xD5, 0x10, 0x21,
+	0x01, 0x20, 0xFA, 0xF7, 0x22, 0xFB, 0xE5, 0xE7, 0x80, 0x07, 0xE3, 0xD5,
+	0x02, 0x21, 0x01, 0x20,
+	0xFA, 0xF7, 0x1B, 0xFB, 0xFF, 0xF7, 0x3F, 0xFB, 0xDC, 0xE7, 0x00, 0xEB,
+	0x80, 0x00, 0x4F, 0xF6,
+	0xFF, 0x72, 0x02, 0xEA, 0x40, 0x00, 0xFB, 0xF7, 0xAA, 0xBC, 0xFB, 0xF7,
+	0xB8, 0xBC, 0x80, 0xB2,
+	0xFB, 0xF7, 0xE9, 0xBB, 0xFB, 0xF7, 0xFB, 0xBB, 0x40, 0x05, 0x10, 0x00,
+	0x78, 0x07, 0x10, 0x00,
+	0x7D, 0x07, 0x10, 0x00, 0x01, 0xF0, 0x41, 0xBA, 0x5E, 0x48, 0x5F, 0x49,
+	0x00, 0x7E, 0x09, 0x7E,
+	0xC8, 0x42, 0x09, 0xD1, 0x5D, 0x48, 0x00, 0x78, 0x80, 0x06, 0x05, 0xD5,
+	0x01, 0x23, 0x5C, 0x4A,
+	0x59, 0x49, 0x58, 0x48, 0x00, 0xF0, 0x00, 0xBD, 0x70, 0x47, 0x3C, 0xB5,
+	0x00, 0x23, 0x00, 0x93,
+	0x01, 0x93, 0x6B, 0x46, 0x07, 0xE0, 0x44, 0x18, 0x64, 0x78, 0x14, 0xB1,
+	0x1D, 0x5D, 0x6D, 0x1C,
+	0x1D, 0x55, 0x49, 0x1C, 0xC9, 0xB2, 0x91, 0x42, 0xF5, 0xD9, 0x00, 0x20,
+	0x01, 0x21, 0x1C, 0x5C,
+	0x5A, 0x5C, 0xA2, 0x42, 0x00, 0xD9, 0x08, 0x46, 0x49, 0x1C, 0xC9, 0xB2,
+	0x06, 0x29, 0xF6, 0xD3,
+	0x3C, 0xBD, 0x70, 0xB5, 0x04, 0x46, 0x00, 0x20, 0x08, 0x70, 0x0E, 0x46,
+	0x10, 0x70, 0x45, 0x48,
+	0x45, 0x49, 0x15, 0x46, 0x00, 0x7E, 0x09, 0x7E, 0xC8, 0x42, 0x0B, 0xD0,
+	0xE2, 0x78, 0xA1, 0x78,
+	0x44, 0x48, 0xFF, 0xF7, 0xD2, 0xFF, 0x30, 0x70, 0x62, 0x78, 0x21, 0x78,
+	0x42, 0x48, 0xFF, 0xF7,
+	0xCC, 0xFF, 0x28, 0x70, 0x70, 0xBD, 0x70, 0xB5, 0x00, 0x24, 0x01, 0x23,
+	0x05, 0x7E, 0x08, 0xE0,
+	0xC6, 0x18, 0x96, 0xF9, 0x12, 0x60, 0x8E, 0x42, 0x02, 0xDB, 0x96, 0x42,
+	0x00, 0xDC, 0x64, 0x1C,
+	0x5B, 0x1C, 0x9D, 0x42, 0xF4, 0xD2, 0x01, 0x2C, 0x01, 0xDC, 0x01, 0x20,
+	0x70, 0xBD, 0x00, 0x20,
+	0x70, 0xBD, 0x2D, 0xE9, 0xF0, 0x43, 0x99, 0x46, 0x00, 0x23, 0x1F, 0x46,
+	0x47, 0xF6, 0xFF, 0x76,
+	0x4F, 0xF0, 0xFF, 0x3C, 0x01, 0x25, 0x04, 0x7E, 0x0D, 0xE0, 0x00, 0xBF,
+	0x00, 0xEB, 0x05, 0x08,
+	0x98, 0xF9, 0x12, 0x80, 0x88, 0x45, 0x05, 0xDB, 0x90, 0x45, 0x03, 0xDC,
+	0x43, 0x19, 0x93, 0xF9,
+	0x12, 0x30, 0x02, 0xE0, 0x6D, 0x1C, 0xAC, 0x42, 0xF0, 0xD2, 0x64, 0x1C,
+	0x0A, 0xE0, 0x05, 0x19,
+	0x95, 0xF9, 0x12, 0x50, 0x8D, 0x42, 0x05, 0xDB, 0x95, 0x42, 0x03, 0xDC,
+	0x20, 0x44, 0x90, 0xF9,
+	0x12, 0x70, 0x01, 0xE0, 0x64, 0x1E, 0xF2, 0xD1, 0xBB, 0x42, 0x09, 0xD1,
+	0x0A, 0xE0, 0x00, 0xBF,
+	0x39, 0xF9, 0x13, 0x00, 0xB0, 0x42, 0x02, 0xDA, 0x06, 0x46, 0x4F, 0xFA,
+	0x83, 0xFC, 0x5B, 0x1C,
+	0xBB, 0x42, 0xF5, 0xDD, 0x60, 0x46, 0xBD, 0xE8, 0xF0, 0x83, 0x2D, 0xE9,
+	0xF0, 0x41, 0x17, 0x46,
+	0x0E, 0x46, 0x04, 0x46, 0xC2, 0x78, 0x81, 0x78, 0x0E, 0x48, 0xFF, 0xF7,
+	0xA4, 0xFF, 0x05, 0x00,
+	0x06, 0xD1, 0xE2, 0x78, 0xA1, 0x78, 0x11, 0x4B, 0x0A, 0x48, 0xFF, 0xF7,
+	0xB2, 0xFF, 0x30, 0x70,
+	0x62, 0x78, 0x21, 0x78, 0x08, 0x48, 0xFF, 0xF7, 0x96, 0xFF, 0x06, 0x00,
+	0x06, 0xD1, 0x62, 0x78,
+	0x21, 0x78, 0x0B, 0x4B, 0x04, 0x48, 0xFF, 0xF7, 0xA4, 0xFF, 0x38, 0x70,
+	0x05, 0xEA, 0x06, 0x00,
+	0xBD, 0xE8, 0xF0, 0x81, 0x18, 0x2A, 0x10, 0x00, 0x58, 0x2A, 0x10, 0x00,
+	0x04, 0x07, 0x10, 0x00,
+	0x40, 0x2B, 0x10, 0x00, 0x0A, 0x0C, 0x01, 0x20, 0x21, 0x0C, 0x01, 0x20,
+	0x94, 0x0B, 0x01, 0x20,
+	0xBE, 0x0B, 0x01, 0x20, 0x24, 0x48, 0x00, 0x21, 0x01, 0x61, 0x41, 0x61,
+	0x23, 0x48, 0x01, 0x70,
+	0x01, 0x21, 0x41, 0x70, 0x70, 0x47, 0x2D, 0xE9, 0xF8, 0x4F, 0x20, 0x4D,
+	0x82, 0x46, 0x0E, 0x46,
+	0x1D, 0x48, 0x69, 0x78, 0x10, 0x30, 0x01, 0x29, 0x0F, 0xD1, 0x1D, 0x49,
+	0x09, 0x68, 0x91, 0xF8,
+	0x40, 0x2A, 0x02, 0xF0, 0x0F, 0x03, 0x03, 0x80, 0x12, 0x09, 0x42, 0x80,
+	0x91, 0xF8, 0x41, 0x1A,
+	0x01, 0xF0, 0x0F, 0x02, 0x82, 0x80, 0x09, 0x09, 0xC1, 0x80, 0x13, 0x49,
+	0x00, 0x27, 0x3C, 0x46,
+	0x8F, 0x60, 0xCF, 0x60, 0x80, 0x46, 0x89, 0x46, 0x0B, 0xE0, 0x68, 0x78,
+	0x00, 0x90, 0x38, 0xF9,
+	0x14, 0x30, 0x0A, 0xEB, 0x44, 0x01, 0x09, 0xEB, 0x44, 0x00, 0x01, 0x22,
+	0x0D, 0xF0, 0xDE, 0xFF,
+	0x64, 0x1C, 0xB4, 0x42, 0xF1, 0xDB, 0x6F, 0x70, 0x03, 0x20, 0xFA, 0xF7,
+	0xAA, 0xFA, 0x06, 0x49,
+	0x33, 0x46, 0x08, 0x4A, 0x01, 0xF1, 0x08, 0x00, 0x0D, 0xF0, 0xC3, 0xFF,
+	0xBD, 0xE8, 0xF8, 0x4F,
+	0x03, 0x20, 0xFA, 0xF7, 0xB9, 0xBA, 0x00, 0x00, 0x7A, 0x09, 0x01, 0x20,
+	0x55, 0x05, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0xFC, 0x4A, 0x01, 0x20, 0x2D, 0xE9, 0xF0, 0x5F,
+	0x82, 0x46, 0x5E, 0x48,
+	0x99, 0x46, 0x3A, 0xF9, 0x12, 0x30, 0x00, 0x68, 0x01, 0x26, 0x0A, 0x9C,
+	0xB0, 0xF9, 0x3E, 0xB2,
+	0x03, 0xFB, 0x02, 0xF0, 0x35, 0x46, 0x29, 0xE0, 0x57, 0x1B, 0x7F, 0xB2,
+	0x00, 0x2F, 0x0F, 0xDB,
+	0x76, 0xB1, 0x3A, 0xF9, 0x17, 0xC0, 0xDC, 0x45, 0x09, 0xDD, 0x0A, 0xEB,
+	0x47, 0x08, 0xB8, 0xF9,
+	0x02, 0x80, 0xC4, 0x45, 0x03, 0xDC, 0x0C, 0xFB, 0x07, 0x00, 0x63, 0x44,
+	0x00, 0xE0, 0x00, 0x26,
+	0x57, 0x19, 0x7F, 0xB2, 0x8F, 0x42, 0x0F, 0xDA, 0x76, 0xB1, 0x3A, 0xF9,
+	0x17, 0xC0, 0xDC, 0x45,
+	0x09, 0xDD, 0x0A, 0xEB, 0x47, 0x08, 0x38, 0xF9, 0x02, 0x8C, 0xC4, 0x45,
+	0x03, 0xDC, 0x0C, 0xFB,
+	0x07, 0x00, 0x63, 0x44, 0x00, 0xE0, 0x00, 0x26, 0x6D, 0x1C, 0xED, 0xB2,
+	0x4D, 0x45, 0xD3, 0xD9,
+	0x49, 0x1E, 0x83, 0xFB, 0x01, 0x23, 0x80, 0xFB, 0x04, 0x01, 0x10, 0xF0,
+	0x42, 0xFF, 0x00, 0x28,
+	0x00, 0xDA, 0x00, 0x20, 0x61, 0x1E, 0x88, 0x42, 0x00, 0xDD, 0x08, 0x46,
+	0xBD, 0xE8, 0xF0, 0x9F,
+	0x70, 0xB5, 0x00, 0x20, 0x96, 0xB0, 0x04, 0x46, 0x38, 0x4D, 0x34, 0xE0,
+	0x22, 0x46, 0x37, 0x49,
+	0x01, 0xA8, 0x00, 0xF0, 0x35, 0xF8, 0x34, 0x4E, 0x30, 0x68, 0xB0, 0xF9,
+	0x34, 0x10, 0x00, 0x91,
+	0x90, 0xF8, 0x40, 0x32, 0x32, 0x48, 0x2A, 0x57, 0x01, 0x78, 0x32, 0x48,
+	0xFF, 0xF7, 0x9C, 0xFF,
+	0x13, 0x90, 0x30, 0x68, 0xB0, 0xF9, 0x32, 0x10, 0x00, 0x91, 0x90, 0xF8,
+	0x40, 0x32, 0x28, 0x19,
+	0x90, 0xF9, 0x02, 0x20, 0x2C, 0x48, 0x01, 0x78, 0x2C, 0x48, 0xFF, 0xF7,
+	0x8D, 0xFF, 0x14, 0x90,
+	0x13, 0xA8, 0x07, 0xF0, 0xB5, 0xF8, 0x14, 0x99, 0xAD, 0xF8, 0x12, 0x10,
+	0x13, 0x98, 0xAD, 0xF8,
+	0x16, 0x10, 0xAD, 0xF8, 0x10, 0x00, 0xAD, 0xF8, 0x14, 0x00, 0x01, 0xA8,
+	0x05, 0xF0, 0xB5, 0xFE,
+	0x01, 0x20, 0x64, 0x1C, 0xE4, 0xB2, 0x29, 0x7A, 0xA1, 0x42, 0xC7, 0xD8,
+	0x16, 0xB0, 0x70, 0xBD,
+	0x70, 0xB5, 0x0E, 0x46, 0x15, 0x46, 0x04, 0x46, 0x48, 0x21, 0x10, 0xF0,
+	0xB7, 0xFF, 0x71, 0x19,
+	0x08, 0x79, 0x8A, 0x79, 0x50, 0x43, 0x03, 0x22, 0x84, 0xF8, 0x40, 0x20,
+	0x18, 0x4A, 0x12, 0x88,
+	0x52, 0x1C, 0x62, 0x86, 0xA2, 0x8C, 0x42, 0xF0, 0x20, 0x02, 0xA2, 0x84,
+	0xE0, 0x84, 0x60, 0x85,
+	0x42, 0x1C, 0x22, 0x85, 0x41, 0xF2, 0x88, 0x32, 0xE2, 0x61, 0xA2, 0x61,
+	0x0A, 0x79, 0x8B, 0x79,
+	0xD1, 0x18, 0x00, 0xD1, 0x01, 0x21, 0x42, 0x43, 0x58, 0x43, 0x52, 0x00,
+	0x40, 0x00, 0xB2, 0xFB,
+	0xF1, 0xF2, 0xB0, 0xFB, 0xF1, 0xF0, 0x82, 0x42, 0x02, 0xD9, 0xE2, 0x85,
+	0x20, 0x86, 0x70, 0xBD,
+	0xE0, 0x85, 0x22, 0x86, 0x70, 0xBD, 0x00, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x0C, 0x2A, 0x10, 0x00,
+	0xED, 0x06, 0x10, 0x00, 0x94, 0x0B, 0x01, 0x20, 0xEE, 0x06, 0x10, 0x00,
+	0xBE, 0x0B, 0x01, 0x20,
+	0x8C, 0x06, 0x10, 0x00, 0x2D, 0xE9, 0xF0, 0x47, 0x00, 0x25, 0x82, 0x46,
+	0xA6, 0xB0, 0x50, 0x1E,
+	0xC7, 0xB2, 0x2C, 0x46, 0x28, 0x46, 0x6B, 0x46, 0x0D, 0xF1, 0x4C, 0x09,
+	0x12, 0xE0, 0x00, 0xBF,
+	0x31, 0xF9, 0x10, 0x60, 0x35, 0x44, 0x46, 0x1C, 0xB4, 0x46, 0x95, 0xFB,
+	0xF6, 0xF6, 0x23, 0xF8,
+	0x10, 0x60, 0x3E, 0x1A, 0x40, 0x1C, 0x31, 0xF9, 0x16, 0x80, 0x44, 0x44,
+	0x94, 0xFB, 0xFC, 0xFC,
+	0x29, 0xF8, 0x16, 0xC0, 0x90, 0x42, 0xEB, 0xDB, 0x48, 0x46, 0x0C, 0xE0,
+	0x33, 0xF9, 0x12, 0x40,
+	0x30, 0xF9, 0x12, 0x50, 0x2C, 0x44, 0x31, 0xF8, 0x12, 0x50, 0x04, 0xEB,
+	0xD4, 0x74, 0xA5, 0xEB,
+	0x64, 0x04, 0x2A, 0xF8, 0x12, 0x40, 0x52, 0x1E, 0xF0, 0xD2, 0x26, 0xB0,
+	0xBD, 0xE8, 0xF0, 0x87,
+	0x2D, 0xE9, 0xFF, 0x4F, 0x4F, 0xF0, 0x00, 0x0B, 0xA7, 0xB0, 0xC0, 0xF8,
+	0x00, 0xB0, 0x81, 0x46,
+	0xC0, 0xF8, 0x04, 0xB0, 0x98, 0x46, 0x14, 0x46, 0x5D, 0x46, 0x5E, 0x46,
+	0xDA, 0x46, 0x5F, 0x46,
+	0x28, 0x21, 0x01, 0xA8, 0x10, 0xF0, 0x32, 0xFF, 0x4C, 0x21, 0x0B, 0xA8,
+	0x10, 0xF0, 0x2E, 0xFF,
+	0xCD, 0xF8, 0x00, 0x80, 0x02, 0x23, 0x22, 0x46, 0x0B, 0xA8, 0x28, 0x99,
+	0x0D, 0xF0, 0x9E, 0xFE,
+	0x8E, 0x49, 0x01, 0x20, 0x02, 0x46, 0x00, 0x23, 0x0D, 0xF1, 0x04, 0x0E,
+	0xD1, 0xF8, 0x00, 0x80,
+	0x17, 0xE0, 0x0B, 0xA9, 0x31, 0xF9, 0x10, 0xC0, 0xB8, 0xF9, 0x4C, 0x12,
+	0x8C, 0x45, 0x04, 0xDD,
+	0x4F, 0xF0, 0x01, 0x0B, 0x0E, 0xF8, 0x00, 0x20, 0x0A, 0xE0, 0x49, 0x42,
+	0x8C, 0x45, 0x05, 0xDA,
+	0xFF, 0x21, 0x4F, 0xF0, 0x01, 0x0B, 0x0E, 0xF8, 0x00, 0x10, 0x01, 0xE0,
+	0x0E, 0xF8, 0x00, 0x30,
+	0x40, 0x1C, 0xA0, 0x42, 0xE5, 0xDB, 0xBB, 0xF1, 0x01, 0x0F, 0x42, 0xD1,
+	0x01, 0x20, 0x71, 0x46,
+	0x09, 0xE0, 0x0A, 0x5C, 0x32, 0xB1, 0xC5, 0xB2, 0x08, 0x56, 0x00, 0x28,
+	0x05, 0xDD, 0x4F, 0xF0,
+	0x01, 0x0A, 0x02, 0xE0, 0x40, 0x1C, 0xA0, 0x42, 0xF3, 0xDB, 0x60, 0x1E,
+	0x07, 0xE0, 0x0A, 0x5C,
+	0x2A, 0xB1, 0xC6, 0xB2, 0x08, 0x56, 0x00, 0x28, 0x03, 0xDA, 0x01, 0x27,
+	0x01, 0xE0, 0x40, 0x1E,
+	0xF5, 0xD2, 0xA4, 0xF1, 0x01, 0x08, 0xBA, 0xF1, 0x00, 0x0F, 0x01, 0xD0,
+	0x97, 0xB9, 0x02, 0xE0,
+	0x4F, 0xF0, 0x01, 0x05, 0x77, 0xB9, 0x08, 0xF0, 0xFF, 0x06, 0x0B, 0xE0,
+	0xD9, 0xE9, 0x00, 0x47,
+	0x2A, 0x46, 0x01, 0x20, 0x00, 0x21, 0x10, 0xF0, 0xF9, 0xFD, 0x04, 0x43,
+	0x0F, 0x43, 0xC9, 0xE9,
+	0x00, 0x47, 0x6D, 0x1C, 0xB5, 0x42, 0xF1, 0xDD, 0xD9, 0xE9, 0x00, 0x04,
+	0x40, 0xF0, 0x01, 0x05,
+	0x42, 0x46, 0x01, 0x20, 0x00, 0x21, 0x10, 0xF0, 0xE9, 0xFD, 0x05, 0x43,
+	0x0C, 0x43, 0xC9, 0xE9,
+	0x00, 0x54, 0x2B, 0xB0, 0xBD, 0xE8, 0xF0, 0x8F, 0x2D, 0xE9, 0xF8, 0x43,
+	0x05, 0x46, 0x16, 0x46,
+	0x0F, 0x46, 0x03, 0x20, 0xFA, 0xF7, 0xFD, 0xF8, 0x55, 0x4C, 0x56, 0x4A,
+	0x29, 0x46, 0x23, 0x78,
+	0x55, 0x48, 0x0D, 0xF0, 0x16, 0xFE, 0x55, 0x4D, 0x53, 0x48, 0x55, 0x4A,
+	0x2B, 0x78, 0x39, 0x46,
+	0x2A, 0x30, 0x0D, 0xF0, 0x0E, 0xFE, 0x03, 0x20, 0xFA, 0xF7, 0x06, 0xF9,
+	0xDF, 0xF8, 0x2C, 0x81,
+	0xD8, 0xF8, 0x00, 0x00, 0x90, 0xF8, 0xE0, 0x13, 0x89, 0x07, 0x12, 0xD5,
+	0x90, 0xF8, 0xF4, 0x03,
+	0x00, 0x96, 0x00, 0xF0, 0x0F, 0x07, 0x3B, 0x46, 0x22, 0x78, 0x47, 0x49,
+	0x49, 0x48, 0x0D, 0xF0,
+	0x05, 0xFE, 0x45, 0x49, 0x00, 0x96, 0x3B, 0x46, 0x2A, 0x78, 0x2A, 0x31,
+	0x46, 0x48, 0x0D, 0xF0,
+	0xFD, 0xFD, 0x22, 0x78, 0x40, 0x49, 0x45, 0x48, 0x00, 0xF0, 0x5B, 0xF8,
+	0x3E, 0x49, 0x2A, 0x78,
+	0x2A, 0x31, 0x43, 0x48, 0x00, 0xF0, 0x55, 0xF8, 0x42, 0x4F, 0x00, 0x96,
+	0x22, 0x78, 0x3F, 0x49,
+	0x41, 0x48, 0x3B, 0x68, 0x0D, 0xF0, 0xEA, 0xFD, 0x00, 0x96, 0x2A, 0x78,
+	0x3C, 0x49, 0x3F, 0x48,
+	0x3B, 0x68, 0x0D, 0xF0, 0xE3, 0xFD, 0xD8, 0xF8, 0x00, 0x00, 0x47, 0x46,
+	0x90, 0xF8, 0x30, 0x02,
+	0xC0, 0x06, 0x0A, 0xD5, 0x22, 0x78, 0x38, 0x49, 0x39, 0x48, 0xFF, 0xF7,
+	0xE3, 0xFE, 0x2A, 0x78,
+	0x36, 0x49, 0x38, 0x48, 0xFF, 0xF7, 0xDE, 0xFE, 0x0B, 0xE0, 0x20, 0x78,
+	0x32, 0x49, 0x42, 0x00,
+	0x33, 0x48, 0x10, 0xF0, 0xB2, 0xFD, 0x28, 0x78, 0x30, 0x49, 0x42, 0x00,
+	0x31, 0x48, 0x10, 0xF0,
+	0xAC, 0xFD, 0x38, 0x68, 0x90, 0xF8, 0x30, 0x02, 0x80, 0x06, 0x04, 0xD5,
+	0x2C, 0x49, 0x22, 0x78,
+	0x08, 0x46, 0x00, 0xF0, 0x30, 0xF8, 0x38, 0x68, 0x90, 0xF8, 0x30, 0x02,
+	0x40, 0x06, 0x04, 0xD5,
+	0x28, 0x49, 0x2A, 0x78, 0x08, 0x46, 0x00, 0xF0, 0x26, 0xF8, 0x33, 0x46,
+	0x22, 0x78, 0x1A, 0x49,
+	0x25, 0x48, 0xFF, 0xF7, 0xED, 0xFE, 0x2A, 0x78, 0x01, 0xB0, 0x33, 0x46,
+	0xBD, 0xE8, 0xF0, 0x43,
+	0x15, 0x49, 0x21, 0x48, 0x2A, 0x31, 0x08, 0x30, 0xE2, 0xE6, 0x20, 0x49,
+	0x00, 0x20, 0x08, 0x70,
+	0x70, 0x47, 0x30, 0xB5, 0x00, 0x23, 0x03, 0x80, 0x01, 0x23, 0x09, 0xE0,
+	0x00, 0xEB, 0x43, 0x04,
+	0x31, 0xF8, 0x13, 0x50, 0x34, 0xF8, 0x02, 0x4C, 0x2C, 0x44, 0x20, 0xF8,
+	0x13, 0x40, 0x5B, 0x1C,
+	0x93, 0x42, 0xF3, 0xDB, 0x30, 0xBD, 0x08, 0xB5, 0x00, 0x92, 0x04, 0x4A,
+	0x12, 0x68, 0xB2, 0xF9,
+	0x4A, 0x32, 0xB2, 0xF9, 0x48, 0x22, 0x02, 0xF0, 0x78, 0xFA, 0x08, 0xBD,
+	0x4C, 0x07, 0x10, 0x00,
+	0xED, 0x06, 0x10, 0x00, 0x7E, 0x4A, 0x01, 0x20, 0x92, 0x09, 0x01, 0x20,
+	0xEE, 0x06, 0x10, 0x00,
+	0xA8, 0x4A, 0x01, 0x20, 0xC8, 0x2A, 0x10, 0x00, 0xF2, 0x2A, 0x10, 0x00,
+	0xA0, 0x0A, 0x01, 0x20,
+	0xCE, 0x0A, 0x01, 0x20, 0x9C, 0x06, 0x10, 0x00, 0x1E, 0x0B, 0x01, 0x20,
+	0x48, 0x0B, 0x01, 0x20,
+	0x94, 0x0B, 0x01, 0x20, 0xBE, 0x0B, 0x01, 0x20, 0x50, 0x2B, 0x10, 0x00,
+	0xF4, 0x06, 0x10, 0x00,
+	0x10, 0xB5, 0x40, 0x21, 0xFE, 0x48, 0x10, 0xF0, 0xE1, 0xFD, 0xFD, 0x48,
+	0x40, 0x21, 0x40, 0x30,
+	0x10, 0xF0, 0xDC, 0xFD, 0xFA, 0x48, 0x00, 0x21, 0x80, 0x30, 0xC0, 0xE9,
+	0x00, 0x11, 0xC0, 0xE9,
+	0x02, 0x11, 0x10, 0x30, 0xC0, 0xE9, 0x00, 0x11, 0xC0, 0xE9, 0x02, 0x11,
+	0x10, 0x30, 0xC0, 0xE9,
+	0x00, 0x11, 0xC0, 0xE9, 0x02, 0x11, 0x08, 0x46, 0xF2, 0x49, 0x08, 0x60,
+	0x10, 0xBD, 0x2D, 0xE9,
+	0xFF, 0x5F, 0x06, 0x46, 0x89, 0x46, 0xF0, 0x48, 0xF0, 0x49, 0x98, 0x46,
+	0x00, 0x78, 0x09, 0x68,
+	0x14, 0x46, 0x01, 0x28, 0x50, 0xD0, 0xB1, 0xF9, 0x86, 0xA2, 0x91, 0xF8,
+	0x88, 0x52, 0xB1, 0xF9,
+	0x82, 0x72, 0x11, 0x46, 0x48, 0x46, 0x0D, 0xF0, 0xAE, 0xFD, 0x83, 0x46,
+	0x21, 0x46, 0x48, 0x46,
+	0x0D, 0xF0, 0xB4, 0xFD, 0x00, 0x90, 0x39, 0x46, 0x58, 0x46, 0x0C, 0xF0,
+	0x91, 0xFD, 0x0F, 0xFA,
+	0x80, 0xFB, 0x39, 0x46, 0x00, 0x98, 0x0C, 0xF0, 0x8B, 0xFD, 0x00, 0xB2,
+	0xAB, 0xEB, 0x00, 0x00,
+	0x68, 0x43, 0x64, 0x21, 0x90, 0xFB, 0xF1, 0xF0, 0x38, 0x44, 0x05, 0xB2,
+	0xA8, 0xF8, 0x08, 0x50,
+	0x70, 0x1C, 0x00, 0x21, 0x03, 0x90, 0xC8, 0xF8, 0x00, 0x10, 0xC8, 0xF8,
+	0x04, 0x10, 0xB9, 0xF9,
+	0x00, 0x00, 0xA8, 0x42, 0x02, 0xDD, 0x03, 0x99, 0x01, 0x20, 0x08, 0x70,
+	0x09, 0xEB, 0x44, 0x00,
+	0x76, 0x1C, 0x30, 0xF9, 0x02, 0x2C, 0x31, 0x19, 0xAA, 0x42, 0x02, 0xDD,
+	0x01, 0x22, 0x01, 0xF8,
+	0x01, 0x2C, 0xB9, 0xF9, 0x02, 0x30, 0x03, 0xEB, 0x0A, 0x02, 0x12, 0xB2,
+	0xAB, 0x42, 0x18, 0xDD,
+	0xB9, 0xF9, 0x00, 0x30, 0x93, 0x42, 0x03, 0xDD, 0xB9, 0xF9, 0x04, 0x30,
+	0x93, 0x42, 0x0A, 0xDC,
+	0x03, 0x9B, 0x01, 0x22, 0x5A, 0x70, 0x0C, 0xE0, 0xB1, 0xF9, 0x69, 0xA2,
+	0x91, 0xF8, 0x64, 0x52,
+	0xB1, 0xF9, 0x65, 0x72, 0xAD, 0xE7, 0xD8, 0xF8, 0x00, 0x60, 0x46, 0xF0,
+	0x02, 0x06, 0xC8, 0xF8,
+	0x00, 0x60, 0x30, 0xF9, 0x04, 0x3C, 0xA4, 0xF1, 0x02, 0x0B, 0x03, 0xEB,
+	0x0A, 0x02, 0x12, 0xB2,
+	0xAB, 0x42, 0x16, 0xDD, 0x30, 0xF9, 0x06, 0x3C, 0x93, 0x42, 0x03, 0xDD,
+	0x30, 0xF9, 0x02, 0x0C,
+	0x90, 0x42, 0x03, 0xDC, 0x01, 0x20, 0x01, 0xF8, 0x02, 0x0C, 0x0A, 0xE0,
+	0xD8, 0xE9, 0x00, 0x64,
+	0x5A, 0x46, 0x01, 0x20, 0x00, 0x21, 0x10, 0xF0, 0x69, 0xFC, 0x06, 0x43,
+	0x0C, 0x43, 0xC8, 0xE9,
+	0x00, 0x64, 0x02, 0x24, 0x58, 0xE0, 0x00, 0xBF, 0x39, 0xF9, 0x14, 0x00,
+	0xA8, 0x42, 0x52, 0xDD,
+	0x09, 0xEB, 0x44, 0x01, 0x02, 0x91, 0x50, 0x44, 0x31, 0xF9, 0x02, 0x1C,
+	0x00, 0xB2, 0x81, 0x42,
+	0x04, 0xDD, 0x02, 0x9A, 0xB2, 0xF9, 0x02, 0x20, 0x82, 0x42, 0x10, 0xDC,
+	0x02, 0x9A, 0x32, 0xF9,
+	0x04, 0x2C, 0x82, 0x42, 0x04, 0xDD, 0x02, 0x9A, 0xB2, 0xF9, 0x02, 0x20,
+	0x82, 0x42, 0x06, 0xDC,
+	0x81, 0x42, 0x35, 0xDD, 0x02, 0x99, 0xB1, 0xF9, 0x04, 0x10, 0x81, 0x42,
+	0x30, 0xDD, 0xD8, 0xE9,
+	0x00, 0x67, 0x22, 0x46, 0x01, 0x20, 0x00, 0x21, 0x10, 0xF0, 0x38, 0xFC,
+	0xCD, 0xE9, 0x00, 0x01,
+	0x06, 0x43, 0x0F, 0x43, 0x62, 0x1E, 0x01, 0x20, 0x00, 0x21, 0xC8, 0xE9,
+	0x00, 0x67, 0x10, 0xF0,
+	0x2D, 0xFC, 0x02, 0x46, 0x0B, 0x46, 0x06, 0xEA, 0x02, 0x00, 0x07, 0xEA,
+	0x03, 0x01, 0x08, 0x43,
+	0x19, 0xD0, 0x02, 0x98, 0x39, 0xF9, 0x14, 0x10, 0x30, 0xF9, 0x02, 0x0C,
+	0x81, 0x42, 0x09, 0xDA,
+	0x96, 0x43, 0x9F, 0x43, 0xC8, 0xE9, 0x00, 0x67, 0x03, 0x99, 0x01, 0x20,
+	0x21, 0x44, 0x01, 0xF8,
+	0x01, 0x0C, 0x08, 0xE0, 0xDD, 0xE9, 0x00, 0x10, 0x8E, 0x43, 0x87, 0x43,
+	0xC8, 0xE9, 0x00, 0x67,
+	0x03, 0x99, 0x01, 0x20, 0x08, 0x55, 0x64, 0x1C, 0x5C, 0x45, 0xA5, 0xD3,
+	0xBD, 0xE8, 0xFF, 0x9F,
+	0x2D, 0xE9, 0xFF, 0x4F, 0x81, 0xB0, 0x82, 0x46, 0x00, 0x21, 0x1D, 0x46,
+	0x19, 0x76, 0x06, 0x20,
+	0x90, 0x46, 0xC3, 0x1F, 0x7A, 0x4C, 0x07, 0xE0, 0x00, 0x22, 0x29, 0x18,
+	0x0A, 0x73, 0x8B, 0x74,
+	0x05, 0xEB, 0x40, 0x01, 0x22, 0x88, 0x0A, 0x80, 0x40, 0x1E, 0xF5, 0xD2,
+	0x72, 0x48, 0x01, 0x78,
+	0x72, 0x48, 0x01, 0x29, 0x00, 0x68, 0x06, 0xD0, 0xB0, 0xF9, 0x84, 0x22,
+	0x4F, 0xF0, 0x00, 0x0B,
+	0x59, 0x46, 0x58, 0x46, 0x16, 0xE0, 0xB0, 0xF9, 0x67, 0x22, 0xF7, 0xE7,
+	0x0A, 0xEB, 0x00, 0x03,
+	0x5C, 0x78, 0x74, 0xB1, 0x1A, 0xF8, 0x00, 0x40, 0x0C, 0xB9, 0x49, 0x1C,
+	0xC9, 0xB2, 0x59, 0x70,
+	0x02, 0x9B, 0x33, 0xF9, 0x10, 0x30, 0x93, 0x42, 0x03, 0xDD, 0x01, 0x23,
+	0x8B, 0x40, 0x43, 0xEA,
+	0x0B, 0x0B, 0x40, 0x1C, 0x40, 0x45, 0xE9, 0xD3, 0x62, 0x48, 0x00, 0x90,
+	0x0E, 0x98, 0x4F, 0xF0,
+	0x00, 0x09, 0x4C, 0x46, 0xC0, 0xE9, 0x00, 0x99, 0x37, 0xE0, 0x00, 0xBF,
+	0x0A, 0xEB, 0x04, 0x00,
+	0x42, 0x78, 0x8A, 0xB3, 0x01, 0x21, 0x91, 0x40, 0x11, 0xEA, 0x0B, 0x0F,
+	0x02, 0xD1, 0x00, 0x21,
+	0x41, 0x70, 0x29, 0xE0, 0x1A, 0xF8, 0x04, 0x10, 0x39, 0xB9, 0x09, 0xF1,
+	0x01, 0x01, 0x01, 0xF0,
+	0xFF, 0x09, 0x54, 0x49, 0x00, 0x91, 0x05, 0xF8, 0x19, 0x40, 0x80, 0xF8,
+	0x01, 0x90, 0x0E, 0x98,
+	0x22, 0x46, 0x00, 0x21, 0xD0, 0xE9, 0x00, 0x67, 0x01, 0x20, 0x10, 0xF0,
+	0x9F, 0xFB, 0x06, 0x43,
+	0x0E, 0x98, 0x0F, 0x43, 0xC0, 0xE9, 0x00, 0x67, 0x05, 0xEB, 0x09, 0x00,
+	0x01, 0x7B, 0x49, 0x1C,
+	0x01, 0x73, 0x05, 0xEB, 0x49, 0x01, 0x4C, 0x70, 0x02, 0x99, 0x00, 0x9A,
+	0x31, 0xF9, 0x14, 0x10,
+	0x91, 0x42, 0x01, 0xDD, 0x00, 0x91, 0x84, 0x74, 0x64, 0x1C, 0x44, 0x45,
+	0xC6, 0xD3, 0x85, 0xF8,
+	0x18, 0x90, 0x05, 0xB0, 0xBD, 0xE8, 0xF0, 0x8F, 0x2D, 0xE9, 0xF8, 0x4F,
+	0x0C, 0x46, 0x05, 0x46,
+	0x1E, 0x46, 0x91, 0x46, 0x17, 0x21, 0x3C, 0x48, 0x10, 0xF0, 0x2E, 0xFC,
+	0x28, 0x21, 0x3B, 0x48,
+	0x10, 0xF0, 0x2A, 0xFC, 0xDF, 0xF8, 0xE8, 0xA0, 0x3A, 0x4F, 0x09, 0xF1,
+	0x08, 0x08, 0x9A, 0xF8,
+	0x00, 0x10, 0x76, 0xB1, 0x0A, 0x46, 0x05, 0xF1, 0x20, 0x03, 0x37, 0x49,
+	0x32, 0x48, 0xFF, 0xF7,
+	0x76, 0xFE, 0x04, 0xF1, 0x20, 0x03, 0x3A, 0x78, 0x34, 0x49, 0x30, 0x48,
+	0xFF, 0xF7, 0x6F, 0xFE,
+	0x11, 0xE0, 0x4A, 0x46, 0x2C, 0x48, 0x00, 0xF0, 0x3D, 0xFA, 0x42, 0x46,
+	0x39, 0x78, 0x2B, 0x48,
+	0x00, 0xF0, 0x38, 0xFA, 0x00, 0x20, 0xC5, 0xE9, 0x08, 0x00, 0xC4, 0xE9,
+	0x08, 0x00, 0x2C, 0x48,
+	0x00, 0x88, 0x28, 0x85, 0x20, 0x85, 0x2B, 0x4E, 0x28, 0x8D, 0x2B, 0x46,
+	0x26, 0xF8, 0x11, 0x0F,
+	0x20, 0x8D, 0x70, 0x80, 0xCD, 0xF8, 0x00, 0x90, 0x9A, 0xF8, 0x00, 0x20,
+	0x22, 0x49, 0x1E, 0x48,
+	0xFF, 0xF7, 0x36, 0xFF, 0xCD, 0xF8, 0x00, 0x80, 0x23, 0x46, 0x3A, 0x78,
+	0x1F, 0x49, 0x1B, 0x48,
+	0xFF, 0xF7, 0x2E, 0xFF, 0x29, 0x7E, 0x30, 0x79, 0x61, 0xF3, 0x03, 0x00,
+	0x30, 0x71, 0x21, 0x7E,
+	0x61, 0xF3, 0x07, 0x10, 0x30, 0x71, 0xBD, 0xE8, 0xF8, 0x8F, 0x2D, 0xE9,
+	0xFF, 0x4F, 0x15, 0x46,
+	0x04, 0x46, 0xD1, 0xE9, 0x02, 0x70, 0xD1, 0xE9, 0x00, 0x92, 0x80, 0x46,
+	0x81, 0xB0, 0x92, 0x46,
+	0x4F, 0xF4, 0x66, 0x71, 0x28, 0x46, 0x10, 0xF0, 0xCF, 0xFB, 0x00, 0x20,
+	0x01, 0x46, 0x00, 0x90,
+	0x0E, 0x98, 0x01, 0x60, 0x00, 0x21, 0x28, 0x46, 0x10, 0xF0, 0xD8, 0xFC,
+	0x83, 0x46, 0x1B, 0xE0,
+	0x18, 0x2A, 0x10, 0x00, 0x58, 0x05, 0x10, 0x00, 0x66, 0x05, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0xFC, 0x78, 0x01, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x0A, 0x0C, 0x01, 0x20,
+	0x21, 0x0C, 0x01, 0x20,
+	0xED, 0x06, 0x10, 0x00, 0xEE, 0x06, 0x10, 0x00, 0x94, 0x0B, 0x01, 0x20,
+	0xBE, 0x0B, 0x01, 0x20,
+	0x68, 0x05, 0x10, 0x00, 0x0A, 0x44, 0x01, 0x20, 0x00, 0x21, 0x20, 0x46,
+	0x10, 0xF0, 0xAE, 0xFC,
+	0x06, 0x46, 0x00, 0x25, 0x34, 0xE0, 0x2A, 0x46, 0x01, 0x20, 0x00, 0x21,
+	0x10, 0xF0, 0xE6, 0xFA,
+	0x00, 0xEA, 0x09, 0x00, 0x01, 0xEA, 0x0A, 0x01, 0x08, 0x43, 0x22, 0xD0,
+	0x00, 0x24, 0x1C, 0xE0,
+	0x22, 0x46, 0x01, 0x20, 0x00, 0x21, 0x10, 0xF0, 0xD9, 0xFA, 0x38, 0x40,
+	0x01, 0xEA, 0x08, 0x01,
+	0x08, 0x43, 0x11, 0xD0, 0x36, 0xF9, 0x14, 0x10, 0x04, 0x98, 0x81, 0x42,
+	0x0C, 0xDD, 0x01, 0x20,
+	0x0B, 0xF8, 0x04, 0x00, 0x00, 0x98, 0x40, 0x1C, 0x00, 0x90, 0x0E, 0x98,
+	0x36, 0xF9, 0x14, 0x10,
+	0x00, 0x68, 0x01, 0x44, 0x0E, 0x98, 0x01, 0x60, 0x64, 0x1C, 0xFE, 0x48,
+	0x00, 0x78, 0x84, 0x42,
+	0xDE, 0xDB, 0xFC, 0x48, 0x0B, 0xF1, 0x28, 0x0B, 0x6D, 0x1C, 0x00, 0x78,
+	0x06, 0xEB, 0x40, 0x06,
+	0xF9, 0x48, 0x00, 0x78, 0x85, 0x42, 0xC6, 0xDB, 0x00, 0x98, 0x2A, 0xE7,
+	0x2D, 0xE9, 0xF0, 0x47,
+	0x0F, 0x46, 0x1C, 0x46, 0x16, 0x46, 0x99, 0x78, 0x10, 0xF0, 0x62, 0xFC,
+	0x05, 0x46, 0xA1, 0x78,
+	0x38, 0x46, 0x10, 0xF0, 0x63, 0xFC, 0x02, 0x46, 0xEE, 0x48, 0x00, 0x23,
+	0xA1, 0x78, 0x90, 0xF8,
+	0x00, 0x90, 0x94, 0xF8, 0x03, 0xC0, 0x13, 0xE0, 0x20, 0x78, 0x67, 0x78,
+	0x09, 0xE0, 0x00, 0xBF,
+	0x15, 0xF8, 0x00, 0x80, 0xB0, 0x45, 0x02, 0xD1, 0x32, 0xF9, 0x10, 0x80,
+	0x43, 0x44, 0x40, 0x1C,
+	0xC0, 0xB2, 0x87, 0x42, 0xF4, 0xD2, 0x49, 0x1C, 0x02, 0xEB, 0x49, 0x02,
+	0xC9, 0xB2, 0x28, 0x35,
+	0x8C, 0x45, 0xE9, 0xD2, 0x18, 0x46, 0xBD, 0xE8, 0xF0, 0x87, 0x2D, 0xE9,
+	0xF0, 0x4F, 0xDF, 0x48,
+	0x87, 0xB0, 0xDF, 0xF8, 0x80, 0x83, 0x06, 0x68, 0x00, 0x20, 0x06, 0xF5,
+	0x88, 0x74, 0x86, 0xF8,
+	0x0E, 0x01, 0xDB, 0x48, 0x01, 0x23, 0x00, 0x22, 0x00, 0x68, 0x30, 0x60,
+	0x31, 0x46, 0xD8, 0xF8,
+	0x00, 0x00, 0x08, 0xF0, 0x85, 0xF8, 0xDF, 0xF8, 0x60, 0xA3, 0xDF, 0xF8,
+	0x60, 0x93, 0x4F, 0xF0,
+	0xFF, 0x37, 0x9A, 0xF8, 0x00, 0x00, 0x01, 0x28, 0x10, 0xD1, 0xD5, 0x48,
+	0x00, 0x68, 0x90, 0xF8,
+	0x51, 0x02, 0xC0, 0x07, 0x01, 0xD0, 0x02, 0x23, 0x00, 0xE0, 0x01, 0x23,
+	0x32, 0x46, 0xD9, 0xF8,
+	0x00, 0x10, 0xD8, 0xF8, 0x00, 0x00, 0x00, 0xF0, 0x4D, 0xF9, 0x07, 0x46,
+	0xCD, 0x49, 0x96, 0xF8,
+	0x0E, 0x01, 0x48, 0x71, 0x00, 0x20, 0x01, 0x25, 0x05, 0x90, 0x51, 0xE0,
+	0x01, 0x20, 0xA8, 0x40,
+	0x38, 0x42, 0x4C, 0xD0, 0x06, 0xEB, 0x85, 0x00, 0x03, 0x90, 0x06, 0xEB,
+	0x45, 0x00, 0x48, 0x21,
+	0xB0, 0xF8, 0xB4, 0xB0, 0x20, 0x46, 0x10, 0xF0, 0x11, 0xFB, 0x03, 0x20,
+	0x84, 0xF8, 0x40, 0x00,
+	0xD9, 0xF8, 0x00, 0x00, 0x60, 0x60, 0xA0, 0x60, 0x84, 0xF8, 0x42, 0x50,
+	0xA4, 0xF8, 0x2A, 0xB0,
+	0xA4, 0xF8, 0x26, 0xB0, 0xE9, 0xB2, 0x23, 0x46, 0x03, 0x9A, 0xD8, 0xF8,
+	0x00, 0x00, 0x07, 0xF0,
+	0x40, 0xF8, 0x9A, 0xF8, 0x00, 0x00, 0x02, 0x28, 0x10, 0xD1, 0xB7, 0x48,
+	0x04, 0xA9, 0xEA, 0xB2,
+	0xB0, 0xF9, 0x00, 0x00, 0x02, 0x94, 0xCD, 0xE9, 0x00, 0x10, 0xD8, 0xF8,
+	0x00, 0x10, 0x03, 0x9B,
+	0x08, 0x46, 0x07, 0xF0, 0x68, 0xF8, 0xDD, 0xE9, 0x03, 0x01, 0x01, 0x60,
+	0xE0, 0x8C, 0xB0, 0xB1,
+	0xAD, 0x48, 0xB4, 0xF9, 0x32, 0x10, 0xB0, 0xF9, 0x00, 0x00, 0x81, 0x42,
+	0x0F, 0xDD, 0x01, 0x20,
+	0x05, 0x90, 0xE9, 0xB2, 0x23, 0x46, 0x03, 0x9A, 0xD8, 0xF8, 0x00, 0x00,
+	0x08, 0xF0, 0x4A, 0xFA,
+	0xE9, 0xB2, 0x23, 0x46, 0x03, 0x9A, 0xD8, 0xF8, 0x00, 0x00, 0x06, 0xF0,
+	0x91, 0xFF, 0x6D, 0x1C,
+	0x96, 0xF8, 0x0E, 0x01, 0xA8, 0x42, 0xA9, 0xD2, 0x05, 0x98, 0x07, 0xB0,
+	0x6A, 0xE6, 0x9F, 0x49,
+	0x10, 0xB5, 0x09, 0x78, 0x00, 0x20, 0x11, 0xB1, 0xFF, 0xF7, 0x67, 0xFF,
+	0x04, 0xE0, 0x9C, 0x49,
+	0x09, 0x7A, 0x09, 0xB1, 0xFF, 0xF7, 0xBC, 0xFA, 0x9A, 0x4A, 0x00, 0x21,
+	0x11, 0x70, 0x9A, 0x4A,
+	0x10, 0x70, 0x9A, 0x48, 0x01, 0x70, 0x10, 0xBD, 0x10, 0xB5, 0x91, 0x4C,
+	0x20, 0x68, 0x90, 0xF8,
+	0x30, 0x12, 0x09, 0x07, 0x1C, 0xD5, 0x96, 0x49, 0x09, 0x78, 0x11, 0xF0,
+	0x30, 0x0F, 0x17, 0xD0,
+	0xB0, 0xF9, 0x44, 0x12, 0x01, 0x22, 0x93, 0x48, 0x00, 0xF0, 0xEB, 0xFA,
+	0x20, 0x68, 0x01, 0x22,
+	0xB0, 0xF9, 0x46, 0x12, 0x8F, 0x48, 0x10, 0x30, 0x00, 0xF0, 0xE3, 0xFA,
+	0x20, 0x68, 0x01, 0x22,
+	0xB0, 0xF9, 0x42, 0x12, 0x8B, 0x48, 0xBD, 0xE8, 0x10, 0x40, 0x10, 0x38,
+	0x00, 0xF0, 0xD9, 0xBA,
+	0x88, 0x48, 0x4F, 0xF0, 0xFF, 0x31, 0xC0, 0xE9, 0x00, 0x11, 0xC0, 0xE9,
+	0x02, 0x11, 0x10, 0x38,
+	0xC0, 0xE9, 0x00, 0x11, 0xC0, 0xE9, 0x02, 0x11, 0x20, 0x30, 0xC0, 0xE9,
+	0x00, 0x11, 0xC0, 0xE9,
+	0x02, 0x11, 0x10, 0xBD, 0x2D, 0xE9, 0xFF, 0x5F, 0x15, 0x46, 0x03, 0x99,
+	0x91, 0xF8, 0x40, 0x10,
+	0x02, 0x29, 0x0C, 0xD0, 0x01, 0x29, 0x0C, 0xD0, 0x7A, 0x49, 0x10, 0x39,
+	0x8A, 0x46, 0x4F, 0xF0,
+	0x00, 0x0B, 0xA9, 0x78, 0x10, 0xF0, 0x5A, 0xFB, 0x81, 0x46, 0xA8, 0x78,
+	0x2A, 0xE0, 0x75, 0x49,
+	0xF4, 0xE7, 0x74, 0x49, 0x10, 0x31, 0xF1, 0xE7, 0x2C, 0x78, 0x1C, 0xE0,
+	0x19, 0xF8, 0x04, 0x10,
+	0x01, 0x98, 0x81, 0x42, 0x16, 0xD1, 0x01, 0x22, 0xDA, 0xF8, 0x00, 0x00,
+	0x02, 0xFA, 0x08, 0xF2,
+	0x10, 0x40, 0x00, 0x00, 0x24, 0xD0, 0xDA, 0xE9, 0x02, 0x76, 0x22, 0x46,
+	0x01, 0x20, 0x00, 0x21,
+	0x10, 0xF0, 0x74, 0xF9, 0x07, 0x40, 0x0E, 0x40, 0x37, 0x43, 0x19, 0xD0,
+	0x0B, 0xF1, 0x01, 0x00,
+	0x1F, 0xFA, 0x80, 0xFB, 0x64, 0x1C, 0x68, 0x78, 0xA0, 0x42, 0xDF, 0xDA,
+	0x09, 0xF1, 0x28, 0x09,
+	0x08, 0xF1, 0x01, 0x00, 0xE9, 0x78, 0x80, 0x46, 0x41, 0x45, 0xD5, 0xDA,
+	0x03, 0x99, 0x5F, 0xEA,
+	0x0B, 0x00, 0xA1, 0xF8, 0x26, 0xB0, 0x00, 0xD0, 0x01, 0x20, 0x04, 0xB0,
+	0xBD, 0xE8, 0xF0, 0x9F,
+	0x00, 0x21, 0x09, 0xF8, 0x04, 0x10, 0xE5, 0xE7, 0x2D, 0xE9, 0xF8, 0x4F,
+	0x80, 0x46, 0x4F, 0xF0,
+	0x00, 0x0B, 0x87, 0x78, 0x90, 0xF8, 0x03, 0xA0, 0x23, 0xE0, 0x00, 0xBF,
+	0x52, 0x49, 0x01, 0x22,
+	0xBA, 0x40, 0x08, 0x68, 0x98, 0xF8, 0x00, 0x40, 0x10, 0x40, 0x00, 0x90,
+	0xD1, 0xE9, 0x02, 0x56,
+	0x98, 0xF8, 0x01, 0x90, 0x12, 0xE0, 0x00, 0x99, 0x09, 0x00, 0x0E, 0xD0,
+	0x22, 0x46, 0x01, 0x20,
+	0x00, 0x21, 0x10, 0xF0, 0x33, 0xF9, 0x05, 0xEA, 0x00, 0x02, 0x06, 0xEA,
+	0x01, 0x00, 0x02, 0x43,
+	0x03, 0xD0, 0x0B, 0xF1, 0x01, 0x00, 0x1F, 0xFA, 0x80, 0xFB, 0x64, 0x1C,
+	0xA1, 0x45, 0xEA, 0xDA,
+	0x7F, 0x1C, 0xBA, 0x45, 0xDA, 0xDA, 0xBB, 0xF1, 0x00, 0x0F, 0x01, 0xD0,
+	0x01, 0x20, 0xF2, 0xE5,
+	0x00, 0x20, 0xF0, 0xE5, 0x2D, 0xE9, 0xF0, 0x47, 0x91, 0x46, 0x45, 0x1C,
+	0x0C, 0x46, 0x4F, 0xF0,
+	0x01, 0x08, 0x0C, 0xE0, 0xD9, 0xE9, 0x00, 0x67, 0x22, 0x46, 0x01, 0x20,
+	0x00, 0x21, 0x10, 0xF0,
+	0x0D, 0xF9, 0x06, 0x40, 0x0F, 0x40, 0x3E, 0x43, 0x01, 0xD0, 0x05, 0xF8,
+	0x04, 0x80, 0x64, 0x1E,
+	0xF0, 0xD2, 0x80, 0xE6, 0x2D, 0xE9, 0xF0, 0x47, 0x92, 0xF8, 0x0E, 0x41,
+	0x86, 0xB0, 0x1D, 0x46,
+	0x17, 0x46, 0x89, 0x46, 0x82, 0x46, 0xE8, 0x46, 0x05, 0x2C, 0x02, 0xD9,
+	0x05, 0x24, 0x01, 0x26,
+	0x01, 0xE0, 0x01, 0x26, 0x0C, 0xE0, 0x07, 0xEB, 0x86, 0x03, 0x32, 0x46,
+	0x49, 0x46, 0x50, 0x46,
+	0xFF, 0xF7, 0x3C, 0xFE, 0x08, 0xEB, 0x86, 0x01, 0x76, 0x1C, 0x41, 0xF8,
+	0x04, 0x0C, 0xF6, 0xB2,
+	0xA6, 0x42, 0xF0, 0xD9, 0x00, 0x20, 0x03, 0x46, 0x01, 0x22, 0x40, 0xE0,
+	0x00, 0x27, 0x4F, 0xF0,
+	0x00, 0x46, 0x01, 0x21, 0x0F, 0xE0, 0x00, 0xBF, 0x02, 0xFA, 0x01, 0xFC,
+	0x1C, 0xEA, 0x00, 0x0F,
+	0x07, 0xD1, 0x08, 0xEB, 0x81, 0x0C, 0x5C, 0xF8, 0x04, 0xCC, 0xB4, 0x45,
+	0x01, 0xDD, 0x66, 0x46,
+	0x0F, 0x46, 0x49, 0x1C, 0xC9, 0xB2, 0xA1, 0x42, 0xEE, 0xD9, 0x02, 0xFA,
+	0x07, 0xF1, 0x08, 0x43,
+	0x5B, 0x1C, 0x23, 0xE0, 0xEE, 0x06, 0x10, 0x00, 0xED, 0x06, 0x10, 0x00,
+	0x58, 0x05, 0x10, 0x00,
+	0x88, 0x06, 0x10, 0x00, 0x50, 0x06, 0x10, 0x00, 0x66, 0x05, 0x10, 0x00,
+	0x14, 0x07, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x0A, 0x44, 0x01, 0x20, 0x92, 0x06, 0x10, 0x00,
+	0x57, 0x05, 0x10, 0x00,
+	0x0C, 0x2A, 0x10, 0x00, 0xF6, 0x06, 0x10, 0x00, 0xF7, 0x06, 0x10, 0x00,
+	0xF8, 0x06, 0x10, 0x00,
+	0x04, 0x07, 0x10, 0x00, 0xA8, 0x2A, 0x10, 0x00, 0x50, 0x2B, 0x10, 0x00,
+	0xDB, 0xB2, 0xAB, 0x42,
+	0xBC, 0xD3, 0x06, 0xB0, 0x17, 0xE6, 0x00, 0x00, 0xA1, 0x4A, 0x10, 0xB5,
+	0x13, 0x68, 0x00, 0x21,
+	0xB3, 0xF8, 0x14, 0x22, 0x82, 0x42, 0x05, 0xDA, 0x93, 0xF8, 0x10, 0x22,
+	0x52, 0x07, 0x01, 0xD5,
+	0x02, 0x21, 0x08, 0xE0, 0xB3, 0xF8, 0x12, 0x22, 0x82, 0x42, 0x04, 0xDA,
+	0x93, 0xF8, 0x10, 0x02,
+	0x80, 0x07, 0x00, 0xD5, 0x01, 0x21, 0x97, 0x48, 0x97, 0x4C, 0x42, 0x78,
+	0x91, 0x42, 0x14, 0xD1,
+	0xA1, 0x78, 0x91, 0x42, 0x0D, 0xD0, 0x95, 0x4B, 0x1B, 0x78, 0x1A, 0x43,
+	0x94, 0x4B, 0x1B, 0x78,
+	0x1A, 0x43, 0x07, 0xD0, 0x41, 0x68, 0x49, 0x1E, 0x41, 0x60, 0x00, 0x29,
+	0x01, 0xDC, 0x40, 0x78,
+	0xA0, 0x70, 0x10, 0xBD, 0x41, 0x70, 0x41, 0x68, 0xF7, 0xE7, 0x59, 0xB1,
+	0x02, 0x29, 0x01, 0xD1,
+	0x01, 0x2A, 0x07, 0xD0, 0x93, 0xF8, 0x18, 0x22, 0x42, 0x60, 0x41, 0x70,
+	0x00, 0x2A, 0xF0, 0xDC,
+	0xA1, 0x70, 0x10, 0xBD, 0x93, 0xF8, 0x19, 0x22, 0xF6, 0xE7, 0x70, 0xB5,
+	0x85, 0x4A, 0x86, 0x4B,
+	0x81, 0x4D, 0x16, 0x78, 0x7E, 0x4A, 0x1C, 0x78, 0x00, 0x21, 0x12, 0x68,
+	0xAB, 0x78, 0x01, 0x2E,
+	0x02, 0xD1, 0x82, 0x4E, 0x36, 0x78, 0x4E, 0xB1, 0xB2, 0xF8, 0x14, 0x62,
+	0x86, 0x42, 0x17, 0xDA,
+	0x92, 0xF8, 0x10, 0x62, 0x76, 0x07, 0x13, 0xD5, 0x02, 0x21, 0x25, 0xE0,
+	0xB2, 0xF8, 0x1C, 0x62,
+	0x86, 0x42, 0x03, 0xDA, 0x92, 0xF8, 0x10, 0x62, 0x76, 0x07, 0xF5, 0xD4,
+	0xB2, 0xF8, 0x1A, 0x62,
+	0x08, 0xE0, 0x00, 0xBF, 0x92, 0xF8, 0x10, 0x02, 0x80, 0x07, 0x05, 0xD5,
+	0x01, 0x21, 0x13, 0xE0,
+	0xB2, 0xF8, 0x12, 0x62, 0x86, 0x42, 0xF5, 0xDB, 0x73, 0xB1, 0x6C, 0x48,
+	0x00, 0x78, 0x01, 0x28,
+	0x03, 0xD0, 0x6B, 0x48, 0x00, 0x78, 0x01, 0x28, 0x03, 0xD1, 0x92, 0xF8,
+	0x10, 0x02, 0x00, 0x07,
+	0x01, 0xD5, 0x01, 0x2C, 0x00, 0xD1, 0x19, 0x46, 0x62, 0x48, 0x34, 0xB1,
+	0x19, 0xB1, 0x00, 0xBF,
+	0x92, 0xF8, 0x19, 0x22, 0x42, 0x60, 0xA9, 0x70, 0x70, 0xBD, 0x00, 0x29,
+	0xF8, 0xD1, 0x00, 0x2B,
+	0xF6, 0xD0, 0x44, 0x68, 0x00, 0x2C, 0xF6, 0xDD, 0x92, 0xF8, 0x10, 0x12,
+	0x0A, 0x07, 0x59, 0x49,
+	0x49, 0x68, 0xA1, 0xF1, 0x01, 0x01, 0x02, 0xD5, 0x5D, 0x4A, 0x12, 0x78,
+	0x02, 0xB1, 0x41, 0x60,
+	0x19, 0x46, 0xE8, 0xE7, 0x52, 0x48, 0x53, 0x49, 0x00, 0x68, 0x90, 0xF8,
+	0x10, 0x02, 0xC2, 0x06,
+	0x4F, 0xF0, 0x00, 0x00, 0x03, 0xD4, 0x50, 0x4A, 0x90, 0x70, 0x48, 0x70,
+	0x48, 0x60, 0x08, 0x70,
+	0x70, 0x47, 0x10, 0xB5, 0x04, 0x46, 0x4A, 0x48, 0x00, 0x68, 0x90, 0xF8,
+	0x10, 0x02, 0xC0, 0x06,
+	0x20, 0x46, 0x02, 0xD5, 0xFF, 0xF7, 0x89, 0xFF, 0x01, 0xE0, 0xFF, 0xF7,
+	0x45, 0xFF, 0x46, 0x48,
+	0x82, 0x78, 0x4C, 0x48, 0x41, 0x7B, 0x62, 0xF3, 0x07, 0x11, 0x41, 0x73,
+	0xA0, 0xF8, 0x2F, 0x40,
+	0x10, 0xBD, 0x2D, 0xE9, 0xFC, 0x5F, 0x83, 0x46, 0x47, 0x48, 0x00, 0x25,
+	0x0A, 0x46, 0x00, 0x78,
+	0x2F, 0x46, 0x2C, 0x46, 0x01, 0x28, 0x00, 0xD1, 0x01, 0x24, 0x44, 0x48,
+	0x06, 0x78, 0x00, 0x78,
+	0x41, 0x00, 0x01, 0x2A, 0x1B, 0xD0, 0xDF, 0xF8, 0xD8, 0x80, 0xDF, 0xF8,
+	0x04, 0xA1, 0xDF, 0xF8,
+	0x04, 0x91, 0xD8, 0xF8, 0x00, 0x00, 0x90, 0xF8, 0x10, 0x22, 0x92, 0x06,
+	0x14, 0xD5, 0x32, 0x1B,
+	0xB0, 0xF9, 0x20, 0x12, 0xCD, 0xE9, 0x00, 0x12, 0xB0, 0xF9, 0x1E, 0x32,
+	0x0A, 0xEB, 0x44, 0x02,
+	0x0B, 0xEB, 0x44, 0x01, 0x09, 0xEB, 0x44, 0x00, 0x0C, 0xF0, 0x72, 0xFF,
+	0x09, 0xE0, 0x34, 0x48,
+	0x4C, 0x38, 0x10, 0xF0, 0x59, 0xF8, 0x41, 0xE0, 0x0A, 0x46, 0x59, 0x46,
+	0x31, 0x48, 0x0F, 0xF0,
+	0xD4, 0xFF, 0x2F, 0x48, 0x4C, 0x38, 0x34, 0xE0, 0x3A, 0xF9, 0x14, 0x20,
+	0x39, 0xF9, 0x14, 0x10,
+	0x51, 0x1A, 0x00, 0xD5, 0x49, 0x42, 0xD8, 0xF8, 0x00, 0x30, 0x09, 0xB2,
+	0x93, 0xF8, 0x10, 0x22,
+	0x52, 0x06, 0x0B, 0xD5, 0x20, 0x4A, 0x12, 0x78, 0x01, 0x2A, 0x07, 0xD1,
+	0x26, 0x4A, 0x12, 0x78,
+	0x22, 0xB9, 0xB3, 0xF8, 0x22, 0x22, 0x8A, 0x42, 0x00, 0xDA, 0x01, 0x27,
+	0x30, 0xF9, 0x14, 0x20,
+	0x8A, 0x42, 0x02, 0xDA, 0x93, 0xF8, 0x16, 0x32, 0x01, 0xE0, 0x93, 0xF8,
+	0x17, 0x32, 0x5A, 0x43,
+	0xC3, 0xF5, 0x80, 0x73, 0x01, 0xFB, 0x03, 0x21, 0xCA, 0x17, 0x01, 0xEB,
+	0x12, 0x61, 0x09, 0x12,
+	0x20, 0xF8, 0x14, 0x10, 0x30, 0xF9, 0x14, 0x10, 0xA9, 0x42, 0x00, 0xDD,
+	0x0D, 0x46, 0x64, 0x1C,
+	0x24, 0xB2, 0xB4, 0x42, 0xC8, 0xDB, 0x28, 0x46, 0xFF, 0xF7, 0x73, 0xFF,
+	0x72, 0x00, 0x59, 0x46,
+	0x0F, 0x48, 0x0F, 0xF0, 0x92, 0xFF, 0x03, 0x48, 0x07, 0x70, 0xBD, 0xE8,
+	0xFC, 0x9F, 0x00, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x5C, 0x05, 0x10, 0x00, 0x74, 0x07, 0x10, 0x00,
+	0xF5, 0x06, 0x10, 0x00,
+	0x64, 0x05, 0x10, 0x00, 0xF6, 0x06, 0x10, 0x00, 0xFD, 0x06, 0x10, 0x00,
+	0xF7, 0x06, 0x10, 0x00,
+	0xFA, 0x06, 0x10, 0x00, 0x0A, 0x44, 0x01, 0x20, 0xF4, 0x06, 0x10, 0x00,
+	0xED, 0x06, 0x10, 0x00,
+	0x54, 0x0A, 0x01, 0x20, 0xA0, 0x0A, 0x01, 0x20, 0x74, 0x05, 0x10, 0x00,
+	0x2D, 0xE9, 0xF0, 0x4F,
+	0x81, 0x46, 0xDD, 0xE9, 0x09, 0xB5, 0x01, 0x20, 0x47, 0xF6, 0xFF, 0x77,
+	0x9A, 0x46, 0x84, 0x46,
+	0xFE, 0x43, 0x2C, 0x46, 0x15, 0xE0, 0x00, 0xBF, 0x32, 0xF8, 0x14, 0x30,
+	0x31, 0xF8, 0x14, 0x80,
+	0xA3, 0xEB, 0x08, 0x03, 0x1B, 0xB2, 0xBB, 0x42, 0x00, 0xDA, 0x1F, 0x46,
+	0xB3, 0x42, 0x00, 0xDD,
+	0x1E, 0x46, 0x00, 0x2B, 0x02, 0xDD, 0x4F, 0xF0, 0x00, 0x0C, 0x02, 0xE0,
+	0x01, 0xDA, 0x4F, 0xF0,
+	0x00, 0x00, 0x64, 0x1E, 0xE8, 0xD2, 0x20, 0xB1, 0xBC, 0xF1, 0x00, 0x0F,
+	0x01, 0xD0, 0x00, 0x23,
+	0x09, 0xE0, 0x50, 0xEA, 0x0C, 0x03, 0x06, 0xD0, 0x20, 0xB9, 0xBC, 0xF1,
+	0x00, 0x0F, 0x01, 0xD0,
+	0x33, 0x46, 0x00, 0xE0, 0x3B, 0x46, 0x00, 0x27, 0x3C, 0x46, 0x28, 0x46,
+	0xCB, 0xF1, 0x00, 0x0C,
+	0x0E, 0xE0, 0x00, 0xBF, 0x32, 0xF8, 0x10, 0x60, 0x31, 0xF8, 0x10, 0x80,
+	0xA6, 0xEB, 0x08, 0x06,
+	0xF6, 0x1A, 0x36, 0xB2, 0x56, 0x45, 0x03, 0xDA, 0x66, 0x45, 0x01, 0xDD,
+	0x37, 0x44, 0x64, 0x1C,
+	0x40, 0x1E, 0xEF, 0xD2, 0x04, 0xB9, 0x01, 0x24, 0x97, 0xFB, 0xF4, 0xF0,
+	0x18, 0x44, 0x04, 0xE0,
+	0x31, 0xF8, 0x15, 0x20, 0x02, 0x44, 0x29, 0xF8, 0x15, 0x20, 0x6D, 0x1E,
+	0xF8, 0xD2, 0xBD, 0xE8,
+	0xF0, 0x8F, 0x2D, 0xE9, 0xF0, 0x41, 0x04, 0x46, 0x03, 0x46, 0xFC, 0x48,
+	0x15, 0x46, 0x0E, 0x46,
+	0x0A, 0x46, 0x01, 0x78, 0xFA, 0x48, 0x00, 0xF0, 0x51, 0xFA, 0xFA, 0x48,
+	0x04, 0xF1, 0x08, 0x03,
+	0x1F, 0x46, 0x01, 0x78, 0xF6, 0x48, 0x32, 0x46, 0x2A, 0x30, 0x00, 0xF0,
+	0x47, 0xFA, 0x00, 0x2D,
+	0x07, 0xD0, 0x20, 0x46, 0x10, 0xF0, 0x6C, 0xF8, 0x38, 0x46, 0xBD, 0xE8,
+	0xF0, 0x41, 0x10, 0xF0,
+	0x67, 0xB8, 0xBD, 0xE8, 0xF0, 0x81, 0x2D, 0xE9, 0xFC, 0x41, 0x07, 0x46,
+	0x14, 0x46, 0x88, 0x46,
+	0x03, 0x20, 0xF9, 0xF7, 0xD6, 0xF9, 0xEC, 0x4D, 0xE8, 0x4E, 0x00, 0x94,
+	0xE8, 0x48, 0x32, 0x78,
+	0x39, 0x46, 0x76, 0x38, 0x2B, 0x68, 0x0C, 0xF0, 0xF9, 0xFE, 0x00, 0x94,
+	0xE5, 0x4C, 0xE4, 0x48,
+	0x41, 0x46, 0x22, 0x78, 0x4C, 0x38, 0x2B, 0x68, 0x0C, 0xF0, 0xF0, 0xFE,
+	0xE3, 0x4D, 0x28, 0x68,
+	0x90, 0xF8, 0x30, 0x12, 0xC9, 0x07, 0x1A, 0xD0, 0x32, 0x78, 0xB0, 0xF9,
+	0x34, 0x12, 0xCD, 0xE9,
+	0x00, 0x12, 0xDB, 0x49, 0xB0, 0xF9, 0x32, 0x32, 0x76, 0x39, 0xDD, 0x4A,
+	0x08, 0x46, 0xFF, 0xF7,
+	0x55, 0xFF, 0x28, 0x68, 0x22, 0x78, 0xB0, 0xF9, 0x38, 0x12, 0xCD, 0xE9,
+	0x00, 0x12, 0xD4, 0x49,
+	0xB0, 0xF9, 0x36, 0x32, 0x4C, 0x39, 0xD7, 0x4A, 0x08, 0x46, 0xFF, 0xF7,
+	0x47, 0xFF, 0xD0, 0x49,
+	0x33, 0x78, 0xD3, 0x4A, 0x76, 0x39, 0xCE, 0x48, 0x0C, 0xF0, 0xBB, 0xFE,
+	0xCC, 0x49, 0x23, 0x78,
+	0x4C, 0x39, 0xD0, 0x4A, 0x01, 0xF1, 0x76, 0x00, 0x0C, 0xF0, 0xB3, 0xFE,
+	0x28, 0x68, 0x90, 0xF8,
+	0x30, 0x12, 0x8A, 0x07, 0x04, 0xD4, 0xCC, 0x4A, 0x12, 0x78, 0x8A, 0xB1,
+	0x49, 0x07, 0x0F, 0xD5,
+	0xC3, 0x49, 0x90, 0xF8, 0x41, 0x32, 0x32, 0x78, 0x08, 0x46, 0x0C, 0xF0,
+	0xE2, 0xFE, 0x28, 0x68,
+	0xBF, 0x49, 0x22, 0x78, 0x90, 0xF8, 0x41, 0x32, 0x2A, 0x31, 0x08, 0x46,
+	0x0C, 0xF0, 0xD9, 0xFE,
+	0xBD, 0xE8, 0xFC, 0x41, 0x03, 0x20, 0xF9, 0xF7, 0x8F, 0xB9, 0x70, 0xB5,
+	0xBF, 0x4C, 0xC0, 0x49,
+	0x00, 0x25, 0xA5, 0x70, 0x01, 0x20, 0x08, 0x70, 0xB8, 0x48, 0x25, 0x70,
+	0x65, 0x70, 0x00, 0x68,
+	0xB0, 0xF8, 0x3A, 0x02, 0xA0, 0x80, 0x00, 0xF0, 0xE3, 0xF9, 0xFF, 0xF7,
+	0xEE, 0xF8, 0xA5, 0x60,
+	0xE5, 0x60, 0x70, 0xBD, 0x2D, 0xE9, 0xF0, 0x41, 0x0E, 0x46, 0xB5, 0x49,
+	0x07, 0x46, 0xB3, 0x4C,
+	0x0D, 0x78, 0x00, 0x20, 0x08, 0x70, 0x60, 0x70, 0x00, 0xF0, 0xD2, 0xF9,
+	0xB1, 0x48, 0x2A, 0x46,
+	0x31, 0x46, 0x00, 0x78, 0x00, 0x28, 0x38, 0x46, 0x02, 0xD0, 0xFF, 0xF7,
+	0x45, 0xF8, 0x01, 0xE0,
+	0xFF, 0xF7, 0x69, 0xFF, 0xAC, 0x48, 0x41, 0x78, 0xA4, 0x48, 0xA9, 0xB1,
+	0xA1, 0x78, 0x01, 0x29,
+	0x12, 0xD0, 0x00, 0x68, 0xB0, 0xF9, 0x3C, 0x12, 0xA8, 0x4D, 0xA1, 0x80,
+	0x01, 0x22, 0x28, 0x46,
+	0xFF, 0xF7, 0x37, 0xFF, 0xD5, 0xE9, 0x00, 0x01, 0x08, 0x43, 0x09, 0xD0,
+	0xD5, 0xE9, 0x02, 0x01,
+	0x08, 0x43, 0x05, 0xD0, 0x01, 0x20, 0x04, 0xE0, 0x00, 0x68, 0xB0, 0xF9,
+	0x3A, 0x12, 0xEB, 0xE7,
+	0x00, 0x20, 0x20, 0x70, 0x45, 0xE7, 0x2D, 0xE9, 0xF0, 0x4F, 0x04, 0x46,
+	0x9C, 0x48, 0xA7, 0xB0,
+	0x4F, 0xF0, 0x01, 0x09, 0x01, 0x78, 0x91, 0x48, 0x01, 0x29, 0x00, 0x68,
+	0x15, 0xD0, 0x92, 0x49,
+	0x09, 0x78, 0xA9, 0xB1, 0xB0, 0xF9, 0x54, 0x62, 0x88, 0x48, 0x00, 0x21,
+	0x4F, 0xF0, 0x01, 0x0A,
+	0x00, 0x78, 0x94, 0x4D, 0x40, 0x1E, 0x00, 0xF0, 0xFF, 0x08, 0x86, 0x48,
+	0x83, 0x46, 0x03, 0x78,
+	0x9A, 0x1E, 0x02, 0xF0, 0xFF, 0x0C, 0x22, 0x46, 0x13, 0xE0, 0xB0, 0xF9,
+	0x59, 0x62, 0xEB, 0xE7,
+	0xB0, 0xF9, 0x52, 0x62, 0xE8, 0xE7, 0x50, 0x46, 0x06, 0xE0, 0x00, 0xBF,
+	0x32, 0xF9, 0x10, 0x70,
+	0xAF, 0x42, 0x00, 0xDD, 0x3D, 0x46, 0x40, 0x1C, 0x60, 0x45, 0xF7, 0xDD,
+	0x02, 0xEB, 0x43, 0x02,
+	0x49, 0x1C, 0x41, 0x45, 0xEF, 0xDD, 0x5F, 0x46, 0x5A, 0x00, 0x04, 0xEB,
+	0x43, 0x01, 0x68, 0x46,
+	0x0F, 0xF0, 0xFB, 0xFD, 0x80, 0x4A, 0x38, 0x78, 0x6B, 0x46, 0x12, 0x88,
+	0x41, 0x42, 0x02, 0xEB,
+	0x41, 0x01, 0x09, 0xB2, 0x42, 0x00, 0x04, 0xEB, 0x41, 0x01, 0x03, 0xEB,
+	0x40, 0x00, 0x0F, 0xF0,
+	0xEC, 0xFD, 0x38, 0x78, 0x69, 0x46, 0x42, 0x00, 0x08, 0x46, 0x0C, 0xF0,
+	0x50, 0xFE, 0x28, 0x1A,
+	0x00, 0xB2, 0xB0, 0x42, 0x01, 0xDD, 0x4F, 0xF0, 0x00, 0x09, 0x48, 0x46,
+	0x27, 0xB0, 0xC6, 0xE6,
+	0x2D, 0xE9, 0xF0, 0x4F, 0x71, 0x49, 0x70, 0x4A, 0x00, 0x27, 0x0C, 0x68,
+	0xB2, 0xF9, 0x00, 0x20,
+	0x4F, 0xF0, 0x01, 0x0A, 0x21, 0x8E, 0x3B, 0x46, 0x91, 0x42, 0x49, 0xD1,
+	0x62, 0x49, 0x0A, 0x78,
+	0x5E, 0x49, 0x0E, 0x68, 0x8A, 0xB1, 0xB6, 0xF9, 0x54, 0x12, 0x00, 0x25,
+	0x89, 0x46, 0x57, 0x49,
+	0x4F, 0xF0, 0x02, 0x0E, 0x09, 0x78, 0x49, 0x1E, 0x01, 0xF0, 0xFF, 0x0B,
+	0x55, 0x49, 0x09, 0x78,
+	0xC9, 0x1E, 0x01, 0xF0, 0xFF, 0x0C, 0x32, 0x34, 0x2A, 0xE0, 0xB6, 0xF9,
+	0x52, 0x12, 0xEC, 0xE7,
+	0x72, 0x46, 0x1C, 0xE0, 0x34, 0xF8, 0x12, 0x10, 0x30, 0xF8, 0x12, 0x80,
+	0xA1, 0xEB, 0x08, 0x01,
+	0x09, 0xB2, 0x00, 0x29, 0x01, 0xDB, 0x88, 0x46, 0x01, 0xE0, 0xC1, 0xF1,
+	0x00, 0x08, 0xB8, 0x45,
+	0x05, 0xDD, 0x00, 0x29, 0x01, 0xDB, 0x0F, 0x46, 0x00, 0xE0, 0x4F, 0x42,
+	0x3F, 0xB2, 0x00, 0x29,
+	0x00, 0xDA, 0x49, 0x42, 0x49, 0x45, 0x01, 0xDD, 0x5B, 0x1C, 0x9B, 0xB2,
+	0x52, 0x1C, 0x62, 0x45,
+	0xE0, 0xDD, 0x96, 0xF8, 0x30, 0x10, 0x6D, 0x1C, 0x04, 0xEB, 0x41, 0x04,
+	0x00, 0xEB, 0x41, 0x00,
+	0x5D, 0x45, 0xD5, 0xDD, 0x96, 0xF8, 0x56, 0x02, 0x98, 0x42, 0x01, 0xD2,
+	0x4F, 0xF0, 0x00, 0x0A,
+	0x47, 0x48, 0x20, 0xF8, 0x33, 0x7F, 0x83, 0x70, 0x50, 0x46, 0x68, 0xE6,
+	0x2D, 0xE9, 0xF0, 0x41,
+	0x06, 0x46, 0x44, 0x48, 0x00, 0x24, 0x00, 0x78, 0xC0, 0x06, 0x5E, 0xD5,
+	0x3C, 0x48, 0x36, 0x4D,
+	0x00, 0x78, 0x88, 0xB1, 0x40, 0x48, 0x31, 0x4B, 0x34, 0x49, 0x02, 0x68,
+	0x18, 0x68, 0x08, 0x31,
+	0xB0, 0xF8, 0x5D, 0x02, 0x40, 0x42, 0x07, 0xB2, 0x00, 0x20, 0xC8, 0x80,
+	0x88, 0x80, 0x08, 0x60,
+	0x35, 0x48, 0xB0, 0xF9, 0x00, 0x00, 0x29, 0xE0, 0x2C, 0x48, 0x2C, 0x78,
+	0x00, 0x78, 0x08, 0xB1,
+	0x01, 0x29, 0x02, 0xD0, 0x08, 0x43, 0x02, 0xD0, 0x3B, 0xE0, 0x01, 0x24,
+	0x3A, 0xE0, 0x00, 0x24,
+	0x67, 0xE0, 0x00, 0xBF, 0x32, 0xF9, 0x10, 0xC0, 0xBC, 0xF1, 0x00, 0x0F,
+	0x16, 0xDA, 0xB1, 0xF8,
+	0x04, 0xC0, 0x0C, 0xF1, 0x01, 0x0C, 0xA1, 0xF8, 0x04, 0xC0, 0x32, 0xF9,
+	0x10, 0xE0, 0xD1, 0xF8,
+	0x00, 0xC0, 0xF4, 0x44, 0xC1, 0xF8, 0x00, 0xC0, 0x32, 0xF9, 0x10, 0xC0,
+	0xBC, 0x45, 0x05, 0xDA,
+	0xB1, 0xF8, 0x06, 0xC0, 0x0C, 0xF1, 0x01, 0x0C, 0xA1, 0xF8, 0x06, 0xC0,
+	0x40, 0x1E, 0xE1, 0xD2,
+	0x08, 0x68, 0x40, 0x42, 0x08, 0x60, 0x15, 0x48, 0x19, 0x68, 0x08, 0x30,
+	0x02, 0x68, 0xB1, 0xF8,
+	0x5F, 0x32, 0x9A, 0x42, 0x3D, 0xDD, 0xB0, 0xF9, 0x06, 0x00, 0x91, 0xF8,
+	0x61, 0x12, 0x88, 0x42,
+	0x37, 0xDD, 0x1A, 0x48, 0x11, 0x4A, 0xB0, 0xF9, 0x00, 0x10, 0x30, 0x46,
+	0x00, 0xF0, 0x20, 0xF9,
+	0x04, 0x46, 0x6C, 0xB3, 0x00, 0xF0, 0xF2, 0xF8, 0x2D, 0xE0, 0x3D, 0xE0,
+	0xED, 0x06, 0x10, 0x00,
+	0x94, 0x0B, 0x01, 0x20, 0xEE, 0x06, 0x10, 0x00, 0x9C, 0x06, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0x7E, 0x4A, 0x01, 0x20, 0xA8, 0x4A, 0x01, 0x20, 0x74, 0x05, 0x10, 0x00,
+	0x64, 0x05, 0x10, 0x00,
+	0x7A, 0x07, 0x10, 0x00, 0xF4, 0x06, 0x10, 0x00, 0x74, 0x07, 0x10, 0x00,
+	0x40, 0x2B, 0x10, 0x00,
+	0x79, 0x05, 0x10, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFE, 0x06, 0x10, 0x00,
+	0x50, 0x07, 0x10, 0x00,
+	0x0A, 0x44, 0x01, 0x20, 0x04, 0x07, 0x10, 0x00, 0x14, 0x07, 0x10, 0x00,
+	0x98, 0x06, 0x10, 0x00,
+	0xFF, 0xE7, 0x00, 0xF0, 0xD9, 0xF8, 0x51, 0x4E, 0x28, 0x78, 0x31, 0x78,
+	0x88, 0x42, 0x06, 0xD0,
+	0x08, 0xB1, 0x01, 0x21, 0x00, 0xE0, 0x00, 0x21, 0x06, 0x20, 0x0B, 0xF0,
+	0xEC, 0xF8, 0x28, 0x78,
+	0x30, 0x70, 0x0C, 0xB1, 0x01, 0x20, 0xE4, 0xE5, 0x00, 0x20, 0xE2, 0xE5,
+	0x70, 0xB5, 0x03, 0x20,
+	0xF8, 0xF7, 0xBF, 0xFF, 0x00, 0xF0, 0x48, 0xF8, 0x04, 0x46, 0x03, 0x20,
+	0xF8, 0xF7, 0xD4, 0xFF,
+	0x43, 0x49, 0xC8, 0x7B, 0x64, 0xF3, 0x05, 0x10, 0xC8, 0x73, 0x42, 0x48,
+	0x01, 0x78, 0x21, 0xB1,
+	0x00, 0x21, 0x01, 0x70, 0x20, 0x46, 0x00, 0xF0, 0x30, 0xF9, 0x3F, 0x4D,
+	0x3F, 0x48, 0x21, 0x46,
+	0x2A, 0x78, 0x00, 0x68, 0xFF, 0xF7, 0x3A, 0xFF, 0xA8, 0x70, 0x70, 0xBD,
+	0x2D, 0xE9, 0xF0, 0x47,
+	0x1D, 0x46, 0x4F, 0xF0, 0x00, 0x08, 0xC5, 0xE9, 0x00, 0x88, 0x91, 0x46,
+	0x82, 0x46, 0x0C, 0x46,
+	0x11, 0xE0, 0x00, 0xBF, 0x3A, 0xF9, 0x14, 0x10, 0x49, 0x45, 0x0C, 0xDD,
+	0xD5, 0xE9, 0x00, 0x67,
+	0x4F, 0xF0, 0x01, 0x08, 0x22, 0x46, 0x40, 0x46, 0x00, 0x21, 0x0F, 0xF0,
+	0x67, 0xFC, 0x06, 0x43,
+	0x0F, 0x43, 0xC5, 0xE9, 0x00, 0x67, 0x64, 0x1E, 0xEC, 0xD2, 0x40, 0x46,
+	0xBD, 0xE8, 0xF0, 0x87,
+	0x2B, 0x48, 0x00, 0x21, 0xC0, 0xE9, 0x00, 0x11, 0xC0, 0xE9, 0x02, 0x11,
+	0x08, 0x46, 0x29, 0x49,
+	0x08, 0x76, 0x29, 0x49, 0x08, 0x76, 0x70, 0x47, 0x2D, 0xE9, 0xF0, 0x41,
+	0x27, 0x48, 0x00, 0x78,
+	0x02, 0x28, 0x35, 0xD9, 0x26, 0x4E, 0x30, 0x68, 0x90, 0xF8, 0x50, 0x02,
+	0x41, 0x07, 0x25, 0x48,
+	0x00, 0x68, 0x02, 0xD5, 0x24, 0x49, 0x09, 0x78, 0x81, 0xB1, 0xFF, 0xF7,
+	0x3C, 0xFE, 0x05, 0x46,
+	0x30, 0x68, 0x90, 0xF8, 0x50, 0x02, 0x00, 0x07, 0x21, 0xD5, 0x22, 0x48,
+	0x1F, 0x4B, 0x20, 0x49,
+	0x02, 0x78, 0x02, 0x2A, 0x1B, 0xDB, 0x20, 0x4C, 0x50, 0x1E, 0x08, 0xE0,
+	0xFF, 0xF7, 0x88, 0xFE,
+	0xED, 0xE7, 0x00, 0xBF, 0x33, 0xF9, 0x10, 0x70, 0xA7, 0x42, 0x00, 0xDD,
+	0x3C, 0x46, 0x40, 0x1E,
+	0xF8, 0xD1, 0x98, 0x1C, 0x92, 0x1E, 0x0C, 0xF0, 0xC2, 0xFC, 0x31, 0x68,
+	0x20, 0x1A, 0x00, 0xB2,
+	0xB1, 0xF9, 0x57, 0x12, 0x88, 0x42, 0x02, 0xDD, 0x35, 0xB1, 0x02, 0x20,
+	0x59, 0xE5, 0x0D, 0xB1,
+	0x00, 0x20, 0x56, 0xE5, 0x01, 0x20, 0x54, 0xE5, 0x03, 0x20, 0x52, 0xE5,
+	0x75, 0x05, 0x10, 0x00,
+	0x0A, 0x44, 0x01, 0x20, 0x78, 0x05, 0x10, 0x00, 0x64, 0x05, 0x10, 0x00,
+	0x14, 0x07, 0x10, 0x00,
+	0x40, 0x2B, 0x10, 0x00, 0x18, 0x2A, 0x10, 0x00, 0x58, 0x2A, 0x10, 0x00,
+	0xED, 0x06, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x1C, 0x07, 0x10, 0x00, 0x79, 0x05, 0x10, 0x00,
+	0xA8, 0x4A, 0x01, 0x20,
+	0xCE, 0x0A, 0x01, 0x20, 0xEE, 0x06, 0x10, 0x00, 0x00, 0x80, 0xFF, 0xFF,
+	0xFE, 0x48, 0x00, 0x21,
+	0xC1, 0x70, 0x02, 0x78, 0x00, 0x2A, 0x0E, 0xD1, 0x82, 0x78, 0xFC, 0x4B,
+	0x52, 0x1C, 0xD2, 0xB2,
+	0x82, 0x70, 0x1B, 0x68, 0x93, 0xF8, 0x62, 0x32, 0x03, 0xF0, 0x0F, 0x03,
+	0x93, 0x42, 0x02, 0xD2,
+	0x01, 0x22, 0x02, 0x70, 0x81, 0x70, 0x70, 0x47, 0xF3, 0x48, 0x00, 0x21,
+	0x81, 0x70, 0x02, 0x78,
+	0x00, 0x2A, 0x0C, 0xD0, 0xC2, 0x78, 0xF1, 0x4B, 0x52, 0x1C, 0xD2, 0xB2,
+	0xC2, 0x70, 0x1B, 0x68,
+	0x93, 0xF8, 0x62, 0x32, 0xB2, 0xEB, 0x13, 0x1F, 0x01, 0xD9, 0x01, 0x70,
+	0xC1, 0x70, 0x70, 0x47,
+	0x2D, 0xE9, 0xF7, 0x4F, 0x86, 0xB0, 0x8A, 0x46, 0xD2, 0xE9, 0x00, 0x01,
+	0xCD, 0xE9, 0x00, 0x01,
+	0xD2, 0xE9, 0x02, 0x01, 0xCD, 0xE9, 0x04, 0x01, 0x68, 0x46, 0x0F, 0xF0,
+	0x61, 0xFD, 0x04, 0xA8,
+	0x0F, 0xF0, 0x5E, 0xFD, 0xE2, 0x48, 0x00, 0x27, 0xB9, 0x46, 0x06, 0x78,
+	0x28, 0xE0, 0xF1, 0xB2,
+	0x06, 0x98, 0x0F, 0xF0, 0x6B, 0xFD, 0x80, 0x46, 0xDE, 0x48, 0xDD, 0xE9,
+	0x04, 0xB1, 0x05, 0x78,
+	0x01, 0x24, 0x00, 0x98, 0xB4, 0x40, 0x04, 0x40, 0x02, 0x91, 0x17, 0xE0,
+	0x38, 0xF9, 0x15, 0x10,
+	0x51, 0x45, 0x13, 0xDD, 0x20, 0x00, 0x0F, 0xD0, 0x2A, 0x46, 0x01, 0x20,
+	0x00, 0x21, 0x0F, 0xF0,
+	0x95, 0xFB, 0x02, 0x9A, 0x00, 0xEA, 0x0B, 0x00, 0x11, 0x40, 0x08, 0x43,
+	0x04, 0xD0, 0x09, 0xF1,
+	0x01, 0x00, 0x1F, 0xFA, 0x80, 0xF9, 0x01, 0xE0, 0x7F, 0x1C, 0xBF, 0xB2,
+	0x6D, 0x1E, 0xE5, 0xD2,
+	0x76, 0x1E, 0xD4, 0xD2, 0xC9, 0x48, 0x00, 0x68, 0x90, 0xF8, 0x5B, 0x12,
+	0xB9, 0x42, 0x07, 0xD8,
+	0x90, 0xF8, 0x5C, 0x12, 0x49, 0x45, 0x03, 0xD3, 0x01, 0x20, 0x09, 0xB0,
+	0xBD, 0xE8, 0xF0, 0x8F,
+	0x00, 0x20, 0xFA, 0xE7, 0xC0, 0x48, 0x10, 0xB5, 0x41, 0x78, 0x01, 0x70,
+	0x00, 0x21, 0x81, 0x70,
+	0xC1, 0x70, 0xFF, 0xF7, 0x1A, 0xFD, 0xBD, 0xE8, 0x10, 0x40, 0xFE, 0xF7,
+	0x59, 0xBE, 0xBA, 0x48,
+	0x00, 0x21, 0xBA, 0x4A, 0x01, 0x70, 0x41, 0x70, 0x12, 0x68, 0x92, 0xF8,
+	0x50, 0x22, 0x92, 0x07,
+	0x00, 0xD5, 0x01, 0x21, 0x41, 0x71, 0x01, 0x71, 0x70, 0x47, 0xB3, 0x49,
+	0x4A, 0x79, 0x01, 0x2A,
+	0x02, 0xD1, 0x00, 0x28, 0x00, 0xD1, 0x48, 0x71, 0x70, 0x47, 0xF0, 0xB5,
+	0x00, 0x24, 0x1C, 0x72,
+	0x04, 0x7E, 0x0D, 0x7E, 0x6C, 0x43, 0x04, 0xF0, 0xFF, 0x0C, 0x4F, 0xF0,
+	0xFF, 0x34, 0xE7, 0x07,
+	0x26, 0x46, 0x00, 0x25, 0x08, 0xE0, 0x00, 0xBF, 0x52, 0xF8, 0x25, 0xE0,
+	0xBE, 0x45, 0x01, 0xDD,
+	0x77, 0x46, 0x6E, 0xB2, 0x6D, 0x1C, 0xED, 0xB2, 0x65, 0x45, 0xF5, 0xD3,
+	0x00, 0x2E, 0x17, 0xDB,
+	0x01, 0x25, 0x1D, 0x72, 0x0D, 0x7E, 0x96, 0xFB, 0xF5, 0xF5, 0x6D, 0x1C,
+	0xED, 0xB2, 0x05, 0x44,
+	0xAF, 0x7C, 0x1F, 0x70, 0x2D, 0x7B, 0x1D, 0x71, 0x0D, 0x7E, 0x96, 0xFB,
+	0xF5, 0xF7, 0x05, 0xFB,
+	0x17, 0x65, 0x6D, 0x1C, 0xED, 0xB2, 0x0D, 0x44, 0xAF, 0x7C, 0x9F, 0x70,
+	0x2D, 0x7B, 0x9D, 0x71,
+	0xBC, 0xF1, 0x01, 0x0F, 0x30, 0xD9, 0x95, 0x4D, 0x2D, 0x68, 0x95, 0xF8,
+	0x51, 0x52, 0xED, 0x07,
+	0x2A, 0xD0, 0x25, 0x46, 0x00, 0x27, 0x3C, 0x46, 0x0A, 0xE0, 0x00, 0xBF,
+	0x52, 0xF8, 0x24, 0xE0,
+	0xBE, 0x45, 0x03, 0xDD, 0xA6, 0x42, 0x01, 0xD0, 0x77, 0x46, 0x65, 0xB2,
+	0x64, 0x1C, 0xE4, 0xB2,
+	0x64, 0x45, 0xF3, 0xD3, 0x00, 0x2D, 0x17, 0xDB, 0x02, 0x22, 0x1A, 0x72,
+	0x0A, 0x7E, 0x95, 0xFB,
+	0xF2, 0xF2, 0x52, 0x1C, 0xD2, 0xB2, 0x10, 0x44, 0x82, 0x7C, 0x5A, 0x70,
+	0x00, 0x7B, 0x58, 0x71,
+	0x08, 0x7E, 0x95, 0xFB, 0xF0, 0xF2, 0x00, 0xFB, 0x12, 0x50, 0x40, 0x1C,
+	0xC0, 0xB2, 0x08, 0x44,
+	0x81, 0x7C, 0xD9, 0x70, 0x00, 0x7B, 0xD8, 0x71, 0xF0, 0xBD, 0x2D, 0xE9,
+	0xFF, 0x47, 0x0F, 0x46,
+	0x06, 0x46, 0xD2, 0xE9, 0x00, 0x01, 0xCD, 0xE9, 0x00, 0x01, 0xD2, 0xE9,
+	0x02, 0x01, 0xCD, 0xE9,
+	0x02, 0x01, 0x68, 0x46, 0x0F, 0xF0, 0x84, 0xFC, 0x02, 0xA8, 0x0F, 0xF0,
+	0x81, 0xFC, 0x00, 0x25,
+	0xDF, 0xF8, 0xD0, 0x91, 0xDF, 0xF8, 0xC8, 0x81, 0x2F, 0xE0, 0x2A, 0x46,
+	0x01, 0x20, 0x00, 0x21,
+	0x0F, 0xF0, 0xCC, 0xFA, 0xDD, 0xE9, 0x00, 0x23, 0x10, 0x40, 0x19, 0x40,
+	0x08, 0x43, 0x01, 0xD0,
+	0x00, 0x24, 0x17, 0xE0, 0x99, 0xF8, 0x00, 0x00, 0x39, 0x46, 0x42, 0x00,
+	0x30, 0x46, 0x0F, 0xF0,
+	0xF4, 0xFA, 0x13, 0xE0, 0x22, 0x46, 0x01, 0x20, 0x00, 0x21, 0x0F, 0xF0,
+	0xB7, 0xFA, 0xDD, 0xE9,
+	0x02, 0x23, 0x10, 0x40, 0x19, 0x40, 0x08, 0x43, 0x03, 0xD1, 0x37, 0xF8,
+	0x14, 0x00, 0x26, 0xF8,
+	0x14, 0x00, 0x64, 0x1C, 0x99, 0xF8, 0x00, 0x00, 0x84, 0x42, 0xEB, 0xDB,
+	0x99, 0xF8, 0x00, 0x00,
+	0x6D, 0x1C, 0x07, 0xEB, 0x40, 0x07, 0x06, 0xEB, 0x40, 0x06, 0x98, 0xF8,
+	0x00, 0x00, 0x85, 0x42,
+	0xCB, 0xDB, 0xBD, 0xE8, 0xFF, 0x87, 0x2D, 0xE9, 0xFF, 0x4F, 0x81, 0x46,
+	0x84, 0x1C, 0x80, 0x78,
+	0x81, 0xB0, 0x9A, 0x46, 0x15, 0x46, 0x60, 0xB1, 0x40, 0x1E, 0xC2, 0xB2,
+	0x22, 0x70, 0xD5, 0xE9,
+	0x00, 0x67, 0x01, 0x20, 0x00, 0x21, 0x0F, 0xF0, 0x89, 0xFA, 0x06, 0x43,
+	0x0F, 0x43, 0xC5, 0xE9,
+	0x00, 0x67, 0x4F, 0xF0, 0x01, 0x08, 0xAA, 0xF1, 0x01, 0x0A, 0x2D, 0xE0,
+	0x09, 0xEB, 0x48, 0x00,
+	0x00, 0xF1, 0x02, 0x0B, 0x82, 0x78, 0x60, 0x78, 0xC1, 0x1C, 0x8A, 0x42,
+	0x1F, 0xD9, 0x50, 0x45,
+	0x0C, 0xDA, 0x40, 0x1C, 0xC2, 0xB2, 0x62, 0x70, 0xD5, 0xE9, 0x00, 0x76,
+	0x01, 0x20, 0x00, 0x21,
+	0x0F, 0xF0, 0x6C, 0xFA, 0x07, 0x43, 0x0E, 0x43, 0xC5, 0xE9, 0x00, 0x76,
+	0x9B, 0xF8, 0x00, 0x00,
+	0x68, 0xB1, 0x40, 0x1E, 0x8B, 0xF8, 0x00, 0x00, 0x22, 0x78, 0xD5, 0xE9,
+	0x00, 0x67, 0x01, 0x20,
+	0x00, 0x21, 0x0F, 0xF0, 0x5B, 0xFA, 0x06, 0x43, 0x0F, 0x43, 0xC5, 0xE9,
+	0x00, 0x67, 0x08, 0xF1,
+	0x01, 0x00, 0x5C, 0x46, 0x00, 0xF0, 0xFF, 0x08, 0x99, 0xF8, 0x18, 0x00,
+	0x40, 0x45, 0xCD, 0xD8,
+	0x60, 0x78, 0x50, 0x45, 0x0C, 0xDA, 0x40, 0x1C, 0xC2, 0xB2, 0x62, 0x70,
+	0xD5, 0xE9, 0x00, 0x46,
+	0x01, 0x20, 0x00, 0x21, 0x0F, 0xF0, 0x42, 0xFA, 0x04, 0x43, 0x0E, 0x43,
+	0xC5, 0xE9, 0x00, 0x46,
+	0x01, 0x20, 0x04, 0x46, 0x00, 0x90, 0x66, 0xE0, 0x02, 0x98, 0x22, 0x46,
+	0x00, 0x21, 0xD0, 0xE9,
+	0x00, 0x67, 0x01, 0x20, 0x0F, 0xF0, 0x32, 0xFA, 0x80, 0x46, 0x8B, 0x46,
+	0x06, 0xEA, 0x08, 0x06,
+	0x07, 0xEA, 0x0B, 0x07, 0x3E, 0x43, 0x27, 0xD0, 0xD5, 0xE9, 0x00, 0x67,
+	0x46, 0xEA, 0x08, 0x06,
+	0x47, 0xEA, 0x0B, 0x07, 0x62, 0x1E, 0x01, 0x20, 0x00, 0x21, 0xC5, 0xE9,
+	0x00, 0x67, 0x0F, 0xF0,
+	0x1D, 0xFA, 0x06, 0x40, 0x0F, 0x40, 0x3E, 0x43, 0x05, 0xD0, 0x00, 0x99,
+	0x09, 0xEB, 0x41, 0x00,
+	0x41, 0x78, 0x49, 0x1C, 0x41, 0x70, 0xD5, 0xE9, 0x00, 0x67, 0x62, 0x1C,
+	0x01, 0x20, 0x00, 0x21,
+	0x0F, 0xF0, 0x0C, 0xFA, 0x06, 0x40, 0x0F, 0x40, 0x3E, 0x43, 0x05, 0xD0,
+	0x00, 0x99, 0x09, 0xEB,
+	0x41, 0x01, 0x88, 0x78, 0x40, 0x1E, 0x88, 0x70, 0xD5, 0xE9, 0x00, 0x67,
+	0x62, 0x1E, 0x01, 0x20,
+	0x00, 0x21, 0x0F, 0xF0, 0xFB, 0xF9, 0x30, 0x40, 0x39, 0x40, 0x08, 0x43,
+	0x21, 0xD0, 0x58, 0xEA,
+	0x0B, 0x01, 0x0F, 0xD0, 0x00, 0x20, 0x07, 0xE0, 0x74, 0x05, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0xED, 0x06, 0x10, 0x00, 0xEE, 0x06, 0x10, 0x00, 0x06, 0x40, 0x07, 0xEA,
+	0xE0, 0x77, 0x3E, 0x43,
+	0x0B, 0xD1, 0x01, 0xE0, 0x01, 0x20, 0xEE, 0xE7, 0x02, 0x99, 0xD1, 0xE9,
+	0x00, 0x01, 0x00, 0xEA,
+	0x08, 0x00, 0x01, 0xEA, 0x0B, 0x01, 0x08, 0x43, 0x03, 0xD0, 0x00, 0x98,
+	0x40, 0x1C, 0xC0, 0xB2,
+	0x00, 0x90, 0x64, 0x1C, 0xE4, 0xB2, 0x54, 0x45, 0x96, 0xDB, 0x05, 0xB0,
+	0x56, 0xE6, 0x2D, 0xE9,
+	0xFF, 0x5F, 0x05, 0x46, 0xFE, 0x49, 0xDD, 0xF8, 0x38, 0xB0, 0x00, 0x20,
+	0x05, 0xEB, 0x40, 0x03,
+	0x40, 0x1C, 0x0C, 0x88, 0xC0, 0xB2, 0x1C, 0x80, 0x06, 0x28, 0xF7, 0xD3,
+	0x00, 0x20, 0x28, 0x73,
+	0xF8, 0x48, 0x00, 0x68, 0xB0, 0xF9, 0x6E, 0x82, 0xB2, 0xF9, 0x08, 0x00,
+	0x40, 0x45, 0x02, 0xDB,
+	0xB8, 0xF1, 0x00, 0x0F, 0x00, 0xD1, 0x80, 0x46, 0x4F, 0xF0, 0x01, 0x0A,
+	0x00, 0x24, 0x28, 0xE0,
+	0x03, 0x98, 0x05, 0xEB, 0x4A, 0x09, 0x22, 0x46, 0xD0, 0xE9, 0x00, 0x67,
+	0x01, 0x20, 0x00, 0x21,
+	0x0F, 0xF0, 0xA4, 0xF9, 0x06, 0x40, 0x0F, 0x40, 0x3E, 0x43, 0x04, 0xD1,
+	0x01, 0x98, 0x30, 0xF9,
+	0x14, 0x10, 0x41, 0x45, 0x0B, 0xDD, 0x99, 0xF8, 0x00, 0x00, 0xFF, 0x28,
+	0x04, 0xD1, 0x89, 0xF8,
+	0x00, 0x40, 0x28, 0x7B, 0x40, 0x1C, 0x28, 0x73, 0x89, 0xF8, 0x01, 0x40,
+	0x07, 0xE0, 0x99, 0xF8,
+	0x00, 0x00, 0xFF, 0x28, 0x03, 0xD0, 0x0A, 0xF1, 0x01, 0x00, 0x00, 0xF0,
+	0xFF, 0x0A, 0x64, 0x1C,
+	0xE4, 0xB2, 0x5C, 0x45, 0xD4, 0xD3, 0xBD, 0xE8, 0xFF, 0x9F, 0x2D, 0xE9,
+	0xFF, 0x4F, 0x85, 0xB0,
+	0x00, 0x20, 0x05, 0x46, 0x02, 0x90, 0x04, 0x90, 0xD7, 0x48, 0x9B, 0x46,
+	0x8A, 0x46, 0x06, 0x68,
+	0x01, 0x20, 0x81, 0x46, 0x05, 0x98, 0x01, 0x7E, 0x49, 0x45, 0x7D, 0xD3,
+	0x05, 0x98, 0x01, 0x27,
+	0x10, 0xF8, 0x19, 0x10, 0x40, 0x46, 0x61, 0xF3, 0x17, 0x40, 0x05, 0x99,
+	0x01, 0xEB, 0x49, 0x01,
+	0x49, 0x78, 0x61, 0xF3, 0x1F, 0x60, 0x80, 0x46, 0x69, 0xE0, 0x00, 0xBF,
+	0x1A, 0xF8, 0x17, 0x10,
+	0x40, 0x46, 0x61, 0xF3, 0x07, 0x00, 0x0A, 0xEB, 0x47, 0x01, 0x01, 0x23,
+	0x49, 0x78, 0x61, 0xF3,
+	0x0F, 0x20, 0x80, 0x46, 0x00, 0x20, 0x86, 0xF8, 0x0E, 0x01, 0x02, 0x46,
+	0xC3, 0x48, 0xC6, 0xF8,
+	0x00, 0x80, 0x44, 0x46, 0x31, 0x46, 0x00, 0x68, 0x06, 0xF0, 0x62, 0xFF,
+	0x0B, 0xEB, 0x85, 0x00,
+	0x44, 0x66, 0x00, 0x20, 0x4B, 0xF8, 0x25, 0x00, 0x4F, 0xF0, 0x00, 0x40,
+	0x01, 0x90, 0x00, 0x20,
+	0x01, 0x24, 0x03, 0x90, 0x3C, 0xE0, 0x00, 0xBF, 0x06, 0xEB, 0x44, 0x00,
+	0xB0, 0xF8, 0xB4, 0x10,
+	0x07, 0x98, 0x81, 0x42, 0x2D, 0xD9, 0xB6, 0x48, 0x06, 0xEB, 0x84, 0x03,
+	0xE2, 0xB2, 0x01, 0x68,
+	0xB2, 0x48, 0x00, 0x68, 0xFE, 0xF7, 0x7A, 0xFE, 0x01, 0x99, 0x00, 0x90,
+	0x88, 0x42, 0x0F, 0xDD,
+	0x03, 0x98, 0x48, 0xB1, 0xC1, 0xB2, 0xAD, 0x48, 0x32, 0x46, 0x00, 0x68,
+	0x07, 0xF0, 0x2D, 0xF8,
+	0x02, 0x98, 0x40, 0x1E, 0xC0, 0xB2, 0x02, 0x90, 0x00, 0x98, 0x01, 0x90,
+	0x60, 0xB2, 0x03, 0x90,
+	0x5B, 0xF8, 0x25, 0x10, 0x00, 0x98, 0x01, 0x44, 0x4B, 0xF8, 0x25, 0x10,
+	0x02, 0x98, 0x04, 0x99,
+	0x40, 0x1C, 0xC0, 0xB2, 0x02, 0x90, 0x01, 0x20, 0xA8, 0x40, 0x08, 0x43,
+	0x80, 0xB2, 0x04, 0x90,
+	0x05, 0xE0, 0x9E, 0x48, 0xE1, 0xB2, 0x32, 0x46, 0x00, 0x68, 0x07, 0xF0,
+	0x0E, 0xF8, 0x64, 0x1C,
+	0x96, 0xF8, 0x0E, 0x01, 0xA0, 0x42, 0xBF, 0xD2, 0x6D, 0x1C, 0xED, 0xB2,
+	0x7F, 0x1C, 0x9A, 0xF8,
+	0x18, 0x00, 0xB8, 0x42, 0x92, 0xD2, 0x00, 0xE0, 0x02, 0xE0, 0x09, 0xF1,
+	0x01, 0x00, 0x78, 0xE7,
+	0x94, 0x48, 0x04, 0x99, 0xA0, 0xF8, 0x19, 0x10, 0x02, 0x98, 0x6E, 0xE5,
+	0x2D, 0xE9, 0xFF, 0x5F,
+	0xDF, 0xF8, 0x44, 0x92, 0x91, 0x4E, 0x09, 0xF1, 0x20, 0x00, 0x03, 0x90,
+	0x06, 0xF1, 0x20, 0x00,
+	0x02, 0x90, 0x90, 0x49, 0x8E, 0x48, 0xDF, 0xF8, 0x40, 0xB2, 0x1E, 0xC9,
+	0x80, 0xE8, 0x1E, 0x00,
+	0x8E, 0x49, 0x00, 0x20, 0x8B, 0xF8, 0x00, 0x00, 0x08, 0x72, 0x82, 0x48,
+	0x31, 0x7E, 0x00, 0x68,
+	0x90, 0xF8, 0x51, 0x02, 0x00, 0xF0, 0x01, 0x08, 0x99, 0xF8, 0x18, 0x00,
+	0xC8, 0x42, 0x05, 0xD1,
+	0x43, 0x46, 0x83, 0x4A, 0x31, 0x46, 0x48, 0x46, 0xFE, 0xF7, 0x3E, 0xFD,
+	0x99, 0xF8, 0x18, 0x40,
+	0x37, 0x7E, 0x04, 0xFB, 0x07, 0xF0, 0x10, 0xF0, 0xFF, 0x05, 0x77, 0xD0,
+	0x19, 0x2D, 0x75, 0xD2,
+	0x05, 0x2C, 0x73, 0xD8, 0x05, 0x2F, 0x71, 0xD8, 0x79, 0x48, 0xFC, 0x21,
+	0x10, 0x30, 0x0F, 0xF0,
+	0x85, 0xF9, 0x77, 0x48, 0x39, 0x46, 0x10, 0x30, 0x80, 0xF8, 0xFA, 0x50,
+	0x20, 0x46, 0x0B, 0xF0,
+	0x67, 0xF9, 0x00, 0xF0, 0xFF, 0x0A, 0x72, 0x48, 0x08, 0x30, 0x01, 0x90,
+	0xB8, 0xF1, 0x00, 0x0F,
+	0x0D, 0xD0, 0x73, 0x48, 0x6E, 0x4A, 0x03, 0x99, 0x03, 0x78, 0x48, 0x46,
+	0xFF, 0xF7, 0xFB, 0xFD,
+	0x70, 0x48, 0xDD, 0xE9, 0x01, 0x21, 0x03, 0x78, 0x30, 0x46, 0xFF, 0xF7,
+	0xF4, 0xFD, 0x6E, 0x48,
+	0x00, 0x90, 0x6E, 0x48, 0x66, 0x49, 0xB0, 0xF9, 0x00, 0x30, 0x60, 0x48,
+	0x02, 0x68, 0x60, 0x48,
+	0x00, 0x68, 0xFE, 0xF7, 0x5A, 0xFD, 0x6A, 0x49, 0x5A, 0x4F, 0x61, 0x4B,
+	0x08, 0x60, 0x38, 0x68,
+	0x10, 0x33, 0x31, 0x46, 0x90, 0xF8, 0x6D, 0x22, 0x48, 0x46, 0xFF, 0xF7,
+	0xF6, 0xFE, 0x04, 0x46,
+	0x38, 0x68, 0x90, 0xF8, 0x51, 0x02, 0x80, 0x07, 0x28, 0xD5, 0x5D, 0x48,
+	0xDF, 0xF8, 0x58, 0x81,
+	0x56, 0x4F, 0x00, 0x78, 0x08, 0xF1, 0x30, 0x08, 0x00, 0x90, 0x30, 0x37,
+	0x54, 0x4B, 0x5D, 0x49,
+	0x40, 0x46, 0x03, 0x9A, 0xFF, 0xF7, 0x93, 0xFE, 0x56, 0x48, 0x5B, 0x49,
+	0x00, 0x78, 0x00, 0x90,
+	0xDD, 0xE9, 0x01, 0x32, 0x38, 0x46, 0xFF, 0xF7, 0x8A, 0xFE, 0x4A, 0x48,
+	0x98, 0xF8, 0x0C, 0x20,
+	0x81, 0x7D, 0x62, 0xF3, 0x03, 0x01, 0x81, 0x75, 0x3A, 0x7B, 0x62, 0xF3,
+	0x07, 0x11, 0x81, 0x75,
+	0x47, 0x4A, 0x39, 0x46, 0x10, 0x32, 0x40, 0x46, 0x00, 0xF0, 0x3A, 0xF8,
+	0xA2, 0x45, 0x06, 0xD8,
+	0xAC, 0x42, 0x04, 0xD8, 0x01, 0x21, 0x8B, 0xF8, 0x00, 0x10, 0x0A, 0xE0,
+	0x10, 0xE0, 0x00, 0x20,
+	0x3F, 0x4A, 0x8B, 0xF8, 0x00, 0x00, 0x41, 0x4B, 0x10, 0x32, 0x31, 0x46,
+	0x48, 0x46, 0xFF, 0xF7,
+	0xE4, 0xFC, 0x38, 0x48, 0x01, 0x7E, 0x6A, 0xF3, 0x03, 0x01, 0x64, 0xF3,
+	0x07, 0x11, 0x01, 0x76,
+	0xA9, 0xE6, 0x10, 0xB5, 0x01, 0x21, 0x31, 0x48, 0x08, 0xF0, 0x31, 0xFD,
+	0x02, 0x21, 0x3F, 0x48,
+	0x08, 0xF0, 0xD5, 0xFC, 0x04, 0x21, 0x2C, 0x48, 0x08, 0xF0, 0xD1, 0xFC,
+	0xFF, 0xF7, 0x36, 0xFF,
+	0xFE, 0xF7, 0x2D, 0xFE, 0x02, 0x21, 0x39, 0x48, 0x08, 0xF0, 0xE6, 0xFC,
+	0x04, 0x21, 0x26, 0x48,
+	0x08, 0xF0, 0xE2, 0xFC, 0xBD, 0xE8, 0x10, 0x40, 0x01, 0x21, 0x24, 0x48,
+	0x08, 0xF0, 0xAA, 0xBD,
+	0x2D, 0xE9, 0xF0, 0x47, 0x14, 0x46, 0x0D, 0x46, 0x06, 0x46, 0x00, 0xF0,
+	0x8B, 0xF8, 0x30, 0x7B,
+	0x29, 0x7B, 0x1C, 0x4F, 0x48, 0x43, 0xC5, 0xB2, 0x01, 0x20, 0x30, 0xE0,
+	0x00, 0x21, 0x0A, 0x46,
+	0x94, 0xF8, 0xFA, 0x60, 0x0C, 0xE0, 0x00, 0xBF, 0x54, 0xF8, 0x22, 0x30,
+	0x8B, 0x42, 0x06, 0xDD,
+	0x04, 0xEB, 0x02, 0x0C, 0x9C, 0xF8, 0xE1, 0xC0, 0x84, 0x45, 0x00, 0xD1,
+	0x19, 0x46, 0x52, 0x1C,
+	0x96, 0x42, 0xF1, 0xD8, 0x3A, 0x68, 0xB2, 0xF8, 0x70, 0x22, 0x8A, 0x42,
+	0x15, 0xDA, 0x00, 0x22,
+	0x0F, 0xE0, 0xA3, 0x18, 0x93, 0xF8, 0xE1, 0x60, 0x86, 0x42, 0x09, 0xD1,
+	0x54, 0xF8, 0x22, 0x60,
+	0x4F, 0xF0, 0x64, 0x0C, 0x06, 0xFB, 0x0C, 0xF6, 0x96, 0xFB, 0xF1, 0xF6,
+	0x83, 0xF8, 0xC8, 0x60,
+	0x52, 0x1C, 0x94, 0xF8, 0xFA, 0x30, 0x93, 0x42, 0xEB, 0xD8, 0x40, 0x1C,
+	0xC0, 0xB2, 0x27, 0xE0,
+	0xFC, 0x78, 0x01, 0x00, 0x4C, 0x07, 0x10, 0x00, 0x58, 0x05, 0x10, 0x00,
+	0x50, 0x06, 0x10, 0x00,
+	0x14, 0x07, 0x10, 0x00, 0x0A, 0x44, 0x01, 0x20, 0x18, 0x2A, 0x10, 0x00,
+	0x58, 0x2A, 0x10, 0x00,
+	0x60, 0x2B, 0x10, 0x00, 0x40, 0x2B, 0x10, 0x00, 0x57, 0x05, 0x10, 0x00,
+	0x0C, 0x2A, 0x10, 0x00,
+	0xED, 0x06, 0x10, 0x00, 0xEE, 0x06, 0x10, 0x00, 0x84, 0x06, 0x10, 0x00,
+	0x92, 0x06, 0x10, 0x00,
+	0x7C, 0x06, 0x10, 0x00, 0x94, 0x0B, 0x01, 0x20, 0xBE, 0x0B, 0x01, 0x20,
+	0x60, 0x06, 0x10, 0x00,
+	0xA8, 0x42, 0xA3, 0xD9, 0x00, 0x26, 0x35, 0x46, 0xB8, 0x46, 0xB1, 0x46,
+	0xDF, 0xF8, 0xD4, 0xA0,
+	0x18, 0xE0, 0xD8, 0xF8, 0x00, 0x00, 0x67, 0x19, 0x97, 0xF8, 0xC8, 0x10,
+	0x90, 0xF8, 0x72, 0x02,
+	0x81, 0x42, 0x0E, 0xD2, 0x04, 0xEB, 0x85, 0x01, 0x00, 0x22, 0x64, 0x31,
+	0xDA, 0xF8, 0x00, 0x00,
+	0x06, 0xF0, 0xCE, 0xFC, 0x44, 0xF8, 0x25, 0x90, 0x97, 0xF8, 0xC8, 0x00,
+	0xB0, 0x42, 0x00, 0xD2,
+	0x06, 0x46, 0x6D, 0x1C, 0x94, 0xF8, 0xFA, 0x00, 0xA8, 0x42, 0xE2, 0xD8,
+	0x26, 0x48, 0xC6, 0x75,
+	0xBD, 0xE8, 0xF0, 0x87, 0x2D, 0xE9, 0xF8, 0x4F, 0x82, 0x46, 0x01, 0x24,
+	0x16, 0x46, 0x0F, 0x46,
+	0x20, 0x46, 0x9A, 0xF8, 0x0C, 0x10, 0x81, 0x46, 0x49, 0x45, 0x38, 0xD3,
+	0x1A, 0xF8, 0x14, 0x00,
+	0x8D, 0xF8, 0x02, 0x00, 0x0A, 0xEB, 0x44, 0x00, 0x40, 0x78, 0x8D, 0xF8,
+	0x03, 0x00, 0x01, 0x20,
+	0x26, 0xE0, 0x00, 0xBF, 0x17, 0xF8, 0x14, 0x00, 0x8D, 0xF8, 0x00, 0x00,
+	0x07, 0xEB, 0x44, 0x00,
+	0x00, 0x25, 0x40, 0x78, 0x8D, 0xF8, 0x01, 0x00, 0x12, 0xE0, 0x00, 0xBF,
+	0x06, 0xEB, 0x05, 0x0B,
+	0x9B, 0xF8, 0xE1, 0x00, 0x58, 0xB9, 0x06, 0xEB, 0x85, 0x01, 0x68, 0x46,
+	0x64, 0x31, 0x06, 0xF0,
+	0x7B, 0xFC, 0x20, 0xB1, 0x8B, 0xF8, 0xE1, 0x40, 0x64, 0x20, 0x8B, 0xF8,
+	0xC8, 0x00, 0x6D, 0x1C,
+	0x96, 0xF8, 0xFA, 0x00, 0xA8, 0x42, 0xE9, 0xD8, 0x64, 0x1C, 0xE4, 0xB2,
+	0x08, 0xF1, 0x01, 0x00,
+	0x39, 0x7B, 0x80, 0x46, 0x41, 0x45, 0xD5, 0xD2, 0x09, 0xF1, 0x01, 0x00,
+	0xC1, 0xE7, 0xBD, 0xE8,
+	0xF8, 0x8F, 0x00, 0x00, 0x50, 0x06, 0x10, 0x00, 0x0A, 0x44, 0x01, 0x20,
+	0x2D, 0xE9, 0xFF, 0x4F,
+	0xCE, 0x4B, 0x83, 0xB0, 0x1B, 0x68, 0xB3, 0xF9, 0xC2, 0x42, 0xB3, 0xF9,
+	0xC4, 0xE2, 0x99, 0xE0,
+	0x47, 0xF6, 0xFF, 0x76, 0xF7, 0x43, 0x06, 0x9D, 0x08, 0xE0, 0x00, 0xBF,
+	0x31, 0xF9, 0x15, 0x30,
+	0xB3, 0x42, 0x00, 0xDA, 0x1E, 0x46, 0xBB, 0x42, 0x00, 0xDD, 0x1F, 0x46,
+	0x6D, 0x1E, 0xF5, 0xD1,
+	0xAB, 0x46, 0x00, 0x2F, 0x01, 0xDA, 0xBB, 0x46, 0x02, 0xE0, 0x00, 0x2E,
+	0x00, 0xDD, 0xB3, 0x46,
+	0x00, 0x26, 0x37, 0x46, 0xB2, 0x46, 0x35, 0x46, 0xB1, 0x46, 0x06, 0x9B,
+	0x13, 0xE0, 0x00, 0xBF,
+	0x31, 0xF9, 0x13, 0x80, 0xA8, 0xEB, 0x0B, 0x0C, 0xA4, 0x45, 0x0C, 0xDA,
+	0x0C, 0xEB, 0x04, 0x08,
+	0xB8, 0xF1, 0x00, 0x0F, 0x07, 0xDD, 0x03, 0xFB, 0x03, 0x77, 0x03, 0xFB,
+	0x0C, 0x55, 0x1E, 0x44,
+	0xE2, 0x44, 0x09, 0xF1, 0x01, 0x09, 0x5B, 0x1E, 0xEA, 0xD1, 0x07, 0xFB,
+	0x09, 0xF3, 0x06, 0xFB,
+	0x16, 0x33, 0x02, 0x93, 0x05, 0xFB, 0x09, 0xF3, 0x06, 0xFB, 0x1A, 0x33,
+	0x07, 0xFB, 0x0A, 0xF7,
+	0x01, 0x93, 0x05, 0xFB, 0x16, 0x73, 0x4F, 0xF0, 0x00, 0x0C, 0x00, 0x93,
+	0x67, 0x46, 0x66, 0x46,
+	0xE2, 0x46, 0x06, 0x9B, 0x28, 0xE0, 0xDD, 0xF8, 0x08, 0x80, 0x00, 0x25,
+	0xB8, 0xF1, 0x00, 0x0F,
+	0x0D, 0xD0, 0xDD, 0xE9, 0x00, 0x58, 0x08, 0xFB, 0x03, 0x58, 0x02, 0x9D,
+	0x98, 0xFB, 0xF5, 0xF5,
+	0xA5, 0x42, 0x01, 0xDD, 0x25, 0x46, 0x02, 0xE0, 0xE5, 0x42, 0x00, 0xD5,
+	0x65, 0x42, 0x31, 0xF8,
+	0x13, 0x80, 0x5D, 0x44, 0xA8, 0xEB, 0x05, 0x05, 0x2D, 0xB2, 0x7F, 0x1C,
+	0xA9, 0x46, 0xAC, 0x44,
+	0x75, 0x45, 0x07, 0xDA, 0x05, 0xEB, 0x0E, 0x08, 0xB8, 0xF1, 0x00, 0x0F,
+	0x02, 0xDD, 0x4E, 0x44,
+	0x0A, 0xF1, 0x01, 0x0A, 0x20, 0xF8, 0x13, 0x90, 0x5B, 0x1E, 0xD4, 0xD1,
+	0x9C, 0xFB, 0xF7, 0xF5,
+	0xBA, 0xF1, 0x00, 0x0F, 0x01, 0xD1, 0x4F, 0xF0, 0x01, 0x0A, 0x96, 0xFB,
+	0xFA, 0xF3, 0x00, 0x2D,
+	0x01, 0xDB, 0x2F, 0x46, 0x00, 0xE0, 0x6F, 0x42, 0x1E, 0x1E, 0x00, 0xDA,
+	0x5E, 0x42, 0xB7, 0xEB,
+	0x46, 0x0F, 0x00, 0xDD, 0x1D, 0x46, 0x06, 0x9B, 0x05, 0xE0, 0x00, 0xBF,
+	0x30, 0xF8, 0x13, 0x60,
+	0x76, 0x1B, 0x20, 0xF8, 0x13, 0x60, 0x5B, 0x1E, 0xF8, 0xD1, 0x06, 0x9B,
+	0x01, 0xEB, 0x43, 0x01,
+	0x00, 0xEB, 0x43, 0x00, 0x52, 0x1E, 0xBF, 0xF4, 0x63, 0xAF, 0x07, 0xB0,
+	0xBD, 0xE8, 0xF0, 0x8F,
+	0x2D, 0xE9, 0xF7, 0x4F, 0x79, 0x4D, 0x7A, 0x4C, 0x7A, 0x4F, 0x28, 0x68,
+	0x0E, 0x46, 0x90, 0xF8,
+	0xC0, 0x02, 0xC0, 0x07, 0x00, 0xD0, 0x3C, 0x68, 0x03, 0x20, 0xF8, 0xF7,
+	0x9A, 0xF9, 0x77, 0x48,
+	0xDF, 0xF8, 0xD4, 0xB1, 0x31, 0x46, 0x02, 0x68, 0xBB, 0xF9, 0x00, 0x30,
+	0x20, 0x46, 0x0B, 0xF0,
+	0xB0, 0xFE, 0x03, 0x20, 0xF8, 0xF7, 0xA8, 0xF9, 0x28, 0x68, 0xDF, 0xF8,
+	0xC4, 0xA1, 0x71, 0x4E,
+	0x90, 0xF8, 0xC0, 0x02, 0xC0, 0x07, 0x06, 0xD0, 0x9A, 0xF8, 0x00, 0x30,
+	0x32, 0x78, 0x21, 0x46,
+	0x67, 0x48, 0xFF, 0xF7, 0x2B, 0xFF, 0xB9, 0x46, 0x65, 0x4A, 0x33, 0x78,
+	0x4F, 0xF0, 0x00, 0x08,
+	0x54, 0x46, 0x38, 0x68, 0x16, 0xE0, 0x00, 0xBF, 0xA0, 0xF8, 0x00, 0x80,
+	0x01, 0x21, 0x09, 0xE0,
+	0x00, 0xEB, 0x41, 0x07, 0x32, 0xF8, 0x11, 0xC0, 0x37, 0xF8, 0x02, 0x7C,
+	0x67, 0x44, 0x20, 0xF8,
+	0x11, 0x70, 0x49, 0x1C, 0x27, 0x78, 0xB9, 0x42, 0xF2, 0xDB, 0xF9, 0xB2,
+	0x02, 0xEB, 0x41, 0x02,
+	0x00, 0xEB, 0x41, 0x00, 0x5B, 0x1E, 0xE7, 0xD2, 0x5B, 0x48, 0x5C, 0x4F,
+	0x02, 0x9B, 0x02, 0x68,
+	0xD9, 0xF8, 0x00, 0x10, 0x38, 0x68, 0x00, 0xF0, 0x73, 0xFA, 0x28, 0x68,
+	0x90, 0xF8, 0xC0, 0x02,
+	0x80, 0x07, 0x06, 0xD5, 0x23, 0x78, 0x32, 0x78, 0x39, 0x68, 0x00, 0x98,
+	0x00, 0xF0, 0x1C, 0xF8,
+	0x06, 0xE0, 0xBB, 0xF9, 0x00, 0x00, 0x39, 0x68, 0x42, 0x00, 0x00, 0x98,
+	0x0E, 0xF0, 0x55, 0xFE,
+	0x28, 0x68, 0x90, 0xF8, 0xC0, 0x02, 0x00, 0x07, 0x08, 0xD5, 0x00, 0x99,
+	0x23, 0x78, 0x32, 0x78,
+	0x03, 0xB0, 0x08, 0x46, 0xBD, 0xE8, 0xF0, 0x4F, 0x00, 0xF0, 0x05, 0xBC,
+	0xBD, 0xE8, 0xFE, 0x8F,
+	0x47, 0x49, 0x00, 0x20, 0x08, 0x70, 0x70, 0x47, 0x2D, 0xE9, 0xF0, 0x4F,
+	0xA7, 0xB0, 0x1C, 0x46,
+	0x0D, 0x46, 0x06, 0x46, 0x17, 0x46, 0xEA, 0x46, 0x0D, 0xF1, 0x4C, 0x0B,
+	0x3C, 0xE0, 0x00, 0x22,
+	0x60, 0x1E, 0x00, 0xF0, 0xFF, 0x09, 0x11, 0x46, 0x10, 0x46, 0x11, 0xE0,
+	0x35, 0xF9, 0x10, 0x30,
+	0x1A, 0x44, 0x43, 0x1C, 0x92, 0xFB, 0xF3, 0xFC, 0x2A, 0xF8, 0x10, 0xC0,
+	0xA9, 0xEB, 0x00, 0x0C,
+	0x40, 0x1C, 0x35, 0xF9, 0x1C, 0x80, 0x41, 0x44, 0x91, 0xFB, 0xF3, 0xF3,
+	0x2B, 0xF8, 0x1C, 0x30,
+	0xA0, 0x42, 0xEB, 0xDB, 0x20, 0x46, 0x52, 0x46, 0x5B, 0x46, 0x0C, 0xE0,
+	0x32, 0xF9, 0x10, 0x10,
+	0x33, 0xF9, 0x10, 0xC0, 0x61, 0x44, 0x35, 0xF8, 0x10, 0xC0, 0x01, 0xEB,
+	0xD1, 0x71, 0xAC, 0xEB,
+	0x61, 0x01, 0x26, 0xF8, 0x10, 0x10, 0x40, 0x1E, 0xF0, 0xD2, 0x20, 0x48,
+	0x00, 0x68, 0x90, 0xF8,
+	0xC0, 0x02, 0x40, 0x07, 0x04, 0xD5, 0x31, 0x46, 0x22, 0x46, 0x08, 0x46,
+	0x00, 0xF0, 0x08, 0xF8,
+	0x05, 0xEB, 0x44, 0x05, 0x06, 0xEB, 0x44, 0x06, 0x7F, 0x1E, 0xC0, 0xD2,
+	0x27, 0xB0, 0x35, 0xE7,
+	0xF0, 0xB5, 0x16, 0x4B, 0x00, 0x26, 0x35, 0x46, 0xD3, 0xF8, 0x00, 0xE0,
+	0x34, 0x46, 0x13, 0x46,
+	0xBE, 0xF9, 0xC6, 0x72, 0xC7, 0xF1, 0x00, 0x0C, 0x06, 0xE0, 0x00, 0xBF,
+	0x31, 0xF9, 0x13, 0x70,
+	0x67, 0x45, 0x01, 0xDA, 0x3E, 0x44, 0x6D, 0x1C, 0x5B, 0x1E, 0xF7, 0xD2,
+	0x00, 0x2D, 0x01, 0xDD,
+	0x96, 0xFB, 0xF5, 0xF4, 0xBE, 0xF8, 0xC8, 0x32, 0x5E, 0x42, 0xA6, 0x42,
+	0x00, 0xDD, 0x1C, 0x44,
+	0x53, 0x1B, 0x63, 0x43, 0x93, 0xFB, 0xF2, 0xF3, 0x05, 0xE0, 0x00, 0xBF,
+	0x31, 0xF8, 0x12, 0x40,
+	0xE4, 0x1A, 0x20, 0xF8, 0x12, 0x40, 0x52, 0x1E, 0xF8, 0xD2, 0xF0, 0xBD,
+	0x4C, 0x07, 0x10, 0x00,
+	0x4A, 0x0C, 0x01, 0x20, 0x80, 0x05, 0x10, 0x00, 0xFE, 0x06, 0x10, 0x00,
+	0x1C, 0x07, 0x10, 0x00,
+	0xEE, 0x06, 0x10, 0x00, 0xED, 0x06, 0x10, 0x00, 0x9C, 0x06, 0x10, 0x00,
+	0x18, 0x07, 0x10, 0x00,
+	0xF3, 0x06, 0x10, 0x00, 0x2D, 0xE9, 0xFF, 0x4F, 0x83, 0xB0, 0x9A, 0x46,
+	0x17, 0x46, 0x89, 0x46,
+	0x00, 0x25, 0x4F, 0xF0, 0xAA, 0x0B, 0xDD, 0xF8, 0x40, 0x80, 0x5B, 0xE0,
+	0x11, 0x98, 0x05, 0xFB,
+	0x00, 0xF6, 0x05, 0xEB, 0x85, 0x00, 0xC4, 0x00, 0x1A, 0xF8, 0x04, 0x00,
+	0x08, 0xB9, 0x38, 0x5D,
+	0xE8, 0xB3, 0x0A, 0xF8, 0x04, 0xB0, 0x39, 0xF9, 0x16, 0x00, 0x00, 0xF0,
+	0xC9, 0xF8, 0x29, 0xF8,
+	0x16, 0x00, 0x38, 0x5D, 0x98, 0xB3, 0x39, 0x19, 0x01, 0x91, 0x11, 0xF8,
+	0x28, 0x1C, 0x81, 0x42,
+	0x1E, 0xD0, 0xAA, 0x28, 0x1C, 0xD0, 0x01, 0x98, 0x00, 0xF8, 0x28, 0xBC,
+	0x11, 0x98, 0x31, 0x1A,
+	0x03, 0x98, 0x00, 0x91, 0x30, 0xF9, 0x11, 0x00, 0x00, 0xF0, 0xB2, 0xF8,
+	0x03, 0x9A, 0x00, 0x99,
+	0x22, 0xF8, 0x11, 0x00, 0x0A, 0xEB, 0x04, 0x01, 0x01, 0xF8, 0x28, 0xBC,
+	0x00, 0x99, 0x39, 0xF9,
+	0x11, 0x00, 0x00, 0xF0, 0xA5, 0xF8, 0x00, 0x99, 0x29, 0xF8, 0x11, 0x00,
+	0x38, 0x5D, 0x70, 0xB1,
+	0x01, 0x98, 0x90, 0xF8, 0x28, 0x10, 0x38, 0x5D, 0x81, 0x42, 0x1A, 0xD0,
+	0xAA, 0x28, 0x18, 0xD0,
+	0x01, 0x98, 0x80, 0xF8, 0x28, 0xB0, 0x11, 0x98, 0x06, 0x44, 0x03, 0x98,
+	0x00, 0xE0, 0x10, 0xE0,
+	0x30, 0xF9, 0x16, 0x00, 0x00, 0xF0, 0x8C, 0xF8, 0x03, 0x99, 0x21, 0xF8,
+	0x16, 0x00, 0x0A, 0xEB,
+	0x04, 0x01, 0x81, 0xF8, 0x28, 0xB0, 0x39, 0xF9, 0x16, 0x00, 0x00, 0xF0,
+	0x81, 0xF8, 0x29, 0xF8,
+	0x16, 0x00, 0x6D, 0x1C, 0x45, 0x45, 0xA1, 0xD3, 0x07, 0xB0, 0xBD, 0xE8,
+	0xF0, 0x8F, 0x44, 0x49,
+	0x00, 0x20, 0x08, 0x60, 0x70, 0x47, 0x42, 0x49, 0x08, 0x60, 0x70, 0x47,
+	0x2D, 0xE9, 0xF0, 0x4F,
+	0x05, 0x46, 0x40, 0x48, 0x8B, 0xB0, 0x17, 0x46, 0x00, 0x78, 0x8A, 0x46,
+	0x00, 0x28, 0x65, 0xD0,
+	0x3D, 0x48, 0x00, 0x68, 0x90, 0xF8, 0x00, 0x04, 0x80, 0x07, 0x5F, 0xD5,
+	0x3B, 0x48, 0x04, 0x90,
+	0x3B, 0x48, 0xDF, 0xF8, 0xDC, 0xB0, 0x01, 0x24, 0x90, 0xF8, 0x00, 0x80,
+	0xDB, 0xF8, 0x00, 0x90,
+	0x22, 0xE0, 0x01, 0x20, 0xA0, 0x40, 0x10, 0xEA, 0x09, 0x0F, 0x1C, 0xD1,
+	0x35, 0x48, 0x00, 0xEB,
+	0x84, 0x06, 0x04, 0x98, 0xB1, 0x78, 0x0E, 0xF0, 0xA9, 0xFE, 0x01, 0x46,
+	0xB2, 0x78, 0x00, 0x23,
+	0x0E, 0xE0, 0x30, 0x78, 0x06, 0xE0, 0x00, 0xBF, 0x11, 0xF8, 0x00, 0xC0,
+	0xA4, 0x45, 0x00, 0xD1,
+	0x0B, 0x54, 0x40, 0x1C, 0x96, 0xF8, 0x01, 0xC0, 0x84, 0x45, 0xF5, 0xDA,
+	0x28, 0x31, 0x52, 0x1C,
+	0xF0, 0x78, 0x90, 0x42, 0xED, 0xDA, 0x64, 0x1C, 0x44, 0x45, 0xDA, 0xD9,
+	0xA8, 0x46, 0x05, 0xF1,
+	0x02, 0x09, 0x00, 0x21, 0x21, 0x48, 0x0E, 0xF0, 0x89, 0xFE, 0x20, 0x4E,
+	0x07, 0x90, 0x00, 0x21,
+	0x70, 0x1C, 0x0E, 0xF0, 0x83, 0xFE, 0x05, 0xEB, 0x47, 0x04, 0xA5, 0x1E,
+	0x3E, 0x44, 0x06, 0x90,
+	0x70, 0x1E, 0x00, 0x21, 0x24, 0x1F, 0x0E, 0xF0, 0x79, 0xFE, 0x03, 0x90,
+	0xB0, 0x1E, 0x00, 0x21,
+	0x0E, 0xF0, 0x74, 0xFE, 0xCD, 0xE9, 0x00, 0xA7, 0xDD, 0xE9, 0x06, 0x32,
+	0x06, 0x46, 0x49, 0x46,
+	0x40, 0x46, 0xFF, 0xF7, 0x27, 0xFF, 0xCD, 0xE9, 0x00, 0xA7, 0x33, 0x46,
+	0x21, 0x46, 0x28, 0x46,
+	0x03, 0x9A, 0xFF, 0xF7, 0x1F, 0xFF, 0x00, 0x20, 0xCB, 0xF8, 0x00, 0x00,
+	0x0B, 0xB0, 0x84, 0xE7,
+	0x09, 0x49, 0x09, 0x68, 0x91, 0xF8, 0x08, 0x24, 0x42, 0x43, 0x64, 0x20,
+	0x92, 0xFB, 0xF0, 0xF0,
+	0xB1, 0xF8, 0x06, 0x24, 0x00, 0xB2, 0x82, 0x42, 0x01, 0xDA, 0xB1, 0xF9,
+	0x06, 0x04, 0x70, 0x47,
+	0x7C, 0x05, 0x10, 0x00, 0xA4, 0x06, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0xC2, 0x18, 0x01, 0x20,
+	0x39, 0x06, 0x10, 0x00, 0x5A, 0x1C, 0x01, 0x20, 0x2D, 0xE9, 0xF0, 0x4F,
+	0xFE, 0x4C, 0x80, 0x25,
+	0xFE, 0x4E, 0x23, 0x68, 0x93, 0xF8, 0x31, 0x10, 0x93, 0xF8, 0x30, 0x00,
+	0x01, 0xFB, 0x00, 0xF2,
+	0x02, 0xE0, 0x00, 0xBF, 0x26, 0xF8, 0x12, 0x50, 0x52, 0x1E, 0xFB, 0xD2,
+	0x93, 0xF8, 0xA0, 0x22,
+	0xA6, 0x46, 0x12, 0x07, 0x4F, 0xF0, 0x64, 0x08, 0x31, 0xD5, 0x4A, 0x1E,
+	0x02, 0xFB, 0x00, 0xFA,
+	0xDF, 0xF8, 0xC8, 0xB3, 0x03, 0xF5, 0x94, 0x69, 0x02, 0x46, 0x26, 0xE0,
+	0x19, 0xF8, 0x02, 0x30,
+	0x0A, 0xEB, 0x02, 0x04, 0xDB, 0x01, 0xB3, 0xFB, 0xF8, 0xF3, 0x0B, 0xEB,
+	0x44, 0x05, 0x0C, 0x46,
+	0x19, 0xE0, 0x80, 0x2B, 0x05, 0xDD, 0xC3, 0xF1, 0x80, 0x06, 0x66, 0x43,
+	0x96, 0xFB, 0xF1, 0xF6,
+	0x06, 0xE0, 0xA3, 0xF1, 0x80, 0x06, 0x06, 0xFB, 0x04, 0xF7, 0x97, 0xFB,
+	0xF1, 0xF7, 0xF6, 0x1B,
+	0xB5, 0xF9, 0x00, 0x70, 0x80, 0x36, 0x77, 0x43, 0xFE, 0x17, 0x07, 0xEB,
+	0x56, 0x66, 0xF6, 0x11,
+	0x2E, 0x80, 0xA5, 0xEB, 0x40, 0x05, 0x64, 0x1E, 0xE3, 0xD2, 0x52, 0x1E,
+	0xD6, 0xD2, 0xDE, 0xF8,
+	0x00, 0x20, 0xF2, 0x46, 0x92, 0xF8, 0xA0, 0x32, 0xDB, 0x06, 0x2F, 0xD5,
+	0x02, 0xF5, 0x98, 0x69,
+	0xD6, 0x4B, 0x4A, 0x1E, 0x42, 0x43, 0x03, 0xEB, 0x42, 0x05, 0x0A, 0x46,
+	0x24, 0xE0, 0x00, 0xBF,
+	0x19, 0xF8, 0x02, 0x30, 0xDB, 0x01, 0xB3, 0xFB, 0xF8, 0xF6, 0x03, 0x46,
+	0x18, 0xE0, 0x80, 0x2E,
+	0x05, 0xDD, 0xC6, 0xF1, 0x80, 0x04, 0x5C, 0x43, 0x94, 0xFB, 0xF0, 0xF4,
+	0x06, 0xE0, 0xA6, 0xF1,
+	0x80, 0x04, 0x04, 0xFB, 0x03, 0xF7, 0x97, 0xFB, 0xF0, 0xF7, 0xE4, 0x1B,
+	0x35, 0xF9, 0x13, 0x70,
+	0x80, 0x34, 0x67, 0x43, 0xFC, 0x17, 0x07, 0xEB, 0x54, 0x64, 0xE4, 0x11,
+	0x25, 0xF8, 0x13, 0x40,
+	0x5B, 0x1E, 0xE4, 0xD2, 0xA5, 0xEB, 0x40, 0x05, 0x52, 0x1E, 0xD9, 0xD2,
+	0xDA, 0xF8, 0x00, 0x40,
+	0x94, 0xF8, 0xA1, 0x22, 0xD2, 0x07, 0x20, 0xD0, 0xBC, 0x4E, 0x00, 0x23,
+	0x04, 0xF5, 0x9C, 0x64,
+	0x19, 0xE0, 0x00, 0xBF, 0x03, 0xFB, 0x00, 0xF2, 0x06, 0xEB, 0x42, 0x07,
+	0x00, 0x22, 0x0F, 0xE0,
+	0xA5, 0x5C, 0xED, 0x01, 0xB5, 0xFB, 0xF8, 0xFC, 0x37, 0xF9, 0x12, 0x50,
+	0x05, 0xFB, 0x0C, 0xF5,
+	0x4F, 0xEA, 0xE5, 0x7C, 0x05, 0xEB, 0x5C, 0x65, 0xED, 0x11, 0x27, 0xF8,
+	0x12, 0x50, 0x52, 0x1C,
+	0x82, 0x42, 0xED, 0xD3, 0x5B, 0x1C, 0x8B, 0x42, 0xE4, 0xD3, 0xBD, 0xE8,
+	0xF0, 0x8F, 0x30, 0xB5,
+	0x0B, 0xE0, 0x00, 0xBF, 0x31, 0xF9, 0x13, 0x40, 0x32, 0xF9, 0x13, 0x50,
+	0x6C, 0x43, 0xE5, 0x17,
+	0x04, 0xEB, 0x55, 0x64, 0xE4, 0x11, 0x20, 0xF8, 0x13, 0x40, 0x5B, 0x1E,
+	0xF2, 0xD2, 0x30, 0xBD,
+	0x08, 0xB5, 0x00, 0x93, 0x13, 0x46, 0xA2, 0x4A, 0xB2, 0xF9, 0x00, 0x20,
+	0x0B, 0xF0, 0x06, 0xFC,
+	0x08, 0xBD, 0x2D, 0xE9, 0xF0, 0x5F, 0xDF, 0xF8, 0x70, 0x92, 0xDF, 0xF8,
+	0x78, 0xB2, 0xD9, 0xF8,
+	0x00, 0x10, 0xDB, 0xF8, 0x00, 0xC0, 0xB1, 0xF9, 0x00, 0x23, 0xB1, 0xF9,
+	0x22, 0x33, 0xB1, 0xF9,
+	0x42, 0x63, 0x5F, 0xEA, 0x8C, 0x70, 0x07, 0xD5, 0x97, 0x48, 0x00, 0x78,
+	0x01, 0x28, 0x03, 0xD1,
+	0xB1, 0xF9, 0x4E, 0x33, 0xB1, 0xF9, 0x50, 0x23, 0x94, 0x48, 0x47, 0x78,
+	0x01, 0x2F, 0x7C, 0xD0,
+	0x02, 0x2F, 0x04, 0xD3, 0xB1, 0xF8, 0x04, 0x03, 0x08, 0xB1, 0xB1, 0xF9,
+	0x04, 0x23, 0x90, 0x4D,
+	0x28, 0x78, 0x98, 0xB1, 0x91, 0xF8, 0x69, 0x03, 0x64, 0x24, 0x00, 0xFB,
+	0x02, 0xF8, 0x98, 0xFB,
+	0xF4, 0xF8, 0x42, 0x44, 0x00, 0xFB, 0x03, 0xF8, 0x70, 0x43, 0x98, 0xFB,
+	0xF4, 0xF8, 0x90, 0xFB,
+	0xF4, 0xF0, 0x43, 0x44, 0x30, 0x44, 0x12, 0xB2, 0x1B, 0xB2, 0x06, 0xB2,
+	0x85, 0x4C, 0xDF, 0xF8,
+	0x18, 0xA2, 0xDF, 0xF8, 0x18, 0xE2, 0x22, 0x80, 0xAA, 0xF8, 0x00, 0x30,
+	0xAE, 0xF8, 0x00, 0x60,
+	0x91, 0xF8, 0x02, 0x03, 0xDF, 0xF8, 0x08, 0x92, 0x10, 0x1A, 0x00, 0xB2,
+	0xA9, 0xF8, 0x00, 0x00,
+	0x91, 0xF8, 0x24, 0x83, 0xA3, 0xEB, 0x08, 0x08, 0x7E, 0x4B, 0xA3, 0xF8,
+	0x00, 0x80, 0x91, 0xF8,
+	0x44, 0x13, 0x76, 0x1A, 0x7C, 0x49, 0x5F, 0xEA, 0xCC, 0x78, 0x0E, 0x80,
+	0x01, 0xD0, 0x02, 0x2F,
+	0x02, 0xD3, 0xAA, 0xF8, 0x00, 0x20, 0x18, 0x80, 0xDA, 0x46, 0x5F, 0xEA,
+	0x8C, 0x76, 0x01, 0xD5,
+	0x02, 0x2F, 0x02, 0xD3, 0xAE, 0xF8, 0x00, 0x20, 0x08, 0x80, 0xB1, 0xF9,
+	0x00, 0x20, 0xB3, 0xF9,
+	0x00, 0x10, 0xC8, 0x46, 0x4F, 0x46, 0x0A, 0xF0, 0xF1, 0xFB, 0x70, 0x4E,
+	0x00, 0xB2, 0x70, 0x4A,
+	0x30, 0x80, 0x21, 0x88, 0x6F, 0x4B, 0x11, 0x80, 0xDF, 0xF8, 0x7C, 0x91,
+	0x39, 0x88, 0x19, 0x80,
+	0xD9, 0xF8, 0x00, 0x10, 0x91, 0xF8, 0x00, 0x74, 0xFF, 0x07, 0x10, 0xD0,
+	0x5F, 0x4F, 0x7F, 0x78,
+	0x0F, 0xB1, 0x91, 0xF8, 0x05, 0x74, 0xB1, 0xF8, 0x02, 0xC4, 0x67, 0x44,
+	0x17, 0x80, 0x91, 0xF8,
+	0x04, 0x14, 0x79, 0x1A, 0x09, 0xB2, 0x19, 0x80, 0x0A, 0xF0, 0xDE, 0xFB,
+	0x30, 0x80, 0x62, 0x4F,
+	0x62, 0x4A, 0x20, 0x88, 0x38, 0x80, 0x10, 0x80, 0x00, 0xE0, 0x0C, 0xE0,
+	0x60, 0x49, 0xB8, 0xF8,
+	0x00, 0x00, 0x08, 0x80, 0xD9, 0xF8, 0x00, 0x00, 0x90, 0xF8, 0x40, 0x34,
+	0xDB, 0x07, 0x26, 0xD0,
+	0x2B, 0x78, 0x6B, 0xB1, 0x23, 0xE0, 0x91, 0xF8, 0x03, 0x03, 0x10, 0x44,
+	0x02, 0xB2, 0x91, 0xF8,
+	0x25, 0x03, 0x18, 0x44, 0x03, 0xB2, 0x91, 0xF8, 0x45, 0x03, 0x30, 0x44,
+	0x06, 0xB2, 0x6E, 0xE7,
+	0xB0, 0xF8, 0x42, 0x34, 0x13, 0xB1, 0xB0, 0xF8, 0x42, 0x34, 0x3B, 0x80,
+	0xB0, 0xF8, 0x44, 0x34,
+	0x33, 0xB1, 0xB0, 0xF8, 0x44, 0x34, 0x13, 0x80, 0x90, 0xF8, 0x46, 0x04,
+	0x18, 0x1A, 0x08, 0x80,
+	0xB1, 0xF9, 0x00, 0x10, 0xB6, 0xF9, 0x00, 0x00, 0x0A, 0xF0, 0xA6, 0xFB,
+	0x30, 0x80, 0x49, 0x4E,
+	0x20, 0x88, 0x30, 0x80, 0xD9, 0xF8, 0x00, 0x00, 0x90, 0xF8, 0x20, 0x14,
+	0xC9, 0x07, 0x07, 0xD0,
+	0x29, 0x78, 0x29, 0xB9, 0xB0, 0xF8, 0x21, 0x14, 0x11, 0xB1, 0xB0, 0xF8,
+	0x21, 0x14, 0x31, 0x80,
+	0x9A, 0xF8, 0x00, 0x10, 0xC9, 0x06, 0x07, 0xD5, 0x3F, 0x49, 0x09, 0x78,
+	0x21, 0xB1, 0xB0, 0xF8,
+	0x6B, 0x12, 0x21, 0x80, 0xA8, 0xF8, 0x00, 0x10, 0x3C, 0x4C, 0xB0, 0xF9,
+	0xB2, 0x02, 0x20, 0x80,
+	0xB7, 0xF9, 0x00, 0x10, 0x0A, 0xF0, 0x80, 0xFB, 0x00, 0xB2, 0x20, 0x80,
+	0xB6, 0xF9, 0x00, 0x10,
+	0x0A, 0xF0, 0x7A, 0xFB, 0x20, 0x80, 0xBD, 0xE8, 0xF0, 0x9F, 0x2D, 0xE9,
+	0xFF, 0x4F, 0x8A, 0x46,
+	0x81, 0x46, 0x33, 0x49, 0x0D, 0x98, 0x93, 0x46, 0x4A, 0x0C, 0x04, 0x46,
+	0x08, 0xE0, 0x00, 0xBF,
+	0x3A, 0xF9, 0x14, 0x30, 0x93, 0x42, 0x00, 0xDA, 0x1A, 0x46, 0x8B, 0x42,
+	0x00, 0xDD, 0x19, 0x46,
+	0x64, 0x1E, 0xF5, 0xD2, 0x00, 0x25, 0x00, 0x29, 0x01, 0xDA, 0x0D, 0x46,
+	0x02, 0xE0, 0x00, 0x2A,
+	0x00, 0xDD, 0x15, 0x46, 0x00, 0x23, 0x1C, 0x46, 0x1E, 0x46, 0x19, 0x46,
+	0x1F, 0x46, 0x02, 0x46,
+	0x12, 0xE0, 0x00, 0xBF, 0x3A, 0xF9, 0x12, 0xC0, 0xAC, 0xEB, 0x05, 0x0C,
+	0xDC, 0x45, 0x0B, 0xDA,
+	0x0C, 0xEB, 0x0B, 0x08, 0xB8, 0xF1, 0x00, 0x0F, 0x06, 0xDD, 0x02, 0xFB,
+	0x02, 0x44, 0x02, 0xFB,
+	0x0C, 0x11, 0x13, 0x44, 0x66, 0x44, 0x7F, 0x1C, 0x52, 0x1E, 0xEB, 0xD2,
+	0x04, 0xFB, 0x07, 0xF2,
+	0x03, 0xFB, 0x13, 0x2E, 0x2E, 0xE0, 0x00, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x86, 0x12, 0x01, 0x20,
+	0xFE, 0x06, 0x10, 0x00, 0x04, 0x07, 0x10, 0x00, 0xF9, 0x06, 0x10, 0x00,
+	0x74, 0x07, 0x10, 0x00,
+	0xFD, 0x06, 0x10, 0x00, 0x8C, 0x06, 0x10, 0x00, 0x8E, 0x06, 0x10, 0x00,
+	0x90, 0x06, 0x10, 0x00,
+	0x92, 0x06, 0x10, 0x00, 0x94, 0x06, 0x10, 0x00, 0x96, 0x06, 0x10, 0x00,
+	0x98, 0x06, 0x10, 0x00,
+	0xA0, 0x06, 0x10, 0x00, 0xA2, 0x06, 0x10, 0x00, 0xA8, 0x06, 0x10, 0x00,
+	0xAA, 0x06, 0x10, 0x00,
+	0xAC, 0x06, 0x10, 0x00, 0xA6, 0x06, 0x10, 0x00, 0x74, 0x05, 0x10, 0x00,
+	0x9A, 0x06, 0x10, 0x00,
+	0x00, 0x80, 0xFF, 0xFF, 0x01, 0xFB, 0x07, 0xF2, 0x03, 0xFB, 0x16, 0x27,
+	0x74, 0x43, 0x01, 0xFB,
+	0x13, 0x46, 0x00, 0x24, 0x21, 0x46, 0x02, 0x46, 0x25, 0xE0, 0x00, 0x23,
+	0xBE, 0xF1, 0x00, 0x0F,
+	0x0F, 0xD0, 0x07, 0xFB, 0x02, 0x6C, 0x9C, 0xFB, 0xFE, 0xF3, 0xDC, 0x46,
+	0x5B, 0x45, 0x01, 0xDD,
+	0x63, 0x46, 0x06, 0xE0, 0xDD, 0xF8, 0x0C, 0xC0, 0x13, 0xEB, 0x0C, 0x0F,
+	0x01, 0xD5, 0x03, 0x9B,
+	0x5B, 0x42, 0x3A, 0xF8, 0x12, 0xC0, 0x2B, 0x44, 0xAC, 0xEB, 0x03, 0x03,
+	0xDD, 0xF8, 0x0C, 0xC0,
+	0x1B, 0xB2, 0x63, 0x45, 0x05, 0xDA, 0x9C, 0x44, 0xBC, 0xF1, 0x00, 0x0F,
+	0x01, 0xDD, 0x1C, 0x44,
+	0x49, 0x1C, 0x29, 0xF8, 0x12, 0x30, 0x52, 0x1E, 0xD7, 0xD2, 0x01, 0xB9,
+	0x01, 0x21, 0x94, 0xFB,
+	0xF1, 0xF1, 0x04, 0xE0, 0x39, 0xF8, 0x10, 0x20, 0x52, 0x1A, 0x29, 0xF8,
+	0x10, 0x20, 0x40, 0x1E,
+	0xF8, 0xD2, 0xBD, 0xE8, 0xFF, 0x8F, 0x2D, 0xE9, 0xF8, 0x43, 0x1F, 0x46,
+	0xFE, 0x4B, 0x0E, 0x46,
+	0x05, 0x46, 0x1B, 0x68, 0x14, 0x46, 0xB3, 0xF9, 0xCA, 0x92, 0xB3, 0xF9,
+	0xCC, 0x82, 0x0A, 0xE0,
+	0x43, 0x46, 0x4A, 0x46, 0x31, 0x46, 0x28, 0x46, 0x00, 0x97, 0xFF, 0xF7,
+	0x3E, 0xFF, 0x06, 0xEB,
+	0x47, 0x06, 0x05, 0xEB, 0x47, 0x05, 0x64, 0x1E, 0xF2, 0xD2, 0xBD, 0xE8,
+	0xF8, 0x83, 0x08, 0xE0,
+	0x30, 0xF9, 0x12, 0x30, 0x00, 0x2B, 0x00, 0xDA, 0x5B, 0x42, 0x8B, 0x42,
+	0x01, 0xDD, 0x01, 0x20,
+	0x70, 0x47, 0x52, 0x1E, 0xF4, 0xD2, 0x00, 0x20, 0x70, 0x47, 0x05, 0xE0,
+	0x30, 0xF9, 0x12, 0x30,
+	0x8B, 0x42, 0x01, 0xDD, 0x01, 0x20, 0x70, 0x47, 0x52, 0x1E, 0xF7, 0xD2,
+	0x00, 0x20, 0x70, 0x47,
+	0x2D, 0xE9, 0xFC, 0x47, 0x04, 0x46, 0xE5, 0x48, 0xE5, 0x4F, 0x13, 0x46,
+	0x02, 0x68, 0x38, 0x68,
+	0xFF, 0xF7, 0x0E, 0xFE, 0x03, 0x20, 0xF7, 0xF7, 0xEC, 0xFC, 0xDF, 0xF8,
+	0x7C, 0x93, 0xDF, 0xF8,
+	0x84, 0x83, 0xE1, 0x4D, 0xD9, 0xF8, 0x00, 0x00, 0xE0, 0x4E, 0x90, 0xF8,
+	0xA0, 0x02, 0x80, 0x07,
+	0x15, 0xD5, 0xDF, 0x48, 0xB0, 0xF9, 0x00, 0x20, 0xDE, 0x48, 0xB0, 0xF9,
+	0x00, 0x10, 0xDE, 0x48,
+	0xB0, 0xF9, 0x00, 0x00, 0x0A, 0xF0, 0x62, 0xFA, 0x03, 0xB2, 0x29, 0x78,
+	0x30, 0x78, 0xCD, 0xE9,
+	0x00, 0x01, 0x39, 0x68, 0xD8, 0xF8, 0x00, 0x20, 0x08, 0x46, 0x00, 0xF0,
+	0x3F, 0xF9, 0xD7, 0x48,
+	0xD8, 0xF8, 0x00, 0x20, 0x39, 0x68, 0xB0, 0xF9, 0x00, 0x30, 0x20, 0x46,
+	0x0B, 0xF0, 0xE1, 0xF9,
+	0x03, 0x20, 0xF7, 0xF7, 0xD9, 0xFC, 0xD9, 0xF8, 0x00, 0x00, 0x4F, 0x46,
+	0x90, 0xF8, 0xA0, 0x02,
+	0x00, 0x06, 0x05, 0xD5, 0x21, 0x46, 0x2B, 0x78, 0x32, 0x78, 0x08, 0x46,
+	0xFF, 0xF7, 0x83, 0xFF,
+	0x38, 0x68, 0x90, 0xF8, 0xA0, 0x02, 0x40, 0x07, 0x25, 0xD5, 0x30, 0x78,
+	0x2E, 0x78, 0x32, 0x46,
+	0x1F, 0xE0, 0x00, 0x21, 0x03, 0x46, 0x0C, 0xE0, 0x03, 0xFB, 0x06, 0x27,
+	0x34, 0xF9, 0x17, 0x50,
+	0x00, 0x2D, 0x04, 0xDD, 0x09, 0xB1, 0x8D, 0x42, 0x03, 0xDA, 0x29, 0x46,
+	0x01, 0xE0, 0x00, 0x21,
+	0x43, 0x1C, 0x5B, 0x1E, 0xF0, 0xD2, 0x00, 0x29, 0x0B, 0xDD, 0x03, 0x46,
+	0x07, 0xE0, 0x00, 0xBF,
+	0x03, 0xFB, 0x06, 0x25, 0x34, 0xF8, 0x15, 0x70, 0x7F, 0x1A, 0x24, 0xF8,
+	0x15, 0x70, 0x5B, 0x1E,
+	0xF6, 0xD2, 0x52, 0x1E, 0xDD, 0xD2, 0xBD, 0xE8, 0xFC, 0x87, 0x2D, 0xE9,
+	0xF0, 0x5F, 0x92, 0x46,
+	0xB3, 0x4A, 0x4F, 0xF0, 0x00, 0x08, 0x8B, 0x46, 0x15, 0x78, 0x06, 0x46,
+	0x82, 0xF8, 0x00, 0x80,
+	0xFF, 0xF7, 0x9F, 0xFD, 0x02, 0x21, 0xAF, 0x48, 0x07, 0xF0, 0x59, 0xFE,
+	0xAE, 0x48, 0xAD, 0x4C,
+	0x2A, 0x46, 0x00, 0x78, 0x31, 0x46, 0x01, 0x28, 0x20, 0x68, 0x5F, 0xD0,
+	0xFF, 0xF7, 0x70, 0xFF,
+	0x9D, 0x4D, 0xA1, 0x4F, 0xDF, 0xF8, 0x84, 0x92, 0x28, 0x68, 0x90, 0xF8,
+	0xA1, 0x02, 0x80, 0x07,
+	0x06, 0xD5, 0x21, 0x68, 0x3B, 0x78, 0x99, 0xF8, 0x00, 0x20, 0x08, 0x46,
+	0x00, 0xF0, 0xDE, 0xF9,
+	0x29, 0x68, 0x9E, 0x4E, 0x91, 0xF8, 0xA0, 0x02, 0x02, 0x07, 0x05, 0xD4,
+	0xC0, 0x06, 0x03, 0xD4,
+	0x91, 0xF8, 0xA1, 0x02, 0xC0, 0x07, 0x06, 0xD0, 0x21, 0x68, 0xB6, 0xF9,
+	0x00, 0x30, 0x9B, 0x4A,
+	0x08, 0x46, 0xFF, 0xF7, 0x54, 0xFD, 0xB6, 0xF9, 0x00, 0x00, 0x21, 0x68,
+	0x42, 0x00, 0x98, 0x48,
+	0x00, 0x68, 0x0E, 0xF0, 0x52, 0xF9, 0x3A, 0x78, 0x99, 0xF8, 0x00, 0x10,
+	0x20, 0x68, 0xFF, 0xF7,
+	0x0D, 0xFC, 0xDF, 0xF8, 0x50, 0x92, 0x99, 0xF8, 0x00, 0x00, 0x10, 0xF0,
+	0x30, 0x0F, 0x04, 0xD0,
+	0x51, 0x46, 0x58, 0x46, 0x22, 0x68, 0xFE, 0xF7, 0xCD, 0xFA, 0x8F, 0x48,
+	0x8F, 0x4F, 0x40, 0x78,
+	0x02, 0x28, 0x28, 0x68, 0x90, 0xF8, 0xA0, 0x12, 0x4F, 0xEA, 0x81, 0x61,
+	0x19, 0xD3, 0x00, 0x29,
+	0x07, 0xDA, 0x21, 0x68, 0xB0, 0xF9, 0xB0, 0x22, 0xB6, 0xF9, 0x00, 0x30,
+	0x08, 0x46, 0x00, 0xF0,
+	0x3E, 0xF9, 0x28, 0x68, 0x90, 0xF8, 0xA0, 0x12, 0x49, 0x06, 0x15, 0xD5,
+	0xB0, 0xF9, 0xAE, 0x32,
+	0x83, 0x4A, 0x21, 0x68, 0x38, 0x68, 0x06, 0xF0, 0xF9, 0xFA, 0x14, 0xE0,
+	0xFF, 0xF7, 0x60, 0xFA,
+	0x9E, 0xE7, 0x00, 0x29, 0x08, 0xDA, 0xB0, 0xF9, 0xB0, 0x22, 0xB6, 0xF9,
+	0x00, 0x30, 0x21, 0x68,
+	0x38, 0x68, 0x00, 0xF0, 0x24, 0xF9, 0x06, 0xE0, 0xB6, 0xF9, 0x00, 0x00,
+	0x21, 0x68, 0x42, 0x00,
+	0x38, 0x68, 0x0E, 0xF0, 0x0A, 0xF9, 0x02, 0x21, 0x6E, 0x48, 0x07, 0xF0,
+	0x6B, 0xFE, 0x75, 0x48,
+	0x00, 0x78, 0x60, 0xB1, 0xD9, 0xF8, 0x00, 0x00, 0x73, 0x49, 0xC2, 0x06,
+	0x02, 0xD5, 0x0A, 0x78,
+	0x01, 0x2A, 0x21, 0xD0, 0x80, 0x06, 0x02, 0xD5, 0x08, 0x78, 0x02, 0x28,
+	0x1E, 0xD0, 0x6F, 0x48,
+	0xB6, 0xF9, 0x00, 0x20, 0xB0, 0xF9, 0x00, 0x10, 0x38, 0x68, 0xFF, 0xF7,
+	0xD6, 0xFE, 0x6C, 0x49,
+	0x6C, 0x4D, 0xA8, 0xB1, 0x01, 0x20, 0x08, 0x70, 0x01, 0x46, 0x02, 0x24,
+	0x6A, 0x48, 0x07, 0xF0,
+	0xB6, 0xFD, 0x6B, 0x48, 0x69, 0x4B, 0xB0, 0xF9, 0x00, 0x20, 0x67, 0x48,
+	0x01, 0x68, 0x38, 0x68,
+	0x00, 0xF0, 0xFF, 0xF8, 0x28, 0x60, 0x0E, 0xE0, 0x03, 0x20, 0xE4, 0xE5,
+	0x04, 0x20, 0xE2, 0xE5,
+	0x64, 0x4A, 0xC5, 0xF8, 0x00, 0x80, 0x01, 0x24, 0xC2, 0xF8, 0x00, 0x80,
+	0x5F, 0x4A, 0xC2, 0xF8,
+	0x00, 0x80, 0x81, 0xF8, 0x00, 0x80, 0x20, 0x46, 0xD5, 0xE5, 0x4E, 0x49,
+	0x10, 0xB5, 0x00, 0x20,
+	0x08, 0x60, 0x57, 0x49, 0x08, 0x70, 0xFF, 0xF7, 0x7B, 0xFA, 0xFF, 0xF7,
+	0x78, 0xFB, 0xBD, 0xE8,
+	0x10, 0x40, 0x00, 0xF0, 0x01, 0xB8, 0x07, 0xE4, 0x3B, 0x48, 0x10, 0xB5,
+	0x00, 0x68, 0x42, 0x49,
+	0x40, 0x4B, 0xB0, 0xF8, 0x00, 0x23, 0x0A, 0x80, 0xB0, 0xF8, 0x22, 0x13,
+	0x3C, 0x4C, 0x19, 0x80,
+	0xB0, 0xF8, 0x42, 0x33, 0x23, 0x80, 0x50, 0x4C, 0x22, 0x80, 0x50, 0x4A,
+	0x11, 0x80, 0x50, 0x49,
+	0x0B, 0x80, 0x4B, 0x49, 0xB0, 0xF8, 0xB2, 0x02, 0x08, 0x80, 0x10, 0xBD,
+	0x2D, 0xE9, 0xFF, 0x4F,
+	0x9B, 0x46, 0xDD, 0xE9, 0x0D, 0x19, 0x86, 0x46, 0xA5, 0xE0, 0x00, 0xBF,
+	0x01, 0x9A, 0x01, 0xFB,
+	0x09, 0xF0, 0x02, 0xEB, 0x40, 0x04, 0x02, 0x9A, 0x46, 0x4F, 0x02, 0xEB,
+	0x40, 0x06, 0x4F, 0xF0,
+	0x01, 0x0C, 0x0E, 0xEB, 0x40, 0x05, 0x7B, 0x0C, 0xE2, 0x46, 0x4A, 0x46,
+	0x15, 0xE0, 0x00, 0xBF,
+	0x36, 0xF8, 0x12, 0x00, 0x34, 0xF8, 0x12, 0x80, 0xA0, 0xEB, 0x08, 0x00,
+	0x00, 0xB2, 0x98, 0x42,
+	0x00, 0xDA, 0x03, 0x46, 0xB8, 0x42, 0x00, 0xDD, 0x07, 0x46, 0x00, 0x28,
+	0x02, 0xDD, 0x4F, 0xF0,
+	0x00, 0x0A, 0x02, 0xE0, 0x01, 0xDA, 0x4F, 0xF0, 0x00, 0x0C, 0x52, 0x1E,
+	0xE8, 0xD2, 0xBC, 0xF1,
+	0x00, 0x0F, 0x04, 0xD0, 0xBA, 0xF1, 0x00, 0x0F, 0x01, 0xD0, 0x00, 0x20,
+	0x0B, 0xE0, 0x5C, 0xEA,
+	0x0A, 0x00, 0x08, 0xD0, 0xBC, 0xF1, 0x00, 0x0F, 0x04, 0xD1, 0xBA, 0xF1,
+	0x00, 0x0F, 0x01, 0xD0,
+	0x38, 0x46, 0x00, 0xE0, 0x18, 0x46, 0x00, 0x27, 0x3B, 0x46, 0x4A, 0x46,
+	0xCB, 0xF1, 0x00, 0x0A,
+	0x10, 0xE0, 0x00, 0xBF, 0x36, 0xF8, 0x12, 0xC0, 0x34, 0xF8, 0x12, 0x80,
+	0xAC, 0xEB, 0x08, 0x0C,
+	0xAC, 0xEB, 0x00, 0x0C, 0x0F, 0xFA, 0x8C, 0xFC, 0xDC, 0x45, 0x03, 0xDA,
+	0xD4, 0x45, 0x01, 0xDD,
+	0x67, 0x44, 0x5B, 0x1C, 0x52, 0x1E, 0x3F, 0xE0, 0x4C, 0x07, 0x10, 0x00,
+	0x9C, 0x06, 0x10, 0x00,
+	0x18, 0x07, 0x10, 0x00, 0x1C, 0x07, 0x10, 0x00, 0xEE, 0x06, 0x10, 0x00,
+	0xED, 0x06, 0x10, 0x00,
+	0x90, 0x06, 0x10, 0x00, 0x8E, 0x06, 0x10, 0x00, 0x8C, 0x06, 0x10, 0x00,
+	0xFE, 0x06, 0x10, 0x00,
+	0x79, 0x07, 0x10, 0x00, 0x80, 0x05, 0x10, 0x00, 0xF3, 0x06, 0x10, 0x00,
+	0x86, 0x12, 0x01, 0x20,
+	0x14, 0x07, 0x10, 0x00, 0x04, 0x07, 0x10, 0x00, 0x74, 0x07, 0x10, 0x00,
+	0x10, 0x07, 0x10, 0x00,
+	0x0E, 0x7A, 0x01, 0x00, 0x64, 0x05, 0x10, 0x00, 0x66, 0x05, 0x10, 0x00,
+	0x98, 0x06, 0x10, 0x00,
+	0xF5, 0x06, 0x10, 0x00, 0x7C, 0x06, 0x10, 0x00, 0x50, 0x06, 0x10, 0x00,
+	0x84, 0x06, 0x10, 0x00,
+	0x9A, 0x06, 0x10, 0x00, 0x80, 0x06, 0x10, 0x00, 0x92, 0x06, 0x10, 0x00,
+	0x94, 0x06, 0x10, 0x00,
+	0x96, 0x06, 0x10, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xAC, 0xD2, 0x03, 0xB9,
+	0x01, 0x23, 0x97, 0xFB,
+	0xF3, 0xF2, 0x02, 0x44, 0x48, 0x46, 0x04, 0xE0, 0x34, 0xF8, 0x10, 0x30,
+	0x13, 0x44, 0x25, 0xF8,
+	0x10, 0x30, 0x40, 0x1E, 0xF8, 0xD2, 0x49, 0x1E, 0xBF, 0xF4, 0x58, 0xAF,
+	0xA9, 0xE5, 0x70, 0xB5,
+	0x00, 0x24, 0x26, 0x46, 0x0A, 0xE0, 0x00, 0xBF, 0x31, 0xF9, 0x14, 0x50,
+	0x95, 0x42, 0x02, 0xDA,
+	0x20, 0xF8, 0x14, 0x60, 0x01, 0xE0, 0x20, 0xF8, 0x14, 0x50, 0x64, 0x1C,
+	0x9C, 0x42, 0xF3, 0xDB,
+	0x70, 0xBD, 0x2D, 0xE9, 0xFF, 0x5F, 0x45, 0x4C, 0x88, 0x46, 0x00, 0x26,
+	0x07, 0x46, 0x92, 0x46,
+	0x35, 0x46, 0x4F, 0xF4, 0x66, 0x71, 0x40, 0x46, 0x26, 0x60, 0x0E, 0xF0,
+	0x4D, 0xF8, 0x00, 0x21,
+	0x40, 0x46, 0x0E, 0xF0, 0x5B, 0xF9, 0x81, 0x46, 0x00, 0x21, 0x38, 0x46,
+	0x0E, 0xF0, 0x4E, 0xF9,
+	0x00, 0x22, 0x3B, 0x4B, 0x3B, 0x4F, 0x29, 0xE0, 0x00, 0x21, 0x4F, 0xF0,
+	0x01, 0x0E, 0xDF, 0xF8,
+	0xE8, 0xB0, 0x18, 0xE0, 0x30, 0xF9, 0x11, 0x80, 0xD0, 0x45, 0x05, 0xDD,
+	0x09, 0xF8, 0x01, 0xE0,
+	0x30, 0xF9, 0x11, 0xC0, 0x76, 0x1C, 0x65, 0x44, 0xDB, 0xF8, 0x00, 0xC0,
+	0x30, 0xF9, 0x11, 0x80,
+	0xBC, 0xF8, 0x55, 0xC3, 0xE0, 0x45, 0x05, 0xDD, 0xD4, 0xF8, 0x00, 0xC0,
+	0x0C, 0xF1, 0x01, 0x0C,
+	0xC4, 0xF8, 0x00, 0xC0, 0x49, 0x1C, 0x93, 0xF8, 0x00, 0xC0, 0x61, 0x45,
+	0xE2, 0xDB, 0x0C, 0xF0,
+	0xFF, 0x01, 0x09, 0xF1, 0x28, 0x09, 0x00, 0xEB, 0x41, 0x00, 0x52, 0x1C,
+	0x39, 0x78, 0x8A, 0x42,
+	0xD2, 0xDB, 0x03, 0x98, 0x05, 0x60, 0x30, 0x46, 0x04, 0xB0, 0x9C, 0xE4,
+	0x2D, 0xE9, 0xF0, 0x43,
+	0x91, 0x46, 0x1C, 0x46, 0x35, 0xE0, 0x21, 0x4D, 0x4F, 0xF0, 0x01, 0x0C,
+	0x6A, 0x0C, 0xE0, 0x46,
+	0x4F, 0x46, 0x11, 0xE0, 0x07, 0xFB, 0x03, 0x46, 0x31, 0xF9, 0x16, 0x60,
+	0x96, 0x42, 0x00, 0xDA,
+	0x32, 0x46, 0xAE, 0x42, 0x00, 0xDD, 0x35, 0x46, 0x00, 0x2E, 0x02, 0xDD,
+	0x4F, 0xF0, 0x00, 0x08,
+	0x02, 0xE0, 0x01, 0xDA, 0x4F, 0xF0, 0x00, 0x0C, 0x7F, 0x1E, 0xEB, 0xD2,
+	0xBC, 0xF1, 0x00, 0x0F,
+	0x02, 0xD0, 0xB8, 0xF1, 0x00, 0x0F, 0x14, 0xD1, 0x5C, 0xEA, 0x08, 0x06,
+	0x11, 0xD0, 0xBC, 0xF1,
+	0x00, 0x0F, 0x03, 0xD1, 0xB8, 0xF1, 0x00, 0x0F, 0x00, 0xD0, 0x2A, 0x46,
+	0x4E, 0x46, 0x06, 0xE0,
+	0x06, 0xFB, 0x03, 0x45, 0x31, 0xF8, 0x15, 0x70, 0xBF, 0x1A, 0x20, 0xF8,
+	0x15, 0x70, 0x76, 0x1E,
+	0xF6, 0xD2, 0x64, 0x1E, 0xC7, 0xD2, 0xBD, 0xE8, 0xF0, 0x83, 0x00, 0x00,
+	0x80, 0x06, 0x10, 0x00,
+	0xEE, 0x06, 0x10, 0x00, 0xED, 0x06, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x00, 0x80, 0xFF, 0xFF,
+	0x70, 0x47, 0xA5, 0x4A, 0x30, 0xB4, 0x12, 0x68, 0x92, 0xF8, 0xA4, 0x23,
+	0x12, 0x09, 0x80, 0xF8,
+	0x28, 0x20, 0x0A, 0x68, 0x02, 0x62, 0x4A, 0x68, 0x42, 0x62, 0xB1, 0xF9,
+	0x02, 0x20, 0xD3, 0x17,
+	0x1B, 0x04, 0x43, 0xEA, 0x12, 0x43, 0x12, 0x04, 0x82, 0x60, 0xC3, 0x60,
+	0xB1, 0xF9, 0x00, 0x10,
+	0xCA, 0x17, 0x12, 0x04, 0x42, 0xEA, 0x11, 0x42, 0x09, 0x04, 0x01, 0x60,
+	0x42, 0x60, 0x10, 0x22,
+	0x01, 0x46, 0x30, 0xBC, 0x10, 0x30, 0x0D, 0xF0, 0x20, 0xBF, 0x2D, 0xE9,
+	0xF0, 0x4F, 0x92, 0x4F,
+	0x81, 0x46, 0x8A, 0x46, 0x38, 0x68, 0x8F, 0xB0, 0x16, 0x46, 0xB0, 0xF8,
+	0xA6, 0x13, 0x90, 0xF8,
+	0xAA, 0x53, 0x01, 0xFB, 0x01, 0xFB, 0xB0, 0xF8, 0xA8, 0x13, 0x01, 0xFB,
+	0x01, 0xF8, 0x0E, 0xF0,
+	0x5B, 0xF8, 0x00, 0x28, 0x38, 0x68, 0x02, 0xD0, 0x90, 0xF8, 0xAC, 0x43,
+	0x01, 0xE0, 0x90, 0xF8,
+	0xAB, 0x43, 0xAC, 0x42, 0x00, 0xD2, 0x25, 0x46, 0x00, 0x2E, 0x02, 0xDB,
+	0x89, 0xF8, 0x28, 0x60,
+	0x19, 0xE0, 0x09, 0xF1, 0x24, 0x01, 0x99, 0xF8, 0x28, 0x60, 0x08, 0x1F,
+	0x0A, 0xF0, 0x5B, 0xF8,
+	0x58, 0x45, 0x01, 0xDB, 0x26, 0x46, 0x02, 0xE0, 0x40, 0x45, 0x00, 0xDC,
+	0x2E, 0x46, 0x38, 0x68,
+	0x99, 0xF8, 0x28, 0x10, 0x90, 0xF8, 0xA4, 0x03, 0x00, 0xF0, 0x0F, 0x02,
+	0x30, 0x46, 0x0A, 0xF0,
+	0x6D, 0xF8, 0x89, 0xF8, 0x28, 0x00, 0x99, 0xF8, 0x28, 0x10, 0x74, 0x48,
+	0x00, 0xEB, 0x81, 0x00,
+	0x01, 0x68, 0xCA, 0x17, 0xCD, 0xE9, 0x07, 0x21, 0x41, 0x6C, 0xCA, 0x17,
+	0xCD, 0xE9, 0x04, 0x12,
+	0xD0, 0xF8, 0xCC, 0x20, 0xD0, 0xF8, 0x88, 0x50, 0xD4, 0x17, 0x01, 0x94,
+	0x93, 0x46, 0xDD, 0xE9,
+	0x07, 0x21, 0xD9, 0xF8, 0x08, 0x30, 0xD9, 0xF8, 0x0C, 0x40, 0xA3, 0xFB,
+	0x01, 0x07, 0x04, 0xFB,
+	0x01, 0x71, 0x03, 0xFB, 0x02, 0x11, 0xEE, 0x17, 0x4F, 0xF4, 0x80, 0x32,
+	0x00, 0x23, 0x0D, 0xF0,
+	0x98, 0xFE, 0xBA, 0xF9, 0x02, 0x30, 0xB9, 0xF9, 0x26, 0x20, 0x01, 0x9C,
+	0x9F, 0x18, 0xA7, 0xFB,
+	0x0B, 0x38, 0x4F, 0xEA, 0xE7, 0x7C, 0x0C, 0xFB, 0x0B, 0x82, 0x07, 0xFB,
+	0x04, 0x24, 0xB9, 0xF9,
+	0x22, 0x20, 0xA2, 0xFB, 0x05, 0xC8, 0xD7, 0x17, 0x07, 0xFB, 0x05, 0x87,
+	0x13, 0xEB, 0x0C, 0x03,
+	0x02, 0xFB, 0x06, 0x72, 0x54, 0x41, 0x1F, 0x1A, 0x64, 0xEB, 0x01, 0x04,
+	0xDD, 0xE9, 0x04, 0x12,
+	0xD9, 0xF8, 0x18, 0x30, 0xD9, 0xF8, 0x1C, 0xC0, 0xA3, 0xFB, 0x01, 0x08,
+	0x0C, 0xFB, 0x01, 0x81,
+	0x03, 0xFB, 0x02, 0x11, 0x4F, 0xF4, 0x80, 0x32, 0x00, 0x23, 0x0D, 0xF0,
+	0x6A, 0xFE, 0x38, 0x1A,
+	0x64, 0xEB, 0x01, 0x04, 0xCD, 0xE9, 0x0D, 0x04, 0x06, 0x94, 0x0A, 0x90,
+	0xDD, 0xE9, 0x07, 0x21,
+	0xD9, 0xF8, 0x00, 0x30, 0xD9, 0xF8, 0x04, 0x40, 0xA3, 0xFB, 0x01, 0x07,
+	0x04, 0xFB, 0x01, 0x71,
+	0x03, 0xFB, 0x02, 0x11, 0x4F, 0xF4, 0x80, 0x32, 0x00, 0x23, 0x0D, 0xF0,
+	0x52, 0xFE, 0xBA, 0xF9,
+	0x00, 0x30, 0xB9, 0xF9, 0x24, 0x20, 0x01, 0x9C, 0x13, 0x44, 0xA3, 0xFB,
+	0x0B, 0xC8, 0xDF, 0x17,
+	0x07, 0xFB, 0x0B, 0x82, 0x03, 0xFB, 0x04, 0x27, 0xB9, 0xF9, 0x20, 0x20,
+	0xA2, 0xFB, 0x05, 0x48,
+	0xD3, 0x17, 0x03, 0xFB, 0x05, 0x83, 0x02, 0xFB, 0x06, 0x32, 0x1C, 0xEB,
+	0x04, 0x03, 0x57, 0x41,
+	0x1C, 0x1A, 0x67, 0xEB, 0x01, 0x07, 0xDD, 0xE9, 0x04, 0x12, 0xD9, 0xF8,
+	0x10, 0x30, 0xD9, 0xF8,
+	0x14, 0x50, 0xA3, 0xFB, 0x01, 0x06, 0x05, 0xFB, 0x01, 0x61, 0x03, 0xFB,
+	0x02, 0x11, 0x4F, 0xF4,
+	0x80, 0x32, 0x00, 0x23, 0x0D, 0xF0, 0x25, 0xFE, 0x25, 0x1A, 0x67, 0xEB,
+	0x01, 0x07, 0xCD, 0xE9,
+	0x0B, 0x57, 0xD9, 0xF8, 0x20, 0x10, 0xC9, 0xF8, 0x24, 0x10, 0xDA, 0xF8,
+	0x00, 0x10, 0xC9, 0xF8,
+	0x20, 0x10, 0x10, 0x22, 0x49, 0x46, 0x09, 0xF1, 0x10, 0x00, 0x0D, 0xF0,
+	0x36, 0xFE, 0x10, 0x22,
+	0x0B, 0xA9, 0x48, 0x46, 0x0D, 0xF0, 0x31, 0xFE, 0x0A, 0x98, 0x4F, 0xF4,
+	0x00, 0x41, 0x06, 0x9C,
+	0x40, 0x18, 0x44, 0xF1, 0x00, 0x01, 0x4F, 0xF4, 0x80, 0x32, 0x00, 0x23,
+	0x0D, 0xF0, 0x01, 0xFE,
+	0xAA, 0xF8, 0x02, 0x00, 0x4F, 0xF4, 0x00, 0x40, 0x28, 0x18, 0x47, 0xF1,
+	0x00, 0x01, 0x4F, 0xF4,
+	0x80, 0x32, 0x00, 0x23, 0x0D, 0xF0, 0xF5, 0xFD, 0xAA, 0xF8, 0x00, 0x00,
+	0x0F, 0xB0, 0xBD, 0xE8,
+	0xF0, 0x8F, 0x70, 0xB5, 0x0D, 0x46, 0x04, 0x46, 0x01, 0x46, 0x10, 0x22,
+	0x10, 0x30, 0x0D, 0xF0,
+	0x0C, 0xFE, 0xB5, 0xF9, 0x02, 0x00, 0xC1, 0x17, 0x09, 0x04, 0x41, 0xEA,
+	0x10, 0x41, 0x00, 0x04,
+	0xA0, 0x60, 0xE1, 0x60, 0xB5, 0xF9, 0x00, 0x00, 0xC1, 0x17, 0x09, 0x04,
+	0x41, 0xEA, 0x10, 0x41,
+	0x00, 0x04, 0x20, 0x60, 0x61, 0x60, 0x70, 0xBD, 0x4C, 0x07, 0x10, 0x00,
+	0xFE, 0x78, 0x01, 0x00,
+	0x70, 0xB5, 0x04, 0x46, 0x00, 0x20, 0x84, 0xF8, 0x42, 0x01, 0x94, 0xF8,
+	0x3F, 0x01, 0xF8, 0x4D,
+	0x0E, 0x46, 0x01, 0x28, 0x0B, 0xD0, 0x0D, 0xF0, 0x37, 0xFF, 0x00, 0x28,
+	0x94, 0xF9, 0x4C, 0x01,
+	0x35, 0xD0, 0xB0, 0x42, 0x28, 0x68, 0x90, 0xF8, 0x9B, 0x03, 0x1A, 0xD1,
+	0x11, 0xE0, 0xF1, 0x48,
+	0x00, 0x78, 0x58, 0xB1, 0x0D, 0xF0, 0x28, 0xFF, 0x00, 0x28, 0x94, 0xF9,
+	0x4C, 0x01, 0x0B, 0xD0,
+	0xB0, 0x42, 0x28, 0x68, 0x90, 0xF8, 0x4D, 0x03, 0x03, 0xD0, 0x0A, 0xE0,
+	0x28, 0x68, 0x90, 0xF8,
+	0x4B, 0x03, 0x00, 0xF0, 0x0F, 0x00, 0x05, 0xE0, 0xB0, 0x42, 0x28, 0x68,
+	0x90, 0xF8, 0x4C, 0x03,
+	0xF7, 0xD0, 0x00, 0x09, 0x84, 0xF8, 0x42, 0x01, 0xE3, 0x48, 0x00, 0x78,
+	0x48, 0xB1, 0x29, 0x68,
+	0x94, 0xF8, 0x42, 0x01, 0x91, 0xF8, 0x63, 0x12, 0x01, 0xF0, 0x0F, 0x01,
+	0x08, 0x44, 0x84, 0xF8,
+	0x42, 0x01, 0x20, 0x46, 0x00, 0xF0, 0x4A, 0xF9, 0x01, 0x28, 0x06, 0xD0,
+	0x0F, 0xE0, 0xB0, 0x42,
+	0x28, 0x68, 0x90, 0xF8, 0x9A, 0x03, 0xE4, 0xD1, 0xDB, 0xE7, 0x29, 0x68,
+	0x94, 0xF8, 0x42, 0x01,
+	0x91, 0xF8, 0x9C, 0x13, 0x01, 0xF0, 0x0F, 0x01, 0x08, 0x44, 0x84, 0xF8,
+	0x42, 0x01, 0xD3, 0x48,
+	0xD3, 0x49, 0x00, 0x78, 0x09, 0x78, 0x08, 0x43, 0x07, 0xD0, 0x29, 0x68,
+	0x94, 0xF8, 0x42, 0x01,
+	0x91, 0xF8, 0x9D, 0x13, 0x08, 0x44, 0x84, 0xF8, 0x42, 0x01, 0x70, 0xBD,
+	0xC9, 0x49, 0x10, 0xB5,
+	0x0C, 0x78, 0xC7, 0x49, 0x90, 0xF8, 0x42, 0x21, 0x09, 0x68, 0x91, 0xF8,
+	0x9A, 0x33, 0x03, 0xF0,
+	0x0F, 0x03, 0x5C, 0xB1, 0x91, 0xF8, 0x4C, 0x13, 0x01, 0xF0, 0x0F, 0x01,
+	0xC9, 0x1A, 0x51, 0x1A,
+	0x00, 0x29, 0x00, 0xDC, 0x00, 0x21, 0x80, 0xF8, 0x42, 0x11, 0x10, 0xBD,
+	0x91, 0xF8, 0x4B, 0x13,
+	0xF2, 0xE7, 0xC0, 0x49, 0x00, 0x20, 0x08, 0x70, 0xBF, 0x49, 0x08, 0x70,
+	0xB9, 0x49, 0x08, 0x70,
+	0x70, 0x47, 0x2D, 0xE9, 0xF0, 0x4F, 0x8B, 0xB0, 0x4F, 0xF0, 0x00, 0x09,
+	0x00, 0xF5, 0x80, 0x55,
+	0x04, 0x46, 0x8D, 0xF8, 0x10, 0x90, 0x8D, 0xF8, 0x14, 0x90, 0xB5, 0xF8,
+	0xEC, 0x03, 0xB5, 0x4A,
+	0x00, 0x04, 0x00, 0x0C, 0x0A, 0xD0, 0x4F, 0xF0, 0xFF, 0x36, 0x10, 0x78,
+	0x31, 0x46, 0x4F, 0xF0,
+	0x00, 0x48, 0x93, 0x46, 0x4F, 0xF0, 0x01, 0x0A, 0xF8, 0xB9, 0x04, 0xE0,
+	0x48, 0x46, 0x82, 0xF8,
+	0x00, 0x90, 0xAD, 0x49, 0xDE, 0xE0, 0x04, 0xF5, 0x80, 0x52, 0x00, 0x20,
+	0x92, 0xF9, 0xF4, 0x73,
+	0x22, 0xE0, 0x00, 0xBF, 0xD2, 0xF8, 0xEC, 0xC3, 0x0A, 0xFA, 0x00, 0xF3,
+	0x1C, 0xEA, 0x03, 0x0F,
+	0x18, 0xD0, 0x00, 0xEB, 0x00, 0x13, 0x03, 0xEB, 0x83, 0x03, 0x04, 0xEB,
+	0x83, 0x03, 0x93, 0xF8,
+	0x3E, 0xC1, 0xBC, 0xF1, 0x01, 0x0F, 0x01, 0xD0, 0x31, 0x46, 0x0F, 0xE0,
+	0xB3, 0xF8, 0x44, 0xC0,
+	0xBC, 0xF1, 0x00, 0x0F, 0x06, 0xD0, 0x5B, 0x6B, 0x93, 0xFB, 0xFC, 0xF3,
+	0x98, 0x45, 0x01, 0xDA,
+	0x98, 0x46, 0x01, 0x46, 0x40, 0x1C, 0x40, 0xB2, 0x87, 0x42, 0xDB, 0xDA,
+	0x00, 0x27, 0xDF, 0xF8,
+	0x40, 0x82, 0x01, 0x91, 0x9D, 0xE0, 0x00, 0xBF, 0xD5, 0xF8, 0xEC, 0x13,
+	0x0A, 0xFA, 0x07, 0xF0,
+	0x01, 0x42, 0x60, 0xD0, 0x07, 0xEB, 0x07, 0x10, 0x00, 0xEB, 0x80, 0x00,
+	0x04, 0xEB, 0x80, 0x06,
+	0x96, 0xF8, 0x3E, 0x01, 0x01, 0x28, 0x02, 0xD0, 0x05, 0x28, 0x08, 0xD0,
+	0x10, 0xE0, 0x30, 0x46,
+	0x01, 0x99, 0xFF, 0xF7, 0x0D, 0xFF, 0x02, 0x20, 0x86, 0xF8, 0x3E, 0x01,
+	0x11, 0xE0, 0x30, 0x46,
+	0x00, 0xF0, 0xB0, 0xF8, 0x06, 0x20, 0x86, 0xF8, 0x3E, 0x01, 0x30, 0x46,
+	0x00, 0xF0, 0x48, 0xF9,
+	0x96, 0xF8, 0x3E, 0x01, 0x02, 0x28, 0x04, 0xD0, 0x06, 0x28, 0x32, 0xD0,
+	0x07, 0x28, 0x3B, 0xD0,
+	0x46, 0xE0, 0x96, 0xF8, 0x42, 0x00, 0xC0, 0x07, 0x13, 0xD0, 0x30, 0x46,
+	0x00, 0xF0, 0x7E, 0xF8,
+	0x78, 0xB9, 0xD8, 0xF8, 0x00, 0x10, 0x96, 0xF8, 0x42, 0x01, 0x91, 0xF8,
+	0x9C, 0x13, 0x01, 0xF0,
+	0x0F, 0x01, 0x88, 0x42, 0x03, 0xD9, 0x40, 0x1A, 0x86, 0xF8, 0x42, 0x01,
+	0x01, 0xE0, 0x86, 0xF8,
+	0x42, 0x91, 0x6E, 0x48, 0x00, 0x78, 0x40, 0xB1, 0x96, 0xF8, 0x42, 0x01,
+	0x10, 0xBB, 0xD8, 0xF8,
+	0x00, 0x00, 0x90, 0xF8, 0x9D, 0x03, 0x86, 0xF8, 0x42, 0x01, 0x96, 0xF8,
+	0x42, 0x01, 0xC8, 0xB9,
+	0x03, 0x20, 0x86, 0xF8, 0x3E, 0x01, 0x9B, 0xF8, 0x00, 0x00, 0x40, 0x1C,
+	0x8B, 0xF8, 0x00, 0x00,
+	0x2B, 0xE0, 0x96, 0xF8, 0x43, 0x01, 0x18, 0xBB, 0x96, 0xF8, 0x42, 0x00,
+	0x80, 0x07, 0x03, 0xD5,
+	0x07, 0x20, 0x86, 0xF8, 0x3E, 0x01, 0x32, 0xE0, 0x08, 0x20, 0x86, 0xF8,
+	0x3E, 0x01, 0x30, 0x46,
+	0x00, 0xF0, 0xA7, 0xF8, 0x96, 0xF8, 0x3E, 0x01, 0x02, 0x28, 0x07, 0xD0,
+	0x06, 0x28, 0x0C, 0xD0,
+	0xC0, 0xB2, 0x03, 0x28, 0x11, 0xD0, 0x04, 0x28, 0x0F, 0xD0, 0x20, 0xE0,
+	0x96, 0xF8, 0x42, 0x01,
+	0xE8, 0xB1, 0x40, 0x1E, 0x86, 0xF8, 0x42, 0x01, 0x19, 0xE0, 0x96, 0xF8,
+	0x43, 0x01, 0xB0, 0xB1,
+	0xC0, 0xB2, 0x40, 0x1E, 0x86, 0xF8, 0x43, 0x01, 0x11, 0xE0, 0x96, 0xF8,
+	0x3F, 0x01, 0x01, 0x28,
+	0x02, 0xD0, 0x03, 0x28, 0x06, 0xD0, 0x0A, 0xE0, 0x9D, 0xF8, 0x14, 0x00,
+	0x40, 0x1C, 0x8D, 0xF8,
+	0x14, 0x00, 0x04, 0xE0, 0x9D, 0xF8, 0x10, 0x00, 0x40, 0x1C, 0x8D, 0xF8,
+	0x10, 0x00, 0x7F, 0x1C,
+	0x7F, 0xB2, 0x95, 0xF9, 0xF4, 0x03, 0xB8, 0x42, 0xBF, 0xF6, 0x5E, 0xAF,
+	0x05, 0xAA, 0x04, 0xA9,
+	0x20, 0x46, 0x00, 0xF0, 0x87, 0xF8, 0x41, 0x49, 0x9D, 0xF8, 0x10, 0x00,
+	0x08, 0x70, 0x9D, 0xF8,
+	0x14, 0x00, 0x3F, 0x49, 0x08, 0x70, 0x0B, 0xB0, 0xBD, 0xE8, 0xF0, 0x8F,
+	0x90, 0xF8, 0x5B, 0x10,
+	0x90, 0xF8, 0x5A, 0x20, 0x8A, 0x1A, 0xB0, 0xF8, 0x42, 0x10, 0x52, 0x1C,
+	0x02, 0x2A, 0x0B, 0xD9,
+	0x90, 0xF8, 0x5D, 0x20, 0x90, 0xF8, 0x5C, 0x30, 0x9A, 0x42, 0x05, 0xD1,
+	0x41, 0xF0, 0x01, 0x01,
+	0xA0, 0xF8, 0x42, 0x10, 0x01, 0x20, 0x70, 0x47, 0x21, 0xF0, 0x01, 0x01,
+	0xA0, 0xF8, 0x42, 0x10,
+	0x00, 0x20, 0x70, 0x47, 0x70, 0xB5, 0x00, 0x25, 0x04, 0x46, 0x80, 0xF8,
+	0x43, 0x51, 0x0D, 0xF0,
+	0x93, 0xFD, 0x01, 0x00, 0x22, 0x48, 0x0C, 0xD0, 0x01, 0x68, 0x01, 0x25,
+	0x91, 0xF8, 0x9E, 0x13,
+	0x5F, 0xEA, 0x11, 0x11, 0x84, 0xF8, 0x43, 0x11, 0x94, 0xF8, 0x3F, 0x11,
+	0x01, 0x29, 0x06, 0xD0,
+	0x0E, 0xE0, 0x01, 0x68, 0x91, 0xF8, 0x9E, 0x13, 0x01, 0xF0, 0x0F, 0x01,
+	0xF2, 0xE7, 0x02, 0x68,
+	0x94, 0xF8, 0x43, 0x11, 0x92, 0xF8, 0x4B, 0x23, 0x01, 0xEB, 0x12, 0x11,
+	0x84, 0xF8, 0x43, 0x11,
+	0x1D, 0xB9, 0x94, 0xF8, 0x42, 0x10, 0x89, 0x07, 0x0D, 0xD4, 0x01, 0x68,
+	0xE2, 0x6A, 0x91, 0xF8,
+	0x9F, 0x13, 0x01, 0xF0, 0x0F, 0x03, 0x9A, 0x42, 0x05, 0xD9, 0x94, 0xF8,
+	0x43, 0x21, 0x02, 0xEB,
+	0x11, 0x11, 0x84, 0xF8, 0x43, 0x11, 0x0C, 0x49, 0x09, 0x78, 0x00, 0x29,
+	0x08, 0xD0, 0x00, 0x68,
+	0x94, 0xF8, 0x43, 0x11, 0x90, 0xF8, 0x63, 0x02, 0x01, 0xEB, 0x10, 0x10,
+	0x84, 0xF8, 0x43, 0x01,
+	0x70, 0xBD, 0x08, 0x49, 0x08, 0x78, 0x00, 0x28, 0x01, 0xD0, 0x40, 0x1E,
+	0x08, 0x70, 0x70, 0x47,
+	0x4C, 0x07, 0x10, 0x00, 0xF9, 0x06, 0x10, 0x00, 0x74, 0x05, 0x10, 0x00,
+	0x76, 0x06, 0x10, 0x00,
+	0x7D, 0x07, 0x10, 0x00, 0xFA, 0x06, 0x10, 0x00, 0x20, 0x07, 0x10, 0x00,
+	0xFB, 0x06, 0x10, 0x00,
+	0xFC, 0x06, 0x10, 0x00, 0x2D, 0xE9, 0xF0, 0x47, 0x16, 0x46, 0x07, 0x46,
+	0x0B, 0x78, 0x34, 0x4A,
+	0x01, 0x20, 0x23, 0xB9, 0x33, 0x78, 0x13, 0xB1, 0x10, 0x70, 0xBD, 0xE8,
+	0xF0, 0x87, 0x00, 0x23,
+	0x13, 0x70, 0x00, 0x29, 0xF9, 0xD0, 0x31, 0x78, 0x00, 0x29, 0xF6, 0xD0,
+	0x00, 0x24, 0x07, 0xF5,
+	0x80, 0x55, 0x80, 0x46, 0x4F, 0xF0, 0x02, 0x09, 0x1D, 0xE0, 0x00, 0xBF,
+	0xD5, 0xF8, 0xEC, 0x13,
+	0x08, 0xFA, 0x04, 0xF0, 0x01, 0x42, 0x14, 0xD0, 0x04, 0xEB, 0x04, 0x10,
+	0x00, 0xEB, 0x80, 0x00,
+	0x07, 0xEB, 0x80, 0x00, 0x90, 0xF8, 0x3E, 0x11, 0x03, 0x29, 0x0A, 0xD1,
+	0x90, 0xF8, 0x3F, 0x11,
+	0x01, 0x29, 0x06, 0xD1, 0x80, 0xF8, 0x3E, 0x91, 0xFF, 0xF7, 0xB3, 0xFF,
+	0x30, 0x78, 0x40, 0x1E,
+	0x30, 0x70, 0x64, 0x1C, 0x64, 0xB2, 0x95, 0xF9, 0xF4, 0x03, 0xA0, 0x42,
+	0xDE, 0xDA, 0xCC, 0xE7,
+	0x2D, 0xE9, 0xF0, 0x41, 0x17, 0x4D, 0x04, 0x46, 0x28, 0x68, 0x90, 0xF8,
+	0x81, 0x03, 0xC0, 0x07,
+	0x24, 0xD0, 0x21, 0x46, 0x20, 0x1D, 0x09, 0xF0, 0x06, 0xFD, 0x07, 0x46,
+	0x21, 0x46, 0x04, 0xF1,
+	0x20, 0x00, 0x09, 0xF0, 0x00, 0xFD, 0x06, 0x46, 0x0D, 0xF0, 0xE6, 0xFC,
+	0x00, 0x28, 0x28, 0x68,
+	0x05, 0xD0, 0xB0, 0xF8, 0x93, 0x13, 0xB0, 0xF8, 0x8F, 0x03, 0x49, 0x43,
+	0x04, 0xE0, 0xB0, 0xF8,
+	0x91, 0x13, 0xB0, 0xF8, 0x8D, 0x03, 0x49, 0x43, 0x40, 0x43, 0x86, 0x42,
+	0x06, 0xDD, 0x8F, 0x42,
+	0x04, 0xDD, 0x34, 0xF8, 0x42, 0x0F, 0x40, 0xF0, 0x02, 0x00, 0x20, 0x80,
+	0xBD, 0xE8, 0xF0, 0x81,
+	0xF9, 0x06, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00, 0xF8, 0xB5, 0x15, 0x46,
+	0x0E, 0x46, 0x04, 0x46,
+	0x0D, 0xF0, 0xC2, 0xFC, 0x01, 0x00, 0xF9, 0x48, 0x0B, 0xD0, 0x00, 0x68,
+	0x90, 0xF8, 0xB4, 0x13,
+	0xB0, 0xF8, 0xB7, 0x23, 0x01, 0xF0, 0x0F, 0x03, 0x0C, 0x09, 0xB0, 0xF8,
+	0xB5, 0x13, 0x49, 0x43,
+	0x10, 0xE0, 0x94, 0xF8, 0x3F, 0x11, 0x02, 0x29, 0x13, 0xD0, 0x00, 0x68,
+	0x01, 0x29, 0x14, 0xD0,
+	0x90, 0xF8, 0xB9, 0x13, 0xB0, 0xF8, 0xC0, 0x23, 0x01, 0xF0, 0x0F, 0x03,
+	0x0C, 0x09, 0xB0, 0xF8,
+	0xBE, 0x13, 0x49, 0x43, 0x52, 0x43, 0x30, 0x46, 0x00, 0x94, 0x09, 0xF0,
+	0xC2, 0xFC, 0x2C, 0x60,
+	0xF8, 0xBD, 0x00, 0x68, 0x90, 0xF8, 0xBA, 0x13, 0xEC, 0xE7, 0x90, 0xF8,
+	0xBB, 0x13, 0xB0, 0xF8,
+	0xC4, 0x23, 0x01, 0xF0, 0x0F, 0x03, 0x0C, 0x09, 0xB0, 0xF8, 0xC2, 0x13,
+	0x49, 0x43, 0xE9, 0xE7,
+	0x2D, 0xE9, 0xF8, 0x43, 0x04, 0x46, 0x90, 0xF8, 0x3E, 0x01, 0x88, 0x46,
+	0x04, 0xF1, 0x78, 0x07,
+	0x03, 0x28, 0x0B, 0xD0, 0xD9, 0x4E, 0x04, 0x28, 0x0D, 0xD0, 0x07, 0x28,
+	0x3B, 0xD0, 0x08, 0x28,
+	0x37, 0xD1, 0x38, 0x46, 0xBD, 0xE8, 0xF8, 0x43, 0x00, 0xF0, 0xC5, 0xBB,
+	0x38, 0x46, 0xBD, 0xE8,
+	0xF8, 0x43, 0x00, 0xF0, 0x8E, 0xBB, 0x20, 0x46, 0x0D, 0xF0, 0x83, 0xFC,
+	0x18, 0xB1, 0x20, 0x46,
+	0x0D, 0xF0, 0x7A, 0xFC, 0x1D, 0xE0, 0x04, 0xF1, 0x0C, 0x01, 0x08, 0x1D,
+	0x09, 0xF0, 0x7B, 0xFC,
+	0x01, 0x46, 0x6A, 0x46, 0x20, 0x46, 0xFF, 0xF7, 0x97, 0xFF, 0x05, 0x46,
+	0x94, 0xF8, 0x41, 0x01,
+	0x80, 0xB9, 0x20, 0x46, 0x0D, 0xF0, 0x6A, 0xFC, 0x10, 0xB1, 0x00, 0x98,
+	0x85, 0x42, 0x09, 0xDB,
+	0x30, 0x68, 0xD4, 0xF8, 0x80, 0x10, 0x90, 0xF8, 0xBC, 0x03, 0x02, 0x09,
+	0x28, 0x46, 0x09, 0xF0,
+	0x85, 0xFC, 0x05, 0x46, 0x2A, 0x46, 0x41, 0x46, 0x38, 0x46, 0x00, 0xF0,
+	0x64, 0xFB, 0xC4, 0xF8,
+	0x80, 0x50, 0xBD, 0xE8, 0xF8, 0x83, 0x30, 0x68, 0x00, 0x24, 0x90, 0xF8,
+	0x81, 0x13, 0x89, 0x07,
+	0x0A, 0xD5, 0x90, 0xF8, 0xBD, 0x03, 0x00, 0xF0, 0x0F, 0x04, 0x0D, 0xF0,
+	0x35, 0xFC, 0x18, 0xB1,
+	0x30, 0x68, 0x90, 0xF8, 0xBD, 0x03, 0x04, 0x09, 0x22, 0x46, 0x41, 0x46,
+	0x38, 0x46, 0xBD, 0xE8,
+	0xF8, 0x43, 0x00, 0xF0, 0x60, 0xBB, 0x2D, 0xE9, 0xF0, 0x43, 0xDF, 0xF8,
+	0xB0, 0x92, 0x4F, 0xF0,
+	0x00, 0x0C, 0xB0, 0xF9, 0x02, 0x30, 0xD9, 0xF8, 0x00, 0x40, 0x67, 0x46,
+	0x66, 0x46, 0x65, 0x46,
+	0x00, 0x2B, 0x02, 0xDA, 0x4F, 0xF0, 0x01, 0x0C, 0x04, 0xE0, 0xB4, 0xF8,
+	0x32, 0x80, 0x98, 0x45,
+	0x00, 0xDA, 0x01, 0x27, 0xB0, 0xF9, 0x00, 0x30, 0x00, 0x2B, 0x01, 0xDA,
+	0x01, 0x26, 0x04, 0xE0,
+	0xB4, 0xF8, 0x34, 0x80, 0x98, 0x45, 0x00, 0xDA, 0x01, 0x25, 0x00, 0x23,
+	0xBC, 0xF1, 0x00, 0x0F,
+	0x02, 0xD0, 0x0E, 0xB1, 0x43, 0x80, 0x03, 0xE0, 0x4F, 0xB1, 0x26, 0xB1,
+	0x61, 0x8E, 0x38, 0xE0,
+	0x03, 0x80, 0xBD, 0xE8, 0xF0, 0x83, 0x15, 0xB1, 0x62, 0x8E, 0x42, 0x80,
+	0x04, 0xE0, 0xBC, 0xF1,
+	0x00, 0x0F, 0x30, 0xD0, 0x2D, 0xB1, 0x43, 0x80, 0xD9, 0xF8, 0x00, 0x10,
+	0x89, 0x8E, 0x01, 0x80,
+	0xEF, 0xE7, 0xB2, 0xF8, 0x02, 0xC0, 0xBC, 0xF1, 0x00, 0x0F, 0x24, 0xD0,
+	0x43, 0x80, 0xB1, 0xF9,
+	0x02, 0x40, 0x67, 0x42, 0x2C, 0xE0, 0x00, 0xBF, 0x0C, 0xFB, 0x07, 0xFC,
+	0x00, 0x2C, 0x00, 0xDA,
+	0x64, 0x42, 0x9C, 0xFB, 0xF4, 0xF4, 0x0F, 0x88, 0x3C, 0x44, 0x04, 0x80,
+	0x46, 0xB3, 0xB2, 0xF9,
+	0x00, 0x40, 0x2C, 0xB3, 0xB1, 0xF9, 0x00, 0x50, 0xB2, 0xF9, 0x02, 0x20,
+	0x6D, 0x42, 0x00, 0xD5,
+	0x6D, 0x42, 0x6A, 0x43, 0x00, 0x2C, 0x00, 0xDA, 0x64, 0x42, 0x92, 0xFB,
+	0xF4, 0xF2, 0x49, 0x88,
+	0x11, 0x44, 0x41, 0x80, 0xC4, 0xE7, 0x00, 0x2F, 0xE8, 0xD0, 0x57, 0x88,
+	0x00, 0x2F, 0xE5, 0xD0,
+	0x64, 0x8E, 0x44, 0x80, 0xD9, 0xF8, 0x00, 0x40, 0xB1, 0xF9, 0x02, 0x70,
+	0x64, 0x8E, 0xE7, 0x1B,
+	0xB2, 0xF9, 0x02, 0x40, 0xB2, 0xF9, 0x00, 0xC0, 0x00, 0x2F, 0xCD, 0xDA,
+	0x7F, 0x42, 0xCB, 0xE7,
+	0x00, 0x2D, 0xAE, 0xD0, 0xB2, 0xF9, 0x00, 0x30, 0x00, 0x2B, 0xAA, 0xD0,
+	0xD9, 0xF8, 0x00, 0x40,
+	0xB1, 0xF9, 0x00, 0x60, 0xB2, 0xF9, 0x02, 0x20, 0xA4, 0x8E, 0xA4, 0x1B,
+	0x00, 0xD5, 0x64, 0x42,
+	0x62, 0x43, 0x00, 0x2B, 0x00, 0xDA, 0x5B, 0x42, 0x92, 0xFB, 0xF3, 0xF2,
+	0x49, 0x88, 0x11, 0x44,
+	0x41, 0x80, 0xA1, 0xE7, 0x2D, 0xE9, 0xF0, 0x5F, 0x04, 0x46, 0x61, 0x48,
+	0x0D, 0x46, 0x00, 0x21,
+	0x41, 0x80, 0x01, 0x80, 0xA0, 0xF1, 0x10, 0x08, 0x28, 0x68, 0xC8, 0xF8,
+	0x00, 0x00, 0x17, 0x46,
+	0x4F, 0xF0, 0x01, 0x0B, 0x46, 0x46, 0x29, 0x46, 0x20, 0x46, 0x00, 0xF0,
+	0x67, 0xFF, 0xDF, 0xF8,
+	0x5C, 0x91, 0x28, 0x68, 0x70, 0x60, 0xD9, 0xF8, 0x00, 0x00, 0x04, 0xF1,
+	0x0C, 0x0A, 0x90, 0xF8,
+	0x80, 0x03, 0x41, 0x07, 0x22, 0xD5, 0x94, 0xF8, 0x3E, 0x01, 0x04, 0xF1,
+	0x84, 0x06, 0x02, 0x28,
+	0x0A, 0xD0, 0x03, 0x28, 0x08, 0xD0, 0x04, 0x28, 0x0B, 0xD0, 0x06, 0x28,
+	0x12, 0xD0, 0x07, 0x28,
+	0x10, 0xD0, 0x08, 0x28, 0x0E, 0xD0, 0x11, 0xE0, 0x51, 0x46, 0x30, 0x46,
+	0xFF, 0xF7, 0xC9, 0xFA,
+	0x0C, 0xE0, 0x20, 0x46, 0x00, 0xF0, 0xDD, 0xF9, 0x02, 0x46, 0x29, 0x46,
+	0x30, 0x46, 0xFF, 0xF7,
+	0xE4, 0xFA, 0x03, 0xE0, 0x29, 0x46, 0x30, 0x46, 0xFF, 0xF7, 0xEB, 0xFB,
+	0x29, 0x68, 0xC8, 0xF8,
+	0x08, 0x10, 0xD9, 0xF8, 0x00, 0x00, 0x4E, 0x46, 0x90, 0xF8, 0x80, 0x03,
+	0x00, 0x07, 0x09, 0xD5,
+	0x94, 0xF8, 0x42, 0x00, 0x10, 0xF0, 0xC8, 0x0F, 0x35, 0xD0, 0x51, 0x46,
+	0x04, 0xF1, 0xB0, 0x00,
+	0x00, 0xF0, 0xF3, 0xFD, 0x29, 0x68, 0xC8, 0xF8, 0x0C, 0x10, 0x30, 0x68,
+	0x90, 0xF8, 0x80, 0x13,
+	0x49, 0x06, 0x0F, 0xD4, 0x90, 0xF8, 0x40, 0x14, 0x49, 0x06, 0x03, 0xD5,
+	0x94, 0xF8, 0x42, 0x10,
+	0x09, 0x07, 0x07, 0xD4, 0x90, 0xF8, 0x20, 0x04, 0x80, 0x07, 0x07, 0xD5,
+	0x94, 0xF8, 0x42, 0x00,
+	0x00, 0x06, 0x03, 0xD5, 0x29, 0x46, 0x20, 0x46, 0x01, 0xF0, 0xBC, 0xFC,
+	0x30, 0x68, 0x90, 0xF8,
+	0x80, 0x03, 0x80, 0x06, 0x03, 0xD5, 0x29, 0x46, 0x20, 0x46, 0xFF, 0xF7,
+	0x89, 0xFE, 0x30, 0x68,
+	0x90, 0xF8, 0x80, 0x03, 0x01, 0x07, 0x11, 0xD5, 0xC0, 0x06, 0x0F, 0xD5,
+	0x94, 0xF8, 0x3E, 0x01,
+	0x07, 0x28, 0x05, 0xD0, 0x0A, 0xE0, 0x29, 0x46, 0x20, 0x46, 0x00, 0xF0,
+	0xB2, 0xF9, 0xC9, 0xE7,
+	0x1B, 0x4A, 0x04, 0xF1, 0xF4, 0x01, 0x28, 0x46, 0xFF, 0xF7, 0xD5, 0xFE,
+	0x30, 0x68, 0xB0, 0xF9,
+	0x32, 0x10, 0xB5, 0xF9, 0x02, 0x00, 0x09, 0xF0, 0xD7, 0xFA, 0x68, 0x80,
+	0x30, 0x68, 0xB0, 0xF9,
+	0x34, 0x10, 0xB5, 0xF9, 0x00, 0x00, 0x09, 0xF0, 0xCF, 0xFA, 0x28, 0x80,
+	0x94, 0xF8, 0x3E, 0x01,
+	0x03, 0x28, 0x06, 0xD0, 0x04, 0x28, 0x08, 0xD0, 0x07, 0x28, 0x1B, 0xD0,
+	0x08, 0x28, 0x19, 0xD0,
+	0x1B, 0xE0, 0x38, 0x88, 0xA4, 0xF8, 0x50, 0x00, 0x17, 0xE0, 0x30, 0x68,
+	0x34, 0xF8, 0x50, 0x2F,
+	0x90, 0xF8, 0xBC, 0x03, 0x00, 0xF0, 0x0F, 0x01, 0xC1, 0xF1, 0x10, 0x00,
+	0x4A, 0x43, 0x39, 0x88,
+	0x01, 0xFB, 0x00, 0x20, 0x00, 0x09, 0x20, 0x80, 0x06, 0xE0, 0x00, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0x94, 0x05, 0x10, 0x00, 0xB4, 0xF8, 0x50, 0x00, 0x38, 0x80, 0x58, 0x46,
+	0xBD, 0xE8, 0xF0, 0x9F,
+	0x2D, 0xE9, 0xF3, 0x4F, 0xE4, 0x49, 0x83, 0xB0, 0x4F, 0xF0, 0x00, 0x08,
+	0xC1, 0xF8, 0x00, 0x80,
+	0xE2, 0x49, 0xE3, 0x4D, 0x83, 0x46, 0xC1, 0xF8, 0x00, 0x80, 0x85, 0xF8,
+	0x00, 0x80, 0x46, 0x46,
+	0xDF, 0xF8, 0x80, 0xA3, 0x4F, 0xF0, 0x01, 0x09, 0x00, 0xF5, 0x80, 0x57,
+	0x77, 0xE0, 0x00, 0xBF,
+	0xD7, 0xF8, 0xEC, 0x13, 0x09, 0xFA, 0x06, 0xF0, 0x01, 0x42, 0x6F, 0xD0,
+	0x06, 0xEB, 0x06, 0x10,
+	0x00, 0xEB, 0x80, 0x01, 0x0B, 0xEB, 0x81, 0x04, 0x94, 0xF8, 0x3E, 0x01,
+	0x03, 0x28, 0x05, 0xD0,
+	0x04, 0x28, 0x03, 0xD0, 0x07, 0x28, 0x01, 0xD0, 0x08, 0x28, 0x5F, 0xD1,
+	0xE0, 0x68, 0x00, 0x90,
+	0xB4, 0xF8, 0x4E, 0x00, 0xAD, 0xF8, 0x04, 0x00, 0x04, 0xF1, 0x0C, 0x01,
+	0xCA, 0x4A, 0x08, 0x1D,
+	0x00, 0xF0, 0x06, 0xF9, 0x01, 0xAA, 0x69, 0x46, 0x20, 0x46, 0xFF, 0xF7,
+	0xF3, 0xFE, 0x02, 0x90,
+	0xC6, 0x4A, 0x69, 0x46, 0x04, 0xF1, 0x24, 0x00, 0x00, 0xF0, 0xFA, 0xF8,
+	0x94, 0xF8, 0x3F, 0x01,
+	0x01, 0x28, 0x08, 0xD1, 0xC4, 0x48, 0x00, 0x78, 0x28, 0xB9, 0x94, 0xF8,
+	0x3E, 0x01, 0x08, 0x28,
+	0x01, 0xD0, 0x00, 0x20, 0x02, 0x90, 0xDA, 0xF8, 0x00, 0x00, 0x90, 0xF8,
+	0x00, 0x04, 0xC0, 0x07,
+	0x0E, 0xD0, 0x94, 0xF8, 0x42, 0x00, 0x40, 0x07, 0x02, 0xD5, 0x00, 0x20,
+	0x02, 0x90, 0x07, 0xE0,
+	0x94, 0xF8, 0x34, 0x01, 0x01, 0x28, 0x03, 0xD1, 0x20, 0x6A, 0x00, 0x90,
+	0x84, 0xF8, 0x34, 0x81,
+	0x94, 0xF8, 0x3F, 0x01, 0x03, 0x28, 0x09, 0xD1, 0x28, 0x78, 0x40, 0x1C,
+	0xC0, 0xB2, 0x28, 0x70,
+	0x94, 0xF8, 0x42, 0x10, 0x49, 0x07, 0x01, 0xD5, 0x40, 0x1E, 0x28, 0x70,
+	0x00, 0x98, 0x60, 0x62,
+	0xBD, 0xF8, 0x04, 0x00, 0xA4, 0xF8, 0x50, 0x00, 0x02, 0x98, 0x01, 0x28,
+	0x0E, 0xD1, 0x00, 0x98,
+	0xA0, 0x61, 0xBD, 0xF8, 0x04, 0x00, 0xA4, 0xF8, 0x52, 0x00, 0x04, 0x98,
+	0x94, 0xF8, 0x4C, 0x21,
+	0x00, 0x68, 0x09, 0xFA, 0x02, 0xF1, 0x08, 0x43, 0x04, 0x99, 0x08, 0x60,
+	0x76, 0x1C, 0x97, 0xF9,
+	0xF4, 0x03, 0xB0, 0x42, 0x84, 0xDA, 0xDA, 0xF8, 0x00, 0x00, 0x90, 0xF8,
+	0x00, 0x04, 0x00, 0x07,
+	0x0E, 0xD5, 0x29, 0x78, 0x9D, 0x48, 0x29, 0xB1, 0x9D, 0x49, 0x09, 0x78,
+	0x01, 0x29, 0x01, 0xD1,
+	0x80, 0xF8, 0x00, 0x90, 0xD7, 0xF8, 0xF0, 0x13, 0x00, 0x29, 0x01, 0xD1,
+	0x80, 0xF8, 0x00, 0x80,
+	0x05, 0xB0, 0xBD, 0xE8, 0xF0, 0x8F, 0x2D, 0xE9, 0xF0, 0x47, 0x89, 0x46,
+	0x06, 0x46, 0x00, 0x27,
+	0x4F, 0xF0, 0x01, 0x08, 0x00, 0xF5, 0x80, 0x55, 0x3D, 0xE0, 0x00, 0xBF,
+	0xD5, 0xF8, 0xEC, 0x13,
+	0x08, 0xFA, 0x07, 0xF2, 0x11, 0x42, 0x35, 0xD0, 0x07, 0xEB, 0x07, 0x11,
+	0x01, 0xEB, 0x81, 0x01,
+	0x06, 0xEB, 0x81, 0x04, 0x94, 0xF8, 0x3E, 0x11, 0x03, 0x29, 0x05, 0xD0,
+	0x04, 0x29, 0x03, 0xD0,
+	0x07, 0x29, 0x01, 0xD0, 0x08, 0x29, 0x25, 0xD1, 0x94, 0xF8, 0x4C, 0x31,
+	0xD9, 0xF8, 0x00, 0x20,
+	0x08, 0xFA, 0x03, 0xF0, 0x02, 0x42, 0x1D, 0xD0, 0x03, 0x29, 0x03, 0xD1,
+	0x21, 0x46, 0x30, 0x46,
+	0x02, 0xF0, 0x7A, 0xF8, 0x94, 0xF9, 0x4D, 0x01, 0x00, 0x28, 0x13, 0xDB,
+	0x94, 0xF8, 0x3F, 0x01,
+	0x00, 0x21, 0x01, 0x28, 0x04, 0xD0, 0x02, 0x28, 0x04, 0xD0, 0x04, 0x28,
+	0x04, 0xD0, 0x04, 0xE0,
+	0x03, 0x21, 0x02, 0xE0, 0x04, 0x21, 0x00, 0xE0, 0x05, 0x21, 0x84, 0xF8,
+	0x40, 0x11, 0x20, 0x46,
+	0x08, 0xF0, 0x7D, 0xFC, 0x7F, 0x1C, 0x95, 0xF9, 0xF4, 0x03, 0xB8, 0x42,
+	0xBE, 0xDA, 0x00, 0x24,
+	0x47, 0x46, 0x24, 0xE0, 0xD5, 0xF8, 0xEC, 0x03, 0x07, 0xFA, 0x04, 0xF1,
+	0x08, 0x42, 0x1D, 0xD0,
+	0x04, 0xEB, 0x04, 0x10, 0x00, 0xEB, 0x80, 0x00, 0x06, 0xEB, 0x80, 0x08,
+	0x98, 0xF8, 0x3E, 0x01,
+	0x08, 0x28, 0x13, 0xD1, 0x98, 0xF8, 0x4C, 0x21, 0xD9, 0xF8, 0x00, 0x10,
+	0x07, 0xFA, 0x02, 0xF0,
+	0x01, 0x42, 0x07, 0xD0, 0x98, 0xF9, 0x4D, 0x01, 0x00, 0x28, 0x03, 0xDB,
+	0x41, 0x46, 0x30, 0x46,
+	0x02, 0xF0, 0x55, 0xF8, 0x41, 0x46, 0x30, 0x46, 0x02, 0xF0, 0x18, 0xF8,
+	0x64, 0x1C, 0x95, 0xF9,
+	0xF4, 0x03, 0xA0, 0x42, 0xD6, 0xDA, 0xBD, 0xE8, 0xF0, 0x87, 0x53, 0x49,
+	0x10, 0xB5, 0x00, 0x20,
+	0x08, 0x60, 0x52, 0x49, 0x08, 0x60, 0xFF, 0xF7, 0x03, 0xF9, 0x00, 0xF0,
+	0x2F, 0xFC, 0xBD, 0xE8,
+	0x10, 0x40, 0x00, 0xF0, 0xAD, 0xB8, 0x38, 0xB5, 0x04, 0x46, 0x00, 0x20,
+	0x00, 0x90, 0x69, 0x46,
+	0x20, 0x46, 0xFF, 0xF7, 0xC5, 0xFE, 0x69, 0x46, 0x20, 0x46, 0xFF, 0xF7,
+	0x6C, 0xFF, 0x38, 0xBD,
+	0x10, 0xB5, 0x14, 0x46, 0x09, 0xF0, 0x97, 0xF9, 0x21, 0x68, 0x81, 0x42,
+	0x00, 0xDA, 0x20, 0x60,
+	0x10, 0xBD, 0x10, 0xB5, 0x02, 0x46, 0x43, 0x49, 0xB2, 0xF8, 0x42, 0x30,
+	0x4F, 0xF0, 0xFF, 0x30,
+	0x09, 0x68, 0x5C, 0x06, 0x03, 0xD5, 0x91, 0xF8, 0xA5, 0x03, 0x00, 0x09,
+	0x10, 0xBD, 0x1C, 0x07,
+	0x02, 0xD5, 0x91, 0xF8, 0x4F, 0x04, 0x03, 0xE0, 0x1B, 0x06, 0x04, 0xD5,
+	0x91, 0xF8, 0x2A, 0x04,
+	0x00, 0xF0, 0x0F, 0x00, 0x10, 0xBD, 0x92, 0xF8, 0x3F, 0x21, 0x01, 0x2A,
+	0x06, 0xD0, 0x39, 0x4A,
+	0x12, 0x78, 0x01, 0x2A, 0xF6, 0xD9, 0x91, 0xF9, 0xAA, 0x03, 0x10, 0xBD,
+	0x91, 0xF8, 0xA5, 0x03,
+	0xEE, 0xE7, 0x30, 0xB4, 0x0C, 0x46, 0x90, 0xF8, 0x3E, 0x11, 0x00, 0xF1,
+	0xB0, 0x03, 0x03, 0x29,
+	0x23, 0xD0, 0x04, 0x29, 0x03, 0xD0, 0x06, 0x29, 0x01, 0xD0, 0x07, 0x29,
+	0x41, 0xD1, 0x29, 0x4A,
+	0x12, 0x68, 0x92, 0xF8, 0x80, 0x23, 0xD2, 0x06, 0x2D, 0xD5, 0x90, 0xF8,
+	0x5B, 0x20, 0x90, 0xF8,
+	0x5A, 0x50, 0x52, 0x1B, 0xC0, 0xF8, 0x24, 0x21, 0x90, 0xF8, 0x5D, 0x20,
+	0x90, 0xF8, 0x5C, 0x50,
+	0x52, 0x1B, 0xC0, 0xF8, 0x28, 0x21, 0x82, 0x6B, 0xC0, 0xF8, 0x20, 0x21,
+	0x22, 0x4A, 0x07, 0x29,
+	0x12, 0x88, 0xC0, 0xF8, 0x2C, 0x21, 0x06, 0xD0, 0x0F, 0xE0, 0x00, 0xF1,
+	0x0C, 0x01, 0x30, 0xBC,
+	0x18, 0x46, 0x00, 0xF0, 0xDA, 0xBB, 0x90, 0xF8, 0x31, 0x11, 0x03, 0x29,
+	0x05, 0xD9, 0x21, 0x46,
+	0x30, 0xBC, 0x1A, 0x4A, 0x18, 0x46, 0x00, 0xF0, 0x68, 0xBC, 0x90, 0xF8,
+	0x31, 0x11, 0x49, 0x1C,
+	0x80, 0xF8, 0x31, 0x11, 0x03, 0xE0, 0x90, 0xF8, 0x31, 0x21, 0x03, 0x2A,
+	0x04, 0xD9, 0x21, 0x46,
+	0x30, 0xBC, 0x18, 0x46, 0x00, 0xF0, 0x26, 0xBC, 0x04, 0x29, 0x04, 0xD0,
+	0x00, 0x21, 0x80, 0xF8,
+	0x31, 0x11, 0x30, 0xBC, 0x70, 0x47, 0x52, 0x1C, 0x80, 0xF8, 0x31, 0x21,
+	0x21, 0x46, 0x30, 0xBC,
+	0x18, 0x46, 0x00, 0xF0, 0x00, 0xBC, 0x00, 0x00, 0x24, 0x07, 0x10, 0x00,
+	0x28, 0x07, 0x10, 0x00,
+	0x20, 0x07, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00, 0xF9, 0x06, 0x10, 0x00,
+	0xA5, 0x06, 0x10, 0x00,
+	0xA4, 0x06, 0x10, 0x00, 0xFA, 0x06, 0x10, 0x00, 0x78, 0x06, 0x10, 0x00,
+	0x94, 0x05, 0x10, 0x00,
+	0x70, 0x47, 0x00, 0xF0, 0x35, 0xB8, 0x7C, 0xB5, 0x04, 0x46, 0x15, 0x46,
+	0x0E, 0x46, 0x68, 0x46,
+	0x00, 0xF0, 0x2E, 0xF8, 0x01, 0x99, 0x2A, 0x46, 0x60, 0x68, 0x00, 0xF0,
+	0x3B, 0xF8, 0x60, 0x60,
+	0x00, 0x99, 0x2A, 0x46, 0x20, 0x68, 0x00, 0xF0, 0x35, 0xF8, 0x20, 0x60,
+	0x21, 0x46, 0x30, 0x46,
+	0x00, 0xF0, 0x27, 0xF8, 0x7C, 0xBD, 0x7C, 0xB5, 0x04, 0x46, 0x15, 0x46,
+	0x0E, 0x46, 0x68, 0x46,
+	0x00, 0xF0, 0x16, 0xF8, 0x01, 0x99, 0x2A, 0x46, 0x60, 0x68, 0x00, 0xF0,
+	0x23, 0xF8, 0x60, 0x60,
+	0x00, 0x99, 0x2A, 0x46, 0x20, 0x68, 0x00, 0xF0, 0x1D, 0xF8, 0x20, 0x60,
+	0x21, 0x46, 0x30, 0x46,
+	0x00, 0xF0, 0x0F, 0xF8, 0x7C, 0xBD, 0x0A, 0x46, 0x01, 0x46, 0x10, 0x46,
+	0x00, 0xF0, 0x09, 0xB8,
+	0xB1, 0xF9, 0x02, 0x20, 0x12, 0x02, 0x42, 0x60, 0xB1, 0xF9, 0x00, 0x10,
+	0x09, 0x02, 0x01, 0x60,
+	0x70, 0x47, 0x4A, 0x68, 0x80, 0x32, 0x12, 0x12, 0x42, 0x80, 0x09, 0x68,
+	0x80, 0x31, 0x09, 0x12,
+	0x01, 0x80, 0x70, 0x47, 0xC2, 0xF1, 0x10, 0x03, 0x50, 0x43, 0x01, 0xFB,
+	0x03, 0x00, 0x00, 0x11,
+	0x70, 0x47, 0x00, 0x00, 0x2D, 0xE9, 0xF0, 0x41, 0xFE, 0x4A, 0x12, 0x68,
+	0x51, 0xB3, 0x51, 0x8E,
+	0x92, 0xF8, 0x30, 0x30, 0x82, 0x6F, 0x04, 0x6F, 0xC0, 0x6F, 0x64, 0x26,
+	0x40, 0x00, 0x00, 0xFB,
+	0x02, 0x40, 0x48, 0x43, 0xA0, 0xFB, 0x00, 0x25, 0x00, 0x21, 0x01, 0xFB,
+	0x00, 0x55, 0x00, 0xFB,
+	0x01, 0x51, 0xA2, 0xFB, 0x06, 0x07, 0x00, 0x25, 0x01, 0xFB, 0x06, 0x71,
+	0x02, 0xFB, 0x05, 0x11,
+	0x5C, 0x43, 0x22, 0x46, 0x2B, 0x46, 0x0C, 0xF0, 0x72, 0xFE, 0x22, 0x46,
+	0x00, 0x23, 0x0C, 0xF0,
+	0x6E, 0xFE, 0xED, 0x4B, 0x00, 0x22, 0x1B, 0x1A, 0x8A, 0x41, 0x01, 0xD2,
+	0xEA, 0x48, 0x00, 0x21,
+	0xBD, 0xE8, 0xF0, 0x81, 0x91, 0x8E, 0x92, 0xF8, 0x31, 0x30, 0x42, 0x6F,
+	0xD3, 0xE7, 0x7C, 0xB5,
+	0x04, 0x46, 0xE6, 0x48, 0xB4, 0xF9, 0x02, 0x10, 0x00, 0x78, 0x01, 0x28,
+	0x30, 0xD0, 0xB4, 0xF9,
+	0x06, 0x00, 0xB4, 0xF9, 0x0A, 0x20, 0x09, 0x1A, 0x80, 0x1A, 0x08, 0x1A,
+	0x01, 0x90, 0xB4, 0xF9,
+	0x00, 0x10, 0xB4, 0xF9, 0x04, 0x00, 0xB4, 0xF9, 0x08, 0x20, 0x09, 0x1A,
+	0x80, 0x1A, 0x08, 0x1A,
+	0xD8, 0x49, 0x00, 0x90, 0x20, 0x6C, 0x09, 0x68, 0x01, 0x9B, 0x91, 0xF8,
+	0xB3, 0x23, 0x50, 0x43,
+	0xC2, 0xF1, 0x80, 0x02, 0x53, 0x43, 0xC2, 0x17, 0x00, 0xEB, 0x52, 0x60,
+	0x03, 0xEB, 0xE0, 0x10,
+	0x20, 0x64, 0x91, 0xF8, 0xB3, 0x13, 0xE0, 0x6B, 0x00, 0x9A, 0x48, 0x43,
+	0xC1, 0xF1, 0x80, 0x01,
+	0x4A, 0x43, 0xC1, 0x17, 0x00, 0xEB, 0x51, 0x60, 0x02, 0xEB, 0xE0, 0x10,
+	0xE0, 0x63, 0x7C, 0xBD,
+	0xB4, 0xF9, 0x46, 0x00, 0xB4, 0xF9, 0x4A, 0x20, 0x09, 0x1A, 0x80, 0x1A,
+	0x08, 0x1A, 0x01, 0x90,
+	0xB4, 0xF9, 0x00, 0x10, 0xB4, 0xF9, 0x44, 0x00, 0xB4, 0xF9, 0x48, 0x20,
+	0x09, 0x1A, 0x80, 0x1A,
+	0x08, 0x1A, 0x00, 0x90, 0x04, 0xF1, 0x50, 0x00, 0x03, 0x22, 0x69, 0x46,
+	0x05, 0x46, 0x09, 0xF0,
+	0x08, 0xF8, 0x94, 0xF8, 0x80, 0x00, 0x03, 0x28, 0x02, 0xD2, 0x40, 0x1C,
+	0x84, 0xF8, 0x80, 0x00,
+	0xC2, 0xB2, 0x29, 0x46, 0x04, 0xF1, 0x68, 0x00, 0x00, 0xF0, 0x98, 0xFB,
+	0x7C, 0xBD, 0x2D, 0xE9,
+	0xF0, 0x4F, 0x89, 0xB0, 0x00, 0x26, 0x05, 0x96, 0x06, 0x96, 0x07, 0x96,
+	0x01, 0x24, 0x0D, 0xF1,
+	0x14, 0x08, 0x08, 0x96, 0x02, 0x25, 0xCD, 0xE9, 0x01, 0x48, 0x07, 0x46,
+	0xCD, 0xE9, 0x03, 0x54,
+	0x00, 0xF1, 0x0C, 0x03, 0xAD, 0x48, 0x9B, 0x46, 0x2A, 0x46, 0x29, 0x46,
+	0x20, 0x30, 0x00, 0x95,
+	0x08, 0xF0, 0x70, 0xFF, 0xDF, 0xF8, 0xA4, 0x92, 0x4F, 0xF4, 0x80, 0x7A,
+	0x99, 0xF8, 0x00, 0x00,
+	0x01, 0x28, 0x48, 0xD0, 0x38, 0x6C, 0x00, 0x90, 0x01, 0x23, 0x02, 0x22,
+	0x07, 0xA9, 0x09, 0xF1,
+	0x08, 0x00, 0x08, 0xF0, 0x36, 0xFF, 0x07, 0xA9, 0x01, 0x23, 0x02, 0x22,
+	0x08, 0x46, 0xCD, 0xF8,
+	0x00, 0xA0, 0x08, 0xF0, 0x20, 0xFF, 0x02, 0x23, 0x5A, 0x46, 0x07, 0xA9,
+	0x05, 0xA8, 0x00, 0x94,
+	0x08, 0xF0, 0x34, 0xFF, 0x05, 0x96, 0x06, 0x96, 0x07, 0x96, 0x08, 0x96,
+	0xCD, 0xE9, 0x01, 0x48,
+	0xCD, 0xE9, 0x03, 0x54, 0x95, 0x48, 0x07, 0xF1, 0x14, 0x03, 0x00, 0x95,
+	0x02, 0x22, 0x1D, 0x46,
+	0x11, 0x46, 0x20, 0x30, 0x08, 0xF0, 0x3E, 0xFF, 0x99, 0xF8, 0x00, 0x00,
+	0x01, 0x28, 0x1F, 0xD0,
+	0xF8, 0x6B, 0x00, 0x90, 0x8D, 0x48, 0x01, 0x23, 0x02, 0x22, 0x07, 0xA9,
+	0x08, 0x30, 0x08, 0xF0,
+	0x08, 0xFF, 0x07, 0xA9, 0x01, 0x23, 0x02, 0x22, 0x08, 0x46, 0xCD, 0xF8,
+	0x00, 0xA0, 0x08, 0xF0,
+	0xF2, 0xFE, 0x02, 0x23, 0x2A, 0x46, 0x07, 0xA9, 0x05, 0xA8, 0x00, 0x94,
+	0x08, 0xF0, 0x06, 0xFF,
+	0x09, 0xB0, 0xBD, 0xE8, 0xF0, 0x8F, 0xDD, 0xE9, 0x05, 0x01, 0xC7, 0xE9,
+	0x03, 0x01, 0xC9, 0xE7,
+	0xDD, 0xE9, 0x05, 0x01, 0xC7, 0xE9, 0x05, 0x01, 0xF2, 0xE7, 0x2D, 0xE9,
+	0xF0, 0x4F, 0x8D, 0xB0,
+	0x00, 0x26, 0x02, 0x24, 0x05, 0x96, 0x06, 0x96, 0x07, 0x96, 0x08, 0x96,
+	0x09, 0x96, 0x0A, 0x96,
+	0x0B, 0x96, 0x05, 0xAF, 0x0C, 0x96, 0xCD, 0xE9, 0x01, 0x47, 0x05, 0x46,
+	0x73, 0x48, 0x05, 0xF1,
+	0x1C, 0x03, 0x03, 0x94, 0x04, 0x94, 0x9B, 0x46, 0x22, 0x46, 0x21, 0x46,
+	0x20, 0x30, 0x00, 0x94,
+	0x08, 0xF0, 0xF8, 0xFE, 0x0D, 0xF1, 0x24, 0x0A, 0xCD, 0xE9, 0x01, 0x4A,
+	0x6B, 0x4B, 0x02, 0x22,
+	0x03, 0x94, 0x04, 0x94, 0x30, 0x33, 0x11, 0x46, 0x05, 0xA8, 0x00, 0x94,
+	0x08, 0xF0, 0xEA, 0xFE,
+	0xDF, 0xF8, 0x98, 0x81, 0x4F, 0xF0, 0x04, 0x09, 0x98, 0xF8, 0x00, 0x00,
+	0x01, 0x28, 0x12, 0xD1,
+	0xE8, 0x6E, 0x02, 0x23, 0x08, 0xF1, 0x60, 0x01, 0x00, 0x90, 0x1A, 0x46,
+	0xA1, 0xF1, 0x10, 0x00,
+	0x08, 0xF0, 0xAF, 0xFE, 0x02, 0x23, 0x08, 0xF1, 0x60, 0x01, 0x1A, 0x46,
+	0x08, 0x46, 0xCD, 0xF8,
+	0x00, 0x90, 0x08, 0xF0, 0x98, 0xFE, 0x59, 0x49, 0x02, 0x23, 0x5A, 0x46,
+	0x60, 0x31, 0x09, 0xA8,
+	0x00, 0x94, 0x08, 0xF0, 0xAB, 0xFE, 0x05, 0x96, 0x06, 0x96, 0x07, 0x96,
+	0x08, 0x96, 0x09, 0x96,
+	0x0A, 0x96, 0x0B, 0x96, 0x0C, 0x96, 0xCD, 0xE9, 0x01, 0x47, 0x50, 0x48,
+	0x05, 0xF1, 0x2C, 0x03,
+	0x02, 0x22, 0x03, 0x94, 0x04, 0x94, 0x1E, 0x46, 0x11, 0x46, 0x20, 0x30,
+	0x00, 0x94, 0x08, 0xF0,
+	0xB1, 0xFE, 0xCD, 0xE9, 0x01, 0x4A, 0x49, 0x4B, 0x02, 0x22, 0x03, 0x94,
+	0x04, 0x94, 0x30, 0x33,
+	0x11, 0x46, 0x05, 0xA8, 0x00, 0x94, 0x08, 0xF0, 0xA5, 0xFE, 0x98, 0xF8,
+	0x00, 0x00, 0x01, 0x28,
+	0x12, 0xD1, 0x42, 0x49, 0xA8, 0x6E, 0x02, 0x23, 0x60, 0x31, 0x00, 0x90,
+	0x1A, 0x46, 0xA1, 0xF1,
+	0x10, 0x00, 0x08, 0xF0, 0x6E, 0xFE, 0x3D, 0x49, 0x02, 0x23, 0x60, 0x31,
+	0x1A, 0x46, 0x08, 0x46,
+	0xCD, 0xF8, 0x00, 0x90, 0x08, 0xF0, 0x57, 0xFE, 0x38, 0x49, 0x02, 0x23,
+	0x32, 0x46, 0x60, 0x31,
+	0x09, 0xA8, 0x00, 0x94, 0x08, 0xF0, 0x6A, 0xFE, 0x0D, 0xB0, 0x62, 0xE7,
+	0x2D, 0xE9, 0xF0, 0x4F,
+	0x89, 0xB0, 0x00, 0x26, 0x01, 0x24, 0x05, 0x96, 0x06, 0x96, 0x0D, 0xF1,
+	0x14, 0x0A, 0x07, 0x96,
+	0xCD, 0xE9, 0x01, 0x4A, 0x05, 0x46, 0x00, 0xF1, 0x0C, 0x03, 0x4F, 0xF0,
+	0x02, 0x09, 0x2B, 0x48,
+	0x93, 0x46, 0x0F, 0x46, 0x03, 0x94, 0x98, 0x46, 0x4A, 0x46, 0x21, 0x46,
+	0x10, 0x30, 0xCD, 0xF8,
+	0x00, 0x90, 0x04, 0x94, 0x08, 0xF0, 0x66, 0xFE, 0xB5, 0xF9, 0x02, 0x00,
+	0x05, 0x99, 0x01, 0x23,
+	0x40, 0x1A, 0x05, 0x90, 0x00, 0x90, 0x02, 0x22, 0x06, 0xA9, 0x38, 0x46,
+	0x08, 0xF0, 0x31, 0xFE,
+	0x64, 0x27, 0x41, 0x46, 0x01, 0x23, 0x02, 0x22, 0x08, 0x46, 0x00, 0x97,
+	0x08, 0xF0, 0x29, 0xFE,
+	0x42, 0x46, 0x02, 0x23, 0x06, 0xA9, 0x10, 0x46, 0x00, 0x94, 0x08, 0xF0,
+	0x2F, 0xFE, 0x41, 0x46,
+	0x01, 0x23, 0x02, 0x22, 0x08, 0x46, 0x00, 0x97, 0x08, 0xF0, 0x0D, 0xFE,
+	0x05, 0x96, 0x06, 0x96,
+	0x07, 0x96, 0xCD, 0xE9, 0x01, 0x4A, 0x11, 0x48, 0x05, 0xF1, 0x14, 0x03,
+	0x03, 0x94, 0x1E, 0x46,
+	0x02, 0x22, 0x01, 0x21, 0x10, 0x30, 0xCD, 0xF8, 0x00, 0x90, 0x04, 0x94,
+	0x08, 0xF0, 0x32, 0xFE,
+	0xB5, 0xF9, 0x00, 0x00, 0x05, 0x99, 0x01, 0x23, 0x40, 0x1A, 0x05, 0x90,
+	0x00, 0x90, 0x02, 0x22,
+	0x06, 0xA9, 0x58, 0x46, 0x08, 0xF0, 0xFD, 0xFD, 0x01, 0x23, 0x31, 0x46,
+	0x02, 0x22, 0x08, 0x46,
+	0x00, 0x97, 0x05, 0xE0, 0x4C, 0x07, 0x10, 0x00, 0x40, 0x42, 0x0F, 0x00,
+	0x98, 0x05, 0x10, 0x00,
+	0x08, 0xF0, 0xEF, 0xFD, 0x32, 0x46, 0x02, 0x23, 0x06, 0xA9, 0x10, 0x46,
+	0x00, 0x94, 0x08, 0xF0,
+	0xF5, 0xFD, 0x31, 0x46, 0x01, 0x23, 0x02, 0x22, 0x08, 0x46, 0x00, 0x97,
+	0x08, 0xF0, 0xD3, 0xFD,
+	0xE6, 0xE6, 0x2D, 0xE9, 0xF7, 0x4F, 0x8A, 0xB0, 0x00, 0x26, 0x05, 0x96,
+	0x06, 0x96, 0x07, 0x96,
+	0x08, 0x96, 0x01, 0x24, 0x4F, 0xF0, 0x02, 0x09, 0x0D, 0xF1, 0x14, 0x0A,
+	0x09, 0x96, 0xCD, 0xE9,
+	0x01, 0x4A, 0xCD, 0xE9, 0x03, 0x94, 0x07, 0x46, 0x07, 0xF1, 0x1C, 0x00,
+	0x4D, 0x46, 0xFD, 0x4B,
+	0x4A, 0x46, 0x49, 0x46, 0x80, 0x46, 0xCD, 0xF8, 0x00, 0x90, 0x08, 0xF0,
+	0xEB, 0xFD, 0x07, 0xA8,
+	0xCD, 0xE9, 0x01, 0x50, 0xF7, 0x48, 0xCD, 0xE9, 0x03, 0x45, 0x43, 0x46,
+	0x02, 0x22, 0x01, 0x21,
+	0x08, 0x38, 0x00, 0x95, 0x08, 0xF0, 0xDE, 0xFD, 0x0D, 0xF1, 0x24, 0x0B,
+	0xCD, 0xE9, 0x01, 0x4B,
+	0x03, 0x94, 0xF0, 0x4B, 0x02, 0x22, 0x01, 0x21, 0x07, 0xA8, 0x00, 0x95,
+	0x04, 0x94, 0x08, 0xF0,
+	0xD1, 0xFD, 0xEC, 0x4D, 0x18, 0x3D, 0x28, 0x78, 0x01, 0x28, 0x04, 0xD1,
+	0x01, 0x21, 0x38, 0x46,
+	0xFF, 0xF7, 0xA8, 0xFD, 0x68, 0x60, 0x09, 0x98, 0x69, 0x68, 0x4F, 0xF0,
+	0x64, 0x08, 0x08, 0x44,
+	0x05, 0xA9, 0x09, 0x90, 0x01, 0x23, 0x02, 0x22, 0xCD, 0xF8, 0x00, 0x80,
+	0x08, 0x46, 0x08, 0xF0,
+	0x90, 0xFD, 0x09, 0x98, 0x00, 0x90, 0x01, 0x23, 0x02, 0x22, 0x05, 0xA8,
+	0x0B, 0x99, 0x08, 0xF0,
+	0x7A, 0xFD, 0x07, 0x96, 0x08, 0x96, 0x05, 0x96, 0x06, 0x96, 0x09, 0x96,
+	0xCD, 0xE9, 0x01, 0x4A,
+	0xCD, 0xE9, 0x03, 0x94, 0x4E, 0x46, 0x02, 0x22, 0x07, 0xF1, 0x2C, 0x00,
+	0xCD, 0xF8, 0x00, 0x90,
+	0xD4, 0x4B, 0x11, 0x46, 0x81, 0x46, 0x08, 0xF0, 0x9D, 0xFD, 0x07, 0xA8,
+	0xCD, 0xE9, 0x01, 0x60,
+	0xCD, 0xE9, 0x03, 0x46, 0xCF, 0x48, 0x4B, 0x46, 0x02, 0x22, 0x01, 0x21,
+	0x08, 0x38, 0x00, 0x96,
+	0x08, 0xF0, 0x90, 0xFD, 0xCD, 0xE9, 0x01, 0x4B, 0x03, 0x94, 0xCA, 0x4B,
+	0x02, 0x22, 0x01, 0x21,
+	0x07, 0xA8, 0x00, 0x96, 0x04, 0x94, 0x08, 0xF0, 0x85, 0xFD, 0x28, 0x78,
+	0x01, 0x28, 0x04, 0xD1,
+	0x00, 0x21, 0x38, 0x46, 0xFF, 0xF7, 0x5E, 0xFD, 0x68, 0x60, 0x09, 0x98,
+	0x69, 0x68, 0x01, 0x23,
+	0x08, 0x44, 0x05, 0xA9, 0x09, 0x90, 0x02, 0x22, 0xCD, 0xF8, 0x00, 0x80,
+	0x08, 0x46, 0x08, 0xF0,
+	0x48, 0xFD, 0x09, 0x98, 0x00, 0x90, 0x01, 0x23, 0x02, 0x22, 0x05, 0xA8,
+	0x0C, 0x99, 0x08, 0xF0,
+	0x32, 0xFD, 0xE1, 0xE6, 0x2D, 0xE9, 0xF7, 0x4F, 0x8E, 0xB0, 0x00, 0x25,
+	0x05, 0x95, 0x06, 0x95,
+	0x07, 0x95, 0x02, 0x24, 0x08, 0x95, 0x09, 0x95, 0x0A, 0x95, 0x0B, 0x95,
+	0x05, 0xAF, 0x0C, 0x95,
+	0xCD, 0xE9, 0x01, 0x47, 0x8C, 0x46, 0x4F, 0xF0, 0x01, 0x0A, 0xAE, 0x4B,
+	0x06, 0x46, 0x03, 0x94,
+	0x08, 0x3B, 0x52, 0x46, 0x21, 0x46, 0x60, 0x46, 0xCD, 0xF8, 0x00, 0xA0,
+	0x04, 0x94, 0x08, 0xF0,
+	0x49, 0xFD, 0xA8, 0x48, 0x05, 0xAA, 0x02, 0x23, 0x11, 0x46, 0x28, 0x30,
+	0x00, 0x94, 0x08, 0xF0,
+	0x33, 0xFD, 0x0D, 0xF1, 0x24, 0x08, 0xCD, 0xE9, 0x01, 0x48, 0x06, 0xF1,
+	0x1C, 0x03, 0x02, 0x22,
+	0x03, 0x94, 0x04, 0x94, 0x9B, 0x46, 0x11, 0x46, 0x05, 0xA8, 0x00, 0x94,
+	0x08, 0xF0, 0x32, 0xFD,
+	0x4F, 0xF0, 0x64, 0x09, 0x02, 0x23, 0x1A, 0x46, 0x59, 0x46, 0x09, 0xA8,
+	0xCD, 0xF8, 0x00, 0x90,
+	0x08, 0xF0, 0xF1, 0xFC, 0x05, 0x95, 0x06, 0x95, 0x07, 0x95, 0x08, 0x95,
+	0x09, 0x95, 0x0A, 0x95,
+	0x0B, 0x95, 0x0C, 0x95, 0xCD, 0xE9, 0x01, 0x47, 0x92, 0x4B, 0x03, 0x94,
+	0x08, 0x3B, 0x01, 0x22,
+	0x02, 0x21, 0xCD, 0xF8, 0x00, 0xA0, 0x04, 0x94, 0x10, 0x98, 0x08, 0xF0,
+	0x13, 0xFD, 0x8D, 0x48,
+	0x05, 0xAA, 0x02, 0x23, 0x11, 0x46, 0x28, 0x30, 0x00, 0x94, 0x08, 0xF0,
+	0xFD, 0xFC, 0xCD, 0xE9,
+	0x01, 0x48, 0x03, 0x94, 0x04, 0x94, 0x06, 0xF1, 0x2C, 0x03, 0x00, 0x94,
+	0x02, 0x22, 0x1C, 0x46,
+	0x11, 0x46, 0x05, 0xA8, 0x08, 0xF0, 0xFE, 0xFC, 0x02, 0x23, 0x1A, 0x46,
+	0x21, 0x46, 0x09, 0xA8,
+	0xCD, 0xF8, 0x00, 0x90, 0x08, 0xF0, 0xBF, 0xFC, 0x11, 0xB0, 0xD2, 0xE5,
+	0x38, 0xB5, 0x7E, 0x48,
+	0x7C, 0x4C, 0x01, 0x68, 0x18, 0x3C, 0x91, 0xF8, 0x80, 0x03, 0xC0, 0xF3,
+	0x00, 0x12, 0x22, 0x70,
+	0xB1, 0xF8, 0xB1, 0x03, 0x1A, 0xB1, 0x64, 0x21, 0x48, 0x43, 0x0D, 0x46,
+	0x01, 0xE0, 0xD1, 0xF8,
+	0xAD, 0x53, 0x74, 0x49, 0x80, 0x08, 0x02, 0x23, 0x48, 0x31, 0x00, 0x90,
+	0x1A, 0x46, 0xA1, 0xF1,
+	0x10, 0x00, 0x08, 0xF0, 0xAE, 0xFC, 0x65, 0x60, 0x38, 0xBD, 0xF8, 0xB5,
+	0x04, 0x46, 0x08, 0x68,
+	0x20, 0x60, 0x48, 0x68, 0x60, 0x60, 0x88, 0x68, 0xA0, 0x60, 0x00, 0x25,
+	0x25, 0x64, 0xE5, 0x63,
+	0xB1, 0xF9, 0x02, 0x00, 0xC4, 0xE9, 0x03, 0x05, 0xB1, 0xF9, 0x00, 0x00,
+	0xC4, 0xE9, 0x05, 0x05,
+	0x64, 0x48, 0x18, 0x38, 0x01, 0x78, 0x01, 0x29, 0x09, 0xD0, 0x60, 0x30,
+	0x1C, 0x34, 0x0F, 0xC8,
+	0x0F, 0xC4, 0x84, 0xE8, 0x0F, 0x00, 0x2C, 0x3C, 0x84, 0xF8, 0x81, 0x50,
+	0xF8, 0xBD, 0x50, 0x30,
+	0x1C, 0x34, 0x0F, 0xC8, 0x0F, 0xC4, 0x5C, 0x4E, 0x0F, 0xC4, 0x30, 0x68,
+	0x64, 0x21, 0x02, 0x23,
+	0xB0, 0xF8, 0xB1, 0x03, 0x1A, 0x46, 0x48, 0x43, 0x80, 0x08, 0xA4, 0xF1,
+	0x20, 0x01, 0x00, 0x90,
+	0x08, 0x46, 0x3C, 0x3C, 0x08, 0xF0, 0x75, 0xFC, 0x30, 0x68, 0x64, 0x21,
+	0x02, 0x23, 0xB0, 0xF8,
+	0xB1, 0x03, 0x1A, 0x46, 0x48, 0x43, 0x80, 0x08, 0x04, 0xF1, 0x2C, 0x01,
+	0x00, 0x90, 0x08, 0x46,
+	0x08, 0xF0, 0x67, 0xFC, 0x94, 0xE8, 0x07, 0x00, 0x04, 0xF1, 0x44, 0x03,
+	0x83, 0xE8, 0x07, 0x00,
+	0x84, 0xF8, 0x80, 0x50, 0xD0, 0xE7, 0x10, 0xB5, 0x04, 0x46, 0x03, 0x22,
+	0x08, 0xF0, 0xDC, 0xFC,
+	0x20, 0x46, 0xFF, 0xF7, 0x94, 0xFC, 0xB4, 0xF9, 0x02, 0x00, 0xE0, 0x60,
+	0xB4, 0xF9, 0x06, 0x10,
+	0x40, 0x1A, 0x20, 0x61, 0xB4, 0xF9, 0x00, 0x00, 0x60, 0x61, 0xB4, 0xF9,
+	0x04, 0x10, 0x40, 0x1A,
+	0xA0, 0x61, 0x10, 0xBD, 0x7F, 0xB5, 0x0D, 0x46, 0x04, 0x46, 0x03, 0x22,
+	0x08, 0xF0, 0xC4, 0xFC,
+	0x20, 0x46, 0xFF, 0xF7, 0x7C, 0xFC, 0x20, 0x46, 0xFF, 0xF7, 0xD9, 0xFC,
+	0x20, 0x46, 0xFF, 0xF7,
+	0x4C, 0xFD, 0x00, 0x20, 0x00, 0x90, 0x01, 0x90, 0x02, 0x90, 0x03, 0x90,
+	0x02, 0xAA, 0x69, 0x46,
+	0x20, 0x46, 0xFF, 0xF7, 0x4E, 0xFE, 0x02, 0xAA, 0x69, 0x46, 0x20, 0x46,
+	0xFF, 0xF7, 0xCE, 0xFD,
+	0x02, 0xAA, 0x69, 0x46, 0x20, 0x46, 0xFF, 0xF7, 0xE5, 0xFE, 0xA0, 0x89,
+	0x68, 0x80, 0xA0, 0x8A,
+	0x28, 0x80, 0x28, 0x48, 0x18, 0x38, 0x00, 0x78, 0x01, 0x28, 0x05, 0xD1,
+	0x03, 0x22, 0x29, 0x46,
+	0x04, 0xF1, 0x44, 0x00, 0x08, 0xF0, 0x98, 0xFC, 0x7F, 0xBD, 0x2D, 0xE9,
+	0xF0, 0x47, 0x06, 0x46,
+	0x48, 0x88, 0xB6, 0xF8, 0x4A, 0x30, 0x89, 0x46, 0xC0, 0x1A, 0xB6, 0xF8,
+	0x46, 0x40, 0x92, 0x46,
+	0x01, 0xB2, 0xB9, 0xF8, 0x00, 0x00, 0xB6, 0xF8, 0x48, 0x20, 0xE3, 0x1A,
+	0x1C, 0xB2, 0x80, 0x1A,
+	0xB6, 0xF8, 0x44, 0x30, 0x00, 0xB2, 0x9A, 0x1A, 0x15, 0xB2, 0x0C, 0xB9,
+	0x00, 0x2D, 0x27, 0xD0,
+	0x49, 0x43, 0x00, 0xFB, 0x00, 0x10, 0x64, 0x21, 0x48, 0x43, 0x04, 0xFB,
+	0x04, 0xF1, 0x05, 0xFB,
+	0x05, 0x11, 0xB0, 0xFB, 0xF1, 0xF0, 0x08, 0xF0, 0xC7, 0xFB, 0x44, 0x43,
+	0x0A, 0x22, 0x45, 0x43,
+	0x21, 0xB2, 0x28, 0xB2, 0x91, 0xFB, 0xF2, 0xF1, 0x90, 0xFB, 0xF2, 0xF0,
+	0xB6, 0xF8, 0x46, 0x20,
+	0x61, 0xF3, 0x1F, 0x48, 0x11, 0x44, 0x61, 0xF3, 0x1F, 0x47, 0xB6, 0xF8,
+	0x44, 0x10, 0x60, 0xF3,
+	0x0F, 0x08, 0x08, 0x44, 0x60, 0xF3, 0x0F, 0x07, 0xC9, 0xF8, 0x00, 0x70,
+	0xCA, 0xF8, 0x00, 0x80,
+	0xBD, 0xE8, 0xF0, 0x87, 0xB0, 0x05, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0xF0, 0xB5, 0x4F, 0xF0,
+	0x00, 0x0C, 0x63, 0x46, 0x65, 0x46, 0x14, 0x46, 0x07, 0xE0, 0x00, 0xBF,
+	0x01, 0xEB, 0xC4, 0x06,
+	0x76, 0x68, 0x35, 0x44, 0x51, 0xF8, 0x34, 0x60, 0x33, 0x44, 0x64, 0x1E,
+	0xF6, 0xD2, 0x95, 0xFB,
+	0xF2, 0xF6, 0x93, 0xFB, 0xF2, 0xF7, 0xC0, 0xF8, 0x04, 0xC0, 0x15, 0x46,
+	0x42, 0xF2, 0x10, 0x74,
+	0xC0, 0xF8, 0x00, 0xC0, 0x17, 0xE0, 0x00, 0xBF, 0x01, 0xEB, 0xC5, 0x03,
+	0x5B, 0x68, 0x9B, 0x1B,
+	0x5B, 0x43, 0xA3, 0x42, 0x00, 0xDD, 0x23, 0x46, 0xD0, 0xF8, 0x04, 0xC0,
+	0x63, 0x44, 0x43, 0x60,
+	0x51, 0xF8, 0x35, 0x30, 0xDB, 0x1B, 0x5B, 0x43, 0xA3, 0x42, 0x00, 0xDD,
+	0x23, 0x46, 0xD0, 0xF8,
+	0x00, 0xC0, 0x63, 0x44, 0x03, 0x60, 0x6D, 0x1E, 0xE6, 0xD2, 0x41, 0x68,
+	0x64, 0x23, 0x59, 0x43,
+	0x91, 0xFB, 0xF2, 0xF1, 0x41, 0x60, 0x01, 0x68, 0x59, 0x43, 0x91, 0xFB,
+	0xF2, 0xF1, 0x01, 0x60,
+	0xF0, 0xBD, 0x00, 0x00, 0x10, 0xB5, 0x14, 0x21, 0x4B, 0x48, 0x0C, 0xF0,
+	0x6F, 0xFB, 0xF6, 0xF7,
+	0xD3, 0xFE, 0x64, 0x21, 0x48, 0x43, 0x48, 0x49, 0x08, 0x60, 0x10, 0xBD,
+	0x2D, 0xE9, 0xF0, 0x41,
+	0xDF, 0xF8, 0x18, 0x81, 0x04, 0x46, 0x0D, 0x46, 0xD8, 0xF8, 0x00, 0x00,
+	0x90, 0xF8, 0xA0, 0x13,
+	0x90, 0xF8, 0x80, 0x03, 0x01, 0xF0, 0x0F, 0x06, 0xC6, 0xF1, 0x10, 0x07,
+	0x80, 0x07, 0x0F, 0xD5,
+	0xB4, 0xF8, 0x42, 0x00, 0x01, 0x07, 0x0B, 0xD4, 0x00, 0x06, 0x09, 0xD4,
+	0x0C, 0xF0, 0xFC, 0xFB,
+	0x30, 0xB9, 0x3B, 0x48, 0x00, 0x78, 0x18, 0xB9, 0x3A, 0x48, 0x00, 0x78,
+	0x01, 0x28, 0x02, 0xD9,
+	0x00, 0x20, 0x20, 0x63, 0x18, 0xE0, 0x20, 0x6B, 0x02, 0x28, 0x18, 0xD8,
+	0x40, 0x1C, 0x20, 0x63,
+	0x02, 0x28, 0x07, 0xD9, 0x94, 0xF8, 0x3E, 0x11, 0x04, 0x29, 0x10, 0xD0,
+	0x06, 0x29, 0x0E, 0xD0,
+	0x07, 0x29, 0x0C, 0xD0, 0x02, 0x28, 0x07, 0xD1, 0xE0, 0x89, 0x61, 0x8A,
+	0x40, 0x1A, 0x60, 0x85,
+	0xA0, 0x89, 0x21, 0x8A, 0x40, 0x1A, 0x20, 0x85, 0x00, 0x20, 0xBD, 0xE8,
+	0xF0, 0x81, 0xE0, 0x89,
+	0x61, 0x8A, 0x22, 0x8A, 0x40, 0x1A, 0x01, 0xB2, 0xA0, 0x89, 0x79, 0x43,
+	0x80, 0x1A, 0xB4, 0xF9,
+	0x2A, 0x20, 0x00, 0xB2, 0x02, 0xFB, 0x06, 0x11, 0x09, 0x11, 0x61, 0x85,
+	0xB4, 0xF9, 0x28, 0x10,
+	0x78, 0x43, 0x01, 0xFB, 0x06, 0x00, 0x00, 0x11, 0x20, 0x85, 0xF6, 0xF7,
+	0x2B, 0xFE, 0x1A, 0x4A,
+	0x91, 0x89, 0x08, 0x1A, 0x11, 0x7C, 0x01, 0x29, 0x01, 0xD1, 0x51, 0x68,
+	0x08, 0x44, 0x00, 0x28,
+	0x00, 0xDA, 0x00, 0x20, 0x00, 0xEB, 0x80, 0x01, 0x13, 0x68, 0x49, 0x00,
+	0xB1, 0xFB, 0xF3, 0xF7,
+	0xD8, 0xF8, 0x00, 0x60, 0xB6, 0xF8, 0xA1, 0x13, 0x8F, 0x42, 0x03, 0xD9,
+	0x59, 0x43, 0x0A, 0x20,
+	0xB1, 0xFB, 0xF0, 0xF0, 0xB4, 0xF9, 0x2A, 0x10, 0x96, 0xF8, 0xA3, 0x33,
+	0x92, 0x68, 0x59, 0x43,
+	0x64, 0x26, 0x41, 0x43, 0x72, 0x43, 0xB4, 0xF9, 0x28, 0x40, 0x91, 0xFB,
+	0xF2, 0xF1, 0x5C, 0x43,
+	0x44, 0x43, 0x94, 0xFB, 0xF2, 0xF0, 0x6A, 0x88, 0x11, 0x44, 0x69, 0x80,
+	0x29, 0x88, 0x08, 0x44,
+	0x28, 0x80, 0x01, 0x20, 0xB1, 0xE7, 0x00, 0x00, 0x6C, 0x2C, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0x74, 0x05, 0x10, 0x00, 0x20, 0x07, 0x10, 0x00, 0xB0, 0xF8, 0x44, 0x20,
+	0xB1, 0xF8, 0x44, 0x30,
+	0x1A, 0x44, 0xA0, 0xF8, 0x44, 0x20, 0xB0, 0xF8, 0x46, 0x20, 0xB1, 0xF8,
+	0x46, 0x30, 0x1A, 0x44,
+	0xA0, 0xF8, 0x46, 0x20, 0x42, 0x6B, 0x4B, 0x6B, 0x1A, 0x44, 0x42, 0x63,
+	0x82, 0x6B, 0x8B, 0x6B,
+	0x1A, 0x44, 0x82, 0x63, 0xB1, 0xF9, 0x54, 0x20, 0xB0, 0xF9, 0x54, 0x30,
+	0x9A, 0x42, 0x01, 0xDD,
+	0xA0, 0xF8, 0x54, 0x20, 0xB1, 0xF9, 0x56, 0x20, 0xB0, 0xF9, 0x56, 0x30,
+	0x9A, 0x42, 0x01, 0xDD,
+	0xA0, 0xF8, 0x56, 0x20, 0x90, 0xF8, 0x46, 0x21, 0x91, 0xF8, 0x46, 0x31,
+	0x9A, 0x42, 0x0A, 0xD0,
+	0x30, 0xF8, 0x48, 0x2F, 0xB1, 0xF8, 0x48, 0x30, 0x1A, 0x44, 0x20, 0xF8,
+	0x0C, 0x29, 0xC9, 0x6B,
+	0x02, 0x68, 0x11, 0x44, 0x01, 0x60, 0x70, 0x47, 0x2D, 0xE9, 0xF0, 0x4F,
+	0x97, 0xB0, 0x80, 0x46,
+	0x00, 0xF5, 0x80, 0x50, 0x00, 0x26, 0x11, 0x90, 0xBF, 0xE0, 0x00, 0x20,
+	0x08, 0x90, 0x05, 0x90,
+	0x10, 0x90, 0x12, 0x90, 0x81, 0x46, 0x82, 0x46, 0x83, 0x46, 0x05, 0x46,
+	0x07, 0x46, 0x0A, 0x90,
+	0x0B, 0x90, 0x0C, 0x90, 0x0D, 0x90, 0x08, 0xEB, 0x86, 0x00, 0x00, 0xF5,
+	0x80, 0x50, 0x14, 0x90,
+	0xD0, 0xF8, 0x68, 0x04, 0x0A, 0xAA, 0x04, 0x46, 0x17, 0xE0, 0x00, 0xBF,
+	0x90, 0xF8, 0x46, 0x11,
+	0x08, 0xEB, 0x01, 0x0C, 0x53, 0x5C, 0x0C, 0xF5, 0x80, 0x5C, 0x5B, 0x1C,
+	0xDB, 0xB2, 0x53, 0x54,
+	0x9C, 0xF8, 0x56, 0xC4, 0x63, 0x45, 0x06, 0xD1, 0x01, 0x2B, 0x04, 0xD9,
+	0x01, 0x23, 0x8B, 0x40,
+	0x12, 0x99, 0x0B, 0x43, 0x12, 0x93, 0xD0, 0xF8, 0x50, 0x01, 0x00, 0x28,
+	0xE6, 0xD1, 0x40, 0xE0,
+	0x94, 0xF8, 0x46, 0x11, 0x01, 0x20, 0x00, 0xFA, 0x01, 0xFC, 0x12, 0x99,
+	0x1C, 0xEA, 0x01, 0x0F,
+	0x12, 0xD1, 0xA0, 0x6B, 0xB4, 0xF9, 0x0E, 0x30, 0x05, 0x9A, 0x49, 0x46,
+	0xC0, 0xFB, 0x03, 0x12,
+	0x05, 0x92, 0x89, 0x46, 0xB4, 0xF9, 0x0C, 0x30, 0x51, 0x46, 0x5A, 0x46,
+	0xC0, 0xFB, 0x03, 0x12,
+	0x8A, 0x46, 0x93, 0x46, 0x05, 0x44, 0x19, 0xE0, 0x08, 0x99, 0x1C, 0xEA,
+	0x01, 0x0F, 0x15, 0xD1,
+	0xE0, 0x6B, 0xB4, 0xF9, 0x1E, 0x30, 0x05, 0x9A, 0x49, 0x46, 0xC0, 0xFB,
+	0x03, 0x12, 0x05, 0x92,
+	0x89, 0x46, 0xB4, 0xF9, 0x1C, 0x30, 0x51, 0x46, 0x5A, 0x46, 0xC0, 0xFB,
+	0x03, 0x12, 0x8A, 0x46,
+	0x08, 0x99, 0x05, 0x44, 0x4C, 0xEA, 0x01, 0x00, 0x93, 0x46, 0x08, 0x90,
+	0x20, 0x46, 0x00, 0xF0,
+	0x98, 0xFB, 0x01, 0x28, 0x02, 0xD1, 0x10, 0x98, 0x40, 0x1C, 0x10, 0x90,
+	0xD4, 0xF8, 0x50, 0x41,
+	0x7F, 0x1C, 0x00, 0x2C, 0xBC, 0xD1, 0x00, 0x2F, 0x45, 0xDD, 0xE8, 0x17,
+	0x04, 0x46, 0x03, 0x46,
+	0x2A, 0x46, 0x48, 0x46, 0x05, 0x99, 0x0C, 0xF0, 0x4C, 0xF9, 0xAD, 0xF8,
+	0x1E, 0x00, 0x2A, 0x46,
+	0x23, 0x46, 0x50, 0x46, 0x59, 0x46, 0x0C, 0xF0, 0x44, 0xF9, 0xAD, 0xF8,
+	0x1C, 0x00, 0x14, 0x98,
+	0x4F, 0xF0, 0xFF, 0x37, 0x00, 0x25, 0xD0, 0xF8, 0x68, 0x44, 0x23, 0xE0,
+	0x20, 0x46, 0x00, 0xF0,
+	0x70, 0xFB, 0x01, 0x28, 0x01, 0xD0, 0x10, 0x98, 0x90, 0xB9, 0x04, 0xF1,
+	0x10, 0x01, 0x07, 0xA8,
+	0x08, 0xF0, 0xB9, 0xFA, 0xB8, 0x42, 0x0B, 0xD2, 0x07, 0x46, 0x3D, 0xB1,
+	0x29, 0x46, 0x20, 0x46,
+	0xFF, 0xF7, 0x1A, 0xFF, 0x29, 0x46, 0x40, 0x46, 0x00, 0xF0, 0x72, 0xFB,
+	0x25, 0x46, 0x07, 0xE0,
+	0x21, 0x46, 0x28, 0x46, 0xFF, 0xF7, 0x10, 0xFF, 0x21, 0x46, 0x40, 0x46,
+	0x00, 0xF0, 0x68, 0xFB,
+	0xD4, 0xF8, 0x50, 0x41, 0x00, 0x2C, 0xD9, 0xD1, 0x07, 0x98, 0x45, 0xF8,
+	0x0C, 0x0F, 0xE8, 0x8E,
+	0x40, 0xF0, 0x40, 0x00, 0xE8, 0x86, 0x11, 0x98, 0x76, 0x1C, 0x90, 0xF8,
+	0xE0, 0x04, 0xB0, 0x42,
+	0x3F, 0xF7, 0x3B, 0xAF, 0x17, 0xB0, 0xBD, 0xE8, 0xF0, 0x8F, 0x2D, 0xE9,
+	0xF7, 0x4F, 0x05, 0x46,
+	0x0E, 0x46, 0x01, 0xEB, 0x06, 0x10, 0x00, 0xEB, 0x80, 0x00, 0x82, 0xB0,
+	0x05, 0xEB, 0x80, 0x0A,
+	0x00, 0x24, 0x4F, 0xF0, 0x01, 0x08, 0xDF, 0xF8, 0x98, 0xB5, 0x05, 0xF5,
+	0x80, 0x57, 0x7F, 0xE0,
+	0xD7, 0xF8, 0xEC, 0x23, 0x08, 0xFA, 0x04, 0xF9, 0x12, 0xEA, 0x09, 0x0F,
+	0x77, 0xD0, 0xB4, 0x42,
+	0x75, 0xD0, 0xDB, 0xF8, 0x08, 0x10, 0x31, 0xF8, 0x16, 0x10, 0x11, 0xEA,
+	0x09, 0x0F, 0x6E, 0xD1,
+	0x04, 0xEB, 0x04, 0x10, 0x00, 0xEB, 0x80, 0x00, 0x05, 0xEB, 0x80, 0x00,
+	0x00, 0x90, 0x00, 0xF0,
+	0x0A, 0xFB, 0x01, 0x28, 0x04, 0xD0, 0x00, 0x98, 0x00, 0xF0, 0x0B, 0xFB,
+	0x01, 0x28, 0x5E, 0xD1,
+	0x00, 0x98, 0x00, 0xF0, 0xF8, 0xFA, 0xE8, 0xBB, 0x00, 0x99, 0x0A, 0xF1,
+	0x0C, 0x00, 0x0C, 0x31,
+	0x08, 0xF0, 0x51, 0xFA, 0x01, 0x90, 0xDB, 0xF8, 0x08, 0x00, 0x08, 0xFA,
+	0x06, 0xF2, 0x30, 0xF8,
+	0x16, 0x30, 0x43, 0xEA, 0x09, 0x03, 0x20, 0xF8, 0x16, 0x30, 0x30, 0xF8,
+	0x14, 0x30, 0x13, 0x43,
+	0x20, 0xF8, 0x14, 0x30, 0x50, 0x46, 0xDB, 0xF8, 0x00, 0x90, 0x00, 0xF0,
+	0xF6, 0xFA, 0x01, 0x28,
+	0x04, 0xD1, 0x00, 0x98, 0x00, 0xF0, 0xDF, 0xFA, 0x01, 0x28, 0x1D, 0xD0,
+	0x50, 0x46, 0x00, 0xF0,
+	0xDA, 0xFA, 0x01, 0x28, 0x04, 0xD1, 0x00, 0x98, 0x00, 0xF0, 0xE7, 0xFA,
+	0x01, 0x28, 0x13, 0xD0,
+	0x50, 0x46, 0x00, 0xF0, 0xD0, 0xFA, 0x01, 0x28, 0x1E, 0xD1, 0x00, 0x98,
+	0x00, 0xF0, 0xCB, 0xFA,
+	0x01, 0x28, 0x19, 0xD1, 0x00, 0x99, 0x9A, 0xF8, 0x42, 0x00, 0x91, 0xF8,
+	0x42, 0x10, 0x08, 0x43,
+	0x80, 0x06, 0x00, 0xE0, 0x1B, 0xE0, 0x0F, 0xD5, 0xBA, 0xF8, 0x42, 0x00,
+	0xDB, 0xF8, 0x04, 0x90,
+	0x40, 0xF0, 0x20, 0x01, 0xAA, 0xF8, 0x42, 0x10, 0x00, 0x98, 0xB0, 0xF8,
+	0x42, 0x00, 0x40, 0xF0,
+	0x20, 0x01, 0x00, 0x98, 0xA0, 0xF8, 0x42, 0x10, 0x01, 0x98, 0x48, 0x45,
+	0x07, 0xD2, 0x41, 0xF2,
+	0x68, 0x40, 0x51, 0x46, 0x28, 0x44, 0x04, 0x9B, 0x00, 0x9A, 0x00, 0xF0,
+	0xD0, 0xFA, 0x64, 0x1C,
+	0x97, 0xF9, 0xF4, 0x03, 0xA0, 0x42, 0xBF, 0xF6, 0x7B, 0xAF, 0x05, 0xB0,
+	0x63, 0xE7, 0x2D, 0xE9,
+	0xF8, 0x4F, 0x88, 0x46, 0x06, 0x46, 0x01, 0xEB, 0x08, 0x10, 0x00, 0xEB,
+	0x80, 0x00, 0x06, 0xEB,
+	0x80, 0x04, 0xDF, 0xF8, 0x6C, 0xA4, 0x94, 0xF8, 0x42, 0x00, 0x4F, 0xF0,
+	0x04, 0x0B, 0x40, 0x06,
+	0x4F, 0xF0, 0x01, 0x09, 0x06, 0xF5, 0x80, 0x55, 0x2E, 0xD5, 0x00, 0x27,
+	0x04, 0xF1, 0x0C, 0x0B,
+	0x24, 0xE0, 0x00, 0xBF, 0xD5, 0xF8, 0xEC, 0x13, 0x09, 0xFA, 0x07, 0xF0,
+	0x01, 0x42, 0x1C, 0xD0,
+	0x47, 0x45, 0x1A, 0xD0, 0x07, 0xEB, 0x07, 0x10, 0x00, 0xEB, 0x80, 0x00,
+	0x06, 0xEB, 0x80, 0x00,
+	0x00, 0x90, 0x00, 0xF0, 0x70, 0xFA, 0x01, 0x28, 0x0F, 0xD1, 0x00, 0x98,
+	0x00, 0xF0, 0x63, 0xFA,
+	0x58, 0xB9, 0x00, 0x99, 0x58, 0x46, 0x10, 0x31, 0x08, 0xF0, 0xBD, 0xF9,
+	0xDA, 0xF8, 0x04, 0x10,
+	0x88, 0x42, 0x02, 0xD2, 0x04, 0x20, 0x84, 0xF8, 0x3E, 0x01, 0x7F, 0x1C,
+	0x95, 0xF9, 0xF4, 0x03,
+	0xB8, 0x42, 0xD7, 0xDA, 0xBD, 0xE8, 0xF8, 0x8F, 0xFE, 0x48, 0xE1, 0x6A,
+	0x00, 0x68, 0x90, 0xF8,
+	0x95, 0x03, 0x81, 0x42, 0xF6, 0xD9, 0x00, 0x27, 0x31, 0xE0, 0x00, 0xBF,
+	0xD5, 0xF8, 0xEC, 0x13,
+	0x09, 0xFA, 0x07, 0xF0, 0x01, 0x42, 0x29, 0xD0, 0x47, 0x45, 0x27, 0xD0,
+	0x07, 0xEB, 0x07, 0x10,
+	0x00, 0xEB, 0x80, 0x00, 0x06, 0xEB, 0x80, 0x00, 0x00, 0x90, 0x00, 0xF0,
+	0x3C, 0xFA, 0x01, 0x28,
+	0x1C, 0xD1, 0x00, 0x98, 0x94, 0xF8, 0x46, 0x11, 0x90, 0xF8, 0x47, 0x01,
+	0x81, 0x42, 0x15, 0xD1,
+	0x00, 0x98, 0x00, 0xF0, 0x28, 0xFA, 0x88, 0xB9, 0x00, 0x99, 0x04, 0xF1,
+	0x0C, 0x00, 0x10, 0x31,
+	0x08, 0xF0, 0x81, 0xF9, 0xDA, 0xF8, 0x04, 0x10, 0x88, 0x42, 0x07, 0xD2,
+	0x84, 0xF8, 0x3E, 0xB1,
+	0xB4, 0xF8, 0x42, 0x00, 0x40, 0xF0, 0x40, 0x00, 0xA4, 0xF8, 0x42, 0x00,
+	0x7F, 0x1C, 0x95, 0xF9,
+	0xF4, 0x03, 0xB8, 0x42, 0xCA, 0xDA, 0x00, 0x27, 0x0C, 0x34, 0x26, 0xE0,
+	0xD5, 0xF8, 0xEC, 0x13,
+	0x09, 0xFA, 0x07, 0xF0, 0x01, 0x42, 0x1F, 0xD0, 0x47, 0x45, 0x1D, 0xD0,
+	0x07, 0xEB, 0x07, 0x10,
+	0x00, 0xEB, 0x80, 0x00, 0x06, 0xEB, 0x80, 0x00, 0x83, 0x46, 0x00, 0xF0,
+	0x0A, 0xFA, 0x01, 0x28,
+	0x12, 0xD1, 0x58, 0x46, 0x00, 0xF0, 0xF7, 0xF9, 0x70, 0xB9, 0x0B, 0xF1,
+	0x10, 0x01, 0x20, 0x46,
+	0x08, 0xF0, 0x51, 0xF9, 0xDA, 0xF8, 0x04, 0x10, 0x88, 0x42, 0x05, 0xD2,
+	0xBB, 0xF8, 0x42, 0x00,
+	0x40, 0xF0, 0x40, 0x01, 0xAB, 0xF8, 0x42, 0x10, 0x7F, 0x1C, 0x95, 0xF9,
+	0xF4, 0x03, 0xB8, 0x42,
+	0xD4, 0xDA, 0x8F, 0xE7, 0x2D, 0xE9, 0xF8, 0x43, 0x06, 0x46, 0xFF, 0x20,
+	0x00, 0x25, 0x8D, 0xF8,
+	0x00, 0x00, 0x01, 0x27, 0x06, 0xF5, 0x80, 0x54, 0x1A, 0xE0, 0x00, 0xBF,
+	0x05, 0xEB, 0x05, 0x10,
+	0x00, 0xEB, 0x80, 0x00, 0x06, 0xEB, 0x80, 0x08, 0xD4, 0xF8, 0xEC, 0x03,
+	0x07, 0xFA, 0x05, 0xF1,
+	0x08, 0x42, 0x0C, 0xD0, 0x40, 0x46, 0x00, 0xF0, 0xC6, 0xF9, 0x01, 0x28,
+	0x07, 0xD0, 0x98, 0xF8,
+	0x3E, 0x01, 0x05, 0x28, 0x03, 0xD1, 0x29, 0x46, 0x30, 0x46, 0xFF, 0xF7,
+	0x28, 0xFF, 0x6D, 0x1C,
+	0x94, 0xF9, 0xF4, 0x03, 0xA8, 0x42, 0xE1, 0xDA, 0x00, 0x25, 0x1B, 0xE0,
+	0x05, 0xEB, 0x05, 0x10,
+	0x00, 0xEB, 0x80, 0x00, 0x06, 0xEB, 0x80, 0x08, 0xD4, 0xF8, 0xEC, 0x03,
+	0x07, 0xFA, 0x05, 0xF1,
+	0x08, 0x42, 0x0E, 0xD0, 0x40, 0x46, 0x00, 0xF0, 0xA6, 0xF9, 0x01, 0x28,
+	0x09, 0xD0, 0x40, 0x46,
+	0x00, 0xF0, 0xAF, 0xF9, 0x01, 0x28, 0x04, 0xD1, 0x6A, 0x46, 0x29, 0x46,
+	0x30, 0x46, 0xFF, 0xF7,
+	0x6C, 0xFE, 0x6D, 0x1C, 0x94, 0xF9, 0xF4, 0x03, 0xA8, 0x42, 0xDF, 0xDA,
+	0x00, 0x25, 0xB8, 0x46,
+	0x21, 0xE0, 0x00, 0xBF, 0x05, 0xEB, 0x05, 0x10, 0x00, 0xEB, 0x80, 0x00,
+	0x06, 0xEB, 0x80, 0x07,
+	0xD4, 0xF8, 0xEC, 0x13, 0x08, 0xFA, 0x05, 0xF0, 0x01, 0x42, 0x13, 0xD0,
+	0x38, 0x46, 0x00, 0xF0,
+	0x82, 0xF9, 0x01, 0x28, 0x0E, 0xD0, 0x38, 0x46, 0x00, 0xF0, 0x85, 0xF9,
+	0x01, 0x28, 0x04, 0xD1,
+	0x6A, 0x46, 0x29, 0x46, 0x30, 0x46, 0xFF, 0xF7, 0x48, 0xFE, 0x37, 0xF8,
+	0x42, 0x0F, 0x20, 0xF0,
+	0x20, 0x00, 0x38, 0x80, 0x6D, 0x1C, 0x94, 0xF9, 0xF4, 0x03, 0xA8, 0x42,
+	0xDA, 0xDA, 0x9D, 0xF8,
+	0x00, 0x00, 0x40, 0x1C, 0x84, 0xF8, 0xE0, 0x04, 0xBD, 0xE8, 0xF8, 0x83,
+	0x10, 0xB5, 0x04, 0x46,
+	0x87, 0x48, 0x03, 0x21, 0x08, 0x30, 0x05, 0xF0, 0xD2, 0xFB, 0x85, 0x48,
+	0x1E, 0x21, 0x80, 0x68,
+	0x0B, 0xF0, 0xD2, 0xFF, 0x41, 0xF2, 0x68, 0x40, 0x7C, 0x21, 0x20, 0x44,
+	0x0B, 0xF0, 0xEE, 0xFF,
+	0x80, 0x48, 0x02, 0x68, 0x80, 0x48, 0xB2, 0xF8, 0x96, 0x13, 0x00, 0x78,
+	0x49, 0x43, 0x10, 0xB1,
+	0xB2, 0xF8, 0x6C, 0x13, 0x49, 0x43, 0xB2, 0xF8, 0x98, 0x23, 0x02, 0xFB,
+	0x02, 0x10, 0x78, 0x4A,
+	0x11, 0x60, 0x11, 0x1D, 0x08, 0x60, 0x20, 0x46, 0xFF, 0xF7, 0x5C, 0xFF,
+	0x20, 0x46, 0xFF, 0xF7,
+	0x3B, 0xFD, 0x73, 0x48, 0x03, 0x21, 0xBD, 0xE8, 0x10, 0x40, 0x08, 0x30,
+	0x05, 0xF0, 0xC4, 0xBB,
+	0xF0, 0xB4, 0x84, 0x6B, 0xC2, 0x68, 0x8B, 0x6B, 0xCE, 0x68, 0x17, 0x14,
+	0x67, 0x43, 0x4F, 0xEA,
+	0x26, 0x4C, 0x03, 0xFB, 0x0C, 0x77, 0xE5, 0x18, 0x97, 0xFB, 0xF5, 0xF7,
+	0x67, 0xF3, 0x1F, 0x42,
+	0x17, 0xB2, 0x67, 0x43, 0x34, 0xB2, 0x03, 0xFB, 0x04, 0x73, 0x93, 0xFB,
+	0xF5, 0xF3, 0x63, 0xF3,
+	0x0F, 0x02, 0xC2, 0x60, 0xF0, 0xBC, 0xDF, 0xE4, 0x62, 0x4A, 0x12, 0x68,
+	0x92, 0xF8, 0x40, 0x24,
+	0x92, 0x06, 0x11, 0xD5, 0x90, 0xF8, 0x49, 0x31, 0x23, 0xB1, 0x91, 0xF8,
+	0x49, 0x21, 0x0A, 0xB1,
+	0x93, 0x42, 0x07, 0xD1, 0x90, 0xF8, 0x4A, 0x01, 0x30, 0xB1, 0x91, 0xF8,
+	0x4A, 0x11, 0x19, 0xB1,
+	0x88, 0x42, 0x01, 0xD0, 0x00, 0x20, 0x70, 0x47, 0x01, 0x20, 0x70, 0x47,
+	0x2D, 0xE9, 0xFE, 0x4F,
+	0x00, 0xF5, 0x80, 0x54, 0x05, 0x46, 0xD4, 0xF8, 0xF8, 0x13, 0xD4, 0xF8,
+	0xEC, 0x03, 0x01, 0x40,
+	0x00, 0x28, 0xC4, 0xF8, 0xF8, 0x13, 0x4F, 0xF0, 0x00, 0x00, 0x0C, 0xD0,
+	0x81, 0x46, 0x0F, 0x21,
+	0x4E, 0x48, 0x0B, 0xF0, 0x61, 0xFF, 0x00, 0x26, 0xDF, 0xF8, 0x30, 0xA1,
+	0x4F, 0xF0, 0x01, 0x08,
+	0x41, 0xF2, 0xFC, 0x3B, 0x5A, 0xE0, 0xC4, 0xF8, 0xF8, 0x03, 0xBD, 0xE8,
+	0xFE, 0x8F, 0xD4, 0xF8,
+	0xEC, 0x23, 0x08, 0xFA, 0x06, 0xF1, 0x40, 0x46, 0x0A, 0x42, 0x4E, 0xD0,
+	0x06, 0xEB, 0x06, 0x12,
+	0x02, 0xEB, 0x82, 0x02, 0x05, 0xEB, 0x82, 0x07, 0x97, 0xF8, 0x40, 0x20,
+	0x12, 0x06, 0xD4, 0xF8,
+	0xF8, 0x23, 0x11, 0xD5, 0x0A, 0x43, 0x05, 0xEB, 0x86, 0x01, 0xC4, 0xF8,
+	0xF8, 0x23, 0x01, 0xF5,
+	0x9C, 0x51, 0xD7, 0xF8, 0x5A, 0x20, 0xCA, 0x67, 0x97, 0xF8, 0x46, 0x11,
+	0x88, 0x40, 0x40, 0xEA,
+	0x09, 0x09, 0x0A, 0xF8, 0x01, 0x60, 0x30, 0xE0, 0x0A, 0x42, 0x2E, 0xD0,
+	0x97, 0xF8, 0x3E, 0x21,
+	0x06, 0x2A, 0x14, 0xD0, 0x05, 0x2A, 0x12, 0xD0, 0x97, 0xF8, 0x46, 0x11,
+	0x08, 0xFA, 0x01, 0xF0,
+	0x40, 0xEA, 0x09, 0x09, 0x0A, 0xF8, 0x01, 0x60, 0x05, 0xEB, 0x86, 0x01,
+	0x01, 0xEB, 0x0B, 0x00,
+	0x5A, 0x37, 0x39, 0x46, 0x00, 0x90, 0x03, 0xF0, 0x8F, 0xFB, 0x98, 0xB1,
+	0x15, 0xE0, 0xB7, 0xF8,
+	0x42, 0x00, 0x20, 0xF0, 0x08, 0x00, 0xA7, 0xF8, 0x42, 0x00, 0xD4, 0xF8,
+	0xF8, 0x03, 0x88, 0x43,
+	0xC4, 0xF8, 0xF8, 0x03, 0x22, 0x49, 0x05, 0xEB, 0x86, 0x00, 0x00, 0xF5,
+	0x9C, 0x50, 0x09, 0x68,
+	0xC1, 0x67, 0xE1, 0xE7, 0x00, 0x98, 0x39, 0x68, 0x01, 0x60, 0x76, 0x1C,
+	0x94, 0xF9, 0xF4, 0x03,
+	0xB0, 0x42, 0xA4, 0xDA, 0x00, 0x27, 0x72, 0xE0, 0xD4, 0xF8, 0xEC, 0x23,
+	0x08, 0xFA, 0x07, 0xF1,
+	0x0A, 0x42, 0x6B, 0xD0, 0xD4, 0xF8, 0xF8, 0x23, 0x0A, 0x42, 0x67, 0xD1,
+	0x07, 0xEB, 0x07, 0x11,
+	0x01, 0xEB, 0x81, 0x01, 0x05, 0xEB, 0x81, 0x01, 0x00, 0x91, 0x91, 0xF8,
+	0x3E, 0x11, 0x02, 0x29,
+	0x01, 0xD0, 0x01, 0x29, 0x5A, 0xD1, 0x00, 0x99, 0x43, 0x46, 0x91, 0xF8,
+	0x46, 0x11, 0x08, 0xFA,
+	0x01, 0xF0, 0x10, 0xEA, 0x09, 0x0F, 0x23, 0xD0, 0x1A, 0xF8, 0x01, 0x00,
+	0xB8, 0x42, 0x4D, 0xD0,
+	0x00, 0xEB, 0x00, 0x10, 0x00, 0xEB, 0x80, 0x00, 0x05, 0xEB, 0x80, 0x00,
+	0x06, 0x46, 0x09, 0xE0,
+	0x08, 0x06, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00, 0xFD, 0x06, 0x10, 0x00,
+	0x80, 0x2C, 0x10, 0x00,
+	0x36, 0x7A, 0x01, 0x00, 0x00, 0x99, 0xFF, 0xF7, 0x2F, 0xFF, 0x01, 0x28,
+	0x36, 0xD1, 0x30, 0x46,
+	0x00, 0x99, 0xFF, 0xF7, 0x0D, 0xFF, 0x28, 0x46, 0x00, 0x99, 0x00, 0xF0,
+	0xF7, 0xFD, 0x2D, 0xE0,
+	0x00, 0x98, 0x98, 0x46, 0x5A, 0x30, 0x00, 0x26, 0x02, 0x90, 0x23, 0xE0,
+	0xD4, 0xF8, 0xF8, 0x13,
+	0x08, 0xFA, 0x06, 0xF0, 0x01, 0x42, 0x1C, 0xD0, 0x06, 0xEB, 0x06, 0x10,
+	0x00, 0xEB, 0x80, 0x00,
+	0x05, 0xEB, 0x80, 0x00, 0x05, 0xEB, 0x86, 0x01, 0x01, 0x90, 0x59, 0x44,
+	0x02, 0x98, 0x03, 0xF0,
+	0x13, 0xFB, 0x01, 0x28, 0x0D, 0xD1, 0xDD, 0xE9, 0x00, 0x10, 0xFF, 0xF7,
+	0x05, 0xFF, 0x01, 0x28,
+	0x07, 0xD1, 0xDD, 0xE9, 0x00, 0x10, 0xFF, 0xF7, 0xE3, 0xFE, 0x28, 0x46,
+	0x00, 0x99, 0x00, 0xF0,
+	0xCD, 0xFD, 0x76, 0x1C, 0x94, 0xF9, 0xF4, 0x03, 0xB0, 0x42, 0xD7, 0xDA,
+	0x7F, 0x1C, 0x94, 0xF9,
+	0xF4, 0x03, 0xB8, 0x42, 0x88, 0xDA, 0x28, 0xE7, 0x33, 0x49, 0x00, 0x20,
+	0x88, 0x60, 0x0F, 0x21,
+	0x32, 0x48, 0x0B, 0xF0, 0x79, 0xBE, 0x90, 0xF8, 0x42, 0x00, 0x40, 0x07,
+	0x01, 0xD5, 0x01, 0x20,
+	0x70, 0x47, 0x00, 0x20, 0x70, 0x47, 0x90, 0xF8, 0x3E, 0x01, 0x01, 0x28,
+	0x00, 0xD0, 0x00, 0x20,
+	0x70, 0x47, 0x90, 0xF8, 0x3E, 0x01, 0x02, 0x28, 0x05, 0xD0, 0x03, 0x28,
+	0x03, 0xD0, 0x04, 0x28,
+	0x01, 0xD0, 0x00, 0x20, 0x70, 0x47, 0x01, 0x20, 0x70, 0x47, 0x10, 0xB5,
+	0x90, 0xF8, 0x42, 0x10,
+	0x49, 0x06, 0x03, 0xD5, 0xFF, 0xF7, 0xED, 0xFF, 0x01, 0x28, 0x00, 0xD0,
+	0x00, 0x20, 0x10, 0xBD,
+	0x91, 0xF8, 0x3E, 0x21, 0x01, 0x2A, 0x08, 0xD0, 0x02, 0x2A, 0x06, 0xD0,
+	0x06, 0x20, 0x81, 0xF8,
+	0x3E, 0x01, 0x00, 0x20, 0x81, 0xF8, 0x43, 0x01, 0x70, 0x47, 0x00, 0xF0,
+	0x87, 0xBD, 0xF0, 0xB5,
+	0x91, 0xF9, 0x4B, 0x61, 0x93, 0xF9, 0x00, 0x40, 0x92, 0xF9, 0x4B, 0x51,
+	0x77, 0x1C, 0x02, 0xD0,
+	0x6D, 0x1C, 0x15, 0xD0, 0x0B, 0xE0, 0x6E, 0x1C, 0x0B, 0xD0, 0x00, 0xEB,
+	0x85, 0x02, 0x00, 0xEB,
+	0x84, 0x00, 0xD2, 0x6B, 0xC2, 0xF8, 0x50, 0x11, 0xC1, 0x63, 0x81, 0xF8,
+	0x4B, 0x41, 0x1C, 0x70,
+	0xF0, 0xBD, 0x64, 0x1C, 0x64, 0xB2, 0x40, 0xF8, 0x24, 0x10, 0x81, 0xF8,
+	0x4B, 0x41, 0x02, 0xE0,
+	0x00, 0xEB, 0x86, 0x01, 0xC9, 0x6B, 0x00, 0xEB, 0x84, 0x00, 0xC1, 0xF8,
+	0x50, 0x21, 0xC2, 0x63,
+	0x82, 0xF8, 0x4B, 0x41, 0xEB, 0xE7, 0x00, 0x00, 0x08, 0x06, 0x10, 0x00,
+	0x80, 0x2C, 0x10, 0x00,
+	0xF0, 0xB5, 0x44, 0x88, 0x4E, 0x88, 0x01, 0x25, 0xA4, 0x1B, 0x24, 0xB2,
+	0x00, 0x2C, 0x01, 0xDB,
+	0x26, 0x46, 0x00, 0xE0, 0x66, 0x42, 0x5E, 0x80, 0x56, 0x42, 0x94, 0x42,
+	0x02, 0xDD, 0x44, 0x88,
+	0xA4, 0x1A, 0x03, 0xE0, 0xB4, 0x42, 0x03, 0xDA, 0x44, 0x88, 0x14, 0x44,
+	0x4C, 0x80, 0x00, 0x25,
+	0x04, 0x88, 0x0F, 0x88, 0xE4, 0x1B, 0x24, 0xB2, 0x00, 0x2C, 0x01, 0xDB,
+	0x27, 0x46, 0x00, 0xE0,
+	0x67, 0x42, 0x1F, 0x80, 0x94, 0x42, 0x02, 0xDD, 0x00, 0x88, 0x80, 0x1A,
+	0x03, 0xE0, 0xB4, 0x42,
+	0x03, 0xDA, 0x00, 0x88, 0x10, 0x44, 0x08, 0x80, 0x00, 0x25, 0x28, 0x46,
+	0xF0, 0xBD, 0x2D, 0xE9,
+	0xF0, 0x41, 0x96, 0x4D, 0x0F, 0x46, 0x06, 0x46, 0x81, 0x89, 0x28, 0x68,
+	0x90, 0x46, 0xF9, 0xB1,
+	0x90, 0xF8, 0xC7, 0x43, 0x0B, 0xF0, 0xA8, 0xFE, 0x18, 0xB1, 0x28, 0x68,
+	0x90, 0xF8, 0xC9, 0x43,
+	0x12, 0xE0, 0xB0, 0x7D, 0x02, 0x28, 0x04, 0xD0, 0x01, 0x28, 0x06, 0xD0,
+	0x03, 0x28, 0x08, 0xD0,
+	0x0A, 0xE0, 0x28, 0x68, 0x90, 0xF8, 0xCE, 0x43, 0x06, 0xE0, 0x28, 0x68,
+	0x90, 0xF8, 0x51, 0x44,
+	0x02, 0xE0, 0x28, 0x68, 0x90, 0xF8, 0x2C, 0x44, 0xB0, 0x89, 0x40, 0x1E,
+	0xB0, 0x81, 0x11, 0xE0,
+	0xB1, 0x7D, 0x90, 0xF8, 0xCB, 0x43, 0x02, 0x29, 0x04, 0xD0, 0x01, 0x29,
+	0x05, 0xD0, 0x03, 0x29,
+	0x06, 0xD0, 0x07, 0xE0, 0x90, 0xF8, 0xCE, 0x43, 0x04, 0xE0, 0x90, 0xF8,
+	0x52, 0x44, 0x01, 0xE0,
+	0x90, 0xF8, 0x2D, 0x44, 0x29, 0x68, 0xB2, 0x7D, 0x91, 0xF8, 0xCA, 0x03,
+	0x02, 0x2A, 0x04, 0xD0,
+	0x01, 0x2A, 0x05, 0xD0, 0x03, 0x2A, 0x06, 0xD0, 0x07, 0xE0, 0x91, 0xF8,
+	0xCD, 0x03, 0x04, 0xE0,
+	0x91, 0xF8, 0x53, 0x04, 0x01, 0xE0, 0x91, 0xF8, 0x2E, 0x04, 0x38, 0x80,
+	0xA8, 0xF8, 0x00, 0x40,
+	0xBD, 0xE8, 0xF0, 0x81, 0x2D, 0xE9, 0xF0, 0x4F, 0x00, 0xF1, 0x5E, 0x04,
+	0x85, 0xB0, 0x4F, 0xF0,
+	0x00, 0x0B, 0x84, 0xF8, 0x15, 0xB0, 0xDF, 0xF8, 0xA4, 0x91, 0x0E, 0x46,
+	0x80, 0xF8, 0x74, 0xB0,
+	0x05, 0x46, 0xB0, 0xF8, 0x42, 0x10, 0x4F, 0xF0, 0x01, 0x08, 0xD9, 0xF8,
+	0x00, 0x00, 0x4A, 0x06,
+	0xC2, 0x46, 0x01, 0xD5, 0x02, 0x21, 0x0F, 0xE0, 0x0A, 0x07, 0x06, 0xD5,
+	0x90, 0xF8, 0x40, 0x24,
+	0x52, 0x06, 0x02, 0xD5, 0x84, 0xF8, 0x16, 0xA0, 0x07, 0xE0, 0x90, 0xF8,
+	0x20, 0x24, 0x92, 0x07,
+	0x03, 0xD5, 0x09, 0x06, 0x01, 0xD5, 0x03, 0x21, 0xA1, 0x75, 0x95, 0xF8,
+	0x3E, 0x11, 0x03, 0x29,
+	0x09, 0xD0, 0xA2, 0x7C, 0x01, 0x2A, 0x06, 0xD0, 0x04, 0x29, 0x2D, 0xD0,
+	0x07, 0x29, 0x2B, 0xD0,
+	0x08, 0x29, 0x76, 0xD0, 0x9C, 0xE0, 0x90, 0xF8, 0xC6, 0x73, 0x0B, 0xF0,
+	0x25, 0xFE, 0x18, 0xB1,
+	0xD9, 0xF8, 0x00, 0x00, 0x90, 0xF8, 0xC8, 0x73, 0x95, 0xF8, 0x3E, 0x01,
+	0x03, 0x28, 0x00, 0xD0,
+	0x00, 0x27, 0xA0, 0x7D, 0x01, 0x28, 0x02, 0xD0, 0x03, 0x28, 0x05, 0xD0,
+	0x08, 0xE0, 0xD9, 0xF8,
+	0x00, 0x00, 0x90, 0xF8, 0x50, 0x74, 0x03, 0xE0, 0xD9, 0xF8, 0x00, 0x00,
+	0x90, 0xF8, 0x2B, 0x74,
+	0xA7, 0x81, 0x31, 0x68, 0x21, 0x60, 0x31, 0x68, 0x61, 0x60, 0x84, 0xF8,
+	0x14, 0xA0, 0x84, 0xF8,
+	0x13, 0xA0, 0x84, 0xF8, 0x12, 0xB0, 0x73, 0xE0, 0x02, 0xAA, 0x01, 0xA9,
+	0x20, 0x46, 0xFF, 0xF7,
+	0x46, 0xFF, 0x03, 0xAB, 0xBD, 0xF9, 0x08, 0x20, 0x21, 0x46, 0x30, 0x46,
+	0xFF, 0xF7, 0x10, 0xFF,
+	0x83, 0x46, 0x04, 0xAB, 0xBD, 0xF9, 0x04, 0x20, 0x21, 0x1D, 0x30, 0x46,
+	0xFF, 0xF7, 0x08, 0xFF,
+	0x07, 0x46, 0xBB, 0xF1, 0x01, 0x0F, 0x03, 0xD0, 0x20, 0x7D, 0x01, 0x28,
+	0x4D, 0xD0, 0x4E, 0xE0,
+	0xBD, 0xF9, 0x0C, 0x00, 0xBD, 0xF9, 0x0E, 0x10, 0x81, 0x42, 0x00, 0xDD,
+	0x08, 0x46, 0xD9, 0xF8,
+	0x00, 0x10, 0x91, 0xF8, 0xCC, 0x23, 0x02, 0xF0, 0x0F, 0x03, 0x4F, 0xEA,
+	0x12, 0x1C, 0xA2, 0x7D,
+	0x02, 0x2A, 0x04, 0xD0, 0x01, 0x2A, 0x05, 0xD0, 0x03, 0x2A, 0x06, 0xD0,
+	0x0B, 0xE0, 0x91, 0xF8,
+	0xCF, 0x13, 0x04, 0xE0, 0x91, 0xF8, 0x54, 0x14, 0x01, 0xE0, 0x91, 0xF8,
+	0x2F, 0x14, 0x01, 0xF0,
+	0x0F, 0x03, 0x4F, 0xEA, 0x11, 0x1C, 0x01, 0x2F, 0x0C, 0xD0, 0xCD, 0xF8,
+	0x00, 0xC0, 0xBD, 0xF9,
+	0x08, 0x20, 0xBD, 0xF9, 0x04, 0x10, 0x07, 0xF0, 0xDC, 0xFD, 0x21, 0x7D,
+	0x01, 0x29, 0x0D, 0xD0,
+	0x18, 0xE0, 0x23, 0xE0, 0xA0, 0x68, 0x30, 0x60, 0xD9, 0xF8, 0x00, 0x00,
+	0x90, 0xF8, 0x80, 0x03,
+	0x00, 0x06, 0x01, 0xD4, 0x4F, 0xF0, 0x00, 0x08, 0x60, 0x46, 0xEE, 0xE7,
+	0x95, 0xF8, 0x41, 0x11,
+	0x41, 0xB9, 0xD9, 0xF8, 0x00, 0x10, 0x91, 0xF8, 0xBC, 0x13, 0x0A, 0x09,
+	0xD4, 0xF8, 0x0E, 0x10,
+	0x07, 0xF0, 0xD4, 0xFD, 0xC4, 0xF8, 0x0E, 0x00, 0x01, 0xE0, 0x84, 0xF8,
+	0x15, 0xA0, 0x84, 0xF8,
+	0x14, 0xB0, 0xE7, 0x74, 0xB8, 0xF1, 0x00, 0x0F, 0x02, 0xD1, 0x03, 0xE0,
+	0xA0, 0x68, 0x30, 0x60,
+	0x30, 0x68, 0xA0, 0x60, 0x05, 0xB0, 0x40, 0x46, 0xBD, 0xE8, 0xF0, 0x8F,
+	0x4C, 0x07, 0x10, 0x00,
+	0x2D, 0xE9, 0xF0, 0x41, 0x17, 0x46, 0x06, 0x46, 0xDD, 0xE9, 0x06, 0xC2,
+	0xC8, 0x78, 0x00, 0x25,
+	0x0C, 0x46, 0x03, 0x28, 0x30, 0xD2, 0xFE, 0x48, 0xDF, 0xF8, 0xF8, 0xE3,
+	0x01, 0x68, 0x91, 0xF8,
+	0x0A, 0x14, 0xA1, 0x70, 0xDE, 0xF8, 0x04, 0xE0, 0xBE, 0xF1, 0x00, 0x0F,
+	0x06, 0xDD, 0xD0, 0xF8,
+	0x00, 0xE0, 0x9E, 0xF8, 0x0B, 0xE4, 0xA1, 0xEB, 0x0E, 0x01, 0xA1, 0x70,
+	0x00, 0x68, 0x71, 0x6B,
+	0xB0, 0xF8, 0x0C, 0x04, 0x81, 0x42, 0x15, 0xDD, 0xDB, 0xB2, 0x39, 0x46,
+	0x60, 0x46, 0x00, 0xF0,
+	0xE8, 0xFA, 0xE0, 0x78, 0x40, 0x1C, 0xC0, 0xB2, 0xE0, 0x70, 0x03, 0x28,
+	0x06, 0xD0, 0xEE, 0x49,
+	0xB6, 0xF9, 0x56, 0x00, 0xB1, 0xF9, 0x00, 0x10, 0x88, 0x42, 0x05, 0xDD,
+	0x03, 0x20, 0xE0, 0x70,
+	0x01, 0x25, 0x01, 0xE0, 0x00, 0x20, 0xE0, 0x70, 0x28, 0x46, 0xBD, 0xE8,
+	0xF0, 0x81, 0x2D, 0xE9,
+	0xFC, 0x5F, 0x4F, 0xF0, 0x00, 0x0B, 0x0C, 0x46, 0x81, 0x46, 0x5D, 0x46,
+	0x4F, 0xF0, 0x02, 0x0A,
+	0x01, 0x26, 0x00, 0xF5, 0x80, 0x57, 0x7C, 0xE0, 0xD7, 0xF8, 0xEC, 0x03,
+	0x06, 0xFA, 0x05, 0xFE,
+	0x10, 0xEA, 0x0E, 0x0F, 0x74, 0xD0, 0x05, 0xEB, 0x05, 0x10, 0x00, 0xEB,
+	0x80, 0x01, 0x09, 0xEB,
+	0x81, 0x00, 0x00, 0xF5, 0x9A, 0x71, 0x90, 0xF8, 0x3E, 0x81, 0xB0, 0xF9,
+	0x0E, 0xC0, 0xB8, 0xF1,
+	0x01, 0x0F, 0x0F, 0xD0, 0xB8, 0xF1, 0x02, 0x0F, 0x0C, 0xD0, 0x90, 0xF8,
+	0x42, 0x00, 0x40, 0x07,
+	0x51, 0xD5, 0xD2, 0x48, 0xEB, 0xB2, 0x61, 0x46, 0xB0, 0xF9, 0x08, 0x20,
+	0x20, 0x46, 0x00, 0xF0,
+	0xA0, 0xFA, 0x55, 0xE0, 0xCE, 0x4B, 0xB0, 0xF9, 0x54, 0x20, 0xB3, 0xF9,
+	0x00, 0x30, 0x9A, 0x42,
+	0x4E, 0xDB, 0xB8, 0xF1, 0x01, 0x0F, 0x03, 0xD1, 0x00, 0x22, 0x0A, 0x60,
+	0x4A, 0x60, 0x0A, 0x81,
+	0xC6, 0x4A, 0xB2, 0xF9, 0x00, 0x30, 0x63, 0x45, 0x03, 0xDC, 0xB2, 0xF9,
+	0x02, 0x30, 0x63, 0x45,
+	0x0C, 0xDA, 0xB0, 0xF8, 0x42, 0x30, 0x43, 0xF0, 0x04, 0x03, 0xA0, 0xF8,
+	0x42, 0x30, 0xC3, 0x68,
+	0x4B, 0x60, 0x81, 0xF8, 0x08, 0xA0, 0xB2, 0xF9, 0x00, 0x20, 0x19, 0xE0,
+	0xB2, 0xF9, 0x08, 0x30,
+	0x63, 0x45, 0x03, 0xDC, 0xB2, 0xF9, 0x0A, 0x30, 0x63, 0x45, 0x19, 0xDA,
+	0xB0, 0xF8, 0x42, 0x30,
+	0x43, 0xF0, 0x04, 0x03, 0xA0, 0xF8, 0x42, 0x30, 0x90, 0xF8, 0x3E, 0x31,
+	0x01, 0x2B, 0x02, 0xD0,
+	0x0B, 0x7A, 0x02, 0x2B, 0x01, 0xD1, 0xC3, 0x68, 0x4B, 0x60, 0x0E, 0x72,
+	0xB2, 0xF9, 0x08, 0x20,
+	0x2B, 0x46, 0xCD, 0xE9, 0x00, 0x42, 0x62, 0x46, 0xFF, 0xF7, 0x4A, 0xFF,
+	0x83, 0x46, 0x0F, 0xE0,
+	0x00, 0x20, 0x08, 0x72, 0x08, 0xE0, 0xA9, 0x48, 0xB0, 0xF9, 0x08, 0x10,
+	0x61, 0x45, 0x07, 0xDA,
+	0xB0, 0xF9, 0x0A, 0x00, 0x60, 0x45, 0x03, 0xDD, 0xA0, 0x68, 0x40, 0xEA,
+	0x0E, 0x00, 0xA0, 0x60,
+	0x6D, 0x1C, 0x97, 0xF9, 0xF4, 0x03, 0xA8, 0x42, 0xBF, 0xF4, 0x7E, 0xAF,
+	0x20, 0x68, 0x61, 0x68,
+	0x9C, 0x4A, 0x50, 0xEA, 0x01, 0x03, 0xA3, 0x68, 0x01, 0xD0, 0x23, 0xB1,
+	0x04, 0xE0, 0x1B, 0xB1,
+	0x82, 0xF8, 0x00, 0xA0, 0x00, 0xE0, 0x16, 0x70, 0x98, 0x4A, 0x18, 0x32,
+	0x13, 0x68, 0x98, 0x43,
+	0x20, 0x60, 0x50, 0x68, 0x81, 0x43, 0x61, 0x60, 0x96, 0x49, 0xA0, 0x68,
+	0x09, 0x78, 0x08, 0x43,
+	0x05, 0xD1, 0x92, 0x49, 0x18, 0x22, 0x18, 0x39, 0x90, 0x48, 0x0B, 0xF0,
+	0x8B, 0xFB, 0x58, 0x46,
+	0xBD, 0xE8, 0xFC, 0x9F, 0x8B, 0x4A, 0x10, 0xB5, 0x12, 0x78, 0x00, 0x21,
+	0x01, 0x2A, 0x01, 0xD1,
+	0x03, 0xB1, 0x01, 0x21, 0x90, 0xF8, 0x3E, 0x21, 0x04, 0x2A, 0x18, 0xD1,
+	0x84, 0x4A, 0x12, 0x68,
+	0x92, 0xF8, 0x00, 0x34, 0x5B, 0x07, 0x12, 0xD5, 0xB0, 0xF8, 0x4A, 0x30,
+	0xB0, 0xF8, 0x4C, 0x40,
+	0x1B, 0x1B, 0x82, 0x4C, 0xA4, 0x8A, 0xA3, 0x42, 0x09, 0xDD, 0x90, 0xF8,
+	0x5B, 0x30, 0x90, 0xF8,
+	0x5A, 0x00, 0x92, 0xF8, 0x09, 0x24, 0x18, 0x1A, 0x90, 0x42, 0x00, 0xDD,
+	0x01, 0x21, 0x08, 0x46,
+	0x10, 0xBD, 0x30, 0xB5, 0x79, 0x4D, 0x00, 0x24, 0x18, 0x35, 0x09, 0xB1,
+	0x29, 0x68, 0x11, 0xB9,
+	0x12, 0xB1, 0x69, 0x68, 0x01, 0xB1, 0x01, 0x24, 0x72, 0x49, 0x09, 0x78,
+	0x01, 0x29, 0x01, 0xD1,
+	0x03, 0xB1, 0x01, 0x24, 0x6E, 0x49, 0x09, 0x68, 0x91, 0xF8, 0x00, 0x24,
+	0x52, 0x07, 0x16, 0xD5,
+	0x90, 0xF8, 0x3E, 0x21, 0x04, 0x2A, 0x12, 0xD1, 0xB0, 0xF8, 0x4A, 0x20,
+	0xB0, 0xF8, 0x4C, 0x30,
+	0xD2, 0x1A, 0x6A, 0x4B, 0x9B, 0x8A, 0x9A, 0x42, 0x09, 0xDD, 0x90, 0xF8,
+	0x5B, 0x20, 0x90, 0xF8,
+	0x5A, 0x00, 0x91, 0xF8, 0x09, 0x14, 0x10, 0x1A, 0x88, 0x42, 0x00, 0xDD,
+	0x01, 0x24, 0x20, 0x46,
+	0x30, 0xBD, 0x2D, 0xE9, 0xF3, 0x4F, 0x8D, 0xB0, 0x5E, 0x48, 0x00, 0x25,
+	0x8B, 0x46, 0x0A, 0x95,
+	0x01, 0x78, 0x5E, 0x48, 0x18, 0x38, 0x01, 0x29, 0x06, 0xD1, 0xDB, 0xF8,
+	0x08, 0x10, 0x19, 0xB1,
+	0xD0, 0xF8, 0x1C, 0x80, 0x47, 0x6A, 0x02, 0xE0, 0xD0, 0xF8, 0x18, 0x80,
+	0x07, 0x6A, 0x0D, 0x9E,
+	0x00, 0x24, 0x4F, 0xF0, 0x01, 0x09, 0x06, 0xF5, 0x80, 0x56, 0x0F, 0xE1,
+	0x09, 0xFA, 0x04, 0xF0,
+	0xD6, 0xF8, 0xEC, 0x13, 0x0B, 0x90, 0x01, 0x42, 0x1A, 0xD0, 0x04, 0xEB,
+	0x04, 0x10, 0x00, 0xEB,
+	0x80, 0x01, 0x0D, 0x98, 0x00, 0xEB, 0x81, 0x0A, 0x9A, 0xF8, 0x42, 0x00,
+	0x40, 0x07, 0x0F, 0xD5,
+	0x0A, 0xF5, 0x9A, 0x70, 0x01, 0x90, 0xBA, 0xF9, 0x0E, 0x00, 0x02, 0x90,
+	0x9A, 0xF8, 0x3E, 0x01,
+	0x01, 0x28, 0x06, 0xD0, 0x02, 0x28, 0x04, 0xD0, 0x04, 0x28, 0x1F, 0xD0,
+	0x05, 0x28, 0x7D, 0xD0,
+	0xEB, 0xE0, 0xDB, 0xF8, 0x00, 0x10, 0xDB, 0xF8, 0x04, 0x20, 0xDB, 0xF8,
+	0x08, 0x30, 0x50, 0x46,
+	0xFF, 0xF7, 0x60, 0xFF, 0x01, 0x28, 0x02, 0xD1, 0x01, 0x99, 0x81, 0xF8,
+	0x01, 0x90, 0xDB, 0xF8,
+	0x00, 0x10, 0xDB, 0xF8, 0x04, 0x20, 0xDB, 0xF8, 0x08, 0x30, 0x50, 0x46,
+	0xFF, 0xF7, 0x79, 0xFF,
+	0x01, 0x28, 0xE5, 0xD1, 0x01, 0x99, 0x00, 0x20, 0x88, 0x70, 0xCE, 0xE0,
+	0xDB, 0xF8, 0x00, 0x10,
+	0xDB, 0xF8, 0x04, 0x20, 0xDB, 0xF8, 0x08, 0x30, 0x50, 0x46, 0xFF, 0xF7,
+	0x6A, 0xFF, 0x01, 0x28,
+	0x09, 0xD0, 0x01, 0x98, 0x80, 0x78, 0x48, 0xB1, 0x01, 0x99, 0x40, 0x1E,
+	0x10, 0xF0, 0xFF, 0x00,
+	0x88, 0x70, 0x03, 0xD0, 0x07, 0xE0, 0x01, 0x99, 0x00, 0x20, 0x88, 0x70,
+	0x9A, 0xF8, 0x48, 0x11,
+	0x09, 0xFA, 0x01, 0xF0, 0x05, 0x43, 0xDB, 0xF8, 0x00, 0x10, 0xDB, 0xF8,
+	0x04, 0x20, 0xDB, 0xF8,
+	0x08, 0x30, 0x50, 0x46, 0xFF, 0xF7, 0x26, 0xFF, 0x01, 0x28, 0x02, 0xD1,
+	0x01, 0x99, 0x81, 0xF8,
+	0x01, 0x90, 0x01, 0x98, 0xC0, 0x78, 0x03, 0x28, 0x1D, 0xD2, 0x01, 0x99,
+	0x89, 0x78, 0xD1, 0xB1,
+	0x17, 0x49, 0xDA, 0xF8, 0x34, 0x20, 0x09, 0x68, 0xB1, 0xF8, 0x0C, 0x14,
+	0x8A, 0x42, 0x0F, 0xDD,
+	0x40, 0x1C, 0x01, 0x99, 0xC0, 0xB2, 0x03, 0x28, 0xC8, 0x70, 0x06, 0xD0,
+	0x12, 0x49, 0xBA, 0xF9,
+	0x56, 0x00, 0xB1, 0xF9, 0x00, 0x10, 0x88, 0x42, 0x05, 0xDD, 0x01, 0x20,
+	0x0A, 0x90, 0x02, 0xE0,
+	0x01, 0x99, 0x00, 0x20, 0xC8, 0x70, 0x02, 0x98, 0x0F, 0xFA, 0x88, 0xF2,
+	0x82, 0x42, 0x04, 0xDC,
+	0x02, 0x98, 0x4F, 0xEA, 0x28, 0x41, 0x81, 0x42, 0x16, 0xDA, 0x01, 0x98,
+	0x02, 0x21, 0xE3, 0xB2,
+	0x01, 0x72, 0x01, 0x98, 0xDA, 0xF8, 0x0C, 0x10, 0x41, 0x60, 0x37, 0xE0,
+	0x56, 0xE0, 0x00, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x14, 0x06, 0x10, 0x00, 0x8C, 0x06, 0x10, 0x00,
+	0xA8, 0x2C, 0x10, 0x00,
+	0xA0, 0x06, 0x10, 0x00, 0x20, 0x07, 0x10, 0x00, 0x38, 0xB2, 0x02, 0x99,
+	0x04, 0x90, 0x88, 0x42,
+	0x03, 0xDC, 0x02, 0x98, 0x39, 0x14, 0x81, 0x42, 0x25, 0xDA, 0x01, 0x98,
+	0x00, 0x7A, 0x02, 0x28,
+	0x06, 0xD1, 0x01, 0x99, 0x81, 0xF8, 0x08, 0x90, 0x01, 0x98, 0xDA, 0xF8,
+	0x0C, 0x10, 0x41, 0x60,
+	0x01, 0x98, 0x40, 0x78, 0x80, 0xB9, 0x01, 0x98, 0x53, 0x46, 0x80, 0x78,
+	0x00, 0x28, 0x82, 0x48,
+	0x02, 0x69, 0x04, 0xD0, 0x01, 0x98, 0x0A, 0xF1, 0x0C, 0x01, 0x00, 0x1D,
+	0x02, 0xE0, 0x0A, 0xF1,
+	0x10, 0x01, 0x08, 0x1F, 0x00, 0xF0, 0xE2, 0xF8, 0x04, 0x9A, 0xE3, 0xB2,
+	0x58, 0x46, 0x02, 0x99,
+	0x00, 0xF0, 0xCF, 0xF8, 0x31, 0xE0, 0xDB, 0xF8, 0x08, 0x00, 0x0B, 0x99,
+	0x08, 0x43, 0xCB, 0xF8,
+	0x08, 0x00, 0x01, 0x98, 0x80, 0x78, 0x20, 0xB1, 0x01, 0x99, 0x00, 0x22,
+	0x50, 0x46, 0x09, 0x1D,
+	0x03, 0xE0, 0x01, 0x22, 0x0A, 0xF1, 0x0C, 0x01, 0x50, 0x46, 0x00, 0xF0,
+	0xA8, 0xF8, 0xBA, 0xF8,
+	0x42, 0x00, 0x20, 0xF0, 0x04, 0x01, 0xAA, 0xF8, 0x42, 0x10, 0x16, 0xE0,
+	0x01, 0x98, 0x00, 0x7A,
+	0x01, 0x28, 0x12, 0xD1, 0x01, 0x98, 0x80, 0x78, 0x78, 0xB1, 0x01, 0x99,
+	0x01, 0x22, 0x50, 0x46,
+	0x09, 0x1D, 0x00, 0xF0, 0x94, 0xF8, 0xBA, 0xF8, 0x42, 0x00, 0x20, 0xF0,
+	0x04, 0x01, 0xAA, 0xF8,
+	0x42, 0x10, 0xBA, 0xF8, 0x56, 0x10, 0xAA, 0xF8, 0x54, 0x10, 0x64, 0x1C,
+	0x96, 0xF9, 0xF4, 0x03,
+	0xA0, 0x42, 0xBF, 0xF4, 0xEB, 0xAE, 0x5D, 0x48, 0x00, 0x68, 0x90, 0xF8,
+	0x00, 0x04, 0x80, 0x07,
+	0x02, 0xD5, 0x28, 0x46, 0xFC, 0xF7, 0x6F, 0xFC, 0x59, 0x48, 0x15, 0xB1,
+	0x80, 0xF8, 0x00, 0x90,
+	0x01, 0xE0, 0x00, 0x21, 0x01, 0x70, 0x0A, 0x98, 0x0F, 0xB0, 0xBD, 0xE8,
+	0xF0, 0x8F, 0x53, 0x49,
+	0x0B, 0x68, 0x51, 0x49, 0x5A, 0x8E, 0x18, 0x39, 0x12, 0x1A, 0x08, 0x80,
+	0x4A, 0x80, 0x93, 0xF8,
+	0x0F, 0x34, 0x18, 0x44, 0x88, 0x80, 0xD0, 0x1A, 0xC8, 0x80, 0x70, 0x47,
+	0x4B, 0x49, 0x0B, 0x68,
+	0x49, 0x49, 0x5A, 0x8E, 0x18, 0x39, 0x12, 0x1A, 0x08, 0x81, 0x4A, 0x81,
+	0x93, 0xF8, 0x12, 0x34,
+	0x18, 0x44, 0x88, 0x81, 0xD0, 0x1A, 0xC8, 0x81, 0x70, 0x47, 0x10, 0xB5,
+	0x43, 0x4C, 0x20, 0x68,
+	0x90, 0xF8, 0x0E, 0x04, 0xFF, 0xF7, 0xDB, 0xFF, 0x20, 0x68, 0x90, 0xF8,
+	0x0E, 0x04, 0xFF, 0xF7,
+	0xE5, 0xFF, 0x22, 0x68, 0x3C, 0x49, 0x92, 0xF8, 0x10, 0x04, 0x18, 0x39,
+	0x40, 0x43, 0x08, 0x61,
+	0x92, 0xF8, 0x11, 0x04, 0x88, 0x82, 0x18, 0x22, 0x37, 0x48, 0x0B, 0xF0,
+	0xB3, 0xF9, 0x38, 0x49,
+	0x00, 0x20, 0x35, 0x4A, 0x08, 0x70, 0x37, 0x49, 0x18, 0x3A, 0x48, 0x60,
+	0x10, 0x63, 0x50, 0x63,
+	0x90, 0x63, 0x35, 0x4A, 0x10, 0x70, 0x08, 0x70, 0x10, 0xBD, 0xFE, 0xB5,
+	0x00, 0x24, 0x06, 0x46,
+	0x00, 0x94, 0x01, 0x94, 0x69, 0x46, 0x02, 0x94, 0xFF, 0xF7, 0x61, 0xFD,
+	0x05, 0x46, 0x69, 0x46,
+	0x30, 0x46, 0xFF, 0xF7, 0x66, 0xFE, 0x40, 0xEA, 0x05, 0x01, 0x2A, 0x48,
+	0x01, 0x29, 0x01, 0xD0,
+	0x41, 0x68, 0x05, 0xE0, 0x25, 0x49, 0x09, 0x68, 0x91, 0xF8, 0x0A, 0x14,
+	0x49, 0x1F, 0x41, 0x60,
+	0x00, 0x29, 0x04, 0xDD, 0x49, 0x1E, 0x41, 0x60, 0x21, 0x49, 0x09, 0x78,
+	0x01, 0xB9, 0x44, 0x60,
+	0x1D, 0x48, 0x9D, 0xE8, 0x0E, 0x00, 0x18, 0x30, 0x80, 0xE8, 0x0E, 0x00,
+	0xFE, 0xBD, 0x02, 0x23,
+	0x80, 0xF8, 0x3E, 0x31, 0x00, 0x23, 0x80, 0xF8, 0x42, 0x31, 0x01, 0x2A,
+	0x05, 0xD0, 0x09, 0x68,
+	0x01, 0x62, 0x01, 0x21, 0x80, 0xF8, 0x34, 0x11, 0x70, 0x47, 0x03, 0x22,
+	0x0C, 0x30, 0x07, 0xF0,
+	0x67, 0xBA, 0x10, 0xB5, 0x01, 0x24, 0x9C, 0x40, 0x91, 0x42, 0x03, 0xDA,
+	0x01, 0x68, 0x21, 0x43,
+	0x01, 0x60, 0x10, 0xBD, 0x41, 0x68, 0x21, 0x43, 0x41, 0x60, 0x10, 0xBD,
+	0x70, 0xB5, 0x15, 0x46,
+	0x0A, 0x46, 0x06, 0x46, 0x01, 0x46, 0x1C, 0x46, 0x10, 0x46, 0x07, 0xF0,
+	0x74, 0xFA, 0xA8, 0x42,
+	0x09, 0xDD, 0x00, 0x22, 0x31, 0x46, 0x20, 0x46, 0xFF, 0xF7, 0xD1, 0xFF,
+	0x34, 0xF8, 0x42, 0x0F,
+	0x20, 0xF0, 0x04, 0x00, 0x20, 0x80, 0x70, 0xBD, 0xA8, 0x2C, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0xA4, 0x06, 0x10, 0x00, 0x14, 0x06, 0x10, 0x00, 0xA5, 0x06, 0x10, 0x00,
+	0x10, 0xB5, 0x41, 0xF2,
+	0xE4, 0x41, 0x82, 0x48, 0x0B, 0xF0, 0x92, 0xF9, 0x40, 0xF2, 0x3C, 0x41,
+	0x80, 0x48, 0x0B, 0xF0,
+	0x8D, 0xF9, 0x80, 0x48, 0xFF, 0x21, 0x80, 0xF8, 0xF4, 0x13, 0x00, 0xF0,
+	0x95, 0xFC, 0xFF, 0xF7,
+	0xE3, 0xFA, 0xFF, 0xF7, 0x5A, 0xFF, 0x00, 0xF0, 0xFB, 0xF8, 0xFD, 0xF7,
+	0x6A, 0xFB, 0xFE, 0xF7,
+	0x8C, 0xF8, 0xBD, 0xE8, 0x10, 0x40, 0xFE, 0xF7, 0x05, 0xBE, 0x70, 0xB5,
+	0x76, 0x4D, 0x00, 0x24,
+	0x72, 0x48, 0xAC, 0x71, 0x00, 0xF0, 0x86, 0xFC, 0x74, 0x4E, 0x30, 0x68,
+	0x90, 0xF8, 0x40, 0x04,
+	0xC1, 0x06, 0x04, 0xD5, 0xC0, 0x07, 0x02, 0xD0, 0x6C, 0x48, 0xFF, 0xF7,
+	0xCF, 0xF9, 0x30, 0x68,
+	0x90, 0xF8, 0x00, 0x04, 0xC0, 0x07, 0x05, 0xD0, 0x68, 0x48, 0xFF, 0xF7,
+	0x5E, 0xFF, 0x67, 0x48,
+	0x00, 0xF0, 0xD7, 0xF8, 0x65, 0x48, 0xFD, 0xF7, 0x4C, 0xFB, 0x64, 0x48,
+	0xFE, 0xF7, 0x73, 0xF8,
+	0x63, 0x48, 0x80, 0xF8, 0x38, 0x44, 0x63, 0x48, 0xB0, 0xF8, 0xF8, 0x03,
+	0xA5, 0xF8, 0x1F, 0x00,
+	0x70, 0xBD, 0x70, 0xB5, 0x5E, 0x4D, 0x60, 0x4E, 0x95, 0xF8, 0x38, 0x04,
+	0x88, 0xB3, 0xB0, 0x71,
+	0x29, 0x46, 0x5A, 0x48, 0x00, 0xF0, 0x88, 0xFC, 0x5C, 0x4C, 0x20, 0x68,
+	0x90, 0xF8, 0x40, 0x04,
+	0xC1, 0x06, 0x04, 0xD5, 0xC0, 0x07, 0x02, 0xD0, 0x54, 0x48, 0xFF, 0xF7,
+	0x9F, 0xF9, 0x20, 0x68,
+	0x90, 0xF8, 0x00, 0x04, 0xC0, 0x07, 0x02, 0xD0, 0x50, 0x48, 0xFF, 0xF7,
+	0x2E, 0xFF, 0x20, 0x68,
+	0x90, 0xF8, 0x80, 0x03, 0xC0, 0x07, 0x02, 0xD0, 0x4C, 0x48, 0xFF, 0xF7,
+	0x27, 0xF9, 0x4B, 0x48,
+	0x00, 0xF0, 0x9F, 0xF8, 0x49, 0x48, 0xFD, 0xF7, 0x14, 0xFB, 0x48, 0x48,
+	0xFE, 0xF7, 0x3B, 0xF8,
+	0x00, 0x20, 0x85, 0xF8, 0x38, 0x04, 0x47, 0x48, 0xB0, 0xF8, 0xF8, 0x03,
+	0xA6, 0xF8, 0x1F, 0x00,
+	0x70, 0xBD, 0xFF, 0xE7, 0xFF, 0xF7, 0x99, 0xFF, 0xF5, 0xE7, 0x10, 0xB5,
+	0x40, 0x4C, 0x01, 0x46,
+	0x94, 0xF8, 0x38, 0x04, 0x0F, 0x28, 0x0B, 0xD2, 0x00, 0xEB, 0xC0, 0x00,
+	0x04, 0xEB, 0xC0, 0x00,
+	0x48, 0x22, 0x0B, 0xF0, 0xA7, 0xF8, 0x94, 0xF8, 0x38, 0x04, 0x40, 0x1C,
+	0x84, 0xF8, 0x38, 0x04,
+	0x10, 0xBD, 0x10, 0xB5, 0x00, 0xF5, 0x80, 0x50, 0x00, 0x21, 0xD0, 0xF8,
+	0xEC, 0x33, 0x01, 0x22,
+	0x02, 0xFA, 0x01, 0xF4, 0x23, 0x42, 0x0B, 0xD1, 0x8A, 0x40, 0x13, 0x43,
+	0xC0, 0xF8, 0xEC, 0x33,
+	0x90, 0xF9, 0xF4, 0x23, 0x8A, 0x42, 0x01, 0xDA, 0x80, 0xF8, 0xF4, 0x13,
+	0x48, 0xB2, 0x10, 0xBD,
+	0x49, 0x1C, 0x0F, 0x29, 0xEC, 0xDB, 0x4F, 0xF0, 0xFF, 0x30, 0x10, 0xBD,
+	0x10, 0xB5, 0x00, 0xF5,
+	0x80, 0x50, 0x91, 0xF8, 0x4C, 0x41, 0x01, 0x23, 0xD0, 0xF8, 0xEC, 0x23,
+	0xA3, 0x40, 0x9A, 0x43,
+	0xC0, 0xF8, 0xEC, 0x23, 0x00, 0x22, 0x81, 0xF8, 0x3E, 0x21, 0x90, 0xF9,
+	0xF4, 0x23, 0x91, 0xF9,
+	0x4C, 0x11, 0x8A, 0x42, 0x07, 0xD1, 0xD0, 0xF8, 0xEC, 0x13, 0xB1, 0xFA,
+	0x81, 0xF1, 0xC1, 0xF1,
+	0x1F, 0x01, 0x80, 0xF8, 0xF4, 0x13, 0x10, 0xBD, 0x30, 0xB5, 0x00, 0xF5,
+	0x80, 0x50, 0x00, 0x22,
+	0xD0, 0xF8, 0xF0, 0x43, 0x01, 0x23, 0x00, 0xBF, 0x03, 0xFA, 0x02, 0xF5,
+	0x2C, 0x42, 0x06, 0xD1,
+	0x93, 0x40, 0x1C, 0x43, 0xC0, 0xF8, 0xF0, 0x43, 0x81, 0xF8, 0x4D, 0x21,
+	0x30, 0xBD, 0x52, 0x1C,
+	0x52, 0xB2, 0x0A, 0x2A, 0xF0, 0xDB, 0xFF, 0x20, 0x81, 0xF8, 0x4D, 0x01,
+	0x30, 0xBD, 0x10, 0xB5,
+	0x00, 0xF5, 0x80, 0x50, 0x91, 0xF8, 0x4D, 0x41, 0x01, 0x23, 0xD0, 0xF8,
+	0xF0, 0x23, 0xA3, 0x40,
+	0x9A, 0x43, 0xC0, 0xF8, 0xF0, 0x23, 0xFF, 0x20, 0x81, 0xF8, 0x4D, 0x01,
+	0x10, 0xBD, 0x04, 0x48,
+	0x70, 0x47, 0x03, 0x48, 0x90, 0xF8, 0x38, 0x04, 0x70, 0x47, 0x00, 0x00,
+	0xCC, 0x2C, 0x10, 0x00,
+	0xB0, 0x41, 0x10, 0x00, 0xCC, 0x3C, 0x10, 0x00, 0x0A, 0x44, 0x01, 0x20,
+	0x4C, 0x07, 0x10, 0x00,
+	0x70, 0x47, 0x2D, 0xE9, 0xF0, 0x5F, 0x00, 0x24, 0x06, 0x46, 0x01, 0x27,
+	0xDF, 0xF8, 0x0C, 0x81,
+	0xDF, 0xF8, 0x0C, 0x91, 0xDF, 0xF8, 0x0C, 0xA1, 0x4F, 0xF0, 0x05, 0x0B,
+	0x00, 0xF5, 0x80, 0x55,
+	0x76, 0xE0, 0x00, 0xBF, 0xD5, 0xF8, 0xEC, 0x03, 0x07, 0xFA, 0x04, 0xF1,
+	0x08, 0x42, 0x6D, 0xD0,
+	0x04, 0xEB, 0x04, 0x10, 0x00, 0xEB, 0x80, 0x00, 0x06, 0xEB, 0x80, 0x01,
+	0x91, 0xF8, 0x3E, 0x01,
+	0x01, 0x28, 0x04, 0xD0, 0x02, 0x28, 0x02, 0xD0, 0x04, 0x28, 0x3B, 0xD0,
+	0x5E, 0xE0, 0x91, 0xF8,
+	0x3F, 0x01, 0x03, 0x28, 0x06, 0xD0, 0x04, 0x28, 0x04, 0xD0, 0x02, 0x28,
+	0x21, 0xD0, 0x01, 0x28,
+	0x29, 0xD0, 0x53, 0xE0, 0x30, 0x48, 0xB1, 0xF8, 0x42, 0x20, 0xB0, 0xF9,
+	0x00, 0x00, 0x53, 0x07,
+	0x01, 0xD5, 0xB8, 0xF9, 0x00, 0x00, 0x13, 0x07, 0x02, 0xD5, 0x2C, 0x48,
+	0xB0, 0xF9, 0x00, 0x00,
+	0xB1, 0xF9, 0x54, 0x30, 0x83, 0x42, 0x41, 0xDA, 0xD0, 0x05, 0x06, 0xD5,
+	0xB9, 0xF9, 0x00, 0x00,
+	0x83, 0x42, 0x02, 0xDD, 0x81, 0xF8, 0x3F, 0x71, 0x38, 0xE0, 0x30, 0x46,
+	0xFF, 0xF7, 0x56, 0xFF,
+	0x34, 0xE0, 0x91, 0xF8, 0x42, 0x20, 0x00, 0x20, 0x52, 0x07, 0x01, 0xD5,
+	0xB8, 0xF9, 0x00, 0x00,
+	0xB1, 0xF9, 0x54, 0x20, 0x03, 0xE0, 0xB1, 0xF9, 0x54, 0x20, 0xB9, 0xF9,
+	0x00, 0x00, 0x82, 0x42,
+	0xEB, 0xDB, 0x23, 0xE0, 0x91, 0xF8, 0x40, 0x00, 0x10, 0xF0, 0x06, 0x0F,
+	0x1E, 0xD0, 0x91, 0xF8,
+	0x42, 0x00, 0x40, 0x07, 0x1A, 0xD4, 0x17, 0x4A, 0x15, 0x48, 0x12, 0x78,
+	0xB0, 0xF9, 0x00, 0x00,
+	0x01, 0x2A, 0x01, 0xD1, 0xBA, 0xF9, 0x00, 0x00, 0x91, 0xF8, 0x3F, 0x21,
+	0x03, 0x2A, 0x02, 0xD0,
+	0x02, 0x2A, 0x05, 0xD0, 0x0A, 0xE0, 0xB1, 0xF9, 0x54, 0x20, 0xBA, 0xF9,
+	0x00, 0x00, 0x01, 0xE0,
+	0xB1, 0xF9, 0x54, 0x20, 0x82, 0x42, 0x01, 0xDA, 0x81, 0xF8, 0x3E, 0xB1,
+	0x64, 0x1C, 0x64, 0xB2,
+	0x95, 0xF9, 0xF4, 0x03, 0xA0, 0x42, 0x85, 0xDA, 0xBD, 0xE8, 0xF0, 0x9F,
+	0xA0, 0x06, 0x10, 0x00,
+	0x90, 0x06, 0x10, 0x00, 0x92, 0x06, 0x10, 0x00, 0x8C, 0x06, 0x10, 0x00,
+	0xAA, 0x06, 0x10, 0x00,
+	0x94, 0x06, 0x10, 0x00, 0xA5, 0x06, 0x10, 0x00, 0x90, 0xF8, 0x40, 0x10,
+	0x09, 0x06, 0x14, 0xD5,
+	0xB0, 0xF8, 0x42, 0x10, 0x0A, 0x07, 0x0C, 0xD4, 0xFE, 0x4A, 0x12, 0x68,
+	0x92, 0xF8, 0x40, 0x34,
+	0x5B, 0x06, 0x06, 0xD5, 0x92, 0xF8, 0x80, 0x23, 0x52, 0x06, 0x02, 0xD4,
+	0x01, 0x22, 0x80, 0xF8,
+	0x70, 0x20, 0x41, 0xF0, 0x08, 0x01, 0xA0, 0xF8, 0x42, 0x10, 0x70, 0x47,
+	0xB0, 0xF8, 0x40, 0x10,
+	0xC9, 0x05, 0x14, 0xD5, 0xB0, 0xF8, 0x42, 0x10, 0x0A, 0x06, 0x0C, 0xD4,
+	0xF1, 0x4A, 0x12, 0x68,
+	0x92, 0xF8, 0x20, 0x34, 0x9B, 0x07, 0x06, 0xD5, 0x92, 0xF8, 0x80, 0x23,
+	0x52, 0x06, 0x02, 0xD4,
+	0x01, 0x22, 0x80, 0xF8, 0x70, 0x20, 0x41, 0xF0, 0x80, 0x01, 0xA0, 0xF8,
+	0x42, 0x10, 0x70, 0x47,
+	0x2D, 0xE9, 0xF0, 0x47, 0x82, 0x46, 0x92, 0xF8, 0x40, 0x00, 0x15, 0x46,
+	0x0C, 0x46, 0x02, 0x28,
+	0x01, 0xD1, 0x28, 0x69, 0xE8, 0x60, 0x04, 0xF1, 0x0C, 0x07, 0x4F, 0xF0,
+	0x00, 0x08, 0x4F, 0xF0,
+	0xFF, 0x39, 0x05, 0xF1, 0x0C, 0x06, 0x63, 0xB3, 0x01, 0x20, 0x84, 0xF8,
+	0x3E, 0x01, 0x95, 0xF8,
+	0x40, 0x00, 0x84, 0xF8, 0x3F, 0x01, 0x84, 0xF8, 0x4D, 0x91, 0x84, 0xF8,
+	0x42, 0x81, 0x84, 0xF8,
+	0x43, 0x81, 0xA4, 0xF8, 0x42, 0x80, 0xC4, 0xF8, 0x2C, 0x80, 0x84, 0xF8,
+	0x41, 0x81, 0x84, 0xF8,
+	0x44, 0x81, 0x95, 0xF8, 0x42, 0x00, 0x84, 0xF8, 0x47, 0x01, 0x68, 0x8E,
+	0xA4, 0xF8, 0x56, 0x00,
+	0x95, 0xF8, 0x41, 0x00, 0x84, 0xF8, 0x48, 0x01, 0xE8, 0x68, 0x20, 0x62,
+	0x03, 0x22, 0x31, 0x46,
+	0x20, 0x46, 0x07, 0xF0, 0x1D, 0xF8, 0x03, 0x22, 0x31, 0x46, 0x38, 0x46,
+	0x07, 0xF0, 0x18, 0xF8,
+	0x14, 0xE0, 0x11, 0x46, 0x20, 0x46, 0x00, 0xF0, 0x5F, 0xFB, 0xE0, 0x6A,
+	0x03, 0x22, 0x40, 0x1C,
+	0xE0, 0x62, 0x31, 0x46, 0x20, 0x46, 0x06, 0xF0, 0xFF, 0xFF, 0x03, 0x22,
+	0x31, 0x46, 0x38, 0x46,
+	0x06, 0xF0, 0xFA, 0xFF, 0x94, 0xF8, 0x46, 0x01, 0x84, 0xF8, 0x47, 0x01,
+	0x95, 0xF8, 0x40, 0x00,
+	0x84, 0xF8, 0x3F, 0x01, 0x95, 0xF8, 0x42, 0x00, 0x84, 0xF8, 0x46, 0x01,
+	0xE8, 0x8C, 0xA4, 0xF8,
+	0x44, 0x00, 0x28, 0x8D, 0xA4, 0xF8, 0x46, 0x00, 0x68, 0x8D, 0xA4, 0xF8,
+	0x48, 0x00, 0xE8, 0x8D,
+	0xA4, 0xF8, 0x4A, 0x00, 0x28, 0x8E, 0xA4, 0xF8, 0x4C, 0x00, 0x28, 0x8B,
+	0xA4, 0xF8, 0x4E, 0x00,
+	0xB5, 0xF9, 0x32, 0x00, 0xA4, 0xF8, 0x54, 0x00, 0xA9, 0x69, 0x61, 0x63,
+	0xE9, 0x69, 0xA1, 0x63,
+	0x29, 0x6A, 0xE1, 0x63, 0xA9, 0x8E, 0xA4, 0xF8, 0x58, 0x10, 0xA9, 0x8C,
+	0xA4, 0xF8, 0x40, 0x10,
+	0xD5, 0xF8, 0x36, 0x10, 0xC4, 0xF8, 0x5A, 0x10, 0x69, 0x69, 0xE1, 0x61,
+	0x95, 0xF8, 0x43, 0x10,
+	0x84, 0xF8, 0x49, 0x11, 0x95, 0xF8, 0x44, 0x10, 0x84, 0xF8, 0x4A, 0x11,
+	0xB4, 0xF9, 0x56, 0x10,
+	0x81, 0x42, 0x01, 0xDA, 0xA4, 0xF8, 0x56, 0x00, 0xC4, 0xF8, 0x50, 0x81,
+	0x84, 0xF8, 0x4B, 0x91,
+	0xA8, 0x8C, 0x80, 0x05, 0xB4, 0xF8, 0x42, 0x00, 0x02, 0xD5, 0x40, 0xF4,
+	0x80, 0x70, 0x01, 0xE0,
+	0x20, 0xF4, 0x80, 0x70, 0xA4, 0xF8, 0x42, 0x00, 0x21, 0x46, 0x50, 0x46,
+	0x00, 0xF0, 0xD3, 0xFA,
+	0x20, 0x46, 0xFF, 0xF7, 0x21, 0xFF, 0x20, 0x46, 0xBD, 0xE8, 0xF0, 0x47,
+	0x36, 0xE7, 0xF0, 0xB5,
+	0xB1, 0xF9, 0x02, 0x60, 0xB2, 0xF9, 0x02, 0x50, 0x78, 0x24, 0x06, 0xFB,
+	0x05, 0xF7, 0x00, 0x2F,
+	0x2A, 0xDD, 0xB1, 0xF9, 0x00, 0x70, 0xB2, 0xF9, 0x00, 0xC0, 0x07, 0xFB,
+	0x0C, 0xF7, 0x00, 0x2F,
+	0x22, 0xDD, 0x76, 0x43, 0x5D, 0x43, 0x96, 0xFB, 0xF5, 0xF5, 0x2D, 0xB2,
+	0x45, 0x80, 0xB1, 0xF9,
+	0x00, 0x10, 0xB2, 0xF9, 0x00, 0x20, 0x49, 0x43, 0x5A, 0x43, 0x91, 0xFB,
+	0xF2, 0xF1, 0x0A, 0xB2,
+	0x02, 0x80, 0x78, 0x2D, 0x00, 0xDD, 0x44, 0x80, 0xB0, 0xF9, 0x02, 0x30,
+	0x6F, 0xF0, 0x77, 0x01,
+	0x8B, 0x42, 0x00, 0xDA, 0x41, 0x80, 0x78, 0x2A, 0x00, 0xDD, 0x04, 0x80,
+	0xB0, 0xF9, 0x00, 0x20,
+	0x8A, 0x42, 0x00, 0xDA, 0x01, 0x80, 0xF0, 0xBD, 0x00, 0x21, 0x41, 0x80,
+	0xFA, 0xE7, 0x2D, 0xE9,
+	0xFF, 0x4F, 0xDF, 0xF8, 0xD4, 0x81, 0x0F, 0x46, 0x72, 0x4E, 0xD8, 0xF8,
+	0x08, 0x10, 0x8F, 0xB0,
+	0x00, 0x20, 0x08, 0x60, 0x30, 0x68, 0xB0, 0xF8, 0x82, 0x53, 0x0A, 0xF0,
+	0x77, 0xFF, 0x01, 0x28,
+	0x04, 0xD1, 0x30, 0x68, 0xB0, 0xF8, 0x84, 0x03, 0x00, 0xB1, 0x05, 0x46,
+	0x0A, 0xF0, 0x64, 0xFF,
+	0x80, 0xB1, 0x30, 0x68, 0x69, 0x49, 0xB0, 0xF8, 0x86, 0x53, 0xB0, 0xF8,
+	0x8A, 0x03, 0x09, 0x68,
+	0x88, 0x42, 0x07, 0xDA, 0x0A, 0xF0, 0x62, 0xFF, 0x01, 0x28, 0x03, 0xD1,
+	0x30, 0x68, 0xB0, 0xF8,
+	0x88, 0x03, 0x05, 0x44, 0xDF, 0xF8, 0x88, 0xB1, 0x62, 0x48, 0x63, 0x4B,
+	0xBB, 0xF9, 0x00, 0x20,
+	0x62, 0x49, 0xDF, 0xF8, 0x8C, 0xA1, 0x12, 0xB1, 0x01, 0x2A, 0x3E, 0xD0,
+	0x7B, 0xE0, 0xB0, 0xF9,
+	0x00, 0x00, 0xBA, 0xF9, 0x00, 0x20, 0xD1, 0x46, 0x42, 0x43, 0x03, 0xEB,
+	0x42, 0x04, 0x42, 0x00,
+	0x09, 0x68, 0x20, 0x46, 0x0A, 0xF0, 0xE9, 0xFD, 0xD8, 0xF8, 0x04, 0x20,
+	0x05, 0x21, 0x92, 0xFB,
+	0xF1, 0xF3, 0x01, 0xFB, 0x13, 0x22, 0x41, 0xF6, 0x5A, 0x61, 0x11, 0x44,
+	0x21, 0x80, 0x55, 0x49,
+	0x40, 0x46, 0x49, 0x79, 0x61, 0x80, 0x54, 0x49, 0x09, 0x88, 0xA1, 0x80,
+	0x53, 0x49, 0x09, 0x88,
+	0xE1, 0x80, 0x53, 0x49, 0x09, 0x88, 0x21, 0x81, 0x52, 0x49, 0x09, 0x88,
+	0x61, 0x81, 0x52, 0x49,
+	0x09, 0x88, 0xA1, 0x81, 0x51, 0x49, 0x09, 0x88, 0xE1, 0x81, 0xB9, 0xF8,
+	0x00, 0x10, 0x49, 0x1C,
+	0x09, 0xB2, 0xA9, 0xF8, 0x00, 0x10, 0x42, 0x68, 0x52, 0x1C, 0xC8, 0xF8,
+	0x04, 0x20, 0x05, 0x29,
+	0x41, 0xDB, 0x00, 0x21, 0xA9, 0xF8, 0x00, 0x10, 0x3D, 0xE0, 0xBA, 0xF9,
+	0x00, 0x40, 0x0A, 0x2C,
+	0x36, 0xDA, 0xB0, 0xF9, 0x00, 0x00, 0xD1, 0x46, 0x00, 0xFB, 0x04, 0xF2,
+	0x03, 0xEB, 0x42, 0x04,
+	0x42, 0x00, 0x09, 0x68, 0x20, 0x46, 0x0A, 0xF0, 0xA8, 0xFD, 0xD8, 0xF8,
+	0x04, 0x20, 0x05, 0x21,
+	0x92, 0xFB, 0xF1, 0xF3, 0x01, 0xFB, 0x13, 0x22, 0x41, 0xF6, 0x5A, 0x61,
+	0x11, 0x44, 0x21, 0x80,
+	0x34, 0x49, 0x40, 0x46, 0x49, 0x79, 0x61, 0x80, 0x33, 0x49, 0x09, 0x88,
+	0xA1, 0x80, 0x33, 0x49,
+	0x09, 0x88, 0xE1, 0x80, 0x32, 0x49, 0x09, 0x88, 0x21, 0x81, 0x32, 0x49,
+	0x09, 0x88, 0x61, 0x81,
+	0x31, 0x49, 0x09, 0x88, 0xA1, 0x81, 0x31, 0x49, 0x09, 0x88, 0xE1, 0x81,
+	0xB9, 0xF8, 0x00, 0x10,
+	0x49, 0x1C, 0xA9, 0xF8, 0x00, 0x10, 0x41, 0x68, 0x49, 0x1C, 0xC8, 0xF8,
+	0x04, 0x10, 0x02, 0xE0,
+	0x02, 0x20, 0xAB, 0xF8, 0x00, 0x00, 0x6D, 0x43, 0x02, 0x95, 0x30, 0x68,
+	0x0F, 0x9E, 0x00, 0x25,
+	0x90, 0xF8, 0x8C, 0x03, 0x04, 0x90, 0x06, 0xF5, 0x80, 0x56, 0x96, 0xE0,
+	0x4F, 0xF0, 0x01, 0x09,
+	0xD6, 0xF8, 0xEC, 0x03, 0x09, 0xFA, 0x05, 0xF1, 0x08, 0x42, 0x7D, 0xD0,
+	0x05, 0xEB, 0x05, 0x10,
+	0x00, 0xEB, 0x80, 0x01, 0x0F, 0x98, 0x00, 0xEB, 0x81, 0x04, 0x94, 0xF8,
+	0x3E, 0x01, 0x07, 0x28,
+	0x72, 0xD0, 0x21, 0x46, 0x20, 0x1D, 0x06, 0xF0, 0xBE, 0xFE, 0x00, 0x90,
+	0xB0, 0xF5, 0x80, 0x5F,
+	0x08, 0xDD, 0x01, 0x46, 0xAD, 0x20, 0x06, 0xF0, 0x69, 0xF9, 0xAB, 0xF8,
+	0x00, 0x90, 0x05, 0x20,
+	0xAA, 0xF8, 0x00, 0x00, 0x04, 0x99, 0x00, 0x98, 0x48, 0x43, 0x00, 0xFB,
+	0x01, 0xF9, 0x02, 0x99,
+	0x89, 0x45, 0x1D, 0xE0, 0x4C, 0x07, 0x10, 0x00, 0x1C, 0x06, 0x10, 0x00,
+	0x24, 0x07, 0x10, 0x00,
+	0x84, 0x07, 0x10, 0x00, 0xFE, 0x06, 0x10, 0x00, 0x20, 0x4D, 0x01, 0x20,
+	0x10, 0x07, 0x10, 0x00,
+	0x82, 0x07, 0x10, 0x00, 0x0A, 0x44, 0x01, 0x20, 0x86, 0x07, 0x10, 0x00,
+	0x88, 0x07, 0x10, 0x00,
+	0x8A, 0x07, 0x10, 0x00, 0x8C, 0x07, 0x10, 0x00, 0x8E, 0x07, 0x10, 0x00,
+	0x90, 0x07, 0x10, 0x00,
+	0x00, 0xDA, 0x89, 0x46, 0x22, 0x46, 0x21, 0x1D, 0x08, 0xA8, 0x06, 0xF0,
+	0x7A, 0xFE, 0x22, 0x1D,
+	0x11, 0x1D, 0x0A, 0xA8, 0x06, 0xF0, 0x75, 0xFE, 0xBD, 0xF9, 0x20, 0x00,
+	0x64, 0x30, 0xC8, 0x28,
+	0x04, 0xD8, 0xBD, 0xF9, 0x22, 0x00, 0x64, 0x30, 0xC8, 0x28, 0x01, 0xD9,
+	0x01, 0x23, 0x00, 0xE0,
+	0x03, 0x23, 0x0A, 0xAA, 0x08, 0xA9, 0x09, 0xA8, 0xFF, 0xF7, 0xA1, 0xFE,
+	0x60, 0x88, 0xBD, 0xF8,
+	0x26, 0x10, 0x08, 0x44, 0xAD, 0xF8, 0x2E, 0x00, 0x20, 0x88, 0xBD, 0xF8,
+	0x24, 0x10, 0x00, 0x24,
+	0x08, 0x44, 0xAD, 0xF8, 0x2C, 0x00, 0x1A, 0xE0, 0x04, 0xEB, 0xC4, 0x00,
+	0x07, 0xEB, 0xC0, 0x01,
+	0x0B, 0xA8, 0x0C, 0x31, 0x06, 0xF0, 0x57, 0xFE, 0x48, 0x45, 0x0E, 0xDA,
+	0xD8, 0xF8, 0x08, 0x10,
+	0x0A, 0x68, 0x02, 0xEB, 0x42, 0x02, 0x00, 0xE0, 0x0D, 0xE0, 0x01, 0xEB,
+	0x42, 0x02, 0x50, 0x60,
+	0x54, 0x72, 0x15, 0x72, 0x08, 0x68, 0x40, 0x1C, 0x08, 0x60, 0x64, 0x1C,
+	0xE4, 0xB2, 0x97, 0xF8,
+	0x38, 0x04, 0xA0, 0x42, 0xE0, 0xD8, 0x6D, 0x1C, 0x6D, 0xB2, 0x96, 0xF9,
+	0xF4, 0x03, 0xA8, 0x42,
+	0xBF, 0xF6, 0x64, 0xAF, 0xD8, 0xF8, 0x08, 0x00, 0x45, 0x46, 0x01, 0x68,
+	0x00, 0x29, 0x78, 0xD0,
+	0x00, 0xF0, 0xC2, 0xF9, 0x00, 0x26, 0x4F, 0xF0, 0x04, 0x09, 0xDF, 0xF8,
+	0xC4, 0xA3, 0x4F, 0xF0,
+	0x06, 0x0B, 0x6A, 0xE0, 0x06, 0xEB, 0x46, 0x01, 0x00, 0xEB, 0x41, 0x00,
+	0x90, 0xF9, 0x08, 0x40,
+	0x90, 0xF9, 0x09, 0x30, 0x11, 0x98, 0x02, 0x68, 0x01, 0x20, 0x00, 0xFA,
+	0x04, 0xF1, 0x0A, 0x42,
+	0x5A, 0xD1, 0xDD, 0xF8, 0x48, 0xC0, 0x00, 0xFA, 0x03, 0xF8, 0xDC, 0xF8,
+	0x00, 0xC0, 0x1C, 0xEA,
+	0x08, 0x0F, 0x51, 0xD1, 0x11, 0x98, 0x0A, 0x43, 0x02, 0x60, 0x12, 0x98,
+	0x12, 0x99, 0x00, 0x68,
+	0x40, 0xEA, 0x08, 0x00, 0x08, 0x60, 0x04, 0xEB, 0x04, 0x10, 0x00, 0xEB,
+	0x80, 0x01, 0x0F, 0x98,
+	0x00, 0xEB, 0x81, 0x04, 0x03, 0xEB, 0xC3, 0x00, 0x07, 0xEB, 0xC0, 0x02,
+	0x00, 0x23, 0x21, 0x46,
+	0x0F, 0x98, 0xFF, 0xF7, 0x7D, 0xFD, 0x94, 0xF8, 0x3E, 0x01, 0x03, 0x28,
+	0x04, 0xD0, 0x04, 0x28,
+	0x04, 0xD0, 0x06, 0x28, 0x08, 0xD0, 0x2F, 0xE0, 0x01, 0x20, 0x00, 0xE0,
+	0x00, 0x20, 0x84, 0xF8,
+	0x41, 0x01, 0x84, 0xF8, 0x3E, 0x91, 0x27, 0xE0, 0x84, 0xF8, 0x3E, 0x91,
+	0x94, 0xF8, 0x40, 0x00,
+	0x10, 0xF0, 0x06, 0x0F, 0x20, 0xD0, 0x94, 0xF8, 0x42, 0x00, 0x40, 0x07,
+	0x1C, 0xD4, 0xCA, 0x49,
+	0xC8, 0x48, 0x09, 0x78, 0xB0, 0xF9, 0x00, 0x00, 0x01, 0x29, 0x01, 0xD1,
+	0xBA, 0xF9, 0x00, 0x00,
+	0x94, 0xF8, 0x3F, 0x11, 0x03, 0x29, 0x02, 0xD0, 0x02, 0x29, 0x09, 0xD0,
+	0x0C, 0xE0, 0xB4, 0xF9,
+	0x54, 0x10, 0xBA, 0xF9, 0x00, 0x00, 0x05, 0xE0, 0x84, 0xF8, 0x3E, 0xB1,
+	0x04, 0xE0, 0x08, 0xE0,
+	0xB4, 0xF9, 0x54, 0x10, 0x81, 0x42, 0xF7, 0xDB, 0x76, 0x1C, 0xA8, 0x68,
+	0x01, 0x68, 0xB1, 0x42,
+	0x90, 0xDC, 0x13, 0xB0, 0xBD, 0xE8, 0xF0, 0x8F, 0xB8, 0x48, 0x00, 0x21,
+	0x01, 0x70, 0x81, 0x60,
+	0xC1, 0x60, 0x70, 0x47, 0x2D, 0xE9, 0xF0, 0x41, 0x05, 0x46, 0x41, 0xF2,
+	0x38, 0x40, 0x2E, 0x21,
+	0x28, 0x44, 0x0A, 0xF0, 0xE3, 0xFC, 0x00, 0x24, 0x05, 0xF5, 0x80, 0x56,
+	0x01, 0x27, 0x4F, 0xF0,
+	0x05, 0x08, 0x1B, 0xE0, 0xD6, 0xF8, 0xEC, 0x03, 0x07, 0xFA, 0x04, 0xF1,
+	0x08, 0x42, 0x14, 0xD0,
+	0x04, 0xEB, 0x04, 0x10, 0x00, 0xEB, 0x80, 0x00, 0x05, 0xEB, 0x80, 0x01,
+	0x91, 0xF8, 0x3E, 0x01,
+	0x03, 0x28, 0x04, 0xD0, 0x04, 0x28, 0x02, 0xD0, 0x02, 0x28, 0x03, 0xD0,
+	0x05, 0xE0, 0x81, 0xF8,
+	0x3E, 0x81, 0x02, 0xE0, 0x28, 0x46, 0xFF, 0xF7, 0xE1, 0xFB, 0x64, 0x1C,
+	0x96, 0xF9, 0xF4, 0x03,
+	0xA0, 0x42, 0xDF, 0xDA, 0xBD, 0xE8, 0xF0, 0x81, 0x2D, 0xE9, 0xFC, 0x47,
+	0x04, 0x46, 0x00, 0x25,
+	0x9A, 0x48, 0x0E, 0x46, 0x00, 0x95, 0x01, 0x21, 0x08, 0x30, 0x01, 0x95,
+	0x04, 0xF0, 0x87, 0xF8,
+	0x96, 0x48, 0x05, 0x21, 0x0C, 0x30, 0x04, 0xF0, 0x82, 0xF8, 0x41, 0xF2,
+	0x38, 0x40, 0x2E, 0x21,
+	0x20, 0x44, 0x0A, 0xF0, 0xA3, 0xFC, 0x91, 0x4F, 0xFF, 0x22, 0x2D, 0x21,
+	0xF8, 0x68, 0x0A, 0xF0,
+	0x73, 0xFC, 0x3D, 0x70, 0x04, 0xF5, 0x80, 0x57, 0x4F, 0xF0, 0x01, 0x08,
+	0xD7, 0xF8, 0xEC, 0x03,
+	0x58, 0xB3, 0x6B, 0x46, 0x01, 0xAA, 0x31, 0x46, 0x20, 0x46, 0xFF, 0xF7,
+	0xC0, 0xFD, 0x4F, 0xF0,
+	0x05, 0x09, 0x1E, 0xE0, 0xD7, 0xF8, 0xEC, 0x13, 0x08, 0xFA, 0x05, 0xF0,
+	0x01, 0x42, 0x17, 0xD0,
+	0x01, 0x99, 0x08, 0x42, 0x14, 0xD1, 0x05, 0xEB, 0x05, 0x10, 0x00, 0xEB,
+	0x80, 0x00, 0x04, 0xEB,
+	0x80, 0x01, 0x91, 0xF8, 0x3E, 0x01, 0x03, 0x28, 0x04, 0xD0, 0x04, 0x28,
+	0x02, 0xD0, 0x02, 0x28,
+	0x03, 0xD0, 0x05, 0xE0, 0x81, 0xF8, 0x3E, 0x91, 0x02, 0xE0, 0x20, 0x46,
+	0xFF, 0xF7, 0x8E, 0xFB,
+	0x6D, 0x1C, 0x97, 0xF9, 0xF4, 0x03, 0xA8, 0x42, 0xDC, 0xDA, 0x00, 0x25,
+	0x47, 0x46, 0x1A, 0xE0,
+	0x00, 0x99, 0x07, 0xFA, 0x05, 0xF0, 0x08, 0x42, 0x14, 0xD1, 0x20, 0x46,
+	0xFF, 0xF7, 0x61, 0xFB,
+	0x00, 0x28, 0x0F, 0xDB, 0x00, 0xEB, 0x00, 0x11, 0x01, 0xEB, 0x81, 0x01,
+	0x04, 0xEB, 0x81, 0x01,
+	0x05, 0xEB, 0xC5, 0x02, 0x81, 0xF8, 0x4C, 0x01, 0x06, 0xEB, 0xC2, 0x02,
+	0x01, 0x23, 0x20, 0x46,
+	0xFF, 0xF7, 0x96, 0xFC, 0x6D, 0x1C, 0x96, 0xF8, 0x38, 0x04, 0xA8, 0x42,
+	0xE0, 0xD8, 0x63, 0x48,
+	0x01, 0x21, 0x08, 0x30, 0x04, 0xF0, 0x38, 0xF8, 0x60, 0x48, 0x05, 0x21,
+	0x0C, 0x30, 0x04, 0xF0,
+	0x33, 0xF8, 0xBD, 0xE8, 0xFC, 0x87, 0x30, 0xB5, 0x5C, 0x4A, 0x91, 0xF8,
+	0x46, 0x51, 0xD4, 0x68,
+	0x63, 0x5D, 0xFF, 0x2B, 0x05, 0xD1, 0x13, 0x78, 0x63, 0x55, 0x0F, 0x2B,
+	0x01, 0xD2, 0x5B, 0x1C,
+	0x13, 0x70, 0x91, 0xF8, 0x46, 0x21, 0xA2, 0x5C, 0x81, 0xF8, 0x46, 0x21,
+	0x00, 0xEB, 0x42, 0x02,
+	0x02, 0xF5, 0x80, 0x52, 0x91, 0xF8, 0x4C, 0x51, 0xB2, 0xF8, 0x38, 0x34,
+	0x01, 0x24, 0xAC, 0x40,
+	0x23, 0x43, 0xA2, 0xF8, 0x38, 0x34, 0x91, 0xF8, 0x46, 0x11, 0x41, 0xF2,
+	0x56, 0x42, 0x10, 0x44,
+	0x0A, 0x5C, 0x52, 0x1C, 0x0A, 0x54, 0x30, 0xBD, 0x2D, 0xE9, 0xF0, 0x41,
+	0x04, 0x46, 0x91, 0xF8,
+	0x40, 0x00, 0x00, 0x26, 0x0D, 0x46, 0x01, 0x28, 0x01, 0xD1, 0x84, 0xF8,
+	0x44, 0x61, 0x94, 0xF8,
+	0x3F, 0x01, 0x43, 0x4F, 0xDF, 0xF8, 0x0C, 0x81, 0x01, 0x28, 0x1F, 0xD1,
+	0x95, 0xF8, 0x40, 0x00,
+	0x03, 0x28, 0x4D, 0xD1, 0x94, 0xF8, 0x3E, 0x01, 0x02, 0x28, 0x04, 0xD0,
+	0x03, 0x28, 0x06, 0xD0,
+	0x04, 0x28, 0x04, 0xD0, 0x1E, 0xE0, 0x20, 0x46, 0xFC, 0xF7, 0xC0, 0xFD,
+	0x0E, 0xE0, 0xD8, 0xF8,
+	0x00, 0x10, 0x94, 0xF8, 0x44, 0x01, 0x91, 0xF8, 0x4B, 0x13, 0x01, 0xF0,
+	0x0F, 0x01, 0x88, 0x42,
+	0x02, 0xD8, 0x39, 0x78, 0x01, 0x29, 0x06, 0xD0, 0x84, 0xF8, 0x44, 0x61,
+	0x95, 0xF8, 0x40, 0x00,
+	0x03, 0x28, 0x07, 0xD0, 0x08, 0xE0, 0x40, 0x1C, 0x84, 0xF8, 0x44, 0x01,
+	0x01, 0x20, 0x85, 0xF8,
+	0x40, 0x00, 0x01, 0xE0, 0x84, 0xF8, 0x45, 0x61, 0x94, 0xF8, 0x3F, 0x01,
+	0x03, 0x28, 0x1F, 0xD1,
+	0x95, 0xF8, 0x40, 0x00, 0x01, 0x28, 0x1B, 0xD1, 0x94, 0xF8, 0x3E, 0x01,
+	0x04, 0x28, 0x17, 0xD1,
+	0x38, 0x78, 0xB0, 0xB9, 0xD8, 0xF8, 0x00, 0x00, 0xB4, 0xF9, 0x56, 0x10,
+	0xB0, 0xF8, 0x52, 0x23,
+	0x91, 0x42, 0x0E, 0xDA, 0x94, 0xF8, 0x45, 0x11, 0x90, 0xF8, 0x54, 0x03,
+	0x81, 0x42, 0x07, 0xD2,
+	0x03, 0x20, 0x85, 0xF8, 0x40, 0x00, 0x94, 0xF8, 0x45, 0x01, 0x40, 0x1C,
+	0x84, 0xF8, 0x45, 0x01,
+	0xF0, 0xE6, 0x84, 0xF8, 0x45, 0x61, 0xED, 0xE6, 0x7C, 0xB5, 0x00, 0x21,
+	0x1C, 0xE0, 0x01, 0xEB,
+	0x41, 0x03, 0x4A, 0x1C, 0x00, 0xEB, 0x43, 0x03, 0x12, 0xE0, 0x02, 0xEB,
+	0x42, 0x04, 0x00, 0xEB,
+	0x44, 0x04, 0x5E, 0x68, 0x65, 0x68, 0xAE, 0x42, 0x09, 0xDD, 0x00, 0x96,
+	0x1E, 0x89, 0xAD, 0xF8,
+	0x04, 0x60, 0x5D, 0x60, 0x25, 0x89, 0x1D, 0x81, 0x00, 0x9D, 0x65, 0x60,
+	0x26, 0x81, 0x52, 0x1C,
+	0x04, 0x68, 0x94, 0x42, 0xE9, 0xDC, 0x49, 0x1C, 0x02, 0x68, 0x8A, 0x42,
+	0xDF, 0xDC, 0x7C, 0xBD,
+	0x92, 0x06, 0x10, 0x00, 0x94, 0x06, 0x10, 0x00, 0xA5, 0x06, 0x10, 0x00,
+	0x1C, 0x06, 0x10, 0x00,
+	0xF9, 0x06, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00, 0x2D, 0xE9, 0xF8, 0x4F,
+	0x00, 0x22, 0x91, 0x46,
+	0x15, 0x46, 0x14, 0x46, 0x00, 0x92, 0xFE, 0x4A, 0xFE, 0x4B, 0x12, 0x68,
+	0xB3, 0xF9, 0x00, 0xC0,
+	0xFD, 0x4B, 0x17, 0x8E, 0x1E, 0x68, 0x67, 0x45, 0x60, 0xD1, 0x86, 0x46,
+	0xFB, 0x48, 0x02, 0xF1,
+	0x32, 0x0A, 0x8B, 0x46, 0x90, 0xF8, 0x00, 0xC0, 0xF9, 0x48, 0x07, 0x78,
+	0x4D, 0xE0, 0x3A, 0x46,
+	0x43, 0xE0, 0x00, 0xBF, 0x3A, 0xF8, 0x12, 0x10, 0x3E, 0xF8, 0x12, 0x00,
+	0x3B, 0xF8, 0x12, 0x30,
+	0x08, 0x1A, 0xC9, 0x1A, 0x00, 0xB2, 0x0B, 0xB2, 0x00, 0x28, 0x01, 0xDB,
+	0x01, 0x46, 0x00, 0xE0,
+	0x41, 0x42, 0x49, 0x45, 0x06, 0xDD, 0x00, 0x28, 0x01, 0xDB, 0x01, 0x46,
+	0x00, 0xE0, 0x41, 0x42,
+	0x0F, 0xFA, 0x81, 0xF9, 0x19, 0x1A, 0x01, 0xD4, 0x88, 0x46, 0x01, 0xE0,
+	0xC1, 0xF1, 0x00, 0x08,
+	0xA8, 0x45, 0x05, 0xDD, 0x00, 0x29, 0x01, 0xDB, 0x0D, 0x46, 0x00, 0xE0,
+	0x4D, 0x42, 0x2D, 0xB2,
+	0x00, 0x29, 0x00, 0xDA, 0x49, 0x42, 0xB6, 0xF8, 0xE2, 0x83, 0x41, 0x45,
+	0x15, 0xDD, 0x00, 0x2B,
+	0x00, 0xDA, 0x5B, 0x42, 0x01, 0x1E, 0x00, 0xDA, 0x41, 0x42, 0x8B, 0x42,
+	0x02, 0xDD, 0x64, 0x1C,
+	0xA4, 0xB2, 0x0A, 0xE0, 0x00, 0x28, 0x00, 0xDA, 0x40, 0x42, 0xB6, 0xF8,
+	0xE4, 0x13, 0x88, 0x42,
+	0x03, 0xDD, 0x4F, 0xF0, 0x00, 0x0C, 0x64, 0x46, 0x01, 0xE0, 0x52, 0x1E,
+	0xBA, 0xD1, 0x0A, 0xEB,
+	0x47, 0x0A, 0x0E, 0xEB, 0x47, 0x0E, 0x0B, 0xEB, 0x47, 0x0B, 0xBC, 0xF1,
+	0x01, 0x0C, 0xAE, 0xD2,
+	0x96, 0xF8, 0xE6, 0x03, 0xA0, 0x42, 0x01, 0xD2, 0x01, 0x20, 0x00, 0x90,
+	0x96, 0xF8, 0xE7, 0x13,
+	0xCC, 0x48, 0x00, 0x9A, 0x06, 0xF0, 0x71, 0xFB, 0xCB, 0x49, 0x21, 0xF8,
+	0x25, 0x5F, 0x21, 0xF8,
+	0x02, 0x9C, 0x8C, 0x70, 0xBD, 0xE8, 0xF8, 0x8F, 0x10, 0xB5, 0x0C, 0x46,
+	0xC3, 0x49, 0x09, 0x78,
+	0x4A, 0x00, 0x01, 0x46, 0xC5, 0x48, 0x0A, 0xF0, 0x50, 0xFA, 0xC1, 0x48,
+	0x21, 0x46, 0x00, 0x78,
+	0x42, 0x00, 0xC3, 0x48, 0x0A, 0xF0, 0x49, 0xFA, 0xC2, 0x49, 0x01, 0x20,
+	0x08, 0x70, 0x10, 0xBD,
+	0xB8, 0x49, 0x10, 0xB5, 0xB1, 0xF9, 0x00, 0x10, 0x4A, 0x00, 0x01, 0x46,
+	0xBE, 0x48, 0x00, 0x68,
+	0x0A, 0xF0, 0x3B, 0xFA, 0xBD, 0x49, 0x01, 0x20, 0x08, 0x70, 0x10, 0xBD,
+	0x10, 0xB5, 0x01, 0x23,
+	0x0A, 0xE0, 0x00, 0xBF, 0x30, 0xF9, 0x13, 0x40, 0x00, 0x2C, 0x00, 0xDA,
+	0x64, 0x42, 0x8C, 0x42,
+	0x01, 0xDD, 0x01, 0x20, 0x10, 0xBD, 0x5B, 0x1C, 0x93, 0x42, 0xF3, 0xDB,
+	0x00, 0x20, 0x10, 0xBD,
+	0x2D, 0xE9, 0xFF, 0x5F, 0xDF, 0xF8, 0xAC, 0xB2, 0x00, 0x24, 0xAB, 0xF1,
+	0x01, 0x0B, 0xDF, 0xF8,
+	0x98, 0x92, 0xCB, 0xF8, 0x04, 0x40, 0x8B, 0xF8, 0x00, 0x40, 0xD9, 0xF8,
+	0x00, 0x00, 0x1F, 0x46,
+	0x26, 0x46, 0x90, 0xF8, 0xE0, 0x03, 0x25, 0x46, 0xA0, 0x46, 0xC0, 0x07,
+	0x0E, 0xD0, 0x03, 0x20,
+	0xF3, 0xF7, 0xF7, 0xFC, 0xA4, 0x48, 0x01, 0x68, 0x00, 0x98, 0xFF, 0xF7,
+	0x2D, 0xFF, 0x04, 0x46,
+	0x11, 0x25, 0x03, 0x20, 0xF3, 0xF7, 0x08, 0xFD, 0x00, 0x2C, 0x63, 0xD1,
+	0xA0, 0x48, 0x00, 0x78,
+	0x10, 0xF0, 0x30, 0x0F, 0x5E, 0xD0, 0xFA, 0xF7, 0x21, 0xFD, 0xD9, 0xF8,
+	0x00, 0x00, 0xDF, 0xF8,
+	0x74, 0xA2, 0x90, 0xF8, 0xE0, 0x03, 0x80, 0x07, 0x0B, 0xD5, 0x9B, 0x4A,
+	0x9B, 0x49, 0xDA, 0xF8,
+	0x00, 0x00, 0x00, 0xF0, 0xFB, 0xF8, 0x04, 0x00, 0x4F, 0xF0, 0x30, 0x05,
+	0x4F, 0xF0, 0x01, 0x06,
+	0x48, 0xD1, 0xD9, 0xF8, 0x00, 0x00, 0x90, 0xF8, 0xE1, 0x03, 0xC0, 0x07,
+	0x0B, 0xD0, 0x94, 0x4A,
+	0x94, 0x49, 0xDA, 0xF8, 0x00, 0x00, 0x00, 0xF0, 0x7B, 0xF8, 0x04, 0x00,
+	0x4F, 0xF0, 0x30, 0x05,
+	0x4F, 0xF0, 0x01, 0x06, 0x36, 0xD1, 0xD9, 0xF8, 0x00, 0x00, 0x90, 0xF8,
+	0xE1, 0x03, 0x80, 0x07,
+	0x0B, 0xD5, 0x8B, 0x4A, 0x8B, 0x49, 0xDA, 0xF8, 0x00, 0x00, 0x00, 0xF0,
+	0xA4, 0xF8, 0x04, 0x00,
+	0x4F, 0xF0, 0x31, 0x05, 0x4F, 0xF0, 0x01, 0x06, 0x24, 0xD1, 0x87, 0x48,
+	0x00, 0x78, 0x01, 0x28,
+	0x20, 0xD1, 0x86, 0x48, 0x01, 0x7E, 0x86, 0x48, 0x00, 0x7E, 0x01, 0xFB,
+	0x00, 0xF2, 0x19, 0x2A,
+	0x03, 0xD2, 0x05, 0x29, 0x01, 0xD8, 0x05, 0x28, 0x02, 0xD9, 0x32, 0x25,
+	0x01, 0x26, 0x11, 0xE0,
+	0xD9, 0xF8, 0x00, 0x00, 0x90, 0xF8, 0xE1, 0x03, 0x40, 0x07, 0x0B, 0xD5,
+	0x03, 0x20, 0xF3, 0xF7,
+	0x90, 0xFC, 0x71, 0x48, 0x7B, 0x4A, 0x00, 0x99, 0x00, 0x68, 0xFA, 0xF7,
+	0x7E, 0xFE, 0x03, 0x20,
+	0xF3, 0xF7, 0xA2, 0xFC, 0x0A, 0xF0, 0x00, 0xFB, 0x01, 0x46, 0x77, 0x48,
+	0x01, 0x70, 0x54, 0xB3,
+	0x6E, 0xB1, 0x87, 0xF8, 0x00, 0x80, 0x29, 0x46, 0x05, 0x20, 0x05, 0xF0,
+	0x9C, 0xFD, 0x00, 0x98,
+	0xFF, 0xF7, 0x46, 0xFF, 0xDD, 0xE9, 0x01, 0x01, 0xFF, 0xF7, 0x2E, 0xFF,
+	0x17, 0xE0, 0x01, 0x20,
+	0x38, 0x70, 0x8B, 0xF8, 0x00, 0x50, 0xDB, 0xF8, 0x04, 0x10, 0x41, 0xF0,
+	0x02, 0x01, 0xCB, 0xF8,
+	0x04, 0x10, 0xD9, 0xF8, 0x00, 0x20, 0x92, 0xF8, 0x50, 0x32, 0xDB, 0x07,
+	0x03, 0xD1, 0x92, 0xF8,
+	0x80, 0x22, 0xD2, 0x07, 0x03, 0xD0, 0x41, 0xF0, 0x08, 0x01, 0xCB, 0xF8,
+	0x04, 0x10, 0x01, 0x20,
+	0x04, 0xB0, 0xBD, 0xE8, 0xF0, 0x9F, 0x87, 0xF8, 0x00, 0x80, 0x00, 0x78,
+	0xF8, 0xE7, 0x4D, 0x48,
+	0x00, 0x21, 0x40, 0x1E, 0x41, 0x60, 0x01, 0x70, 0xA0, 0xF8, 0x01, 0x10,
+	0xC1, 0x70, 0x70, 0x47,
+	0x2D, 0xE9, 0xF7, 0x4F, 0xDF, 0xF8, 0x10, 0x81, 0x93, 0x46, 0x0B, 0x46,
+	0xD8, 0xF8, 0x00, 0x00,
+	0x00, 0x25, 0x2C, 0x46, 0x90, 0xF8, 0xEC, 0x73, 0xB0, 0xF9, 0xE8, 0x63,
+	0xB0, 0xF9, 0xEA, 0xA3,
+	0x3E, 0x48, 0x31, 0x46, 0x02, 0x78, 0x18, 0x46, 0xFB, 0xF7, 0x21, 0xFF,
+	0x81, 0x46, 0x3C, 0x48,
+	0x31, 0x46, 0x02, 0x78, 0x58, 0x46, 0xFB, 0xF7, 0x1A, 0xFF, 0x01, 0x46,
+	0xB9, 0xF1, 0x00, 0x0F,
+	0x00, 0xD0, 0x51, 0xB9, 0x33, 0x48, 0x51, 0x46, 0xB0, 0xF9, 0x00, 0x20,
+	0x00, 0x98, 0x00, 0xF0,
+	0xBE, 0xF8, 0x04, 0x46, 0xB8, 0x42, 0x00, 0xD9, 0x01, 0x25, 0xD8, 0xF8,
+	0x00, 0x00, 0x2A, 0x46,
+	0x90, 0xF8, 0xED, 0x13, 0x2F, 0x48, 0x40, 0x1C, 0x06, 0xF0, 0x37, 0xFA,
+	0x2E, 0x49, 0x81, 0xF8,
+	0x31, 0x40, 0xBD, 0xE8, 0xFE, 0x8F, 0x2D, 0xE9, 0xF0, 0x47, 0x27, 0x4E,
+	0x89, 0x46, 0x92, 0x46,
+	0x31, 0x68, 0x24, 0x4A, 0x00, 0x25, 0x91, 0xF8, 0xF2, 0x73, 0xB1, 0xF9,
+	0xF0, 0x83, 0x2C, 0x46,
+	0xB1, 0xF9, 0xEE, 0x13, 0xB2, 0xF9, 0x00, 0x20, 0xFB, 0xF7, 0xF7, 0xFE,
+	0x88, 0xB9, 0x1F, 0x48,
+	0x41, 0x46, 0x02, 0x78, 0x48, 0x46, 0x00, 0xF0, 0x92, 0xF8, 0x04, 0x46,
+	0x1C, 0x48, 0x41, 0x46,
+	0x02, 0x78, 0x50, 0x46, 0x00, 0xF0, 0x8B, 0xF8, 0x20, 0x44, 0xC4, 0xB2,
+	0xBC, 0x42, 0x00, 0xD9,
+	0x01, 0x25, 0x30, 0x68, 0x2A, 0x46, 0x90, 0xF8, 0xF3, 0x13, 0x16, 0x48,
+	0x80, 0x1C, 0x06, 0xF0,
+	0x04, 0xFA, 0x15, 0x49, 0x81, 0xF8, 0x32, 0x40, 0xBD, 0xE8, 0xF0, 0x87,
+	0x2D, 0xE9, 0xF0, 0x5F,
+	0x0D, 0x4E, 0x83, 0x46, 0x0B, 0x46, 0x30, 0x68, 0x20, 0x49, 0x00, 0x25,
+	0x90, 0xF8, 0xF5, 0x73,
+	0xB0, 0xF9, 0xF6, 0xC3, 0xB0, 0xF9, 0xFA, 0x93, 0x09, 0x78, 0x92, 0x46,
+	0x2C, 0x46, 0x09, 0xB1,
+	0xB0, 0xF9, 0xF8, 0xC3, 0x1A, 0x48, 0x00, 0x78, 0xB0, 0xB3, 0x1A, 0x48,
+	0x00, 0x78, 0x34, 0xE0,
+	0x50, 0x07, 0x10, 0x00, 0xFE, 0x06, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0xED, 0x06, 0x10, 0x00,
+	0xEE, 0x06, 0x10, 0x00, 0x2D, 0x06, 0x10, 0x00, 0x0A, 0x44, 0x01, 0x20,
+	0x7E, 0x4A, 0x01, 0x20,
+	0xA8, 0x4A, 0x01, 0x20, 0x7A, 0x07, 0x10, 0x00, 0x1C, 0x07, 0x10, 0x00,
+	0x79, 0x07, 0x10, 0x00,
+	0x04, 0x07, 0x10, 0x00, 0x10, 0x07, 0x10, 0x00, 0xF2, 0x2A, 0x10, 0x00,
+	0xC8, 0x2A, 0x10, 0x00,
+	0xBE, 0x0B, 0x01, 0x20, 0x94, 0x0B, 0x01, 0x20, 0x66, 0x05, 0x10, 0x00,
+	0x18, 0x2A, 0x10, 0x00,
+	0x58, 0x2A, 0x10, 0x00, 0x60, 0x2B, 0x10, 0x00, 0x76, 0x06, 0x10, 0x00,
+	0xF9, 0x06, 0x10, 0x00,
+	0x74, 0x05, 0x10, 0x00, 0x64, 0x05, 0x10, 0x00, 0x01, 0xE0, 0x90, 0xB1,
+	0x1C, 0xE0, 0x1C, 0x48,
+	0x61, 0x46, 0x02, 0x78, 0x18, 0x46, 0xFF, 0xF7, 0x61, 0xFE, 0x80, 0x46,
+	0x19, 0x48, 0x61, 0x46,
+	0x02, 0x78, 0x50, 0x46, 0xFF, 0xF7, 0x5A, 0xFE, 0x01, 0x46, 0xB8, 0xF1,
+	0x00, 0x0F, 0x00, 0xD0,
+	0x51, 0xB9, 0x15, 0x48, 0x49, 0x46, 0xB0, 0xF9, 0x00, 0x20, 0x58, 0x46,
+	0x00, 0xF0, 0x0F, 0xF8,
+	0x04, 0x46, 0xB8, 0x42, 0x00, 0xD9, 0x01, 0x25, 0x30, 0x68, 0x2A, 0x46,
+	0x90, 0xF8, 0xFC, 0x13,
+	0x0E, 0x48, 0x06, 0xF0, 0x8A, 0xF9, 0x0E, 0x49, 0x81, 0xF8, 0x31, 0x40,
+	0x09, 0xE7, 0x10, 0xB5,
+	0x04, 0x46, 0x00, 0x20, 0x09, 0xE0, 0x00, 0xBF, 0x34, 0xF9, 0x12, 0x30,
+	0x00, 0x2B, 0x00, 0xDA,
+	0x5B, 0x42, 0x8B, 0x42, 0x01, 0xDD, 0x40, 0x1C, 0xC0, 0xB2, 0x52, 0x1E,
+	0xF4, 0xD2, 0x10, 0xBD,
+	0xED, 0x06, 0x10, 0x00, 0xEE, 0x06, 0x10, 0x00, 0xFE, 0x06, 0x10, 0x00,
+	0x2E, 0x06, 0x10, 0x00,
+	0x0A, 0x44, 0x01, 0x20, 0x2D, 0xE9, 0xFF, 0x4F, 0x87, 0xB0, 0x00, 0x20,
+	0x81, 0x46, 0x03, 0x90,
+	0x02, 0x90, 0x01, 0x90, 0xFF, 0x48, 0x88, 0x46, 0x93, 0x46, 0x00, 0x68,
+	0xB0, 0xF8, 0xB0, 0x02,
+	0x06, 0x90, 0x89, 0x78, 0x50, 0x68, 0x0A, 0xF0, 0xD1, 0xF9, 0x00, 0x90,
+	0x98, 0xF8, 0x02, 0x50,
+	0x98, 0xF8, 0x03, 0x00, 0x05, 0x90, 0x32, 0xE0, 0x07, 0x98, 0x98, 0xF8,
+	0x00, 0x40, 0x00, 0xEB,
+	0xC5, 0x00, 0x04, 0x90, 0x98, 0xF8, 0x01, 0xA0, 0x1F, 0xE0, 0x04, 0x98,
+	0x22, 0x46, 0x00, 0x21,
+	0xD0, 0xE9, 0x00, 0x67, 0x01, 0x20, 0x09, 0xF0, 0xF9, 0xFF, 0x06, 0x40,
+	0x0F, 0x40, 0x3E, 0x43,
+	0x12, 0xD0, 0x00, 0x98, 0x06, 0x99, 0x30, 0xF9, 0x14, 0x00, 0x88, 0x42,
+	0x0C, 0xDD, 0x02, 0x99,
+	0x81, 0x44, 0x04, 0xFB, 0x00, 0x11, 0x02, 0x91, 0x01, 0x99, 0x05, 0xFB,
+	0x00, 0x10, 0x01, 0x90,
+	0x03, 0x98, 0x40, 0x1C, 0x80, 0xB2, 0x03, 0x90, 0x64, 0x1C, 0xA2, 0x45,
+	0xDD, 0xDA, 0xE2, 0x49,
+	0x00, 0x98, 0x6D, 0x1C, 0x09, 0x78, 0x00, 0xEB, 0x41, 0x00, 0x00, 0x90,
+	0x05, 0x98, 0xA8, 0x42,
+	0xCA, 0xDA, 0xDC, 0x48, 0x00, 0x25, 0x04, 0x68, 0x01, 0x98, 0xA1, 0x8E,
+	0xC2, 0x17, 0xA1, 0xFB,
+	0x00, 0x36, 0x05, 0xFB, 0x00, 0x60, 0x01, 0xFB, 0x02, 0x02, 0x4F, 0xF6,
+	0xFF, 0x76, 0xA3, 0xFB,
+	0x06, 0x07, 0x02, 0xFB, 0x06, 0x72, 0x03, 0xFB, 0x05, 0x21, 0x94, 0xF8,
+	0x31, 0x30, 0x30, 0x34,
+	0x5B, 0x1E, 0x89, 0xFB, 0x03, 0x23, 0x09, 0xF0, 0xCC, 0xFF, 0x72, 0x10,
+	0x80, 0x18, 0xB0, 0x46,
+	0x41, 0xF1, 0x00, 0x01, 0x42, 0x46, 0x00, 0x23, 0x09, 0xF0, 0xC3, 0xFF,
+	0x07, 0x46, 0x02, 0x98,
+	0x61, 0x88, 0xC2, 0x17, 0xA1, 0xFB, 0x00, 0x36, 0x05, 0xFB, 0x00, 0x60,
+	0x01, 0xFB, 0x02, 0x01,
+	0x42, 0x46, 0xA3, 0xFB, 0x02, 0x06, 0x01, 0xFB, 0x02, 0x61, 0x03, 0xFB,
+	0x05, 0x11, 0x23, 0x78,
+	0x5B, 0x1E, 0x89, 0xFB, 0x03, 0x23, 0x09, 0xF0, 0xAC, 0xFF, 0x47, 0xF6,
+	0xFF, 0x72, 0x80, 0x18,
+	0x41, 0xF1, 0x00, 0x01, 0x42, 0x46, 0x00, 0x23, 0x09, 0xF0, 0xA3, 0xFF,
+	0xCB, 0xF8, 0x1C, 0x90,
+	0x03, 0x99, 0xAB, 0xF8, 0x28, 0x10, 0x0A, 0x99, 0x48, 0x60, 0x0A, 0x99,
+	0x0F, 0x60, 0x0B, 0xB0,
+	0xBD, 0xE8, 0xF0, 0x8F, 0x2D, 0xE9, 0xFF, 0x4F, 0x81, 0x46, 0xB2, 0x48,
+	0x00, 0x26, 0x8A, 0x46,
+	0x00, 0x68, 0x14, 0x46, 0x95, 0xB0, 0x90, 0xF8, 0x21, 0x03, 0x4F, 0xF6,
+	0xFF, 0x75, 0x32, 0x46,
+	0x31, 0x46, 0x43, 0x07, 0xAA, 0xF1, 0x01, 0x07, 0x4C, 0xD5, 0x00, 0x07,
+	0x02, 0xD5, 0x8C, 0xB3,
+	0xBC, 0x42, 0x48, 0xDA, 0x68, 0x46, 0xD4, 0x46, 0xA3, 0x46, 0x00, 0x23,
+	0x08, 0xE0, 0x00, 0xBF,
+	0x39, 0xF8, 0x13, 0x40, 0x00, 0xEB, 0x43, 0x08, 0x5B, 0x1C, 0xA8, 0xF8,
+	0x02, 0x40, 0xDB, 0xB2,
+	0x63, 0x45, 0xF5, 0xD3, 0x43, 0x88, 0x03, 0x80, 0x00, 0xEB, 0x4C, 0x04,
+	0x30, 0xF8, 0x1C, 0x30,
+	0x63, 0x80, 0x01, 0x23, 0x10, 0xE0, 0x00, 0xBF, 0x00, 0xEB, 0x43, 0x04,
+	0x34, 0xF8, 0x02, 0x8C,
+	0x64, 0x88, 0x44, 0x44, 0x30, 0xF8, 0x13, 0x80, 0x04, 0xEB, 0x48, 0x04,
+	0x09, 0xEB, 0x43, 0x08,
+	0x5B, 0x1C, 0x28, 0xF8, 0x02, 0x4C, 0xDB, 0xB2, 0x63, 0x45, 0xED, 0xD9,
+	0x93, 0x4B, 0xD8, 0x46,
+	0x00, 0x20, 0x09, 0xE0, 0x1B, 0xE0, 0x00, 0xBF, 0x39, 0xF9, 0x10, 0x40,
+	0x9C, 0x42, 0x01, 0xDD,
+	0x23, 0x46, 0x80, 0x46, 0x40, 0x1C, 0xC0, 0xB2, 0x60, 0x45, 0xF5, 0xD3,
+	0x5F, 0xEA, 0x08, 0x04,
+	0x01, 0xD1, 0xBD, 0xF9, 0x00, 0x20, 0xBC, 0x42, 0x04, 0xDB, 0x69, 0x46,
+	0x01, 0xEB, 0x4A, 0x00,
+	0x30, 0xF9, 0x02, 0x1C, 0x1C, 0xB1, 0x09, 0xEB, 0x44, 0x00, 0x30, 0xF9,
+	0x02, 0x2C, 0x39, 0xF9,
+	0x14, 0xA0, 0xBC, 0x42, 0x03, 0xDA, 0x09, 0xEB, 0x44, 0x00, 0xB0, 0xF9,
+	0x02, 0x10, 0x10, 0x46,
+	0x88, 0x46, 0x8A, 0x42, 0x01, 0xDD, 0x80, 0x46, 0x08, 0x46, 0x8A, 0x1A,
+	0xA2, 0xFB, 0x05, 0x1C,
+	0xD3, 0x17, 0x03, 0xFB, 0x05, 0xC3, 0x02, 0xFB, 0x06, 0x3C, 0x0A, 0xEB,
+	0x08, 0x02, 0x40, 0x42,
+	0x02, 0xEB, 0x40, 0x02, 0x08, 0x46, 0xD3, 0x17, 0x61, 0x46, 0x09, 0xF0,
+	0x12, 0xFF, 0xA4, 0xFB,
+	0x05, 0x3C, 0x00, 0x22, 0x02, 0xFB, 0x05, 0xC2, 0x04, 0xFB, 0x06, 0x22,
+	0x1B, 0x18, 0x4A, 0x41,
+	0x18, 0x99, 0xA3, 0xFB, 0x01, 0x0C, 0xCC, 0x17, 0x02, 0xFB, 0x01, 0xC1,
+	0x03, 0xFB, 0x04, 0x11,
+	0xFB, 0x17, 0x3A, 0x46, 0x09, 0xF0, 0xFD, 0xFE, 0x04, 0x46, 0x0F, 0x46,
+	0x02, 0x22, 0x00, 0x23,
+	0x28, 0x46, 0x31, 0x46, 0x09, 0xF0, 0xF5, 0xFE, 0x00, 0x19, 0x79, 0x41,
+	0x2A, 0x46, 0x33, 0x46,
+	0x09, 0xF0, 0xEF, 0xFE, 0x19, 0xB0, 0x53, 0xE7, 0x2D, 0xE9, 0xFF, 0x4F,
+	0x9F, 0xB0, 0x00, 0x20,
+	0x1B, 0x90, 0x16, 0x90, 0x1C, 0x90, 0x0C, 0x46, 0x90, 0x46, 0x89, 0x78,
+	0x50, 0x68, 0x0A, 0xF0,
+	0x8D, 0xF8, 0x13, 0x90, 0x94, 0xF8, 0x02, 0x90, 0x94, 0xF8, 0x03, 0xB0,
+	0x2E, 0xE0, 0x1F, 0x98,
+	0x25, 0x78, 0x00, 0xEB, 0xC9, 0x00, 0x1D, 0x90, 0x94, 0xF8, 0x01, 0xA0,
+	0x1A, 0xE0, 0x1D, 0x98,
+	0x2A, 0x46, 0x00, 0x21, 0xD0, 0xE9, 0x00, 0x67, 0x01, 0x20, 0x09, 0xF0,
+	0xB7, 0xFE, 0x06, 0x40,
+	0x0F, 0x40, 0x3E, 0x43, 0x0C, 0xD0, 0x13, 0x98, 0x1C, 0x99, 0x30, 0xF9,
+	0x15, 0x00, 0x88, 0x42,
+	0x06, 0xDD, 0x16, 0x99, 0x08, 0x44, 0x16, 0x90, 0x1B, 0x98, 0x40, 0x1C,
+	0x80, 0xB2, 0x1B, 0x90,
+	0x6D, 0x1C, 0xED, 0xB2, 0xAA, 0x45, 0xE2, 0xD2, 0x43, 0x49, 0x13, 0x98,
+	0x09, 0x78, 0x00, 0xEB,
+	0x41, 0x00, 0x13, 0x90, 0x09, 0xF1, 0x01, 0x00, 0x00, 0xF0, 0xFF, 0x09,
+	0xCB, 0x45, 0xCE, 0xD2,
+	0x16, 0x98, 0xC8, 0xF8, 0x1C, 0x00, 0x1B, 0x98, 0xA8, 0xF8, 0x28, 0x00,
+	0x98, 0xF8, 0x3E, 0x70,
+	0x98, 0xF8, 0x3F, 0x90, 0x4C, 0x21, 0x68, 0x46, 0x09, 0xF0, 0x60, 0xFF,
+	0xA1, 0x78, 0xD8, 0xF8,
+	0x04, 0x00, 0x0A, 0xF0, 0x43, 0xF8, 0x34, 0x4A, 0xA1, 0x78, 0x6D, 0x46,
+	0x12, 0x78, 0x07, 0xE0,
+	0x30, 0xF8, 0x17, 0x30, 0x25, 0xF8, 0x11, 0x30, 0x49, 0x1C, 0x00, 0xEB,
+	0x42, 0x00, 0xC9, 0xB2,
+	0xE3, 0x78, 0x8B, 0x42, 0xF4, 0xD2, 0x2B, 0x4E, 0x4A, 0x46, 0x30, 0x68,
+	0xB0, 0xF9, 0x34, 0x30,
+	0x90, 0xF8, 0x31, 0x10, 0x28, 0x46, 0xFF, 0xF7, 0xE5, 0xFE, 0x22, 0x99,
+	0x08, 0x60, 0x4C, 0x21,
+	0x68, 0x46, 0x09, 0xF0, 0x3B, 0xFF, 0x49, 0x46, 0xD8, 0xF8, 0x04, 0x00,
+	0x0A, 0xF0, 0x1E, 0xF8,
+	0x21, 0x78, 0x05, 0xE0, 0x30, 0xF8, 0x11, 0x20, 0x25, 0xF8, 0x11, 0x20,
+	0x49, 0x1C, 0xC9, 0xB2,
+	0x62, 0x78, 0x8A, 0x42, 0xF6, 0xD2, 0x30, 0x68, 0x3A, 0x46, 0xB0, 0xF9,
+	0x32, 0x30, 0x90, 0xF8,
+	0x30, 0x10, 0x68, 0x46, 0xFF, 0xF7, 0xC6, 0xFE, 0x22, 0x99, 0x48, 0x60,
+	0x23, 0xB0, 0xBF, 0xE6,
+	0x10, 0xB5, 0x14, 0x49, 0x43, 0x68, 0x00, 0x22, 0x09, 0x68, 0x00, 0x2B,
+	0x01, 0xDA, 0x42, 0x60,
+	0x03, 0xE0, 0x4C, 0x8E, 0xA3, 0x42, 0x00, 0xDD, 0x44, 0x60, 0x03, 0x68,
+	0x00, 0x2B, 0x01, 0xDA,
+	0x02, 0x60, 0x10, 0xBD, 0x89, 0x8E, 0x8B, 0x42, 0xFB, 0xDD, 0x01, 0x60,
+	0x10, 0xBD, 0x2D, 0xE9,
+	0xFF, 0x47, 0x14, 0x46, 0x88, 0x46, 0x81, 0x46, 0x00, 0x27, 0x01, 0x26,
+	0x6B, 0x46, 0xFF, 0xF7,
+	0x01, 0xFE, 0x07, 0x48, 0x03, 0x4D, 0x00, 0x78, 0x78, 0xB1, 0x28, 0x68,
+	0x90, 0xF8, 0x07, 0x05,
+	0x00, 0x07, 0x07, 0xE0, 0x4C, 0x07, 0x10, 0x00, 0xEE, 0x06, 0x10, 0x00,
+	0x00, 0x80, 0xFF, 0xFF,
+	0xA4, 0x06, 0x10, 0x00, 0x01, 0xD5, 0x04, 0x27, 0x3E, 0x46, 0x94, 0xF8,
+	0x40, 0x00, 0x03, 0x28,
+	0x04, 0xD0, 0x02, 0x28, 0x06, 0xD0, 0x01, 0x28, 0x14, 0xD0, 0x1C, 0xE0,
+	0x28, 0x68, 0x06, 0xE0,
+	0x39, 0x46, 0x15, 0xE0, 0x28, 0x68, 0x90, 0xF8, 0x21, 0x13, 0x89, 0x07,
+	0x04, 0xD5, 0x90, 0xF8,
+	0x07, 0x05, 0xC0, 0x07, 0xF4, 0xD1, 0x0E, 0xE0, 0x90, 0xF8, 0x07, 0x05,
+	0x80, 0x07, 0x0A, 0xD5,
+	0x31, 0x46, 0x05, 0xE0, 0x28, 0x68, 0x90, 0xF8, 0x07, 0x05, 0x40, 0x07,
+	0x03, 0xD5, 0x02, 0x21,
+	0x68, 0x46, 0x01, 0xF0, 0xC1, 0xFD, 0x68, 0x46, 0xFF, 0xF7, 0xA2, 0xFF,
+	0xDD, 0xE9, 0x00, 0x01,
+	0xCD, 0xE9, 0x02, 0x01, 0x94, 0xF8, 0x40, 0x00, 0x02, 0x28, 0x41, 0xD1,
+	0x28, 0x68, 0x90, 0xF8,
+	0x21, 0x03, 0x80, 0x07, 0x3C, 0xD5, 0x02, 0xAB, 0x22, 0x46, 0x41, 0x46,
+	0x48, 0x46, 0xFF, 0xF7,
+	0xFB, 0xFE, 0x28, 0x68, 0x90, 0xF8, 0x07, 0x05, 0x80, 0x07, 0x03, 0xD5,
+	0x31, 0x46, 0x02, 0xA8,
+	0x01, 0xF0, 0xA2, 0xFD, 0x02, 0xA8, 0xFF, 0xF7, 0x83, 0xFF, 0x29, 0x68,
+	0xE3, 0x69, 0x91, 0xF8,
+	0x2D, 0x23, 0x02, 0xF0, 0x0F, 0x00, 0x15, 0x09, 0xB1, 0xF8, 0x2E, 0x23,
+	0xB1, 0xF8, 0x30, 0x13,
+	0x93, 0x42, 0x0D, 0xDD, 0x8B, 0x42, 0x01, 0xDB, 0x28, 0x46, 0x09, 0xE0,
+	0x91, 0x42, 0x00, 0xD1,
+	0x49, 0x1C, 0x9B, 0x1A, 0x2D, 0x1A, 0x6B, 0x43, 0x89, 0x1A, 0x93, 0xFB,
+	0xF1, 0xF1, 0x08, 0x44,
+	0x01, 0x9A, 0x03, 0x9B, 0xC0, 0xF1, 0x10, 0x01, 0x42, 0x43, 0x03, 0xFB,
+	0x01, 0x22, 0x12, 0x11,
+	0x03, 0x92, 0x00, 0x9A, 0x42, 0x43, 0x02, 0x98, 0x00, 0xFB, 0x01, 0x20,
+	0x00, 0x11, 0x02, 0x90,
+	0x01, 0x98, 0xE0, 0x81, 0x00, 0x98, 0xA0, 0x81, 0x03, 0x98, 0x60, 0x82,
+	0x02, 0x98, 0x20, 0x82,
+	0x94, 0xF8, 0x24, 0x00, 0xC0, 0x06, 0x01, 0xD4, 0xE0, 0x68, 0x60, 0x61,
+	0xBD, 0xE8, 0xFF, 0x87,
+	0x2D, 0xE9, 0xF0, 0x47, 0x05, 0x46, 0x90, 0xF8, 0x02, 0x80, 0x0F, 0x46,
+	0x88, 0x68, 0x14, 0x46,
+	0x01, 0x26, 0x41, 0x46, 0x09, 0xF0, 0x42, 0xFF, 0x81, 0x46, 0xA8, 0xF1,
+	0x01, 0x00, 0xC1, 0xB2,
+	0xB8, 0x68, 0x09, 0xF0, 0x3B, 0xFF, 0x29, 0x78, 0x09, 0xEB, 0x41, 0x02,
+	0x32, 0xF9, 0x02, 0x2C,
+	0xA2, 0x42, 0x03, 0xDB, 0x30, 0xF9, 0x11, 0x10, 0xA1, 0x42, 0x00, 0xDA,
+	0x00, 0x26, 0x69, 0x78,
+	0x09, 0xEB, 0x41, 0x02, 0xB2, 0xF9, 0x02, 0x20, 0xA2, 0x42, 0x03, 0xDB,
+	0x30, 0xF9, 0x11, 0x00,
+	0xA0, 0x42, 0x00, 0xDA, 0x00, 0x26, 0x95, 0xF8, 0x03, 0x80, 0xB8, 0x68,
+	0x41, 0x46, 0x09, 0xF0,
+	0x1D, 0xFF, 0x81, 0x46, 0x08, 0xF1, 0x01, 0x00, 0xC1, 0xB2, 0xB8, 0x68,
+	0x09, 0xF0, 0x16, 0xFF,
+	0x29, 0x78, 0x09, 0xEB, 0x41, 0x02, 0x32, 0xF9, 0x02, 0x2C, 0xA2, 0x42,
+	0x03, 0xDB, 0x30, 0xF9,
+	0x11, 0x10, 0xA1, 0x42, 0x00, 0xDA, 0x00, 0x26, 0x69, 0x78, 0x09, 0xEB,
+	0x41, 0x02, 0xB2, 0xF9,
+	0x02, 0x20, 0xA2, 0x42, 0x03, 0xDB, 0x30, 0xF9, 0x11, 0x00, 0xA0, 0x42,
+	0x00, 0xDA, 0x00, 0x26,
+	0x30, 0x46, 0xBD, 0xE8, 0xF0, 0x87, 0x2D, 0xE9, 0xFF, 0x4F, 0x97, 0xB0,
+	0x99, 0x46, 0x92, 0x46,
+	0xFE, 0x48, 0xDF, 0xF8, 0xFC, 0x83, 0x01, 0x22, 0x04, 0x68, 0x51, 0x46,
+	0xD8, 0xF8, 0x00, 0x00,
+	0x01, 0xF0, 0x6E, 0xFA, 0xFB, 0x48, 0x00, 0x68, 0xB0, 0xF9, 0x4B, 0x14,
+	0x11, 0x91, 0x90, 0xF8,
+	0x4A, 0x04, 0x0A, 0x90, 0xF8, 0x48, 0x9A, 0xF8, 0x02, 0x70, 0x9A, 0xF8,
+	0x03, 0x60, 0x00, 0x78,
+	0x9A, 0xF8, 0x00, 0xB0, 0x9A, 0xF8, 0x01, 0x50, 0x40, 0x1E, 0x87, 0x42,
+	0x01, 0xDA, 0x7F, 0x1C,
+	0xFF, 0xB2, 0x0E, 0xB1, 0x76, 0x1E, 0xF6, 0xB2, 0xF0, 0x49, 0x09, 0x78,
+	0x49, 0x1E, 0x8B, 0x45,
+	0x03, 0xDA, 0x0B, 0xF1, 0x01, 0x00, 0x00, 0xF0, 0xFF, 0x0B, 0x0D, 0xB1,
+	0x6D, 0x1E, 0xED, 0xB2,
+	0xB8, 0x1E, 0xC1, 0xB2, 0xD9, 0xF8, 0x08, 0x00, 0x09, 0xF0, 0xC0, 0xFE,
+	0x0B, 0x90, 0x78, 0x1E,
+	0xC1, 0xB2, 0xD9, 0xF8, 0x08, 0x00, 0x09, 0xF0, 0xB9, 0xFE, 0x04, 0x90,
+	0x39, 0x46, 0xD9, 0xF8,
+	0x08, 0x00, 0x09, 0xF0, 0xB3, 0xFE, 0x01, 0x90, 0x78, 0x1C, 0xC1, 0xB2,
+	0xD9, 0xF8, 0x08, 0x00,
+	0x09, 0xF0, 0xAC, 0xFE, 0x02, 0x90, 0xB8, 0x1C, 0xC1, 0xB2, 0xD9, 0xF8,
+	0x08, 0x00, 0x09, 0xF0,
+	0xA5, 0xFE, 0x03, 0x90, 0x39, 0x46, 0x17, 0x98, 0x09, 0xF0, 0x9A, 0xFE,
+	0x08, 0x90, 0xD4, 0x48,
+	0x39, 0x46, 0x00, 0x68, 0x09, 0xF0, 0xA2, 0xFE, 0x86, 0x46, 0x00, 0x20,
+	0x7A, 0xB2, 0xD4, 0x4F,
+	0x0C, 0x90, 0xB7, 0xE0, 0x4F, 0xFA, 0x8B, 0xF0, 0x94, 0xE0, 0x00, 0x21,
+	0x0E, 0xF8, 0x00, 0x10,
+	0x08, 0x99, 0x18, 0x9B, 0x09, 0x5C, 0x99, 0x42, 0x75, 0xD1, 0xDF, 0xF8,
+	0x28, 0xC3, 0x01, 0x9B,
+	0xDC, 0xF8, 0x00, 0xC0, 0x33, 0xF9, 0x10, 0x30, 0xBC, 0xF8, 0x4D, 0xC4,
+	0x63, 0x45, 0x6A, 0xDA,
+	0x00, 0x21, 0x14, 0x91, 0x13, 0x91, 0x11, 0x99, 0x19, 0x44, 0x04, 0x9B,
+	0x09, 0xB2, 0x33, 0xF9,
+	0x10, 0x30, 0x10, 0x93, 0x8B, 0x42, 0x06, 0xDD, 0x02, 0x9B, 0x33, 0xF9,
+	0x10, 0x30, 0x8B, 0x42,
+	0x01, 0xDD, 0x01, 0x23, 0x13, 0x93, 0x01, 0x9B, 0x03, 0xEB, 0x40, 0x03,
+	0x33, 0xF9, 0x02, 0x8C,
+	0x88, 0x45, 0x07, 0xDD, 0xB3, 0xF9, 0x02, 0xC0, 0x8C, 0x45, 0x03, 0xDD,
+	0x4F, 0xF0, 0x01, 0x0C,
+	0xCD, 0xF8, 0x50, 0xC0, 0x01, 0x2A, 0x0F, 0xDD, 0xDD, 0xF8, 0x2C, 0xC0,
+	0x3C, 0xF9, 0x10, 0xC0,
+	0x8C, 0x45, 0x09, 0xDD, 0xDD, 0xF8, 0x08, 0xC0, 0x3C, 0xF9, 0x10, 0xC0,
+	0x8C, 0x45, 0x03, 0xDD,
+	0x4F, 0xF0, 0x01, 0x0C, 0xCD, 0xF8, 0x4C, 0xC0, 0xDF, 0xF8, 0xAC, 0xC2,
+	0x9C, 0xF8, 0x00, 0xC0,
+	0xAC, 0xF1, 0x02, 0x0C, 0x62, 0x45, 0x0D, 0xDA, 0xDD, 0xF8, 0x40, 0xC0,
+	0x8C, 0x45, 0x09, 0xDD,
+	0xDD, 0xF8, 0x0C, 0xC0, 0x3C, 0xF9, 0x10, 0xC0, 0x8C, 0x45, 0x03, 0xDD,
+	0x4F, 0xF0, 0x01, 0x0C,
+	0xCD, 0xF8, 0x4C, 0xC0, 0x01, 0x28, 0x0B, 0xDD, 0x33, 0xF9, 0x04, 0xCC,
+	0x8C, 0x45, 0x07, 0xDD,
+	0xB3, 0xF9, 0x02, 0xC0, 0x8C, 0x45, 0x03, 0xDD, 0x4F, 0xF0, 0x01, 0x0C,
+	0xCD, 0xF8, 0x50, 0xC0,
+	0xDF, 0xF8, 0x68, 0xC2, 0x9C, 0xF8, 0x00, 0xC0, 0xAC, 0xF1, 0x02, 0x0C,
+	0x60, 0x45, 0x05, 0xDA,
+	0x88, 0x45, 0x03, 0xDD, 0xB3, 0xF9, 0x04, 0x30, 0x8B, 0x42, 0x12, 0xDC,
+	0x14, 0x99, 0x81, 0xB9,
+	0x13, 0x99, 0x0D, 0xE0, 0xFF, 0xE7, 0x99, 0xB9, 0x01, 0x99, 0xB7, 0xF9,
+	0x00, 0x30, 0x31, 0xF9,
+	0x10, 0x10, 0x99, 0x42, 0x0C, 0xDA, 0x8B, 0x49, 0x09, 0x68, 0x91, 0xF8,
+	0x41, 0x14, 0xC9, 0x07,
+	0x31, 0xB1, 0x01, 0x21, 0x0E, 0xF8, 0x00, 0x10, 0x0C, 0x99, 0x49, 0x1C,
+	0x89, 0xB2, 0x0C, 0x91,
+	0x40, 0x1C, 0x40, 0xB2, 0xA8, 0x42, 0x7F, 0xF7, 0x68, 0xAF, 0x84, 0x48,
+	0x0B, 0x99, 0x0E, 0xF1,
+	0x28, 0x0E, 0x00, 0x78, 0x01, 0xEB, 0x40, 0x01, 0x0B, 0x91, 0x04, 0x99,
+	0x01, 0xEB, 0x40, 0x01,
+	0x04, 0x91, 0x01, 0x99, 0x01, 0xEB, 0x40, 0x01, 0x01, 0x91, 0x02, 0x99,
+	0x01, 0xEB, 0x40, 0x01,
+	0x02, 0x91, 0x03, 0x99, 0x01, 0xEB, 0x40, 0x00, 0x03, 0x90, 0x08, 0x98,
+	0x28, 0x30, 0x52, 0x1C,
+	0x52, 0xB2, 0x08, 0x90, 0xB2, 0x42, 0x7F, 0xF7, 0x45, 0xAF, 0x0A, 0x99,
+	0x0C, 0x98, 0x88, 0x42,
+	0x2A, 0xD9, 0x00, 0x20, 0x84, 0xF8, 0x0E, 0x01, 0xDA, 0xF8, 0x00, 0x00,
+	0x20, 0x60, 0x6C, 0x48,
+	0x00, 0x23, 0x1A, 0x46, 0x21, 0x46, 0x00, 0x68, 0x01, 0xF0, 0x22, 0xFA,
+	0x01, 0x25, 0x17, 0xE0,
+	0x04, 0xEB, 0x85, 0x00, 0x06, 0x46, 0x51, 0x46, 0x00, 0xF0, 0x53, 0xF9,
+	0x70, 0xB1, 0x04, 0xEB,
+	0x45, 0x00, 0xB0, 0xF8, 0xB4, 0x10, 0x0A, 0x98, 0x81, 0x42, 0x07, 0xD9,
+	0x30, 0x46, 0xB7, 0xF9,
+	0x00, 0x20, 0x49, 0x46, 0xFF, 0xF7, 0x64, 0xFE, 0x01, 0x28, 0x06, 0xD0,
+	0x6D, 0x1C, 0xED, 0xB2,
+	0x94, 0xF8, 0x0E, 0x01, 0xA8, 0x42, 0xE3, 0xD2, 0x00, 0x20, 0x1B, 0xB0,
+	0xBD, 0xE8, 0xF0, 0x8F,
+	0x2D, 0xE9, 0xF8, 0x4F, 0x04, 0x46, 0x55, 0x48, 0xDF, 0xF8, 0x54, 0x81,
+	0x91, 0x46, 0x8B, 0x46,
+	0x05, 0x68, 0x01, 0x22, 0x21, 0x46, 0xD8, 0xF8, 0x00, 0x00, 0x01, 0xF0,
+	0x19, 0xF9, 0x00, 0x27,
+	0xA6, 0x78, 0x4F, 0xF0, 0x01, 0x0A, 0x1D, 0xE0, 0x31, 0x46, 0xD8, 0xF8,
+	0x00, 0x00, 0x09, 0xF0,
+	0x95, 0xFD, 0x00, 0x90, 0x31, 0x46, 0xDB, 0xF8, 0x08, 0x00, 0x09, 0xF0,
+	0x87, 0xFD, 0x01, 0x46,
+	0x20, 0x78, 0x52, 0x46, 0x09, 0xE0, 0x00, 0xBF, 0x31, 0xF9, 0x10, 0xC0,
+	0xCC, 0x45, 0x02, 0xDA,
+	0x00, 0x9B, 0x01, 0x27, 0x1A, 0x54, 0x40, 0x1C, 0xC0, 0xB2, 0x63, 0x78,
+	0x83, 0x42, 0xF3, 0xD2,
+	0x76, 0x1C, 0xF6, 0xB2, 0xE0, 0x78, 0xB0, 0x42, 0xDE, 0xD2, 0x01, 0x2F,
+	0x2E, 0xD1, 0x00, 0x20,
+	0x85, 0xF8, 0x0E, 0x01, 0x20, 0x68, 0x28, 0x60, 0x00, 0x23, 0x1A, 0x46,
+	0x29, 0x46, 0xD8, 0xF8,
+	0x00, 0x00, 0x01, 0xF0, 0xBD, 0xF9, 0x01, 0x26, 0xDF, 0xF8, 0xD8, 0x80,
+	0x1A, 0xE0, 0x00, 0xBF,
+	0x05, 0xEB, 0x86, 0x07, 0x21, 0x46, 0x38, 0x46, 0x00, 0xF0, 0xEB, 0xF8,
+	0x80, 0xB1, 0x05, 0xEB,
+	0x46, 0x00, 0xB0, 0xF8, 0xB4, 0x10, 0xD8, 0xF8, 0x00, 0x00, 0x90, 0xF8,
+	0x4A, 0x04, 0x81, 0x42,
+	0x06, 0xD9, 0x38, 0x46, 0x4A, 0x46, 0x59, 0x46, 0xFF, 0xF7, 0xFA, 0xFD,
+	0x01, 0x28, 0x06, 0xD0,
+	0x76, 0x1C, 0xF6, 0xB2, 0x95, 0xF8, 0x0E, 0x01, 0xB0, 0x42, 0xE1, 0xD2,
+	0x00, 0x20, 0xBD, 0xE8,
+	0xF8, 0x8F, 0x2D, 0xE9, 0xF0, 0x41, 0x23, 0x4D, 0x0F, 0x46, 0x80, 0x46,
+	0x29, 0x68, 0x14, 0x46,
+	0x24, 0x48, 0x1E, 0x46, 0x9A, 0x69, 0xB1, 0xF8, 0x47, 0x34, 0x00, 0x78,
+	0x9A, 0x42, 0x10, 0xDC,
+	0xF2, 0x8C, 0x04, 0x2A, 0x0D, 0xD9, 0x62, 0x78, 0x23, 0x78, 0x91, 0xF8,
+	0x49, 0x14, 0xD2, 0x1A,
+	0x52, 0x1C, 0x8A, 0x42, 0x05, 0xDC, 0xE2, 0x78, 0xA3, 0x78, 0xD2, 0x1A,
+	0x52, 0x1C, 0x8A, 0x42,
+	0x02, 0xDD, 0x00, 0x20, 0xBD, 0xE8, 0xF0, 0x81, 0x00, 0x28, 0xFB, 0xD1,
+	0x14, 0x48, 0x31, 0x46,
+	0xB0, 0xF9, 0x00, 0x20, 0x20, 0x46, 0xFF, 0xF7, 0x6B, 0xFF, 0x00, 0x28,
+	0xF2, 0xD1, 0x29, 0x68,
+	0x91, 0xF8, 0x40, 0x24, 0x92, 0x07, 0xED, 0xD5, 0x91, 0xF8, 0xE0, 0x22,
+	0x52, 0x06, 0x09, 0xD5,
+	0x0D, 0x4A, 0x52, 0x78, 0x02, 0xB3, 0xB1, 0xF8, 0xF0, 0x12, 0x0C, 0x4A,
+	0x49, 0x43, 0x12, 0x68,
+	0x8A, 0x42, 0xDF, 0xDC, 0x33, 0x46, 0x22, 0x46, 0x39, 0x46, 0x11, 0xE0,
+	0x6C, 0x06, 0x10, 0x00,
+	0x54, 0x06, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00, 0xED, 0x06, 0x10, 0x00,
+	0xEE, 0x06, 0x10, 0x00,
+	0xA8, 0x06, 0x10, 0x00, 0x34, 0x06, 0x10, 0x00, 0x74, 0x07, 0x10, 0x00,
+	0x24, 0x07, 0x10, 0x00,
+	0x40, 0x46, 0xBD, 0xE8, 0xF0, 0x41, 0xE6, 0xE5, 0xB1, 0xF8, 0xEE, 0x12,
+	0xDD, 0xE7, 0x2D, 0xE9,
+	0xFF, 0x4F, 0x81, 0xB0, 0xDF, 0xF8, 0x04, 0xB1, 0xDD, 0xF8, 0x38, 0x90,
+	0x5F, 0xEA, 0x03, 0x08,
+	0x15, 0x46, 0x1C, 0xD4, 0x2C, 0x78, 0x0B, 0xEB, 0xC8, 0x0A, 0x15, 0xE0,
+	0x08, 0xF0, 0xFF, 0x01,
+	0x01, 0x98, 0x09, 0xF0, 0xD3, 0xFC, 0x00, 0x90, 0xDA, 0xE9, 0x00, 0x67,
+	0x22, 0x46, 0x01, 0x20,
+	0x00, 0x21, 0x09, 0xF0, 0x03, 0xFB, 0x06, 0x40, 0x0F, 0x40, 0x3E, 0x43,
+	0x02, 0xD1, 0x00, 0x98,
+	0x00, 0x21, 0x01, 0x55, 0x64, 0x1C, 0xE4, 0xB2, 0x68, 0x78, 0xA0, 0x42,
+	0xE6, 0xD2, 0xB9, 0xF1,
+	0x00, 0x00, 0x1E, 0xDB, 0x02, 0x46, 0xAC, 0x78, 0x01, 0x20, 0x00, 0x21,
+	0x09, 0xF0, 0xEE, 0xFA,
+	0x06, 0x46, 0x0F, 0x46, 0x4F, 0xF0, 0x00, 0x08, 0x10, 0xE0, 0x21, 0x46,
+	0x01, 0x98, 0x09, 0xF0,
+	0xAD, 0xFC, 0x0B, 0xEB, 0xC4, 0x01, 0x02, 0x46, 0xD1, 0xE9, 0x00, 0x01,
+	0x30, 0x40, 0x39, 0x40,
+	0x08, 0x43, 0x01, 0xD1, 0x02, 0xF8, 0x09, 0x80, 0x64, 0x1C, 0xE4, 0xB2,
+	0xE8, 0x78, 0xA0, 0x42,
+	0xEB, 0xD2, 0x05, 0xB0, 0xEA, 0xE6, 0x70, 0xB5, 0x1E, 0x4B, 0x1D, 0x4A,
+	0x8C, 0x69, 0x1B, 0x68,
+	0x12, 0x78, 0xB3, 0xF8, 0x47, 0x54, 0xAC, 0x42, 0x10, 0xDC, 0xCC, 0x8C,
+	0x04, 0x2C, 0x0D, 0xD9,
+	0x44, 0x78, 0x05, 0x78, 0x93, 0xF8, 0x49, 0x34, 0x64, 0x1B, 0x64, 0x1C,
+	0x9C, 0x42, 0x05, 0xDC,
+	0xC4, 0x78, 0x85, 0x78, 0x64, 0x1B, 0x64, 0x1C, 0x9C, 0x42, 0x01, 0xDD,
+	0x00, 0x22, 0x06, 0xE0,
+	0x2A, 0xB9, 0x11, 0x4A, 0xB2, 0xF9, 0x00, 0x20, 0xFF, 0xF7, 0xCA, 0xFE,
+	0x02, 0x46, 0x10, 0x46,
+	0x70, 0xBD, 0x02, 0x78, 0x0B, 0x78, 0x9A, 0x42, 0x0B, 0xD9, 0x42, 0x78,
+	0x4B, 0x78, 0x9A, 0x42,
+	0x07, 0xD2, 0x82, 0x78, 0x8B, 0x78, 0x9A, 0x42, 0x03, 0xD9, 0xC0, 0x78,
+	0xC9, 0x78, 0x88, 0x42,
+	0x01, 0xD3, 0x00, 0x20, 0x70, 0x47, 0x01, 0x20, 0x70, 0x47, 0x00, 0x00,
+	0x98, 0x46, 0x10, 0x00,
+	0x34, 0x06, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00, 0x92, 0x06, 0x10, 0x00,
+	0x70, 0xB5, 0xFE, 0x4C,
+	0x00, 0xEB, 0x43, 0x05, 0x04, 0x9E, 0x00, 0xEB, 0x83, 0x03, 0x86, 0xB1,
+	0x8E, 0x69, 0xA6, 0x60,
+	0xCE, 0x8C, 0x66, 0x80, 0x09, 0x68, 0x61, 0x61, 0xB5, 0xF8, 0xB4, 0x10,
+	0xA1, 0x80, 0x19, 0x68,
+	0xE1, 0x60, 0x90, 0xF8, 0x0E, 0x01, 0x20, 0x70, 0x10, 0x68, 0x20, 0x61,
+	0x70, 0xBD, 0xA6, 0x68,
+	0x8E, 0x61, 0x66, 0x88, 0xCE, 0x84, 0x66, 0x69, 0x0E, 0x60, 0xA1, 0x88,
+	0xA5, 0xF8, 0xB4, 0x10,
+	0xE1, 0x68, 0x19, 0x60, 0x21, 0x78, 0x80, 0xF8, 0x0E, 0x11, 0x20, 0x69,
+	0x10, 0x60, 0x70, 0xBD,
+	0x2D, 0xE9, 0xF0, 0x47, 0xE9, 0x4D, 0x81, 0x46, 0xE9, 0x4F, 0x28, 0x68,
+	0x1C, 0x46, 0x16, 0x46,
+	0x90, 0xF8, 0x30, 0x02, 0x88, 0x46, 0x00, 0x07, 0x07, 0xD5, 0x38, 0x78,
+	0x01, 0x28, 0x04, 0xD0,
+	0x48, 0x46, 0xF9, 0xF7, 0xAF, 0xF8, 0x00, 0x28, 0x40, 0xD0, 0x28, 0x68,
+	0x90, 0xF8, 0x30, 0x02,
+	0x00, 0x06, 0x0A, 0xD5, 0x38, 0x78, 0x01, 0x28, 0x07, 0xD0, 0xDE, 0x48,
+	0x00, 0x78, 0x20, 0xB1,
+	0x30, 0x46, 0xF9, 0xF7, 0xF1, 0xF8, 0x00, 0x28, 0x30, 0xD0, 0xDB, 0x4B,
+	0x32, 0x46, 0x41, 0x46,
+	0x48, 0x46, 0x00, 0xF0, 0x34, 0xFF, 0x00, 0x28, 0x28, 0xD0, 0x94, 0xF8,
+	0x40, 0x00, 0x03, 0x28,
+	0x08, 0xD1, 0x29, 0x68, 0xE0, 0x8C, 0x91, 0xF8, 0x07, 0x13, 0x88, 0x42,
+	0x02, 0xD9, 0x04, 0x20,
+	0x84, 0xF8, 0x40, 0x00, 0x30, 0x68, 0xC4, 0xF8, 0x36, 0x00, 0x04, 0xF1,
+	0x44, 0x02, 0x51, 0x1E,
+	0x30, 0x46, 0xF8, 0xF7, 0xBE, 0xF9, 0x22, 0x46, 0x31, 0x46, 0xCB, 0x48,
+	0x00, 0xF0, 0x7A, 0xFD,
+	0x31, 0x46, 0xC9, 0x48, 0x00, 0xF0, 0xAC, 0xFE, 0x22, 0x46, 0x31, 0x46,
+	0xC6, 0x48, 0xFF, 0xF7,
+	0xE6, 0xFB, 0x20, 0x46, 0xBD, 0xE8, 0xF0, 0x47, 0xFE, 0xF7, 0xD7, 0xB9,
+	0xBD, 0xE8, 0xF0, 0x87,
+	0x2D, 0xE9, 0xF0, 0x41, 0x0D, 0x46, 0x1F, 0x46, 0x16, 0x46, 0x04, 0x46,
+	0x48, 0x21, 0x09, 0xF0,
+	0xDD, 0xFA, 0x00, 0x20, 0x84, 0xF8, 0x40, 0x00, 0xBC, 0x48, 0x00, 0x68,
+	0x60, 0x60, 0xA0, 0x60,
+	0x06, 0xEB, 0x45, 0x00, 0x84, 0xF8, 0x42, 0x50, 0x30, 0xF8, 0xB4, 0x1F,
+	0x61, 0x85, 0x00, 0x88,
+	0xE0, 0x84, 0x06, 0xEB, 0x85, 0x00, 0x00, 0x68, 0xC4, 0xF8, 0x3A, 0x00,
+	0xAE, 0x48, 0x81, 0x69,
+	0x21, 0x60, 0x01, 0x21, 0xA9, 0x40, 0x39, 0x42, 0x01, 0xD0, 0x40, 0x6A,
+	0x20, 0x60, 0xBD, 0xE8,
+	0xF0, 0x81, 0x2D, 0xE9, 0xF0, 0x47, 0x89, 0x46, 0x1C, 0x46, 0x16, 0x46,
+	0xAC, 0x4D, 0x03, 0xF1,
+	0x3E, 0x08, 0x91, 0x78, 0x09, 0xF0, 0x94, 0xFB, 0x07, 0x46, 0xB1, 0x78,
+	0x60, 0x68, 0x09, 0xF0,
+	0x95, 0xFB, 0x02, 0x46, 0x00, 0x20, 0xA0, 0x61, 0xB1, 0x78, 0x1F, 0xE0,
+	0x30, 0x78, 0x13, 0xE0,
+	0x17, 0xF8, 0x00, 0xC0, 0xCC, 0x45, 0x0D, 0xD1, 0x32, 0xF9, 0x10, 0x30,
+	0xD4, 0xF8, 0x18, 0xC0,
+	0xAB, 0x42, 0x9C, 0x44, 0xC4, 0xF8, 0x18, 0xC0, 0x04, 0xDD, 0x88, 0xF8,
+	0x00, 0x00, 0x1D, 0x46,
+	0x88, 0xF8, 0x01, 0x10, 0x40, 0x1C, 0xC0, 0xB2, 0x73, 0x78, 0x83, 0x42,
+	0xE8, 0xD2, 0x99, 0x48,
+	0x49, 0x1C, 0xC9, 0xB2, 0x00, 0x78, 0x28, 0x37, 0x02, 0xEB, 0x40, 0x02,
+	0xF0, 0x78, 0x88, 0x42,
+	0xDC, 0xD2, 0x65, 0x86, 0x9A, 0xE7, 0x2D, 0xE9, 0xFF, 0x4F, 0x81, 0xB0,
+	0x0C, 0x46, 0x1E, 0x46,
+	0x99, 0x78, 0xDD, 0xF8, 0x40, 0x80, 0x0E, 0x9D, 0x09, 0xF0, 0x68, 0xFB,
+	0x00, 0x90, 0xB1, 0x78,
+	0x20, 0x46, 0x09, 0xF0, 0x55, 0xFB, 0x83, 0x46, 0xB1, 0x78, 0xD8, 0xF8,
+	0x04, 0x00, 0x09, 0xF0,
+	0x55, 0xFB, 0x81, 0x46, 0x88, 0x48, 0x4F, 0xF0, 0x00, 0x0A, 0xC8, 0xF8,
+	0x18, 0xA0, 0x00, 0x68,
+	0x28, 0x60, 0xB7, 0x78, 0x42, 0xE0, 0x34, 0x78, 0x32, 0xE0, 0x00, 0xBF,
+	0x1B, 0xF8, 0x04, 0x10,
+	0x03, 0x98, 0x81, 0x42, 0x2A, 0xD1, 0x39, 0xF9, 0x14, 0x10, 0x0F, 0x98,
+	0x81, 0x42, 0x22, 0xDD,
+	0x00, 0x99, 0x03, 0x98, 0x08, 0x55, 0x29, 0x78, 0x20, 0x46, 0x05, 0xF0,
+	0x35, 0xFA, 0x28, 0x70,
+	0x69, 0x78, 0x20, 0x46, 0x05, 0xF0, 0x34, 0xFA, 0x68, 0x70, 0xA9, 0x78,
+	0x38, 0x46, 0x05, 0xF0,
+	0x2B, 0xFA, 0xA8, 0x70, 0xE9, 0x78, 0x38, 0x46, 0x05, 0xF0, 0x2A, 0xFA,
+	0xE8, 0x70, 0x0A, 0xF1,
+	0x01, 0x00, 0x1F, 0xFA, 0x80, 0xFA, 0x39, 0xF9, 0x14, 0x00, 0xD8, 0xF8,
+	0x18, 0x10, 0x01, 0x44,
+	0xC8, 0xF8, 0x18, 0x10, 0x02, 0xE0, 0x00, 0x99, 0x00, 0x20, 0x08, 0x55,
+	0x64, 0x1C, 0xE4, 0xB2,
+	0x70, 0x78, 0xA0, 0x42, 0xCA, 0xD2, 0x00, 0x98, 0x66, 0x49, 0x28, 0x30,
+	0x00, 0x90, 0x09, 0x78,
+	0x7F, 0x1C, 0x0B, 0xF1, 0x28, 0x0B, 0x09, 0xEB, 0x41, 0x09, 0xFF, 0xB2,
+	0xF0, 0x78, 0xB8, 0x42,
+	0xB9, 0xD2, 0xA8, 0xF8, 0x26, 0xA0, 0x05, 0xB0, 0xBD, 0xE8, 0xF0, 0x8F,
+	0x2D, 0xE9, 0xFF, 0x41,
+	0x17, 0x46, 0x0A, 0xAA, 0x80, 0x46, 0x92, 0xE8, 0x31, 0x00, 0x5C, 0x4A,
+	0x1E, 0x46, 0xB2, 0xF9,
+	0x00, 0x20, 0x82, 0x42, 0x02, 0xDB, 0x00, 0x20, 0x04, 0xB0, 0x48, 0xE7,
+	0x03, 0xAA, 0xCD, 0xE9,
+	0x00, 0x20, 0x02, 0x94, 0x3A, 0x46, 0x40, 0x46, 0xFF, 0xF7, 0x7D, 0xFF,
+	0x01, 0x21, 0x28, 0x68,
+	0xB9, 0x40, 0x08, 0x43, 0x28, 0x60, 0xC4, 0xF8, 0x00, 0x80, 0xE0, 0x8C,
+	0x10, 0xB1, 0x03, 0x98,
+	0x30, 0x60, 0xE8, 0xE7, 0x01, 0x20, 0xE7, 0xE7, 0x2D, 0xE9, 0xFF, 0x4F,
+	0x81, 0xB0, 0x90, 0x46,
+	0x0E, 0x9C, 0x8B, 0x46, 0x04, 0xEB, 0x88, 0x00, 0x94, 0xF8, 0x0E, 0x71,
+	0xDD, 0xF8, 0x40, 0xA0,
+	0x00, 0x68, 0x1E, 0x46, 0x20, 0x60, 0x01, 0x23, 0x21, 0x46, 0x58, 0x46,
+	0x00, 0xF0, 0x20, 0xFF,
+	0x01, 0x98, 0x58, 0x45, 0x1F, 0xD0, 0xB5, 0x78, 0x1A, 0xE0, 0x29, 0x46,
+	0x01, 0x98, 0x09, 0xF0,
+	0xC5, 0xFA, 0x81, 0x46, 0x29, 0x46, 0x58, 0x46, 0x09, 0xF0, 0xC0, 0xFA,
+	0x01, 0x46, 0x30, 0x78,
+	0x09, 0xE0, 0x00, 0xBF, 0x19, 0xF8, 0x00, 0x30, 0x43, 0x45, 0x02, 0xD1,
+	0x0B, 0x5C, 0x09, 0xF8,
+	0x00, 0x30, 0x40, 0x1C, 0xC0, 0xB2, 0x72, 0x78, 0x82, 0x42, 0xF3, 0xD2,
+	0x6D, 0x1C, 0xED, 0xB2,
+	0xF0, 0x78, 0xA8, 0x42, 0xE1, 0xD2, 0x94, 0xF8, 0x0E, 0x01, 0x00, 0x25,
+	0x01, 0x21, 0xB8, 0x42,
+	0x12, 0xD0, 0x11, 0x98, 0x78, 0xB1, 0x7F, 0x1C, 0xF8, 0xB2, 0x08, 0xE0,
+	0xDA, 0xF8, 0x00, 0x20,
+	0x01, 0xFA, 0x00, 0xF3, 0x1A, 0x43, 0x40, 0x1C, 0xC0, 0xB2, 0xCA, 0xF8,
+	0x00, 0x20, 0x94, 0xF8,
+	0x0E, 0x21, 0x82, 0x42, 0xF2, 0xD2, 0x01, 0x25, 0x00, 0x91, 0x43, 0x46,
+	0x52, 0x46, 0x20, 0x46,
+	0x0F, 0x99, 0xFF, 0xF7, 0x33, 0xFE, 0x28, 0x46, 0x7D, 0xE7, 0x10, 0xB5,
+	0x17, 0x4A, 0x20, 0x4C,
+	0x13, 0x68, 0x64, 0x78, 0x93, 0xF8, 0x06, 0x23, 0x4C, 0xB1, 0x91, 0xF8,
+	0x24, 0x10, 0x09, 0x07,
+	0x02, 0xD5, 0x93, 0xF8, 0x09, 0x13, 0x01, 0xE0, 0x93, 0xF8, 0x08, 0x13,
+	0x0A, 0x44, 0x90, 0x42,
+	0x01, 0xD9, 0x01, 0x20, 0x10, 0xBD, 0x00, 0x20, 0x10, 0xBD, 0x2D, 0xE9,
+	0xF0, 0x47, 0x1C, 0x46,
+	0x17, 0x46, 0x88, 0x46, 0x81, 0x46, 0x01, 0xF0, 0xED, 0xF8, 0x08, 0x4E,
+	0xE1, 0x8C, 0x30, 0x68,
+	0x90, 0xF8, 0x0E, 0x23, 0x91, 0x42, 0x7C, 0xD8, 0x03, 0x21, 0x84, 0xF8,
+	0x40, 0x10, 0x90, 0xF8,
+	0xE0, 0x12, 0x00, 0x25, 0x8A, 0x07, 0x15, 0xE0, 0x38, 0x06, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0x66, 0x05, 0x10, 0x00, 0xF4, 0x06, 0x10, 0x00, 0xF0, 0x45, 0x10, 0x00,
+	0x10, 0x07, 0x10, 0x00,
+	0x00, 0x80, 0xFF, 0xFF, 0xEE, 0x06, 0x10, 0x00, 0x36, 0x7A, 0x01, 0x00,
+	0x9A, 0x06, 0x10, 0x00,
+	0x74, 0x07, 0x10, 0x00, 0x01, 0xD4, 0x49, 0x07, 0x00, 0xD5, 0x01, 0x25,
+	0xFF, 0x4A, 0xB0, 0xF8,
+	0x0A, 0x13, 0x52, 0x78, 0x22, 0xB1, 0xFE, 0x4A, 0x12, 0x78, 0x0A, 0xB9,
+	0xB0, 0xF8, 0x0C, 0x13,
+	0xA2, 0x8D, 0x8A, 0x42, 0x02, 0xD2, 0xFB, 0x49, 0x09, 0x78, 0x21, 0xB1,
+	0x61, 0x8D, 0x03, 0x29,
+	0x06, 0xD2, 0x00, 0x25, 0x2C, 0xE0, 0x61, 0x8D, 0x00, 0x25, 0x03, 0x29,
+	0xF9, 0xD3, 0x27, 0xE0,
+	0x35, 0xB3, 0x90, 0xF8, 0x40, 0x04, 0xC1, 0x07, 0x0D, 0xD0, 0x40, 0x07,
+	0x0B, 0xD5, 0x21, 0x46,
+	0x38, 0x46, 0xFF, 0xF7, 0x80, 0xFD, 0xF0, 0x49, 0x08, 0x70, 0x20, 0xB1,
+	0xA0, 0x8C, 0x40, 0xF0,
+	0x80, 0x00, 0xA0, 0x84, 0xE5, 0xE7, 0x30, 0x68, 0x90, 0xF8, 0x20, 0x04,
+	0xC0, 0x07, 0x0F, 0xD0,
+	0xEA, 0x48, 0xEB, 0x49, 0xB0, 0xF9, 0x00, 0x00, 0xB1, 0xF9, 0x00, 0x10,
+	0x88, 0x42, 0x07, 0xDB,
+	0x23, 0x46, 0x3A, 0x46, 0x41, 0x46, 0x48, 0x46, 0x02, 0xF0, 0x4D, 0xF9,
+	0x01, 0x28, 0x04, 0xD0,
+	0xA0, 0x8C, 0x10, 0xF4, 0xC0, 0x7F, 0x19, 0xD1, 0x04, 0xE0, 0xA0, 0x8C,
+	0x40, 0xF4, 0x80, 0x70,
+	0xA0, 0x84, 0x13, 0xE0, 0x95, 0xB1, 0x30, 0x68, 0x90, 0xF8, 0xE0, 0x02,
+	0xC0, 0x07, 0x03, 0xD0,
+	0x21, 0x46, 0x38, 0x46, 0x01, 0xF0, 0x3B, 0xFA, 0x23, 0x46, 0x3A, 0x46,
+	0x41, 0x46, 0x48, 0x46,
+	0x00, 0xE0, 0x0A, 0xE0, 0xBD, 0xE8, 0xF0, 0x47, 0x01, 0xF0, 0xFD, 0xBF,
+	0x23, 0x46, 0x3A, 0x46,
+	0x41, 0x46, 0x48, 0x46, 0xBD, 0xE8, 0xF0, 0x47, 0xAA, 0xE5, 0x04, 0x20,
+	0x84, 0xF8, 0x40, 0x00,
+	0xF4, 0xE7, 0xD0, 0x48, 0x00, 0x78, 0x80, 0x07, 0x0B, 0xD5, 0xCF, 0x48,
+	0xCF, 0x4A, 0x00, 0x68,
+	0x12, 0x68, 0x90, 0xF8, 0x57, 0x13, 0x91, 0x42, 0x05, 0xD2, 0x90, 0xF8,
+	0x40, 0x03, 0x80, 0x07,
+	0x01, 0xD5, 0x00, 0x20, 0x70, 0x47, 0x01, 0x20, 0x70, 0x47, 0x91, 0xF8,
+	0x24, 0x10, 0xC6, 0x4A,
+	0xCB, 0x07, 0xC7, 0x49, 0x12, 0x68, 0x09, 0x78, 0x06, 0xD0, 0x11, 0xB1,
+	0x92, 0xF8, 0x48, 0x13,
+	0x05, 0xE0, 0x92, 0xF8, 0x49, 0x13, 0x02, 0xE0, 0x59, 0xB1, 0x92, 0xF8,
+	0x46, 0x13, 0xB7, 0x4B,
+	0x5B, 0x78, 0x13, 0xB1, 0x92, 0xF8, 0x4A, 0x23, 0x11, 0x44, 0x88, 0x42,
+	0x04, 0xD9, 0x01, 0x20,
+	0x70, 0x47, 0x92, 0xF8, 0x47, 0x13, 0xF2, 0xE7, 0x00, 0x20, 0x70, 0x47,
+	0x2D, 0xE9, 0xFF, 0x4F,
+	0xB8, 0x48, 0xDF, 0xF8, 0xD4, 0x92, 0x87, 0xB0, 0xB0, 0xF9, 0x00, 0x80,
+	0xD9, 0xF8, 0x00, 0x00,
+	0x0C, 0x46, 0x00, 0x26, 0x90, 0xF8, 0x40, 0x04, 0xDF, 0xF8, 0xCC, 0xB2,
+	0xC1, 0x07, 0x14, 0x98,
+	0x4F, 0xF0, 0x01, 0x07, 0x15, 0x46, 0x07, 0xFA, 0x00, 0xF7, 0xB2, 0x46,
+	0x3A, 0xD0, 0xAF, 0x49,
+	0xA7, 0x4A, 0xB1, 0xF9, 0x00, 0x00, 0xB2, 0xF9, 0x00, 0x20, 0x90, 0x42,
+	0x32, 0xDA, 0x2A, 0x68,
+	0x3A, 0x42, 0x2F, 0xD1, 0xE2, 0x8C, 0x04, 0x2A, 0x2C, 0xD9, 0x8D, 0xE8,
+	0x31, 0x00, 0x0A, 0x9B,
+	0x14, 0x9A, 0xDB, 0xF8, 0x18, 0x10, 0xDB, 0xF8, 0x24, 0x00, 0xFF, 0xF7,
+	0x67, 0xFE, 0x06, 0x00,
+	0x20, 0xD1, 0x23, 0x46, 0x20, 0x68, 0x0A, 0x9A, 0x14, 0x99, 0xFF, 0xF7,
+	0x22, 0xFC, 0x96, 0x49,
+	0x08, 0x70, 0xA0, 0xB1, 0x70, 0x1E, 0x8D, 0xF8, 0x10, 0x00, 0x8D, 0xF8,
+	0x14, 0x00, 0xD9, 0xF8,
+	0x00, 0x00, 0x90, 0xF8, 0x41, 0x04, 0x80, 0x07, 0x05, 0xD5, 0x05, 0xAA,
+	0x04, 0xA9, 0x0A, 0x98,
+	0xF7, 0xF7, 0x93, 0xFF, 0xA8, 0xB3, 0xA0, 0x8C, 0x40, 0xF0, 0x80, 0x00,
+	0xA0, 0x84, 0x93, 0x48,
+	0xB0, 0xF9, 0x00, 0x80, 0xD9, 0xF8, 0x00, 0x00, 0x90, 0xF8, 0x20, 0x04,
+	0xC0, 0x07, 0x53, 0xD0,
+	0x94, 0xF8, 0x24, 0x00, 0x00, 0x06, 0x4F, 0xD4, 0x84, 0x48, 0x85, 0x4A,
+	0xB0, 0xF9, 0x00, 0x10,
+	0xB2, 0xF9, 0x00, 0x20, 0x91, 0x42, 0x47, 0xDA, 0x81, 0x46, 0x41, 0x45,
+	0x17, 0xD0, 0x28, 0x68,
+	0x38, 0x42, 0x07, 0xD0, 0xCD, 0xF8, 0x00, 0xA0, 0x2A, 0x46, 0x21, 0x46,
+	0x14, 0x9B, 0x07, 0x98,
+	0xFF, 0xF7, 0xD4, 0xFC, 0xB9, 0xF9, 0x00, 0x00, 0x8D, 0xE8, 0x31, 0x00,
+	0x0A, 0x9B, 0x14, 0x9A,
+	0xDB, 0xF8, 0x18, 0x10, 0xDB, 0xF8, 0x24, 0x00, 0xFF, 0xF7, 0x18, 0xFE,
+	0x06, 0x46, 0xFE, 0xB1,
+	0x2A, 0xE0, 0xFF, 0xE7, 0x7A, 0x49, 0x9D, 0xF9, 0x10, 0x30, 0x01, 0xF8,
+	0x36, 0x3F, 0x9D, 0xF9,
+	0x14, 0x00, 0x48, 0x70, 0x00, 0x90, 0x20, 0x68, 0x0A, 0x9A, 0x07, 0x99,
+	0xFF, 0xF7, 0x27, 0xFC,
+	0x07, 0x98, 0x04, 0xF1, 0x3A, 0x03, 0x8D, 0xE8, 0x31, 0x04, 0x21, 0x68,
+	0x14, 0x9A, 0xDB, 0xF8,
+	0x18, 0x00, 0xFF, 0xF7, 0x21, 0xFE, 0x00, 0x28, 0xB1, 0xD0, 0x01, 0x20,
+	0x0B, 0xB0, 0xF3, 0xE5,
+	0x23, 0x46, 0x20, 0x68, 0x0A, 0x9A, 0x14, 0x99, 0x02, 0xF0, 0x45, 0xF8,
+	0x01, 0x28, 0x03, 0xD1,
+	0xA0, 0x8C, 0x40, 0xF4, 0x80, 0x70, 0xA0, 0x84, 0xA0, 0x8C, 0x10, 0xF4,
+	0xC0, 0x7F, 0x0A, 0xD1,
+	0x28, 0x68, 0x38, 0x42, 0x07, 0xD0, 0xCD, 0xF8, 0x00, 0xA0, 0x2A, 0x46,
+	0x21, 0x46, 0x14, 0x9B,
+	0x07, 0x98, 0xFF, 0xF7, 0x8B, 0xFC, 0x30, 0x46, 0xE0, 0xE7, 0x2D, 0xE9,
+	0xF0, 0x4F, 0x5D, 0x49,
+	0x53, 0x48, 0xE7, 0xB0, 0xB1, 0xF9, 0x00, 0x10, 0xB0, 0xF9, 0x00, 0x00,
+	0x4F, 0xF0, 0x00, 0x08,
+	0xCD, 0xE9, 0x62, 0x01, 0x54, 0x48, 0xC3, 0x46, 0xC1, 0x46, 0x47, 0x46,
+	0x01, 0x21, 0x1C, 0x30,
+	0x02, 0xF0, 0x0D, 0xFC, 0x50, 0x48, 0x01, 0x21, 0x24, 0x30, 0x02, 0xF0,
+	0x08, 0xFC, 0x4E, 0x48,
+	0x02, 0x21, 0x20, 0x30, 0x02, 0xF0, 0x03, 0xFC, 0x02, 0x21, 0x4F, 0x48,
+	0x02, 0xF0, 0xA7, 0xFB,
+	0x04, 0x21, 0x4E, 0x48, 0x02, 0xF0, 0xA3, 0xFB, 0x47, 0x4C, 0x4F, 0xF4,
+	0x66, 0x75, 0x29, 0x46,
+	0xE0, 0x69, 0x08, 0xF0, 0xA1, 0xFF, 0x29, 0x46, 0x60, 0x6A, 0x08, 0xF0,
+	0x9D, 0xFF, 0x48, 0x48,
+	0xB0, 0xF9, 0x00, 0x00, 0x41, 0x00, 0x20, 0x6A, 0x08, 0xF0, 0x96, 0xFF,
+	0x29, 0x46, 0x45, 0x48,
+	0x08, 0xF0, 0x92, 0xFF, 0x4F, 0xF0, 0x00, 0x0A, 0x55, 0x46, 0x84, 0xF8,
+	0x01, 0xA0, 0xF8, 0xF7,
+	0xFB, 0xFC, 0xF7, 0xF7, 0x41, 0xFE, 0x40, 0x48, 0x8D, 0xF8, 0x72, 0x51,
+	0x01, 0x23, 0x00, 0x68,
+	0x19, 0x90, 0x00, 0x22, 0x19, 0xA9, 0xA0, 0x69, 0x00, 0xF0, 0xE2, 0xFC,
+	0x3B, 0x48, 0x5D, 0x95,
+	0x00, 0x26, 0xB0, 0xF9, 0x00, 0x10, 0x2A, 0x48, 0xB0, 0xF9, 0x00, 0x00,
+	0x04, 0xF0, 0x7C, 0xFF,
+	0x00, 0xB2, 0x06, 0x90, 0x9D, 0xF8, 0x72, 0x01, 0x01, 0x28, 0x02, 0xD9,
+	0x22, 0x49, 0x81, 0xF8,
+	0x00, 0xA0, 0x0D, 0xF1, 0x56, 0x00, 0x01, 0x25, 0x60, 0x90, 0x9B, 0xE1,
+	0x00, 0x20, 0x01, 0x90,
+	0x19, 0xA8, 0x00, 0xEB, 0x85, 0x00, 0x05, 0x90, 0x19, 0xAA, 0x29, 0x46,
+	0x07, 0xA8, 0x5D, 0x9B,
+	0xFF, 0xF7, 0x96, 0xFC, 0x07, 0xAB, 0x29, 0x46, 0x05, 0x9A, 0x07, 0x98,
+	0xFF, 0xF7, 0xB9, 0xFC,
+	0x01, 0x24, 0x2B, 0x46, 0x5D, 0xAA, 0x07, 0xA9, 0x19, 0xA8, 0x00, 0x94,
+	0xFF, 0xF7, 0x06, 0xFC,
+	0x0D, 0xF1, 0x5A, 0x00, 0x00, 0xF0, 0xFE, 0xFA, 0x78, 0xB1, 0xBD, 0xF8,
+	0x40, 0x00, 0x40, 0xF0,
+	0x01, 0x00, 0xAD, 0xF8, 0x40, 0x00, 0x07, 0xA8, 0x00, 0xF0, 0x41, 0xFC,
+	0x28, 0xB1, 0x1C, 0x48,
+	0x14, 0x49, 0x00, 0x88, 0x08, 0x80, 0x0A, 0x49, 0x08, 0x80, 0x06, 0x48,
+	0x00, 0x78, 0x88, 0xB3,
+	0xBD, 0xF8, 0x40, 0x00, 0x10, 0xF0, 0x06, 0x0F, 0x30, 0xD1, 0x2C, 0xE0,
+	0x74, 0x07, 0x10, 0x00,
+	0xFD, 0x06, 0x10, 0x00, 0xA4, 0x06, 0x10, 0x00, 0x34, 0x06, 0x10, 0x00,
+	0xA6, 0x06, 0x10, 0x00,
+	0x92, 0x06, 0x10, 0x00, 0x04, 0x07, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x80, 0x06, 0x10, 0x00,
+	0xF9, 0x06, 0x10, 0x00, 0x9A, 0x06, 0x10, 0x00, 0x38, 0x06, 0x10, 0x00,
+	0xA8, 0x06, 0x10, 0x00,
+	0x0A, 0x44, 0x01, 0x20, 0x94, 0x06, 0x10, 0x00, 0x60, 0x06, 0x10, 0x00,
+	0x6C, 0x06, 0x10, 0x00,
+	0xFE, 0x06, 0x10, 0x00, 0xC2, 0x18, 0x01, 0x20, 0x88, 0x06, 0x10, 0x00,
+	0xAC, 0x06, 0x10, 0x00,
+	0xA2, 0x06, 0x10, 0x00, 0x02, 0xE0, 0xFE, 0x48, 0x00, 0x68, 0x08, 0x90,
+	0x05, 0x98, 0x00, 0xF0,
+	0xC3, 0xFA, 0x28, 0xB1, 0xBD, 0xF8, 0x40, 0x00, 0x40, 0xF0, 0x08, 0x00,
+	0xAD, 0xF8, 0x40, 0x00,
+	0x01, 0x24, 0x5D, 0x98, 0xAC, 0x40, 0x04, 0x42, 0x41, 0xD1, 0xF6, 0x48,
+	0x00, 0x78, 0xC0, 0x07,
+	0x3D, 0xD0, 0xF5, 0x48, 0x00, 0x68, 0x90, 0xF8, 0x28, 0x13, 0xF4, 0x48,
+	0x00, 0x68, 0x81, 0x42,
+	0xF3, 0x48, 0x40, 0x78, 0x01, 0xD2, 0x90, 0xBB, 0x01, 0xE0, 0x02, 0x28,
+	0x2F, 0xD2, 0xF1, 0x48,
+	0x5D, 0xAA, 0x07, 0xA9, 0xB0, 0xF9, 0x00, 0x00, 0x8D, 0xE8, 0x07, 0x00,
+	0xEE, 0x48, 0x2A, 0x46,
+	0x05, 0x9B, 0x81, 0x69, 0x40, 0x6A, 0xFF, 0xF7, 0xD9, 0xFC, 0x01, 0x90,
+	0xB8, 0xB9, 0x07, 0xAB,
+	0x29, 0x46, 0x05, 0x9A, 0x07, 0x98, 0x00, 0xF0, 0xA6, 0xF9, 0x80, 0xB1,
+	0x4F, 0xF0, 0x02, 0x0C,
+	0x8D, 0xF8, 0x5C, 0xC0, 0x29, 0x46, 0x07, 0xAB, 0x05, 0x9A, 0x07, 0x98,
+	0xAD, 0xF8, 0x4A, 0xC0,
+	0xAD, 0xF8, 0x4C, 0xC0, 0xFF, 0xF7, 0x9C, 0xFB, 0x4F, 0xF0, 0x01, 0x0B,
+	0xCF, 0xE0, 0x2B, 0x46,
+	0x5D, 0xAA, 0x07, 0xA9, 0x19, 0xA8, 0xCD, 0xF8, 0x00, 0xA0, 0xFF, 0xF7,
+	0x67, 0xFB, 0xBD, 0xF9,
+	0x4E, 0x00, 0x06, 0x99, 0x88, 0x42, 0x6A, 0xDD, 0x00, 0x95, 0x5D, 0xAA,
+	0x07, 0xA9, 0x19, 0xA8,
+	0x05, 0x9B, 0xFF, 0xF7, 0x13, 0xFE, 0x00, 0x28, 0x7E, 0xD1, 0x5D, 0x98,
+	0x04, 0x42, 0x3A, 0xD1,
+	0xBD, 0xF8, 0x40, 0x00, 0x10, 0xF4, 0xC0, 0x7F, 0x35, 0xD1, 0xD0, 0x48,
+	0x5D, 0xAA, 0x07, 0xA9,
+	0xB0, 0xF9, 0x00, 0x00, 0x8D, 0xE8, 0x07, 0x00, 0xCB, 0x48, 0x2A, 0x46,
+	0x05, 0x9B, 0x81, 0x69,
+	0x40, 0x6A, 0xFF, 0xF7, 0x93, 0xFC, 0x01, 0x90, 0x5D, 0x98, 0x04, 0x42,
+	0x23, 0xD0, 0xC2, 0x48,
+	0xBD, 0xF8, 0x42, 0x20, 0x00, 0x68, 0x90, 0xF8, 0x0E, 0x33, 0x9A, 0x42,
+	0x05, 0xD8, 0x90, 0xF8,
+	0xE0, 0x02, 0x82, 0x07, 0x17, 0xD4, 0x40, 0x07, 0x15, 0xD4, 0x01, 0x23,
+	0x5D, 0xAA, 0x07, 0xA9,
+	0x19, 0xA8, 0x8D, 0xE8, 0x0F, 0x00, 0xBC, 0x48, 0x2A, 0x46, 0x60, 0x9B,
+	0x41, 0x6A, 0x80, 0x69,
+	0xFF, 0xF7, 0x9A, 0xFC, 0x01, 0x90, 0x01, 0x20, 0x00, 0x90, 0x2B, 0x46,
+	0x5D, 0xAA, 0x07, 0xA9,
+	0x19, 0xA8, 0xFF, 0xF7, 0x1B, 0xFB, 0x01, 0x98, 0xC8, 0xB9, 0xBD, 0xF8,
+	0x42, 0x00, 0x07, 0xA9,
+	0xFF, 0xF7, 0xE3, 0xFC, 0x98, 0xB1, 0x07, 0xA8, 0x00, 0x90, 0xB1, 0x48,
+	0x29, 0x46, 0x60, 0x9A,
+	0xB0, 0xF9, 0x00, 0x30, 0xAC, 0x48, 0x80, 0x69, 0x00, 0xF0, 0x84, 0xF9,
+	0x07, 0xAB, 0x29, 0x46,
+	0x05, 0x9A, 0x07, 0x98, 0xFF, 0xF7, 0xE9, 0xFC, 0x4F, 0xF0, 0x01, 0x08,
+	0x5F, 0xE0, 0x2B, 0x46,
+	0x5D, 0xAA, 0x07, 0xA9, 0x19, 0xA8, 0xCD, 0xF8, 0x00, 0xA0, 0xFF, 0xF7,
+	0xF7, 0xFA, 0xA4, 0x48,
+	0xBD, 0xF9, 0x4E, 0x10, 0xB0, 0xF9, 0x00, 0x00, 0x81, 0x42, 0x50, 0xDD,
+	0xFF, 0xF7, 0x71, 0xFD,
+	0xF0, 0xB3, 0x5D, 0x98, 0x04, 0x42, 0x2F, 0xD1, 0x9D, 0x48, 0x5D, 0xAA,
+	0x07, 0xA9, 0xB0, 0xF9,
+	0x00, 0x00, 0x8D, 0xE8, 0x07, 0x00, 0x98, 0x48, 0x2A, 0x46, 0x05, 0x9B,
+	0x81, 0x69, 0x40, 0x6A,
+	0xFF, 0xF7, 0x2C, 0xFC, 0x01, 0x90, 0x00, 0xE0, 0x52, 0xE0, 0x8F, 0x48,
+	0x00, 0x68, 0x90, 0xF8,
+	0x40, 0x03, 0xC0, 0x06, 0x18, 0xD4, 0x5D, 0x98, 0x04, 0x42, 0x15, 0xD0,
+	0x01, 0x23, 0x5D, 0xAA,
+	0x07, 0xA9, 0x19, 0xA8, 0x8D, 0xE8, 0x0F, 0x00, 0x8B, 0x48, 0x2A, 0x46,
+	0x60, 0x9B, 0x41, 0x6A,
+	0x80, 0x69, 0xFF, 0xF7, 0x39, 0xFC, 0x01, 0x90, 0x01, 0x20, 0x00, 0x90,
+	0x2B, 0x46, 0x5D, 0xAA,
+	0x07, 0xA9, 0x19, 0xA8, 0xFF, 0xF7, 0xBA, 0xFA, 0x01, 0x98, 0x80, 0xB9,
+	0xBD, 0xF8, 0x42, 0x00,
+	0x07, 0xA9, 0xFF, 0xF7, 0x4A, 0xFD, 0x50, 0xB1, 0x07, 0xAB, 0x29, 0x46,
+	0x05, 0x9A, 0x00, 0xE0,
+	0x0D, 0xE0, 0x07, 0x98, 0x00, 0xF0, 0x6F, 0xF9, 0x4F, 0xF0, 0x01, 0x09,
+	0x07, 0xE0, 0x2B, 0x46,
+	0x5D, 0xAA, 0x07, 0xA9, 0x19, 0xA8, 0xCD, 0xF8, 0x00, 0xA0, 0xFF, 0xF7,
+	0x9F, 0xFA, 0x5D, 0x99,
+	0x44, 0xEA, 0x01, 0x00, 0x73, 0x49, 0x5D, 0x90, 0x63, 0x98, 0x08, 0x80,
+	0x73, 0x49, 0x62, 0x98,
+	0x08, 0x80, 0x74, 0x48, 0x01, 0x78, 0x31, 0xB1, 0x9D, 0xF8, 0x72, 0x11,
+	0x26, 0x43, 0x01, 0x29,
+	0x01, 0xD9, 0x80, 0xF8, 0x00, 0xA0, 0xBD, 0xF8, 0x40, 0x00, 0xC0, 0x05,
+	0x00, 0xD5, 0x27, 0x43,
+	0x6D, 0x1C, 0xED, 0xB2, 0x9D, 0xF8, 0x72, 0x01, 0xA8, 0x42, 0xBF, 0xF4,
+	0x5F, 0xAE, 0x66, 0x48,
+	0x6A, 0x4A, 0x69, 0x4B, 0x41, 0x78, 0xA2, 0xF5, 0x66, 0x70, 0x01, 0xF0,
+	0x7A, 0xFC, 0x68, 0x48,
+	0x9D, 0xF8, 0x72, 0x11, 0x00, 0xF8, 0x05, 0x1F, 0x68, 0x49, 0x06, 0x83,
+	0x87, 0x83, 0x65, 0x48,
+	0x80, 0xF8, 0x00, 0xB0, 0x64, 0x48, 0x80, 0xF8, 0x00, 0x80, 0x81, 0xF8,
+	0x00, 0x90, 0x02, 0x21,
+	0x63, 0x48, 0x02, 0xF0, 0xC1, 0xF9, 0x04, 0x21, 0x62, 0x48, 0x02, 0xF0,
+	0xBD, 0xF9, 0x56, 0x48,
+	0x01, 0x21, 0x18, 0x30, 0x02, 0xF0, 0x86, 0xFA, 0x53, 0x48, 0x01, 0x21,
+	0x1C, 0x30, 0x02, 0xF0,
+	0x81, 0xFA, 0x51, 0x48, 0x01, 0x21, 0x24, 0x30, 0x02, 0xF0, 0x7C, 0xFA,
+	0x4E, 0x48, 0x02, 0x21,
+	0x20, 0x30, 0x02, 0xF0, 0x77, 0xFA, 0x67, 0xB0, 0xBD, 0xE8, 0xF0, 0x8F,
+	0x51, 0x49, 0x00, 0x20,
+	0x08, 0x70, 0x51, 0x49, 0x08, 0x70, 0x51, 0x49, 0x08, 0x70, 0x4A, 0x49,
+	0x08, 0x70, 0xA8, 0x21,
+	0x49, 0x48, 0x08, 0xF0, 0xA3, 0xBD, 0x44, 0x49, 0x00, 0x20, 0x4D, 0x4A,
+	0x08, 0x62, 0x88, 0x61,
+	0xC8, 0x61, 0x10, 0x60, 0x4B, 0x4A, 0x10, 0x60, 0x46, 0x4A, 0x10, 0x70,
+	0x46, 0x4A, 0x10, 0x70,
+	0x46, 0x4A, 0x10, 0x70, 0x3F, 0x4A, 0x10, 0x70, 0x48, 0x70, 0x70, 0x47,
+	0x3A, 0x49, 0x10, 0xB5,
+	0x00, 0x20, 0x48, 0x70, 0x4F, 0xF4, 0x66, 0x71, 0x43, 0x48, 0x08, 0xF0,
+	0x65, 0xFD, 0x3A, 0x48,
+	0xA8, 0x21, 0xA8, 0x38, 0x08, 0xF0, 0x82, 0xFD, 0xBD, 0xE8, 0x10, 0x40,
+	0xA8, 0x21, 0x36, 0x48,
+	0x08, 0xF0, 0x7C, 0xBD, 0x2D, 0xE9, 0xF7, 0x4F, 0x2F, 0x48, 0x0D, 0x46,
+	0x41, 0x78, 0x0F, 0x29,
+	0x01, 0xD2, 0x49, 0x1C, 0x41, 0x70, 0x01, 0xF0, 0xFF, 0x09, 0x30, 0x49,
+	0x82, 0xF8, 0x41, 0x90,
+	0x01, 0xEB, 0x89, 0x00, 0x29, 0x68, 0x01, 0x60, 0xA9, 0x78, 0x33, 0x48,
+	0x08, 0xF0, 0x56, 0xFE,
+	0x82, 0x46, 0xA8, 0x78, 0x19, 0xE0, 0x00, 0x98, 0x2C, 0x78, 0x00, 0xEB,
+	0xC8, 0x0B, 0x0D, 0xE0,
+	0xDB, 0xE9, 0x00, 0x67, 0x22, 0x46, 0x01, 0x20, 0x00, 0x21, 0x08, 0xF0,
+	0x7F, 0xFC, 0x06, 0x40,
+	0x0F, 0x40, 0x3E, 0x43, 0x01, 0xD0, 0x0A, 0xF8, 0x04, 0x90, 0x64, 0x1C,
+	0x68, 0x78, 0xA0, 0x42,
+	0xEE, 0xDA, 0x0A, 0xF1, 0x28, 0x0A, 0x08, 0xF1, 0x01, 0x00, 0xE9, 0x78,
+	0x80, 0x46, 0x41, 0x45,
+	0xE1, 0xDA, 0xBD, 0xE8, 0xFE, 0x8F, 0x2D, 0xE9, 0xF0, 0x41, 0x0F, 0x4C,
+	0x10, 0x4F, 0xB3, 0xF8,
+	0x26, 0xC0, 0x24, 0x68, 0x7F, 0x78, 0x00, 0x26, 0x94, 0xF8, 0x29, 0x53,
+	0x17, 0xB1, 0x94, 0xF8,
+	0x2A, 0x73, 0x3D, 0x44, 0x93, 0xF8, 0x24, 0xE0, 0x94, 0xF8, 0x2B, 0x73,
+	0x5F, 0xEA, 0xCE, 0x7E,
+	0x01, 0xD0, 0x94, 0xF8, 0x2C, 0x73, 0xAC, 0x45, 0x39, 0xD9, 0xBC, 0x45,
+	0x37, 0xD8, 0x25, 0xE0,
+	0x14, 0x07, 0x10, 0x00, 0x04, 0x07, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x7C, 0x06, 0x10, 0x00,
+	0x74, 0x07, 0x10, 0x00, 0x94, 0x06, 0x10, 0x00, 0x38, 0x06, 0x10, 0x00,
+	0x92, 0x06, 0x10, 0x00,
+	0x96, 0x06, 0x10, 0x00, 0x34, 0x06, 0x10, 0x00, 0x98, 0x46, 0x10, 0x00,
+	0x5A, 0x1C, 0x01, 0x20,
+	0x0A, 0x44, 0x01, 0x20, 0xF6, 0x06, 0x10, 0x00, 0xF7, 0x06, 0x10, 0x00,
+	0xF8, 0x06, 0x10, 0x00,
+	0x60, 0x06, 0x10, 0x00, 0x6C, 0x06, 0x10, 0x00, 0xC2, 0x18, 0x01, 0x20,
+	0x45, 0x4F, 0xB3, 0xF9,
+	0x32, 0x50, 0xB7, 0xF9, 0x00, 0x70, 0xBD, 0x42, 0x09, 0xDD, 0xB4, 0xF8,
+	0x26, 0x43, 0x9D, 0x69,
+	0xA5, 0x42, 0x04, 0xDA, 0x00, 0xF0, 0xDB, 0xFC, 0x01, 0x28, 0x00, 0xD1,
+	0x01, 0x26, 0x30, 0x46,
+	0xBD, 0xE8, 0xF0, 0x81, 0x2D, 0xE9, 0xFF, 0x5F, 0x8B, 0x46, 0x14, 0x46,
+	0x91, 0x78, 0x0E, 0x9D,
+	0x08, 0xF0, 0xC6, 0xFD, 0x06, 0x46, 0xA1, 0x78, 0x68, 0x68, 0x08, 0xF0,
+	0xC7, 0xFD, 0x07, 0x46,
+	0x4F, 0xF0, 0x00, 0x09, 0xFF, 0xF7, 0xF5, 0xFB, 0x00, 0x28, 0x32, 0xD0,
+	0x32, 0x49, 0xB5, 0xF9,
+	0x32, 0x00, 0xB1, 0xF9, 0x00, 0x10, 0x88, 0x42, 0x2B, 0xDC, 0x30, 0x48,
+	0xA1, 0x78, 0xE3, 0x78,
+	0x90, 0xF8, 0x00, 0xA0, 0x19, 0xE0, 0x20, 0x78, 0x62, 0x78, 0x0F, 0xE0,
+	0x16, 0xF8, 0x00, 0x80,
+	0xD8, 0x45, 0x09, 0xD1, 0x37, 0xF9, 0x10, 0x80, 0xDD, 0xF8, 0x0C, 0xC0,
+	0xE0, 0x45, 0x03, 0xDD,
+	0x09, 0xF1, 0x01, 0x0C, 0x1F, 0xFA, 0x8C, 0xF9, 0x40, 0x1C, 0xC0, 0xB2,
+	0x82, 0x42, 0xED, 0xD2,
+	0x49, 0x1C, 0x07, 0xEB, 0x4A, 0x07, 0xC9, 0xB2, 0x28, 0x36, 0x8B, 0x42,
+	0xE3, 0xD2, 0x29, 0x46,
+	0x48, 0x46, 0xFF, 0xF7, 0xDA, 0xFB, 0x00, 0x28, 0x03, 0xD0, 0xA8, 0x8C,
+	0x40, 0xF4, 0x00, 0x70,
+	0xA8, 0x84, 0xBD, 0xE8, 0xFF, 0x9F, 0x2D, 0xE9, 0xF0, 0x41, 0x80, 0x46,
+	0x01, 0x20, 0x83, 0xF8,
+	0x40, 0x00, 0x1C, 0x46, 0x16, 0x46, 0x0F, 0x46, 0x40, 0x46, 0x00, 0xF0,
+	0x0B, 0xFC, 0x14, 0x4D,
+	0x28, 0x68, 0x90, 0xF8, 0x40, 0x03, 0x41, 0x07, 0x04, 0xD5, 0x21, 0x46,
+	0x30, 0x46, 0x00, 0xF0,
+	0xDF, 0xFD, 0x05, 0xE0, 0x00, 0x07, 0x03, 0xD5, 0x21, 0x46, 0x30, 0x46,
+	0x00, 0xF0, 0xC7, 0xFD,
+	0x28, 0x68, 0x23, 0x46, 0x32, 0x46, 0x90, 0xF8, 0x40, 0x03, 0x39, 0x46,
+	0xC0, 0x06, 0x40, 0x46,
+	0x03, 0xD5, 0xBD, 0xE8, 0xF0, 0x41, 0x01, 0xF0, 0x86, 0xBB, 0xBD, 0xE8,
+	0xF0, 0x41, 0xFF, 0xF7,
+	0x37, 0xB9, 0x00, 0x00, 0x94, 0x06, 0x10, 0x00, 0x8C, 0x06, 0x10, 0x00,
+	0xEE, 0x06, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x01, 0x78, 0x59, 0xB1, 0x80, 0x4A, 0x12, 0x78,
+	0x52, 0x1E, 0x91, 0x42,
+	0x06, 0xD0, 0x40, 0x78, 0x20, 0xB1, 0x7E, 0x49, 0x09, 0x78, 0x49, 0x1E,
+	0x88, 0x42, 0x01, 0xD1,
+	0x01, 0x20, 0x70, 0x47, 0x00, 0x20, 0x70, 0x47, 0x01, 0x78, 0x29, 0xB1,
+	0x77, 0x49, 0x42, 0x78,
+	0x09, 0x78, 0x49, 0x1E, 0x8A, 0x42, 0x09, 0xD1, 0x81, 0x78, 0x29, 0xB1,
+	0xC1, 0x78, 0x74, 0x48,
+	0x00, 0x78, 0x40, 0x1E, 0x81, 0x42, 0x01, 0xD1, 0x01, 0x20, 0x70, 0x47,
+	0x00, 0x20, 0x70, 0x47,
+	0xF0, 0xB5, 0x70, 0x4D, 0x00, 0x22, 0x05, 0xEB, 0xC2, 0x06, 0x00, 0x23,
+	0xC6, 0xE9, 0x00, 0x33,
+	0x52, 0x1C, 0xD2, 0xB2, 0x17, 0x2A, 0xF6, 0xD3, 0x8A, 0x78, 0x2C, 0xE0,
+	0x00, 0xEB, 0xC2, 0x03,
+	0xD3, 0xE9, 0x00, 0x76, 0x57, 0xEA, 0x06, 0x03, 0x23, 0xD0, 0x74, 0x08,
+	0x4F, 0xEA, 0x37, 0x03,
+	0x17, 0xEB, 0x07, 0x0E, 0x46, 0xEB, 0x06, 0x0C, 0x44, 0xEA, 0x0C, 0x04,
+	0x34, 0x43, 0x43, 0xEA,
+	0x0E, 0x03, 0x05, 0xEB, 0xC2, 0x06, 0x3B, 0x43, 0xD6, 0xE9, 0x00, 0x7C,
+	0x1F, 0x43, 0x4C, 0xEA,
+	0x04, 0x0C, 0xC6, 0xE9, 0x00, 0x7C, 0xD6, 0xE9, 0x02, 0x7C, 0x1F, 0x43,
+	0x4C, 0xEA, 0x04, 0x0C,
+	0xC6, 0xE9, 0x02, 0x7C, 0xD6, 0xE9, 0x04, 0x7C, 0x1F, 0x43, 0x4C, 0xEA,
+	0x04, 0x0C, 0xC6, 0xE9,
+	0x04, 0x7C, 0x52, 0x1C, 0xD2, 0xB2, 0xCB, 0x78, 0x93, 0x42, 0xCF, 0xD2,
+	0x00, 0x22, 0x50, 0x4B,
+	0x0A, 0xE0, 0x00, 0xBF, 0x05, 0xEB, 0xC2, 0x04, 0x00, 0xEB, 0xC2, 0x07,
+	0xD4, 0xE9, 0x02, 0x64,
+	0xC7, 0xE9, 0x00, 0x64, 0x52, 0x1C, 0xD2, 0xB2, 0x1C, 0x78, 0xA2, 0x42,
+	0xF2, 0xD3, 0x08, 0x78,
+	0x08, 0xB1, 0x40, 0x1E, 0x08, 0x70, 0x45, 0x4A, 0x48, 0x78, 0x12, 0x78,
+	0x52, 0x1E, 0x90, 0x42,
+	0x01, 0xDA, 0x40, 0x1C, 0x48, 0x70, 0x88, 0x78, 0x08, 0xB1, 0x40, 0x1E,
+	0x88, 0x70, 0x1A, 0x78,
+	0xC8, 0x78, 0x52, 0x1E, 0x90, 0x42, 0x01, 0xDA, 0x40, 0x1C, 0xC8, 0x70,
+	0xF0, 0xBD, 0x2D, 0xE9,
+	0xFF, 0x5F, 0x94, 0x78, 0x16, 0x46, 0x04, 0xEB, 0x84, 0x02, 0x8B, 0x46,
+	0x00, 0xEB, 0xC2, 0x00,
+	0x00, 0x21, 0x00, 0xF1, 0x29, 0x08, 0x20, 0xE0, 0x00, 0x20, 0x81, 0x46,
+	0x82, 0x46, 0x35, 0x78,
+	0x77, 0x78, 0x0F, 0xE0, 0x18, 0xF8, 0x05, 0x20, 0x5A, 0x45, 0x09, 0xD1,
+	0x2A, 0x46, 0x01, 0x20,
+	0x00, 0x21, 0x08, 0xF0, 0xEB, 0xFA, 0x41, 0xEA, 0x0A, 0x0A, 0x40, 0xEA,
+	0x09, 0x09, 0x01, 0x21,
+	0x6D, 0x1C, 0xED, 0xB2, 0xAF, 0x42, 0xED, 0xD2, 0x03, 0x9B, 0x08, 0xF1,
+	0x28, 0x08, 0x03, 0xEB,
+	0xC4, 0x03, 0x64, 0x1C, 0xC3, 0xE9, 0x00, 0x9A, 0xE4, 0xB2, 0xF0, 0x78,
+	0xA0, 0x42, 0xDB, 0xD2,
+	0x04, 0xB0, 0x08, 0x46, 0xBD, 0xE8, 0xF0, 0x9F, 0x0A, 0x78, 0x43, 0x78,
+	0x9A, 0x42, 0x0B, 0xD8,
+	0x4A, 0x78, 0x03, 0x78, 0x9A, 0x42, 0x07, 0xD3, 0x8A, 0x78, 0xC3, 0x78,
+	0x9A, 0x42, 0x03, 0xD8,
+	0xC9, 0x78, 0x80, 0x78, 0x81, 0x42, 0x01, 0xD2, 0x00, 0x20, 0x70, 0x47,
+	0x01, 0x20, 0x70, 0x47,
+	0x70, 0xB5, 0x0C, 0x78, 0x8B, 0x78, 0x4D, 0x78, 0xC9, 0x78, 0x9A, 0xB1,
+	0x0C, 0xB1, 0x64, 0x1E,
+	0xE4, 0xB2, 0x12, 0x4A, 0x12, 0x78, 0x52, 0x1E, 0x95, 0x42, 0x01, 0xDA,
+	0x6D, 0x1C, 0xED, 0xB2,
+	0x0B, 0xB1, 0x5B, 0x1E, 0xDB, 0xB2, 0x0E, 0x4A, 0x12, 0x78, 0x52, 0x1E,
+	0x91, 0x42, 0x01, 0xDA,
+	0x49, 0x1C, 0xC9, 0xB2, 0x03, 0xEB, 0x83, 0x02, 0x00, 0xEB, 0xC2, 0x02,
+	0x00, 0x26, 0x29, 0x32,
+	0x09, 0xE0, 0x20, 0x46, 0x02, 0xE0, 0x16, 0x54, 0x40, 0x1C, 0xC0, 0xB2,
+	0xA8, 0x42, 0xFA, 0xD9,
+	0x5B, 0x1C, 0xDB, 0xB2, 0x28, 0x32, 0x8B, 0x42, 0xF3, 0xD9, 0x70, 0xBD,
+	0xEE, 0x06, 0x10, 0x00,
+	0xED, 0x06, 0x10, 0x00, 0x40, 0x47, 0x10, 0x00, 0x2D, 0xE9, 0xF0, 0x47,
+	0xDF, 0xF8, 0xA0, 0x90,
+	0x80, 0x46, 0x0C, 0x78, 0x99, 0xF8, 0x00, 0x00, 0x0D, 0x46, 0x80, 0x1E,
+	0x01, 0x2C, 0x05, 0xD9,
+	0x69, 0x78, 0x81, 0x42, 0x02, 0xDA, 0x00, 0x20, 0xBD, 0xE8, 0xF0, 0x87,
+	0x02, 0x2C, 0x01, 0xD2,
+	0x02, 0x27, 0x01, 0xE0, 0x6F, 0x78, 0xC4, 0xB2, 0x4F, 0xF0, 0x00, 0x0A,
+	0xA9, 0x78, 0xD8, 0xF8,
+	0x08, 0x00, 0x08, 0xF0, 0x2B, 0xFC, 0x06, 0x46, 0xA9, 0x78, 0xD8, 0xF8,
+	0x04, 0x00, 0x08, 0xF0,
+	0x25, 0xFC, 0xAA, 0x78, 0x01, 0x46, 0xED, 0x78, 0x99, 0xF8, 0x00, 0x30,
+	0x13, 0xE0, 0x20, 0x46,
+	0x0A, 0xE0, 0x00, 0xBF, 0x36, 0xF9, 0x10, 0xC0, 0x31, 0xF9, 0x10, 0x80,
+	0xC4, 0x45, 0x02, 0xD0,
+	0x4F, 0xF0, 0x01, 0x0A, 0x02, 0xE0, 0x40, 0x1C, 0xB8, 0x42, 0xF3, 0xD9,
+	0x06, 0xEB, 0x43, 0x06,
+	0x01, 0xEB, 0x43, 0x01, 0x52, 0x1C, 0x95, 0x42, 0xE9, 0xD2, 0x50, 0x46,
+	0xCC, 0xE7, 0x08, 0x49,
+	0x09, 0x78, 0x49, 0x1E, 0xCA, 0xB2, 0x90, 0xF8, 0x3E, 0x10, 0x09, 0xB1,
+	0x91, 0x42, 0x05, 0xD1,
+	0x81, 0x8C, 0x41, 0xF0, 0x04, 0x01, 0x81, 0x84, 0x01, 0x20, 0x70, 0x47,
+	0x00, 0x20, 0x70, 0x47,
+	0xEE, 0x06, 0x10, 0x00, 0x30, 0xB5, 0xB0, 0xB1, 0x88, 0x42, 0x14, 0xD0,
+	0x02, 0xD2, 0x0A, 0x46,
+	0x01, 0x46, 0x10, 0x46, 0xDE, 0x4A, 0x53, 0x68, 0x03, 0xEB, 0x40, 0x03,
+	0x1C, 0x78, 0x8C, 0x42,
+	0x09, 0xD0, 0x5C, 0x78, 0x8C, 0x42, 0x06, 0xD0, 0x95, 0x68, 0x2A, 0x5C,
+	0x02, 0x2A, 0x02, 0xD2,
+	0x54, 0x1C, 0x2C, 0x54, 0x99, 0x54, 0x08, 0x46, 0x30, 0xBD, 0xF0, 0xB5,
+	0x03, 0xEB, 0x82, 0x04,
+	0xA5, 0x78, 0x05, 0xEB, 0x85, 0x06, 0x00, 0xEB, 0xC6, 0x06, 0xE0, 0x78,
+	0x28, 0x36, 0xA8, 0x42,
+	0x0F, 0xD3, 0x20, 0x78, 0x07, 0xE0, 0x37, 0x18, 0x97, 0xF8, 0x01, 0xC0,
+	0x94, 0x45, 0x00, 0xD1,
+	0x79, 0x70, 0x40, 0x1C, 0xC0, 0xB2, 0x67, 0x78, 0x87, 0x42, 0xF4, 0xD2,
+	0x6D, 0x1C, 0xED, 0xB2,
+	0xEB, 0xE7, 0x03, 0xEB, 0x81, 0x00, 0x25, 0x68, 0x05, 0x60, 0x03, 0xEB,
+	0x42, 0x00, 0x03, 0xEB,
+	0x41, 0x01, 0x30, 0xF8, 0xB4, 0x2F, 0xA1, 0xF8, 0xB4, 0x20, 0xC2, 0x49,
+	0x09, 0x68, 0x21, 0x60,
+	0x00, 0x21, 0x01, 0x80, 0x93, 0xF8, 0x0E, 0x01, 0x40, 0x1E, 0x83, 0xF8,
+	0x0E, 0x01, 0xF0, 0xBD,
+	0x2D, 0xE9, 0xFF, 0x4F, 0x88, 0x46, 0x08, 0x46, 0x09, 0x78, 0x8F, 0xB0,
+	0xFF, 0x29, 0x13, 0xD0,
+	0x8A, 0x46, 0xB9, 0x49, 0x42, 0x78, 0x09, 0x78, 0x8A, 0x42, 0x00, 0xD2,
+	0x51, 0x1C, 0xCE, 0xB2,
+	0xB6, 0x49, 0x90, 0xF8, 0x02, 0x90, 0xC0, 0x78, 0x09, 0x78, 0x88, 0x42,
+	0x01, 0xD2, 0x40, 0x1C,
+	0x00, 0xE0, 0x08, 0x46, 0xC7, 0xB2, 0x04, 0xE0, 0x4F, 0xF0, 0x00, 0x0A,
+	0x56, 0x46, 0xD1, 0x46,
+	0x57, 0x46, 0x11, 0x98, 0x4F, 0xF0, 0x00, 0x0B, 0x08, 0xB1, 0x98, 0xF8,
+	0x0E, 0xB1, 0xA8, 0x4A,
+	0x11, 0x68, 0x01, 0xF1, 0x5A, 0x00, 0xC2, 0xE9, 0x01, 0x10, 0x02, 0x46,
+	0x5F, 0xF0, 0x2C, 0x00,
+	0x00, 0x23, 0x01, 0xF8, 0x10, 0x00, 0x13, 0x54, 0x40, 0x1E, 0xC0, 0xB2,
+	0xF8, 0xD2, 0x0B, 0xF1,
+	0x01, 0x00, 0x0D, 0x90, 0xC0, 0xB2, 0x06, 0x90, 0x0F, 0x98, 0x09, 0xEB,
+	0x89, 0x01, 0x00, 0xEB,
+	0xC1, 0x05, 0x09, 0xF1, 0x01, 0x00, 0x09, 0x95, 0x39, 0xE0, 0x00, 0xBF,
+	0x0A, 0xF1, 0x01, 0x00,
+	0x0A, 0x95, 0xC4, 0xB2, 0x28, 0x35, 0x2E, 0xE0, 0x29, 0x19, 0x08, 0x68,
+	0xE0, 0xB1, 0x28, 0x5D,
+	0x38, 0xB3, 0x11, 0xF8, 0x01, 0x1C, 0x00, 0x20, 0x01, 0xB1, 0x08, 0x46,
+	0x0A, 0x99, 0x09, 0x5D,
+	0x09, 0xB1, 0xFF, 0xF7, 0x57, 0xFF, 0x12, 0x99, 0x61, 0xB1, 0x0A, 0x99,
+	0x21, 0x44, 0x0E, 0x91,
+	0x11, 0xF8, 0x01, 0x1C, 0x09, 0xB1, 0xFF, 0xF7, 0x4D, 0xFF, 0x0E, 0x99,
+	0x49, 0x78, 0x09, 0xB1,
+	0xFF, 0xF7, 0x48, 0xFF, 0x18, 0xB1, 0x0B, 0xE0, 0xE4, 0x1C, 0xE4, 0xB2,
+	0x09, 0xE0, 0x06, 0x98,
+	0x2D, 0x28, 0x03, 0xD2, 0x41, 0x1C, 0xC9, 0xB2, 0x06, 0x91, 0x01, 0xE0,
+	0x40, 0x1E, 0xC0, 0xB2,
+	0x28, 0x55, 0x64, 0x1C, 0xE4, 0xB2, 0xB4, 0x42, 0xCE, 0xD9, 0x07, 0x98,
+	0x40, 0x1C, 0xC0, 0xB2,
+	0x07, 0x90, 0xB8, 0x42, 0xC2, 0xD9, 0x06, 0x98, 0x00, 0xF0, 0x99, 0xF8,
+	0x06, 0x90, 0x0D, 0x98,
+	0x00, 0x22, 0xC0, 0xB2, 0x77, 0x4C, 0x09, 0xE0, 0x08, 0xEB, 0x80, 0x03,
+	0x21, 0x68, 0x19, 0x60,
+	0x08, 0xEB, 0x40, 0x01, 0x40, 0x1C, 0xA1, 0xF8, 0xB4, 0x20, 0xC0, 0xB2,
+	0x06, 0x99, 0x88, 0x42,
+	0xF2, 0xD3, 0x09, 0x98, 0x4D, 0x46, 0x28, 0x30, 0x00, 0x90, 0x39, 0xE0,
+	0x54, 0x46, 0x30, 0xE0,
+	0x20, 0x44, 0x01, 0x21, 0x09, 0x58, 0xE9, 0xB3, 0x41, 0x78, 0x41, 0xB3,
+	0x68, 0x4A, 0x52, 0x68,
+	0x12, 0xF8, 0x11, 0x10, 0x41, 0x70, 0x08, 0xEB, 0x41, 0x00, 0x08, 0xEB,
+	0x81, 0x09, 0x30, 0xF8,
+	0xB4, 0x2F, 0x52, 0x1C, 0x02, 0x80, 0x99, 0xF8, 0x00, 0x10, 0x20, 0x46,
+	0x04, 0xF0, 0xEC, 0xF9,
+	0x89, 0xF8, 0x00, 0x00, 0x99, 0xF8, 0x01, 0x10, 0x20, 0x46, 0x04, 0xF0,
+	0xE9, 0xF9, 0x89, 0xF8,
+	0x01, 0x00, 0x99, 0xF8, 0x02, 0x10, 0x28, 0x46, 0x04, 0xF0, 0xDE, 0xF9,
+	0x89, 0xF8, 0x02, 0x00,
+	0x99, 0xF8, 0x03, 0x10, 0x28, 0x46, 0x04, 0xF0, 0xDB, 0xF9, 0x89, 0xF8,
+	0x03, 0x00, 0x64, 0x1C,
+	0xE4, 0xB2, 0x00, 0x98, 0xB4, 0x42, 0xCB, 0xD3, 0x28, 0x30, 0x6D, 0x1C,
+	0xED, 0xB2, 0x00, 0x90,
+	0xBD, 0x42, 0xC3, 0xD3, 0x06, 0x98, 0x40, 0x1E, 0xC2, 0xB2, 0x88, 0xF8,
+	0x0E, 0x21, 0x11, 0x98,
+	0x00, 0x28, 0x00, 0xE0, 0x0B, 0xE0, 0x0D, 0xD0, 0xA2, 0xEB, 0x0B, 0x00,
+	0x01, 0x28, 0x09, 0xD1,
+	0x11, 0x99, 0x0F, 0x98, 0x13, 0xB0, 0x43, 0x46, 0xBD, 0xE8, 0xF0, 0x4F,
+	0xDD, 0xE6, 0xE4, 0x1C,
+	0xE4, 0xB2, 0xDC, 0xE7, 0x13, 0xB0, 0xBD, 0xE8, 0xF0, 0x8F, 0xF0, 0xB5,
+	0x02, 0xEB, 0x81, 0x03,
+	0x00, 0x26, 0x9D, 0x78, 0x18, 0xE0, 0x00, 0xBF, 0x05, 0xEB, 0x85, 0x04,
+	0x00, 0xEB, 0xC4, 0x07,
+	0x1C, 0x78, 0x28, 0x37, 0x0A, 0xE0, 0x00, 0xBF, 0x07, 0xEB, 0x04, 0x0C,
+	0x9C, 0xF8, 0x01, 0xE0,
+	0x8E, 0x45, 0x01, 0xD1, 0x8C, 0xF8, 0x01, 0x60, 0x64, 0x1C, 0xE4, 0xB2,
+	0x93, 0xF8, 0x01, 0xC0,
+	0xA4, 0x45, 0xF1, 0xD2, 0x6D, 0x1C, 0xED, 0xB2, 0xDC, 0x78, 0xAC, 0x42,
+	0xE4, 0xD2, 0x31, 0x48,
+	0x00, 0x68, 0x18, 0x60, 0x02, 0xEB, 0x41, 0x00, 0xA0, 0xF8, 0xB4, 0x60,
+	0xF0, 0xBD, 0x2D, 0xE9,
+	0xF0, 0x5F, 0x07, 0x46, 0x00, 0x25, 0xDF, 0xF8, 0xA8, 0xB0, 0x2C, 0xE0,
+	0xDB, 0xF8, 0x08, 0x10,
+	0x4E, 0x5D, 0xDB, 0xF8, 0x04, 0x10, 0x01, 0xEB, 0x45, 0x0A, 0x1A, 0xE0,
+	0x0A, 0xEB, 0x06, 0x00,
+	0x80, 0x46, 0x10, 0xF8, 0x01, 0x1C, 0x10, 0xF8, 0x02, 0x9C, 0x08, 0x46,
+	0x00, 0xF0, 0x35, 0xF8,
+	0x04, 0x46, 0x48, 0x46, 0x00, 0xF0, 0x31, 0xF8, 0x84, 0x42, 0x02, 0xD2,
+	0x01, 0x46, 0x20, 0x46,
+	0x0C, 0x46, 0xDB, 0xF8, 0x04, 0x10, 0x76, 0x1E, 0xF6, 0xB2, 0x01, 0xF8,
+	0x10, 0x40, 0x08, 0xF8,
+	0x02, 0x4C, 0x01, 0x2E, 0xE2, 0xD8, 0x04, 0xD1, 0x28, 0x46, 0x00, 0xF0,
+	0x1E, 0xF8, 0x8A, 0xF8,
+	0x00, 0x00, 0x6D, 0x1C, 0xED, 0xB2, 0xBD, 0x42, 0xD0, 0xD3, 0x00, 0x21,
+	0x08, 0x46, 0xDB, 0xF8,
+	0x04, 0x40, 0x0D, 0xE0, 0x04, 0xEB, 0x40, 0x02, 0x13, 0x78, 0x83, 0x42,
+	0x03, 0xD1, 0x11, 0x70,
+	0x49, 0x1C, 0xC9, 0xB2, 0x02, 0xE0, 0x14, 0xF8, 0x13, 0x30, 0x13, 0x70,
+	0x40, 0x1C, 0xC0, 0xB2,
+	0xB8, 0x42, 0xEF, 0xD3, 0x08, 0x46, 0xBD, 0xE8, 0xF0, 0x9F, 0x05, 0x4A,
+	0xD2, 0xE9, 0x01, 0x12,
+	0x02, 0xE0, 0x00, 0xBF, 0x11, 0xF8, 0x10, 0x00, 0x13, 0x5C, 0x00, 0x2B,
+	0xFA, 0xD1, 0x70, 0x47,
+	0x60, 0x06, 0x10, 0x00, 0x36, 0x7A, 0x01, 0x00, 0xEE, 0x06, 0x10, 0x00,
+	0xED, 0x06, 0x10, 0x00,
+	0xF0, 0xB5, 0xB2, 0xF9, 0x00, 0x40, 0x06, 0x68, 0xB4, 0x42, 0x02, 0xDD,
+	0xB3, 0xF9, 0x00, 0x10,
+	0x30, 0xE0, 0x02, 0xEB, 0x41, 0x04, 0x34, 0xF9, 0x02, 0x5C, 0xB5, 0x42,
+	0x04, 0xDA, 0x03, 0xEB,
+	0x41, 0x01, 0x31, 0xF9, 0x02, 0x1C, 0x25, 0xE0, 0x00, 0x25, 0x2C, 0x46,
+	0x4F, 0x1E, 0x0C, 0xE0,
+	0x32, 0xF9, 0x14, 0xC0, 0xB4, 0x45, 0x07, 0xDC, 0x02, 0xEB, 0x44, 0x0C,
+	0xBC, 0xF9, 0x02, 0xC0,
+	0xB4, 0x45, 0x01, 0xDB, 0x25, 0x46, 0x0C, 0x46, 0x64, 0x1C, 0xBC, 0x42,
+	0xF0, 0xDB, 0x32, 0xF9,
+	0x15, 0x40, 0x03, 0xEB, 0x45, 0x01, 0x33, 0xF9, 0x15, 0x30, 0xB1, 0xF9,
+	0x02, 0x10, 0x02, 0xEB,
+	0x45, 0x02, 0x36, 0x1B, 0xC9, 0x1A, 0xB2, 0xF9, 0x02, 0x20, 0x71, 0x43,
+	0x12, 0x1B, 0x91, 0xFB,
+	0xF2, 0xF1, 0x19, 0x44, 0x01, 0x60, 0xF0, 0xBD, 0x2D, 0xE9, 0xF0, 0x41,
+	0x07, 0x46, 0x2A, 0x48,
+	0x00, 0x68, 0x00, 0xF2, 0x0F, 0x53, 0xE9, 0xB1, 0x01, 0x29, 0x22, 0xD0,
+	0x02, 0x29, 0x2C, 0xD0,
+	0x03, 0x29, 0x31, 0xD0, 0x04, 0x29, 0x36, 0xD0, 0x00, 0x21, 0x0C, 0x46,
+	0x0E, 0xEB, 0x01, 0x00,
+	0x20, 0x44, 0x64, 0x28, 0x3D, 0xDC, 0x01, 0x29, 0x03, 0xDD, 0x38, 0x1D,
+	0x63, 0x46, 0xFF, 0xF7,
+	0xA7, 0xFF, 0x01, 0x2C, 0x35, 0xDD, 0x38, 0x46, 0x33, 0x46, 0x2A, 0x46,
+	0x21, 0x46, 0xBD, 0xE8,
+	0xF0, 0x41, 0x9D, 0xE7, 0x90, 0xF8, 0x08, 0x15, 0x90, 0xF8, 0x09, 0x45,
+	0x90, 0xF8, 0x0A, 0xE5,
+	0x05, 0xE0, 0x90, 0xF8, 0x08, 0x15, 0x90, 0xF8, 0x09, 0x45, 0x90, 0xF8,
+	0x0B, 0xE5, 0x9C, 0x46,
+	0x03, 0xEB, 0x41, 0x06, 0x03, 0xEB, 0x4E, 0x02, 0x18, 0xE0, 0x90, 0xF8,
+	0x08, 0x15, 0x90, 0xF8,
+	0x09, 0x45, 0x90, 0xF8, 0x0C, 0xE5, 0xF2, 0xE7, 0x90, 0xF8, 0x08, 0x15,
+	0x90, 0xF8, 0x09, 0x45,
+	0x90, 0xF8, 0x0D, 0xE5, 0xEB, 0xE7, 0x90, 0xF8, 0x08, 0x15, 0x90, 0xF8,
+	0x09, 0x45, 0x90, 0xF8,
+	0x0E, 0x05, 0x9C, 0x46, 0x03, 0xEB, 0x41, 0x06, 0x03, 0xEB, 0x40, 0x02,
+	0x02, 0xEB, 0x41, 0x05,
+	0xBC, 0xE7, 0xBD, 0xE8, 0xF0, 0x81, 0x00, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x30, 0xB5, 0x42, 0x78,
+	0x03, 0x78, 0xCD, 0x8C, 0xD2, 0x1A, 0xC3, 0x78, 0x80, 0x78, 0x52, 0x1C,
+	0x1B, 0x1A, 0x5B, 0x1C,
+	0x05, 0xFB, 0x02, 0xF0, 0xD4, 0x18, 0x5D, 0x43, 0x40, 0x00, 0x6A, 0x00,
+	0xB0, 0xFB, 0xF4, 0xF0,
+	0xB2, 0xFB, 0xF4, 0xF2, 0x90, 0x42, 0x02, 0xD9, 0xC8, 0x85, 0x0A, 0x86,
+	0x30, 0xBD, 0xCA, 0x85,
+	0x08, 0x86, 0x30, 0xBD, 0x2D, 0xE9, 0xFF, 0x4F, 0x00, 0x27, 0x83, 0xB0,
+	0x15, 0x46, 0x01, 0x97,
+	0x00, 0x97, 0x3E, 0x46, 0x3C, 0x46, 0xBB, 0x46, 0x91, 0x78, 0x08, 0xF0,
+	0x61, 0xF9, 0x82, 0x46,
+	0xAB, 0x78, 0x95, 0xF8, 0x03, 0x90, 0x28, 0xE0, 0x29, 0x78, 0x95, 0xF8,
+	0x01, 0xC0, 0x8E, 0x46,
+	0x1D, 0xE0, 0x00, 0xBF, 0x1A, 0xF8, 0x01, 0x20, 0x04, 0x98, 0x82, 0x42,
+	0x15, 0xD1, 0xA1, 0xEB,
+	0x0E, 0x02, 0x52, 0x1C, 0xDD, 0xF8, 0x00, 0x80, 0xA9, 0xEB, 0x03, 0x00,
+	0x02, 0xFB, 0x02, 0x88,
+	0x40, 0x1C, 0xCD, 0xF8, 0x00, 0x80, 0xDD, 0xF8, 0x04, 0x80, 0x16, 0x44,
+	0x02, 0xFB, 0x00, 0x82,
+	0x00, 0xFB, 0x00, 0xBB, 0x04, 0x44, 0x7F, 0x1C, 0x01, 0x92, 0x49, 0x1C,
+	0xC9, 0xB2, 0x8C, 0x45,
+	0xE0, 0xD2, 0x5B, 0x1C, 0x0A, 0xF1, 0x28, 0x0A, 0xDB, 0xB2, 0x99, 0x45,
+	0xD4, 0xD2, 0x4F, 0xF4,
+	0x7A, 0x70, 0x70, 0x43, 0x90, 0xFB, 0xF7, 0xF1, 0x4F, 0xF4, 0x7A, 0x70,
+	0x60, 0x43, 0x90, 0xFB,
+	0xF7, 0xF3, 0x4F, 0xF4, 0x7A, 0x72, 0x01, 0xFB, 0x04, 0xF0, 0x71, 0x43,
+	0x90, 0xFB, 0xF2, 0xF7,
+	0x91, 0xFB, 0xF2, 0xF6, 0x63, 0x43, 0x93, 0xFB, 0xF2, 0xF3, 0x01, 0x98,
+	0x00, 0x99, 0xC0, 0x1B,
+	0x89, 0x1B, 0xAB, 0xEB, 0x03, 0x02, 0x06, 0x9C, 0x8B, 0x1A, 0x00, 0xD5,
+	0x5B, 0x42, 0x00, 0x28,
+	0x00, 0xDA, 0x40, 0x42, 0x03, 0xEB, 0x40, 0x00, 0x11, 0x44, 0x0A, 0x18,
+	0x08, 0x1A, 0x52, 0x10,
+	0x40, 0x10, 0x4F, 0xF4, 0x7A, 0x71, 0x48, 0x43, 0x90, 0xFB, 0xF2, 0xF0,
+	0xC0, 0xF5, 0x7A, 0x70,
+	0xA0, 0x85, 0x06, 0x99, 0x07, 0xB0, 0x28, 0x46, 0xBD, 0xE8, 0xF0, 0x4F,
+	0x6E, 0xE7, 0x01, 0x20,
+	0x70, 0x47, 0x00, 0x00, 0x2D, 0xE9, 0xF0, 0x5F, 0x8A, 0x46, 0x0A, 0x9F,
+	0x00, 0x25, 0x98, 0x46,
+	0x14, 0x46, 0x83, 0x46, 0x2E, 0x46, 0x39, 0x46, 0x08, 0xF0, 0xF0, 0xF8,
+	0x30, 0xF9, 0x18, 0x00,
+	0xA0, 0x42, 0x2E, 0xDD, 0x78, 0x1E, 0x44, 0xB2, 0x7F, 0x1C, 0x27, 0xE0,
+	0x00, 0x2C, 0x21, 0xDB,
+	0xB0, 0x48, 0x00, 0x78, 0x84, 0x42, 0x1D, 0xDA, 0xE1, 0xB2, 0x58, 0x46,
+	0x08, 0xF0, 0xDE, 0xF8,
+	0xAD, 0x49, 0x81, 0x46, 0xA8, 0xF1, 0x01, 0x00, 0x0A, 0x78, 0x40, 0xB2,
+	0x08, 0xF1, 0x01, 0x01,
+	0x0D, 0xE0, 0x00, 0x28, 0x07, 0xDB, 0x90, 0x42, 0x05, 0xDA, 0x39, 0xF9,
+	0x10, 0xC0, 0x3A, 0xF9,
+	0x15, 0x30, 0x0C, 0xFB, 0x03, 0x66, 0x6D, 0x1C, 0x40, 0x1C, 0xED, 0xB2,
+	0x40, 0xB2, 0x88, 0x42,
+	0xEF, 0xDD, 0x01, 0xE0, 0xED, 0x1C, 0xED, 0xB2, 0x64, 0x1C, 0x64, 0xB2,
+	0xBC, 0x42, 0xD5, 0xDD,
+	0x00, 0xE0, 0x06, 0x46, 0x01, 0x20, 0x96, 0xFB, 0xF0, 0xF0, 0x00, 0xB2,
+	0xBD, 0xE8, 0xF0, 0x9F,
+	0x2D, 0xE9, 0xFF, 0x4F, 0x83, 0xB0, 0x91, 0x46, 0x10, 0x99, 0x08, 0x78,
+	0x00, 0xB1, 0x40, 0x1E,
+	0xC4, 0xB2, 0x88, 0x78, 0x00, 0xB1, 0x40, 0x1E, 0xDF, 0xF8, 0x4C, 0xA2,
+	0xC5, 0xB2, 0x4A, 0x78,
+	0x9A, 0xF8, 0x00, 0x00, 0x43, 0x1E, 0x9A, 0x42, 0x01, 0xDA, 0x50, 0x1C,
+	0x00, 0xE0, 0x40, 0x1E,
+	0xDF, 0xF8, 0x30, 0xB2, 0xC6, 0xB2, 0xC9, 0x78, 0x9B, 0xF8, 0x00, 0x00,
+	0x42, 0x1E, 0x91, 0x42,
+	0x01, 0xDA, 0x48, 0x1C, 0x00, 0xE0, 0x40, 0x1E, 0xC7, 0xB2, 0xCC, 0xB9,
+	0xA8, 0x46, 0x12, 0xE0,
+	0x01, 0x46, 0x03, 0x98, 0x08, 0xF0, 0x98, 0xF8, 0xCD, 0xE9, 0x00, 0x80,
+	0x23, 0x46, 0x49, 0x46,
+	0x06, 0x9A, 0x04, 0x98, 0xFF, 0xF7, 0x86, 0xFF, 0x01, 0x99, 0x21, 0xF8,
+	0x14, 0x00, 0x08, 0xF1,
+	0x01, 0x00, 0x00, 0xF0, 0xFF, 0x08, 0x40, 0x46, 0xB8, 0x45, 0xE9, 0xD9,
+	0x64, 0x1C, 0xE4, 0xB2,
+	0x79, 0x48, 0x00, 0x78, 0x40, 0x1E, 0x86, 0x42, 0x19, 0xD1, 0xA8, 0x46,
+	0x12, 0xE0, 0x01, 0x46,
+	0x03, 0x98, 0x08, 0xF0, 0x79, 0xF8, 0x82, 0x46, 0x33, 0x46, 0xCD, 0xF8,
+	0x00, 0x80, 0x49, 0x46,
+	0x06, 0x9A, 0x04, 0x98, 0xFF, 0xF7, 0x66, 0xFF, 0x2A, 0xF8, 0x16, 0x00,
+	0x08, 0xF1, 0x01, 0x00,
+	0x00, 0xF0, 0xFF, 0x08, 0x40, 0x46, 0xB8, 0x45, 0xE9, 0xD9, 0x76, 0x1E,
+	0xF6, 0xB2, 0xC5, 0xB9,
+	0x29, 0x46, 0x03, 0x98, 0x08, 0xF0, 0x60, 0xF8, 0x82, 0x46, 0xA0, 0x46,
+	0x0C, 0xE0, 0x03, 0x46,
+	0x00, 0x95, 0x49, 0x46, 0x06, 0x9A, 0x04, 0x98, 0xFF, 0xF7, 0x4C, 0xFF,
+	0x2A, 0xF8, 0x18, 0x00,
+	0x08, 0xF1, 0x01, 0x00, 0x00, 0xF0, 0xFF, 0x08, 0x40, 0x46, 0xB0, 0x45,
+	0xEF, 0xD9, 0x6D, 0x1C,
+	0xED, 0xB2, 0x9B, 0xF8, 0x00, 0x00, 0x40, 0x1E, 0x87, 0x42, 0x18, 0xD1,
+	0x39, 0x46, 0x03, 0x98,
+	0x08, 0xF0, 0x42, 0xF8, 0x82, 0x46, 0xA0, 0x46, 0x0C, 0xE0, 0x03, 0x46,
+	0x00, 0x97, 0x49, 0x46,
+	0x06, 0x9A, 0x04, 0x98, 0xFF, 0xF7, 0x2E, 0xFF, 0x2A, 0xF8, 0x18, 0x00,
+	0x08, 0xF1, 0x01, 0x00,
+	0x00, 0xF0, 0xFF, 0x08, 0x40, 0x46, 0xB0, 0x45, 0xEF, 0xD9, 0x7F, 0x1E,
+	0xFF, 0xB2, 0xB9, 0xF9,
+	0x12, 0x00, 0x5F, 0xEA, 0x00, 0x0A, 0x64, 0xD1, 0x4F, 0xF0, 0x01, 0x0A,
+	0x61, 0xE0, 0x29, 0x46,
+	0x03, 0x98, 0x08, 0xF0, 0x21, 0xF8, 0x01, 0x90, 0x68, 0x1E, 0xC1, 0xB2,
+	0x04, 0x98, 0x08, 0xF0,
+	0x0D, 0xF8, 0x00, 0x90, 0x29, 0x46, 0x04, 0x98, 0x08, 0xF0, 0x08, 0xF8,
+	0x21, 0x46, 0x4C, 0xE0,
+	0x30, 0xF9, 0x11, 0x20, 0x06, 0x9B, 0x9A, 0x42, 0x42, 0xDD, 0x00, 0x9A,
+	0xB9, 0xF9, 0x00, 0x80,
+	0x02, 0xEB, 0x41, 0x02, 0x00, 0x23, 0x32, 0xF9, 0x02, 0xCD, 0x0C, 0xFB,
+	0x08, 0x33, 0xB2, 0xF9,
+	0x02, 0xC0, 0xB9, 0xF9, 0x02, 0x80, 0x0C, 0xFB, 0x08, 0x33, 0xB2, 0xF9,
+	0x04, 0xC0, 0xB9, 0xF9,
+	0x04, 0x80, 0x0C, 0xFB, 0x08, 0x3B, 0x34, 0x4B, 0xB9, 0xF9, 0x06, 0x80,
+	0x93, 0xF8, 0x00, 0xE0,
+	0x02, 0xEB, 0x4E, 0x02, 0xB2, 0xF9, 0x00, 0xC0, 0x0C, 0xFB, 0x08, 0xB3,
+	0xB2, 0xF9, 0x02, 0xC0,
+	0xB9, 0xF9, 0x08, 0x80, 0x0C, 0xFB, 0x08, 0x33, 0xB2, 0xF9, 0x04, 0xC0,
+	0xB9, 0xF9, 0x0A, 0x80,
+	0x02, 0xEB, 0x4E, 0x02, 0x0C, 0xFB, 0x08, 0x3B, 0xB2, 0xF9, 0x00, 0xC0,
+	0xB9, 0xF9, 0x0C, 0x80,
+	0x0C, 0xFB, 0x08, 0xB3, 0xB2, 0xF9, 0x02, 0xC0, 0xB9, 0xF9, 0x0E, 0x80,
+	0x0C, 0xFB, 0x08, 0x33,
+	0xB2, 0xF9, 0x04, 0xC0, 0xB9, 0xF9, 0x10, 0x20, 0x0C, 0xFB, 0x02, 0x32,
+	0x92, 0xFB, 0xFA, 0xF2,
+	0x01, 0x9B, 0x23, 0xF8, 0x11, 0x20, 0x49, 0x1C, 0xC9, 0xB2, 0xB1, 0x42,
+	0xB0, 0xD9, 0x6D, 0x1C,
+	0xED, 0xB2, 0xBD, 0x42, 0x9B, 0xD9, 0x07, 0xB0, 0xBD, 0xE8, 0xF0, 0x8F,
+	0x1C, 0xB5, 0x17, 0x4C,
+	0x24, 0x68, 0x01, 0x94, 0x01, 0xAC, 0x00, 0x94, 0xFF, 0xF7, 0xF2, 0xFE,
+	0x1C, 0xBD, 0x38, 0xB5,
+	0x16, 0x4D, 0x00, 0x90, 0x12, 0x48, 0x0C, 0x46, 0x12, 0x4A, 0x00, 0x68,
+	0xB0, 0xF9, 0xE2, 0x32,
+	0x11, 0x48, 0x01, 0x68, 0x28, 0x68, 0xFF, 0xF7, 0xE3, 0xFE, 0x28, 0x68,
+	0xA0, 0x60, 0x38, 0xBD,
+	0x38, 0xB5, 0x0E, 0x4D, 0x00, 0x90, 0x0A, 0x48, 0x0C, 0x46, 0x0A, 0x4A,
+	0x00, 0x68, 0x14, 0x3A,
+	0xB0, 0xF9, 0xE2, 0x32, 0x08, 0x48, 0x01, 0x68, 0x28, 0x68, 0xFF, 0xF7,
+	0xD1, 0xFE, 0x28, 0x68,
+	0x60, 0x60, 0x38, 0xBD, 0xED, 0x06, 0x10, 0x00, 0xEE, 0x06, 0x10, 0x00,
+	0x88, 0x06, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x22, 0x7A, 0x01, 0x00, 0x10, 0x07, 0x10, 0x00,
+	0x58, 0x06, 0x10, 0x00,
+	0x2D, 0xE9, 0xFF, 0x5F, 0x89, 0x46, 0x14, 0x46, 0x91, 0x78, 0x0F, 0x9D,
+	0x07, 0xF0, 0x68, 0xFF,
+	0x82, 0x46, 0xA1, 0x78, 0xA8, 0x68, 0x07, 0xF0, 0x69, 0xFF, 0x47, 0xF6,
+	0xFF, 0x76, 0xA7, 0x78,
+	0xF5, 0x43, 0xFE, 0x49, 0x94, 0xF8, 0x03, 0x80, 0x91, 0xF8, 0x00, 0xB0,
+	0x18, 0xE0, 0x22, 0x78,
+	0x94, 0xF8, 0x01, 0xC0, 0x0D, 0xE0, 0x00, 0xBF, 0x1A, 0xF8, 0x02, 0x10,
+	0x49, 0x45, 0x07, 0xD1,
+	0x30, 0xF9, 0x12, 0x30, 0xB3, 0x42, 0x00, 0xDA, 0x1E, 0x46, 0xAB, 0x42,
+	0x00, 0xDD, 0x1D, 0x46,
+	0x52, 0x1C, 0x94, 0x45, 0xF0, 0xD2, 0x0A, 0xF1, 0x28, 0x0A, 0x00, 0xEB,
+	0x4B, 0x00, 0x7F, 0x1C,
+	0xB8, 0x45, 0xE4, 0xD2, 0x03, 0x98, 0x06, 0x80, 0x0E, 0x98, 0x05, 0x80,
+	0xBD, 0xE8, 0xFF, 0x9F,
+	0x2D, 0xE9, 0xFF, 0x4F, 0xEA, 0x48, 0x85, 0xB0, 0x9A, 0x46, 0x04, 0x68,
+	0x03, 0xA9, 0xCD, 0xE9,
+	0x00, 0x1A, 0xDD, 0xE9, 0x05, 0x01, 0x15, 0x46, 0x04, 0xF5, 0x88, 0x79,
+	0x02, 0xAB, 0xFF, 0xF7,
+	0xB7, 0xFF, 0xE4, 0x48, 0xBD, 0xF9, 0x0C, 0x20, 0xDF, 0xF8, 0x8C, 0xB3,
+	0x00, 0x68, 0x5F, 0x46,
+	0x90, 0xF8, 0xE4, 0x12, 0xBD, 0xF9, 0x08, 0x00, 0x12, 0x1A, 0x4A, 0x43,
+	0x64, 0x21, 0x92, 0xFB,
+	0xF1, 0xF1, 0x0E, 0x18, 0x01, 0x22, 0x29, 0x46, 0xDB, 0xF8, 0x00, 0x00,
+	0xFF, 0xF7, 0x98, 0xFA,
+	0xD7, 0xF8, 0x00, 0x80, 0xDD, 0xE9, 0x05, 0x07, 0x31, 0xB2, 0x01, 0x91,
+	0xA9, 0x78, 0x07, 0xF0,
+	0x07, 0xFF, 0x06, 0x46, 0xA9, 0x78, 0x40, 0x46, 0x07, 0xF0, 0x10, 0xFF,
+	0x00, 0x90, 0xA9, 0x78,
+	0xDA, 0xF8, 0x08, 0x00, 0x07, 0xF0, 0x02, 0xFF, 0x01, 0x46, 0xAA, 0x78,
+	0x01, 0x23, 0xDF, 0xF8,
+	0x2C, 0xE3, 0x1D, 0xE0, 0x28, 0x78, 0x0E, 0xE0, 0x16, 0xF8, 0x00, 0xC0,
+	0xBC, 0x45, 0x09, 0xD1,
+	0x31, 0xF9, 0x10, 0x80, 0xDD, 0xF8, 0x04, 0xC0, 0xE0, 0x45, 0x03, 0xDD,
+	0xDD, 0xF8, 0x00, 0xC0,
+	0x0C, 0xF8, 0x00, 0x30, 0x40, 0x1C, 0x95, 0xF8, 0x01, 0xC0, 0x84, 0x45,
+	0xEC, 0xD2, 0x00, 0x98,
+	0x52, 0x1C, 0x28, 0x30, 0x00, 0x90, 0x9E, 0xF8, 0x00, 0x00, 0x28, 0x36,
+	0x01, 0xEB, 0x40, 0x01,
+	0xE8, 0x78, 0x90, 0x42, 0xDE, 0xD2, 0x00, 0x20, 0x84, 0xF8, 0x0E, 0x01,
+	0x28, 0x68, 0x20, 0x60,
+	0x01, 0x23, 0x00, 0x22, 0x21, 0x46, 0x5E, 0x46, 0xDB, 0xF8, 0x00, 0x00,
+	0xFF, 0xF7, 0x28, 0xFB,
+	0x94, 0xF8, 0x0E, 0x01, 0x01, 0x28, 0x26, 0xD9, 0x01, 0x25, 0x1D, 0xE0,
+	0x48, 0x22, 0x51, 0x46,
+	0x48, 0x46, 0x07, 0xF0, 0x7F, 0xFD, 0x04, 0xEB, 0x45, 0x00, 0x04, 0xEB,
+	0x85, 0x07, 0xB0, 0xF8,
+	0xB4, 0x10, 0xA9, 0xF8, 0x26, 0x10, 0x49, 0x46, 0x38, 0x46, 0xFF, 0xF7,
+	0x27, 0xFD, 0x3A, 0x46,
+	0xE9, 0xB2, 0x4B, 0x46, 0x30, 0x68, 0xFE, 0xF7, 0x0C, 0xFB, 0x3A, 0x46,
+	0xE9, 0xB2, 0x4B, 0x46,
+	0x30, 0x68, 0xFE, 0xF7, 0x85, 0xFA, 0x6D, 0x1C, 0x94, 0xF8, 0x0E, 0x01,
+	0xA8, 0x42, 0xDD, 0xD2,
+	0x09, 0xB0, 0xBD, 0xE8, 0xF0, 0x8F, 0xDD, 0xE9, 0x05, 0x01, 0x53, 0x46,
+	0x2A, 0x46, 0xFE, 0xF7,
+	0x77, 0xFA, 0xF5, 0xE7, 0x2D, 0xE9, 0xFF, 0x5F, 0x06, 0x46, 0x9A, 0x48,
+	0x1D, 0x46, 0x0B, 0x46,
+	0x00, 0x68, 0xDD, 0xE9, 0x0F, 0xB4, 0x92, 0x46, 0x98, 0x49, 0xB0, 0xF9,
+	0xE6, 0x22, 0x00, 0x92,
+	0x09, 0x78, 0x11, 0xB1, 0xB0, 0xF9, 0x62, 0x03, 0x00, 0x90, 0x18, 0x46,
+	0x0E, 0x99, 0x07, 0xF0,
+	0x7F, 0xFE, 0x81, 0x46, 0x30, 0x46, 0x0E, 0x99, 0x07, 0xF0, 0x88, 0xFE,
+	0x03, 0x90, 0xA0, 0x68,
+	0x0E, 0x99, 0x07, 0xF0, 0x7B, 0xFE, 0x2C, 0x78, 0x6D, 0x78, 0x80, 0x46,
+	0x5C, 0xB9, 0x99, 0xF8,
+	0x00, 0x10, 0x51, 0x45, 0x06, 0xD1, 0xB8, 0xF9, 0x00, 0x10, 0x59, 0x45,
+	0x02, 0xDD, 0x03, 0x99,
+	0x01, 0x20, 0x08, 0x70, 0x01, 0x24, 0x81, 0x48, 0x00, 0x78, 0x40, 0x1E,
+	0x85, 0x42, 0x54, 0xD1,
+	0x19, 0xF8, 0x05, 0x10, 0x51, 0x45, 0x06, 0xD1, 0x38, 0xF9, 0x15, 0x10,
+	0x59, 0x45, 0x02, 0xDD,
+	0x03, 0x99, 0x01, 0x20, 0x48, 0x55, 0x6D, 0x1E, 0xED, 0xB2, 0x46, 0xE0,
+	0x19, 0xF8, 0x04, 0x10,
+	0x51, 0x45, 0x41, 0xD1, 0x38, 0xF9, 0x14, 0x00, 0x01, 0x90, 0x58, 0x45,
+	0x3C, 0xDD, 0x00, 0x20,
+	0x02, 0x90, 0x77, 0x49, 0x0E, 0x98, 0x22, 0x46, 0x01, 0xEB, 0xC0, 0x00,
+	0x00, 0x21, 0xD0, 0xE9,
+	0x00, 0x67, 0x01, 0x20, 0x07, 0xF0, 0x82, 0xFC, 0x06, 0x40, 0x0F, 0x40,
+	0x3E, 0x43, 0x28, 0xD1,
+	0xDD, 0xE9, 0x00, 0x01, 0x08, 0xEB, 0x44, 0x02, 0x08, 0x44, 0x32, 0xF9,
+	0x02, 0x1C, 0x00, 0xB2,
+	0x81, 0x42, 0x05, 0xDD, 0xB2, 0xF9, 0x02, 0x30, 0x83, 0x42, 0x01, 0xDD,
+	0x01, 0x23, 0x02, 0x93,
+	0x01, 0x2C, 0x09, 0xD9, 0x32, 0xF9, 0x04, 0x3C, 0x83, 0x42, 0x05, 0xDD,
+	0xB2, 0xF9, 0x02, 0x30,
+	0x83, 0x42, 0x01, 0xDD, 0x01, 0x23, 0x02, 0x93, 0x5C, 0x4B, 0x1B, 0x78,
+	0x9B, 0x1E, 0x9C, 0x42,
+	0x05, 0xD2, 0x81, 0x42, 0x03, 0xDD, 0xB2, 0xF9, 0x04, 0x10, 0x81, 0x42,
+	0x04, 0xDC, 0x02, 0x98,
+	0x10, 0xB9, 0x03, 0x99, 0x01, 0x20, 0x08, 0x55, 0x64, 0x1C, 0xAC, 0x42,
+	0xB6, 0xD9, 0xCD, 0xE6,
+	0x2D, 0xE9, 0xFF, 0x4F, 0xDF, 0xF8, 0x54, 0xA1, 0xDF, 0xF8, 0x48, 0x81,
+	0x9B, 0xB0, 0x8B, 0x46,
+	0x9A, 0xF8, 0x00, 0x10, 0x28, 0x9E, 0xD8, 0xF8, 0x00, 0x00, 0x1D, 0x46,
+	0x11, 0xB1, 0x90, 0xF8,
+	0x68, 0x43, 0x01, 0xE0, 0x90, 0xF8, 0xE5, 0x42, 0x4E, 0x4F, 0xAC, 0xB1,
+	0x03, 0xA8, 0xCD, 0xE9,
+	0x00, 0x06, 0x02, 0xAB, 0x2A, 0x46, 0x58, 0x46, 0x1D, 0x99, 0xFF, 0xF7,
+	0x79, 0xFE, 0xBD, 0xF9,
+	0x0C, 0x00, 0xBD, 0xF9, 0x08, 0x10, 0x40, 0x1A, 0x60, 0x43, 0x64, 0x21,
+	0x90, 0xFB, 0xF1, 0xF0,
+	0x39, 0x88, 0x08, 0x44, 0x00, 0xB2, 0x01, 0xE0, 0xB7, 0xF9, 0x00, 0x00,
+	0x42, 0x49, 0x81, 0x46,
+	0x38, 0x88, 0x08, 0x80, 0x41, 0x49, 0xA1, 0xF8, 0x00, 0x90, 0xD8, 0xF8,
+	0x00, 0x00, 0xB0, 0xF9,
+	0xE6, 0x12, 0x11, 0x91, 0xB0, 0xF9, 0xE8, 0x12, 0x0C, 0x91, 0x9A, 0xF8,
+	0x00, 0x10, 0x29, 0xB1,
+	0xB0, 0xF9, 0x62, 0x13, 0x11, 0x91, 0xB0, 0xF9, 0x64, 0x03, 0x0C, 0x90,
+	0xAC, 0x78, 0x95, 0xF8,
+	0x03, 0x80, 0x4C, 0xB9, 0xCD, 0xE9, 0x00, 0x49, 0x02, 0x96, 0x2B, 0x46,
+	0x59, 0x46, 0x1D, 0x9A,
+	0x1B, 0x98, 0xFF, 0xF7, 0x1F, 0xFF, 0x01, 0x24, 0x31, 0x49, 0x09, 0x78,
+	0x49, 0x1E, 0x88, 0x45,
+	0x0D, 0xD1, 0xCD, 0xF8, 0x00, 0x80, 0xCD, 0xE9, 0x01, 0x96, 0x2B, 0x46,
+	0x59, 0x46, 0x1D, 0x9A,
+	0x1B, 0x98, 0xFF, 0xF7, 0x0F, 0xFF, 0xA8, 0xF1, 0x01, 0x00, 0x00, 0xF0,
+	0xFF, 0x08, 0xA0, 0x1E,
+	0xC1, 0xB2, 0xB0, 0x68, 0x07, 0xF0, 0xA2, 0xFD, 0x0D, 0x90, 0x60, 0x1E,
+	0xC1, 0xB2, 0xB0, 0x68,
+	0x07, 0xF0, 0x9C, 0xFD, 0x03, 0x90, 0x21, 0x46, 0xB0, 0x68, 0x07, 0xF0,
+	0x97, 0xFD, 0x02, 0x90,
+	0x60, 0x1C, 0xC1, 0xB2, 0xB0, 0x68, 0x07, 0xF0, 0x91, 0xFD, 0x01, 0x90,
+	0xA0, 0x1C, 0xC1, 0xB2,
+	0xB0, 0x68, 0x07, 0xF0, 0x8B, 0xFD, 0x04, 0x90, 0x21, 0x46, 0x58, 0x46,
+	0x07, 0xF0, 0x80, 0xFD,
+	0x83, 0x46, 0x21, 0x46, 0x1B, 0x98, 0x07, 0xF0, 0x89, 0xFD, 0x05, 0x90,
+	0x00, 0x20, 0x14, 0x90,
+	0x01, 0x20, 0x13, 0x90, 0x00, 0x20, 0x12, 0x90, 0x0A, 0x48, 0x00, 0x68,
+	0x90, 0xF8, 0x40, 0x14,
+	0xCA, 0x07, 0x29, 0xD0, 0x09, 0x07, 0x27, 0xD5, 0x69, 0x78, 0x2A, 0x78,
+	0x8A, 0x1A, 0x90, 0xF8,
+	0x49, 0x14, 0x52, 0x1C, 0x8A, 0x42, 0x1F, 0xDC, 0xEA, 0x78, 0x13, 0xE0,
+	0xEE, 0x06, 0x10, 0x00,
+	0x6C, 0x06, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00, 0x54, 0x06, 0x10, 0x00,
+	0xFD, 0x06, 0x10, 0x00,
+	0x98, 0x46, 0x10, 0x00, 0x92, 0x06, 0x10, 0x00, 0x8E, 0x07, 0x10, 0x00,
+	0x90, 0x07, 0x10, 0x00,
+	0xED, 0x06, 0x10, 0x00, 0xAB, 0x78, 0xD2, 0x1A, 0x52, 0x1C, 0x8A, 0x42,
+	0x04, 0xDC, 0xB0, 0xF8,
+	0x47, 0x04, 0xB1, 0x69, 0x81, 0x42, 0x01, 0xDD, 0x00, 0x20, 0x13, 0x90,
+	0xA2, 0x46, 0xF1, 0xE0,
+	0x2C, 0x78, 0xCE, 0xE0, 0x1B, 0xF8, 0x04, 0x10, 0x1D, 0x98, 0x81, 0x42,
+	0x6B, 0xD1, 0x00, 0x20,
+	0x10, 0x90, 0xFB, 0x49, 0x16, 0x90, 0x15, 0x90, 0x01, 0xEB, 0xCA, 0x00,
+	0x22, 0x46, 0xD0, 0xE9,
+	0x00, 0x67, 0x01, 0x20, 0x00, 0x21, 0x07, 0xF0, 0x71, 0xFB, 0x06, 0x40,
+	0x0F, 0x40, 0x3E, 0x43,
+	0x7E, 0xD1, 0xF4, 0x49, 0x40, 0xF2, 0xD2, 0x40, 0x08, 0x80, 0x02, 0x98,
+	0x0C, 0x9A, 0x30, 0xF8,
+	0x14, 0x10, 0x11, 0x98, 0x08, 0x44, 0x11, 0x44, 0x03, 0x9A, 0x00, 0xB2,
+	0x09, 0xB2, 0x32, 0xF9,
+	0x14, 0x20, 0x82, 0x42, 0x07, 0xDD, 0x01, 0x9B, 0x33, 0xF9, 0x14, 0x30,
+	0x83, 0x42, 0x02, 0xDD,
+	0x01, 0x23, 0x10, 0x93, 0x15, 0x93, 0xEC, 0xB3, 0xE7, 0x4B, 0x93, 0xF8,
+	0x00, 0xE0, 0xAE, 0xF1,
+	0x01, 0x03, 0x9C, 0x42, 0x68, 0xD0, 0x02, 0x9B, 0x03, 0xEB, 0x44, 0x0C,
+	0x3C, 0xF9, 0x02, 0x6C,
+	0x86, 0x42, 0x06, 0xDD, 0xBC, 0xF9, 0x02, 0x30, 0x83, 0x42, 0x02, 0xDD,
+	0x01, 0x23, 0x10, 0x93,
+	0x16, 0x93, 0x03, 0x9B, 0x03, 0xEB, 0x44, 0x03, 0x33, 0xF9, 0x02, 0x7C,
+	0x8F, 0x42, 0x08, 0xDD,
+	0x01, 0x9F, 0x07, 0xEB, 0x44, 0x07, 0xB7, 0xF9, 0x02, 0x70, 0x8F, 0x42,
+	0x01, 0xDD, 0x01, 0x27,
+	0x10, 0x97, 0xB3, 0xF9, 0x02, 0x30, 0x8B, 0x42, 0x06, 0xDD, 0x01, 0x9B,
+	0x03, 0xEB, 0x44, 0x03,
+	0x33, 0xF9, 0x02, 0x3C, 0x8B, 0x42, 0x41, 0xDC, 0x10, 0x99, 0x59, 0xB9,
+	0xBA, 0xF1, 0x01, 0x0F,
+	0x0F, 0xD9, 0x0D, 0x99, 0x31, 0xF9, 0x14, 0x10, 0x81, 0x42, 0x0A, 0xDD,
+	0x01, 0x99, 0x31, 0xF9,
+	0x14, 0x10, 0x01, 0xE0, 0x30, 0xE0, 0x5B, 0xE0, 0x81, 0x42, 0x02, 0xDD,
+	0x01, 0x21, 0x10, 0x91,
+	0x15, 0x91, 0xC6, 0x4B, 0x1B, 0x78, 0x9B, 0x1E, 0x9A, 0x45, 0x09, 0xD2,
+	0x82, 0x42, 0x07, 0xDD,
+	0x04, 0x99, 0x31, 0xF9, 0x14, 0x10, 0x81, 0x42, 0x02, 0xDD, 0x01, 0x21,
+	0x10, 0x91, 0x15, 0x91,
+	0x01, 0x2C, 0x0A, 0xD9, 0x3C, 0xF9, 0x04, 0x1C, 0x81, 0x42, 0x06, 0xDD,
+	0xBC, 0xF9, 0x02, 0x10,
+	0x81, 0x42, 0x02, 0xDD, 0x01, 0x21, 0x10, 0x91, 0x16, 0x91, 0xAE, 0xF1,
+	0x02, 0x01, 0x00, 0xE0,
+	0x17, 0xE0, 0x8C, 0x42, 0x08, 0xD2, 0x86, 0x42, 0x06, 0xDD, 0xBC, 0xF9,
+	0x04, 0x10, 0x81, 0x42,
+	0x02, 0xDD, 0x01, 0x20, 0x16, 0x90, 0x01, 0xE0, 0x10, 0x98, 0x48, 0xB1,
+	0xB0, 0x49, 0x41, 0xF2,
+	0xB3, 0x50, 0x08, 0x80, 0xAF, 0x48, 0xB0, 0x49, 0x04, 0x80, 0xA1, 0xF8,
+	0x00, 0xA0, 0x09, 0xE0,
+	0x40, 0xB9, 0x02, 0x98, 0x30, 0xF9, 0x14, 0x10, 0x49, 0x45, 0x03, 0xDD,
+	0x05, 0x99, 0x01, 0x20,
+	0x08, 0x55, 0x15, 0xE0, 0x16, 0x98, 0x98, 0xB1, 0x15, 0x98, 0x88, 0xB1,
+	0x13, 0x98, 0x78, 0xB1,
+	0x05, 0x98, 0x01, 0x21, 0x01, 0x55, 0x12, 0x98, 0x40, 0x1C, 0x80, 0xB2,
+	0x12, 0x90, 0xA3, 0x48,
+	0x00, 0x68, 0x90, 0xF8, 0x4A, 0x14, 0x12, 0x98, 0x81, 0x42, 0x01, 0xD2,
+	0x01, 0x20, 0x14, 0x90,
+	0x64, 0x1C, 0x68, 0x78, 0xA0, 0x42, 0xBF, 0xF4, 0x2D, 0xAF, 0x97, 0x48,
+	0x0D, 0x99, 0x0B, 0xF1,
+	0x28, 0x0B, 0x00, 0x78, 0x0A, 0xF1, 0x01, 0x0A, 0x01, 0xEB, 0x40, 0x01,
+	0x0D, 0x91, 0x03, 0x99,
+	0x01, 0xEB, 0x40, 0x01, 0x03, 0x91, 0x02, 0x99, 0x01, 0xEB, 0x40, 0x01,
+	0x02, 0x91, 0x01, 0x99,
+	0x01, 0xEB, 0x40, 0x01, 0x01, 0x91, 0x04, 0x99, 0x01, 0xEB, 0x40, 0x00,
+	0x04, 0x90, 0x05, 0x98,
+	0x28, 0x30, 0x05, 0x90, 0xC2, 0x45, 0x7F, 0xF6, 0x0B, 0xAF, 0x14, 0x98,
+	0x1F, 0xB0, 0xA8, 0xE5,
+	0x2D, 0xE9, 0xF0, 0x47, 0x04, 0x46, 0x91, 0x42, 0x5A, 0xD0, 0x07, 0xD9,
+	0x01, 0xEB, 0x02, 0x00,
+	0xA0, 0xEB, 0x02, 0x01, 0xCA, 0xB2, 0xA0, 0xEB, 0x02, 0x00, 0xC1, 0xB2,
+	0x01, 0xEB, 0xC1, 0x00,
+	0x04, 0xEB, 0xC0, 0x01, 0x02, 0xEB, 0xC2, 0x00, 0x04, 0xEB, 0xC0, 0x00,
+	0xB1, 0xF9, 0x32, 0x50,
+	0xB0, 0xF9, 0x32, 0x30, 0x81, 0x46, 0x9D, 0x42, 0x00, 0xDA, 0x4B, 0x86,
+	0xCB, 0x8C, 0xC5, 0x8C,
+	0x2B, 0x44, 0xCB, 0x84, 0x0B, 0x8D, 0x05, 0x8D, 0x2B, 0x44, 0x0B, 0x85,
+	0x4B, 0x8D, 0x45, 0x8D,
+	0x2B, 0x44, 0x4B, 0x85, 0x8B, 0x69, 0x85, 0x69, 0x2B, 0x44, 0x8B, 0x61,
+	0xC7, 0x69, 0xCE, 0x69,
+	0xCB, 0x68, 0xD9, 0xF8, 0x0C, 0x00, 0x4F, 0xEA, 0x23, 0x4C, 0x4F, 0xEA,
+	0x20, 0x48, 0x0C, 0xFB,
+	0x06, 0xFC, 0xF5, 0x19, 0x07, 0xFB, 0x08, 0xCC, 0x9C, 0xFB, 0xF5, 0xFC,
+	0x6C, 0xF3, 0x1F, 0x43,
+	0x0F, 0xFA, 0x83, 0xFC, 0x0C, 0xFB, 0x06, 0xFC, 0x00, 0xB2, 0x07, 0xFB,
+	0x00, 0xC0, 0x90, 0xFB,
+	0xF5, 0xF0, 0x60, 0xF3, 0x0F, 0x03, 0xCD, 0x61, 0xCB, 0x60, 0x94, 0xF8,
+	0x38, 0x04, 0x41, 0x1E,
+	0x91, 0x42, 0x08, 0xD0, 0x00, 0xEB, 0xC0, 0x00, 0x04, 0xEB, 0xC0, 0x01,
+	0x48, 0x46, 0x48, 0x22,
+	0x48, 0x39, 0x07, 0xF0, 0xAF, 0xFA, 0x94, 0xF8, 0x38, 0x04, 0x40, 0x1E,
+	0x84, 0xF8, 0x38, 0x04,
+	0xBD, 0xE8, 0xF0, 0x87, 0x2D, 0xE9, 0xFE, 0x4F, 0x07, 0x46, 0x58, 0x48,
+	0x8A, 0x46, 0x00, 0x25,
+	0x01, 0x68, 0xB1, 0xF8, 0xEA, 0x02, 0x00, 0xFB, 0x00, 0xF9, 0x55, 0x48,
+	0x00, 0x78, 0x18, 0xB1,
+	0xB1, 0xF8, 0x66, 0x03, 0x00, 0xFB, 0x00, 0xF9, 0x54, 0x46, 0x4F, 0xF0,
+	0x01, 0x0B, 0xB0, 0xE0,
+	0x0B, 0xFA, 0x04, 0xF0, 0x26, 0x46, 0x00, 0x90, 0x66, 0xE0, 0x00, 0xBF,
+	0x00, 0x99, 0x0B, 0xFA,
+	0x06, 0xF0, 0x08, 0x42, 0x5F, 0xD0, 0x06, 0xEB, 0xC6, 0x00, 0x07, 0xEB,
+	0xC0, 0x00, 0xC2, 0x68,
+	0x20, 0x46, 0x4D, 0xE0, 0xB0, 0x42, 0x4A, 0xD0, 0x00, 0xEB, 0xC0, 0x01,
+	0x07, 0xEB, 0xC1, 0x01,
+	0xC9, 0x68, 0x4F, 0xEA, 0x21, 0x4C, 0xAC, 0xEB, 0x22, 0x4C, 0x89, 0x1A,
+	0x0F, 0xFA, 0x8C, 0xFC,
+	0x09, 0xB2, 0x6C, 0xF3, 0x1F, 0x45, 0x61, 0xF3, 0x0F, 0x05, 0x8E, 0x46,
+	0x3B, 0x49, 0xCD, 0xF8,
+	0x04, 0xC0, 0x09, 0x68, 0x91, 0xF8, 0xE0, 0xC2, 0xCD, 0xF8, 0x08, 0xC0,
+	0x5F, 0xEA, 0x8C, 0x6C,
+	0x0B, 0xD5, 0x91, 0xF8, 0xED, 0x82, 0x0E, 0xFB, 0x08, 0xFC, 0x4F, 0xF0,
+	0x64, 0x08, 0x9C, 0xFB,
+	0xF8, 0xF8, 0x08, 0xEB, 0x0E, 0x0C, 0x6C, 0xF3, 0x0F, 0x05, 0xDD, 0xF8,
+	0x08, 0xC0, 0x5F, 0xEA,
+	0xCC, 0x6C, 0x0C, 0xD5, 0x91, 0xF8, 0xED, 0x12, 0xDD, 0xF8, 0x04, 0xC0,
+	0x0C, 0xFB, 0x01, 0xFC,
+	0x64, 0x21, 0x9C, 0xFB, 0xF1, 0xFC, 0x01, 0x99, 0x61, 0x44, 0x61, 0xF3,
+	0x1F, 0x45, 0x4F, 0xEA,
+	0x25, 0x4C, 0x0C, 0xFB, 0x0C, 0xFC, 0x29, 0xB2, 0x01, 0xFB, 0x01, 0xC1,
+	0x49, 0x45, 0x06, 0xD2,
+	0xDD, 0xF8, 0x00, 0xC0, 0x0B, 0xFA, 0x00, 0xF1, 0x41, 0xEA, 0x0C, 0x01,
+	0x00, 0x91, 0x40, 0x1C,
+	0x83, 0x42, 0xAF, 0xD8, 0x04, 0x21, 0x68, 0x46, 0xF1, 0xF7, 0x3D, 0xFA,
+	0x01, 0x28, 0x02, 0xD1,
+	0x00, 0x98, 0x40, 0x00, 0x00, 0x90, 0x76, 0x1C, 0x97, 0xF8, 0x38, 0x34,
+	0xB3, 0x42, 0x95, 0xD8,
+	0x04, 0x21, 0x68, 0x46, 0xF1, 0xF7, 0x2F, 0xFA, 0x01, 0x28, 0x0B, 0xD0,
+	0x04, 0x21, 0x68, 0x46,
+	0xF1, 0xF7, 0x29, 0xFA, 0x97, 0xF8, 0x38, 0x64, 0xA6, 0xEB, 0x0A, 0x01,
+	0x88, 0x42, 0x06, 0xD1,
+	0x87, 0xF8, 0x38, 0xA4, 0xBD, 0xE8, 0xFE, 0x8F, 0x64, 0x1C, 0xE4, 0xB2,
+	0x01, 0xE0, 0x00, 0x99,
+	0x58, 0x46, 0x00, 0xFA, 0x04, 0xF2, 0x0A, 0x42, 0xF6, 0xD0, 0xD8, 0x46,
+	0x1C, 0xE0, 0x00, 0x00,
+	0x98, 0x46, 0x10, 0x00, 0x86, 0x07, 0x10, 0x00, 0xEE, 0x06, 0x10, 0x00,
+	0xED, 0x06, 0x10, 0x00,
+	0x88, 0x07, 0x10, 0x00, 0x8A, 0x07, 0x10, 0x00, 0x8C, 0x07, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0xFD, 0x06, 0x10, 0x00, 0x00, 0x99, 0x08, 0xFA, 0x06, 0xF0, 0x08, 0x42,
+	0x04, 0xD0, 0xF2, 0xB2,
+	0x21, 0x46, 0x38, 0x46, 0xFF, 0xF7, 0xDC, 0xFE, 0x76, 0x1E, 0xA6, 0x42,
+	0xF2, 0xD8, 0x64, 0x1C,
+	0xE4, 0xB2, 0x97, 0xF8, 0x38, 0x04, 0xA0, 0x42, 0x3F, 0xF6, 0x4A, 0xAF,
+	0xCA, 0xE7, 0x2D, 0xE9,
+	0xFF, 0x4F, 0xFB, 0x48, 0xFB, 0x4C, 0x93, 0x46, 0x06, 0x68, 0x81, 0xB0,
+	0x1D, 0x46, 0x06, 0xF5,
+	0x88, 0x7A, 0x01, 0x22, 0x59, 0x46, 0x20, 0x68, 0xFE, 0xF7, 0x92, 0xFE,
+	0x00, 0x95, 0xDD, 0xE9,
+	0x01, 0x12, 0x5B, 0x46, 0x20, 0x68, 0xFF, 0xF7, 0xFB, 0xFC, 0x03, 0x00,
+	0x4F, 0xF0, 0x01, 0x01,
+	0x05, 0xD0, 0xF1, 0x48, 0x01, 0x70, 0xA8, 0x8C, 0x40, 0xF0, 0x80, 0x00,
+	0xA8, 0x84, 0xEF, 0x48,
+	0x00, 0x78, 0x50, 0xB1, 0x4B, 0xB9, 0x95, 0xF8, 0x24, 0x00, 0x10, 0xF0,
+	0x06, 0x0F, 0x04, 0xD1,
+	0x59, 0x46, 0x28, 0x46, 0xFE, 0xF7, 0xA8, 0xFE, 0x03, 0x46, 0x00, 0x20,
+	0x86, 0xF8, 0x0E, 0x01,
+	0xDB, 0xF8, 0x00, 0x00, 0x30, 0x60, 0xE3, 0x48, 0x00, 0x22, 0x31, 0x46,
+	0x00, 0x68, 0xFE, 0xF7,
+	0x3F, 0xFF, 0x96, 0xF8, 0x0E, 0x01, 0x00, 0x24, 0x01, 0x28, 0x79, 0xD9,
+	0xFC, 0xF7, 0x61, 0xF9,
+	0x81, 0x46, 0xFC, 0xF7, 0x5C, 0xF9, 0x80, 0x46, 0xDB, 0xF8, 0x00, 0x20,
+	0xDD, 0xE9, 0x01, 0x01,
+	0x00, 0x92, 0xDB, 0x4B, 0x6A, 0x46, 0xFE, 0xF7, 0x0A, 0xFE, 0x60, 0xB1,
+	0x69, 0x46, 0xD8, 0x48,
+	0xFE, 0xF7, 0x9E, 0xFD, 0x2A, 0x46, 0x69, 0x46, 0xD5, 0x48, 0xFD, 0xF7,
+	0xD8, 0xFA, 0xE9, 0x68,
+	0x69, 0x61, 0xE9, 0x69, 0x29, 0x62, 0x01, 0x27, 0x2F, 0xE0, 0x48, 0x22,
+	0x29, 0x46, 0x50, 0x46,
+	0x07, 0xF0, 0x78, 0xF9, 0xCF, 0x49, 0x06, 0xEB, 0x47, 0x00, 0x09, 0x68,
+	0xB0, 0xF8, 0xB4, 0x20,
+	0x91, 0xF8, 0xEC, 0x12, 0x8A, 0x42, 0x1F, 0xD9, 0xBA, 0xF8, 0x24, 0x10,
+	0x41, 0xF0, 0x10, 0x02,
+	0xAA, 0xF8, 0x24, 0x20, 0xB0, 0xF8, 0xB4, 0x10, 0xAA, 0xF8, 0x26, 0x10,
+	0x06, 0xEB, 0x87, 0x00,
+	0x51, 0x46, 0x00, 0x90, 0xFF, 0xF7, 0x12, 0xF9, 0xBE, 0x48, 0xF9, 0xB2,
+	0x53, 0x46, 0x00, 0x9A,
+	0x00, 0x68, 0xFD, 0xF7, 0xF6, 0xFE, 0xBB, 0x48, 0xF9, 0xB2, 0x53, 0x46,
+	0x00, 0x9A, 0x00, 0x68,
+	0xFD, 0xF7, 0x6E, 0xFE, 0x64, 0x1C, 0xE4, 0xB2, 0x7F, 0x1C, 0x96, 0xF8,
+	0x0E, 0x01, 0xB8, 0x42,
+	0xCB, 0xD2, 0xB8, 0x4E, 0x30, 0x68, 0x90, 0xF8, 0xE0, 0x02, 0x00, 0x07,
+	0x0A, 0xD5, 0x01, 0x2C,
+	0x08, 0xD9, 0x49, 0x46, 0x40, 0x46, 0xFF, 0xF7, 0x95, 0xFE, 0xFC, 0xF7,
+	0x02, 0xF9, 0xA0, 0xEB,
+	0x09, 0x00, 0xC4, 0xB2, 0x31, 0x68, 0x91, 0xF8, 0xE0, 0x02, 0x00, 0x06,
+	0x13, 0xD5, 0x20, 0x46,
+	0x0F, 0xE0, 0x00, 0xBF, 0x09, 0xEB, 0x00, 0x02, 0xD2, 0xB2, 0x02, 0xEB,
+	0xC2, 0x03, 0x08, 0xEB,
+	0xC3, 0x02, 0x91, 0xF8, 0x07, 0x33, 0xD2, 0x8C, 0x9A, 0x42, 0x02, 0xD9,
+	0x88, 0xF8, 0x38, 0x94,
+	0x05, 0xE0, 0x40, 0x1E, 0xEE, 0xD2, 0x01, 0x2C, 0x0A, 0xD0, 0x00, 0x2C,
+	0x0E, 0xD1, 0xDD, 0xE9,
+	0x01, 0x01, 0x05, 0xB0, 0x2B, 0x46, 0x5A, 0x46, 0xBD, 0xE8, 0xF0, 0x4F,
+	0xFD, 0xF7, 0x30, 0xBE,
+	0x98, 0xF8, 0x38, 0x04, 0x40, 0x1E, 0x88, 0xF8, 0x38, 0x04, 0xF0, 0xE7,
+	0x05, 0xB0, 0xBD, 0xE8,
+	0xF0, 0x8F, 0x2D, 0xE9, 0xFF, 0x4F, 0x97, 0x48, 0x81, 0xB0, 0x00, 0x68,
+	0x90, 0xF8, 0xE1, 0x02,
+	0xC0, 0x07, 0xF3, 0xD0, 0xA8, 0x21, 0x04, 0x98, 0x07, 0xF0, 0x58, 0xF9,
+	0x01, 0x25, 0x44, 0xE0,
+	0x03, 0x98, 0x00, 0xEB, 0x85, 0x00, 0x82, 0x46, 0x84, 0x78, 0x90, 0xF8,
+	0x03, 0x90, 0x8E, 0x48,
+	0x00, 0x78, 0x40, 0x1E, 0x84, 0x42, 0x01, 0xDA, 0x64, 0x1C, 0xE4, 0xB2,
+	0xB9, 0xF1, 0x00, 0x0F,
+	0x03, 0xD0, 0xA9, 0xF1, 0x01, 0x00, 0x00, 0xF0, 0xFF, 0x09, 0x21, 0x46,
+	0x01, 0x98, 0x07, 0xF0,
+	0x1F, 0xFA, 0x83, 0x46, 0xA0, 0x46, 0x24, 0xE0, 0x03, 0x98, 0x04, 0x99,
+	0x10, 0xF8, 0x25, 0x40,
+	0x01, 0xEB, 0xC8, 0x00, 0x00, 0x90, 0x12, 0xE0, 0x1B, 0xF8, 0x04, 0x00,
+	0xA8, 0x42, 0x0C, 0xD1,
+	0x00, 0x98, 0x22, 0x46, 0x00, 0x21, 0xD0, 0xE9, 0x00, 0x67, 0x01, 0x20,
+	0x07, 0xF0, 0x4E, 0xF8,
+	0x06, 0x43, 0x00, 0x98, 0x0F, 0x43, 0xC0, 0xE9, 0x00, 0x67, 0x64, 0x1C,
+	0xE4, 0xB2, 0x9A, 0xF8,
+	0x01, 0x00, 0xA0, 0x42, 0xE8, 0xD2, 0x08, 0xF1, 0x01, 0x00, 0x0B, 0xF1,
+	0x28, 0x0B, 0x00, 0xF0,
+	0xFF, 0x08, 0xC8, 0x45, 0xD8, 0xD9, 0x6D, 0x1C, 0xED, 0xB2, 0x02, 0x98,
+	0x85, 0x42, 0xB7, 0xD9,
+	0x00, 0x21, 0x6D, 0x4E, 0x13, 0xE0, 0x04, 0x98, 0x00, 0xEB, 0xC1, 0x05,
+	0x01, 0xF1, 0x01, 0x01,
+	0xD5, 0xE9, 0x00, 0x32, 0xDC, 0x18, 0x42, 0xEB, 0x02, 0x00, 0x52, 0x08,
+	0x4F, 0xEA, 0x33, 0x03,
+	0x04, 0xEA, 0x03, 0x04, 0x00, 0xEA, 0x02, 0x00, 0xC5, 0xE9, 0x00, 0x40,
+	0xC9, 0xB2, 0x30, 0x78,
+	0x81, 0x42, 0xE8, 0xD3, 0x8A, 0xE7, 0xF0, 0xB4, 0x60, 0x4D, 0x00, 0x24,
+	0x2C, 0x80, 0x60, 0x4D,
+	0x2C, 0x80, 0x60, 0x4D, 0x2C, 0x80, 0x60, 0x4D, 0x2C, 0x80, 0x14, 0x68,
+	0xC3, 0xF8, 0x3A, 0x40,
+	0x58, 0x4C, 0x25, 0x68, 0x95, 0xF8, 0xE0, 0x42, 0xA6, 0x07, 0x13, 0xD4,
+	0x93, 0xF8, 0x40, 0x60,
+	0x01, 0x2E, 0x0F, 0xD0, 0x66, 0x07, 0x13, 0xD5, 0x64, 0x06, 0x09, 0xD5,
+	0x57, 0x4C, 0x64, 0x78,
+	0x5C, 0xB1, 0xB5, 0xF8, 0xF0, 0x42, 0x56, 0x4D, 0x64, 0x43, 0x2D, 0x68,
+	0xA5, 0x42, 0x07, 0xDC,
+	0xF0, 0xBC, 0x94, 0xE6, 0xF0, 0xBC, 0xFF, 0xF7, 0x73, 0xBA, 0xB5, 0xF8,
+	0xEE, 0x42, 0xF2, 0xE7,
+	0xF0, 0xBC, 0xFD, 0xF7, 0x85, 0xBD, 0x2D, 0xE9, 0xFF, 0x4F, 0x94, 0x78,
+	0xD7, 0x78, 0x15, 0x78,
+	0x56, 0x78, 0x81, 0xB0, 0x98, 0x46, 0x82, 0x46, 0x04, 0xB9, 0x01, 0x24,
+	0x42, 0x48, 0x00, 0x78,
+	0x40, 0x1E, 0x87, 0x42, 0x01, 0xD1, 0x7F, 0x1E, 0xFF, 0xB2, 0x05, 0xB9,
+	0x01, 0x25, 0xDF, 0xF8,
+	0x14, 0xB1, 0x9B, 0xF8, 0x00, 0x00, 0x40, 0x1E, 0x86, 0x42, 0x01, 0xD1,
+	0x76, 0x1E, 0xF6, 0xB2,
+	0x60, 0x1E, 0xC1, 0xB2, 0xD8, 0xF8, 0x08, 0x00, 0x07, 0xF0, 0x88, 0xF9,
+	0x00, 0x90, 0x21, 0x46,
+	0xD8, 0xF8, 0x08, 0x00, 0x07, 0xF0, 0x82, 0xF9, 0x81, 0x46, 0x60, 0x1C,
+	0xC1, 0xB2, 0xD8, 0xF8,
+	0x08, 0x00, 0x07, 0xF0, 0x7B, 0xF9, 0x80, 0x46, 0x21, 0x46, 0x50, 0x46,
+	0x07, 0xF0, 0x70, 0xF9,
+	0x35, 0xE0, 0x2C, 0x4A, 0x29, 0x46, 0xD2, 0xF8, 0x00, 0xA0, 0x24, 0xE0,
+	0x43, 0x5C, 0x02, 0x9A,
+	0x93, 0x42, 0x1E, 0xD1, 0x39, 0xF8, 0x11, 0x30, 0x9A, 0xF8, 0x27, 0x24,
+	0x1A, 0x44, 0x00, 0x9B,
+	0x12, 0xB2, 0x03, 0xEB, 0x41, 0x03, 0x33, 0xF9, 0x02, 0xCC, 0x94, 0x45,
+	0x05, 0xDD, 0x08, 0xEB,
+	0x41, 0x0C, 0xBC, 0xF9, 0x02, 0xC0, 0x94, 0x45, 0x09, 0xDC, 0xB3, 0xF9,
+	0x02, 0x30, 0x93, 0x42,
+	0x07, 0xDD, 0x08, 0xEB, 0x41, 0x03, 0x33, 0xF9, 0x02, 0x3C, 0x93, 0x42,
+	0x01, 0xDD, 0x01, 0x20,
+	0xFC, 0xE6, 0x49, 0x1C, 0xC9, 0xB2, 0xB1, 0x42, 0xD8, 0xD9, 0xCD, 0xF8,
+	0x00, 0x90, 0x9B, 0xF8,
+	0x00, 0x20, 0x64, 0x1C, 0xC1, 0x46, 0x08, 0xEB, 0x42, 0x08, 0xE4, 0xB2,
+	0x28, 0x30, 0xBC, 0x42,
+	0xC7, 0xD9, 0x00, 0x20, 0xEA, 0xE6, 0x2D, 0xE9, 0xF8, 0x4F, 0x4F, 0xF0,
+	0x00, 0x0A, 0x89, 0x46,
+	0x04, 0x46, 0x01, 0x26, 0x57, 0x46, 0xD0, 0x46, 0x85, 0x78, 0x46, 0xE0,
+	0x29, 0x46, 0xD9, 0xF8,
+	0x08, 0x00, 0x07, 0xF0, 0x2B, 0xF9, 0x02, 0x46, 0x00, 0x20, 0x21, 0x78,
+	0x63, 0x78, 0x20, 0xE0,
+	0x6C, 0x06, 0x10, 0x00, 0x54, 0x06, 0x10, 0x00, 0x34, 0x06, 0x10, 0x00,
+	0xA4, 0x06, 0x10, 0x00,
+	0xF0, 0x45, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00, 0xED, 0x06, 0x10, 0x00,
+	0x86, 0x07, 0x10, 0x00,
+	0x88, 0x07, 0x10, 0x00, 0x8A, 0x07, 0x10, 0x00, 0x8C, 0x07, 0x10, 0x00,
+	0x74, 0x07, 0x10, 0x00,
+	0x24, 0x07, 0x10, 0x00, 0xEE, 0x06, 0x10, 0x00, 0x32, 0xF9, 0x11, 0xC0,
+	0x49, 0x1C, 0x60, 0x44,
+	0xC9, 0xB2, 0x8B, 0x42, 0xF8, 0xD2, 0xA1, 0x78, 0x4A, 0x1C, 0xAA, 0x42,
+	0x10, 0xD2, 0x46, 0x4A,
+	0x12, 0x68, 0xB2, 0xF8, 0x28, 0x34, 0x03, 0xEB, 0x08, 0x02, 0xBA, 0x42,
+	0x01, 0xDA, 0x82, 0x42,
+	0x33, 0xDB, 0x89, 0x1C, 0xA9, 0x42, 0x03, 0xD2, 0x52, 0x45, 0x01, 0xDA,
+	0x82, 0x42, 0x2C, 0xDB,
+	0xBA, 0x46, 0x47, 0x46, 0x6D, 0x1C, 0x80, 0x46, 0xED, 0xB2, 0xE0, 0x78,
+	0xA8, 0x42, 0xB5, 0xD2,
+	0x00, 0x20, 0x00, 0x90, 0x82, 0x46, 0x83, 0x46, 0x25, 0x78, 0x2E, 0xE0,
+	0x4F, 0xF0, 0x00, 0x08,
+	0xA7, 0x78, 0x09, 0xE0, 0x39, 0x46, 0xD9, 0xF8, 0x08, 0x00, 0x07, 0xF0,
+	0xD7, 0xF8, 0x30, 0xF9,
+	0x15, 0x10, 0x7F, 0x1C, 0x88, 0x44, 0xFF, 0xB2, 0xE0, 0x78, 0xB8, 0x42,
+	0xF2, 0xD2, 0x20, 0x78,
+	0x41, 0x1C, 0xA9, 0x42, 0x13, 0xD2, 0x2C, 0x49, 0x09, 0x68, 0xB1, 0xF8,
+	0x28, 0x24, 0x02, 0xEB,
+	0x0B, 0x01, 0x51, 0x45, 0x03, 0xDA, 0x41, 0x45, 0x01, 0xDA, 0x00, 0x26,
+	0x10, 0xE0, 0x80, 0x1C,
+	0xA8, 0x42, 0x04, 0xD2, 0x00, 0x98, 0x81, 0x42, 0x01, 0xDA, 0x41, 0x45,
+	0xF5, 0xDB, 0xCD, 0xF8,
+	0x00, 0xA0, 0xDA, 0x46, 0x6D, 0x1C, 0xC3, 0x46, 0xED, 0xB2, 0x60, 0x78,
+	0xA8, 0x42, 0xCD, 0xD2,
+	0x30, 0x46, 0xBD, 0xE8, 0xF8, 0x8F, 0x2D, 0xE9, 0xF0, 0x41, 0x07, 0x46,
+	0x98, 0x8C, 0x14, 0x46,
+	0x00, 0x26, 0x1D, 0x46, 0xC2, 0x05, 0x02, 0xD5, 0x01, 0x20, 0xBD, 0xE8,
+	0xF0, 0x81, 0x00, 0x06,
+	0x27, 0xD4, 0x15, 0x48, 0xEA, 0x8C, 0x00, 0x68, 0x90, 0xF8, 0x23, 0x34,
+	0x9A, 0x42, 0x20, 0xD3,
+	0xB0, 0xF8, 0x24, 0x34, 0xAA, 0x69, 0x9A, 0x42, 0x1B, 0xDC, 0x62, 0x78,
+	0x23, 0x78, 0x90, 0xF8,
+	0x26, 0x04, 0xD2, 0x1A, 0x52, 0x1C, 0x82, 0x42, 0x13, 0xDC, 0xE2, 0x78,
+	0xA3, 0x78, 0xD2, 0x1A,
+	0x52, 0x1C, 0x82, 0x42, 0x0D, 0xDC, 0x2B, 0x46, 0x22, 0x46, 0x38, 0x46,
+	0xFF, 0xF7, 0xD3, 0xFE,
+	0x01, 0x28, 0x06, 0xD1, 0x29, 0x46, 0x20, 0x46, 0xFF, 0xF7, 0x3D, 0xFF,
+	0x01, 0x28, 0x00, 0xD1,
+	0x01, 0x26, 0x30, 0x46, 0xD1, 0xE7, 0x00, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x70, 0x47, 0xF0, 0xB5,
+	0x99, 0x4B, 0x02, 0x46, 0x0C, 0x46, 0x1F, 0x78, 0x98, 0x4B, 0x1E, 0x68,
+	0x98, 0x4B, 0x1D, 0x78,
+	0x19, 0xE0, 0x2B, 0x46, 0x11, 0xE0, 0x00, 0xBF, 0x34, 0xF8, 0x13, 0xC0,
+	0x32, 0xF8, 0x13, 0xE0,
+	0xAC, 0xEB, 0x0E, 0x0C, 0xB6, 0xF9, 0x46, 0xE0, 0x0F, 0xFA, 0x8C, 0xFC,
+	0x1E, 0xEB, 0x0C, 0x0F,
+	0x22, 0xD4, 0xB6, 0xF8, 0x48, 0xE0, 0xE6, 0x45, 0x1E, 0xDB, 0x5B, 0x1E,
+	0xEC, 0xD1, 0x02, 0xEB,
+	0x45, 0x02, 0x04, 0xEB, 0x45, 0x04, 0x7F, 0x1E, 0xE3, 0xD2, 0x96, 0xF8,
+	0x44, 0x20, 0x89, 0x4B,
+	0x02, 0xF0, 0x0F, 0x02, 0xC2, 0xF1, 0x10, 0x04, 0xB3, 0xF9, 0x00, 0x30,
+	0x0A, 0xE0, 0x00, 0xBF,
+	0x31, 0xF9, 0x13, 0x50, 0x30, 0xF9, 0x13, 0x60, 0x55, 0x43, 0x06, 0xFB,
+	0x04, 0x55, 0x2D, 0x11,
+	0x21, 0xF8, 0x13, 0x50, 0x5B, 0x1E, 0xF3, 0xD2, 0xF0, 0xBD, 0xF0, 0xB5,
+	0x14, 0x46, 0x05, 0x9F,
+	0x0B, 0xE0, 0x00, 0xBF, 0x31, 0xF9, 0x14, 0x50, 0x30, 0xF9, 0x14, 0x60,
+	0x05, 0xEB, 0x03, 0x0C,
+	0xB4, 0x45, 0x19, 0xDB, 0xED, 0x1B, 0xB5, 0x42, 0x16, 0xDC, 0x64, 0x1E,
+	0xF2, 0xD1, 0x73, 0x4B,
+	0x1B, 0x68, 0x93, 0xF8, 0x45, 0x30, 0x1B, 0x09, 0xC3, 0xF1, 0x10, 0x04,
+	0x0A, 0xE0, 0x00, 0xBF,
+	0x31, 0xF9, 0x12, 0x50, 0x30, 0xF9, 0x12, 0x60, 0x5D, 0x43, 0x06, 0xFB,
+	0x04, 0x55, 0x2D, 0x11,
+	0x21, 0xF8, 0x12, 0x50, 0x52, 0x1E, 0xF3, 0xD2, 0xF0, 0xBD, 0x2D, 0xE9,
+	0xF0, 0x43, 0x81, 0x46,
+	0x66, 0x48, 0x69, 0x4C, 0x00, 0x68, 0x30, 0xF9, 0x5B, 0x6F, 0xB0, 0xF9,
+	0x02, 0x70, 0x10, 0xF8,
+	0x01, 0x0C, 0x00, 0xF0, 0x0F, 0x03, 0xC3, 0xF1, 0x10, 0x08, 0x00, 0x20,
+	0x17, 0xE0, 0x00, 0xBF,
+	0x34, 0xF9, 0x10, 0x20, 0x39, 0xF9, 0x10, 0x50, 0x02, 0xEB, 0x06, 0x0C,
+	0x65, 0x45, 0x0C, 0xDC,
+	0xA2, 0xEB, 0x07, 0x0C, 0x65, 0x45, 0x08, 0xDB, 0x5A, 0x43, 0x05, 0xFB,
+	0x08, 0x22, 0xD5, 0x17,
+	0x02, 0xEB, 0x15, 0x72, 0x12, 0x11, 0x24, 0xF8, 0x10, 0x20, 0x40, 0x1C,
+	0xC0, 0xB2, 0x88, 0x42,
+	0xE6, 0xD3, 0xBD, 0xE8, 0xF0, 0x83, 0x2D, 0xE9, 0xF8, 0x4F, 0x0D, 0x46,
+	0x04, 0x46, 0x01, 0xF0,
+	0x7F, 0xF8, 0x00, 0x28, 0x5B, 0xD1, 0xE8, 0x07, 0x08, 0xD0, 0x50, 0x48,
+	0x50, 0x49, 0x00, 0x78,
+	0x09, 0x68, 0x01, 0x28, 0x20, 0x68, 0x2D, 0xD0, 0x00, 0xF0, 0x53, 0xF8,
+	0x47, 0x4E, 0xE8, 0x06,
+	0x17, 0xD5, 0x30, 0x68, 0xB0, 0xF9, 0x50, 0x10, 0x00, 0x91, 0x43, 0x49,
+	0xB0, 0xF9, 0x4E, 0x30,
+	0x20, 0x69, 0x0A, 0x78, 0x47, 0x49, 0xFF, 0xF7, 0x88, 0xFF, 0x30, 0x68,
+	0xB0, 0xF9, 0x54, 0x10,
+	0x00, 0x91, 0x3F, 0x49, 0xB0, 0xF9, 0x52, 0x30, 0x60, 0x69, 0x0A, 0x78,
+	0x42, 0x49, 0xFF, 0xF7,
+	0x7C, 0xFF, 0xA8, 0x07, 0x2B, 0xD5, 0x36, 0x68, 0x41, 0x49, 0xA7, 0x68,
+	0x96, 0xF8, 0x45, 0x00,
+	0xDF, 0xF8, 0xF8, 0x90, 0x00, 0xF0, 0x0F, 0x03, 0xC3, 0xF1, 0x10, 0x0A,
+	0x00, 0x20, 0xB1, 0xF9,
+	0x00, 0xC0, 0x1A, 0xE0, 0xFF, 0xF7, 0x2B, 0xFF, 0xD0, 0xE7, 0x00, 0xBF,
+	0x39, 0xF9, 0x10, 0x10,
+	0xB6, 0xF9, 0x56, 0x80, 0x37, 0xF9, 0x10, 0x20, 0x88, 0x44, 0x90, 0x45,
+	0x0B, 0xDB, 0xB6, 0xF9,
+	0x58, 0x80, 0xA1, 0xEB, 0x08, 0x08, 0x90, 0x45, 0x05, 0xDC, 0x59, 0x43,
+	0x02, 0xFB, 0x0A, 0x11,
+	0x0A, 0x11, 0x29, 0xF8, 0x10, 0x20, 0x40, 0x1C, 0x00, 0xB2, 0x60, 0x45,
+	0xE6, 0xDB, 0xA8, 0x05,
+	0x05, 0xD5, 0x94, 0xF8, 0x32, 0x10, 0xA0, 0x69, 0xBD, 0xE8, 0xF8, 0x4F,
+	0x6D, 0xE7, 0xBD, 0xE8,
+	0xF8, 0x8F, 0x2D, 0xE9, 0xF0, 0x43, 0x81, 0x46, 0x26, 0x48, 0x03, 0x78,
+	0x1B, 0x48, 0x05, 0x2B,
+	0x00, 0x68, 0x90, 0xF8, 0x44, 0x20, 0x0C, 0xD0, 0x30, 0xF9, 0x46, 0x5F,
+	0x02, 0xF0, 0x0F, 0x03,
+	0xB0, 0xF9, 0x02, 0x60, 0x17, 0x48, 0xC3, 0xF1, 0x10, 0x04, 0xB0, 0xF9,
+	0x00, 0x00, 0x02, 0x46,
+	0x11, 0xE0, 0x30, 0xF9, 0x4A, 0x5F, 0x13, 0x09, 0xB0, 0xF9, 0x02, 0x60,
+	0xF2, 0xE7, 0x00, 0xBF,
+	0x31, 0xF9, 0x12, 0x70, 0x39, 0xF9, 0x12, 0xC0, 0x07, 0xEB, 0x05, 0x08,
+	0xE0, 0x45, 0x11, 0xDB,
+	0xBF, 0x1B, 0x67, 0x45, 0x0E, 0xDC, 0x52, 0x1E, 0xF2, 0xD2, 0x09, 0xE0,
+	0x31, 0xF9, 0x10, 0x20,
+	0x39, 0xF9, 0x10, 0x50, 0x5A, 0x43, 0x05, 0xFB, 0x04, 0x22, 0x12, 0x11,
+	0x21, 0xF8, 0x10, 0x20,
+	0x40, 0x1E, 0xF3, 0xD2, 0x5D, 0xE7, 0x00, 0x00, 0xED, 0x06, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0xEE, 0x06, 0x10, 0x00, 0xFE, 0x06, 0x10, 0x00, 0xFC, 0x4A, 0x01, 0x20,
+	0xF3, 0x06, 0x10, 0x00,
+	0x1C, 0x07, 0x10, 0x00, 0x7E, 0x4A, 0x01, 0x20, 0xA8, 0x4A, 0x01, 0x20,
+	0xF4, 0x4A, 0x01, 0x20,
+	0x00, 0x07, 0x10, 0x00, 0xEC, 0x06, 0x10, 0x00, 0x87, 0x48, 0x00, 0x68,
+	0x90, 0xF8, 0x90, 0x02,
+	0x40, 0x07, 0x07, 0xD5, 0x85, 0x48, 0x86, 0x49, 0xC0, 0x78, 0x09, 0x78,
+	0x88, 0x42, 0x01, 0xD0,
+	0x01, 0x20, 0x70, 0x47, 0x00, 0x20, 0x70, 0x47, 0x7F, 0x48, 0x10, 0xB5,
+	0x00, 0x68, 0x90, 0xF8,
+	0x90, 0x12, 0x89, 0x07, 0x27, 0xD5, 0x7F, 0x49, 0x0A, 0x78, 0x52, 0x1C,
+	0xD2, 0xB2, 0x0A, 0x70,
+	0x90, 0xF8, 0x92, 0x32, 0x93, 0x42, 0x1E, 0xD2, 0x00, 0x22, 0x0A, 0x70,
+	0x90, 0xF8, 0x50, 0x12,
+	0x03, 0x24, 0xC9, 0x07, 0x03, 0xD1, 0x90, 0xF8, 0x80, 0x02, 0xC0, 0x07,
+	0x00, 0xD0, 0x0B, 0x24,
+	0xEF, 0xF7, 0x36, 0xFE, 0x74, 0x48, 0x01, 0x68, 0x21, 0x43, 0x01, 0x60,
+	0xEF, 0xF7, 0x2E, 0xFE,
+	0x10, 0x21, 0x05, 0x20, 0x02, 0xF0, 0x6F, 0xF9, 0xBD, 0xE8, 0x10, 0x40,
+	0x4F, 0xF4, 0x80, 0x71,
+	0x00, 0x20, 0xEF, 0xF7, 0x66, 0xBF, 0x10, 0xBD, 0x68, 0x48, 0x6C, 0x49,
+	0x4F, 0xF0, 0x00, 0x02,
+	0x43, 0x78, 0x09, 0x78, 0x0B, 0x43, 0x67, 0x49, 0x08, 0xD1, 0x4B, 0x78,
+	0x5B, 0x1C, 0xDB, 0xB2,
+	0x4B, 0x70, 0x05, 0x2B, 0x03, 0xD9, 0x01, 0x23, 0x43, 0x70, 0x83, 0x70,
+	0x4A, 0x70, 0x70, 0x47,
+	0x2D, 0xE9, 0xF3, 0x4F, 0x62, 0x48, 0x00, 0x27, 0xDF, 0xF8, 0x88, 0xA1,
+	0x90, 0xF8, 0x00, 0x80,
+	0x59, 0x48, 0x81, 0xB0, 0x3C, 0x46, 0x00, 0x68, 0xB9, 0x46, 0x90, 0xF8,
+	0x90, 0x02, 0xC0, 0x07,
+	0x1A, 0xD0, 0x00, 0x26, 0x4F, 0xF0, 0x01, 0x0B, 0x01, 0x9D, 0x12, 0xE0,
+	0x28, 0x46, 0x02, 0x99,
+	0x00, 0xF0, 0x32, 0xF8, 0x10, 0xF0, 0x01, 0x0F, 0x05, 0xD0, 0x0B, 0xFA,
+	0x06, 0xF0, 0x38, 0x43,
+	0x64, 0x1C, 0xC7, 0xB2, 0xE4, 0xB2, 0xBA, 0xF9, 0x00, 0x00, 0x76, 0x1C,
+	0x05, 0xEB, 0x40, 0x05,
+	0x36, 0xB2, 0x46, 0x45, 0xEA, 0xDB, 0x01, 0xE0, 0x44, 0x46, 0xFF, 0x27,
+	0x4E, 0x48, 0x07, 0x70,
+	0x4C, 0xB1, 0x00, 0x94, 0xBA, 0xF8, 0x00, 0x00, 0x3B, 0x46, 0x82, 0xB2,
+	0x41, 0x46, 0x01, 0x98,
+	0x00, 0xF0, 0x45, 0xF8, 0x07, 0xE0, 0x49, 0x48, 0xB0, 0xF9, 0x00, 0x10,
+	0x03, 0x20, 0x02, 0xF0,
+	0x12, 0xF9, 0x4F, 0xF0, 0x01, 0x09, 0x48, 0x46, 0xBD, 0xE8, 0xFE, 0x8F,
+	0x70, 0x47, 0x3D, 0x48,
+	0x00, 0x21, 0x01, 0x70, 0x41, 0x70, 0x70, 0x47, 0x70, 0xB5, 0x37, 0x4A,
+	0x3B, 0x4C, 0x12, 0x68,
+	0x24, 0x78, 0xB2, 0xF9, 0x93, 0x32, 0x0C, 0xB1, 0xB2, 0xF9, 0x99, 0x32,
+	0x33, 0x4C, 0x64, 0x78,
+	0x01, 0x2C, 0x02, 0xD0, 0x02, 0x2C, 0x03, 0xD0, 0x04, 0xE0, 0xB2, 0xF9,
+	0x95, 0x32, 0x01, 0xE0,
+	0xB2, 0xF9, 0x97, 0x32, 0x33, 0x4A, 0x36, 0x4C, 0xB2, 0xF9, 0x00, 0x20,
+	0x25, 0x78, 0x12, 0xE0,
+	0x30, 0xF9, 0x12, 0x40, 0x31, 0xF9, 0x12, 0x60, 0xA4, 0x1B, 0x00, 0xD5,
+	0x64, 0x42, 0x24, 0xB2,
+	0x9C, 0x42, 0x08, 0xDD, 0x92, 0xFB, 0xF5, 0xF6, 0x05, 0xFB, 0x16, 0x26,
+	0x1E, 0xB1, 0x2B, 0x48,
+	0x04, 0x80, 0x00, 0x20, 0x70, 0xBD, 0x52, 0x1E, 0xEA, 0xD2, 0x01, 0x20,
+	0x70, 0xBD, 0x2D, 0xE9,
+	0xF0, 0x03, 0x06, 0x9F, 0x00, 0x2F, 0x19, 0xD0, 0x01, 0x25, 0x01, 0x2F,
+	0x02, 0xD0, 0x14, 0x46,
+	0xA9, 0x46, 0x2E, 0xE0, 0x00, 0x24, 0x0F, 0xE0, 0x05, 0xFA, 0x04, 0xF6,
+	0x1E, 0x42, 0x0A, 0xD0,
+	0x00, 0x2C, 0x0B, 0xD0, 0x53, 0x00, 0x62, 0x43, 0xBD, 0xE8, 0xF0, 0x03,
+	0x00, 0xEB, 0x42, 0x01,
+	0x1A, 0x46, 0x06, 0xF0, 0xAA, 0xBC, 0x64, 0x1C, 0x8C, 0x42, 0xED, 0xDB,
+	0xBD, 0xE8, 0xF0, 0x03,
+	0x70, 0x47, 0x00, 0xBF, 0x00, 0x26, 0x00, 0xEB, 0x44, 0x0C, 0x35, 0x46,
+	0x0B, 0xE0, 0x00, 0xBF,
+	0x09, 0xFA, 0x05, 0xF8, 0x18, 0xEA, 0x03, 0x0F, 0x02, 0xD0, 0xBC, 0xF9,
+	0x00, 0x80, 0x46, 0x44,
+	0x0C, 0xEB, 0x42, 0x0C, 0x6D, 0x1C, 0x8D, 0x42, 0xF2, 0xDB, 0x96, 0xFB,
+	0xF7, 0xF5, 0x20, 0xF8,
+	0x14, 0x50, 0x64, 0x1E, 0xE6, 0xD2, 0xE1, 0xE7, 0x4C, 0x07, 0x10, 0x00,
+	0x74, 0x07, 0x10, 0x00,
+	0xEF, 0x06, 0x10, 0x00, 0x70, 0x06, 0x10, 0x00, 0x54, 0x07, 0x10, 0x00,
+	0x74, 0x05, 0x10, 0x00,
+	0xF0, 0x06, 0x10, 0x00, 0xFE, 0x06, 0x10, 0x00, 0x75, 0x06, 0x10, 0x00,
+	0x7A, 0x06, 0x10, 0x00,
+	0xEE, 0x06, 0x10, 0x00, 0x10, 0xB5, 0xF6, 0xF7, 0x3D, 0xFC, 0xF7, 0xF7,
+	0xC3, 0xF8, 0xBD, 0xE8,
+	0x10, 0x40, 0xF5, 0xF7, 0x9F, 0xBB, 0x2D, 0xE9, 0xF0, 0x47, 0x81, 0x46,
+	0x1F, 0x46, 0x90, 0x46,
+	0x0E, 0x46, 0x03, 0x20, 0x08, 0x9D, 0xEF, 0xF7, 0x4C, 0xFF, 0x5C, 0x48,
+	0x01, 0x68, 0x48, 0x46,
+	0xFF, 0xF7, 0x16, 0xFF, 0x04, 0x46, 0x03, 0x20, 0xEF, 0xF7, 0x5E, 0xFF,
+	0x64, 0xB1, 0xFF, 0xF7,
+	0xFB, 0xFE, 0xFF, 0xF7, 0xC9, 0xFE, 0x31, 0x46, 0x48, 0x46, 0xFF, 0xF7,
+	0x4F, 0xFF, 0x54, 0x48,
+	0x04, 0x70, 0x20, 0x46, 0xBD, 0xE8, 0xF0, 0x87, 0xFF, 0xF7, 0x49, 0xFF,
+	0x16, 0xB1, 0x30, 0x46,
+	0x00, 0xF0, 0xE8, 0xFC, 0x65, 0xB1, 0x4F, 0x48, 0x01, 0x78, 0x28, 0x46,
+	0xF6, 0xF7, 0x31, 0xFC,
+	0x4D, 0x48, 0x80, 0x78, 0x20, 0xB1, 0x4D, 0x48, 0x01, 0x68, 0x21, 0xF0,
+	0x30, 0x01, 0x01, 0x60,
+	0x06, 0xF0, 0x6C, 0xFD, 0x05, 0x46, 0xFF, 0xF7, 0x97, 0xFE, 0x50, 0xEA,
+	0x05, 0x04, 0xDA, 0xD1,
+	0x3A, 0x46, 0x41, 0x46, 0x48, 0x46, 0x00, 0xF0, 0x32, 0xF8, 0x04, 0x46,
+	0xD3, 0xE7, 0x10, 0xB5,
+	0xF8, 0xF7, 0x5B, 0xFB, 0xFD, 0xF7, 0x1F, 0xFF, 0xFB, 0xF7, 0x28, 0xFB,
+	0xFF, 0xF7, 0xAA, 0xFF,
+	0xFF, 0xF7, 0x1D, 0xFF, 0xFC, 0xF7, 0xB3, 0xFA, 0x39, 0x49, 0x00, 0x20,
+	0x08, 0x70, 0x48, 0x70,
+	0x88, 0x80, 0xC8, 0x80, 0x88, 0x70, 0x88, 0x60, 0xC8, 0x60, 0x08, 0x61,
+	0x14, 0x31, 0x08, 0x70,
+	0x88, 0x70, 0x37, 0x48, 0x00, 0x68, 0x10, 0xF8, 0x30, 0x2F, 0x4A, 0x70,
+	0x40, 0x78, 0xC8, 0x70,
+	0x10, 0xBD, 0x10, 0xB5, 0xF8, 0xF7, 0x47, 0xFB, 0xFD, 0xF7, 0x10, 0xFF,
+	0x00, 0xF0, 0x15, 0xFD,
+	0xF7, 0xF7, 0x5D, 0xF8, 0x2C, 0x48, 0x00, 0x21, 0x41, 0x70, 0x81, 0x70,
+	0x10, 0xBD, 0xF8, 0xB5,
+	0x07, 0x46, 0x00, 0x24, 0x15, 0x46, 0x0E, 0x46, 0x8D, 0xF8, 0x00, 0x40,
+	0x02, 0x20, 0xEF, 0xF7,
+	0xD8, 0xFE, 0x2A, 0x46, 0x31, 0x46, 0x38, 0x46, 0xF8, 0xF7, 0x4F, 0xFA,
+	0x25, 0x49, 0x01, 0x28,
+	0xCA, 0x78, 0x60, 0xF3, 0x03, 0x02, 0xCA, 0x70, 0x2A, 0xD0, 0x02, 0x28,
+	0x2D, 0xD0, 0x03, 0x28,
+	0x2E, 0xD0, 0x04, 0x28, 0x00, 0xD0, 0x01, 0x24, 0x6B, 0x46, 0x2A, 0x46,
+	0x31, 0x46, 0x38, 0x46,
+	0xFC, 0xF7, 0xAE, 0xF9, 0x40, 0xEA, 0x04, 0x05, 0x02, 0x20, 0xEF, 0xF7,
+	0xD5, 0xFE, 0x9D, 0xF8,
+	0x00, 0x00, 0x98, 0xB1, 0xEF, 0xF7, 0x94, 0xFC, 0x17, 0x48, 0x18, 0x4A,
+	0x01, 0x68, 0x12, 0x68,
+	0x11, 0x43, 0x01, 0x60, 0xEF, 0xF7, 0x8A, 0xFC, 0x15, 0x48, 0x01, 0x78,
+	0x05, 0x20, 0x01, 0xF0,
+	0xCA, 0xFF, 0x4F, 0xF4, 0x80, 0x71, 0x00, 0x20, 0xEF, 0xF7, 0xC3, 0xFD,
+	0x28, 0x46, 0xF8, 0xBD,
+	0xFD, 0xF7, 0xA4, 0xFE, 0xFB, 0xF7, 0xD9, 0xFA, 0xD6, 0xE7, 0xFD, 0xF7,
+	0x5E, 0xFC, 0x01, 0xE0,
+	0xF7, 0xF7, 0x47, 0xFB, 0xFB, 0xF7, 0xFD, 0xFA, 0xCE, 0xE7, 0x00, 0x00,
+	0x1C, 0x07, 0x10, 0x00,
+	0x74, 0x06, 0x10, 0x00, 0x79, 0x07, 0x10, 0x00, 0x74, 0x07, 0x10, 0x00,
+	0x04, 0x07, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x0A, 0x44, 0x01, 0x20, 0x54, 0x07, 0x10, 0x00,
+	0x30, 0x06, 0x10, 0x00,
+	0x2C, 0x06, 0x10, 0x00, 0x06, 0x28, 0x08, 0xD2, 0xDF, 0xE8, 0x00, 0xF0,
+	0x07, 0x03, 0x03, 0x03,
+	0x05, 0x05, 0x01, 0x20, 0x70, 0x47, 0x02, 0x20, 0x70, 0x47, 0x00, 0x20,
+	0x70, 0x47, 0x10, 0xB5,
+	0x04, 0x46, 0x08, 0x46, 0xFF, 0xF7, 0xEE, 0xFF, 0xA8, 0x4A, 0x01, 0x21,
+	0x81, 0x40, 0x12, 0x68,
+	0x11, 0x42, 0x09, 0xD1, 0x02, 0x28, 0x07, 0xDC, 0xA5, 0x49, 0x51, 0xF8,
+	0x20, 0x10, 0x21, 0x60,
+	0xA4, 0x49, 0x41, 0xF8, 0x20, 0x40, 0x10, 0xBD, 0x00, 0x20, 0x20, 0x60,
+	0x21, 0x46, 0xBD, 0xE8,
+	0x10, 0x40, 0x48, 0x20, 0x01, 0xF0, 0x2D, 0xBD, 0x70, 0xB5, 0x04, 0x46,
+	0x08, 0x46, 0xFF, 0xF7,
+	0xD1, 0xFF, 0x00, 0x25, 0x88, 0xB1, 0x02, 0x28, 0x0F, 0xDC, 0x99, 0x4A,
+	0x21, 0x68, 0x52, 0xF8,
+	0x20, 0x20, 0x91, 0x42, 0x09, 0xD1, 0x95, 0x49, 0x01, 0x22, 0x82, 0x40,
+	0x0B, 0x68, 0x93, 0x43,
+	0x0B, 0x60, 0x94, 0x49, 0x41, 0xF8, 0x20, 0x50, 0x03, 0xE0, 0x21, 0x46,
+	0x49, 0x20, 0x01, 0xF0,
+	0x10, 0xFD, 0x25, 0x60, 0x70, 0xBD, 0x2D, 0xE9, 0xF0, 0x41, 0x01, 0x24,
+	0x8B, 0x4E, 0x8D, 0x4F,
+	0x4F, 0xF0, 0x00, 0x08, 0x25, 0x46, 0x00, 0xBF, 0x31, 0x68, 0x05, 0xFA,
+	0x04, 0xF0, 0x08, 0x42,
+	0x08, 0xD0, 0x81, 0x43, 0x31, 0x60, 0x57, 0xF8, 0x24, 0x10, 0x4A, 0x20,
+	0x01, 0xF0, 0xF9, 0xFC,
+	0x47, 0xF8, 0x24, 0x80, 0x64, 0x1C, 0x02, 0x2C, 0xEE, 0xDD, 0xBD, 0xE8,
+	0xF0, 0x81, 0x2D, 0xE9,
+	0xF0, 0x41, 0x80, 0x4D, 0x0A, 0x46, 0x00, 0x27, 0x0C, 0x35, 0x7C, 0x4B,
+	0x7E, 0x4C, 0x05, 0xF1,
+	0x14, 0x06, 0x03, 0xF1, 0x08, 0x01, 0x07, 0x60, 0x01, 0x2A, 0x63, 0xD0,
+	0x02, 0x2A, 0x39, 0xD0,
+	0x03, 0x2A, 0x6A, 0xD1, 0x5F, 0xF0, 0x00, 0x02, 0x11, 0xF8, 0x02, 0xC0,
+	0xBC, 0xF1, 0x00, 0x0F,
+	0x10, 0xD1, 0x01, 0xEB, 0x02, 0x0C, 0x9C, 0xF8, 0x01, 0xE0, 0xBE, 0xF1,
+	0x00, 0x0F, 0x09, 0xD1,
+	0x9C, 0xF8, 0x02, 0xE0, 0xBE, 0xF1, 0x00, 0x0F, 0x04, 0xD1, 0x9C, 0xF8,
+	0x03, 0xE0, 0xBE, 0xF1,
+	0x00, 0x0F, 0x0B, 0xD0, 0x02, 0xF1, 0x04, 0x0C, 0x52, 0x1C, 0xBC, 0xF1,
+	0x05, 0x0F, 0xE3, 0xDB,
+	0x59, 0x68, 0x04, 0x29, 0x47, 0xD3, 0x01, 0x46, 0x4C, 0x20, 0x48, 0xE0,
+	0x73, 0x27, 0x57, 0x43,
+	0x04, 0xEB, 0xC7, 0x04, 0x04, 0x60, 0x45, 0xF8, 0x22, 0x40, 0x46, 0xF8,
+	0x22, 0x00, 0x03, 0x20,
+	0x88, 0x54, 0x11, 0x44, 0x48, 0x70, 0x8C, 0xF8, 0x02, 0x00, 0x8C, 0xF8,
+	0x03, 0x00, 0x58, 0x68,
+	0x00, 0x1F, 0x45, 0xE0, 0x5F, 0xF0, 0x00, 0x02, 0x11, 0xF8, 0x02, 0xC0,
+	0xBC, 0xF1, 0x00, 0x0F,
+	0x06, 0xD1, 0x01, 0xEB, 0x02, 0x0C, 0x9C, 0xF8, 0x01, 0xC0, 0xBC, 0xF1,
+	0x00, 0x0F, 0x09, 0xD0,
+	0x02, 0xF1, 0x02, 0x0C, 0x52, 0x1C, 0xBC, 0xF1, 0x05, 0x0F, 0xED, 0xDB,
+	0x59, 0x68, 0x02, 0x29,
+	0xD1, 0xD2, 0x18, 0xE0, 0x73, 0x27, 0x57, 0x43, 0x04, 0xEB, 0xC7, 0x04,
+	0x04, 0x60, 0x45, 0xF8,
+	0x22, 0x40, 0x46, 0xF8, 0x22, 0x00, 0x02, 0x20, 0x88, 0x54, 0x11, 0x44,
+	0x48, 0x70, 0x58, 0x68,
+	0x80, 0x1E, 0x1D, 0xE0, 0x5F, 0xF0, 0x04, 0x02, 0x11, 0xF8, 0x02, 0xC0,
+	0xBC, 0xF1, 0x00, 0x0F,
+	0x09, 0xD0, 0x52, 0x1E, 0xF8, 0xD2, 0x00, 0x2F, 0x13, 0xD1, 0x01, 0x46,
+	0x4B, 0x20, 0xBD, 0xE8,
+	0xF0, 0x41, 0x01, 0xF0, 0x6E, 0xBC, 0x73, 0x27, 0x57, 0x43, 0x04, 0xEB,
+	0xC7, 0x04, 0x04, 0x60,
+	0x45, 0xF8, 0x22, 0x40, 0x46, 0xF8, 0x22, 0x00, 0x01, 0x20, 0x88, 0x54,
+	0x58, 0x68, 0x40, 0x1E,
+	0x58, 0x60, 0x6A, 0xE7, 0xF0, 0xB4, 0x37, 0x4D, 0x34, 0x4C, 0x00, 0x22,
+	0x04, 0x23, 0x0C, 0x35,
+	0x06, 0x68, 0x08, 0x34, 0x55, 0xF8, 0x23, 0x70, 0xB7, 0x42, 0x14, 0xD1,
+	0xE7, 0x5C, 0x8F, 0x42,
+	0x11, 0xD1, 0x5A, 0x1C, 0x13, 0xD0, 0x00, 0x22, 0x02, 0x60, 0x45, 0xF8,
+	0x23, 0x20, 0x2D, 0x4D,
+	0x20, 0x35, 0x01, 0x29, 0x45, 0xF8, 0x23, 0x20, 0xE2, 0x54, 0x11, 0xD0,
+	0x02, 0x29, 0x11, 0xD0,
+	0x03, 0x29, 0x04, 0xD1, 0x08, 0xE0, 0x5B, 0x1E, 0xE4, 0xD2, 0x00, 0x2A,
+	0x08, 0xD1, 0xF0, 0xBC,
+	0x01, 0x46, 0x4D, 0x20, 0x01, 0xF0, 0x35, 0xBC, 0xE0, 0x18, 0x42, 0x70,
+	0x82, 0x70, 0xC2, 0x70,
+	0xF0, 0xBC, 0x70, 0x47, 0xE0, 0x18, 0x42, 0x70, 0xFA, 0xE7, 0x2D, 0xE9,
+	0xF0, 0x41, 0x1D, 0x4E,
+	0x1A, 0x4F, 0x0C, 0x36, 0x05, 0x24, 0x06, 0xF1, 0x14, 0x05, 0x08, 0x37,
+	0x0D, 0xE0, 0x00, 0xBF,
+	0x56, 0xF8, 0x24, 0x00, 0x48, 0xB1, 0x55, 0xF8, 0x24, 0x10, 0x4E, 0x20,
+	0x01, 0xF0, 0x19, 0xFC,
+	0x39, 0x5D, 0x55, 0xF8, 0x24, 0x00, 0xFF, 0xF7, 0xB5, 0xFF, 0x64, 0x1E,
+	0xF0, 0xD2, 0x1C, 0xE7,
+	0x30, 0xB5, 0x0E, 0x4A, 0x01, 0x20, 0x01, 0x46, 0x0E, 0x4B, 0x10, 0x60,
+	0x5F, 0xF0, 0x00, 0x00,
+	0x43, 0xF8, 0x21, 0x00, 0x49, 0x1C, 0x02, 0x29, 0xFA, 0xDD, 0x05, 0x21,
+	0x09, 0x4C, 0x51, 0x60,
+	0x0C, 0x34, 0x06, 0x4A, 0x04, 0x21, 0x08, 0x32, 0x04, 0xF1, 0x14, 0x03,
+	0x44, 0xF8, 0x21, 0x00,
+	0x50, 0x54, 0x43, 0xF8, 0x21, 0x00, 0x49, 0x1E, 0xF8, 0xD2, 0x30, 0xBD,
+	0xB0, 0x06, 0x10, 0x00,
+	0x3C, 0x7A, 0x01, 0x00, 0x9C, 0x4E, 0x10, 0x00, 0xD4, 0x56, 0x10, 0x00,
+	0x73, 0x49, 0x00, 0x20,
+	0x74, 0x4B, 0x08, 0x70, 0x72, 0x49, 0x01, 0x22, 0x88, 0x60, 0xC8, 0x60,
+	0x08, 0x70, 0x1A, 0x70,
+	0xC1, 0xF8, 0x01, 0x00, 0x70, 0x47, 0xFE, 0xB5, 0x6F, 0x4C, 0x6E, 0x4D,
+	0x70, 0x4F, 0x22, 0x68,
+	0xB2, 0xF8, 0x7A, 0x14, 0xAD, 0xF8, 0x04, 0x10, 0xB2, 0xF8, 0x7C, 0x14,
+	0xAD, 0xF8, 0x06, 0x10,
+	0xB2, 0xF8, 0x7E, 0x14, 0xAD, 0xF8, 0x08, 0x10, 0xB2, 0xF8, 0x80, 0x14,
+	0xAD, 0xF8, 0x0A, 0x10,
+	0x66, 0x49, 0x03, 0x68, 0x0B, 0x60, 0x43, 0x68, 0x4B, 0x60, 0x29, 0x78,
+	0x00, 0x91, 0x92, 0xF8,
+	0x82, 0x14, 0xB7, 0xF9, 0x00, 0x20, 0x01, 0xF0, 0x0F, 0x03, 0x01, 0x46,
+	0x5F, 0x48, 0x08, 0x30,
+	0x03, 0xF0, 0x0C, 0xFA, 0x00, 0x26, 0x2E, 0x70, 0x03, 0x20, 0xEF, 0xF7,
+	0xDA, 0xFC, 0x5B, 0x49,
+	0xB7, 0xF9, 0x00, 0x30, 0x08, 0x31, 0x5B, 0x4A, 0x01, 0xF1, 0x08, 0x00,
+	0x03, 0xF0, 0xF1, 0xF9,
+	0x03, 0x20, 0xEF, 0xF7, 0xE9, 0xFC, 0x55, 0x48, 0x01, 0xA9, 0x10, 0x30,
+	0x00, 0xF0, 0x27, 0xF8,
+	0x4E, 0x49, 0x4F, 0x4D, 0xC0, 0xB1, 0x01, 0x26, 0x0E, 0x70, 0x21, 0x68,
+	0x91, 0xF8, 0x60, 0x14,
+	0x89, 0x07, 0x12, 0xD5, 0x04, 0x46, 0x00, 0x90, 0x04, 0x21, 0x68, 0x46,
+	0xF0, 0xF7, 0x23, 0xFA,
+	0xC0, 0xB2, 0x01, 0x28, 0x02, 0xD9, 0xA8, 0x68, 0x10, 0xB1, 0x04, 0x46,
+	0x20, 0x46, 0x04, 0xE0,
+	0x28, 0x78, 0x86, 0x40, 0x34, 0x43, 0xF9, 0xE7, 0x0E, 0x70, 0xA9, 0x68,
+	0x00, 0xF0, 0x43, 0xF8,
+	0xA9, 0x68, 0x88, 0x42, 0x02, 0xD0, 0xA8, 0x60, 0x01, 0xF0, 0xA4, 0xFD,
+	0xFE, 0xBD, 0x2D, 0xE9,
+	0xFC, 0x43, 0x04, 0x46, 0x00, 0x20, 0x89, 0x46, 0xDF, 0xF8, 0xEC, 0xC0,
+	0x80, 0x46, 0x6E, 0x46,
+	0x00, 0x90, 0x03, 0x46, 0x02, 0x46, 0x01, 0x21, 0xCD, 0xF8, 0x04, 0x00,
+	0xDC, 0xF8, 0x00, 0x50,
+	0x95, 0xF8, 0x61, 0x74, 0x01, 0xFA, 0x02, 0xF5, 0x2F, 0x42, 0x05, 0xD0,
+	0x34, 0xF8, 0x13, 0x50,
+	0x5B, 0x1C, 0x26, 0xF8, 0x12, 0x50, 0x1B, 0xB2, 0x52, 0x1C, 0x12, 0xB2,
+	0x04, 0x2A, 0xED, 0xDB,
+	0x2F, 0x4B, 0x34, 0x46, 0x00, 0x22, 0x2A, 0x4E, 0xB3, 0xF9, 0x00, 0x50,
+	0x0F, 0xE0, 0x00, 0xBF,
+	0x34, 0xF9, 0x12, 0x30, 0x39, 0xF9, 0x12, 0x70, 0xBB, 0x42, 0x06, 0xDD,
+	0x01, 0xFA, 0x02, 0xF7,
+	0x38, 0x43, 0x43, 0x45, 0x01, 0xDD, 0x98, 0x46, 0x32, 0x70, 0x52, 0x1C,
+	0x12, 0xB2, 0xAA, 0x42,
+	0xEE, 0xDB, 0xBD, 0xE8, 0xFC, 0x83, 0x2D, 0xE9, 0xF0, 0x43, 0x1D, 0x4F,
+	0x89, 0x46, 0x00, 0x22,
+	0xF9, 0x68, 0x4F, 0xF0, 0x01, 0x08, 0x80, 0xEA, 0x01, 0x04, 0x1B, 0x49,
+	0x7B, 0x1C, 0x0D, 0x68,
+	0x1B, 0x49, 0xB1, 0xF9, 0x00, 0x60, 0x1B, 0xE0, 0x08, 0xFA, 0x02, 0xF1,
+	0x21, 0x42, 0x0A, 0xD0,
+	0x95, 0xF8, 0x83, 0xC4, 0x01, 0x42, 0x02, 0xD0, 0x0C, 0xF0, 0x0F, 0x0C,
+	0x01, 0xE0, 0x4F, 0xEA,
+	0x1C, 0x1C, 0x03, 0xF8, 0x02, 0xC0, 0x13, 0xF9, 0x02, 0xC0, 0xBC, 0xF1,
+	0x00, 0x0F, 0x0D, 0xD0,
+	0x03, 0xDD, 0xAC, 0xF1, 0x01, 0x0C, 0x03, 0xF8, 0x02, 0xC0, 0x02, 0xF1,
+	0x01, 0x02, 0x12, 0xB2,
+	0xB2, 0x42, 0xE1, 0xDB, 0xF8, 0x60, 0x48, 0x46, 0xBD, 0xE8, 0xF0, 0x83,
+	0x01, 0x42, 0x02, 0xD0,
+	0x41, 0xEA, 0x09, 0x09, 0xF1, 0xE7, 0x29, 0xEA, 0x01, 0x09, 0xEE, 0xE7,
+	0x2C, 0x07, 0x10, 0x00,
+	0xC0, 0x06, 0x10, 0x00, 0x7B, 0x07, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x9A, 0x1C, 0x01, 0x20,
+	0x00, 0x07, 0x10, 0x00, 0xF4, 0x4A, 0x01, 0x20, 0xF0, 0xB5, 0x06, 0x46,
+	0xF8, 0x48, 0x00, 0x24,
+	0xA7, 0xB0, 0x00, 0x78, 0x0D, 0x46, 0x01, 0x28, 0x00, 0xD1, 0x01, 0x24,
+	0x98, 0x21, 0x68, 0x46,
+	0x06, 0xF0, 0xC4, 0xF9, 0xF3, 0x4A, 0x00, 0x21, 0x68, 0x46, 0x13, 0x78,
+	0x11, 0xE0, 0x00, 0xBF,
+	0x01, 0xFB, 0x03, 0xF7, 0x22, 0x46, 0x09, 0xE0, 0x07, 0xEB, 0x02, 0x0E,
+	0x50, 0xF8, 0x22, 0xC0,
+	0x36, 0xF9, 0x1E, 0xE0, 0xF4, 0x44, 0x40, 0xF8, 0x22, 0xC0, 0x52, 0x1C,
+	0x9A, 0x42, 0xF3, 0xDB,
+	0x49, 0x1C, 0xA9, 0x42, 0xEC, 0xDB, 0x21, 0x46, 0x07, 0xE0, 0x00, 0xBF,
+	0x50, 0xF8, 0x21, 0x20,
+	0x92, 0xFB, 0xF5, 0xF2, 0x40, 0xF8, 0x21, 0x20, 0x49, 0x1C, 0x99, 0x42,
+	0xF6, 0xDB, 0x00, 0x21,
+	0x17, 0xE0, 0x00, 0x27, 0x3A, 0x46, 0x0C, 0xE0, 0x02, 0xFB, 0x03, 0x4C,
+	0x50, 0xF8, 0x24, 0xE0,
+	0x36, 0xF9, 0x1C, 0xC0, 0xBC, 0xEB, 0x0E, 0x0C, 0x01, 0xD5, 0xCC, 0xF1,
+	0x00, 0x0C, 0x67, 0x44,
+	0x52, 0x1C, 0xAA, 0x42, 0xF0, 0xDB, 0x97, 0xFB, 0xF5, 0xF2, 0x8A, 0x42,
+	0x00, 0xDD, 0x11, 0x46,
+	0x64, 0x1C, 0x9C, 0x42, 0xE5, 0xDB, 0xB1, 0xF5, 0x80, 0x3F, 0x03, 0xDB,
+	0x4F, 0xF6, 0xFF, 0x70,
+	0x27, 0xB0, 0xF0, 0xBD, 0x88, 0xB2, 0xFB, 0xE7, 0xF0, 0xB5, 0xCF, 0x49,
+	0xCF, 0x4B, 0x09, 0x68,
+	0x91, 0xF8, 0xA0, 0x22, 0xD2, 0x07, 0x34, 0xD0, 0xCD, 0x4A, 0x57, 0x78,
+	0x4F, 0xB1, 0x91, 0xF8,
+	0xAB, 0x42, 0xB1, 0xF8, 0xA8, 0x52, 0x04, 0xF0, 0x0F, 0x02, 0x26, 0x09,
+	0xB1, 0xF8, 0xA6, 0x42,
+	0x08, 0xE0, 0x91, 0xF8, 0xAA, 0x42, 0xB1, 0xF8, 0xA4, 0x52, 0x04, 0xF0,
+	0x0F, 0x02, 0x26, 0x09,
+	0xB1, 0xF8, 0xA2, 0x42, 0xDF, 0xF8, 0x0C, 0xC3, 0x9C, 0xF8, 0x00, 0xC0,
+	0xBC, 0xF1, 0x03, 0x0F,
+	0x06, 0xD1, 0x91, 0xF8, 0xAC, 0x12, 0x0F, 0xB1, 0x0A, 0x09, 0x01, 0xE0,
+	0x01, 0xF0, 0x0F, 0x02,
+	0xA0, 0x42, 0x01, 0xDC, 0x1A, 0x60, 0xF0, 0xBD, 0xA8, 0x42, 0x01, 0xDB,
+	0x1E, 0x60, 0xF0, 0xBD,
+	0x00, 0x1B, 0xB1, 0x1A, 0x48, 0x43, 0x29, 0x1B, 0x90, 0xFB, 0xF1, 0xF0,
+	0x10, 0x44, 0x18, 0x60,
+	0xF0, 0xBD, 0x00, 0x20, 0xFB, 0xE7, 0xB0, 0x48, 0xB1, 0x49, 0x00, 0x68,
+	0x0A, 0x78, 0x00, 0xF5,
+	0xF9, 0x70, 0x80, 0x5C, 0xC8, 0x70, 0x70, 0x47, 0x2D, 0xE9, 0xF0, 0x0F,
+	0x83, 0x46, 0xAA, 0x48,
+	0xDF, 0xF8, 0xAC, 0x92, 0xDF, 0xF8, 0xB0, 0xA2, 0x01, 0x68, 0x99, 0xF8,
+	0x00, 0x70, 0x00, 0x20,
+	0x91, 0xF8, 0x0A, 0x62, 0x91, 0xF8, 0x09, 0x12, 0x3A, 0xF8, 0x17, 0x40,
+	0x6F, 0xF0, 0x00, 0x42,
+	0x4F, 0xEA, 0x11, 0x18, 0x0B, 0x07, 0x1C, 0xD0, 0x01, 0xF0, 0x0F, 0x05,
+	0x9E, 0x4B, 0x00, 0x21,
+	0x8C, 0x46, 0x1B, 0x68, 0xB4, 0x42, 0x93, 0xF8, 0x08, 0x32, 0x05, 0xDB,
+	0xA6, 0x1B, 0x06, 0xFB,
+	0x08, 0xF6, 0x96, 0xFB, 0xF5, 0xF5, 0x2B, 0x44, 0x97, 0x4D, 0x99, 0xF8,
+	0x01, 0x60, 0x2D, 0x68,
+	0x01, 0x2E, 0x95, 0xF8, 0xF1, 0x51, 0x06, 0xD0, 0x02, 0x2E, 0x07, 0xD0,
+	0x05, 0xF0, 0x03, 0x06,
+	0x13, 0xE0, 0x01, 0x25, 0xE2, 0xE7, 0xC5, 0xF3, 0x81, 0x06, 0x0E, 0xE0,
+	0xC5, 0xF3, 0x01, 0x16,
+	0x0B, 0xE0, 0x00, 0xBF, 0x3A, 0xF8, 0x1C, 0x50, 0xAA, 0x42, 0x01, 0xDD,
+	0x2A, 0x46, 0x60, 0x46,
+	0xA9, 0x42, 0x00, 0xDA, 0x29, 0x46, 0x0C, 0xF1, 0x01, 0x0C, 0xB4, 0x45,
+	0xF2, 0xDD, 0xAB, 0xF8,
+	0x00, 0x10, 0xA1, 0x1A, 0x99, 0x42, 0x01, 0xDC, 0xB7, 0x42, 0x04, 0xDD,
+	0x89, 0xF8, 0x00, 0x00,
+	0xBD, 0xE8, 0xF0, 0x0F, 0x9F, 0xE7, 0xBD, 0xE8, 0xF0, 0x0F, 0x70, 0x47,
+	0x83, 0x49, 0x10, 0xB5,
+	0x0B, 0x78, 0x7D, 0x49, 0x00, 0x22, 0x01, 0x2B, 0x09, 0x68, 0x02, 0xD1,
+	0x80, 0x4B, 0x1B, 0x78,
+	0x4B, 0xB1, 0xB1, 0xF8, 0xFC, 0x31, 0x83, 0x42, 0x18, 0xD2, 0x91, 0xF8,
+	0xF0, 0x31, 0x1B, 0x07,
+	0x14, 0xD5, 0x03, 0x22, 0x25, 0xE0, 0xB1, 0xF8, 0x02, 0x32, 0x83, 0x42,
+	0x03, 0xD2, 0x91, 0xF8,
+	0xF0, 0x31, 0x1B, 0x07, 0xF5, 0xD4, 0xB1, 0xF8, 0x00, 0x32, 0x83, 0x42,
+	0x03, 0xD2, 0x91, 0xF8,
+	0xF0, 0x31, 0x5B, 0x07, 0x0A, 0xD4, 0xB1, 0xF8, 0xFE, 0x31, 0x0B, 0xE0,
+	0xB1, 0xF8, 0xFA, 0x31,
+	0x83, 0x42, 0x05, 0xD2, 0x91, 0xF8, 0xF0, 0x31, 0x5B, 0x07, 0x01, 0xD5,
+	0x02, 0x22, 0x08, 0xE0,
+	0xB1, 0xF8, 0xF8, 0x31, 0x83, 0x42, 0x04, 0xD2, 0x91, 0xF8, 0xF0, 0x01,
+	0x80, 0x07, 0x00, 0xD5,
+	0x01, 0x22, 0x65, 0x48, 0x62, 0x4C, 0x14, 0x38, 0x03, 0x78, 0x9A, 0x42,
+	0x11, 0xD1, 0x61, 0x78,
+	0x99, 0x42, 0x1A, 0xD0, 0x63, 0x4A, 0x12, 0x78, 0x13, 0x43, 0x07, 0xD0,
+	0x81, 0x68, 0x49, 0x1E,
+	0x81, 0x60, 0x00, 0x29, 0x11, 0xDC, 0x00, 0x78, 0x60, 0x70, 0x0E, 0xE0,
+	0x01, 0x70, 0x81, 0x68,
+	0xF7, 0xE7, 0x8A, 0xB1, 0x02, 0x2A, 0x01, 0xD1, 0x01, 0x2B, 0x0D, 0xD0,
+	0x91, 0xF8, 0xF6, 0x11,
+	0x81, 0x60, 0x02, 0x70, 0x00, 0x29, 0x00, 0xDC, 0x62, 0x70, 0x57, 0x48,
+	0x62, 0x78, 0x41, 0x7B,
+	0x62, 0xF3, 0x03, 0x01, 0x41, 0x73, 0x10, 0xBD, 0x91, 0xF8, 0xF7, 0x11,
+	0xF0, 0xE7, 0x4A, 0x4A,
+	0x12, 0x68, 0x92, 0xF8, 0xF0, 0x21, 0xD2, 0x06, 0x07, 0xD5, 0x42, 0x1A,
+	0x00, 0x2A, 0x04, 0xDC,
+	0xC1, 0xEB, 0xC1, 0x11, 0x08, 0x44, 0xC0, 0xF3, 0xCF, 0x10, 0x70, 0x47,
+	0x44, 0x49, 0x00, 0x20,
+	0x41, 0x4A, 0x48, 0x70, 0x44, 0x49, 0x14, 0x39, 0x48, 0x60, 0x88, 0x60,
+	0x08, 0x70, 0x12, 0x68,
+	0x92, 0xF8, 0xA0, 0x32, 0xDB, 0x07, 0x03, 0xD0, 0x92, 0xF8, 0xAB, 0x22,
+	0x12, 0x09, 0x00, 0xE0,
+	0x00, 0x22, 0x3A, 0x4B, 0x1A, 0x60, 0xC8, 0x60, 0x08, 0x61, 0x48, 0x61,
+	0x88, 0x61, 0x70, 0x47,
+	0x2D, 0xE9, 0xF8, 0x4F, 0x00, 0x21, 0xAD, 0xF8, 0x00, 0x10, 0x32, 0x49,
+	0xDF, 0xF8, 0xD8, 0x90,
+	0xDF, 0xF8, 0xD4, 0x80, 0x0D, 0x78, 0x4F, 0xF0, 0x10, 0x0B, 0x2F, 0x01,
+	0x06, 0x46, 0x00, 0x24,
+	0xA9, 0xF1, 0x08, 0x09, 0xA8, 0xF1, 0x14, 0x0A, 0x10, 0xE0, 0x2A, 0x46,
+	0x59, 0x46, 0x30, 0x46,
+	0xFF, 0xF7, 0x5A, 0xFE, 0x29, 0xF8, 0x14, 0x00, 0x43, 0x46, 0x38, 0xF8,
+	0x14, 0x10, 0xFF, 0xF7,
+	0xB6, 0xFF, 0x23, 0xF8, 0x14, 0x00, 0x06, 0xEB, 0x47, 0x06, 0x64, 0x1C,
+	0x9A, 0xF8, 0x01, 0x00,
+	0x84, 0x42, 0xEA, 0xDD, 0x68, 0x46, 0xFF, 0xF7, 0xE7, 0xFE, 0x1F, 0x48,
+	0x20, 0x4D, 0x00, 0x68,
+	0x90, 0xF8, 0xF0, 0x01, 0x40, 0x06, 0x02, 0xD5, 0xBD, 0xF8, 0x00, 0x40,
+	0x02, 0xE0, 0x29, 0x78,
+	0x38, 0xF8, 0x11, 0x40, 0x21, 0x48, 0x04, 0x80, 0x20, 0x46, 0xFF, 0xF7,
+	0x2F, 0xFF, 0x20, 0x46,
+	0xFF, 0xF7, 0x8A, 0xFE, 0x29, 0x78, 0x39, 0xF8, 0x11, 0x00, 0x1B, 0x49,
+	0xA1, 0xF8, 0x1B, 0x00,
+	0xBD, 0xE8, 0xF8, 0x8F, 0x2D, 0xE9, 0xFC, 0x5F, 0x0E, 0x49, 0x4F, 0xF0,
+	0x00, 0x09, 0x0D, 0x78,
+	0x0B, 0x49, 0x09, 0x78, 0x01, 0x29, 0x00, 0xD1, 0x89, 0x46, 0x0F, 0x49,
+	0x10, 0x26, 0x14, 0x39,
+	0x04, 0x46, 0x4A, 0x68, 0x12, 0x48, 0x92, 0xFB, 0xF6, 0xF3, 0x06, 0xFB,
+	0x13, 0x22, 0x6A, 0x43,
+	0x4F, 0x78, 0x4F, 0xEA, 0x05, 0x1A, 0x00, 0xEB, 0x42, 0x08, 0x83, 0x46,
+	0x7F, 0x1C, 0x3D, 0xE0,
+	0xF3, 0x06, 0x10, 0x00, 0xEE, 0x06, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x9C, 0x06, 0x10, 0x00,
+	0x74, 0x07, 0x10, 0x00, 0xEC, 0x06, 0x10, 0x00, 0xE4, 0x06, 0x10, 0x00,
+	0xF6, 0x06, 0x10, 0x00,
+	0xF7, 0x06, 0x10, 0x00, 0xF5, 0x06, 0x10, 0x00, 0x0A, 0x44, 0x01, 0x20,
+	0x78, 0x06, 0x10, 0x00,
+	0xB2, 0x1C, 0x01, 0x20, 0x2A, 0x48, 0x00, 0x68, 0x90, 0xF8, 0xF0, 0x11,
+	0x89, 0x06, 0x14, 0xD5,
+	0x28, 0x49, 0x49, 0x68, 0x00, 0x29, 0x0E, 0xDD, 0xA5, 0xEB, 0x09, 0x02,
+	0xB0, 0xF9, 0x06, 0x12,
+	0xCD, 0xE9, 0x00, 0x12, 0xB0, 0xF9, 0x04, 0x32, 0x04, 0xEB, 0x49, 0x00,
+	0x0B, 0xEB, 0x49, 0x02,
+	0x01, 0x46, 0x02, 0xF0, 0x9D, 0xFE, 0x0B, 0xEB, 0x4A, 0x0B, 0x6A, 0x00,
+	0x21, 0x46, 0x40, 0x46,
+	0x05, 0xF0, 0x03, 0xFF, 0x04, 0xEB, 0x45, 0x04, 0x08, 0xEB, 0x4A, 0x08,
+	0x7F, 0x1E, 0xD9, 0xD2,
+	0x18, 0x48, 0x4F, 0xF0, 0xFF, 0x31, 0x01, 0xEB, 0x46, 0x01, 0x42, 0x68,
+	0x52, 0x1C, 0x42, 0x60,
+	0x91, 0x42, 0x00, 0xDA, 0x46, 0x60, 0x40, 0x68, 0xB0, 0x42, 0x03, 0xDB,
+	0xBD, 0xE8, 0xFC, 0x5F,
+	0x11, 0x48, 0x45, 0xE7, 0xBD, 0xE8, 0xFC, 0x9F, 0x28, 0xE7, 0x10, 0xB5,
+	0x0C, 0x4C, 0x20, 0x68,
+	0x90, 0xF8, 0xF1, 0x01, 0xC0, 0xF3, 0x01, 0x12, 0xC0, 0xF3, 0x81, 0x01,
+	0x00, 0xF0, 0x03, 0x00,
+	0x01, 0xF0, 0x5B, 0xFF, 0x07, 0x49, 0x48, 0x70, 0x20, 0x68, 0x08, 0x49,
+	0x90, 0xF8, 0xEC, 0x00,
+	0x00, 0xF0, 0x03, 0x00, 0x08, 0x70, 0xFF, 0xF7, 0x36, 0xFE, 0xBD, 0xE8,
+	0x10, 0x40, 0x0D, 0xE7,
+	0x4C, 0x07, 0x10, 0x00, 0xD0, 0x06, 0x10, 0x00, 0xB2, 0x1C, 0x01, 0x20,
+	0x74, 0x07, 0x10, 0x00,
+	0x10, 0xB5, 0xBA, 0x48, 0x00, 0x24, 0x84, 0x61, 0x04, 0x62, 0xC4, 0x61,
+	0xFF, 0xF7, 0xB9, 0xFA,
+	0xFF, 0xF7, 0x6E, 0xFC, 0xB6, 0x48, 0x04, 0x80, 0xBD, 0xE8, 0x10, 0x40,
+	0x00, 0xF0, 0x11, 0xB9,
+	0x10, 0xB5, 0xB4, 0x48, 0xB1, 0x4C, 0x90, 0xF8, 0x30, 0x10, 0x61, 0x70,
+	0x90, 0xF8, 0x31, 0x20,
+	0xA2, 0x70, 0x51, 0x43, 0x61, 0x82, 0x90, 0xF8, 0x33, 0x10, 0xE1, 0x70,
+	0x10, 0xF8, 0x2C, 0x1F,
+	0x21, 0x70, 0x41, 0x78, 0x21, 0x71, 0x81, 0x78, 0x61, 0x71, 0xC1, 0x78,
+	0xA1, 0x71, 0x41, 0x7A,
+	0xE1, 0x71, 0x80, 0x7A, 0x20, 0x72, 0xA8, 0x48, 0x60, 0x62, 0x00, 0xF2,
+	0x3C, 0x60, 0xA0, 0x62,
+	0xA0, 0xF6, 0x78, 0x40, 0xE0, 0x62, 0xA5, 0x48, 0x20, 0x63, 0xA5, 0x48,
+	0x01, 0x21, 0x00, 0x68,
+	0x00, 0xF2, 0x61, 0x40, 0xEF, 0xF7, 0xDF, 0xFE, 0xA0, 0x82, 0x10, 0xBD,
+	0x9D, 0x48, 0x10, 0xB5,
+	0x9B, 0x49, 0x90, 0xF8, 0x2C, 0x00, 0x99, 0x4A, 0x88, 0x70, 0x08, 0x79,
+	0x53, 0x7A, 0x63, 0xF3,
+	0x00, 0x00, 0xD3, 0x7A, 0x63, 0xF3, 0xC3, 0x00, 0x93, 0x7A, 0x63, 0xF3,
+	0x82, 0x00, 0x13, 0x7B,
+	0x63, 0xF3, 0x41, 0x00, 0x97, 0x4B, 0xDB, 0x78, 0x0B, 0x72, 0x93, 0x7B,
+	0xCB, 0x71, 0x53, 0x7B,
+	0xD4, 0x7B, 0x63, 0xF3, 0x04, 0x10, 0x11, 0xF8, 0x0E, 0x3F, 0x12, 0x7C,
+	0x64, 0xF3, 0x03, 0x03,
+	0x62, 0xF3, 0x07, 0x13, 0x90, 0x4A, 0x01, 0xF8, 0x0B, 0x39, 0x12, 0x78,
+	0x81, 0xF8, 0x25, 0x20,
+	0x8E, 0x4A, 0x12, 0x88, 0xCA, 0x84, 0x8E, 0x4A, 0x12, 0x78, 0x62, 0xF3,
+	0xC7, 0x10, 0x48, 0x70,
+	0x8C, 0x48, 0x00, 0x88, 0x08, 0x85, 0x8C, 0x48, 0x00, 0x88, 0x48, 0x85,
+	0x8B, 0x48, 0x02, 0x78,
+	0x08, 0x7B, 0x62, 0xF3, 0x03, 0x00, 0x08, 0x73, 0x89, 0x48, 0x02, 0x78,
+	0x48, 0x7B, 0x62, 0xF3,
+	0x00, 0x00, 0x88, 0x4A, 0x12, 0x78, 0x62, 0xF3, 0x41, 0x00, 0x20, 0xF0,
+	0x04, 0x00, 0x48, 0x73,
+	0x10, 0xBD, 0x70, 0xB5, 0x0D, 0x46, 0x80, 0xEA, 0x05, 0x04, 0xE0, 0x06,
+	0x01, 0xD5, 0xF6, 0xF7,
+	0x89, 0xFA, 0xA0, 0x06, 0x01, 0xD5, 0xF4, 0xF7, 0x65, 0xFD, 0x14, 0xF0,
+	0x48, 0x0F, 0x05, 0xD0,
+	0x6E, 0x48, 0x15, 0xF0, 0x48, 0x01, 0x00, 0xD0, 0x01, 0x21, 0x41, 0x74,
+	0x70, 0xBD, 0x70, 0xB5,
+	0x79, 0x4D, 0x2C, 0x68, 0x00, 0x2C, 0x0D, 0xD0, 0x68, 0x49, 0xA0, 0xB2,
+	0x0A, 0x7A, 0xC9, 0x79,
+	0x01, 0xF0, 0x44, 0xF9, 0x28, 0x68, 0xA0, 0x43, 0x28, 0x60, 0x03, 0xD1,
+	0xBD, 0xE8, 0x70, 0x40,
+	0x01, 0xF0, 0xB7, 0xB9, 0x70, 0xBD, 0xF8, 0xB5, 0x00, 0x26, 0x00, 0xF0,
+	0xC1, 0xFF, 0x01, 0x20,
+	0xEF, 0xF7, 0xF7, 0xF8, 0x00, 0xF0, 0x8F, 0xF8, 0x5C, 0x4D, 0x5E, 0x4C,
+	0x95, 0xF8, 0x20, 0x00,
+	0x80, 0x07, 0x02, 0xD5, 0xA0, 0x68, 0xFF, 0xF7, 0xE6, 0xFB, 0x95, 0xF8,
+	0x20, 0x00, 0xC0, 0x07,
+	0x09, 0xD0, 0xE0, 0x68, 0x00, 0x90, 0xD4, 0xE9, 0x00, 0x01, 0xD4, 0xE9,
+	0x04, 0x23, 0xFF, 0xF7,
+	0x8A, 0xF9, 0x06, 0x00, 0x0A, 0xD1, 0x28, 0x8C, 0x80, 0x05, 0x07, 0xD5,
+	0x94, 0xF8, 0x32, 0x10,
+	0xA0, 0x69, 0xF4, 0xF7, 0xF8, 0xFD, 0xE8, 0x69, 0x18, 0xB9, 0x0C, 0xE0,
+	0xE8, 0x69, 0x50, 0xB1,
+	0x4E, 0xB9, 0x03, 0x20, 0xEF, 0xF7, 0xCD, 0xF8, 0x4A, 0x48, 0xE9, 0x69,
+	0xFE, 0xF7, 0x8B, 0xFF,
+	0x03, 0x20, 0xEF, 0xF7, 0xE1, 0xF8, 0xFF, 0xF7, 0x51, 0xFF, 0xFF, 0xF7,
+	0xB0, 0xFF, 0xFF, 0xF7,
+	0x6C, 0xFB, 0xFF, 0xF7, 0x88, 0xFA, 0xBD, 0xE8, 0xF8, 0x40, 0x01, 0x20,
+	0xEF, 0xF7, 0xD4, 0xB8,
+	0x3E, 0x48, 0x81, 0x7A, 0x01, 0x29, 0x08, 0xD0, 0xC1, 0x7A, 0x01, 0x29,
+	0x05, 0xD0, 0x01, 0x7B,
+	0x01, 0x29, 0x02, 0xD0, 0x80, 0x7B, 0x00, 0x28, 0x00, 0xD0, 0x01, 0x20,
+	0x70, 0x47, 0x08, 0xB5,
+	0xFF, 0xF7, 0xF6, 0xFE, 0x6B, 0x46, 0x00, 0x22, 0x03, 0x21, 0x02, 0x20,
+	0xEF, 0xF7, 0x0A, 0xF8,
+	0x00, 0x98, 0xC0, 0x07, 0x05, 0xD0, 0x01, 0x21, 0x02, 0x20, 0xEE, 0xF7,
+	0xE6, 0xFF, 0xFF, 0xF7,
+	0x9A, 0xFF, 0x00, 0x98, 0x80, 0x07, 0xED, 0xD5, 0x02, 0x21, 0x08, 0x46,
+	0xEE, 0xF7, 0xDD, 0xFF,
+	0xE8, 0xE7, 0x2F, 0x48, 0x10, 0xB5, 0x02, 0x68, 0x28, 0x48, 0x00, 0x24,
+	0x92, 0xF8, 0x31, 0x10,
+	0x41, 0x70, 0x92, 0xF8, 0x30, 0x20, 0x82, 0x70, 0x51, 0x43, 0x41, 0x82,
+	0x29, 0x49, 0xC9, 0x78,
+	0xC1, 0x70, 0x01, 0x21, 0x01, 0x71, 0x41, 0x71, 0x81, 0x71, 0x01, 0x70,
+	0x84, 0x82, 0xC4, 0x71,
+	0x04, 0x72, 0xC4, 0x73, 0x04, 0x74, 0xFF, 0xF7, 0x62, 0xF9, 0xFF, 0xF7,
+	0x5F, 0xFB, 0xFE, 0xF7,
+	0x9D, 0xFE, 0x43, 0xF6, 0x58, 0x61, 0x29, 0x48, 0x05, 0xF0, 0xFE, 0xFD,
+	0x28, 0x48, 0x04, 0x80,
+	0x28, 0x48, 0x04, 0x80, 0x10, 0xBD, 0x70, 0xB5, 0x14, 0x4E, 0x16, 0x4D,
+	0x31, 0x6A, 0x28, 0x6A,
+	0x81, 0xEA, 0x00, 0x04, 0x19, 0xB9, 0x10, 0xB1, 0xFF, 0xF7, 0xAA, 0xFE,
+	0x11, 0xE0, 0xA0, 0x07,
+	0x01, 0xD5, 0xFF, 0xF7, 0x43, 0xFB, 0xE0, 0x07, 0x03, 0xD0, 0xFF, 0xF7,
+	0x40, 0xF9, 0xFF, 0xF7,
+	0x7B, 0xFE, 0xE0, 0x06, 0x01, 0xD5, 0xFF, 0xF7, 0xED, 0xF8, 0xA0, 0x05,
+	0x01, 0xD5, 0xF4, 0xF7,
+	0x61, 0xFD, 0xE9, 0x69, 0xB0, 0x69, 0xFF, 0xF7, 0x1C, 0xFF, 0xE8, 0x69,
+	0xB0, 0x61, 0x28, 0x6A,
+	0x30, 0x62, 0x68, 0x6A, 0xF0, 0x61, 0xBD, 0xE8, 0x70, 0x40, 0x99, 0xE6,
+	0xEC, 0x06, 0x10, 0x00,
+	0x0A, 0x44, 0x01, 0x20, 0xCC, 0x68, 0x10, 0x00, 0xEE, 0x35, 0x01, 0x20,
+	0x42, 0x44, 0x01, 0x20,
+	0x4C, 0x07, 0x10, 0x00, 0x74, 0x07, 0x10, 0x00, 0x75, 0x06, 0x10, 0x00,
+	0x7A, 0x06, 0x10, 0x00,
+	0x7D, 0x07, 0x10, 0x00, 0x7E, 0x07, 0x10, 0x00, 0x80, 0x07, 0x10, 0x00,
+	0x66, 0x05, 0x10, 0x00,
+	0x64, 0x05, 0x10, 0x00, 0x74, 0x05, 0x10, 0x00, 0x68, 0x07, 0x10, 0x00,
+	0x20, 0x4D, 0x01, 0x20,
+	0x82, 0x07, 0x10, 0x00, 0x84, 0x07, 0x10, 0x00, 0x0B, 0x4D, 0x00, 0x20,
+	0x0B, 0x4C, 0x28, 0x60,
+	0x28, 0x68, 0x40, 0x1C, 0x28, 0x60, 0xEE, 0xF7, 0xEB, 0xFD, 0xF0, 0xF7,
+	0x70, 0xF9, 0x01, 0x28,
+	0x20, 0x68, 0x06, 0xD0, 0x40, 0xF0, 0x04, 0x00, 0x20, 0x60, 0xEE, 0xF7,
+	0xDF, 0xFD, 0x30, 0xBF,
+	0xEE, 0xE7, 0x20, 0xF0, 0x04, 0x00, 0xF7, 0xE7, 0x30, 0x07, 0x10, 0x00,
+	0x10, 0xED, 0x00, 0xE0,
+	0x2D, 0xE9, 0xF0, 0x47, 0x1C, 0x4D, 0xDF, 0xF8, 0x74, 0x90, 0xA8, 0x46,
+	0x20, 0x21, 0x1A, 0x48,
+	0x05, 0xF0, 0x82, 0xFD, 0x18, 0x48, 0x00, 0xF0, 0x53, 0xFB, 0x47, 0x1E,
+	0xD9, 0xF8, 0x00, 0x00,
+	0x98, 0xF8, 0x00, 0x60, 0x08, 0xF1, 0x01, 0x04, 0x90, 0xF8, 0xA0, 0x00,
+	0xC0, 0x07, 0x05, 0xD0,
+	0x3A, 0x46, 0x21, 0x46, 0x30, 0x46, 0x00, 0xF0, 0x23, 0xF8, 0x28, 0xB9,
+	0x3A, 0x46, 0x21, 0x46,
+	0x30, 0x46, 0x00, 0xF0, 0xD3, 0xF8, 0x18, 0xB1, 0x01, 0x20, 0x29, 0x68,
+	0x01, 0xF0, 0xF3, 0xF8,
+	0x00, 0xF0, 0x50, 0xFB, 0x00, 0x28, 0xD9, 0xD1, 0xBD, 0xE8, 0xF0, 0x87,
+	0x38, 0xB5, 0x0C, 0x46,
+	0x05, 0x46, 0xEE, 0xF7, 0xE6, 0xFE, 0x69, 0x46, 0x28, 0x46, 0xEE, 0xF7,
+	0x1C, 0xFF, 0x00, 0x99,
+	0x21, 0x42, 0xF8, 0xD1, 0x38, 0xBD, 0x00, 0x00, 0xD0, 0x4E, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0x70, 0xB5, 0x0D, 0x46, 0x00, 0x24, 0xA0, 0xF1, 0x10, 0x01, 0x03, 0x29,
+	0x01, 0xD8, 0x52, 0x48,
+	0x05, 0xE0, 0xA0, 0xF1, 0x30, 0x01, 0x0A, 0x29, 0x06, 0xD8, 0x4F, 0x48,
+	0x20, 0x30, 0x50, 0xF8,
+	0x31, 0x30, 0x00, 0xEB, 0xC1, 0x00, 0x0A, 0xE0, 0x62, 0x28, 0x10, 0xD1,
+	0x4A, 0x49, 0xA0, 0xF1,
+	0x62, 0x00, 0xA1, 0xF1, 0x08, 0x01, 0x51, 0xF8, 0x30, 0x30, 0x01, 0xEB,
+	0xC0, 0x00, 0x4F, 0xF0,
+	0x01, 0x04, 0x40, 0x68, 0x90, 0x42, 0x02, 0xD1, 0x11, 0x46, 0x28, 0x46,
+	0x98, 0x47, 0x20, 0x46,
+	0x70, 0xBD, 0x42, 0x49, 0x43, 0x20, 0x08, 0x60, 0x04, 0x21, 0x01, 0x20,
+	0xFF, 0xF7, 0xBE, 0xBF,
+	0x3E, 0x49, 0x00, 0x20, 0x08, 0x60, 0x04, 0x21, 0x01, 0x20, 0xFF, 0xF7,
+	0xB7, 0xBF, 0xEF, 0xF7,
+	0x92, 0xBB, 0x10, 0xB5, 0xEE, 0xF7, 0x5C, 0xFD, 0x39, 0x49, 0x1E, 0x20,
+	0x08, 0x60, 0xEE, 0xF7,
+	0x55, 0xFD, 0x02, 0x21, 0x05, 0x20, 0x01, 0xF0, 0x96, 0xF8, 0xBD, 0xE8,
+	0x10, 0x40, 0x4F, 0xF4,
+	0x80, 0x71, 0x00, 0x20, 0xFF, 0xF7, 0xA2, 0xBF, 0x32, 0x49, 0x02, 0x78,
+	0x0A, 0x70, 0x42, 0x78,
+	0x4A, 0x70, 0x01, 0x78, 0x4B, 0x07, 0x30, 0x49, 0x0A, 0x68, 0x02, 0xD5,
+	0x42, 0xF0, 0x04, 0x02,
+	0x01, 0xE0, 0x22, 0xF0, 0x04, 0x02, 0x0A, 0x60, 0x02, 0x78, 0x12, 0x07,
+	0x0A, 0x68, 0x02, 0xD5,
+	0x42, 0xF0, 0x02, 0x02, 0x01, 0xE0, 0x22, 0xF0, 0x02, 0x02, 0x0A, 0x60,
+	0x02, 0x78, 0xD2, 0x06,
+	0x0A, 0x68, 0x02, 0xD5, 0x42, 0xF0, 0x01, 0x02, 0x01, 0xE0, 0x22, 0xF0,
+	0x01, 0x02, 0x0A, 0x60,
+	0x00, 0x78, 0x40, 0x06, 0x02, 0xD5, 0x42, 0xF0, 0x10, 0x00, 0x01, 0xE0,
+	0x22, 0xF0, 0x10, 0x00,
+	0x08, 0x60, 0x08, 0x21, 0x01, 0x20, 0xFF, 0xF7, 0x71, 0xBF, 0x00, 0x78,
+	0x28, 0xB1, 0x01, 0x28,
+	0x05, 0xD1, 0x10, 0x21, 0x01, 0x20, 0xFF, 0xF7, 0x69, 0xBF, 0x04, 0x21,
+	0xFA, 0xE7, 0x70, 0x47,
+	0x02, 0x78, 0x15, 0x48, 0x01, 0x68, 0x22, 0xB1, 0x01, 0x2A, 0x05, 0xD0,
+	0x02, 0x2A, 0x08, 0xD1,
+	0x0B, 0xE0, 0x21, 0xF0, 0x08, 0x01, 0x01, 0xE0, 0x41, 0xF0, 0x08, 0x01,
+	0x21, 0xF0, 0x40, 0x01,
+	0x01, 0x60, 0x08, 0x21, 0x01, 0x20, 0xFF, 0xF7, 0x51, 0xBF, 0x21, 0xF0,
+	0x08, 0x01, 0x41, 0xF0,
+	0x40, 0x01, 0xF5, 0xE7, 0x70, 0x47, 0x70, 0x47, 0x70, 0x47, 0x70, 0x47,
+	0x70, 0x47, 0x70, 0x47,
+	0x70, 0x47, 0x70, 0x47, 0x00, 0xF0, 0x21, 0xBC, 0x50, 0x7A, 0x01, 0x00,
+	0x6C, 0x07, 0x10, 0x00,
+	0x54, 0x07, 0x10, 0x00, 0xF0, 0x4F, 0x10, 0x00, 0x70, 0x07, 0x10, 0x00,
+	0x0B, 0x46, 0x10, 0xB5,
+	0x00, 0x21, 0xA0, 0x38, 0x09, 0x28, 0x06, 0xD8, 0xF7, 0x49, 0x51, 0xF8,
+	0x20, 0x40, 0x11, 0x46,
+	0x18, 0x46, 0xA0, 0x47, 0x01, 0x46, 0x08, 0x46, 0x10, 0xBD, 0x00, 0x20,
+	0x70, 0x47, 0x70, 0xB5,
+	0x00, 0x23, 0x00, 0x29, 0x11, 0xDD, 0x02, 0x78, 0x49, 0x1E, 0x03, 0x2A,
+	0x0D, 0xD2, 0xEE, 0x4D,
+	0x40, 0x1C, 0x28, 0x35, 0x55, 0xF8, 0x32, 0x40, 0x05, 0xEB, 0xC2, 0x02,
+	0x52, 0x68, 0x00, 0x2A,
+	0x03, 0xDB, 0x91, 0x42, 0x01, 0xD1, 0xA0, 0x47, 0x03, 0x46, 0x18, 0x46,
+	0x70, 0xBD, 0x10, 0xB5,
+	0x00, 0x78, 0x00, 0x21, 0xC2, 0x07, 0x00, 0xD0, 0x01, 0x21, 0x82, 0x07,
+	0x01, 0xD5, 0x41, 0xF0,
+	0x02, 0x01, 0xC0, 0x06, 0x01, 0xD5, 0x41, 0xF0, 0x40, 0x01, 0xE0, 0x48,
+	0x02, 0x68, 0x8A, 0x42,
+	0x04, 0xD0, 0x01, 0x60, 0x04, 0x21, 0x01, 0x20, 0xFF, 0xF7, 0xF8, 0xFE,
+	0x01, 0x20, 0x10, 0xBD,
+	0x00, 0x20, 0x70, 0x47, 0x70, 0xB5, 0x00, 0x23, 0x00, 0x29, 0x0F, 0xDD,
+	0x02, 0x78, 0x49, 0x1E,
+	0x05, 0x2A, 0x0B, 0xD2, 0xD4, 0x4D, 0x40, 0x1C, 0x40, 0x35, 0x55, 0xF8,
+	0x32, 0x40, 0x05, 0xEB,
+	0xC2, 0x02, 0x52, 0x68, 0x91, 0x42, 0x01, 0xD1, 0xA0, 0x47, 0x03, 0x46,
+	0x18, 0x46, 0x70, 0xBD,
+	0x10, 0xB5, 0x00, 0x78, 0xC2, 0x07, 0xCE, 0x48, 0x01, 0x68, 0x02, 0xD0,
+	0x41, 0xF0, 0x02, 0x01,
+	0x01, 0xE0, 0x21, 0xF0, 0x02, 0x01, 0x01, 0x60, 0x08, 0x21, 0x01, 0x20,
+	0xFF, 0xF7, 0xCE, 0xFE,
+	0x01, 0x20, 0x10, 0xBD, 0x10, 0xB5, 0x00, 0x78, 0xC2, 0x07, 0xC5, 0x48,
+	0x01, 0x68, 0x02, 0xD0,
+	0x41, 0xF0, 0x04, 0x01, 0x01, 0xE0, 0x21, 0xF0, 0x04, 0x01, 0x01, 0x60,
+	0x08, 0x21, 0x01, 0x20,
+	0xFF, 0xF7, 0xBC, 0xFE, 0x01, 0x20, 0x10, 0xBD, 0x10, 0xB5, 0x01, 0x78,
+	0xCB, 0x07, 0xBC, 0x49,
+	0x0A, 0x68, 0x02, 0xD0, 0x42, 0xF0, 0x08, 0x02, 0x01, 0xE0, 0x22, 0xF0,
+	0x08, 0x02, 0x0A, 0x60,
+	0x00, 0x78, 0x80, 0x07, 0x02, 0xD5, 0x42, 0xF0, 0x40, 0x00, 0x01, 0xE0,
+	0x22, 0xF0, 0x40, 0x00,
+	0x08, 0x60, 0x08, 0x21, 0x01, 0x20, 0xFF, 0xF7, 0xA1, 0xFE, 0x01, 0x20,
+	0x10, 0xBD, 0x00, 0x20,
+	0x70, 0x47, 0x00, 0x20, 0x70, 0x47, 0x70, 0xB5, 0x00, 0x23, 0x00, 0x29,
+	0x0F, 0xDD, 0x02, 0x78,
+	0x49, 0x1E, 0x0A, 0x2A, 0x0B, 0xD2, 0xA8, 0x4D, 0x40, 0x1C, 0x68, 0x35,
+	0x55, 0xF8, 0x32, 0x40,
+	0x05, 0xEB, 0xC2, 0x02, 0x52, 0x68, 0x91, 0x42, 0x01, 0xD1, 0xA0, 0x47,
+	0x03, 0x46, 0x18, 0x46,
+	0x70, 0xBD, 0x01, 0x46, 0x00, 0x20, 0x09, 0x78, 0x04, 0x29, 0x06, 0xD2,
+	0x9E, 0x48, 0xB8, 0x30,
+	0x50, 0xF8, 0x21, 0x20, 0x00, 0x21, 0x08, 0x46, 0x10, 0x47, 0x70, 0x47,
+	0x10, 0xB5, 0xEF, 0xF7,
+	0x52, 0xFA, 0x01, 0x20, 0x10, 0xBD, 0x10, 0xB5, 0x00, 0xF0, 0x4F, 0xFB,
+	0x01, 0x20, 0x10, 0xBD,
+	0x10, 0xB5, 0x4F, 0xF4, 0x00, 0x61, 0x00, 0x20, 0xFF, 0xF7, 0x68, 0xFE,
+	0x01, 0x20, 0x10, 0xBD,
+	0x10, 0xB5, 0x4F, 0xF4, 0x80, 0x51, 0x00, 0x20, 0xFF, 0xF7, 0x60, 0xFE,
+	0x01, 0x20, 0x10, 0xBD,
+	0x10, 0xB5, 0x00, 0x78, 0xC0, 0x07, 0x02, 0xD0, 0x00, 0xF0, 0xD8, 0xFA,
+	0x01, 0xE0, 0x00, 0xF0,
+	0xCC, 0xFA, 0x01, 0x20, 0x10, 0xBD, 0x10, 0xB5, 0x00, 0x88, 0x00, 0x24,
+	0xC1, 0x07, 0x00, 0xD0,
+	0x02, 0x24, 0x81, 0x07, 0x01, 0xD5, 0x44, 0xF0, 0x04, 0x04, 0x41, 0x07,
+	0x01, 0xD5, 0x44, 0xF0,
+	0x08, 0x04, 0xC1, 0x06, 0x01, 0xD5, 0x44, 0xF0, 0x10, 0x04, 0x00, 0x06,
+	0x01, 0xD5, 0x44, 0xF0,
+	0x80, 0x04, 0x94, 0xB1, 0xEE, 0xF7, 0xE4, 0xFB, 0x7E, 0x48, 0x01, 0x68,
+	0x21, 0x43, 0x01, 0x60,
+	0xEE, 0xF7, 0xDC, 0xFB, 0x02, 0x21, 0x05, 0x20, 0x00, 0xF0, 0x1D, 0xFF,
+	0x4F, 0xF4, 0x80, 0x71,
+	0x00, 0x20, 0xFF, 0xF7, 0x2B, 0xFE, 0x01, 0x20, 0x10, 0xBD, 0x00, 0x20,
+	0x10, 0xBD, 0x10, 0xB5,
+	0x00, 0x88, 0x00, 0x24, 0xC1, 0x07, 0x00, 0xD0, 0x01, 0x24, 0x81, 0x07,
+	0x01, 0xD5, 0x44, 0xF0,
+	0x02, 0x04, 0x41, 0x07, 0x01, 0xD5, 0x44, 0xF0, 0x04, 0x04, 0x01, 0x07,
+	0x01, 0xD5, 0x44, 0xF0,
+	0x08, 0x04, 0xC1, 0x05, 0x01, 0xD5, 0x44, 0xF4, 0x00, 0x74, 0x81, 0x05,
+	0x01, 0xD5, 0x44, 0xF4,
+	0x80, 0x64, 0xC1, 0x06, 0x01, 0xD5, 0x44, 0xF0, 0x10, 0x04, 0x00, 0x06,
+	0x01, 0xD5, 0x44, 0xF0,
+	0x80, 0x04, 0x6C, 0xB1, 0xEE, 0xF7, 0xAC, 0xFB, 0x63, 0x48, 0x01, 0x68,
+	0x21, 0x43, 0x01, 0x60,
+	0xEE, 0xF7, 0xA4, 0xFB, 0x02, 0x21, 0x00, 0x20, 0xFF, 0xF7, 0xF8, 0xFD,
+	0x01, 0x20, 0x10, 0xBD,
+	0x00, 0x20, 0x10, 0xBD, 0x10, 0xB5, 0x00, 0x88, 0x00, 0x24, 0xC1, 0x07,
+	0x00, 0xD0, 0x01, 0x24,
+	0x81, 0x07, 0x01, 0xD5, 0x44, 0xF0, 0x02, 0x04, 0x41, 0x07, 0x01, 0xD5,
+	0x44, 0xF0, 0x04, 0x04,
+	0x01, 0x07, 0x01, 0xD5, 0x44, 0xF0, 0x08, 0x04, 0xC0, 0x06, 0x01, 0xD5,
+	0x44, 0xF0, 0x10, 0x04,
+	0x74, 0xB1, 0xEE, 0xF7, 0x85, 0xFB, 0x51, 0x48, 0x01, 0x68, 0x21, 0x43,
+	0x01, 0x60, 0xEE, 0xF7,
+	0x7D, 0xFB, 0x4F, 0xF4, 0x00, 0x11, 0x00, 0x20, 0xFF, 0xF7, 0xD0, 0xFD,
+	0x01, 0x20, 0x10, 0xBD,
+	0x00, 0x20, 0x10, 0xBD, 0x10, 0xB5, 0x00, 0x88, 0x00, 0x24, 0xC1, 0x07,
+	0x00, 0xD0, 0x01, 0x24,
+	0x81, 0x07, 0x01, 0xD5, 0x44, 0xF0, 0x02, 0x04, 0x41, 0x07, 0x01, 0xD5,
+	0x44, 0xF0, 0x04, 0x04,
+	0x01, 0x07, 0x01, 0xD5, 0x44, 0xF0, 0x08, 0x04, 0xC1, 0x06, 0x01, 0xD5,
+	0x44, 0xF0, 0x10, 0x04,
+	0x81, 0x06, 0x01, 0xD5, 0x44, 0xF0, 0x20, 0x04, 0x41, 0x06, 0x01, 0xD5,
+	0x44, 0xF0, 0x40, 0x04,
+	0x01, 0x06, 0x01, 0xD5, 0x44, 0xF0, 0x80, 0x04, 0xC1, 0x05, 0x01, 0xD5,
+	0x44, 0xF4, 0x80, 0x74,
+	0x81, 0x05, 0x01, 0xD5, 0x44, 0xF4, 0x00, 0x74, 0x40, 0x05, 0x01, 0xD5,
+	0x44, 0xF4, 0x80, 0x64,
+	0x6C, 0xB1, 0xEE, 0xF7, 0x45, 0xFB, 0x32, 0x48, 0x01, 0x68, 0x21, 0x43,
+	0x01, 0x60, 0xEE, 0xF7,
+	0x3D, 0xFB, 0x80, 0x21, 0x00, 0x20, 0xFF, 0xF7, 0x91, 0xFD, 0x01, 0x20,
+	0x10, 0xBD, 0x00, 0x20,
+	0x10, 0xBD, 0x10, 0xB5, 0x00, 0x78, 0x00, 0x24, 0xC1, 0x07, 0x00, 0xD0,
+	0x01, 0x24, 0x81, 0x07,
+	0x01, 0xD5, 0x44, 0xF0, 0x02, 0x04, 0x40, 0x07, 0x01, 0xD5, 0x44, 0xF0,
+	0x04, 0x04, 0x74, 0xB1,
+	0xEE, 0xF7, 0x26, 0xFB, 0x23, 0x48, 0x01, 0x68, 0x21, 0x43, 0x01, 0x60,
+	0xEE, 0xF7, 0x1E, 0xFB,
+	0x4F, 0xF4, 0x80, 0x61, 0x00, 0x20, 0xFF, 0xF7, 0x71, 0xFD, 0x01, 0x20,
+	0x10, 0xBD, 0x00, 0x20,
+	0x10, 0xBD, 0x10, 0xB5, 0x00, 0x78, 0x00, 0x24, 0x31, 0x28, 0x39, 0xD0,
+	0x10, 0xDC, 0x12, 0x28,
+	0x32, 0xD0, 0x06, 0xDC, 0x01, 0x28, 0x1C, 0xD0, 0x10, 0x28, 0x2D, 0xD0,
+	0x11, 0x28, 0x31, 0xD1,
+	0x2A, 0xE0, 0x13, 0x28, 0x28, 0xD0, 0x14, 0x28, 0x26, 0xD0, 0x30, 0x28,
+	0x2A, 0xD1, 0x27, 0xE0,
+	0x51, 0x28, 0x29, 0xD0, 0x06, 0xDC, 0x32, 0x28, 0x22, 0xD0, 0x33, 0x28,
+	0x20, 0xD0, 0x50, 0x28,
+	0x20, 0xD1, 0x21, 0xE0, 0x52, 0x28, 0x1F, 0xD0, 0x53, 0x28, 0x1D, 0xD0,
+	0x54, 0x28, 0x19, 0xD1,
+	0x1A, 0xE0, 0x00, 0xF0, 0x5B, 0xFC, 0x11, 0xE0, 0xC8, 0x7A, 0x01, 0x00,
+	0x6C, 0x07, 0x10, 0x00,
+	0x70, 0x07, 0x10, 0x00, 0x54, 0x07, 0x10, 0x00, 0x58, 0x07, 0x10, 0x00,
+	0x5C, 0x07, 0x10, 0x00,
+	0x64, 0x07, 0x10, 0x00, 0x60, 0x07, 0x10, 0x00, 0x00, 0xF0, 0xDC, 0xFC,
+	0x01, 0x24, 0x01, 0xE0,
+	0x00, 0xF0, 0xF8, 0xFC, 0x20, 0x46, 0x10, 0xBD, 0x00, 0xF0, 0xE2, 0xFC,
+	0xF6, 0xE7, 0x00, 0x00,
+	0x08, 0xB5, 0x00, 0xF0, 0x3B, 0xFC, 0x00, 0xF0, 0xE3, 0xFD, 0x17, 0x4C,
+	0x6B, 0x46, 0x00, 0x22,
+	0x19, 0x21, 0x03, 0x20, 0xEE, 0xF7, 0x4E, 0xFC, 0x00, 0x98, 0xC0, 0x07,
+	0x05, 0xD0, 0x01, 0x21,
+	0x03, 0x20, 0xEE, 0xF7, 0x2A, 0xFC, 0xFF, 0xF7, 0xE3, 0xFC, 0x00, 0x98,
+	0x00, 0x07, 0x0B, 0xD5,
+	0x08, 0x21, 0x03, 0x20, 0xEE, 0xF7, 0x21, 0xFC, 0x20, 0x68, 0x08, 0x21,
+	0x40, 0xF0, 0x08, 0x00,
+	0x20, 0x60, 0x01, 0x20, 0xFF, 0xF7, 0x02, 0xFD, 0x00, 0x98, 0xC0, 0x06,
+	0xDE, 0xD5, 0x10, 0x21,
+	0x03, 0x20, 0xEE, 0xF7, 0x12, 0xFC, 0x20, 0x68, 0x08, 0x21, 0x20, 0xF0,
+	0x08, 0x00, 0x20, 0x60,
+	0x01, 0x20, 0xFF, 0xF7, 0xF3, 0xFC, 0xD1, 0xE7, 0x70, 0x07, 0x10, 0x00,
+	0x1F, 0x48, 0x00, 0x21,
+	0x01, 0x70, 0x41, 0x70, 0x81, 0x70, 0x70, 0x47, 0x10, 0xB5, 0x1C, 0x4C,
+	0x03, 0x46, 0xA0, 0x78,
+	0x10, 0x28, 0x14, 0xD2, 0x0F, 0x29, 0x00, 0xD9, 0x0F, 0x21, 0x19, 0x48,
+	0x22, 0x78, 0x00, 0xEB,
+	0x02, 0x10, 0x0A, 0x46, 0x00, 0xF8, 0x01, 0x1B, 0x19, 0x46, 0x05, 0xF0,
+	0xB6, 0xF9, 0x20, 0x78,
+	0x40, 0x1C, 0x00, 0xF0, 0x0F, 0x00, 0x20, 0x70, 0xA0, 0x78, 0x40, 0x1C,
+	0xA0, 0x70, 0x10, 0xBD,
+	0x70, 0xB5, 0x0E, 0x4C, 0x00, 0x25, 0xA1, 0x78, 0x91, 0xB1, 0x0D, 0x49,
+	0x62, 0x78, 0x01, 0xEB,
+	0x02, 0x11, 0x11, 0xF8, 0x01, 0x5B, 0x2A, 0x46, 0x05, 0xF0, 0x9F, 0xF9,
+	0x60, 0x78, 0x40, 0x1C,
+	0x00, 0xF0, 0x0F, 0x00, 0x60, 0x70, 0x72, 0xB6, 0xA0, 0x78, 0x40, 0x1E,
+	0xA0, 0x70, 0x62, 0xB6,
+	0x28, 0x46, 0x70, 0xBD, 0x01, 0x48, 0x80, 0x78, 0x70, 0x47, 0x00, 0x00,
+	0x34, 0x07, 0x10, 0x00,
+	0xF0, 0x4E, 0x10, 0x00, 0x70, 0xB5, 0x14, 0x46, 0x00, 0x20, 0x05, 0xF0,
+	0xAB, 0xFA, 0x00, 0xF0,
+	0x01, 0x05, 0x01, 0x20, 0x05, 0xF0, 0xA6, 0xFA, 0x00, 0xF0, 0x01, 0x00,
+	0x45, 0xEA, 0x00, 0x10,
+	0x20, 0x70, 0x01, 0x20, 0x70, 0xBD, 0x80, 0x20, 0x10, 0x70, 0x01, 0x20,
+	0x70, 0x47, 0x10, 0xB5,
+	0x14, 0x46, 0xEF, 0xF7, 0x64, 0xF8, 0x53, 0x21, 0x21, 0x70, 0x54, 0x21,
+	0x61, 0x70, 0x01, 0x0A,
+	0xA1, 0x70, 0xE0, 0x70, 0xEF, 0xF7, 0x5F, 0xF8, 0x20, 0x71, 0x05, 0x20,
+	0x10, 0xBD, 0x38, 0xB5,
+	0x14, 0x46, 0x70, 0x4A, 0x13, 0x68, 0x59, 0x8E, 0x98, 0x8E, 0x93, 0xF8,
+	0x36, 0x30, 0xDB, 0x07,
+	0x0A, 0xD0, 0x03, 0x0A, 0x23, 0x70, 0x60, 0x70, 0x0D, 0x0A, 0xA5, 0x70,
+	0xE1, 0x70, 0x23, 0x71,
+	0x60, 0x71, 0xA5, 0x71, 0xE1, 0x71, 0x09, 0xE0, 0x0B, 0x0A, 0x23, 0x70,
+	0x61, 0x70, 0x05, 0x0A,
+	0xA5, 0x70, 0xE0, 0x70, 0x23, 0x71, 0x61, 0x71, 0xA5, 0x71, 0xE0, 0x71,
+	0x10, 0x68, 0x90, 0xF8,
+	0x31, 0x10, 0x21, 0x72, 0x10, 0xF8, 0x30, 0x1F, 0x61, 0x72, 0x90, 0xF8,
+	0x31, 0x04, 0x8D, 0xF8,
+	0x00, 0x00, 0x01, 0x21, 0x68, 0x46, 0xEF, 0xF7, 0x8E, 0xF9, 0xA0, 0x72,
+	0x0B, 0x20, 0x38, 0xBD,
+	0xA2, 0x20, 0x10, 0x70, 0x33, 0x20, 0x50, 0x70, 0x00, 0x20, 0x90, 0x70,
+	0xD0, 0x70, 0x10, 0x71,
+	0x50, 0x71, 0x06, 0x20, 0x70, 0x47, 0x08, 0xB5, 0x02, 0x23, 0x00, 0x93,
+	0x52, 0x4B, 0x00, 0xF0,
+	0x8D, 0xF8, 0x02, 0x20, 0x08, 0xBD, 0x08, 0xB5, 0x01, 0x23, 0x00, 0x93,
+	0x4E, 0x4B, 0x9B, 0x1C,
+	0x00, 0xF0, 0x84, 0xF8, 0x01, 0x20, 0x08, 0xBD, 0x08, 0xB5, 0x01, 0x23,
+	0x00, 0x93, 0x4A, 0x4B,
+	0xDB, 0x1C, 0x00, 0xF0, 0x7B, 0xF8, 0x01, 0x20, 0x08, 0xBD, 0x08, 0xB5,
+	0x01, 0x23, 0x00, 0x93,
+	0x45, 0x4B, 0x1B, 0x1D, 0x00, 0xF0, 0x72, 0xF8, 0x01, 0x20, 0x08, 0xBD,
+	0x08, 0xB5, 0x01, 0x23,
+	0x00, 0x93, 0x41, 0x4B, 0x5B, 0x1D, 0x00, 0xF0, 0x69, 0xF8, 0x01, 0x20,
+	0x08, 0xBD, 0x08, 0xB5,
+	0x01, 0x23, 0x00, 0x93, 0x3C, 0x4B, 0x9B, 0x1D, 0x00, 0xF0, 0x60, 0xF8,
+	0x01, 0x20, 0x08, 0xBD,
+	0x08, 0xB5, 0x02, 0x23, 0x00, 0x93, 0x38, 0x4B, 0xDB, 0x1D, 0x00, 0xF0,
+	0x57, 0xF8, 0x02, 0x20,
+	0x08, 0xBD, 0x08, 0xB5, 0x02, 0x23, 0x00, 0x93, 0x33, 0x4B, 0x09, 0x33,
+	0x00, 0xF0, 0x4E, 0xF8,
+	0x02, 0x20, 0x08, 0xBD, 0x08, 0xB5, 0x01, 0x23, 0x00, 0x93, 0x2F, 0x4B,
+	0x0B, 0x33, 0x00, 0xF0,
+	0x45, 0xF8, 0x01, 0x20, 0x08, 0xBD, 0x08, 0xB5, 0x01, 0x23, 0x00, 0x93,
+	0x2A, 0x4B, 0x0C, 0x33,
+	0x00, 0xF0, 0x3C, 0xF8, 0x01, 0x20, 0x08, 0xBD, 0x08, 0xB5, 0x01, 0x23,
+	0x00, 0x93, 0x26, 0x4B,
+	0x0D, 0x33, 0x00, 0xF0, 0x33, 0xF8, 0x01, 0x20, 0x08, 0xBD, 0x2D, 0xE9,
+	0xF0, 0x41, 0x0F, 0x46,
+	0x04, 0x46, 0x00, 0x78, 0x49, 0x1E, 0xCE, 0xB2, 0x00, 0x25, 0x63, 0x1C,
+	0xA0, 0xF1, 0x20, 0x01,
+	0x04, 0x29, 0x09, 0xD8, 0x1D, 0x49, 0x01, 0xEB, 0x80, 0x00, 0x31, 0x46,
+	0x50, 0xF8, 0x80, 0x4C,
+	0x18, 0x46, 0xA0, 0x47, 0x05, 0x46, 0x16, 0xE0, 0xA0, 0xF1, 0x30, 0x01,
+	0x0B, 0x29, 0x12, 0xD8,
+	0x16, 0x49, 0x14, 0x31, 0x01, 0xEB, 0x80, 0x00, 0x31, 0x46, 0x50, 0xF8,
+	0xC0, 0x5C, 0x18, 0x46,
+	0xA8, 0x47, 0x05, 0x46, 0x3E, 0xB1, 0x39, 0x46, 0x20, 0x46, 0xFF, 0xF7,
+	0xD5, 0xFE, 0x01, 0x21,
+	0x03, 0x20, 0xEE, 0xF7, 0xA6, 0xFA, 0x28, 0x46, 0xBD, 0xE8, 0xF0, 0x81,
+	0x70, 0xB5, 0x1D, 0x46,
+	0x04, 0x9C, 0x16, 0x46, 0x39, 0xB1, 0xA1, 0x42, 0x00, 0xD9, 0x21, 0x46,
+	0x0A, 0x46, 0x01, 0x46,
+	0x18, 0x46, 0x05, 0xF0, 0x8A, 0xF8, 0x22, 0x46, 0x29, 0x46, 0x30, 0x46,
+	0xBD, 0xE8, 0x70, 0x40,
+	0x05, 0xF0, 0x83, 0xB8, 0x4C, 0x07, 0x10, 0x00, 0xF0, 0x4F, 0x10, 0x00,
+	0x90, 0x7B, 0x01, 0x00,
+	0x10, 0xB5, 0x4F, 0xF4, 0x86, 0x71, 0x46, 0x48, 0x05, 0xF0, 0x18, 0xF9,
+	0x44, 0x49, 0x01, 0x20,
+	0xC1, 0xF8, 0x04, 0x01, 0x43, 0x49, 0x00, 0x20, 0x08, 0x70, 0x05, 0xF0,
+	0xA1, 0xF9, 0x00, 0x21,
+	0xBD, 0xE8, 0x10, 0x40, 0x01, 0x20, 0xEF, 0xF7, 0x20, 0xB9, 0x10, 0xB5,
+	0x72, 0xB6, 0x00, 0x20,
+	0x3C, 0x49, 0x08, 0x70, 0x05, 0xF0, 0x94, 0xF9, 0x62, 0xB6, 0x10, 0xBD,
+	0x10, 0xB5, 0x72, 0xB6,
+	0x01, 0x20, 0x38, 0x49, 0x08, 0x70, 0x36, 0x48, 0xD0, 0xF8, 0x08, 0x01,
+	0x08, 0xB1, 0x05, 0xF0,
+	0x2B, 0xF9, 0x62, 0xB6, 0x10, 0xBD, 0x10, 0xB5, 0x72, 0xB6, 0x31, 0x49,
+	0xD1, 0xF8, 0x08, 0x31,
+	0xD1, 0xF8, 0x00, 0x21, 0x20, 0x2B, 0x07, 0xD2, 0x5B, 0x1C, 0x52, 0x1C,
+	0x22, 0xF0, 0x20, 0x02,
+	0xC1, 0xF8, 0x08, 0x31, 0xC1, 0xF8, 0x00, 0x21, 0x01, 0xEB, 0xC2, 0x02,
+	0x03, 0x68, 0x13, 0x60,
+	0x40, 0x68, 0x50, 0x60, 0x27, 0x48, 0x00, 0x78, 0x01, 0x28, 0x05, 0xD1,
+	0xD1, 0xF8, 0x08, 0x01,
+	0x01, 0x28, 0x01, 0xD1, 0x05, 0xF0, 0x08, 0xF9, 0x62, 0xB6, 0x10, 0xBD,
+	0x20, 0x4A, 0xD2, 0xF8,
+	0x08, 0x01, 0x00, 0x28, 0x0E, 0xD0, 0xD2, 0xF8, 0x04, 0x01, 0x02, 0xEB,
+	0xC0, 0x00, 0xC3, 0x79,
+	0x23, 0xF0, 0x3F, 0x03, 0xC3, 0x71, 0x92, 0xF8, 0x08, 0x21, 0x52, 0x1E,
+	0x02, 0xF0, 0x3F, 0x02,
+	0x13, 0x43, 0xC3, 0x71, 0x70, 0x47, 0x10, 0xB5, 0x72, 0xB6, 0x15, 0x48,
+	0xD0, 0xF8, 0x08, 0x11,
+	0x59, 0xB1, 0x49, 0x1E, 0xC0, 0xF8, 0x08, 0x11, 0xD0, 0xF8, 0x04, 0x21,
+	0x02, 0xF1, 0x01, 0x02,
+	0x22, 0xF0, 0x20, 0x02, 0xC0, 0xF8, 0x04, 0x21, 0x05, 0xD1, 0x0E, 0x48,
+	0x00, 0x78, 0x01, 0x28,
+	0x01, 0xD1, 0x05, 0xF0, 0x35, 0xF9, 0x62, 0xB6, 0x10, 0xBD, 0x10, 0xB5,
+	0x72, 0xB6, 0x00, 0x21,
+	0x07, 0x48, 0xC0, 0xF8, 0x08, 0x11, 0xC0, 0xF8, 0x00, 0x11, 0x01, 0x21,
+	0xC0, 0xF8, 0x04, 0x11,
+	0x04, 0x48, 0x00, 0x78, 0x01, 0x28, 0x01, 0xD1, 0x05, 0xF0, 0x22, 0xF9,
+	0x62, 0xB6, 0x10, 0xBD,
+	0x68, 0x42, 0x01, 0x20, 0x37, 0x07, 0x10, 0x00, 0x18, 0x49, 0x00, 0x22,
+	0x0A, 0x80, 0x4A, 0x80,
+	0x4F, 0xF4, 0x70, 0x42, 0x8A, 0x80, 0x16, 0x4A, 0xCA, 0x80, 0x16, 0x4A,
+	0x0A, 0x81, 0x16, 0x4A,
+	0xC0, 0xE9, 0x00, 0x21, 0x05, 0x21, 0x01, 0x72, 0x70, 0x47, 0x1C, 0xB5,
+	0x12, 0x49, 0xAD, 0xF8,
+	0x04, 0x00, 0x02, 0x20, 0x8D, 0xF8, 0x06, 0x00, 0x04, 0x20, 0x09, 0x1F,
+	0x8D, 0xF8, 0x07, 0x00,
+	0x00, 0x91, 0x68, 0x46, 0xEF, 0xF7, 0x4B, 0xF9, 0x1C, 0xBD, 0x30, 0xB4,
+	0x03, 0x46, 0x0A, 0x4A,
+	0x00, 0x20, 0x14, 0x78, 0x9C, 0x42, 0x02, 0xD1, 0x30, 0xBC, 0xEF, 0xF7,
+	0x76, 0xB9, 0x40, 0x1C,
+	0xC0, 0xB2, 0x52, 0x1D, 0x05, 0x28, 0xF4, 0xD3, 0x30, 0xBC, 0x70, 0x47,
+	0xFE, 0x4F, 0x10, 0x00,
+	0x14, 0xA6, 0x01, 0x20, 0x6C, 0xA2, 0x01, 0x20, 0xD4, 0x7B, 0x01, 0x00,
+	0x10, 0xB5, 0x88, 0xB3,
+	0xA3, 0x49, 0xA4, 0x4A, 0x09, 0x78, 0x37, 0x29, 0x71, 0xD0, 0x11, 0xDC,
+	0xA1, 0xF1, 0x20, 0x01,
+	0x17, 0x29, 0x2C, 0xD2, 0xDF, 0xE8, 0x01, 0xF0, 0x6B, 0x6B, 0x6B, 0x6B,
+	0x6B, 0x2B, 0x2B, 0x2B,
+	0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x6B, 0x6B, 0x6B, 0x6B,
+	0x6B, 0x6B, 0x6B, 0x00,
+	0x97, 0x4B, 0x70, 0x29, 0x5B, 0x78, 0x26, 0xD0, 0x0C, 0xDC, 0x3B, 0x29,
+	0x57, 0xD0, 0x04, 0xDC,
+	0x38, 0x29, 0x54, 0xD0, 0x3A, 0x29, 0x12, 0xD1, 0x51, 0xE0, 0x60, 0x29,
+	0x19, 0xD0, 0x61, 0x29,
+	0x0D, 0xD1, 0x16, 0xE0, 0x73, 0x29, 0x28, 0xD0, 0x05, 0xDC, 0x71, 0x29,
+	0x15, 0xD0, 0x72, 0x29,
+	0x05, 0xD1, 0x14, 0xE0, 0x0B, 0xE0, 0x85, 0x29, 0x0B, 0xD0, 0x86, 0x29,
+	0x09, 0xD0, 0xC1, 0xB2,
+	0x87, 0x48, 0xFF, 0xF7, 0xA9, 0xFD, 0x01, 0x21, 0x03, 0x20, 0xEE, 0xF7,
+	0x7A, 0xF9, 0x00, 0x20,
+	0x10, 0xBD, 0x02, 0x20, 0x10, 0xBD, 0x93, 0x70, 0xF9, 0xE7, 0xD3, 0x70,
+	0xF7, 0xE7, 0x90, 0x78,
+	0x01, 0x28, 0x08, 0xD0, 0x00, 0x28, 0xF2, 0xD1, 0x7F, 0x48, 0x81, 0xB2,
+	0x5F, 0xF0, 0x72, 0x00,
+	0xFF, 0xF7, 0x93, 0xFF, 0xEB, 0xE7, 0x7D, 0x48, 0xF7, 0xE7, 0xD0, 0x78,
+	0x01, 0x28, 0x05, 0xD0,
+	0x00, 0x28, 0xE4, 0xD1, 0x7A, 0x48, 0x81, 0xB2, 0x73, 0x20, 0xF1, 0xE7,
+	0x79, 0x4C, 0x7A, 0x49,
+	0x20, 0x68, 0x90, 0xF8, 0x31, 0x00, 0x42, 0x00, 0x71, 0x48, 0x10, 0x30,
+	0x04, 0xF0, 0x45, 0xFF,
+	0x20, 0x68, 0x10, 0xF8, 0x30, 0x1F, 0x4A, 0x00, 0x6D, 0x49, 0x40, 0x78,
+	0x10, 0x31, 0x01, 0xEB,
+	0x40, 0x00, 0x72, 0x49, 0x04, 0xF0, 0x39, 0xFF, 0x69, 0x48, 0x10, 0x30,
+	0xE3, 0xE7, 0xC1, 0xB2,
+	0x52, 0x68, 0x67, 0x48, 0xFF, 0xF7, 0x69, 0xFE, 0x6D, 0x49, 0x08, 0x70,
+	0x01, 0x20, 0x10, 0xBD,
+	0x2D, 0xE9, 0xF0, 0x5F, 0xDF, 0xF8, 0x88, 0xB1, 0x62, 0x4E, 0x62, 0x4D,
+	0x89, 0x46, 0x07, 0x46,
+	0x4F, 0xF0, 0x01, 0x0A, 0xAB, 0xF1, 0x10, 0x0B, 0x08, 0x36, 0x28, 0x78,
+	0xA8, 0x46, 0x04, 0x46,
+	0x07, 0x28, 0x76, 0xD2, 0xDF, 0xE8, 0x00, 0xF0, 0x04, 0x21, 0x25, 0x40,
+	0x5C, 0x78, 0x8A, 0x00,
+	0x01, 0x2F, 0x02, 0xD0, 0x02, 0x2F, 0x0C, 0xD0, 0x6B, 0xE0, 0x48, 0x46,
+	0xFF, 0xF7, 0x5E, 0xFF,
+	0x02, 0x28, 0x02, 0xD0, 0x01, 0x28, 0x02, 0xD0, 0x63, 0xE0, 0x03, 0x24,
+	0x61, 0xE0, 0x02, 0x24,
+	0x5F, 0xE0, 0x68, 0x78, 0x01, 0x28, 0x04, 0xD0, 0x4D, 0x48, 0x10, 0x21,
+	0x10, 0x38, 0x04, 0xF0,
+	0x7B, 0xFF, 0x54, 0x46, 0x86, 0xF8, 0x00, 0xA0, 0x53, 0xE0, 0x02, 0x2F,
+	0x4F, 0xD0, 0x00, 0x24,
+	0x39, 0xE0, 0x02, 0x2F, 0x1A, 0xD1, 0x4E, 0x4C, 0x45, 0x48, 0xD8, 0xF8,
+	0x04, 0x10, 0x22, 0x78,
+	0x10, 0x38, 0x04, 0xF0, 0xEA, 0xFE, 0x03, 0x20, 0x30, 0x70, 0x20, 0x78,
+	0xB0, 0x80, 0x98, 0xF8,
+	0x00, 0x00, 0x04, 0x24, 0x88, 0xF8, 0x01, 0x00, 0x88, 0xF8, 0x00, 0x40,
+	0x27, 0xE0, 0x00, 0x24,
+	0x88, 0xF8, 0x01, 0x00, 0x2C, 0x70, 0xB8, 0xE7, 0x02, 0x2F, 0x02, 0xD0,
+	0x01, 0x2F, 0xF6, 0xD0,
+	0x2F, 0xE0, 0xFF, 0xF7, 0xA3, 0xFE, 0x08, 0x21, 0x28, 0xB1, 0x02, 0x22,
+	0x32, 0x70, 0x70, 0x80,
+	0xB1, 0x80, 0x05, 0x24, 0x25, 0xE0, 0x68, 0x78, 0x06, 0x28, 0x04, 0xD0,
+	0x00, 0x22, 0xCB, 0xF8,
+	0x00, 0x20, 0xCB, 0xF8, 0x04, 0x20, 0x03, 0x20, 0x30, 0x70, 0xB1, 0x80,
+	0x06, 0x24, 0x18, 0xE0,
+	0x02, 0x2F, 0x08, 0xD0, 0x02, 0x24, 0xC0, 0xB2, 0x88, 0xF8, 0x01, 0x00,
+	0x2C, 0x70, 0x29, 0x48,
+	0x08, 0x30, 0xBD, 0xE8, 0xF0, 0x9F, 0x68, 0x78, 0x04, 0x28, 0x08, 0xD0,
+	0x0B, 0xEB, 0x09, 0x00,
+	0x49, 0x46, 0x10, 0xF8, 0x01, 0x2C, 0x22, 0x48, 0x10, 0x38, 0x04, 0xF0,
+	0x1D, 0xFF, 0x86, 0xF8,
+	0x00, 0xA0, 0xA8, 0x46, 0x28, 0x78, 0xE7, 0xE7, 0x02, 0x2F, 0x05, 0xD0,
+	0xB9, 0xF1, 0x08, 0x0F,
+	0x93, 0xD1, 0xFF, 0xF7, 0x80, 0xFE, 0x90, 0xE7, 0xFF, 0xF7, 0x7D, 0xFE,
+	0x98, 0xF8, 0x00, 0x00,
+	0x03, 0x24, 0x88, 0xF8, 0x01, 0x00, 0x88, 0xF8, 0x00, 0x40, 0x6E, 0xE7,
+	0x02, 0x2F, 0x4F, 0xF0,
+	0x03, 0x04, 0xAD, 0xD0, 0xCF, 0xE7, 0x13, 0x49, 0x00, 0x22, 0x0A, 0x70,
+	0x4A, 0x70, 0x18, 0x4A,
+	0x52, 0x1C, 0x4A, 0x60, 0x17, 0x49, 0x01, 0x60, 0x0D, 0x49, 0x10, 0x39,
+	0x81, 0x80, 0x10, 0x31,
+	0xC1, 0x80, 0x10, 0x21, 0x01, 0x81, 0x0E, 0x21, 0x13, 0x48, 0x04, 0xF0,
+	0xF5, 0xBE, 0x10, 0xB5,
+	0x04, 0x46, 0x04, 0xF0, 0xA5, 0xFF, 0x06, 0x48, 0x21, 0x68, 0x10, 0x38,
+	0x01, 0x60, 0x61, 0x68,
+	0x41, 0x60, 0x0E, 0x48, 0xFF, 0xF7, 0x91, 0xFE, 0xBD, 0xE8, 0x10, 0x40,
+	0x04, 0xF0, 0x3C, 0xBF,
+	0x84, 0x43, 0x01, 0x20, 0x38, 0x07, 0x10, 0x00, 0x14, 0xA6, 0x01, 0x20,
+	0xEE, 0x35, 0x01, 0x20,
+	0x6C, 0xA2, 0x01, 0x20, 0x4C, 0x07, 0x10, 0x00, 0x94, 0x0B, 0x01, 0x20,
+	0xBE, 0x0B, 0x01, 0x20,
+	0x08, 0x50, 0x10, 0x00, 0xB1, 0x22, 0x01, 0x00, 0xF0, 0x4F, 0x10, 0x00,
+	0x74, 0x43, 0x00, 0x00,
+	0x70, 0xB5, 0x04, 0x4D, 0x38, 0x21, 0x28, 0x46, 0x2C, 0x88, 0x04, 0xF0,
+	0xC5, 0xFE, 0x64, 0x1C,
+	0x2C, 0x80, 0x70, 0xBD, 0x0A, 0x44, 0x01, 0x20, 0x37, 0x48, 0x00, 0x21,
+	0x01, 0x60, 0x41, 0x60,
+	0x70, 0x47, 0xC0, 0xB2, 0x01, 0x22, 0x00, 0xF0, 0x48, 0xFA, 0xFE, 0xE7,
+	0x34, 0x4C, 0x00, 0x25,
+	0x32, 0x4F, 0xC4, 0xE9, 0x02, 0x25, 0xC4, 0xE9, 0x00, 0x71, 0x06, 0x46,
+	0x00, 0x68, 0x20, 0x61,
+	0x70, 0x68, 0x60, 0x61, 0xB0, 0x68, 0xA0, 0x61, 0xF0, 0x68, 0xE0, 0x61,
+	0x30, 0x69, 0x20, 0x62,
+	0x70, 0x69, 0x60, 0x62, 0xB0, 0x69, 0xA0, 0x62, 0xF0, 0x69, 0xE0, 0x62,
+	0x29, 0x48, 0x90, 0x46,
+	0x89, 0x46, 0x00, 0x68, 0x20, 0x63, 0x27, 0x48, 0x10, 0x38, 0x00, 0x68,
+	0x60, 0x63, 0x25, 0x48,
+	0x0C, 0x38, 0x00, 0x68, 0xA0, 0x63, 0x23, 0x48, 0x08, 0x38, 0x00, 0x68,
+	0xE0, 0x63, 0x21, 0x48,
+	0x00, 0x1D, 0x00, 0x68, 0x20, 0x64, 0x1F, 0x48, 0x34, 0x38, 0x00, 0x68,
+	0x60, 0x64, 0x1D, 0x48,
+	0x14, 0x38, 0x00, 0x68, 0xC4, 0xE9, 0x12, 0x05, 0xEE, 0xF7, 0x9B, 0xF9,
+	0x20, 0x65, 0xC4, 0xE9,
+	0x15, 0x65, 0xE5, 0x65, 0x25, 0x66, 0x65, 0x66, 0xA5, 0x66, 0xE5, 0x66,
+	0x25, 0x67, 0x65, 0x67,
+	0xC4, 0xE9, 0x1E, 0x57, 0x41, 0x46, 0x48, 0x46, 0xFF, 0xF7, 0xB3, 0xFF,
+	0x10, 0xB5, 0x04, 0x46,
+	0xC0, 0xB2, 0x00, 0x22, 0x00, 0xF0, 0xF9, 0xF9, 0x0F, 0x49, 0x08, 0x68,
+	0x08, 0x28, 0x03, 0xDA,
+	0x09, 0x4A, 0x14, 0x54, 0x40, 0x1C, 0x08, 0x60, 0x10, 0xBD, 0x01, 0x28,
+	0x06, 0xD0, 0x02, 0x28,
+	0x08, 0xD1, 0x00, 0x22, 0x11, 0x46, 0x13, 0x20, 0x00, 0xF0, 0xE7, 0xB9,
+	0x00, 0x22, 0x11, 0x46,
+	0x12, 0x20, 0xF9, 0xE7, 0x70, 0x47, 0x00, 0x00, 0x70, 0xEF, 0x01, 0x20,
+	0xAF, 0x05, 0x50, 0xFA,
+	0x80, 0xEF, 0x01, 0x20, 0x38, 0xED, 0x00, 0xE0, 0x48, 0x07, 0x10, 0x00,
+	0x2D, 0xE9, 0xF0, 0x41,
+	0x40, 0xF2, 0x02, 0x71, 0xB9, 0x48, 0x04, 0xF0, 0x3F, 0xFE, 0xB8, 0x4C,
+	0x01, 0x26, 0x00, 0x25,
+	0x66, 0x70, 0xA5, 0x80, 0xA5, 0x71, 0x02, 0x20, 0xE0, 0x71, 0xEE, 0xF7,
+	0xAC, 0xFC, 0x20, 0x81,
+	0xEE, 0xF7, 0xA5, 0xFC, 0x07, 0x02, 0xEE, 0xF7, 0xA2, 0xFC, 0x47, 0xEA,
+	0x10, 0x20, 0x60, 0x81,
+	0x4A, 0xF2, 0x33, 0x20, 0x20, 0x82, 0x30, 0x02, 0x60, 0x82, 0xAD, 0x48,
+	0x00, 0x68, 0x41, 0x8A,
+	0xA1, 0x82, 0x01, 0x8A, 0xE1, 0x82, 0xC1, 0x8A, 0x21, 0x83, 0x81, 0x8A,
+	0x61, 0x83, 0x90, 0xF8,
+	0xDE, 0x10, 0x21, 0x77, 0xA7, 0x49, 0x09, 0x68, 0x09, 0x7E, 0x61, 0x77,
+	0x90, 0xF8, 0xA0, 0x10,
+	0x01, 0xF0, 0x01, 0x01, 0xA1, 0x77, 0x81, 0x69, 0x21, 0x63, 0xC1, 0x69,
+	0x61, 0x63, 0xA5, 0x63,
+	0xE5, 0x63, 0xA4, 0xF8, 0x40, 0x50, 0x84, 0xF8, 0x42, 0x50, 0x84, 0xF8,
+	0x43, 0x60, 0x41, 0x8E,
+	0xA4, 0xF8, 0x50, 0x10, 0x81, 0x8E, 0xA4, 0xF8, 0x52, 0x10, 0x90, 0xF8,
+	0x31, 0x10, 0x84, 0xF8,
+	0x54, 0x10, 0x90, 0xF8, 0x30, 0x10, 0x84, 0xF8, 0x55, 0x10, 0x01, 0x21,
+	0x00, 0xF2, 0x61, 0x40,
+	0xEE, 0xF7, 0xC9, 0xFD, 0x84, 0xF8, 0x56, 0x00, 0x93, 0x48, 0xA4, 0xF8,
+	0x80, 0x00, 0x93, 0x48,
+	0xA4, 0xF8, 0x88, 0x00, 0x92, 0x48, 0xA4, 0xF8, 0x8A, 0x00, 0x92, 0x48,
+	0xA4, 0xF8, 0x8C, 0x00,
+	0x91, 0x48, 0xA4, 0xF8, 0x8E, 0x00, 0x91, 0x48, 0xA4, 0xF8, 0x90, 0x00,
+	0x90, 0x48, 0xA4, 0xF8,
+	0x92, 0x00, 0x90, 0x48, 0xA4, 0xF8, 0x94, 0x00, 0x8F, 0x48, 0xA4, 0xF8,
+	0x96, 0x00, 0x8F, 0x48,
+	0xA4, 0xF8, 0x98, 0x00, 0x8E, 0x48, 0xA4, 0xF8, 0x9A, 0x00, 0x8E, 0x48,
+	0xA4, 0xF8, 0x9C, 0x00,
+	0x8D, 0x48, 0xA4, 0xF8, 0x9E, 0x00, 0x8D, 0x48, 0xA4, 0xF8, 0xA0, 0x00,
+	0x8C, 0x48, 0xA4, 0xF8,
+	0xA2, 0x00, 0x8C, 0x48, 0xA4, 0xF8, 0xA4, 0x00, 0x8C, 0x49, 0x8B, 0x48,
+	0xA4, 0xF8, 0xA6, 0x00,
+	0x48, 0x88, 0x40, 0x1C, 0x48, 0x80, 0xA5, 0x22, 0x22, 0x70, 0x66, 0x70,
+	0x60, 0x80, 0x0E, 0x70,
+	0xBD, 0xE8, 0xF0, 0x81, 0x70, 0xB5, 0x85, 0x4C, 0x05, 0x46, 0x00, 0x23,
+	0x60, 0x88, 0x6F, 0x49,
+	0x40, 0x1C, 0x82, 0xB2, 0x62, 0x80, 0x28, 0x46, 0x01, 0xF0, 0x80, 0xFA,
+	0x25, 0x70, 0x70, 0xBD,
+	0x70, 0xB5, 0x05, 0x46, 0x40, 0xF2, 0x02, 0x71, 0x68, 0x48, 0x04, 0xF0,
+	0x9D, 0xFD, 0x7B, 0x4C,
+	0x66, 0x49, 0x60, 0x88, 0x40, 0x1C, 0x82, 0xB2, 0x62, 0x80, 0x28, 0x46,
+	0x01, 0xF0, 0xA6, 0xFA,
+	0x25, 0x70, 0x70, 0xBD, 0x2D, 0xE9, 0xF0, 0x41, 0x74, 0x4C, 0x05, 0x46,
+	0x20, 0x78, 0xA8, 0x42,
+	0x04, 0xD0, 0x40, 0xF2, 0x02, 0x71, 0x5D, 0x48, 0x04, 0xF0, 0x86, 0xFD,
+	0x70, 0x49, 0x65, 0x70,
+	0x0F, 0x20, 0x08, 0x60, 0x5A, 0x48, 0x00, 0x68, 0x90, 0xF8, 0x61, 0x24,
+	0x0A, 0xB1, 0x1F, 0x22,
+	0x0A, 0x60, 0x56, 0x49, 0x55, 0x4D, 0x10, 0x31, 0x61, 0x60, 0x38, 0x21,
+	0x29, 0x71, 0x05, 0xF1,
+	0x48, 0x03, 0xA3, 0x60, 0x90, 0xF8, 0x31, 0x20, 0x90, 0xF8, 0x30, 0x60,
+	0x6A, 0x71, 0x02, 0xFB,
+	0x06, 0xF1, 0x03, 0xEB, 0x41, 0x07, 0xAE, 0x71, 0xE7, 0x60, 0xEA, 0x71,
+	0x11, 0x44, 0x03, 0xEB,
+	0x41, 0x02, 0x22, 0x61, 0x31, 0x44, 0x2E, 0x72, 0x03, 0xEB, 0x41, 0x01,
+	0x61, 0x61, 0x01, 0x21,
+	0x00, 0xF2, 0x61, 0x40, 0xEE, 0xF7, 0x2F, 0xFD, 0x68, 0x72, 0xA1, 0xE7,
+	0x2D, 0xE9, 0xF0, 0x41,
+	0x05, 0x46, 0x56, 0x4C, 0x17, 0x46, 0x88, 0x46, 0xC0, 0x07, 0x04, 0xD0,
+	0x38, 0x22, 0x42, 0x49,
+	0x60, 0x68, 0x04, 0xF0, 0xCA, 0xFC, 0x3E, 0x4E, 0xA8, 0x07, 0x12, 0xD5,
+	0x31, 0x68, 0x91, 0xF8,
+	0x31, 0x00, 0x91, 0xF8, 0x30, 0x10, 0x48, 0x43, 0x61, 0x78, 0x30, 0x29,
+	0x3E, 0xD0, 0x31, 0x29,
+	0x3E, 0xD0, 0x32, 0x29, 0x42, 0xD0, 0x3B, 0x49, 0xA3, 0x68, 0x42, 0x00,
+	0x18, 0x46, 0x04, 0xF0,
+	0xB4, 0xFC, 0x68, 0x07, 0x0E, 0xD5, 0x30, 0x68, 0x90, 0xF8, 0x31, 0x20,
+	0x60, 0x78, 0x30, 0x28,
+	0x36, 0xD0, 0x31, 0x28, 0x36, 0xD0, 0x32, 0x28, 0x39, 0xD0, 0x36, 0x49,
+	0x52, 0x00, 0xE0, 0x68,
+	0x04, 0xF0, 0xA3, 0xFC, 0x28, 0x07, 0x0F, 0xD5, 0x30, 0x68, 0x61, 0x78,
+	0x90, 0xF8, 0x30, 0x00,
+	0x30, 0x29, 0x2E, 0xD0, 0x31, 0x29, 0x2E, 0xD0, 0x32, 0x29, 0x31, 0xD0,
+	0x31, 0x49, 0x23, 0x69,
+	0x42, 0x00, 0x18, 0x46, 0x04, 0xF0, 0x91, 0xFC, 0xE8, 0x06, 0x31, 0xD5,
+	0x1F, 0x48, 0x42, 0x7A,
+	0x60, 0x78, 0x30, 0x28, 0x26, 0xD0, 0x31, 0x28, 0x26, 0xD0, 0x32, 0x28,
+	0x26, 0xD0, 0x2D, 0x49,
+	0x60, 0x69, 0xBD, 0xE8, 0xF0, 0x41, 0x52, 0x00, 0x04, 0xF0, 0x7F, 0xBC,
+	0x1B, 0x49, 0xC3, 0xE7,
+	0x1B, 0x49, 0xB8, 0xF1, 0x00, 0x0F, 0xBF, 0xD0, 0x2A, 0x49, 0xBD, 0xE7,
+	0x1A, 0x49, 0xBB, 0xE7,
+	0x1A, 0x49, 0xCB, 0xE7, 0x1A, 0x49, 0x00, 0x2F, 0xC8, 0xD0, 0x27, 0x49,
+	0xC6, 0xE7, 0x1A, 0x49,
+	0xC4, 0xE7, 0x1A, 0x49, 0xD3, 0xE7, 0x1A, 0x49, 0x00, 0x2F, 0xD0, 0xD0,
+	0x23, 0x49, 0xCE, 0xE7,
+	0x19, 0x49, 0xCC, 0xE7, 0x19, 0x49, 0xDB, 0xE7, 0x19, 0x49, 0xD9, 0xE7,
+	0x1A, 0x49, 0xD7, 0xE7,
+	0x26, 0xE7, 0x06, 0x4A, 0xA5, 0x20, 0x10, 0x70, 0x18, 0x48, 0x41, 0x78,
+	0x51, 0x70, 0x01, 0x70,
+	0x41, 0x88, 0x49, 0x1C, 0x41, 0x80, 0x51, 0x80, 0x70, 0x47, 0x00, 0x00,
+	0x00, 0x00, 0x01, 0x20,
+	0x4C, 0x07, 0x10, 0x00, 0x50, 0x07, 0x10, 0x00, 0x0A, 0x44, 0x01, 0x20,
+	0x14, 0xA6, 0x01, 0x20,
+	0xB2, 0x2F, 0x01, 0x20, 0xEE, 0x35, 0x01, 0x20, 0x42, 0x44, 0x01, 0x20,
+	0x04, 0xA3, 0x01, 0x20,
+	0x1E, 0x0B, 0x01, 0x20, 0x94, 0x0B, 0x01, 0x20, 0x7E, 0x4A, 0x01, 0x20,
+	0x2E, 0xA3, 0x01, 0x20,
+	0x48, 0x0B, 0x01, 0x20, 0xBE, 0x0B, 0x01, 0x20, 0xA8, 0x4A, 0x01, 0x20,
+	0xB8, 0xA4, 0x01, 0x20,
+	0xA2, 0x1C, 0x01, 0x20, 0xAA, 0x1C, 0x01, 0x20, 0xF4, 0x4A, 0x01, 0x20,
+	0x94, 0x07, 0x10, 0x00,
+	0x68, 0x07, 0x10, 0x00, 0x4A, 0x0C, 0x01, 0x20, 0x92, 0x09, 0x01, 0x20,
+	0xBC, 0x09, 0x01, 0x20,
+	0x1F, 0x48, 0x00, 0x68, 0x90, 0xF8, 0xA0, 0x00, 0xC0, 0x07, 0x01, 0xD0,
+	0x00, 0xF0, 0x3A, 0xB8,
+	0x00, 0xF0, 0xDC, 0xB8, 0x1A, 0x49, 0x09, 0x68, 0x91, 0xF8, 0xA0, 0x10,
+	0xC9, 0x07, 0x02, 0xD0,
+	0xC0, 0xB2, 0x00, 0xF0, 0x39, 0xB8, 0x01, 0x46, 0x00, 0x20, 0x00, 0xF0,
+	0x2C, 0xB9, 0x38, 0xB5,
+	0x04, 0x46, 0x69, 0x46, 0x18, 0x30, 0x00, 0xF0, 0xA2, 0xFD, 0x11, 0x48,
+	0x00, 0x99, 0x00, 0x68,
+	0x90, 0xF8, 0xA0, 0x00, 0xC0, 0x07, 0x20, 0x46, 0x02, 0xD0, 0x00, 0xF0,
+	0x44, 0xF8, 0x38, 0xBD,
+	0x00, 0xF0, 0xC6, 0xF8, 0x38, 0xBD, 0x00, 0xF0, 0x24, 0xB9, 0x09, 0x4B,
+	0x1B, 0x68, 0x93, 0xF8,
+	0xA0, 0x30, 0xDB, 0x07, 0x01, 0xD1, 0x00, 0xF0, 0x3A, 0xB9, 0x70, 0x47,
+	0x04, 0x4A, 0x12, 0x68,
+	0x92, 0xF8, 0xA0, 0x20, 0x52, 0x07, 0x01, 0xD5, 0x00, 0xF0, 0x43, 0xB9,
+	0x70, 0x47, 0x00, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x1C, 0xB5, 0x4F, 0x49, 0xD1, 0xE9, 0x00, 0x01,
+	0xCD, 0xE9, 0x00, 0x01,
+	0x68, 0x46, 0xFF, 0xF7, 0x80, 0xFB, 0x1C, 0xBD, 0x1C, 0xB5, 0x4A, 0x4A,
+	0xD2, 0xE9, 0x02, 0x12,
+	0xCD, 0xE9, 0x00, 0x12, 0x8D, 0xF8, 0x02, 0x00, 0x68, 0x46, 0xFF, 0xF7,
+	0x74, 0xFB, 0x1C, 0xBD,
+	0x88, 0x42, 0x0E, 0xD9, 0x90, 0x42, 0x01, 0xD3, 0xFF, 0x20, 0x70, 0x47,
+	0x91, 0x42, 0x08, 0xD0,
+	0x40, 0x1A, 0xC0, 0xEB, 0x00, 0x20, 0x51, 0x1A, 0xB0, 0xFB, 0xF1, 0xF0,
+	0x10, 0xF0, 0xFF, 0x00,
+	0xF3, 0xD1, 0x01, 0x20, 0x70, 0x47, 0x7C, 0xB5, 0x05, 0x46, 0x00, 0x20,
+	0x00, 0x90, 0x01, 0x90,
+	0x95, 0xF8, 0x4D, 0x21, 0x9D, 0xF8, 0x00, 0x00, 0x62, 0xF3, 0x85, 0x00,
+	0x8D, 0xF8, 0x00, 0x00,
+	0x95, 0xF8, 0x3E, 0x21, 0x03, 0x2A, 0x3E, 0xD0, 0x08, 0x2A, 0x40, 0xD0,
+	0x20, 0xF0, 0xC0, 0x00,
+	0x10, 0xF1, 0x80, 0x00, 0x8D, 0xF8, 0x00, 0x00, 0x0A, 0x14, 0x10, 0x09,
+	0x8D, 0xF8, 0x01, 0x00,
+	0x9D, 0xF8, 0x03, 0x00, 0x2C, 0x4E, 0x62, 0xF3, 0x07, 0x10, 0x0A, 0x09,
+	0x8D, 0xF8, 0x02, 0x20,
+	0x61, 0xF3, 0x03, 0x00, 0x8D, 0xF8, 0x03, 0x00, 0x30, 0x68, 0xB0, 0xF8,
+	0xA3, 0x20, 0xB0, 0xF8,
+	0xA1, 0x10, 0x35, 0xF8, 0x4A, 0x0F, 0xFF, 0xF7, 0xBB, 0xFF, 0x8D, 0xF8,
+	0x04, 0x00, 0x30, 0x68,
+	0xB0, 0xF8, 0xA7, 0x20, 0xB0, 0xF8, 0xA5, 0x10, 0x68, 0x88, 0xFF, 0xF7,
+	0xB1, 0xFF, 0x8D, 0xF8,
+	0x05, 0x00, 0x29, 0x7A, 0x9D, 0xF8, 0x06, 0x00, 0x61, 0xF3, 0x05, 0x00,
+	0x8D, 0xF8, 0x06, 0x00,
+	0x95, 0xF8, 0xF6, 0x10, 0x09, 0x29, 0x1E, 0xD2, 0xDF, 0xE8, 0x01, 0xF0,
+	0x0C, 0x0E, 0x10, 0x12,
+	0x14, 0x16, 0x18, 0x1A, 0x1C, 0x00, 0x20, 0xF0, 0xC0, 0x00, 0x40, 0x30,
+	0xC2, 0xE7, 0x40, 0xF0,
+	0xC0, 0x00, 0xBF, 0xE7, 0x00, 0x24, 0x0E, 0xE0, 0x01, 0x24, 0x0C, 0xE0,
+	0x02, 0x24, 0x0A, 0xE0,
+	0x03, 0x24, 0x08, 0xE0, 0x04, 0x24, 0x06, 0xE0, 0x05, 0x24, 0x04, 0xE0,
+	0x06, 0x24, 0x02, 0xE0,
+	0x07, 0x24, 0x00, 0xE0, 0x08, 0x24, 0xA1, 0x08, 0x61, 0xF3, 0x87, 0x10,
+	0x8D, 0xF8, 0x06, 0x00,
+	0x9D, 0xF8, 0x07, 0x00, 0x64, 0xF3, 0x87, 0x10, 0x8D, 0xF8, 0x07, 0x00,
+	0x68, 0x46, 0xFF, 0xF7,
+	0xEA, 0xFA, 0x7C, 0xBD, 0xF0, 0x7B, 0x01, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x1C, 0xB5, 0x54, 0x49,
+	0xD1, 0xE9, 0x00, 0x01, 0xCD, 0xE9, 0x00, 0x01, 0x68, 0x46, 0xFF, 0xF7,
+	0xDC, 0xFA, 0x1C, 0xBD,
+	0x1C, 0xB5, 0x4F, 0x4B, 0xD3, 0xE9, 0x02, 0x23, 0xCD, 0xE9, 0x00, 0x23,
+	0x90, 0xF8, 0x3E, 0x21,
+	0x03, 0x2A, 0x19, 0xD0, 0x08, 0x2A, 0x9D, 0xF8, 0x00, 0x20, 0x22, 0xF0,
+	0xF0, 0x02, 0x19, 0xD0,
+	0x12, 0xF1, 0x20, 0x02, 0x8D, 0xF8, 0x00, 0x20, 0x90, 0xF8, 0x3F, 0x21,
+	0x02, 0xF0, 0x0F, 0x02,
+	0x01, 0x2A, 0x11, 0xD0, 0x02, 0x2A, 0x15, 0xD0, 0x04, 0x2A, 0x9D, 0xF8,
+	0x01, 0x20, 0x22, 0xF0,
+	0x0F, 0x02, 0x2E, 0xD0, 0x52, 0x1C, 0x12, 0xE0, 0x9D, 0xF8, 0x00, 0x20,
+	0x22, 0xF0, 0xF0, 0x02,
+	0x10, 0x32, 0xE7, 0xE7, 0x30, 0x32, 0xE5, 0xE7, 0x9D, 0xF8, 0x01, 0x20,
+	0x22, 0xF0, 0x0F, 0x02,
+	0x92, 0x1C, 0x04, 0xE0, 0x9D, 0xF8, 0x01, 0x20, 0x22, 0xF0, 0x0F, 0x02,
+	0xD2, 0x1C, 0x8D, 0xF8,
+	0x01, 0x20, 0x90, 0xF8, 0x4D, 0x01, 0xD2, 0xB2, 0x60, 0xF3, 0x07, 0x12,
+	0x8D, 0xF8, 0x01, 0x20,
+	0xBD, 0xF8, 0x02, 0x00, 0x0A, 0x0C, 0x62, 0xF3, 0x0B, 0x00, 0xAD, 0xF8,
+	0x02, 0x00, 0xBD, 0xF8,
+	0x03, 0x00, 0x61, 0xF3, 0x0F, 0x10, 0xAD, 0xF8, 0x03, 0x00, 0x68, 0x46,
+	0xFF, 0xF7, 0x8B, 0xFA,
+	0x1C, 0xBD, 0x12, 0x1D, 0xE3, 0xE7, 0x1C, 0xB5, 0x25, 0x4B, 0xD3, 0xE9,
+	0x04, 0x23, 0xCD, 0xE9,
+	0x00, 0x23, 0x8D, 0xF8, 0x01, 0x00, 0xCD, 0xF8, 0x02, 0x10, 0x68, 0x46,
+	0xFF, 0xF7, 0x7B, 0xFA,
+	0x1C, 0xBD, 0x1C, 0xB5, 0x1F, 0x4A, 0x12, 0x68, 0x92, 0xF8, 0xA0, 0x20,
+	0x93, 0x07, 0x15, 0xD5,
+	0x08, 0x28, 0x13, 0xD2, 0xDF, 0xE8, 0x00, 0xF0, 0x12, 0x04, 0x06, 0x06,
+	0x06, 0x06, 0x06, 0x06,
+	0x12, 0x06, 0x0B, 0xD5, 0x16, 0x4B, 0xD3, 0xE9, 0x06, 0x23, 0xCD, 0xE9,
+	0x00, 0x23, 0x8D, 0xF8,
+	0x01, 0x00, 0xCD, 0xF8, 0x02, 0x10, 0x68, 0x46, 0xFF, 0xF7, 0x5D, 0xFA,
+	0x1C, 0xBD, 0x1C, 0xB5,
+	0x0F, 0x4C, 0xD4, 0xE9, 0x08, 0x34, 0xCD, 0xE9, 0x00, 0x34, 0x8D, 0xF8,
+	0x01, 0x00, 0xCD, 0xF8,
+	0x02, 0x10, 0x68, 0x46, 0x12, 0xB1, 0xFF, 0xF7, 0x2A, 0xFC, 0x1C, 0xBD,
+	0xFF, 0xF7, 0x4B, 0xFA,
+	0x1C, 0xBD, 0x1C, 0xB5, 0x06, 0x4B, 0xD3, 0xE9, 0x0A, 0x23, 0xCD, 0xE9,
+	0x00, 0x23, 0x8D, 0xF8,
+	0x01, 0x00, 0xCD, 0xF8, 0x02, 0x10, 0x68, 0x46, 0xFF, 0xF7, 0x3D, 0xFA,
+	0x1C, 0xBD, 0x00, 0x00,
+	0x08, 0x7C, 0x01, 0x00, 0x4C, 0x07, 0x10, 0x00, 0x2D, 0xE9, 0xFF, 0x41,
+	0xED, 0xF7, 0xDC, 0xFB,
+	0x23, 0x4D, 0x00, 0x24, 0xC4, 0xEB, 0xC4, 0x01, 0x05, 0xEB, 0x81, 0x00,
+	0x00, 0xF1, 0x0C, 0x03,
+	0x02, 0x7E, 0xC8, 0xCB, 0xCD, 0xE9, 0x02, 0x72, 0xCD, 0xE9, 0x00, 0x36,
+	0xD0, 0xE9, 0x01, 0x23,
+	0x55, 0xF8, 0x21, 0x00, 0x00, 0x21, 0xED, 0xF7, 0xB1, 0xFD, 0x18, 0xB1,
+	0x21, 0x46, 0x43, 0x20,
+	0xFF, 0xF7, 0x2F, 0xFC, 0x64, 0x1C, 0x05, 0x2C, 0xE4, 0xDB, 0x15, 0x4D,
+	0x00, 0x24, 0x8C, 0x35,
+	0x05, 0xEB, 0xC4, 0x00, 0x00, 0x21, 0x42, 0x68, 0x55, 0xF8, 0x34, 0x00,
+	0xED, 0xF7, 0x25, 0xFD,
+	0x18, 0xB1, 0x21, 0x46, 0x44, 0x20, 0xFF, 0xF7, 0x1C, 0xFC, 0x64, 0x1C,
+	0x06, 0x2C, 0xEF, 0xDB,
+	0x0B, 0x4D, 0x00, 0x24, 0x15, 0xF1, 0xBC, 0x05, 0x00, 0x21, 0x55, 0xF8,
+	0x24, 0x00, 0xED, 0xF7,
+	0x3A, 0xFC, 0x18, 0xB1, 0x21, 0x46, 0x45, 0x20, 0xFF, 0xF7, 0x0B, 0xFC,
+	0x64, 0x1C, 0x04, 0x2C,
+	0xF2, 0xDB, 0xBD, 0xE8, 0xFF, 0x81, 0x01, 0x46, 0x46, 0x20, 0xFF, 0xF7,
+	0x02, 0xBC, 0x00, 0x00,
+	0x38, 0x7C, 0x01, 0x00, 0x00, 0xF0, 0x1F, 0x03, 0x01, 0x22, 0x9A, 0x40,
+	0x43, 0x09, 0x9B, 0x00,
+	0x03, 0xF1, 0xE0, 0x23, 0xC3, 0xF8, 0x80, 0x22, 0x49, 0x07, 0x09, 0x0E,
+	0x00, 0x28, 0x06, 0xDA,
+	0x00, 0xF0, 0x0F, 0x00, 0x00, 0xF1, 0xE0, 0x20, 0x80, 0xF8, 0x14, 0x1D,
+	0x03, 0xE0, 0x00, 0xF1,
+	0xE0, 0x20, 0x80, 0xF8, 0x00, 0x14, 0xC3, 0xF8, 0x00, 0x21, 0x70, 0x47,
+	0x2D, 0xE9, 0xF0, 0x41,
+	0x64, 0x27, 0x07, 0x26, 0x00, 0x25, 0xFD, 0x4C, 0xFD, 0x48, 0xEE, 0xF7,
+	0xF3, 0xF9, 0xFC, 0x48,
+	0x03, 0x68, 0xD9, 0x1C, 0x3C, 0xD0, 0x42, 0x68, 0xD1, 0x1C, 0x39, 0xD0,
+	0x81, 0x68, 0x11, 0xF1,
+	0x03, 0x0F, 0x35, 0xD0, 0x00, 0x69, 0x10, 0xF1, 0x03, 0x0F, 0x31, 0xD0,
+	0xB3, 0xF1, 0xFF, 0x3F,
+	0x31, 0xD0, 0x13, 0xF1, 0x02, 0x0F, 0x2E, 0xD0, 0xB2, 0xF1, 0xFF, 0x3F,
+	0x2B, 0xD0, 0x12, 0xF1,
+	0x02, 0x0F, 0x28, 0xD0, 0xB1, 0xF1, 0xFF, 0x3F, 0x25, 0xD0, 0x11, 0xF1,
+	0x02, 0x0F, 0x22, 0xD0,
+	0xB0, 0xF1, 0xFF, 0x3F, 0x1F, 0xD0, 0x10, 0xF1, 0x02, 0x0F, 0x1C, 0xD0,
+	0xDF, 0xB2, 0xD6, 0xB2,
+	0xCD, 0xB2, 0x04, 0x46, 0x2A, 0x46, 0x31, 0x46, 0x38, 0x46, 0xEE, 0xF7,
+	0xF1, 0xF8, 0x20, 0x46,
+	0xEE, 0xF7, 0xFB, 0xF8, 0xE3, 0x48, 0xEE, 0xF7, 0x64, 0xF9, 0x03, 0x28,
+	0x10, 0xD0, 0x01, 0x28,
+	0x11, 0xD0, 0x02, 0x28, 0x0F, 0xD0, 0xDF, 0x48, 0x00, 0x68, 0x01, 0x28,
+	0x10, 0xD0, 0x12, 0xE0,
+	0x00, 0x21, 0x24, 0x20, 0x01, 0xE0, 0x00, 0x21, 0x25, 0x20, 0xFF, 0xF7,
+	0xDF, 0xFB, 0xE1, 0xE7,
+	0x00, 0x21, 0x29, 0x20, 0x01, 0xE0, 0x00, 0x21, 0x2A, 0x20, 0xFF, 0xF7,
+	0xD7, 0xFB, 0x02, 0xE0,
+	0xD4, 0x48, 0xED, 0xF7, 0x7B, 0xFD, 0xD2, 0x48, 0x14, 0x30, 0xEE, 0xF7,
+	0x6C, 0xF9, 0x04, 0x46,
+	0x03, 0x28, 0x04, 0xD0, 0x01, 0x2C, 0x05, 0xD0, 0x02, 0x2C, 0x03, 0xD0,
+	0x06, 0xE0, 0x00, 0x21,
+	0x2B, 0x20, 0x01, 0xE0, 0x00, 0x21, 0x2C, 0x20, 0xFF, 0xF7, 0xC0, 0xFB,
+	0x21, 0x46, 0xBD, 0xE8,
+	0xF0, 0x41, 0xC7, 0x48, 0x14, 0x30, 0x00, 0xF0, 0x81, 0xBF, 0x7C, 0xB5,
+	0xC6, 0x4E, 0x01, 0xAA,
+	0x69, 0x46, 0x30, 0x46, 0xEE, 0xF7, 0x09, 0xFA, 0xC4, 0x4C, 0x40, 0xF2,
+	0xBC, 0x65, 0x01, 0x28,
+	0x02, 0xD0, 0x00, 0x21, 0x22, 0x20, 0x10, 0xE0, 0x00, 0x98, 0xA0, 0xF5,
+	0x80, 0x71, 0xAF, 0x39,
+	0xF7, 0xD1, 0x2A, 0x46, 0x31, 0x46, 0x20, 0x68, 0x04, 0xF0, 0x8F, 0xF9,
+	0x20, 0x68, 0xEE, 0xF7,
+	0x07, 0xFA, 0x01, 0x28, 0x08, 0xD0, 0x00, 0x21, 0x23, 0x20, 0xFF, 0xF7,
+	0x97, 0xFB, 0x29, 0x46,
+	0x20, 0x68, 0x04, 0xF0, 0x01, 0xFA, 0x7C, 0xBD, 0xB5, 0x48, 0x00, 0x68,
+	0x90, 0xF8, 0x70, 0x11,
+	0x89, 0x07, 0x07, 0xD4, 0x90, 0xF8, 0x88, 0x11, 0xC9, 0x06, 0x03, 0xD4,
+	0x90, 0xF8, 0xA0, 0x01,
+	0xC0, 0x06, 0xF0, 0xD5, 0x24, 0x68, 0x26, 0x22, 0x04, 0xF2, 0x02, 0x61,
+	0xAD, 0x48, 0x04, 0xF0,
+	0x6C, 0xF9, 0xAC, 0x48, 0x1D, 0x22, 0x04, 0xF5, 0xC5, 0x61, 0x28, 0x30,
+	0x04, 0xF0, 0x65, 0xF9,
+	0xA8, 0x48, 0x26, 0x22, 0x04, 0xF2, 0x5E, 0x61, 0x48, 0x30, 0x04, 0xF0,
+	0x5E, 0xF9, 0xA5, 0x48,
+	0x1D, 0x22, 0x04, 0xF2, 0x84, 0x61, 0x70, 0x30, 0x04, 0xF0, 0x57, 0xF9,
+	0x7C, 0xBD, 0xF8, 0xB5,
+	0x0D, 0x46, 0x06, 0x46, 0x00, 0x24, 0x6A, 0x46, 0xEE, 0xF7, 0xB7, 0xF9,
+	0x01, 0x28, 0x01, 0xD0,
+	0x01, 0x24, 0x0B, 0xE0, 0x28, 0x68, 0x31, 0x46, 0x82, 0x00, 0x9B, 0x48,
+	0x04, 0xF0, 0x8A, 0xF9,
+	0x99, 0x48, 0xEE, 0xF7, 0xBD, 0xF9, 0x01, 0x28, 0x00, 0xD0, 0x02, 0x24,
+	0x20, 0x46, 0xF8, 0xBD,
+	0x2D, 0xE9, 0xF8, 0x43, 0x94, 0x4D, 0x95, 0x4F, 0x10, 0x35, 0x41, 0xF2,
+	0xC8, 0x11, 0x94, 0x48,
+	0x04, 0xF0, 0xD4, 0xF9, 0x69, 0x46, 0x38, 0x46, 0xFF, 0xF7, 0xD9, 0xFF,
+	0x01, 0x28, 0x05, 0xD0,
+	0x02, 0x28, 0x06, 0xD0, 0xE8, 0x78, 0x01, 0x28, 0x0A, 0xD1, 0x05, 0xE0,
+	0x00, 0x21, 0xA0, 0x20,
+	0x2E, 0xE0, 0x00, 0x21, 0xA1, 0x20, 0x2B, 0xE0, 0xA8, 0x78, 0x08, 0xB9,
+	0x28, 0x88, 0x10, 0xB1,
+	0x00, 0x21, 0xA2, 0x20, 0x24, 0xE0, 0x82, 0x4E, 0xE9, 0x88, 0x30, 0x68,
+	0x82, 0x8A, 0x91, 0x42,
+	0x02, 0xD0, 0x00, 0x21, 0xA3, 0x20, 0x1B, 0xE0, 0xA9, 0x88, 0xC0, 0x8A,
+	0x81, 0x42, 0x02, 0xD0,
+	0x00, 0x21, 0xA4, 0x20, 0x14, 0xE0, 0x00, 0x24, 0x00, 0x98, 0x69, 0x46,
+	0x07, 0xEB, 0x80, 0x07,
+	0x38, 0x46, 0xFF, 0xF7, 0xAC, 0xFF, 0x78, 0xB1, 0x01, 0x28, 0x03, 0xD0,
+	0x00, 0x21, 0xA6, 0x20,
+	0xFF, 0xF7, 0x0C, 0xFB, 0xE0, 0x07, 0x35, 0xD0, 0xA0, 0x07, 0x35, 0xD4,
+	0x11, 0x21, 0xA7, 0x20,
+	0xFF, 0xF7, 0x04, 0xFB, 0xBD, 0xE8, 0xF8, 0x83, 0x95, 0xF8, 0x01, 0x80,
+	0x29, 0x46, 0x40, 0x46,
+	0x00, 0xF0, 0xDE, 0xFD, 0xA0, 0xB1, 0xB8, 0xF1, 0x10, 0x0F, 0x14, 0xD0,
+	0xB8, 0xF1, 0x11, 0x0F,
+	0x14, 0xD0, 0xB8, 0xF1, 0x12, 0x0F, 0x14, 0xD0, 0xB8, 0xF1, 0x13, 0x0F,
+	0x14, 0xD0, 0xB8, 0xF1,
+	0x14, 0x0F, 0x14, 0xD0, 0xB8, 0xF1, 0x17, 0x0F, 0xCE, 0xD1, 0x44, 0xF0,
+	0x20, 0x04, 0xCB, 0xE7,
+	0x41, 0x46, 0xA8, 0x20, 0xD4, 0xE7, 0x44, 0xF0, 0x01, 0x04, 0xC5, 0xE7,
+	0x44, 0xF0, 0x02, 0x04,
+	0xC2, 0xE7, 0x44, 0xF0, 0x08, 0x04, 0xBF, 0xE7, 0x44, 0xF0, 0x10, 0x04,
+	0xBC, 0xE7, 0x44, 0xF0,
+	0x04, 0x04, 0xB9, 0xE7, 0x10, 0x21, 0xCA, 0xE7, 0x20, 0x07, 0x0A, 0xD4,
+	0x30, 0x68, 0x90, 0xF8,
+	0x50, 0x12, 0xC9, 0x07, 0x03, 0xD1, 0x90, 0xF8, 0x80, 0x02, 0xC0, 0x07,
+	0x01, 0xD0, 0x12, 0x21,
+	0xBD, 0xE7, 0xE0, 0x06, 0x01, 0xD4, 0x13, 0x21, 0xB9, 0xE7, 0x60, 0x07,
+	0x05, 0xD4, 0x30, 0x68,
+	0x90, 0xF8, 0x61, 0x04, 0x08, 0xB1, 0x14, 0x21, 0xB1, 0xE7, 0xA0, 0x06,
+	0xB2, 0xD4, 0x30, 0x68,
+	0x90, 0xF8, 0x2F, 0x0A, 0xC0, 0x07, 0xAD, 0xD0, 0x17, 0x21, 0xA8, 0xE7,
+	0x10, 0xB5, 0x8E, 0xB0,
+	0xED, 0xF7, 0x66, 0xF9, 0x00, 0x20, 0x01, 0x22, 0x41, 0xB2, 0x01, 0xF0,
+	0x1F, 0x03, 0x02, 0xFA,
+	0x03, 0xF3, 0x49, 0x09, 0x89, 0x00, 0x01, 0xF1, 0xE0, 0x21, 0xC1, 0xF8,
+	0x80, 0x31, 0x40, 0x1C,
+	0x1F, 0x28, 0xF1, 0xDB, 0xED, 0xF7, 0x52, 0xF9, 0xED, 0xF7, 0x5C, 0xFF,
+	0xEE, 0xF7, 0x26, 0xF9,
+	0x07, 0x21, 0x0A, 0x20, 0xFF, 0xF7, 0x46, 0xFE, 0x07, 0x21, 0x0B, 0x20,
+	0xFF, 0xF7, 0x42, 0xFE,
+	0xFE, 0xF7, 0xFE, 0xFF, 0xFE, 0xF7, 0xAA, 0xFE, 0x04, 0xA8, 0xFF, 0xF7,
+	0xEC, 0xF9, 0x0A, 0xA9,
+	0x07, 0xA8, 0xFF, 0xF7, 0x89, 0xF8, 0x04, 0xA8, 0x00, 0x90, 0x07, 0xA8,
+	0x02, 0x90, 0x0A, 0xA8,
+	0x03, 0x90, 0x68, 0x46, 0xEE, 0xF7, 0x26, 0xFA, 0x02, 0x21, 0x00, 0x20,
+	0xFF, 0xF7, 0x2A, 0xFE,
+	0xFF, 0xF7, 0x04, 0xF8, 0xFF, 0xF7, 0x20, 0xFA, 0xFF, 0xF7, 0x40, 0xFE,
+	0xED, 0xF7, 0x60, 0xFF,
+	0x28, 0x4C, 0x01, 0xAA, 0x69, 0x46, 0x20, 0x46, 0xEE, 0xF7, 0xBF, 0xF8,
+	0x01, 0x28, 0x02, 0xD0,
+	0x00, 0x21, 0x20, 0x20, 0x11, 0xE0, 0x00, 0x98, 0xB0, 0xF5, 0x25, 0x7F,
+	0xF8, 0xD1, 0x21, 0x46,
+	0x1B, 0x4C, 0x4F, 0xF4, 0x25, 0x62, 0x20, 0x68, 0x04, 0xF0, 0x47, 0xF8,
+	0x20, 0x68, 0xEE, 0xF7,
+	0xBF, 0xF8, 0x01, 0x28, 0x03, 0xD0, 0x00, 0x21, 0x21, 0x20, 0xFF, 0xF7,
+	0x02, 0xFA, 0xFF, 0xF7,
+	0x94, 0xFE, 0xFF, 0xF7, 0xFD, 0xFE, 0x00, 0xF0, 0x07, 0xF8, 0x00, 0xF0,
+	0x55, 0xF8, 0x0E, 0xB0,
+	0xBD, 0xE8, 0x10, 0x40, 0x00, 0xF0, 0x86, 0xB8, 0x10, 0xB5, 0xEE, 0xF7,
+	0xBF, 0xFA, 0x0B, 0x48,
+	0x00, 0x68, 0x01, 0x7C, 0xA5, 0x29, 0x1F, 0xD0, 0x4F, 0xF4, 0xFA, 0x40,
+	0xEE, 0xF7, 0x61, 0xFC,
+	0x00, 0x21, 0x28, 0x20, 0xFF, 0xF7, 0x32, 0xFA, 0x19, 0xE0, 0x00, 0x00,
+	0x00, 0x90, 0xD0, 0x03,
+	0x84, 0x7B, 0x10, 0x00, 0xE8, 0x84, 0x10, 0x00, 0xF0, 0x9F, 0x01, 0x00,
+	0x50, 0x07, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0xE4, 0x9F, 0x01, 0x20, 0xD4, 0x56, 0x10, 0x00,
+	0xF0, 0xAF, 0x01, 0x00,
+	0x78, 0x8B, 0x01, 0x20, 0xF0, 0xEF, 0x01, 0x00, 0x40, 0x69, 0xEE, 0xF7,
+	0x42, 0xFC, 0x04, 0x21,
+	0x02, 0x20, 0xFF, 0xF7, 0xC7, 0xFD, 0x04, 0x21, 0x03, 0x20, 0xFF, 0xF7,
+	0xC3, 0xFD, 0x04, 0x21,
+	0x08, 0x46, 0xFF, 0xF7, 0xBF, 0xFD, 0x04, 0x21, 0x05, 0x20, 0xFF, 0xF7,
+	0xBB, 0xFD, 0x04, 0x21,
+	0x06, 0x20, 0xFF, 0xF7, 0xB7, 0xFD, 0x04, 0x21, 0x07, 0x20, 0xFF, 0xF7,
+	0xB3, 0xFD, 0x04, 0x21,
+	0x08, 0x20, 0xFF, 0xF7, 0xAF, 0xFD, 0x01, 0x21, 0x09, 0x20, 0xFF, 0xF7,
+	0xAB, 0xFD, 0x04, 0x21,
+	0xBD, 0xE8, 0x10, 0x40, 0x0F, 0x20, 0xA5, 0xE5, 0x38, 0xB5, 0x03, 0xF0,
+	0xFB, 0xFB, 0x03, 0x21,
+	0x01, 0x20, 0xFF, 0xF7, 0x9F, 0xFD, 0x28, 0x4C, 0x20, 0x68, 0x90, 0xF8,
+	0xB0, 0x10, 0xC9, 0x07,
+	0x27, 0xD0, 0x00, 0x25, 0x00, 0x95, 0x90, 0xF8, 0xC0, 0x00, 0x2B, 0x46,
+	0xC0, 0xF3, 0x02, 0x10,
+	0x01, 0x22, 0x29, 0x46, 0xEE, 0xF7, 0x87, 0xF8, 0x20, 0x68, 0x0A, 0x21,
+	0x90, 0xF8, 0xC0, 0x00,
+	0xC0, 0xF3, 0x02, 0x10, 0xEE, 0xF7, 0xA7, 0xF8, 0x00, 0x95, 0x20, 0x68,
+	0x00, 0x23, 0x01, 0x22,
+	0x90, 0xF8, 0xC0, 0x00, 0x19, 0x46, 0x00, 0xF0, 0x07, 0x00, 0xEE, 0xF7,
+	0x74, 0xF8, 0x20, 0x68,
+	0x01, 0x21, 0x90, 0xF8, 0xC0, 0x00, 0xBD, 0xE8, 0x38, 0x40, 0x00, 0xF0,
+	0x07, 0x00, 0xEE, 0xF7,
+	0x92, 0xB8, 0x38, 0xBD, 0x38, 0xB5, 0x10, 0x4C, 0x20, 0x68, 0x90, 0xF8,
+	0x60, 0x03, 0xC1, 0x07,
+	0x0F, 0xD0, 0x81, 0x07, 0x0D, 0xD5, 0x00, 0x21, 0x01, 0x23, 0x40, 0x09,
+	0x1A, 0x46, 0x00, 0x91,
+	0xEE, 0xF7, 0x59, 0xF8, 0x20, 0x68, 0x00, 0x21, 0x90, 0xF8, 0x60, 0x03,
+	0x40, 0x09, 0xEE, 0xF7,
+	0x7A, 0xF8, 0x20, 0x68, 0x90, 0xF8, 0x79, 0x00, 0xBD, 0xE8, 0x38, 0x40,
+	0x00, 0xF0, 0x03, 0x01,
+	0xC0, 0x09, 0xED, 0xF7, 0xA5, 0xBE, 0x00, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x88, 0x42, 0x00, 0xD3,
+	0x08, 0x46, 0x90, 0x42, 0x00, 0xD3, 0x10, 0x46, 0x70, 0x47, 0x88, 0x42,
+	0x00, 0xD8, 0x08, 0x46,
+	0x90, 0x42, 0x00, 0xD8, 0x10, 0x46, 0x70, 0x47, 0x88, 0x42, 0x00, 0xD3,
+	0x08, 0x46, 0x70, 0x47,
+	0x88, 0x42, 0x00, 0xD8, 0x08, 0x46, 0x70, 0x47, 0x02, 0x46, 0x00, 0x20,
+	0x4F, 0xF0, 0x80, 0x41,
+	0x00, 0xE0, 0x89, 0x08, 0x91, 0x42, 0xFC, 0xD8, 0x07, 0xE0, 0x43, 0x18,
+	0x93, 0x42, 0x02, 0xD8,
+	0xD2, 0x1A, 0x00, 0xEB, 0x41, 0x00, 0x40, 0x08, 0x89, 0x08, 0x00, 0x29,
+	0xF5, 0xD1, 0x82, 0x42,
+	0x00, 0xD9, 0x40, 0x1C, 0x70, 0x47, 0x10, 0xB5, 0x5A, 0x43, 0x02, 0x9C,
+	0x06, 0xE0, 0x00, 0xBF,
+	0x50, 0xF8, 0x22, 0x30, 0x93, 0xFB, 0xF4, 0xF3, 0x41, 0xF8, 0x22, 0x30,
+	0x52, 0x1E, 0xF7, 0xD2,
+	0x10, 0xBD, 0x10, 0xB5, 0x5A, 0x43, 0x02, 0x9C, 0x05, 0xE0, 0x00, 0xBF,
+	0x50, 0xF8, 0x22, 0x30,
+	0x63, 0x43, 0x41, 0xF8, 0x22, 0x30, 0x52, 0x1E, 0xF8, 0xD2, 0x10, 0xBD,
+	0x30, 0xB5, 0x03, 0x9C,
+	0x63, 0x43, 0x06, 0xE0, 0x50, 0xF8, 0x23, 0x40, 0x51, 0xF8, 0x23, 0x50,
+	0x2C, 0x44, 0x42, 0xF8,
+	0x23, 0x40, 0x5B, 0x1E, 0xF6, 0xD2, 0x30, 0xBD, 0x30, 0xB5, 0x03, 0x9C,
+	0x63, 0x43, 0x06, 0xE0,
+	0x50, 0xF8, 0x23, 0x40, 0x51, 0xF8, 0x23, 0x50, 0x64, 0x1B, 0x42, 0xF8,
+	0x23, 0x40, 0x5B, 0x1E,
+	0xF6, 0xD2, 0x30, 0xBD, 0x2D, 0xE9, 0xF0, 0x4F, 0x83, 0x46, 0xDD, 0xE9,
+	0x09, 0x06, 0xDD, 0xF8,
+	0x34, 0xE0, 0x8A, 0x46, 0x82, 0x42, 0x26, 0xD1, 0x00, 0x20, 0x22, 0xE0,
+	0x00, 0xFB, 0x02, 0xF1,
+	0x0B, 0xEB, 0x81, 0x09, 0x0B, 0x9D, 0x00, 0xFB, 0x0E, 0xF1, 0x00, 0x24,
+	0x05, 0xEB, 0x81, 0x05,
+	0x14, 0xE0, 0x00, 0x21, 0x0F, 0xE0, 0x00, 0xBF, 0x01, 0xFB, 0x06, 0xF8,
+	0x03, 0xEB, 0x88, 0x08,
+	0x59, 0xF8, 0x21, 0xC0, 0x55, 0xF8, 0x24, 0x70, 0x58, 0xF8, 0x24, 0x80,
+	0x49, 0x1C, 0x0C, 0xFB,
+	0x08, 0x77, 0x45, 0xF8, 0x24, 0x70, 0x91, 0x42, 0xEE, 0xDB, 0x64, 0x1C,
+	0xB4, 0x42, 0xE8, 0xDB,
+	0x40, 0x1C, 0x50, 0x45, 0xDA, 0xDB, 0xBD, 0xE8, 0xF0, 0x8F, 0x10, 0xB5,
+	0x00, 0x23, 0x1C, 0x46,
+	0x42, 0xB1, 0x02, 0x78, 0x52, 0x1C, 0xD2, 0xB2, 0x02, 0x70, 0x8A, 0x42,
+	0x03, 0xD9, 0x04, 0x70,
+	0x01, 0x23, 0x00, 0xE0, 0x04, 0x70, 0x18, 0x46, 0x10, 0xBD, 0x30, 0xB5,
+	0x00, 0x24, 0x01, 0x23,
+	0x05, 0xE0, 0x0C, 0x44, 0xE4, 0x1C, 0x04, 0xF0, 0x03, 0x05, 0x64, 0x1B,
+	0x5B, 0x1C, 0x93, 0x42,
+	0xF7, 0xDD, 0x00, 0xEB, 0x44, 0x00, 0x30, 0xBD, 0x88, 0x42, 0x01, 0xDD,
+	0x08, 0x46, 0x70, 0x47,
+	0x00, 0x28, 0xFC, 0xDA, 0x00, 0x20, 0x70, 0x47, 0x10, 0xB5, 0x04, 0xE0,
+	0x00, 0xEB, 0x82, 0x03,
+	0x53, 0xF8, 0x04, 0x4C, 0x1C, 0x60, 0x52, 0x1E, 0xF8, 0xD1, 0x09, 0x68,
+	0x01, 0x60, 0x10, 0xBD,
+	0x10, 0xB5, 0x03, 0xE0, 0x00, 0xEB, 0x82, 0x03, 0x0C, 0x68, 0x1C, 0x60,
+	0x52, 0x1E, 0xF9, 0xD2,
+	0x10, 0xBD, 0x30, 0xB5, 0x06, 0xE0, 0x00, 0xBF, 0x00, 0xEB, 0xC2, 0x03,
+	0x73, 0xE9, 0x02, 0x45,
+	0xC3, 0xE9, 0x02, 0x45, 0x52, 0x1E, 0xF7, 0xD1, 0xD1, 0xE9, 0x00, 0x21,
+	0xC0, 0xE9, 0x00, 0x21,
+	0x30, 0xBD, 0x10, 0xB5, 0x53, 0x88, 0x4C, 0x88, 0x1B, 0x1B, 0x43, 0x80,
+	0x12, 0x88, 0x09, 0x88,
+	0x51, 0x1A, 0x01, 0x80, 0x10, 0xBD, 0x08, 0xB5, 0x0A, 0x46, 0x01, 0x46,
+	0x68, 0x46, 0xFF, 0xF7,
+	0xF0, 0xFF, 0xBD, 0xF9, 0x00, 0x10, 0xBD, 0xF9, 0x02, 0x00, 0x49, 0x43,
+	0x00, 0xFB, 0x00, 0x10,
+	0x08, 0xBD, 0x10, 0xB5, 0x88, 0x42, 0x02, 0x9C, 0x01, 0xDC, 0x20, 0x46,
+	0x10, 0xBD, 0x90, 0x42,
+	0x01, 0xDB, 0x18, 0x46, 0x10, 0xBD, 0x8A, 0x42, 0x00, 0xD1, 0x52, 0x1C,
+	0x40, 0x1A, 0xE3, 0x1A,
+	0x58, 0x43, 0x51, 0x1A, 0x90, 0xFB, 0xF1, 0xF0, 0x20, 0x1A, 0x10, 0xBD,
+	0x10, 0xB5, 0x00, 0x2A,
+	0x03, 0xD0, 0x43, 0x1A, 0x93, 0x42, 0x01, 0xDD, 0x88, 0x18, 0x10, 0xBD,
+	0x54, 0x42, 0xA3, 0x42,
+	0xFB, 0xDA, 0x88, 0x1A, 0x10, 0xBD, 0x91, 0x42, 0x01, 0xD1, 0x00, 0xB2,
+	0x70, 0x47, 0x50, 0x43,
+	0xB0, 0xFB, 0xF1, 0xF0, 0x00, 0xB2, 0x90, 0x42, 0xF7, 0xD9, 0x10, 0x46,
+	0xF5, 0xE7, 0x70, 0xB5,
+	0x0B, 0x00, 0x02, 0x46, 0x3D, 0xD0, 0x1F, 0x4C, 0x20, 0x68, 0x46, 0x8E,
+	0x85, 0x8E, 0xB2, 0xF9,
+	0x02, 0x00, 0x31, 0xB2, 0xFF, 0xF7, 0x80, 0xFF, 0x58, 0x80, 0xB2, 0xF9,
+	0x00, 0x00, 0x29, 0xB2,
+	0xFF, 0xF7, 0x7A, 0xFF, 0x18, 0x80, 0x21, 0x68, 0x91, 0xF8, 0x36, 0x10,
+	0x49, 0x07, 0x02, 0xD5,
+	0x59, 0x88, 0x71, 0x1A, 0x59, 0x80, 0x21, 0x68, 0x91, 0xF8, 0x36, 0x10,
+	0x89, 0x07, 0x01, 0xD5,
+	0x28, 0x1A, 0x18, 0x80, 0x20, 0x68, 0x90, 0xF8, 0x36, 0x10, 0x09, 0x07,
+	0x10, 0xD5, 0xB0, 0xF8,
+	0x37, 0x20, 0xB3, 0xF9, 0x02, 0x00, 0x31, 0x46, 0xFF, 0xF7, 0xC5, 0xFF,
+	0x58, 0x80, 0x20, 0x68,
+	0x29, 0x46, 0xB0, 0xF8, 0x39, 0x20, 0xB3, 0xF9, 0x00, 0x00, 0xFF, 0xF7,
+	0xBC, 0xFF, 0x18, 0x80,
+	0x20, 0x68, 0x90, 0xF8, 0x36, 0x00, 0xC0, 0x07, 0x03, 0xD0, 0x58, 0x88,
+	0x19, 0x88, 0x59, 0x80,
+	0x18, 0x80, 0x70, 0xBD, 0x4C, 0x07, 0x10, 0x00, 0x31, 0xB5, 0xED, 0xF7,
+	0xE1, 0xF9, 0x04, 0x00,
+	0x08, 0xD4, 0xDD, 0xF8, 0x00, 0x00, 0x01, 0x22, 0x02, 0xFA, 0x04, 0xF1,
+	0x01, 0x42, 0x01, 0xD1,
+	0x64, 0x1E, 0xF9, 0xD5, 0x04, 0x21, 0x68, 0x46, 0xED, 0xF7, 0x5D, 0xFE,
+	0xFE, 0x49, 0xC0, 0xB2,
+	0x09, 0x68, 0x91, 0xF8, 0xE7, 0x10, 0xC1, 0xF3, 0x41, 0x11, 0x02, 0x29,
+	0x0E, 0xD3, 0x10, 0xF0,
+	0x03, 0x00, 0x05, 0xD0, 0x01, 0x28, 0x05, 0xD0, 0x02, 0x28, 0x05, 0xD0,
+	0x1F, 0x20, 0x0A, 0xE0,
+	0x0F, 0x20, 0x08, 0xE0, 0x7F, 0x20, 0x06, 0xE0, 0x3F, 0x20, 0x04, 0xE0,
+	0xC0, 0x07, 0x01, 0xD0,
+	0x07, 0x20, 0x00, 0xE0, 0x03, 0x20, 0x64, 0x1C, 0x00, 0x99, 0xA0, 0x40,
+	0x08, 0x43, 0x38, 0xBD,
+	0x10, 0xB5, 0xEE, 0x4C, 0x50, 0x28, 0x13, 0xD0, 0x09, 0xDC, 0xA0, 0xF1,
+	0x10, 0x00, 0x08, 0x28,
+	0x40, 0xD2, 0xDF, 0xE8, 0x00, 0xF0, 0x0D, 0x20, 0x20, 0x20, 0x26, 0x3F,
+	0x3F, 0x39, 0x51, 0x38,
+	0x07, 0x28, 0x37, 0xD2, 0xDF, 0xE8, 0x00, 0xF0, 0x17, 0x17, 0x17, 0x1D,
+	0x36, 0x36, 0x30, 0x00,
+	0x03, 0xF0, 0x8D, 0xFA, 0x20, 0x60, 0x03, 0xF0, 0x8C, 0xFA, 0xC4, 0xE9,
+	0x04, 0x01, 0xDE, 0x48,
+	0x00, 0x68, 0x90, 0xF8, 0xE7, 0x00, 0x10, 0xF0, 0x60, 0x0F, 0x11, 0xD0,
+	0x20, 0x68, 0xFF, 0xF7,
+	0xA3, 0xFF, 0x20, 0x60, 0x0C, 0xE0, 0x03, 0xF0, 0x7A, 0xFA, 0x20, 0x60,
+	0x03, 0xF0, 0x79, 0xFA,
+	0x04, 0xE0, 0x03, 0xF0, 0x78, 0xFA, 0x20, 0x60, 0x03, 0xF0, 0x77, 0xFA,
+	0xC4, 0xE9, 0x04, 0x01,
+	0x04, 0x21, 0xD2, 0x48, 0xED, 0xF7, 0xFF, 0xFD, 0x60, 0x60, 0xD0, 0x48,
+	0x08, 0x21, 0x10, 0x30,
+	0xED, 0xF7, 0xF9, 0xFD, 0xA0, 0x60, 0x10, 0xBD, 0x03, 0xF0, 0x69, 0xFA,
+	0x20, 0x60, 0x03, 0xF0,
+	0x68, 0xFA, 0xEB, 0xE7, 0x00, 0x20, 0x01, 0x46, 0x20, 0x60, 0xE7, 0xE7,
+	0x2D, 0xE9, 0xFF, 0x5F,
+	0x04, 0x21, 0xDD, 0xE9, 0x0F, 0xAB, 0x68, 0x46, 0xED, 0xF7, 0xE5, 0xFD,
+	0x81, 0x46, 0x08, 0x21,
+	0x02, 0xA8, 0xED, 0xF7, 0xE0, 0xFD, 0x07, 0x46, 0x00, 0x24, 0x20, 0x46,
+	0x35, 0xE0, 0x01, 0x20,
+	0x00, 0x99, 0x00, 0xFA, 0x08, 0xF0, 0x08, 0x42, 0x2D, 0xD0, 0x00, 0x25,
+	0x2E, 0x46, 0x27, 0xE0,
+	0x32, 0x46, 0x01, 0x20, 0x00, 0x21, 0x03, 0xF0, 0x41, 0xFD, 0xDD, 0xE9,
+	0x02, 0x23, 0x10, 0x40,
+	0x19, 0x40, 0x08, 0x43, 0x1B, 0xD0, 0x11, 0x98, 0x60, 0xB1, 0x04, 0xFB,
+	0x07, 0xF0, 0x0A, 0xEB,
+	0x05, 0x01, 0x41, 0x56, 0x32, 0x46, 0x01, 0xEB, 0x0B, 0x03, 0x21, 0x46,
+	0x0E, 0x98, 0xED, 0xF7,
+	0xBC, 0xF9, 0x0B, 0xE0, 0x32, 0x46, 0x21, 0x46, 0x0E, 0x98, 0xED, 0xF7,
+	0xAB, 0xF9, 0x04, 0xFB,
+	0x07, 0xF1, 0x0A, 0xEB, 0x05, 0x02, 0xA0, 0xEB, 0x0B, 0x00, 0x88, 0x54,
+	0x6D, 0x1C, 0x76, 0x1C,
+	0xBD, 0x42, 0xD5, 0xDB, 0x64, 0x1C, 0x08, 0xF1, 0x01, 0x00, 0x80, 0x46,
+	0x4C, 0x45, 0xC6, 0xDB,
+	0xBD, 0xE8, 0xFF, 0x9F, 0x2D, 0xE9, 0xFF, 0x5F, 0x84, 0xB0, 0x04, 0x21,
+	0xDD, 0xE9, 0x12, 0xAB,
+	0x04, 0xA8, 0xED, 0xF7, 0x98, 0xFD, 0x81, 0x46, 0x08, 0x21, 0x06, 0xA8,
+	0xED, 0xF7, 0x93, 0xFD,
+	0x07, 0x46, 0x00, 0x25, 0x0A, 0xF1, 0x48, 0x00, 0x02, 0x90, 0x20, 0x30,
+	0x01, 0x90, 0x48, 0x38,
+	0x2C, 0x46, 0xA8, 0x46, 0x2E, 0x46, 0x00, 0x90, 0x31, 0xE0, 0x01, 0x20,
+	0x04, 0x99, 0x00, 0xFA,
+	0x08, 0xF0, 0x08, 0x42, 0x27, 0xD0, 0x16, 0x98, 0x90, 0xB1, 0x1B, 0xF8,
+	0x05, 0x10, 0x14, 0x98,
+	0x08, 0x44, 0xC2, 0xB2, 0x41, 0x46, 0x02, 0x98, 0xED, 0xF7, 0xDF, 0xF9,
+	0x05, 0xEB, 0x09, 0x00,
+	0xC1, 0x19, 0x1B, 0xF9, 0x01, 0x20, 0x41, 0x46, 0x50, 0x46, 0xED, 0xF7,
+	0xAD, 0xF9, 0x10, 0xE0,
+	0x41, 0x46, 0x02, 0x98, 0xED, 0xF7, 0xCF, 0xF9, 0x14, 0x99, 0x40, 0x1A,
+	0x0B, 0xF8, 0x05, 0x00,
+	0x41, 0x46, 0x50, 0x46, 0xED, 0xF7, 0x99, 0xF9, 0x05, 0xEB, 0x09, 0x01,
+	0xCA, 0x19, 0x0B, 0xF8,
+	0x02, 0x00, 0x6D, 0x1C, 0xED, 0xB2, 0x08, 0xF1, 0x01, 0x00, 0x00, 0xF0,
+	0xFF, 0x08, 0x4D, 0x45,
+	0xCB, 0xDB, 0x38, 0xE0, 0x32, 0x46, 0x01, 0x20, 0x00, 0x21, 0x03, 0xF0,
+	0xBF, 0xFC, 0xDD, 0xE9,
+	0x06, 0x23, 0x10, 0x40, 0x19, 0x40, 0x08, 0x43, 0x2B, 0xD0, 0x16, 0x98,
+	0xA0, 0xB1, 0x04, 0xEB,
+	0x09, 0x01, 0x15, 0x98, 0x1B, 0xF8, 0x01, 0x10, 0x08, 0x44, 0xC2, 0xB2,
+	0x31, 0x46, 0x01, 0x98,
+	0xED, 0xF7, 0xA3, 0xF9, 0x04, 0xEB, 0x49, 0x00, 0xC1, 0x19, 0x1B, 0xF9,
+	0x01, 0x20, 0x31, 0x46,
+	0x00, 0x98, 0xED, 0xF7, 0x71, 0xF9, 0x12, 0xE0, 0x31, 0x46, 0x01, 0x98,
+	0xED, 0xF7, 0x93, 0xF9,
+	0x15, 0x99, 0x04, 0xEB, 0x09, 0x02, 0x40, 0x1A, 0x0B, 0xF8, 0x02, 0x00,
+	0x31, 0x46, 0x00, 0x98,
+	0xED, 0xF7, 0x5B, 0xF9, 0x04, 0xEB, 0x49, 0x01, 0xCA, 0x19, 0x0B, 0xF8,
+	0x02, 0x00, 0x64, 0x1C,
+	0xE4, 0xB2, 0x76, 0x1C, 0xF6, 0xB2, 0xBC, 0x42, 0xC4, 0xDB, 0x08, 0xB0,
+	0xBD, 0xE8, 0xF0, 0x9F,
+	0x2D, 0xE9, 0xFF, 0x5F, 0x04, 0x21, 0xDD, 0xE9, 0x0E, 0xBA, 0x68, 0x46,
+	0xED, 0xF7, 0x0B, 0xFD,
+	0x81, 0x46, 0x08, 0x21, 0x02, 0xA8, 0xED, 0xF7, 0x06, 0xFD, 0x07, 0x46,
+	0x00, 0x24, 0x20, 0x46,
+	0x24, 0xE0, 0x01, 0x20, 0x00, 0x99, 0x00, 0xFA, 0x08, 0xF0, 0x08, 0x42,
+	0x1C, 0xD0, 0x00, 0x25,
+	0x2E, 0x46, 0x16, 0xE0, 0x32, 0x46, 0x01, 0x20, 0x00, 0x21, 0x03, 0xF0,
+	0x67, 0xFC, 0xDD, 0xE9,
+	0x02, 0x23, 0x10, 0x40, 0x19, 0x40, 0x08, 0x43, 0x0A, 0xD0, 0x32, 0x46,
+	0x21, 0x46, 0x58, 0x46,
+	0xED, 0xF7, 0xE0, 0xF8, 0x04, 0xFB, 0x07, 0x52, 0x80, 0x00, 0x2A, 0xF8,
+	0x12, 0x00, 0x6D, 0x1C,
+	0x76, 0x1C, 0xBD, 0x42, 0xE6, 0xDB, 0x64, 0x1C, 0x08, 0xF1, 0x01, 0x00,
+	0x80, 0x46, 0x4C, 0x45,
+	0xD7, 0xDB, 0x35, 0xE7, 0x2D, 0xE9, 0xFF, 0x5F, 0x04, 0x21, 0xDD, 0xE9,
+	0x0E, 0x9B, 0x68, 0x46,
+	0xED, 0xF7, 0xD1, 0xFC, 0x82, 0x46, 0x08, 0x21, 0x02, 0xA8, 0xED, 0xF7,
+	0xCC, 0xFC, 0x00, 0x25,
+	0x80, 0x46, 0x2C, 0x46, 0x2F, 0x46, 0x2E, 0x46, 0x36, 0xE0, 0x01, 0x20,
+	0x00, 0x99, 0xB8, 0x40,
+	0x08, 0x42, 0x2F, 0xD0, 0x39, 0x46, 0x09, 0xF1, 0x48, 0x00, 0xED, 0xF7,
+	0x24, 0xF9, 0x2E, 0x49,
+	0x99, 0xF8, 0x92, 0x30, 0x09, 0x68, 0x91, 0xF8, 0x43, 0xC1, 0x91, 0xF8,
+	0x42, 0x11, 0x0C, 0xF0,
+	0x0F, 0x02, 0x52, 0x1C, 0x53, 0x43, 0x01, 0x22, 0x02, 0xEB, 0x1C, 0x1C,
+	0x00, 0xFB, 0x0C, 0x33,
+	0x99, 0xF8, 0x90, 0x00, 0x02, 0xEB, 0x11, 0x11, 0x00, 0xFB, 0x01, 0x30,
+	0x10, 0x99, 0x19, 0xB9,
+	0x4F, 0xF6, 0xFF, 0x71, 0x01, 0xEA, 0x80, 0x00, 0x2B, 0xF8, 0x15, 0x00,
+	0x39, 0x46, 0x48, 0x46,
+	0xED, 0xF7, 0xD3, 0xF8, 0x05, 0xEB, 0x0A, 0x02, 0x80, 0x00, 0x42, 0x44,
+	0x6D, 0x1C, 0x2B, 0xF8,
+	0x12, 0x00, 0xED, 0xB2, 0x7F, 0x1C, 0xFF, 0xB2, 0x55, 0x45, 0xC6, 0xDB,
+	0x45, 0xE0, 0x32, 0x46,
+	0x01, 0x20, 0x00, 0x21, 0x03, 0xF0, 0xFA, 0xFB, 0xDD, 0xE9, 0x02, 0x23,
+	0x10, 0x40, 0x19, 0x40,
+	0x08, 0x43, 0x38, 0xD0, 0x31, 0x46, 0x09, 0xF1, 0x68, 0x00, 0xED, 0xF7,
+	0xE4, 0xF8, 0x0E, 0x49,
+	0x99, 0xF8, 0x93, 0x50, 0x09, 0x68, 0x91, 0xF8, 0x48, 0x21, 0x91, 0xF8,
+	0x47, 0x11, 0x02, 0xF0,
+	0x0F, 0x03, 0x5B, 0x1C, 0x5D, 0x43, 0x01, 0x23, 0x03, 0xEB, 0x12, 0x12,
+	0x00, 0xFB, 0x02, 0x52,
+	0x99, 0xF8, 0x91, 0x00, 0x03, 0xEB, 0x11, 0x11, 0x00, 0xFB, 0x01, 0x20,
+	0x10, 0x99, 0x49, 0xB9,
+	0x4F, 0xF6, 0xFF, 0x71, 0x04, 0xE0, 0x00, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0xB0, 0x07, 0x10, 0x00,
+	0x01, 0xEA, 0x80, 0x00, 0x04, 0xEB, 0x0A, 0x02, 0x31, 0x46, 0x2B, 0xF8,
+	0x12, 0x00, 0x09, 0xF1,
+	0x20, 0x00, 0xED, 0xF7, 0x8A, 0xF8, 0x04, 0xEB, 0x4A, 0x02, 0x80, 0x00,
+	0x42, 0x44, 0x64, 0x1C,
+	0x2B, 0xF8, 0x12, 0x00, 0xE4, 0xB2, 0x76, 0x1C, 0xF6, 0xB2, 0x44, 0x45,
+	0xB7, 0xDB, 0x9F, 0xE6,
+	0x2D, 0xE9, 0xF0, 0x43, 0x89, 0x46, 0x00, 0x27, 0x85, 0xB0, 0x90, 0x46,
+	0x04, 0x46, 0x3E, 0x46,
+	0xFC, 0x21, 0x03, 0xF0, 0x61, 0xFC, 0xFE, 0x4D, 0xB8, 0xF1, 0x01, 0x0F,
+	0x28, 0x79, 0x20, 0x71,
+	0x28, 0x7A, 0x60, 0x71, 0xFB, 0x48, 0x90, 0xF8, 0x52, 0x1E, 0xA1, 0x71,
+	0x90, 0xF8, 0x53, 0x1E,
+	0xE1, 0x71, 0x90, 0xF8, 0x54, 0x1E, 0xA1, 0x72, 0x90, 0xF8, 0x55, 0x1E,
+	0xE1, 0x72, 0x90, 0xF8,
+	0x50, 0x1E, 0x21, 0x73, 0x90, 0xF8, 0x51, 0x0E, 0x60, 0x73, 0x08, 0xD1,
+	0xF2, 0x48, 0x00, 0x68,
+	0x81, 0x7F, 0xA5, 0x29, 0x03, 0xD1, 0x90, 0xF9, 0x1F, 0x70, 0x90, 0xF9,
+	0x20, 0x60, 0x04, 0xF1,
+	0x10, 0x00, 0xCD, 0xE9, 0x01, 0x07, 0xED, 0x48, 0x00, 0x21, 0x00, 0x90,
+	0xCD, 0xE9, 0x03, 0x61,
+	0xD5, 0xE9, 0x04, 0x23, 0x28, 0x68, 0xFF, 0xF7, 0x65, 0xFE, 0xA5, 0x20,
+	0x20, 0x70, 0x12, 0x20,
+	0x60, 0x70, 0xA4, 0xF8, 0x02, 0x90, 0xD5, 0xE9, 0x01, 0x01, 0x08, 0x44,
+	0x13, 0x30, 0x80, 0x08,
+	0x05, 0xB0, 0xBD, 0xE8, 0xF0, 0x83, 0x2D, 0xE9, 0xF0, 0x43, 0x89, 0x46,
+	0x00, 0x27, 0x85, 0xB0,
+	0x90, 0x46, 0x04, 0x46, 0x3E, 0x46, 0xFC, 0x21, 0x03, 0xF0, 0x16, 0xFC,
+	0xD8, 0x4D, 0xB8, 0xF1,
+	0x01, 0x0F, 0x28, 0x79, 0x20, 0x71, 0x28, 0x7A, 0x60, 0x71, 0xD6, 0x48,
+	0x90, 0xF8, 0xEA, 0x1E,
+	0xA1, 0x71, 0x90, 0xF8, 0xEB, 0x1E, 0xE1, 0x71, 0x90, 0xF8, 0xEC, 0x1E,
+	0xA1, 0x72, 0x90, 0xF8,
+	0xED, 0x1E, 0xE1, 0x72, 0x90, 0xF8, 0xE8, 0x1E, 0x21, 0x73, 0x90, 0xF8,
+	0xE9, 0x0E, 0x60, 0x73,
+	0x09, 0xD1, 0xCD, 0x48, 0x00, 0x68, 0x90, 0xF8, 0x21, 0x10, 0xA5, 0x29,
+	0x03, 0xD1, 0x10, 0xF9,
+	0x22, 0x7F, 0x90, 0xF9, 0x01, 0x60, 0x04, 0xF1, 0x10, 0x00, 0xCD, 0xE9,
+	0x01, 0x07, 0xC7, 0x48,
+	0x00, 0x21, 0x98, 0x30, 0x00, 0x90, 0xCD, 0xE9, 0x03, 0x61, 0xD5, 0xE9,
+	0x04, 0x23, 0x28, 0x68,
+	0xFF, 0xF7, 0x18, 0xFE, 0xA5, 0x20, 0x20, 0x70, 0x13, 0x20, 0x60, 0x70,
+	0xA4, 0xF8, 0x02, 0x90,
+	0xD5, 0xE9, 0x01, 0x01, 0x08, 0x44, 0x13, 0x30, 0x80, 0x08, 0xB1, 0xE7,
+	0x2D, 0xE9, 0xF0, 0x43,
+	0x89, 0x46, 0x00, 0x27, 0x85, 0xB0, 0x90, 0x46, 0x04, 0x46, 0x3E, 0x46,
+	0xFC, 0x21, 0x03, 0xF0,
+	0xCB, 0xFB, 0xB3, 0x4D, 0xB8, 0xF1, 0x01, 0x0F, 0x28, 0x79, 0x20, 0x71,
+	0x28, 0x7A, 0x60, 0x71,
+	0xB0, 0x48, 0x90, 0xF8, 0x82, 0x1F, 0xA1, 0x71, 0x90, 0xF8, 0x83, 0x1F,
+	0xE1, 0x71, 0x90, 0xF8,
+	0x84, 0x1F, 0xA1, 0x72, 0x90, 0xF8, 0x85, 0x1F, 0xE1, 0x72, 0x90, 0xF8,
+	0x80, 0x1F, 0x21, 0x73,
+	0x90, 0xF8, 0x81, 0x0F, 0x60, 0x73, 0x09, 0xD1, 0xA7, 0x48, 0x00, 0x68,
+	0x90, 0xF8, 0x26, 0x10,
+	0xA5, 0x29, 0x03, 0xD1, 0x10, 0xF9, 0x27, 0x7F, 0x90, 0xF9, 0x01, 0x60,
+	0x04, 0xF1, 0x10, 0x00,
+	0xCD, 0xE9, 0x01, 0x07, 0xA2, 0x48, 0x00, 0x21, 0x00, 0x90, 0xCD, 0xE9,
+	0x03, 0x61, 0xD5, 0xE9,
+	0x04, 0x23, 0x28, 0x68, 0xFF, 0xF7, 0xCE, 0xFD, 0xA5, 0x20, 0x20, 0x70,
+	0x17, 0x20, 0x60, 0x70,
+	0xA4, 0xF8, 0x02, 0x90, 0xD5, 0xE9, 0x01, 0x01, 0x08, 0x44, 0x13, 0x30,
+	0x80, 0x08, 0x67, 0xE7,
+	0x2D, 0xE9, 0xFF, 0x41, 0x0D, 0x46, 0x07, 0x46, 0x00, 0x26, 0xFF, 0xF7,
+	0x21, 0xFD, 0x01, 0x22,
+	0x8F, 0x4C, 0x91, 0x49, 0x10, 0x3F, 0x05, 0xF1, 0x10, 0x00, 0x08, 0x2F,
+	0x4E, 0xD2, 0xDF, 0xE8,
+	0x07, 0xF0, 0x04, 0x15, 0x26, 0x2A, 0x2F, 0x4D, 0x4D, 0x51, 0x2B, 0x79,
+	0x66, 0x68, 0xB3, 0x42,
+	0x2E, 0xD1, 0x6B, 0x79, 0xA5, 0x68, 0xAB, 0x42, 0x2A, 0xD1, 0x09, 0x68,
+	0x00, 0x23, 0x8D, 0x7E,
+	0xA5, 0x2D, 0x01, 0xD1, 0x91, 0xF9, 0x1B, 0x30, 0x82, 0x49, 0x2D, 0xE0,
+	0x2B, 0x79, 0x66, 0x68,
+	0xB3, 0x42, 0x1D, 0xD1, 0x6B, 0x79, 0xA5, 0x68, 0xAB, 0x42, 0x19, 0xD1,
+	0x09, 0x68, 0x00, 0x23,
+	0x0D, 0x7F, 0xA5, 0x2D, 0x01, 0xD1, 0x91, 0xF9, 0x1D, 0x30, 0x7E, 0x49,
+	0x1C, 0xE0, 0x28, 0x46,
+	0x00, 0xF0, 0x12, 0xF9, 0x02, 0xE0, 0x28, 0x46, 0x00, 0xF0, 0x49, 0xF9,
+	0x06, 0x46, 0x1D, 0xE0,
+	0x2B, 0x79, 0x66, 0x68, 0xB3, 0x42, 0x03, 0xD1, 0x6B, 0x79, 0xA5, 0x68,
+	0xAB, 0x42, 0x01, 0xD0,
+	0x00, 0x26, 0x13, 0xE0, 0x09, 0x68, 0x00, 0x23, 0x91, 0xF8, 0x24, 0x50,
+	0xA5, 0x2D, 0x01, 0xD1,
+	0x91, 0xF9, 0x25, 0x30, 0x6D, 0x49, 0xA0, 0x39, 0xCD, 0xE9, 0x00, 0x10,
+	0xCD, 0xE9, 0x02, 0x32,
+	0xD4, 0xE9, 0x04, 0x23, 0x20, 0x68, 0xFF, 0xF7, 0x19, 0xFD, 0x01, 0x26,
+	0x30, 0x46, 0x04, 0xB0,
+	0xBD, 0xE8, 0xF0, 0x81, 0x28, 0x46, 0x00, 0xF0, 0x5E, 0xF9, 0xD7, 0xE7,
+	0x2D, 0xE9, 0xF0, 0x41,
+	0x1E, 0x46, 0x17, 0x46, 0x88, 0x46, 0x05, 0x46, 0x00, 0x24, 0xFF, 0xF7,
+	0xB9, 0xFC, 0x10, 0x3D,
+	0x08, 0x2D, 0x11, 0xD2, 0xDF, 0xE8, 0x05, 0xF0, 0x04, 0x0A, 0x12, 0x18,
+	0x1E, 0x10, 0x10, 0x24,
+	0x32, 0x46, 0x39, 0x46, 0x40, 0x46, 0x00, 0xF0, 0x81, 0xF9, 0x04, 0xE0,
+	0x32, 0x46, 0x39, 0x46,
+	0x40, 0x46, 0x00, 0xF0, 0xAC, 0xF9, 0x04, 0x46, 0x20, 0x46, 0xD9, 0xE7,
+	0x32, 0x46, 0x39, 0x46,
+	0x40, 0x46, 0xFF, 0xF7, 0x95, 0xFE, 0xF6, 0xE7, 0x32, 0x46, 0x39, 0x46,
+	0x40, 0x46, 0xFF, 0xF7,
+	0xDA, 0xFE, 0xF0, 0xE7, 0x32, 0x46, 0x39, 0x46, 0x40, 0x46, 0x00, 0xF0,
+	0xC9, 0xF9, 0xEA, 0xE7,
+	0x32, 0x46, 0x39, 0x46, 0x40, 0x46, 0xFF, 0xF7, 0x19, 0xFF, 0xE4, 0xE7,
+	0xFE, 0xB5, 0x17, 0x46,
+	0x06, 0x46, 0x0D, 0x46, 0xFF, 0xF7, 0x84, 0xFC, 0x41, 0x48, 0x47, 0x4A,
+	0x05, 0xF1, 0x10, 0x04,
+	0x01, 0x79, 0x29, 0x71, 0x01, 0x7A, 0x69, 0x71, 0xA6, 0xF1, 0x50, 0x01,
+	0x08, 0x29, 0x26, 0xD2,
+	0xDF, 0xE8, 0x01, 0xF0, 0x04, 0x06, 0x0F, 0x16, 0x2A, 0x25, 0x25, 0x2D,
+	0x39, 0x49, 0x00, 0xE0,
+	0x3C, 0x49, 0xCD, 0xE9, 0x00, 0x14, 0xD0, 0xE9, 0x04, 0x23, 0x00, 0x68,
+	0xFF, 0xF7, 0x90, 0xFD,
+	0x15, 0xE0, 0x11, 0x68, 0x35, 0x4A, 0x91, 0xF8, 0x42, 0x11, 0x01, 0xF0,
+	0x01, 0x01, 0x06, 0xE0,
+	0x11, 0x68, 0x32, 0x4A, 0x91, 0xF8, 0x92, 0x19, 0x98, 0x32, 0x01, 0xF0,
+	0x01, 0x01, 0x00, 0x92,
+	0xCD, 0xE9, 0x01, 0x41, 0xD0, 0xE9, 0x04, 0x23, 0x00, 0x68, 0xFF, 0xF7,
+	0xB3, 0xFD, 0xA5, 0x20,
+	0x28, 0x70, 0x6E, 0x70, 0x6F, 0x80, 0xFE, 0xBD, 0x28, 0x49, 0xA0, 0x39,
+	0xD9, 0xE7, 0x11, 0x68,
+	0x27, 0x4A, 0x91, 0xF8, 0x12, 0x1A, 0x01, 0xF0, 0x01, 0x01, 0xE8, 0xE7,
+	0x2D, 0xE9, 0xF0, 0x41,
+	0x0C, 0x46, 0x05, 0x46, 0x4F, 0xF4, 0x29, 0x71, 0x24, 0x48, 0x03, 0xF0,
+	0xBF, 0xFA, 0x23, 0x48,
+	0x00, 0x2C, 0x04, 0x60, 0x57, 0xD1, 0x80, 0x46, 0x04, 0xEB, 0x84, 0x00,
+	0xC4, 0xEB, 0xC4, 0x01,
+	0x05, 0xEB, 0xC0, 0x06, 0x08, 0xEB, 0x01, 0x17, 0x38, 0x1D, 0x28, 0x22,
+	0x31, 0x46, 0x03, 0xF0,
+	0x0C, 0xFA, 0xC4, 0xEB, 0x04, 0x10, 0x05, 0xEB, 0x80, 0x01, 0x07, 0xF1,
+	0x2C, 0x00, 0x20, 0x22,
+	0x78, 0x31, 0x03, 0xF0, 0x02, 0xFA, 0x06, 0xF5, 0x96, 0x71, 0x07, 0xF1,
+	0x4C, 0x00, 0x28, 0x22,
+	0x03, 0xF0, 0xFB, 0xF9, 0x64, 0x1C, 0x03, 0x2C, 0xDE, 0xDB, 0x00, 0x24,
+	0x04, 0xEB, 0x84, 0x00,
+	0xC4, 0xEB, 0xC4, 0x02, 0x05, 0xEB, 0xC0, 0x06, 0x08, 0xEB, 0x02, 0x17,
+	0x06, 0xF5, 0xD2, 0x71,
+	0x07, 0xF5, 0xAA, 0x70, 0x28, 0x22, 0x03, 0xF0, 0xE8, 0xF9, 0xC4, 0xEB,
+	0x04, 0x10, 0x0F, 0xE0,
+	0xB0, 0x07, 0x10, 0x00, 0x78, 0x8B, 0x01, 0x20, 0x50, 0x07, 0x10, 0x00,
+	0x38, 0x99, 0x01, 0x20,
+	0x68, 0x9A, 0x01, 0x20, 0x08, 0x92, 0x01, 0x20, 0x4C, 0x07, 0x10, 0x00,
+	0x40, 0x9D, 0x01, 0x20,
+	0x05, 0xEB, 0x80, 0x01, 0x07, 0xF5, 0xBE, 0x70, 0x20, 0x22, 0x01, 0xF5,
+	0x07, 0x71, 0x03, 0xF0,
+	0xCC, 0xF9, 0x06, 0xF5, 0x34, 0x71, 0x07, 0xF5, 0xCE, 0x70, 0x28, 0x22,
+	0x03, 0xF0, 0xC5, 0xF9,
+	0x64, 0x1C, 0x03, 0x2C, 0xCA, 0xDB, 0x13, 0xE7, 0x30, 0xB5, 0xA3, 0x49,
+	0x02, 0x79, 0x85, 0xB0,
+	0x4B, 0x68, 0x9A, 0x42, 0x03, 0xD1, 0x42, 0x79, 0x8B, 0x68, 0x9A, 0x42,
+	0x02, 0xD0, 0x00, 0x20,
+	0x05, 0xB0, 0x30, 0xBD, 0x9D, 0x4A, 0x85, 0x79, 0x00, 0x24, 0x82, 0xF8,
+	0x52, 0x5E, 0xC5, 0x79,
+	0x82, 0xF8, 0x53, 0x5E, 0x85, 0x7A, 0x82, 0xF8, 0x54, 0x5E, 0xC5, 0x7A,
+	0x82, 0xF8, 0x55, 0x5E,
+	0x05, 0x7B, 0x82, 0xF8, 0x50, 0x5E, 0x45, 0x7B, 0x82, 0xF8, 0x51, 0x5E,
+	0x94, 0x4A, 0x23, 0x46,
+	0x12, 0x68, 0x95, 0x7F, 0xA5, 0x2D, 0x03, 0xD1, 0x92, 0xF9, 0x1F, 0x40,
+	0x92, 0xF9, 0x20, 0x30,
+	0x10, 0x30, 0xCD, 0xE9, 0x01, 0x04, 0x8F, 0x48, 0x01, 0x22, 0x00, 0x90,
+	0xCD, 0xE9, 0x03, 0x32,
+	0xD1, 0xE9, 0x04, 0x23, 0x08, 0x68, 0xFF, 0xF7, 0x3D, 0xFC, 0x01, 0x20,
+	0xD0, 0xE7, 0x30, 0xB5,
+	0x85, 0x49, 0x02, 0x79, 0x85, 0xB0, 0x4B, 0x68, 0x9A, 0x42, 0x03, 0xD1,
+	0x42, 0x79, 0x8B, 0x68,
+	0x9A, 0x42, 0x01, 0xD0, 0x00, 0x20, 0xC3, 0xE7, 0x80, 0x4A, 0x85, 0x79,
+	0x00, 0x24, 0x82, 0xF8,
+	0xEA, 0x5E, 0xC5, 0x79, 0x82, 0xF8, 0xEB, 0x5E, 0x85, 0x7A, 0x82, 0xF8,
+	0xEC, 0x5E, 0xC5, 0x7A,
+	0x82, 0xF8, 0xED, 0x5E, 0x05, 0x7B, 0x82, 0xF8, 0xE8, 0x5E, 0x45, 0x7B,
+	0x82, 0xF8, 0xE9, 0x5E,
+	0x77, 0x4A, 0x23, 0x46, 0x12, 0x68, 0x92, 0xF8, 0x21, 0x50, 0xA5, 0x2D,
+	0x03, 0xD1, 0x12, 0xF9,
+	0x22, 0x4F, 0x92, 0xF9, 0x01, 0x30, 0x10, 0x30, 0xCD, 0xE9, 0x01, 0x04,
+	0x71, 0x48, 0x01, 0x22,
+	0x98, 0x30, 0x00, 0x90, 0xCD, 0xE9, 0x03, 0x32, 0xD1, 0xE9, 0x04, 0x23,
+	0x08, 0x68, 0xFF, 0xF7,
+	0x01, 0xFC, 0x01, 0x20, 0x94, 0xE7, 0x30, 0xB5, 0x67, 0x49, 0x02, 0x79,
+	0x85, 0xB0, 0x4B, 0x68,
+	0x9A, 0x42, 0x03, 0xD1, 0x42, 0x79, 0x8B, 0x68, 0x9A, 0x42, 0x01, 0xD0,
+	0x00, 0x20, 0x87, 0xE7,
+	0x62, 0x4A, 0x85, 0x79, 0x00, 0x24, 0x82, 0xF8, 0x82, 0x5F, 0xC5, 0x79,
+	0x82, 0xF8, 0x83, 0x5F,
+	0x85, 0x7A, 0x82, 0xF8, 0x84, 0x5F, 0xC5, 0x7A, 0x82, 0xF8, 0x85, 0x5F,
+	0x05, 0x7B, 0x82, 0xF8,
+	0x80, 0x5F, 0x45, 0x7B, 0x82, 0xF8, 0x81, 0x5F, 0x59, 0x4A, 0x23, 0x46,
+	0x12, 0x68, 0x92, 0xF8,
+	0x26, 0x50, 0xA5, 0x2D, 0x03, 0xD1, 0x12, 0xF9, 0x27, 0x4F, 0x92, 0xF9,
+	0x01, 0x30, 0x10, 0x30,
+	0xCD, 0xE9, 0x01, 0x04, 0x54, 0x48, 0x01, 0x22, 0x00, 0x90, 0xCD, 0xE9,
+	0x03, 0x32, 0xD1, 0xE9,
+	0x04, 0x23, 0x08, 0x68, 0xFF, 0xF7, 0xC6, 0xFB, 0x01, 0x20, 0x59, 0xE7,
+	0x2D, 0xE9, 0xFF, 0x41,
+	0x0F, 0x46, 0x15, 0x46, 0x04, 0x46, 0x00, 0x26, 0x40, 0xF2, 0x7A, 0x31,
+	0x03, 0xF0, 0x84, 0xF9,
+	0x45, 0x48, 0x01, 0x2D, 0x01, 0x79, 0x21, 0x71, 0x01, 0x7A, 0x61, 0x71,
+	0x06, 0xD1, 0x44, 0x49,
+	0x09, 0x68, 0x8A, 0x7E, 0xA5, 0x2A, 0x01, 0xD1, 0x91, 0xF9, 0x1B, 0x60,
+	0x00, 0x22, 0x04, 0xF1,
+	0x10, 0x01, 0x3E, 0x4B, 0xCD, 0xE9, 0x00, 0x31, 0xCD, 0xE9, 0x02, 0x62,
+	0x05, 0x46, 0x00, 0x68,
+	0xD5, 0xE9, 0x04, 0x23, 0xFF, 0xF7, 0x52, 0xFB, 0xA5, 0x20, 0x20, 0x70,
+	0x10, 0x20, 0x60, 0x70,
+	0x67, 0x80, 0xD5, 0xE9, 0x01, 0x01, 0x48, 0x43, 0x13, 0x30, 0x80, 0x08,
+	0x2F, 0xE6, 0x2D, 0xE9,
+	0xFF, 0x41, 0x0F, 0x46, 0x15, 0x46, 0x04, 0x46, 0x00, 0x26, 0x40, 0xF2,
+	0x7A, 0x31, 0x03, 0xF0,
+	0x53, 0xF9, 0x2D, 0x48, 0x01, 0x2D, 0x01, 0x79, 0x21, 0x71, 0x01, 0x7A,
+	0x61, 0x71, 0x06, 0xD1,
+	0x2B, 0x49, 0x09, 0x68, 0x0A, 0x7F, 0xA5, 0x2A, 0x01, 0xD1, 0x91, 0xF9,
+	0x1D, 0x60, 0x00, 0x23,
+	0x04, 0xF1, 0x10, 0x01, 0x29, 0x4A, 0xCD, 0xE9, 0x00, 0x21, 0xCD, 0xE9,
+	0x02, 0x63, 0x05, 0x46,
+	0x00, 0x68, 0xD5, 0xE9, 0x04, 0x23, 0xFF, 0xF7, 0x21, 0xFB, 0xA5, 0x20,
+	0x20, 0x70, 0x11, 0x20,
+	0x60, 0x70, 0x67, 0x80, 0xD5, 0xE9, 0x01, 0x01, 0x48, 0x43, 0x13, 0x30,
+	0x80, 0x08, 0xFE, 0xE5,
+	0x2D, 0xE9, 0xFF, 0x41, 0x0F, 0x46, 0x15, 0x46, 0x04, 0x46, 0x00, 0x26,
+	0x40, 0xF2, 0x7A, 0x31,
+	0x03, 0xF0, 0x22, 0xF9, 0x14, 0x48, 0x01, 0x2D, 0x01, 0x79, 0x21, 0x71,
+	0x01, 0x7A, 0x61, 0x71,
+	0x07, 0xD1, 0x13, 0x49, 0x09, 0x68, 0x91, 0xF8, 0x24, 0x20, 0xA5, 0x2A,
+	0x01, 0xD1, 0x91, 0xF9,
+	0x25, 0x60, 0x10, 0x4A, 0x00, 0x23, 0x04, 0xF1, 0x10, 0x01, 0xA0, 0x3A,
+	0xCD, 0xE9, 0x00, 0x21,
+	0xCD, 0xE9, 0x02, 0x63, 0x05, 0x46, 0x00, 0x68, 0xD5, 0xE9, 0x04, 0x23,
+	0xFF, 0xF7, 0xEE, 0xFA,
+	0xA5, 0x20, 0x20, 0x70, 0x14, 0x20, 0x60, 0x70, 0x67, 0x80, 0xD5, 0xE9,
+	0x01, 0x01, 0x48, 0x43,
+	0x13, 0x30, 0x80, 0x08, 0xCB, 0xE5, 0x00, 0x00, 0xB0, 0x07, 0x10, 0x00,
+	0x78, 0x8B, 0x01, 0x20,
+	0x50, 0x07, 0x10, 0x00, 0x38, 0x99, 0x01, 0x20, 0x68, 0x9A, 0x01, 0x20,
+	0x08, 0x92, 0x01, 0x20,
+	0x2D, 0xE9, 0xF0, 0x4F, 0x47, 0xF6, 0xFF, 0x77, 0xDD, 0xE9, 0x09, 0xB5,
+	0x81, 0x46, 0xFE, 0x43,
+	0x01, 0x20, 0x9A, 0x46, 0x84, 0x46, 0x2C, 0x46, 0x15, 0xE0, 0x00, 0xBF,
+	0x32, 0xF8, 0x14, 0x30,
+	0x31, 0xF8, 0x14, 0x80, 0xA3, 0xEB, 0x08, 0x03, 0x1B, 0xB2, 0xBB, 0x42,
+	0x00, 0xDA, 0x1F, 0x46,
+	0xB3, 0x42, 0x00, 0xDD, 0x1E, 0x46, 0x00, 0x2B, 0x02, 0xDD, 0x4F, 0xF0,
+	0x00, 0x0C, 0x02, 0xE0,
+	0x01, 0xDA, 0x4F, 0xF0, 0x00, 0x00, 0x64, 0x1E, 0xE8, 0xD2, 0x20, 0xB1,
+	0xBC, 0xF1, 0x00, 0x0F,
+	0x01, 0xD0, 0x00, 0x23, 0x09, 0xE0, 0x50, 0xEA, 0x0C, 0x03, 0x06, 0xD0,
+	0x20, 0xB9, 0xBC, 0xF1,
+	0x00, 0x0F, 0x01, 0xD0, 0x33, 0x46, 0x00, 0xE0, 0x3B, 0x46, 0x00, 0x27,
+	0x3C, 0x46, 0x28, 0x46,
+	0xCB, 0xF1, 0x00, 0x0C, 0x0E, 0xE0, 0x00, 0xBF, 0x32, 0xF8, 0x10, 0x60,
+	0x31, 0xF8, 0x10, 0x80,
+	0xA6, 0xEB, 0x08, 0x06, 0xF6, 0x1A, 0x36, 0xB2, 0x56, 0x45, 0x03, 0xDA,
+	0x66, 0x45, 0x01, 0xDD,
+	0x37, 0x44, 0x64, 0x1C, 0x40, 0x1E, 0xEF, 0xD2, 0x04, 0xB9, 0x01, 0x24,
+	0x97, 0xFB, 0xF4, 0xF0,
+	0x18, 0x44, 0x04, 0xE0, 0x31, 0xF8, 0x15, 0x20, 0x02, 0x44, 0x29, 0xF8,
+	0x15, 0x20, 0x6D, 0x1E,
+	0xF8, 0xD2, 0xBD, 0xE8, 0xF0, 0x8F, 0xF0, 0xB5, 0x00, 0x23, 0x06, 0x46,
+	0x1D, 0x46, 0x18, 0x46,
+	0x0E, 0xE0, 0x00, 0xBF, 0x36, 0xF9, 0x11, 0x40, 0x00, 0x2C, 0x01, 0xDB,
+	0x27, 0x46, 0x00, 0xE0,
+	0x67, 0x42, 0x97, 0x42, 0x04, 0xDD, 0x00, 0x2C, 0x01, 0xDD, 0x25, 0x44,
+	0x00, 0xE0, 0x23, 0x44,
+	0x49, 0x1E, 0xEF, 0xD2, 0x00, 0x2B, 0x00, 0xDA, 0x5B, 0x42, 0xAB, 0x42,
+	0x00, 0xDD, 0x01, 0x20,
+	0xF0, 0xBD, 0x30, 0xB5, 0x07, 0xE0, 0x00, 0xBF, 0x32, 0xF8, 0x13, 0x40,
+	0x31, 0xF8, 0x13, 0x50,
+	0x64, 0x1B, 0x20, 0xF8, 0x13, 0x40, 0x5B, 0x1E, 0xF6, 0xD2, 0x30, 0xBD,
+	0xF0, 0xB4, 0x04, 0x9C,
+	0x1C, 0xB9, 0x13, 0xB1, 0xC3, 0xF1, 0x10, 0x04, 0x0E, 0xE0, 0xF0, 0xBC,
+	0x52, 0x00, 0x02, 0xF0,
+	0xDC, 0xBF, 0x00, 0xBF, 0x30, 0xF9, 0x12, 0x50, 0x31, 0xF9, 0x12, 0x60,
+	0x5D, 0x43, 0x06, 0xFB,
+	0x04, 0x55, 0x2D, 0x11, 0x20, 0xF8, 0x12, 0x50, 0x52, 0x1E, 0xF3, 0xD2,
+	0xF0, 0xBC, 0x70, 0x47,
+	0xF0, 0xB4, 0x04, 0x9C, 0x1C, 0xB9, 0x13, 0xB1, 0xC3, 0xF1, 0x80, 0x04,
+	0x0E, 0xE0, 0xF0, 0xBC,
+	0x52, 0x00, 0x02, 0xF0, 0xC2, 0xBF, 0x00, 0xBF, 0x30, 0xF9, 0x12, 0x50,
+	0x31, 0xF9, 0x12, 0x60,
+	0x5D, 0x43, 0x06, 0xFB, 0x04, 0x55, 0xED, 0x11, 0x20, 0xF8, 0x12, 0x50,
+	0x52, 0x1E, 0xF3, 0xD2,
+	0xE4, 0xE7, 0xF0, 0xB5, 0x00, 0x2B, 0x19, 0xD0, 0x14, 0x46, 0x15, 0xE0,
+	0x00, 0x27, 0x3E, 0x46,
+	0xE5, 0x1A, 0x04, 0xEB, 0x03, 0x0C, 0x08, 0xE0, 0x00, 0x2D, 0x05, 0xDB,
+	0x95, 0x42, 0x03, 0xDA,
+	0x31, 0xF9, 0x15, 0xE0, 0x76, 0x1C, 0x77, 0x44, 0x6D, 0x1C, 0xAC, 0x45,
+	0xF4, 0xDA, 0x1E, 0xB1,
+	0x97, 0xFB, 0xF6, 0xF5, 0x20, 0xF8, 0x14, 0x50, 0x64, 0x1E, 0xE7, 0xD2,
+	0xF0, 0xBD, 0x70, 0xB5,
+	0x0C, 0x46, 0x15, 0x46, 0xA0, 0x42, 0x04, 0xD0, 0x01, 0x46, 0x6A, 0x00,
+	0x20, 0x46, 0x02, 0xF0,
+	0x8C, 0xFF, 0x00, 0x20, 0x17, 0xE0, 0x01, 0x46, 0x42, 0x1C, 0x07, 0xE0,
+	0x34, 0xF9, 0x12, 0x60,
+	0x34, 0xF9, 0x11, 0x30, 0x9E, 0x42, 0x00, 0xDA, 0x11, 0x46, 0x52, 0x1C,
+	0xAA, 0x42, 0xF5, 0xD3,
+	0x88, 0x42, 0x07, 0xD0, 0x34, 0xF8, 0x10, 0x20, 0x34, 0xF8, 0x11, 0x30,
+	0x24, 0xF8, 0x10, 0x30,
+	0x24, 0xF8, 0x11, 0x20, 0x40, 0x1C, 0xB0, 0xEB, 0x55, 0x0F, 0xE4, 0xD9,
+	0xE9, 0x07, 0x25, 0xF0,
+	0x01, 0x00, 0x01, 0xD0, 0x20, 0x5E, 0x70, 0xBD, 0x21, 0x5E, 0x20, 0x44,
+	0x30, 0xF9, 0x02, 0x0C,
+	0x08, 0x44, 0x40, 0x10, 0x70, 0xBD, 0x03, 0x46, 0x00, 0x20, 0x04, 0xE0,
+	0x33, 0xF9, 0x11, 0x20,
+	0x82, 0x42, 0x00, 0xDD, 0x10, 0x46, 0x49, 0x1E, 0xF8, 0xD2, 0x70, 0x47,
+	0x03, 0x46, 0x47, 0xF6,
+	0xFF, 0x70, 0x04, 0xE0, 0x33, 0xF9, 0x11, 0x20, 0x82, 0x42, 0x00, 0xDA,
+	0x10, 0x46, 0x49, 0x1E,
+	0xF8, 0xD2, 0x00, 0x28, 0x00, 0xDA, 0x00, 0x20, 0x70, 0x47, 0x02, 0x46,
+	0xB0, 0xF9, 0x00, 0x00,
+	0x05, 0xE0, 0x00, 0xBF, 0x32, 0xF9, 0x11, 0x30, 0x83, 0x42, 0x00, 0xDD,
+	0x18, 0x46, 0x49, 0x1E,
+	0xF8, 0xD2, 0x70, 0x47, 0x70, 0xB5, 0x05, 0x00, 0x03, 0xD0, 0xBD, 0xE8,
+	0x70, 0x40, 0x02, 0xF0,
+	0xE4, 0xBB, 0xFE, 0x4C, 0x21, 0x46, 0x60, 0x78, 0x09, 0x79, 0x30, 0xB1,
+	0x0A, 0x46, 0xFC, 0x49,
+	0x01, 0xF1, 0x98, 0x00, 0x02, 0xF0, 0x04, 0xFC, 0x0B, 0xE0, 0x20, 0x78,
+	0x02, 0xF0, 0x42, 0xFD,
+	0x21, 0x79, 0x4A, 0x00, 0xF6, 0x49, 0x01, 0xEB, 0x40, 0x01, 0xF5, 0x48,
+	0x98, 0x30, 0x02, 0xF0,
+	0x1C, 0xFF, 0xA0, 0x78, 0xF3, 0x4E, 0x28, 0xB1, 0xF1, 0x48, 0x21, 0x79,
+	0x98, 0x30, 0x02, 0xF0,
+	0x2F, 0xFD, 0x01, 0xE0, 0xEE, 0x48, 0x98, 0x30, 0xB0, 0x62, 0xE0, 0x78,
+	0x86, 0xF8, 0x31, 0x00,
+	0x28, 0x46, 0xD2, 0xE7, 0x2D, 0xE9, 0xF0, 0x47, 0xDF, 0xF8, 0xAC, 0xA3,
+	0x01, 0x27, 0xB8, 0x46,
+	0xDA, 0xF8, 0x00, 0x00, 0x00, 0xF2, 0x5E, 0x64, 0x90, 0xF8, 0xA6, 0x19,
+	0x90, 0xF8, 0xA2, 0x59,
+	0x01, 0xF0, 0x1F, 0x06, 0x90, 0xF8, 0xA3, 0x19, 0x01, 0xF0, 0x0F, 0x09,
+	0x90, 0xF8, 0x82, 0x19,
+	0x89, 0x06, 0x09, 0xD5, 0x90, 0xF8, 0x58, 0x16, 0x90, 0xF8, 0x59, 0x06,
+	0x0A, 0x22, 0x04, 0xEB,
+	0x40, 0x00, 0x02, 0xF0, 0x09, 0xFC, 0x07, 0x46, 0xDA, 0xF8, 0x00, 0x00,
+	0x90, 0xF8, 0x82, 0x19,
+	0x49, 0x06, 0x09, 0xD5, 0x90, 0xF8, 0x68, 0x18, 0x90, 0xF8, 0x69, 0x08,
+	0x0A, 0x22, 0x04, 0xEB,
+	0x40, 0x00, 0x02, 0xF0, 0xF9, 0xFB, 0x80, 0x46, 0x4F, 0xF4, 0x80, 0x70,
+	0x85, 0x42, 0x00, 0xD9,
+	0x05, 0x46, 0x1F, 0x2E, 0x00, 0xD9, 0x1F, 0x26, 0x76, 0x1C, 0x75, 0x43,
+	0x09, 0xF1, 0x01, 0x00,
+	0x45, 0x43, 0xC5, 0xEB, 0x45, 0x20, 0x78, 0x43, 0x00, 0xFB, 0x08, 0xF0,
+	0xC0, 0x13, 0xB0, 0xFA,
+	0x80, 0xF0, 0xC0, 0xF1, 0x20, 0x00, 0xC0, 0xB2, 0xBD, 0xE8, 0xF0, 0x87,
+	0x2D, 0xE9, 0xF0, 0x41,
+	0x04, 0x46, 0xEC, 0xF7, 0x61, 0xFA, 0xC2, 0x48, 0xEC, 0xF7, 0x63, 0xFA,
+	0xA4, 0xF8, 0x76, 0x00,
+	0x02, 0xF0, 0xB2, 0xFB, 0x01, 0x46, 0x20, 0x46, 0xEC, 0xF7, 0xCC, 0xFC,
+	0x02, 0xF0, 0xB0, 0xFB,
+	0x02, 0x46, 0x0B, 0x46, 0x20, 0x46, 0xEC, 0xF7, 0xE7, 0xFC, 0x20, 0x46,
+	0x02, 0xF0, 0xE2, 0xFC,
+	0xB9, 0x4D, 0xB4, 0xF8, 0x56, 0x10, 0x28, 0x68, 0xB0, 0xF8, 0xBE, 0x20,
+	0x62, 0xF3, 0x09, 0x01,
+	0xA4, 0xF8, 0x56, 0x10, 0x90, 0xF8, 0xBD, 0x00, 0x94, 0xF8, 0x55, 0x10,
+	0x60, 0xF3, 0x03, 0x01,
+	0x84, 0xF8, 0x55, 0x10, 0x04, 0x21, 0x20, 0x46, 0xEC, 0xF7, 0x69, 0xFA,
+	0x28, 0x68, 0x90, 0xF8,
+	0xA2, 0x09, 0xA0, 0x70, 0x28, 0x68, 0x21, 0x8E, 0xB0, 0xF8, 0xA7, 0x29,
+	0x62, 0xF3, 0x08, 0x01,
+	0x21, 0x86, 0x90, 0xF8, 0xA3, 0x09, 0x00, 0xF0, 0x0F, 0x01, 0x20, 0x46,
+	0xEC, 0xF7, 0xB7, 0xFA,
+	0x28, 0x68, 0x34, 0xF8, 0x1A, 0x1F, 0xB0, 0xF8, 0x8E, 0x29, 0x62, 0xF3,
+	0x0B, 0x01, 0x24, 0xF8,
+	0x12, 0x19, 0xB0, 0xF8, 0x8C, 0x29, 0x21, 0x89, 0x62, 0xF3, 0x0B, 0x01,
+	0x21, 0x81, 0xB0, 0xF8,
+	0x8A, 0x29, 0xA1, 0x88, 0x62, 0xF3, 0x0B, 0x01, 0xA1, 0x80, 0x90, 0xF8,
+	0xA4, 0x29, 0xA1, 0x7A,
+	0x62, 0xF3, 0x01, 0x01, 0xA1, 0x72, 0x90, 0xF8, 0xA4, 0x29, 0x92, 0x08,
+	0x62, 0xF3, 0x87, 0x11,
+	0xA1, 0x72, 0x90, 0xF8, 0x82, 0x19, 0x14, 0xF8, 0x01, 0x2C, 0x61, 0xF3,
+	0x00, 0x02, 0x04, 0xF8,
+	0x01, 0x2C, 0x90, 0xF8, 0x85, 0x09, 0x60, 0x70, 0x90, 0x48, 0x90, 0xF8,
+	0xE8, 0x1E, 0xA1, 0x75,
+	0x90, 0xF8, 0xE9, 0x1E, 0x21, 0x77, 0x90, 0xF8, 0xEA, 0x1E, 0xE1, 0x75,
+	0x90, 0xF8, 0xEB, 0x1E,
+	0x61, 0x77, 0x90, 0xF8, 0xEC, 0x1E, 0x21, 0x76, 0x90, 0xF8, 0xED, 0x0E,
+	0xA0, 0x77, 0x88, 0x48,
+	0xEC, 0xF7, 0xE7, 0xF9, 0xA4, 0xF8, 0x78, 0x00, 0x85, 0x48, 0x20, 0x30,
+	0xEC, 0xF7, 0xE1, 0xF9,
+	0xA4, 0xF8, 0x7C, 0x00, 0x28, 0x68, 0x26, 0x7D, 0x90, 0xF8, 0x92, 0x19,
+	0x09, 0x09, 0x61, 0xF3,
+	0x07, 0x16, 0x26, 0x75, 0x90, 0xF8, 0x97, 0x19, 0x0A, 0x09, 0xA1, 0x7E,
+	0x62, 0xF3, 0x07, 0x11,
+	0xA1, 0x76, 0x90, 0xF8, 0x93, 0x29, 0x63, 0x7D, 0x62, 0xF3, 0x03, 0x03,
+	0x63, 0x75, 0x90, 0xF8,
+	0x98, 0x79, 0xE2, 0x7E, 0x67, 0xF3, 0x03, 0x02, 0xE2, 0x76, 0x90, 0xF8,
+	0x93, 0x79, 0x3F, 0x09,
+	0x67, 0xF3, 0x07, 0x13, 0x63, 0x75, 0x90, 0xF8, 0x98, 0x39, 0x1B, 0x09,
+	0x63, 0xF3, 0x07, 0x12,
+	0xE2, 0x76, 0x90, 0xF8, 0x92, 0x29, 0x62, 0xF3, 0x00, 0x06, 0x26, 0x75,
+	0x90, 0xF8, 0x97, 0x29,
+	0x62, 0xF3, 0x00, 0x01, 0xA1, 0x76, 0x90, 0xF8, 0x87, 0x09, 0x01, 0x09,
+	0xE0, 0x78, 0x61, 0xF3,
+	0x03, 0x00, 0xE0, 0x70, 0x66, 0x48, 0x48, 0x38, 0xEC, 0xF7, 0xA3, 0xF9,
+	0xA4, 0xF8, 0x76, 0x00,
+	0x63, 0x48, 0x28, 0x38, 0xEC, 0xF7, 0x9D, 0xF9, 0xA4, 0xF8, 0x7A, 0x00,
+	0x29, 0x68, 0x91, 0xF8,
+	0x84, 0x09, 0xC2, 0x08, 0x14, 0xF8, 0x1F, 0x0F, 0x62, 0xF3, 0x83, 0x00,
+	0x20, 0x70, 0x91, 0xF8,
+	0x84, 0x29, 0x52, 0x08, 0x62, 0xF3, 0x00, 0x00, 0x20, 0x70, 0x91, 0xF8,
+	0x84, 0x29, 0x92, 0x08,
+	0x62, 0xF3, 0x41, 0x00, 0x04, 0xF8, 0x27, 0x09, 0x91, 0xF8, 0x83, 0x09,
+	0xC0, 0xF3, 0x81, 0x01,
+	0x20, 0x46, 0xEC, 0xF7, 0xF9, 0xF9, 0x28, 0x68, 0x90, 0xF8, 0x83, 0x09,
+	0x01, 0x09, 0x14, 0xF8,
+	0x28, 0x0F, 0x61, 0xF3, 0x04, 0x10, 0x20, 0x70, 0x4E, 0x48, 0xEC, 0xF7,
+	0x72, 0xF9, 0xA4, 0xF8,
+	0x60, 0x00, 0x4C, 0x48, 0x20, 0x30, 0xEC, 0xF7, 0x6C, 0xF9, 0xA4, 0xF8,
+	0x62, 0x00, 0x28, 0x68,
+	0x90, 0xF8, 0x82, 0x19, 0xCA, 0x08, 0xE1, 0x7A, 0x62, 0xF3, 0x45, 0x11,
+	0xE1, 0x72, 0x90, 0xF8,
+	0x83, 0x09, 0x41, 0x08, 0x20, 0x78, 0x61, 0xF3, 0x45, 0x10, 0x04, 0xF8,
+	0x28, 0x09, 0x20, 0x46,
+	0x02, 0xF0, 0x8D, 0xFB, 0x28, 0x68, 0x90, 0xF8, 0x86, 0x09, 0x81, 0x09,
+	0x20, 0x46, 0xEC, 0xF7,
+	0xB8, 0xF9, 0x14, 0xF8, 0x32, 0x0F, 0x20, 0xF0, 0x0F, 0x00, 0x0A, 0x30,
+	0x20, 0xF0, 0xF0, 0x00,
+	0xA0, 0x30, 0x04, 0xF8, 0x1C, 0x09, 0x29, 0x68, 0x91, 0xF8, 0x82, 0x09,
+	0x82, 0x09, 0x60, 0x7F,
+	0x62, 0xF3, 0x00, 0x00, 0x60, 0x77, 0x91, 0xF8, 0x82, 0x29, 0x52, 0x09,
+	0x62, 0xF3, 0x41, 0x00,
+	0x60, 0x77, 0x91, 0xF8, 0x88, 0x29, 0x62, 0xF3, 0x82, 0x00, 0x60, 0x77,
+	0x91, 0xF8, 0xA5, 0x09,
+	0xE2, 0x7D, 0x60, 0xF3, 0x04, 0x02, 0xE2, 0x75, 0x91, 0xF8, 0xA6, 0x09,
+	0xA1, 0x7D, 0x60, 0xF3,
+	0x04, 0x01, 0x23, 0x48, 0xA1, 0x75, 0x08, 0x38, 0x94, 0xF8, 0x49, 0x10,
+	0x40, 0x78, 0x60, 0xF3,
+	0x04, 0x01, 0x23, 0x48, 0x84, 0xF8, 0x49, 0x10, 0xE8, 0x30, 0xEC, 0xF7,
+	0x1A, 0xF9, 0xA4, 0xF8,
+	0x64, 0x00, 0x28, 0x68, 0x21, 0x8B, 0xB0, 0xF8, 0x90, 0x29, 0x62, 0xF3,
+	0x0B, 0x01, 0x21, 0x83,
+	0x90, 0xF8, 0x86, 0x19, 0xCA, 0x08, 0x94, 0xF8, 0x22, 0x10, 0x62, 0xF3,
+	0x02, 0x01, 0x84, 0xF8,
+	0x22, 0x10, 0x10, 0xF8, 0xE0, 0x1F, 0x22, 0x7D, 0x61, 0xF3, 0x03, 0x02,
+	0x22, 0x75, 0x10, 0xF8,
+	0xE0, 0x1B, 0x0A, 0x09, 0x61, 0x7D, 0x62, 0xF3, 0x03, 0x01, 0x61, 0x75,
+	0x90, 0xF8, 0xC7, 0x17,
+	0xE2, 0x7C, 0x61, 0xF3, 0x02, 0x02, 0xE2, 0x74, 0x90, 0xF8, 0xC2, 0x17,
+	0xCA, 0x09, 0xA1, 0x7F,
+	0x62, 0xF3, 0x00, 0x01, 0xA1, 0x77, 0x94, 0xF8, 0x49, 0x10, 0x41, 0xF0,
+	0x20, 0x01, 0x84, 0xF8,
+	0x49, 0x10, 0x90, 0xF8, 0xC4, 0x27, 0xD2, 0x09, 0x0E, 0xE0, 0x00, 0x00,
+	0xC8, 0x07, 0x10, 0x00,
+	0x7C, 0xA0, 0x01, 0x20, 0xB4, 0x84, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x78, 0x8B, 0x01, 0x20,
+	0x18, 0x9A, 0x01, 0x20, 0x48, 0xBF, 0x01, 0x20, 0x62, 0xF3, 0xC7, 0x11,
+	0x84, 0xF8, 0x49, 0x10,
+	0xB0, 0xF8, 0xDC, 0x27, 0xB4, 0xF8, 0x4A, 0x10, 0x62, 0xF3, 0x08, 0x01,
+	0xA4, 0xF8, 0x4A, 0x10,
+	0x00, 0x21, 0xE1, 0x64, 0x90, 0xF8, 0xC7, 0x17, 0xCA, 0x08, 0x61, 0x7F,
+	0x62, 0xF3, 0xC3, 0x01,
+	0x61, 0x77, 0x90, 0xF8, 0xC2, 0x27, 0x12, 0x09, 0x62, 0xF3, 0x04, 0x11,
+	0x61, 0x77, 0x90, 0xF8,
+	0xE5, 0x17, 0x4A, 0x09, 0x14, 0xF8, 0x0E, 0x1C, 0x62, 0xF3, 0x06, 0x11,
+	0x04, 0xF8, 0x0E, 0x1C,
+	0x90, 0xF8, 0xC3, 0x17, 0x4A, 0x09, 0xA1, 0x78, 0x62, 0xF3, 0xC3, 0x01,
+	0xA1, 0x70, 0x90, 0xF8,
+	0xC2, 0x27, 0x52, 0x08, 0x62, 0xF3, 0x04, 0x11, 0xA1, 0x70, 0x90, 0xF8,
+	0xC4, 0x07, 0x80, 0x09,
+	0x60, 0xF3, 0x86, 0x11, 0xA1, 0x70, 0xBD, 0xE8, 0xF0, 0x81, 0x2D, 0xE9,
+	0xF0, 0x41, 0x04, 0x46,
+	0x6A, 0x4D, 0x01, 0x20, 0x01, 0x29, 0xA8, 0x70, 0x08, 0xD0, 0x00, 0x26,
+	0x68, 0x4F, 0x02, 0x29,
+	0x08, 0xD0, 0x03, 0x29, 0x14, 0xD0, 0x04, 0x29, 0x2C, 0xD1, 0x3C, 0xE0,
+	0x20, 0x46, 0x00, 0xF0,
+	0xC0, 0xF8, 0x27, 0xE0, 0x63, 0x48, 0xFF, 0xF7, 0x19, 0xFE, 0x20, 0x46,
+	0x00, 0xF0, 0xB9, 0xF8,
+	0xB8, 0x78, 0x94, 0xF8, 0x5F, 0x10, 0x60, 0xF3, 0x04, 0x01, 0x84, 0xF8,
+	0x5F, 0x10, 0x14, 0xE0,
+	0x5C, 0x48, 0xFF, 0xF7, 0x0B, 0xFE, 0x20, 0x46, 0x00, 0xF0, 0xAB, 0xF8,
+	0xF8, 0x78, 0x94, 0xF8,
+	0x5F, 0x10, 0x60, 0xF3, 0x04, 0x01, 0x84, 0xF8, 0x5F, 0x10, 0x94, 0xF8,
+	0x27, 0x00, 0x20, 0xF0,
+	0x02, 0x00, 0x40, 0xF0, 0x01, 0x00, 0x84, 0xF8, 0x27, 0x00, 0x00, 0x21,
+	0x20, 0x46, 0xEC, 0xF7,
+	0xEE, 0xF8, 0xAE, 0x70, 0x20, 0x46, 0x02, 0xF0, 0xD9, 0xFA, 0x94, 0xF8,
+	0x27, 0x00, 0x40, 0xF3,
+	0x00, 0x00, 0x40, 0x1C, 0xE8, 0x70, 0x4C, 0x48, 0x00, 0x68, 0x90, 0xF8,
+	0x83, 0x09, 0xC0, 0xF3,
+	0x80, 0x10, 0x68, 0x70, 0xAF, 0xE7, 0x20, 0x46, 0x00, 0xF0, 0x83, 0xF8,
+	0x14, 0xF8, 0x37, 0x0F,
+	0x40, 0xF0, 0x10, 0x00, 0x04, 0xF8, 0x1F, 0x09, 0xE0, 0x7E, 0x20, 0xF0,
+	0x23, 0x00, 0xE0, 0x76,
+	0x34, 0xF8, 0x0C, 0x0C, 0x6F, 0xF3, 0x0B, 0x00, 0x10, 0x30, 0x24, 0xF8,
+	0x0C, 0x0C, 0x34, 0xF8,
+	0x08, 0x0C, 0x6F, 0xF3, 0x0B, 0x00, 0x40, 0x30, 0x24, 0xF8, 0x08, 0x0C,
+	0x08, 0x20, 0x04, 0xF8,
+	0x16, 0x0C, 0x94, 0xF8, 0x47, 0x00, 0x20, 0xF0, 0x1F, 0x00, 0x84, 0xF8,
+	0x47, 0x00, 0x34, 0xF8,
+	0x18, 0x0F, 0x6F, 0xF3, 0x08, 0x00, 0x24, 0xF8, 0x03, 0x0B, 0x20, 0x78,
+	0x40, 0xF0, 0x0C, 0x00,
+	0x04, 0xF8, 0x0B, 0x09, 0x20, 0x78, 0x40, 0xF0, 0x20, 0x00, 0x04, 0xF8,
+	0x28, 0x09, 0xB8, 0xE7,
+	0x38, 0xB5, 0x02, 0xF0, 0x69, 0xF9, 0x00, 0x90, 0x04, 0x21, 0x68, 0x46,
+	0xEC, 0xF7, 0xBB, 0xFC,
+	0x26, 0x49, 0x27, 0x4D, 0x08, 0x71, 0x00, 0x20, 0x28, 0x60, 0x28, 0x71,
+	0x01, 0x24, 0xE0, 0xB2,
+	0xFF, 0xF7, 0x50, 0xFD, 0x28, 0x55, 0x64, 0x1C, 0x05, 0x2C, 0xF8, 0xDB,
+	0x21, 0x48, 0xFF, 0xF7,
+	0x95, 0xFD, 0x38, 0xBD, 0x30, 0xB5, 0x01, 0x7A, 0xA9, 0xB0, 0x79, 0xB3,
+	0x68, 0x46, 0xFF, 0xF7,
+	0x5C, 0xFF, 0x9D, 0xF8, 0x12, 0x00, 0x00, 0xF0, 0x03, 0x00, 0x02, 0xF0,
+	0xB7, 0xF9, 0x1A, 0x4C,
+	0x20, 0x68, 0x00, 0xF2, 0x5E, 0x63, 0x00, 0xF6, 0x6E, 0x05, 0x90, 0xF8,
+	0x58, 0x16, 0x90, 0xF8,
+	0x59, 0x06, 0x03, 0xEB, 0x40, 0x00, 0x02, 0xF0, 0x7A, 0xF9, 0x20, 0x68,
+	0x90, 0xF8, 0x68, 0x18,
+	0x90, 0xF8, 0x69, 0x08, 0x05, 0xEB, 0x40, 0x00, 0x02, 0xF0, 0x88, 0xF9,
+	0x0B, 0x48, 0x41, 0x78,
+	0x01, 0xB1, 0x02, 0x21, 0x01, 0x70, 0xC9, 0xB2, 0x68, 0x46, 0xEC, 0xF7,
+	0x7F, 0xFA, 0x0B, 0x49,
+	0x68, 0x46, 0xEC, 0xF7, 0xB0, 0xFA, 0x00, 0x20, 0x29, 0xB0, 0x30, 0xBD,
+	0xFF, 0xE7, 0x01, 0x20,
+	0xFA, 0xE7, 0xA4, 0x22, 0x03, 0x49, 0x02, 0xF0, 0x18, 0xBC, 0x00, 0x00,
+	0xC8, 0x07, 0x10, 0x00,
+	0x74, 0xA0, 0x01, 0x20, 0xE0, 0x7E, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x95, 0x42, 0x01, 0x00,
+	0x10, 0xB5, 0x04, 0x00, 0x03, 0xD0, 0xBD, 0xE8, 0x10, 0x40, 0x02, 0xF0,
+	0xB6, 0xB8, 0xFE, 0x48,
+	0x02, 0x46, 0x81, 0x78, 0x52, 0x78, 0x29, 0xB1, 0xFC, 0x49, 0xA1, 0xF1,
+	0x0A, 0x00, 0x02, 0xF0,
+	0xD7, 0xF8, 0x0B, 0xE0, 0x03, 0x78, 0x00, 0x21, 0x01, 0x2B, 0x00, 0xD8,
+	0x11, 0x46, 0xF7, 0x48,
+	0x52, 0x00, 0x00, 0xEB, 0x41, 0x01, 0x0A, 0x38, 0x02, 0xF0, 0xEF, 0xFB,
+	0xF3, 0x48, 0xF4, 0x49,
+	0x0A, 0x38, 0xC8, 0x62, 0x20, 0x46, 0xDE, 0xE7, 0x2D, 0xE9, 0xF0, 0x47,
+	0xDF, 0xF8, 0xC4, 0xA3,
+	0x01, 0x27, 0xB8, 0x46, 0xDA, 0xF8, 0x00, 0x00, 0x00, 0xF2, 0x5E, 0x64,
+	0x90, 0xF8, 0x22, 0x1A,
+	0x90, 0xF8, 0x1E, 0x5A, 0x01, 0xF0, 0x1F, 0x06, 0x90, 0xF8, 0x1F, 0x1A,
+	0x01, 0xF0, 0x0F, 0x09,
+	0x90, 0xF8, 0x02, 0x1A, 0x89, 0x06, 0x09, 0xD5, 0x90, 0xF8, 0x5C, 0x16,
+	0x90, 0xF8, 0x5D, 0x06,
+	0x0A, 0x22, 0x04, 0xEB, 0x40, 0x00, 0x02, 0xF0, 0xE7, 0xF8, 0x07, 0x46,
+	0xDA, 0xF8, 0x00, 0x00,
+	0x90, 0xF8, 0x02, 0x1A, 0x49, 0x06, 0x09, 0xD5, 0x90, 0xF8, 0x6C, 0x18,
+	0x90, 0xF8, 0x6D, 0x08,
+	0x0A, 0x22, 0x04, 0xEB, 0x40, 0x00, 0x02, 0xF0, 0xD7, 0xF8, 0x80, 0x46,
+	0x4F, 0xF4, 0x80, 0x70,
+	0x85, 0x42, 0x00, 0xD9, 0x05, 0x46, 0x1F, 0x2E, 0x00, 0xD9, 0x1F, 0x26,
+	0x76, 0x1C, 0x75, 0x43,
+	0x09, 0xF1, 0x01, 0x00, 0x45, 0x43, 0xC5, 0xEB, 0x45, 0x20, 0x78, 0x43,
+	0x00, 0xFB, 0x08, 0xF0,
+	0xC0, 0x13, 0xB0, 0xFA, 0x80, 0xF0, 0xC0, 0xF1, 0x20, 0x00, 0xC0, 0xB2,
+	0xBD, 0xE8, 0xF0, 0x87,
+	0x2D, 0xE9, 0xF0, 0x41, 0x04, 0x46, 0xEB, 0xF7, 0x3F, 0xFF, 0xC8, 0x48,
+	0xEB, 0xF7, 0x41, 0xFF,
+	0xA4, 0xF8, 0x76, 0x00, 0x02, 0xF0, 0xA5, 0xF8, 0x01, 0x46, 0x20, 0x46,
+	0xEC, 0xF7, 0xAA, 0xF9,
+	0x02, 0xF0, 0xA4, 0xF8, 0x02, 0x46, 0x0B, 0x46, 0x20, 0x46, 0xEC, 0xF7,
+	0xC5, 0xF9, 0x04, 0x21,
+	0x20, 0x46, 0xEB, 0xF7, 0x5C, 0xFF, 0xBF, 0x4D, 0x28, 0x68, 0x90, 0xF8,
+	0x1E, 0x0A, 0xA0, 0x70,
+	0x28, 0x68, 0x21, 0x8E, 0xB0, 0xF8, 0x23, 0x2A, 0x62, 0xF3, 0x08, 0x01,
+	0x21, 0x86, 0x90, 0xF8,
+	0x1F, 0x0A, 0x00, 0xF0, 0x0F, 0x01, 0x20, 0x46, 0xEB, 0xF7, 0xA9, 0xFF,
+	0x28, 0x68, 0x34, 0xF8,
+	0x1A, 0x1F, 0xB0, 0xF8, 0x0E, 0x2A, 0x62, 0xF3, 0x0B, 0x01, 0x24, 0xF8,
+	0x12, 0x19, 0xB0, 0xF8,
+	0x0C, 0x2A, 0x21, 0x89, 0x62, 0xF3, 0x0B, 0x01, 0x21, 0x81, 0xB0, 0xF8,
+	0x0A, 0x2A, 0xA1, 0x88,
+	0x62, 0xF3, 0x0B, 0x01, 0xA1, 0x80, 0x90, 0xF8, 0x20, 0x2A, 0xA1, 0x7A,
+	0x62, 0xF3, 0x01, 0x01,
+	0xA1, 0x72, 0x90, 0xF8, 0x20, 0x2A, 0x92, 0x08, 0x62, 0xF3, 0x87, 0x11,
+	0xA1, 0x72, 0x90, 0xF8,
+	0x02, 0x1A, 0x14, 0xF8, 0x01, 0x2C, 0x61, 0xF3, 0x00, 0x02, 0x04, 0xF8,
+	0x01, 0x2C, 0x90, 0xF8,
+	0x05, 0x0A, 0x60, 0x70, 0xA0, 0x48, 0x90, 0xF8, 0x80, 0x1F, 0xA1, 0x75,
+	0x90, 0xF8, 0x81, 0x1F,
+	0x21, 0x77, 0x90, 0xF8, 0x82, 0x1F, 0xE1, 0x75, 0x90, 0xF8, 0x83, 0x1F,
+	0x61, 0x77, 0x90, 0xF8,
+	0x84, 0x1F, 0x21, 0x76, 0x90, 0xF8, 0x85, 0x0F, 0xA0, 0x77, 0x98, 0x48,
+	0xEB, 0xF7, 0xD9, 0xFE,
+	0xA4, 0xF8, 0x78, 0x00, 0x95, 0x48, 0x20, 0x30, 0xEB, 0xF7, 0xD3, 0xFE,
+	0xA4, 0xF8, 0x7C, 0x00,
+	0x28, 0x68, 0x23, 0x7D, 0x90, 0xF8, 0x12, 0x1A, 0x09, 0x09, 0x61, 0xF3,
+	0x07, 0x13, 0x23, 0x75,
+	0x90, 0xF8, 0x17, 0x1A, 0xA6, 0x7E, 0x09, 0x09, 0x61, 0xF3, 0x07, 0x16,
+	0xA6, 0x76, 0x90, 0xF8,
+	0x13, 0x1A, 0x62, 0x7D, 0x61, 0xF3, 0x03, 0x02, 0x62, 0x75, 0x90, 0xF8,
+	0x18, 0x7A, 0xE1, 0x7E,
+	0x67, 0xF3, 0x03, 0x01, 0xE1, 0x76, 0x90, 0xF8, 0x13, 0x7A, 0x3F, 0x09,
+	0x67, 0xF3, 0x07, 0x12,
+	0x62, 0x75, 0x90, 0xF8, 0x18, 0x2A, 0x12, 0x09, 0x62, 0xF3, 0x07, 0x11,
+	0xE1, 0x76, 0x90, 0xF8,
+	0x12, 0x1A, 0x61, 0xF3, 0x00, 0x03, 0x23, 0x75, 0x90, 0xF8, 0x17, 0x1A,
+	0x61, 0xF3, 0x00, 0x06,
+	0xA6, 0x76, 0x90, 0xF8, 0x07, 0x0A, 0x01, 0x09, 0xE0, 0x78, 0x61, 0xF3,
+	0x03, 0x00, 0xE0, 0x70,
+	0x76, 0x48, 0x48, 0x38, 0xEB, 0xF7, 0x95, 0xFE, 0xA4, 0xF8, 0x76, 0x00,
+	0x73, 0x48, 0x28, 0x38,
+	0xEB, 0xF7, 0x8F, 0xFE, 0xA4, 0xF8, 0x7A, 0x00, 0x28, 0x68, 0x90, 0xF8,
+	0x04, 0x1A, 0xCA, 0x08,
+	0x14, 0xF8, 0x1F, 0x1F, 0x62, 0xF3, 0x83, 0x01, 0x41, 0xF0, 0x01, 0x01,
+	0x21, 0x70, 0x90, 0xF8,
+	0x04, 0x2A, 0x92, 0x08, 0x62, 0xF3, 0x41, 0x01, 0x04, 0xF8, 0x27, 0x19,
+	0x90, 0xF8, 0x03, 0x0A,
+	0xC0, 0xF3, 0x81, 0x01, 0x20, 0x46, 0xEB, 0xF7, 0xEF, 0xFE, 0x28, 0x68,
+	0x90, 0xF8, 0x03, 0x0A,
+	0x01, 0x09, 0x14, 0xF8, 0x28, 0x0F, 0x61, 0xF3, 0x04, 0x10, 0x20, 0x70,
+	0x60, 0x48, 0xEB, 0xF7,
+	0x68, 0xFE, 0xA4, 0xF8, 0x60, 0x00, 0x5E, 0x48, 0x20, 0x30, 0xEB, 0xF7,
+	0x62, 0xFE, 0xA4, 0xF8,
+	0x62, 0x00, 0x28, 0x68, 0x90, 0xF8, 0x02, 0x1A, 0xCA, 0x08, 0xE1, 0x7A,
+	0x62, 0xF3, 0x45, 0x11,
+	0xE1, 0x72, 0x90, 0xF8, 0x03, 0x0A, 0x41, 0x08, 0x20, 0x78, 0x61, 0xF3,
+	0x45, 0x10, 0x04, 0xF8,
+	0x28, 0x09, 0x20, 0x46, 0x02, 0xF0, 0x4A, 0xF8, 0x28, 0x68, 0x90, 0xF8,
+	0x06, 0x0A, 0x81, 0x09,
+	0x20, 0x46, 0xEB, 0xF7, 0xAE, 0xFE, 0x14, 0xF8, 0x32, 0x0F, 0x20, 0xF0,
+	0x0F, 0x00, 0x0A, 0x30,
+	0x20, 0xF0, 0xF0, 0x00, 0xA0, 0x30, 0x04, 0xF8, 0x1C, 0x09, 0x29, 0x68,
+	0x91, 0xF8, 0x02, 0x0A,
+	0x82, 0x09, 0x60, 0x7F, 0x62, 0xF3, 0x00, 0x00, 0x60, 0x77, 0x91, 0xF8,
+	0x02, 0x2A, 0x52, 0x09,
+	0x62, 0xF3, 0x41, 0x00, 0x60, 0x77, 0x91, 0xF8, 0x08, 0x2A, 0x62, 0xF3,
+	0x82, 0x00, 0x60, 0x77,
+	0x91, 0xF8, 0x21, 0x0A, 0xE2, 0x7D, 0x60, 0xF3, 0x04, 0x02, 0xE2, 0x75,
+	0x91, 0xF8, 0x22, 0x0A,
+	0xA1, 0x7D, 0x60, 0xF3, 0x04, 0x01, 0x35, 0x48, 0xA1, 0x75, 0x10, 0x38,
+	0x94, 0xF8, 0x49, 0x10,
+	0x40, 0x78, 0x60, 0xF3, 0x04, 0x01, 0x35, 0x48, 0x84, 0xF8, 0x49, 0x10,
+	0x50, 0x30, 0xEB, 0xF7,
+	0x10, 0xFE, 0xA4, 0xF8, 0x64, 0x00, 0x28, 0x68, 0x34, 0xF8, 0x18, 0x1F,
+	0xB0, 0xF8, 0x10, 0x2A,
+	0x62, 0xF3, 0x0B, 0x01, 0x24, 0xF8, 0x0A, 0x1B, 0x90, 0xF8, 0x06, 0x1A,
+	0xCA, 0x08, 0x21, 0x78,
+	0x62, 0xF3, 0x02, 0x01, 0x04, 0xF8, 0x0E, 0x19, 0x10, 0xF8, 0xE0, 0x1F,
+	0x22, 0x78, 0x61, 0xF3,
+	0x03, 0x02, 0x04, 0xF8, 0x01, 0x2B, 0x01, 0x78, 0x0A, 0x09, 0x21, 0x78,
+	0x62, 0xF3, 0x03, 0x01,
+	0x04, 0xF8, 0x02, 0x19, 0x90, 0xF8, 0x27, 0x19, 0x22, 0x78, 0x61, 0xF3,
+	0x02, 0x02, 0x04, 0xF8,
+	0x0B, 0x2B, 0x90, 0xF8, 0x22, 0x19, 0xCA, 0x09, 0x21, 0x78, 0x62, 0xF3,
+	0x00, 0x01, 0x04, 0xF8,
+	0x0E, 0x1B, 0x14, 0xF8, 0x1D, 0x1F, 0x41, 0xF0, 0x20, 0x01, 0x21, 0x70,
+	0x90, 0xF8, 0x24, 0x29,
+	0xD2, 0x09, 0x62, 0xF3, 0xC7, 0x11, 0x04, 0xF8, 0x01, 0x1B, 0xB0, 0xF8,
+	0x3C, 0x29, 0x21, 0x88,
+	0x62, 0xF3, 0x08, 0x01, 0x24, 0xF8, 0x02, 0x1B, 0x00, 0x21, 0x44, 0xF8,
+	0x2F, 0x19, 0x90, 0xF8,
+	0x27, 0x19, 0xCA, 0x08, 0x21, 0x78, 0x62, 0xF3, 0xC3, 0x01, 0x21, 0x70,
+	0x90, 0xF8, 0x22, 0x29,
+	0x12, 0x09, 0x62, 0xF3, 0x04, 0x11, 0x04, 0xF8, 0x0C, 0x19, 0x14, 0xF8,
+	0x1F, 0x19, 0x21, 0xF0,
+	0x10, 0x01, 0xE1, 0x77, 0x0E, 0xE0, 0x00, 0x00, 0xCD, 0x07, 0x10, 0x00,
+	0x70, 0xA1, 0x01, 0x20,
+	0xB4, 0x84, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00, 0x78, 0x8B, 0x01, 0x20,
+	0xB0, 0x9A, 0x01, 0x20,
+	0x48, 0xBF, 0x01, 0x20, 0x90, 0xF8, 0x41, 0x19, 0x4A, 0x09, 0x21, 0x78,
+	0x62, 0xF3, 0x06, 0x11,
+	0x21, 0x70, 0x90, 0xF8, 0x23, 0x19, 0x4A, 0x09, 0x21, 0x7C, 0x62, 0xF3,
+	0xC3, 0x01, 0x21, 0x74,
+	0x90, 0xF8, 0x22, 0x29, 0x52, 0x08, 0x62, 0xF3, 0x04, 0x11, 0x21, 0x74,
+	0x90, 0xF8, 0x24, 0x09,
+	0x80, 0x09, 0x60, 0xF3, 0x86, 0x11, 0x21, 0x74, 0xBD, 0xE8, 0xF0, 0x81,
+	0xF8, 0xB5, 0x01, 0xF0,
+	0xF0, 0xFE, 0x00, 0x90, 0x04, 0x21, 0x68, 0x46, 0xEC, 0xF7, 0x2D, 0xFA,
+	0x45, 0x4E, 0x46, 0x4D,
+	0x70, 0x70, 0x00, 0x20, 0x28, 0x60, 0x28, 0x71, 0x01, 0x24, 0xE0, 0xB2,
+	0xFF, 0xF7, 0xE4, 0xFD,
+	0x28, 0x55, 0x64, 0x1C, 0x05, 0x2C, 0xF8, 0xDB, 0x40, 0x48, 0xFF, 0xF7,
+	0x29, 0xFE, 0x40, 0x48,
+	0x00, 0x68, 0x90, 0xF8, 0x03, 0x0A, 0xC0, 0xF3, 0x80, 0x10, 0xB0, 0x70,
+	0xF8, 0xBD, 0x30, 0xB5,
+	0x81, 0x7A, 0xA9, 0xB0, 0x79, 0xB3, 0x68, 0x46, 0x00, 0xF0, 0x30, 0xF8,
+	0x9D, 0xF8, 0x12, 0x00,
+	0x00, 0xF0, 0x03, 0x00, 0x01, 0xF0, 0x22, 0xFF, 0x35, 0x4C, 0x20, 0x68,
+	0x00, 0xF2, 0x5E, 0x63,
+	0x00, 0xF6, 0x6E, 0x05, 0x90, 0xF8, 0x5C, 0x16, 0x90, 0xF8, 0x5D, 0x06,
+	0x03, 0xEB, 0x40, 0x00,
+	0x01, 0xF0, 0xE5, 0xFE, 0x20, 0x68, 0x90, 0xF8, 0x6C, 0x18, 0x90, 0xF8,
+	0x6D, 0x08, 0x05, 0xEB,
+	0x40, 0x00, 0x01, 0xF0, 0xF3, 0xFE, 0x27, 0x48, 0x81, 0x78, 0x01, 0xB1,
+	0x02, 0x21, 0x01, 0x70,
+	0xC9, 0xB2, 0x68, 0x46, 0xEB, 0xF7, 0xEA, 0xFF, 0x26, 0x49, 0x68, 0x46,
+	0xEC, 0xF7, 0x1B, 0xF8,
+	0x00, 0x20, 0x29, 0xB0, 0x30, 0xBD, 0xFF, 0xE7, 0x01, 0x20, 0xFA, 0xE7,
+	0x70, 0xB5, 0x01, 0x29,
+	0x20, 0xD0, 0x1D, 0x4D, 0x03, 0x29, 0x21, 0xD0, 0x04, 0x29, 0x2E, 0xD1,
+	0x04, 0x46, 0x1B, 0x48,
+	0xFF, 0xF7, 0xDE, 0xFD, 0x20, 0x46, 0x00, 0xF0, 0x29, 0xF8, 0x28, 0x79,
+	0x94, 0xF8, 0x5F, 0x10,
+	0x60, 0xF3, 0x04, 0x01, 0x84, 0xF8, 0x5F, 0x10, 0x94, 0xF8, 0x27, 0x00,
+	0x20, 0xF0, 0x02, 0x00,
+	0x40, 0xF0, 0x01, 0x00, 0x84, 0xF8, 0x27, 0x00, 0x20, 0x46, 0xBD, 0xE8,
+	0x70, 0x40, 0x00, 0x21,
+	0xEB, 0xF7, 0x9D, 0xBD, 0xBD, 0xE8, 0x70, 0x40, 0x00, 0xF0, 0x10, 0xB8,
+	0x04, 0x46, 0x0B, 0x48,
+	0xFF, 0xF7, 0xBE, 0xFD, 0x20, 0x46, 0x00, 0xF0, 0x09, 0xF8, 0xE8, 0x78,
+	0x94, 0xF8, 0x5F, 0x10,
+	0x60, 0xF3, 0x04, 0x01, 0x84, 0xF8, 0x5F, 0x10, 0xE6, 0xE7, 0x70, 0xBD,
+	0xA4, 0x22, 0x03, 0x49,
+	0x02, 0xF0, 0x4B, 0xB9, 0xCD, 0x07, 0x10, 0x00, 0x60, 0xA1, 0x01, 0x20,
+	0x84, 0x7F, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0xF1, 0x48, 0x01, 0x00, 0x10, 0xB5, 0x04, 0x00,
+	0x03, 0xD0, 0xBD, 0xE8,
+	0x10, 0x40, 0x01, 0xF0, 0xEA, 0xBD, 0x23, 0x48, 0x23, 0x49, 0x00, 0x78,
+	0x42, 0x00, 0x01, 0xEB,
+	0x40, 0x01, 0x21, 0x48, 0x98, 0x30, 0x02, 0xF0, 0x30, 0xF9, 0x1F, 0x48,
+	0x1F, 0x49, 0x98, 0x30,
+	0x48, 0x62, 0x20, 0x46, 0xEB, 0xE7, 0x38, 0xB5, 0x01, 0xF0, 0x26, 0xFE,
+	0x00, 0x90, 0x04, 0x21,
+	0x68, 0x46, 0xEC, 0xF7, 0x78, 0xF9, 0x17, 0x49, 0x19, 0x4C, 0x08, 0x70,
+	0x20, 0x46, 0x00, 0xF0,
+	0x19, 0xFB, 0x18, 0x48, 0x01, 0x68, 0xA0, 0x7C, 0x91, 0xF8, 0x50, 0x21,
+	0x62, 0xF3, 0x01, 0x00,
+	0xA0, 0x74, 0x91, 0xF8, 0x50, 0x11, 0x89, 0x08, 0x61, 0xF3, 0x87, 0x10,
+	0xA0, 0x74, 0x38, 0xBD,
+	0x10, 0xB5, 0x0F, 0x4C, 0xC0, 0x79, 0x98, 0xB1, 0x20, 0x46, 0x01, 0xF0,
+	0x2F, 0xFF, 0xA0, 0x7C,
+	0x00, 0xF0, 0x03, 0x00, 0x01, 0xF0, 0x72, 0xFE, 0x00, 0xF0, 0x8D, 0xFB,
+	0x04, 0x21, 0x20, 0x46,
+	0xEB, 0xF7, 0x54, 0xFF, 0x08, 0x49, 0x20, 0x46, 0xEB, 0xF7, 0x85, 0xFF,
+	0x00, 0x20, 0x10, 0xBD,
+	0x01, 0x20, 0x10, 0xBD, 0xD0, 0x07, 0x10, 0x00, 0x80, 0xA1, 0x01, 0x20,
+	0xB4, 0x84, 0x10, 0x00,
+	0x28, 0x80, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00, 0x89, 0x4E, 0x01, 0x00,
+	0xFE, 0x49, 0xC8, 0x68,
+	0x40, 0x1C, 0xC8, 0x60, 0x02, 0x28, 0x03, 0xD2, 0xFC, 0x49, 0x51, 0xF8,
+	0x20, 0x00, 0x00, 0x47,
+	0x00, 0x20, 0x01, 0xF0, 0x8A, 0xBD, 0x00, 0x28, 0x01, 0xD1, 0xEB, 0xF7,
+	0x55, 0xBF, 0x70, 0x47,
+	0xF5, 0x49, 0x10, 0xB5, 0x0A, 0x79, 0x01, 0x20, 0x52, 0x1C, 0xD2, 0xB2,
+	0x0A, 0x71, 0x0B, 0x7A,
+	0x9A, 0x42, 0x0A, 0xD8, 0x48, 0x7A, 0x48, 0xB1, 0xEB, 0xF7, 0xB6, 0xFE,
+	0x03, 0x20, 0xEB, 0xF7,
+	0x91, 0xF9, 0xEF, 0x48, 0xEB, 0xF7, 0xA4, 0xFE, 0x00, 0x20, 0x10, 0xBD,
+	0xEB, 0xF7, 0x3C, 0xFF,
+	0xFA, 0xE7, 0x70, 0xB5, 0x18, 0xB1, 0xBD, 0xE8, 0x70, 0x40, 0x01, 0xF0,
+	0x66, 0xBD, 0xE6, 0x4C,
+	0x20, 0x7A, 0x08, 0xB1, 0xE7, 0x4D, 0x01, 0xE0, 0xE6, 0x4D, 0x76, 0x3D,
+	0xA0, 0x78, 0xE6, 0x49,
+	0x82, 0x00, 0x01, 0xF5, 0xAE, 0x70, 0x02, 0xF0, 0xED, 0xF8, 0x60, 0x79,
+	0x28, 0xB1, 0xA2, 0x78,
+	0xE1, 0x49, 0x28, 0x46, 0x01, 0xF0, 0x7C, 0xFD, 0x0C, 0xE0, 0xA1, 0x78,
+	0x60, 0x78, 0x01, 0xF0,
+	0xB9, 0xFE, 0xA1, 0x78, 0xC0, 0xB2, 0x4A, 0x00, 0xDB, 0x49, 0x01, 0xEB,
+	0x40, 0x01, 0x28, 0x46,
+	0x02, 0xF0, 0x93, 0xF8, 0xD7, 0x48, 0x23, 0x79, 0xA2, 0x78, 0x29, 0x46,
+	0x76, 0x38, 0x01, 0xF0,
+	0x77, 0xFD, 0xFF, 0xF7, 0xB5, 0xFF, 0x00, 0x28, 0x15, 0xD0, 0xA0, 0x79,
+	0xD3, 0x4D, 0x01, 0x28,
+	0x0B, 0xD0, 0xD0, 0x48, 0x76, 0x38, 0xA8, 0x61, 0xE0, 0x79, 0x85, 0xF8,
+	0x30, 0x00, 0x20, 0x79,
+	0x85, 0xF8, 0x20, 0x00, 0xBD, 0xE8, 0x70, 0x40, 0x90, 0xE7, 0xCA, 0x48,
+	0xA1, 0x78, 0x76, 0x38,
+	0x01, 0xF0, 0x8E, 0xFE, 0xEF, 0xE7, 0x70, 0xBD, 0x70, 0xB5, 0x18, 0xB1,
+	0xBD, 0xE8, 0x70, 0x40,
+	0x01, 0xF0, 0x1B, 0xBD, 0xC0, 0x4C, 0x20, 0x7A, 0x08, 0xB1, 0xC2, 0x4D,
+	0x01, 0xE0, 0xC1, 0x4D,
+	0x4C, 0x3D, 0xE0, 0x78, 0xC0, 0x49, 0x82, 0x00, 0x01, 0xF5, 0xD8, 0x70,
+	0x02, 0xF0, 0xA2, 0xF8,
+	0x60, 0x79, 0x28, 0xB1, 0xE2, 0x78, 0xBC, 0x49, 0x28, 0x46, 0x01, 0xF0,
+	0x31, 0xFD, 0x0C, 0xE0,
+	0xE1, 0x78, 0x60, 0x78, 0x01, 0xF0, 0x74, 0xFE, 0xE1, 0x78, 0xC0, 0xB2,
+	0x4A, 0x00, 0xB6, 0x49,
+	0x01, 0xEB, 0x40, 0x01, 0x28, 0x46, 0x02, 0xF0, 0x48, 0xF8, 0xB2, 0x48,
+	0x23, 0x79, 0xE2, 0x78,
+	0x29, 0x46, 0x4C, 0x38, 0x01, 0xF0, 0x2C, 0xFD, 0xFF, 0xF7, 0x6A, 0xFF,
+	0x00, 0x28, 0x15, 0xD0,
+	0xA0, 0x79, 0xAE, 0x4D, 0x01, 0x28, 0x0B, 0xD0, 0xAA, 0x48, 0x4C, 0x38,
+	0xE8, 0x61, 0xE0, 0x79,
+	0x85, 0xF8, 0x30, 0x00, 0x20, 0x79, 0x85, 0xF8, 0x21, 0x00, 0xBD, 0xE8,
+	0x70, 0x40, 0x45, 0xE7,
+	0xA4, 0x48, 0xE1, 0x78, 0x4C, 0x38, 0x01, 0xF0, 0x44, 0xFE, 0xEF, 0xE7,
+	0x70, 0xBD, 0x2D, 0xE9,
+	0xF0, 0x5F, 0xA3, 0x48, 0x01, 0x27, 0xB8, 0x46, 0x00, 0x68, 0x00, 0xF2,
+	0x5E, 0x64, 0x90, 0xF8,
+	0x33, 0x11, 0x90, 0xF8, 0x4E, 0x51, 0xC1, 0xF3, 0x80, 0x1B, 0x90, 0xF8,
+	0x55, 0x11, 0x01, 0xF0,
+	0x03, 0x0A, 0x90, 0xF8, 0x52, 0x11, 0x01, 0xF0, 0x1F, 0x06, 0x90, 0xF8,
+	0x4F, 0x11, 0x01, 0xF0,
+	0x0F, 0x09, 0x90, 0xF8, 0x32, 0x11, 0x89, 0x06, 0x09, 0xD5, 0x90, 0xF8,
+	0x56, 0x16, 0x90, 0xF8,
+	0x57, 0x06, 0x0A, 0x22, 0x04, 0xEB, 0x40, 0x00, 0x01, 0xF0, 0x1E, 0xFD,
+	0x07, 0x46, 0x90, 0x48,
+	0x00, 0x68, 0x90, 0xF8, 0x32, 0x11, 0x49, 0x06, 0x09, 0xD5, 0x90, 0xF8,
+	0x66, 0x18, 0x90, 0xF8,
+	0x67, 0x08, 0x0A, 0x22, 0x04, 0xEB, 0x40, 0x00, 0x01, 0xF0, 0x0E, 0xFD,
+	0x80, 0x46, 0x4F, 0xF4,
+	0x80, 0x70, 0x85, 0x42, 0x00, 0xD9, 0x05, 0x46, 0x1F, 0x2E, 0x00, 0xD9,
+	0x1F, 0x26, 0x76, 0x1C,
+	0x75, 0x43, 0x09, 0xF1, 0x01, 0x00, 0x45, 0x43, 0xC5, 0xEB, 0x45, 0x20,
+	0x78, 0x43, 0x00, 0xFB,
+	0x08, 0xF0, 0x0A, 0xF1, 0x01, 0x01, 0x48, 0x43, 0x0B, 0xF1, 0x01, 0x01,
+	0x48, 0x43, 0xC0, 0x13,
+	0xB0, 0xFA, 0x80, 0xF0, 0xC0, 0xF1, 0x20, 0x00, 0xC0, 0xB2, 0xBD, 0xE8,
+	0xF0, 0x9F, 0x2D, 0xE9,
+	0xF0, 0x41, 0x04, 0x46, 0xEB, 0xF7, 0x70, 0xFB, 0x73, 0x48, 0xEB, 0xF7,
+	0x72, 0xFB, 0xA4, 0xF8,
+	0x76, 0x00, 0x01, 0xF0, 0xC1, 0xFC, 0x01, 0x46, 0x20, 0x46, 0xEB, 0xF7,
+	0xDB, 0xFD, 0x01, 0xF0,
+	0xBF, 0xFC, 0x02, 0x46, 0x0B, 0x46, 0x20, 0x46, 0xEB, 0xF7, 0xF6, 0xFD,
+	0x20, 0x46, 0x01, 0xF0,
+	0xF1, 0xFD, 0x6B, 0x4D, 0xB4, 0xF8, 0x56, 0x10, 0x28, 0x68, 0xB0, 0xF8,
+	0xBE, 0x20, 0x62, 0xF3,
+	0x09, 0x01, 0xA4, 0xF8, 0x56, 0x10, 0x90, 0xF8, 0xBD, 0x10, 0x94, 0xF8,
+	0x55, 0x00, 0x61, 0xF3,
+	0x03, 0x00, 0x84, 0xF8, 0x55, 0x00, 0x04, 0x21, 0x20, 0x46, 0xEB, 0xF7,
+	0x78, 0xFB, 0x28, 0x68,
+	0x90, 0xF8, 0x4E, 0x01, 0xA0, 0x70, 0x28, 0x68, 0x21, 0x8E, 0xB0, 0xF8,
+	0x53, 0x21, 0x62, 0xF3,
+	0x08, 0x01, 0x21, 0x86, 0x90, 0xF8, 0x4F, 0x01, 0x00, 0xF0, 0x0F, 0x01,
+	0x20, 0x46, 0xEB, 0xF7,
+	0xC6, 0xFB, 0x28, 0x68, 0x34, 0xF8, 0x1A, 0x1F, 0xB0, 0xF8, 0x3E, 0x21,
+	0x62, 0xF3, 0x0B, 0x01,
+	0x24, 0xF8, 0x12, 0x19, 0xB0, 0xF8, 0x3C, 0x21, 0x21, 0x89, 0x62, 0xF3,
+	0x0B, 0x01, 0x21, 0x81,
+	0xB0, 0xF8, 0x3A, 0x21, 0xA1, 0x88, 0x62, 0xF3, 0x0B, 0x01, 0xA1, 0x80,
+	0x90, 0xF8, 0x50, 0x21,
+	0xA1, 0x7A, 0x62, 0xF3, 0x01, 0x01, 0xA1, 0x72, 0x90, 0xF8, 0x50, 0x21,
+	0x92, 0x08, 0x62, 0xF3,
+	0x87, 0x11, 0xA1, 0x72, 0x90, 0xF8, 0x32, 0x11, 0x14, 0xF8, 0x01, 0x2C,
+	0x61, 0xF3, 0x00, 0x02,
+	0x04, 0xF8, 0x01, 0x2C, 0x90, 0xF8, 0x35, 0x01, 0x60, 0x70, 0x42, 0x48,
+	0x90, 0xF8, 0x50, 0x1E,
+	0xA1, 0x75, 0x90, 0xF8, 0x51, 0x1E, 0x21, 0x77, 0x90, 0xF8, 0x52, 0x1E,
+	0xE1, 0x75, 0x90, 0xF8,
+	0x53, 0x1E, 0x61, 0x77, 0x90, 0xF8, 0x54, 0x1E, 0x21, 0x76, 0x90, 0xF8,
+	0x55, 0x0E, 0xA0, 0x77,
+	0x39, 0x48, 0xEB, 0xF7, 0xF6, 0xFA, 0xA4, 0xF8, 0x78, 0x00, 0x37, 0x48,
+	0x20, 0x30, 0xEB, 0xF7,
+	0xF0, 0xFA, 0xA4, 0xF8, 0x7C, 0x00, 0x28, 0x68, 0x90, 0xF8, 0x42, 0x11,
+	0x0A, 0x09, 0x21, 0x7D,
+	0x62, 0xF3, 0x07, 0x11, 0x21, 0x75, 0x90, 0xF8, 0x47, 0x21, 0xA3, 0x7E,
+	0x12, 0x09, 0x62, 0xF3,
+	0x07, 0x13, 0xA3, 0x76, 0x90, 0xF8, 0x43, 0x61, 0x62, 0x7D, 0x66, 0xF3,
+	0x03, 0x02, 0x62, 0x75,
+	0x90, 0xF8, 0x48, 0x71, 0xE6, 0x7E, 0x67, 0xF3, 0x03, 0x06, 0xE6, 0x76,
+	0x90, 0xF8, 0x43, 0x71,
+	0x3F, 0x09, 0x67, 0xF3, 0x07, 0x12, 0x62, 0x75, 0x90, 0xF8, 0x48, 0x21,
+	0x12, 0x09, 0x62, 0xF3,
+	0x07, 0x16, 0xE6, 0x76, 0x90, 0xF8, 0x42, 0x21, 0x62, 0xF3, 0x00, 0x01,
+	0x21, 0x75, 0x90, 0xF8,
+	0x47, 0x11, 0x61, 0xF3, 0x00, 0x03, 0xA3, 0x76, 0x90, 0xF8, 0x37, 0x01,
+	0x01, 0x09, 0xE0, 0x78,
+	0x61, 0xF3, 0x03, 0x00, 0xE0, 0x70, 0x18, 0x48, 0x48, 0x38, 0xEB, 0xF7,
+	0xB2, 0xFA, 0xA4, 0xF8,
+	0x76, 0x00, 0x15, 0x48, 0x28, 0x38, 0xEB, 0xF7, 0xAC, 0xFA, 0xA4, 0xF8,
+	0x7A, 0x00, 0x29, 0x68,
+	0x91, 0xF8, 0x34, 0x01, 0xC2, 0x08, 0x14, 0xF8, 0x1F, 0x0F, 0x62, 0xF3,
+	0x83, 0x00, 0x20, 0x70,
+	0x91, 0xF8, 0x34, 0x21, 0x52, 0x08, 0x62, 0xF3, 0x00, 0x00, 0x20, 0x70,
+	0x91, 0xF8, 0x34, 0x21,
+	0x92, 0x08, 0x62, 0xF3, 0x41, 0x00, 0x11, 0xE0, 0xD4, 0x07, 0x10, 0x00,
+	0x04, 0x7D, 0x01, 0x00,
+	0x57, 0x4F, 0x01, 0x00, 0x7A, 0xA3, 0x01, 0x20, 0x6C, 0xA2, 0x01, 0x20,
+	0xB4, 0x84, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x78, 0x8B, 0x01, 0x20, 0x80, 0x99, 0x01, 0x20,
+	0x04, 0xF8, 0x27, 0x09,
+	0x91, 0xF8, 0x33, 0x01, 0xC0, 0xF3, 0x81, 0x01, 0x20, 0x46, 0xEB, 0xF7,
+	0xF5, 0xFA, 0x28, 0x68,
+	0x90, 0xF8, 0x33, 0x01, 0x01, 0x09, 0x14, 0xF8, 0x28, 0x0F, 0x61, 0xF3,
+	0x04, 0x10, 0x20, 0x70,
+	0xF8, 0x48, 0xEB, 0xF7, 0x6E, 0xFA, 0xA4, 0xF8, 0x60, 0x00, 0xF6, 0x48,
+	0x20, 0x30, 0xEB, 0xF7,
+	0x68, 0xFA, 0xA4, 0xF8, 0x62, 0x00, 0x28, 0x68, 0x90, 0xF8, 0x32, 0x11,
+	0xCA, 0x08, 0xE1, 0x7A,
+	0x62, 0xF3, 0x45, 0x11, 0xE1, 0x72, 0x90, 0xF8, 0x33, 0x01, 0x41, 0x08,
+	0x20, 0x78, 0x61, 0xF3,
+	0x45, 0x10, 0x04, 0xF8, 0x28, 0x09, 0x20, 0x46, 0x01, 0xF0, 0x50, 0xFC,
+	0x28, 0x68, 0x90, 0xF8,
+	0x36, 0x01, 0x81, 0x09, 0x20, 0x46, 0xEB, 0xF7, 0xB4, 0xFA, 0x14, 0xF8,
+	0x32, 0x0F, 0x20, 0xF0,
+	0x0F, 0x00, 0x0A, 0x30, 0x20, 0xF0, 0xF0, 0x00, 0xA0, 0x30, 0x04, 0xF8,
+	0x1C, 0x09, 0x29, 0x68,
+	0x91, 0xF8, 0x32, 0x01, 0x82, 0x09, 0x60, 0x7F, 0x62, 0xF3, 0x00, 0x00,
+	0x60, 0x77, 0x91, 0xF8,
+	0x32, 0x21, 0x52, 0x09, 0x62, 0xF3, 0x41, 0x00, 0x60, 0x77, 0x91, 0xF8,
+	0x38, 0x21, 0x62, 0xF3,
+	0x82, 0x00, 0x60, 0x77, 0x91, 0xF8, 0x51, 0x01, 0xE2, 0x7D, 0x60, 0xF3,
+	0x04, 0x02, 0xE2, 0x75,
+	0x91, 0xF8, 0x52, 0x01, 0xA1, 0x7D, 0x60, 0xF3, 0x04, 0x01, 0xD3, 0x48,
+	0xA1, 0x75, 0x94, 0xF8,
+	0x49, 0x10, 0x40, 0x78, 0x60, 0xF3, 0x04, 0x01, 0x84, 0xF8, 0x49, 0x10,
+	0xCF, 0x48, 0xEB, 0xF7,
+	0x18, 0xFA, 0xA4, 0xF8, 0x64, 0x00, 0x28, 0x68, 0x21, 0x8B, 0xB0, 0xF8,
+	0x40, 0x21, 0x62, 0xF3,
+	0x0B, 0x01, 0x21, 0x83, 0x90, 0xF8, 0x36, 0x11, 0xCA, 0x08, 0x94, 0xF8,
+	0x22, 0x10, 0x62, 0xF3,
+	0x02, 0x01, 0x84, 0xF8, 0x22, 0x10, 0x10, 0xF8, 0xE0, 0x1F, 0x22, 0x7D,
+	0x61, 0xF3, 0x03, 0x02,
+	0x22, 0x75, 0x10, 0xF8, 0x52, 0x1B, 0x0A, 0x09, 0x61, 0x7D, 0x62, 0xF3,
+	0x03, 0x01, 0x61, 0x75,
+	0x42, 0x79, 0xE1, 0x7C, 0x62, 0xF3, 0x02, 0x01, 0xE1, 0x74, 0x01, 0x78,
+	0xCA, 0x09, 0xA1, 0x7F,
+	0x62, 0xF3, 0x00, 0x01, 0xA1, 0x77, 0x94, 0xF8, 0x49, 0x10, 0x41, 0xF0,
+	0x20, 0x01, 0x84, 0xF8,
+	0x49, 0x10, 0x82, 0x78, 0xD2, 0x09, 0x62, 0xF3, 0xC7, 0x11, 0x84, 0xF8,
+	0x49, 0x10, 0x42, 0x8B,
+	0xB4, 0xF8, 0x4A, 0x10, 0x62, 0xF3, 0x08, 0x01, 0xA4, 0xF8, 0x4A, 0x10,
+	0x00, 0x21, 0xE1, 0x64,
+	0x41, 0x79, 0xCA, 0x08, 0x61, 0x7F, 0x62, 0xF3, 0xC3, 0x01, 0x61, 0x77,
+	0x02, 0x78, 0x12, 0x09,
+	0x62, 0xF3, 0x04, 0x11, 0x61, 0x77, 0xC1, 0x7F, 0x4A, 0x09, 0x14, 0xF8,
+	0x0E, 0x1C, 0x62, 0xF3,
+	0x06, 0x11, 0x04, 0xF8, 0x0E, 0x1C, 0x41, 0x78, 0x4A, 0x09, 0xA1, 0x78,
+	0x62, 0xF3, 0xC3, 0x01,
+	0xA1, 0x70, 0x02, 0x78, 0x52, 0x08, 0x62, 0xF3, 0x04, 0x11, 0xA1, 0x70,
+	0x82, 0x78, 0x92, 0x09,
+	0x62, 0xF3, 0x86, 0x11, 0xA1, 0x70, 0x40, 0x78, 0x9D, 0x49, 0xC0, 0xF3,
+	0x80, 0x10, 0x48, 0x71,
+	0xBD, 0xE8, 0xF0, 0x81, 0xA4, 0x22, 0x9B, 0x49, 0x01, 0xF0, 0xFF, 0xBD,
+	0x2D, 0xE9, 0xF0, 0x41,
+	0x97, 0x4D, 0x00, 0x26, 0x01, 0x27, 0x2E, 0x71, 0x2E, 0x72, 0xAF, 0x71,
+	0x0C, 0x46, 0x6E, 0x72,
+	0x01, 0x28, 0x07, 0xD0, 0x90, 0x4F, 0x02, 0x28, 0x2C, 0xD0, 0x03, 0x28,
+	0x14, 0xD0, 0x04, 0x28,
+	0x3A, 0xD1, 0x43, 0xE0, 0x08, 0x46, 0xFF, 0xF7, 0xE5, 0xFF, 0x8F, 0x48,
+	0x01, 0x68, 0x91, 0xF8,
+	0x38, 0x01, 0x42, 0x06, 0x30, 0xD5, 0x91, 0xF8, 0x55, 0x11, 0x00, 0x06,
+	0x01, 0xF0, 0x03, 0x01,
+	0x29, 0x72, 0x29, 0xD5, 0x6F, 0x72, 0x27, 0xE0, 0x86, 0x48, 0xFF, 0xF7,
+	0x08, 0xFE, 0x20, 0x46,
+	0xFF, 0xF7, 0xD0, 0xFF, 0xF8, 0x78, 0x94, 0xF8, 0x5F, 0x10, 0x60, 0xF3,
+	0x04, 0x01, 0x84, 0xF8,
+	0x5F, 0x10, 0x94, 0xF8, 0x27, 0x00, 0x20, 0xF0, 0x02, 0x00, 0x40, 0xF0,
+	0x01, 0x00, 0x84, 0xF8,
+	0x27, 0x00, 0x0C, 0xE0, 0x7B, 0x48, 0xFF, 0xF7, 0xF2, 0xFD, 0x20, 0x46,
+	0xFF, 0xF7, 0xBA, 0xFF,
+	0xB8, 0x78, 0x94, 0xF8, 0x5F, 0x10, 0x60, 0xF3, 0x04, 0x01, 0x84, 0xF8,
+	0x5F, 0x10, 0x00, 0x21,
+	0x20, 0x46, 0xEB, 0xF7, 0xEC, 0xF9, 0xAE, 0x71, 0x20, 0x46, 0x01, 0xF0,
+	0xD7, 0xFB, 0x94, 0xF8,
+	0x27, 0x00, 0x40, 0xF3, 0x00, 0x00, 0x40, 0x1C, 0xE8, 0x71, 0xA1, 0xE7,
+	0x08, 0x46, 0xFF, 0xF7,
+	0xA1, 0xFF, 0x14, 0xF8, 0x37, 0x0F, 0x40, 0xF0, 0x10, 0x00, 0x04, 0xF8,
+	0x1F, 0x09, 0xE0, 0x7E,
+	0x20, 0xF0, 0x23, 0x00, 0xE0, 0x76, 0x34, 0xF8, 0x0C, 0x0C, 0x6F, 0xF3,
+	0x0B, 0x00, 0x10, 0x30,
+	0x24, 0xF8, 0x0C, 0x0C, 0x34, 0xF8, 0x08, 0x0C, 0x6F, 0xF3, 0x0B, 0x00,
+	0x40, 0x30, 0x24, 0xF8,
+	0x08, 0x0C, 0x08, 0x20, 0x04, 0xF8, 0x16, 0x0C, 0x94, 0xF8, 0x47, 0x00,
+	0x20, 0xF0, 0x1F, 0x00,
+	0x84, 0xF8, 0x47, 0x00, 0x34, 0xF8, 0x18, 0x0F, 0x6F, 0xF3, 0x08, 0x00,
+	0x24, 0xF8, 0x03, 0x0B,
+	0x20, 0x78, 0x40, 0xF0, 0x0C, 0x00, 0x04, 0xF8, 0x0B, 0x09, 0x20, 0x78,
+	0x40, 0xF0, 0x20, 0x00,
+	0x04, 0xF8, 0x28, 0x09, 0xBF, 0xE7, 0x70, 0xB5, 0x53, 0x4D, 0x28, 0x68,
+	0x00, 0xF2, 0x5E, 0x62,
+	0x00, 0xF6, 0x6E, 0x04, 0x90, 0xF8, 0x56, 0x16, 0x90, 0xF8, 0x57, 0x06,
+	0x02, 0xEB, 0x40, 0x00,
+	0x01, 0xF0, 0xA5, 0xFA, 0x28, 0x68, 0x90, 0xF8, 0x66, 0x18, 0x90, 0xF8,
+	0x67, 0x08, 0x04, 0xEB,
+	0x40, 0x00, 0xBD, 0xE8, 0x70, 0x40, 0x01, 0xF0, 0xB1, 0xBA, 0x70, 0xB5,
+	0x44, 0x4D, 0x45, 0x4C,
+	0x68, 0x79, 0xA4, 0x34, 0x00, 0xB1, 0x02, 0x20, 0x68, 0x70, 0x21, 0x46,
+	0x28, 0x78, 0xFF, 0xF7,
+	0x4D, 0xFF, 0x41, 0x48, 0x01, 0x68, 0xA0, 0x7C, 0x91, 0xF8, 0x50, 0x21,
+	0x62, 0xF3, 0x01, 0x00,
+	0xA0, 0x74, 0x91, 0xF8, 0x50, 0x11, 0x89, 0x08, 0x61, 0xF3, 0x87, 0x10,
+	0xA0, 0x74, 0x69, 0x78,
+	0x20, 0x46, 0xEB, 0xF7, 0x93, 0xFB, 0xA0, 0x7C, 0x00, 0xF0, 0x03, 0x00,
+	0x01, 0xF0, 0xA6, 0xFA,
+	0xFF, 0xF7, 0xC1, 0xFF, 0x20, 0x46, 0xBD, 0xE8, 0x70, 0x40, 0x34, 0x49,
+	0xEB, 0xF7, 0xBB, 0xBB,
+	0x70, 0xB5, 0x2F, 0x4D, 0x2F, 0x4C, 0x68, 0x79, 0xA4, 0x34, 0x08, 0xB1,
+	0x03, 0x20, 0x00, 0xE0,
+	0x01, 0x20, 0x68, 0x70, 0x21, 0x46, 0x28, 0x78, 0xFF, 0xF7, 0x20, 0xFF,
+	0x2A, 0x48, 0x01, 0x68,
+	0x91, 0xF8, 0x50, 0x01, 0x02, 0x09, 0xA0, 0x7C, 0x62, 0xF3, 0x01, 0x00,
+	0xA0, 0x74, 0x91, 0xF8,
+	0x50, 0x11, 0x89, 0x09, 0x61, 0xF3, 0x87, 0x10, 0xA0, 0x74, 0x69, 0x78,
+	0x20, 0x46, 0xEB, 0xF7,
+	0x65, 0xFB, 0xA0, 0x7C, 0x00, 0xF0, 0x03, 0x00, 0x01, 0xF0, 0x78, 0xFA,
+	0xFF, 0xF7, 0x93, 0xFF,
+	0x20, 0x46, 0xBD, 0xE8, 0x70, 0x40, 0x1E, 0x49, 0xEB, 0xF7, 0x8D, 0xBB,
+	0x7F, 0xB5, 0x01, 0xF0,
+	0xFB, 0xF9, 0x01, 0x90, 0x01, 0xF0, 0xFC, 0xF9, 0xCD, 0xE9, 0x02, 0x01,
+	0x04, 0x21, 0x01, 0xA8,
+	0xEB, 0xF7, 0x49, 0xFD, 0x12, 0x4C, 0x08, 0x21, 0xA0, 0x70, 0x02, 0xA8,
+	0xEB, 0xF7, 0x43, 0xFD,
+	0xE0, 0x70, 0x0D, 0x4D, 0x01, 0x24, 0xE0, 0xB2, 0xFF, 0xF7, 0xC1, 0xFC,
+	0x28, 0x55, 0x64, 0x1C,
+	0x05, 0x2C, 0xF8, 0xDB, 0x0B, 0x48, 0xFF, 0xF7, 0x12, 0xFD, 0x7F, 0xBD,
+	0x10, 0xB5, 0x80, 0x79,
+	0xC0, 0xB1, 0x07, 0x49, 0x08, 0x70, 0x4F, 0xF0, 0xFF, 0x30, 0xC8, 0x60,
+	0xFF, 0xF7, 0xEE, 0xFB,
+	0x00, 0x20, 0x10, 0xBD, 0x48, 0xBF, 0x01, 0x20, 0x64, 0xA2, 0x01, 0x20,
+	0x00, 0x9B, 0x01, 0x20,
+	0xD4, 0x07, 0x10, 0x00, 0xCC, 0x80, 0x10, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x93, 0x4F, 0x01, 0x00,
+	0x29, 0x50, 0x01, 0x00, 0x01, 0x20, 0xEC, 0xE7, 0x2D, 0xE9, 0xF0, 0x47,
+	0xF9, 0x49, 0x02, 0x46,
+	0x01, 0x27, 0x08, 0x68, 0xB8, 0x46, 0x00, 0xF2, 0x5E, 0x64, 0x02, 0x2A,
+	0x01, 0xD0, 0x03, 0x2A,
+	0x3C, 0xD0, 0x89, 0x46, 0x90, 0xF8, 0x23, 0x11, 0x90, 0xF8, 0x1F, 0x61,
+	0x01, 0xF0, 0x1F, 0x05,
+	0x90, 0xF8, 0x12, 0x11, 0x89, 0x06, 0x09, 0xD5, 0x90, 0xF8, 0x5A, 0x16,
+	0x90, 0xF8, 0x5B, 0x06,
+	0x0A, 0x22, 0x04, 0xEB, 0x40, 0x00, 0x01, 0xF0, 0xBF, 0xF9, 0x07, 0x46,
+	0xD9, 0xF8, 0x00, 0x00,
+	0x90, 0xF8, 0x12, 0x11, 0x49, 0x06, 0x09, 0xD5, 0x90, 0xF8, 0x6A, 0x18,
+	0x90, 0xF8, 0x6B, 0x08,
+	0x0A, 0x22, 0x04, 0xEB, 0x40, 0x00, 0x01, 0xF0, 0xAF, 0xF9, 0x80, 0x46,
+	0x4F, 0xF4, 0x80, 0x70,
+	0x86, 0x42, 0x00, 0xD9, 0x06, 0x46, 0x1F, 0x2D, 0x00, 0xD9, 0x1F, 0x25,
+	0x6D, 0x1C, 0x6E, 0x43,
+	0x70, 0x00, 0xC0, 0xEB, 0x40, 0x20, 0x78, 0x43, 0x00, 0xFB, 0x08, 0xF0,
+	0xC0, 0x13, 0xB0, 0xFA,
+	0x80, 0xF0, 0xC0, 0xF1, 0x20, 0x00, 0xC0, 0xB2, 0xBD, 0xE8, 0xF0, 0x87,
+	0x10, 0xF8, 0xD3, 0x6F,
+	0x00, 0x79, 0x00, 0xF0, 0x1F, 0x05, 0xE1, 0xE7, 0x70, 0xB5, 0x05, 0x00,
+	0x03, 0xD0, 0xBD, 0xE8,
+	0x70, 0x40, 0x01, 0xF0, 0x1A, 0xB9, 0xD0, 0x48, 0xD0, 0x4E, 0x00, 0x78,
+	0x01, 0x28, 0x01, 0xD0,
+	0xCF, 0x48, 0x16, 0xE0, 0xCB, 0x4C, 0xCE, 0x49, 0x22, 0x68, 0xA1, 0xF1,
+	0x08, 0x00, 0x02, 0xF2,
+	0x72, 0x42, 0x00, 0xF0, 0xD1, 0xF9, 0x22, 0x68, 0x92, 0xF8, 0x60, 0x04,
+	0xC0, 0x07, 0x06, 0xD0,
+	0xC7, 0x49, 0x02, 0xF2, 0x76, 0x42, 0xA1, 0xF1, 0x08, 0x00, 0x00, 0xF0,
+	0xC5, 0xF9, 0xC4, 0x48,
+	0x08, 0x38, 0x70, 0x61, 0x28, 0x46, 0xDA, 0xE7, 0x70, 0xB5, 0x04, 0x46,
+	0xEA, 0xF7, 0xEC, 0xFF,
+	0xBF, 0x48, 0xEA, 0xF7, 0xEE, 0xFF, 0xA4, 0xF8, 0x76, 0x00, 0x01, 0xF0,
+	0x3D, 0xF9, 0x01, 0x46,
+	0x00, 0x22, 0x20, 0x46, 0xEB, 0xF7, 0x88, 0xF9, 0x01, 0xF0, 0x3A, 0xF9,
+	0x02, 0x46, 0x0B, 0x46,
+	0x20, 0x46, 0xEB, 0xF7, 0xAD, 0xF9, 0xA0, 0x79, 0x00, 0x21, 0x20, 0xF0,
+	0x02, 0x00, 0xA0, 0x71,
+	0x94, 0xF8, 0x6F, 0x00, 0x20, 0xF0, 0x07, 0x00, 0x84, 0xF8, 0x6F, 0x00,
+	0x94, 0xF8, 0x6E, 0x00,
+	0x20, 0xF0, 0x0F, 0x00, 0x84, 0xF8, 0x6E, 0x00, 0x20, 0x46, 0xEB, 0xF7,
+	0xB3, 0xF9, 0x94, 0xF8,
+	0x5E, 0x00, 0x20, 0xF0, 0x01, 0x00, 0x84, 0xF8, 0x5E, 0x00, 0x20, 0x46,
+	0x01, 0xF0, 0x52, 0xFA,
+	0x04, 0x21, 0x20, 0x46, 0xEA, 0xF7, 0xEB, 0xFF, 0xA2, 0x4D, 0x28, 0x68,
+	0x90, 0xF8, 0x1F, 0x01,
+	0xA0, 0x70, 0x28, 0x68, 0x21, 0x8E, 0xB0, 0xF8, 0x24, 0x21, 0x62, 0xF3,
+	0x08, 0x01, 0x21, 0x86,
+	0x90, 0xF8, 0x20, 0x01, 0x00, 0xF0, 0x0F, 0x01, 0x20, 0x46, 0xEB, 0xF7,
+	0x38, 0xF8, 0x28, 0x68,
+	0x62, 0x7D, 0x90, 0xF8, 0x16, 0x11, 0x61, 0xF3, 0x03, 0x02, 0x62, 0x75,
+	0xB0, 0xF8, 0x19, 0x21,
+	0x21, 0x8A, 0x62, 0xF3, 0x0B, 0x01, 0x21, 0x82, 0x90, 0xF8, 0x21, 0x11,
+	0xA2, 0x7D, 0x61, 0xF3,
+	0x03, 0x02, 0xA2, 0x75, 0xB0, 0xF8, 0x1B, 0x21, 0xA1, 0x89, 0x62, 0xF3,
+	0x0B, 0x01, 0xA1, 0x81,
+	0x90, 0xF8, 0x20, 0x11, 0x0A, 0x09, 0xA1, 0x7C, 0x62, 0xF3, 0x01, 0x01,
+	0xA1, 0x74, 0x90, 0xF8,
+	0x20, 0x21, 0x92, 0x09, 0x62, 0xF3, 0x87, 0x11, 0xA1, 0x74, 0x90, 0xF8,
+	0x12, 0x11, 0xE2, 0x79,
+	0x61, 0xF3, 0x00, 0x02, 0xE2, 0x71, 0x90, 0xF8, 0x15, 0x11, 0x61, 0x72,
+	0x90, 0xF8, 0x18, 0x01,
+	0x01, 0x09, 0xE0, 0x7A, 0x61, 0xF3, 0x03, 0x00, 0xE0, 0x72, 0x82, 0x48,
+	0xEA, 0xF7, 0x71, 0xFF,
+	0xA4, 0xF8, 0x7C, 0x00, 0x29, 0x68, 0x91, 0xF8, 0x14, 0x01, 0xC2, 0x08,
+	0x94, 0xF8, 0x27, 0x00,
+	0x62, 0xF3, 0x83, 0x00, 0x20, 0xF0, 0x02, 0x00, 0x40, 0xF0, 0x01, 0x00,
+	0x84, 0xF8, 0x27, 0x00,
+	0x91, 0xF8, 0x13, 0x01, 0xC0, 0xF3, 0x81, 0x01, 0x20, 0x46, 0xEA, 0xF7,
+	0xD5, 0xFF, 0x28, 0x68,
+	0x90, 0xF8, 0x13, 0x01, 0x01, 0x09, 0x14, 0xF8, 0x28, 0x0F, 0x61, 0xF3,
+	0x04, 0x10, 0x20, 0x70,
+	0x71, 0x48, 0xEA, 0xF7, 0x4E, 0xFF, 0xA4, 0xF8, 0x5E, 0x00, 0x28, 0x68,
+	0x90, 0xF8, 0x12, 0x11,
+	0xCA, 0x08, 0xE1, 0x7A, 0x62, 0xF3, 0x45, 0x11, 0xE1, 0x72, 0x90, 0xF8,
+	0x13, 0x01, 0x41, 0x08,
+	0x20, 0x78, 0x61, 0xF3, 0x45, 0x10, 0x04, 0xF8, 0x28, 0x09, 0x20, 0x46,
+	0x01, 0xF0, 0x10, 0xF9,
+	0x28, 0x68, 0x90, 0xF8, 0x18, 0x01, 0xC0, 0xF3, 0x81, 0x01, 0x20, 0x46,
+	0xEA, 0xF7, 0x99, 0xFF,
+	0x14, 0xF8, 0x32, 0x0F, 0x20, 0xF0, 0x0F, 0x00, 0x0A, 0x30, 0x20, 0xF0,
+	0xF0, 0x00, 0xA0, 0x30,
+	0x04, 0xF8, 0x0A, 0x09, 0x29, 0x68, 0x91, 0xF8, 0x12, 0x01, 0x82, 0x09,
+	0xE0, 0x7A, 0x62, 0xF3,
+	0x00, 0x00, 0xE0, 0x72, 0x91, 0xF8, 0x12, 0x21, 0x52, 0x09, 0x62, 0xF3,
+	0x41, 0x00, 0xE0, 0x72,
+	0x91, 0xF8, 0x17, 0x21, 0xD2, 0x09, 0x62, 0xF3, 0x82, 0x00, 0xE0, 0x72,
+	0x91, 0xF8, 0x22, 0x01,
+	0x62, 0x79, 0x60, 0xF3, 0x04, 0x02, 0x62, 0x71, 0x91, 0xF8, 0x23, 0x01,
+	0x21, 0x79, 0x60, 0xF3,
+	0x04, 0x01, 0x4B, 0x48, 0x21, 0x71, 0x0C, 0x38, 0x41, 0x78, 0x94, 0xF8,
+	0x37, 0x00, 0x61, 0xF3,
+	0x04, 0x00, 0x84, 0xF8, 0x37, 0x00, 0x49, 0x48, 0xEA, 0xF7, 0xFB, 0xFE,
+	0xA4, 0xF8, 0x52, 0x00,
+	0x28, 0x68, 0xE1, 0x88, 0xB0, 0xF8, 0x1D, 0x21, 0x62, 0xF3, 0x0B, 0x01,
+	0xE1, 0x80, 0x90, 0xF8,
+	0x17, 0x11, 0xCA, 0x08, 0x21, 0x7C, 0x62, 0xF3, 0x02, 0x01, 0x21, 0x74,
+	0x10, 0xF8, 0xDF, 0x2F,
+	0xA1, 0x78, 0x62, 0xF3, 0x03, 0x01, 0xA1, 0x70, 0x10, 0xF8, 0x19, 0x1B,
+	0x0A, 0x09, 0xE1, 0x78,
+	0x62, 0xF3, 0x03, 0x01, 0xE1, 0x70, 0x81, 0x7F, 0x0A, 0x09, 0x61, 0x78,
+	0x62, 0xF3, 0x02, 0x01,
+	0x61, 0x70, 0x01, 0x7F, 0x8A, 0x09, 0x21, 0x78, 0x62, 0xF3, 0x00, 0x01,
+	0x21, 0x70, 0x81, 0x7E,
+	0xCA, 0x09, 0x21, 0x7B, 0x62, 0xF3, 0x00, 0x01, 0x21, 0x73, 0x94, 0xF8,
+	0x37, 0x10, 0x41, 0xF0,
+	0x20, 0x01, 0x84, 0xF8, 0x37, 0x10, 0x21, 0x8F, 0x6F, 0xF3, 0x08, 0x01,
+	0x01, 0xF5, 0x80, 0x71,
+	0x21, 0x87, 0x00, 0x21, 0xC4, 0xF8, 0x3A, 0x10, 0xC1, 0x7F, 0x8A, 0x09,
+	0xE1, 0x7A, 0x62, 0xF3,
+	0xC3, 0x01, 0xE1, 0x72, 0x80, 0x7E, 0x00, 0x09, 0x60, 0xF3, 0x04, 0x11,
+	0xE1, 0x72, 0x70, 0xBD,
+	0x70, 0xB5, 0x1F, 0x4D, 0x00, 0x20, 0x0C, 0x3D, 0x01, 0x24, 0x28, 0x60,
+	0xE0, 0xB2, 0xFF, 0xF7,
+	0x3B, 0xFE, 0x28, 0x55, 0x64, 0x1C, 0x04, 0x2C, 0xF8, 0xDB, 0xBD, 0xE8,
+	0x70, 0x40, 0x1C, 0x48,
+	0xAA, 0xE6, 0x70, 0xB5, 0x41, 0x7A, 0xAA, 0xB0, 0x59, 0xB1, 0x13, 0x4D,
+	0x01, 0x20, 0x6C, 0x46,
+	0x28, 0x70, 0x01, 0x29, 0x08, 0xD0, 0x00, 0x26, 0x02, 0x29, 0x09, 0xD0,
+	0x03, 0x29, 0x2D, 0xD1,
+	0x28, 0xE0, 0x01, 0x20, 0x2A, 0xB0, 0x70, 0xBD, 0x20, 0x46, 0x00, 0xF0,
+	0x60, 0xF8, 0x25, 0xE0,
+	0x20, 0x46, 0x00, 0xF0, 0x5C, 0xF8, 0x0A, 0x48, 0x9D, 0xF8, 0x5F, 0x10,
+	0x0C, 0x38, 0x80, 0x78,
+	0x60, 0xF3, 0x04, 0x01, 0x8D, 0xF8, 0x5F, 0x10, 0x00, 0x21, 0x20, 0x46,
+	0xEA, 0xF7, 0x07, 0xFF,
+	0x13, 0xE0, 0x00, 0x00, 0x4C, 0x07, 0x10, 0x00, 0xE4, 0x07, 0x10, 0x00,
+	0xB4, 0x84, 0x10, 0x00,
+	0xC0, 0xA4, 0x01, 0x20, 0x98, 0x98, 0x01, 0x20, 0x20, 0xBF, 0x01, 0x20,
+	0x00, 0x9B, 0x01, 0x20,
+	0x14, 0x82, 0x10, 0x00, 0x20, 0x46, 0x00, 0xF0, 0x3E, 0xF8, 0x2E, 0x70,
+	0x20, 0x46, 0x01, 0xF0,
+	0xDD, 0xF8, 0x9D, 0xF8, 0x12, 0x00, 0x00, 0xF0, 0x03, 0x00, 0x01, 0xF0,
+	0x1F, 0xF8, 0x37, 0x4C,
+	0x20, 0x68, 0x00, 0xF2, 0x5E, 0x63, 0x00, 0xF6, 0x6E, 0x05, 0x90, 0xF8,
+	0x5A, 0x16, 0x90, 0xF8,
+	0x5B, 0x06, 0x03, 0xEB, 0x40, 0x00, 0x00, 0xF0, 0xE2, 0xFF, 0x20, 0x68,
+	0x90, 0xF8, 0x6A, 0x18,
+	0x90, 0xF8, 0x6B, 0x08, 0x05, 0xEB, 0x40, 0x00, 0x00, 0xF0, 0xF0, 0xFF,
+	0x2C, 0x49, 0x68, 0x46,
+	0xEB, 0xF7, 0x34, 0xF8, 0x00, 0x20, 0xAD, 0xE7, 0x40, 0xF2, 0xFF, 0x10,
+	0xC1, 0xEB, 0x41, 0x21,
+	0x91, 0xFB, 0xF0, 0xF0, 0x00, 0x20, 0x70, 0x47, 0x10, 0xB5, 0x00, 0x23,
+	0xD4, 0x5C, 0x31, 0xF8,
+	0x14, 0x40, 0x20, 0xF8, 0x13, 0x40, 0x5B, 0x1C, 0x04, 0x2B, 0xF7, 0xDB,
+	0x10, 0xBD, 0xA4, 0x22,
+	0x20, 0x49, 0x01, 0xF0, 0x7A, 0xBA, 0x70, 0xB5, 0x04, 0x46, 0x00, 0xF0,
+	0x6A, 0xFB, 0x1E, 0x48,
+	0xEA, 0xF7, 0x1F, 0xFE, 0xA4, 0xF8, 0x76, 0x00, 0x00, 0xF0, 0x77, 0xFF,
+	0x17, 0x4D, 0x01, 0x46,
+	0x28, 0x68, 0x90, 0xF8, 0xC9, 0x00, 0xC0, 0xF3, 0x41, 0x12, 0x20, 0x46,
+	0xEA, 0xF7, 0xB4, 0xFF,
+	0x00, 0xF0, 0x70, 0xFF, 0x02, 0x46, 0x0B, 0x46, 0x20, 0x46, 0xEA, 0xF7,
+	0xD9, 0xFF, 0x13, 0x48,
+	0xEA, 0xF7, 0x07, 0xFE, 0xA4, 0xF8, 0x7C, 0x00, 0x0F, 0x48, 0x0C, 0x38,
+	0xC1, 0x78, 0x14, 0xF8,
+	0x5F, 0x0F, 0x61, 0xF3, 0x04, 0x00, 0x20, 0x70, 0x29, 0x68, 0x00, 0xF0,
+	0x1F, 0x00, 0x11, 0xF8,
+	0xD3, 0x2F, 0xC9, 0x78, 0x01, 0xF0, 0x1F, 0x01, 0x49, 0x1C, 0xC1, 0xEB,
+	0x41, 0x21, 0x49, 0x00,
+	0x4A, 0x43, 0xC2, 0x40, 0x50, 0x08, 0xC4, 0xF8, 0x03, 0x00, 0x70, 0xBD,
+	0x4C, 0x07, 0x10, 0x00,
+	0x29, 0x58, 0x01, 0x00, 0x14, 0x82, 0x10, 0x00, 0xC0, 0xA4, 0x01, 0x20,
+	0x98, 0x98, 0x01, 0x20,
+	0x10, 0xB9, 0x66, 0x4A, 0x64, 0x49, 0x11, 0x61, 0x00, 0xF0, 0xDF, 0xBE,
+	0x70, 0xB5, 0x64, 0x4D,
+	0x04, 0x46, 0x28, 0x68, 0x90, 0xF8, 0xF1, 0x01, 0xC0, 0xF3, 0x01, 0x12,
+	0xC0, 0xF3, 0x81, 0x01,
+	0x00, 0xF0, 0x03, 0x00, 0xFD, 0xF7, 0xA1, 0xFA, 0x40, 0x1C, 0xC6, 0xB2,
+	0x20, 0x46, 0x00, 0xF0,
+	0x71, 0xFC, 0x59, 0x48, 0xEA, 0xF7, 0xC5, 0xFD, 0xA4, 0xF8, 0x76, 0x00,
+	0x00, 0x22, 0x31, 0x46,
+	0x20, 0x46, 0xEA, 0xF7, 0x82, 0xFF, 0xA0, 0x79, 0x40, 0xF0, 0x02, 0x00,
+	0xA0, 0x71, 0x94, 0xF8,
+	0x6F, 0x00, 0x66, 0xF3, 0x02, 0x00, 0x84, 0xF8, 0x6F, 0x00, 0x94, 0xF8,
+	0x6E, 0x00, 0x20, 0xF0,
+	0x0F, 0x00, 0x84, 0xF8, 0x6E, 0x00, 0x29, 0x68, 0xA0, 0x7C, 0x91, 0xF8,
+	0x08, 0x21, 0x62, 0xF3,
+	0x01, 0x00, 0xA0, 0x74, 0x91, 0xF8, 0x08, 0x21, 0x92, 0x08, 0x62, 0xF3,
+	0x87, 0x10, 0xA0, 0x74,
+	0xA0, 0x89, 0x6F, 0xF3, 0x0B, 0x00, 0xA0, 0x81, 0x91, 0xF8, 0x07, 0x01,
+	0xA0, 0x70, 0x94, 0xF8,
+	0x5E, 0x00, 0x00, 0x21, 0x20, 0xF0, 0x01, 0x00, 0x84, 0xF8, 0x5E, 0x00,
+	0x20, 0x46, 0xEA, 0xF7,
+	0x1E, 0xFE, 0x28, 0x68, 0x90, 0xF8, 0xF2, 0x11, 0x84, 0xF8, 0x66, 0x10,
+	0x90, 0xF8, 0xF3, 0x11,
+	0x84, 0xF8, 0x68, 0x10, 0x90, 0xF8, 0xF4, 0x11, 0x84, 0xF8, 0x6A, 0x10,
+	0x90, 0xF8, 0xF5, 0x01,
+	0x84, 0xF8, 0x6C, 0x00, 0x34, 0x48, 0x94, 0xF8, 0x5F, 0x10, 0x00, 0x1F,
+	0x40, 0x78, 0x60, 0xF3,
+	0x04, 0x01, 0x84, 0xF8, 0x5F, 0x10, 0x20, 0x46, 0xBD, 0xE8, 0x70, 0x40,
+	0x00, 0xF0, 0x48, 0xBF,
+	0x10, 0xB5, 0x2D, 0x4C, 0x00, 0x20, 0x24, 0x1F, 0x20, 0x80, 0x01, 0x20,
+	0x00, 0xF0, 0x32, 0xF8,
+	0x60, 0x70, 0xBD, 0xE8, 0x10, 0x40, 0x2B, 0x48, 0x88, 0xE7, 0x2D, 0xE9,
+	0xF0, 0x41, 0x29, 0x4E,
+	0x40, 0x79, 0x28, 0xB3, 0x30, 0x46, 0x00, 0xF0, 0xD9, 0xFF, 0xB0, 0x7C,
+	0x00, 0xF0, 0x03, 0x00,
+	0x00, 0xF0, 0x1C, 0xFF, 0x22, 0x4F, 0x3C, 0x68, 0x04, 0xF2, 0x5E, 0x60,
+	0x94, 0xF8, 0x51, 0x26,
+	0x04, 0xF6, 0x6E, 0x05, 0x94, 0xF8, 0x50, 0x16, 0x00, 0xEB, 0x42, 0x00,
+	0x00, 0xF0, 0xDF, 0xFE,
+	0x38, 0x68, 0x90, 0xF8, 0x60, 0x18, 0x90, 0xF8, 0x61, 0x08, 0x05, 0xEB,
+	0x40, 0x00, 0x00, 0xF0,
+	0xED, 0xFE, 0x19, 0x49, 0x30, 0x46, 0xEA, 0xF7, 0x31, 0xFF, 0x00, 0x20,
+	0xBD, 0xE8, 0xF0, 0x81,
+	0x01, 0x20, 0xFB, 0xE7, 0x12, 0x48, 0x4F, 0xF4, 0x80, 0x73, 0x02, 0x68,
+	0x92, 0xF8, 0xF5, 0x10,
+	0x92, 0xF8, 0x07, 0x01, 0x92, 0xF8, 0xF2, 0x20, 0x01, 0xF0, 0x1F, 0x01,
+	0x02, 0xF0, 0x0F, 0x02,
+	0x98, 0x42, 0x00, 0xD9, 0x18, 0x46, 0x1F, 0x29, 0x00, 0xD9, 0x1F, 0x21,
+	0x49, 0x1C, 0x48, 0x43,
+	0x40, 0x00, 0x52, 0x1C, 0x50, 0x43, 0xC0, 0xEB, 0x40, 0x20, 0xC0, 0x13,
+	0xB0, 0xFA, 0x80, 0xF0,
+	0xC0, 0xF1, 0x20, 0x00, 0xC0, 0xB2, 0x70, 0x47, 0xE4, 0xA4, 0x01, 0x20,
+	0xB4, 0x84, 0x10, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0xB8, 0x82, 0x10, 0x00, 0xA1, 0x5C, 0x01, 0x00,
+	0x2D, 0xE9, 0xF0, 0x47,
+	0xFE, 0x49, 0x4F, 0xF0, 0x01, 0x08, 0x00, 0x27, 0x0A, 0x68, 0x80, 0x1E,
+	0x02, 0xF2, 0x5E, 0x64,
+	0xC1, 0x46, 0x06, 0x28, 0x52, 0xD2, 0xDF, 0xE8, 0x00, 0xF0, 0x51, 0x09,
+	0x2D, 0x51, 0x2D, 0x03,
+	0x12, 0xF8, 0xD3, 0x6F, 0x10, 0x79, 0x00, 0xF0, 0x1F, 0x05, 0x70, 0xE0,
+	0x92, 0xF8, 0xF5, 0x00,
+	0x92, 0xF8, 0x01, 0x61, 0x00, 0xF0, 0x1F, 0x05, 0x92, 0xF8, 0xF2, 0x00,
+	0x8A, 0x46, 0x00, 0xF0,
+	0x0F, 0x07, 0x92, 0xF8, 0xE6, 0x00, 0x80, 0x06, 0x09, 0xD5, 0x92, 0xF8,
+	0x53, 0x06, 0x92, 0xF8,
+	0x52, 0x16, 0x04, 0xEB, 0x40, 0x00, 0x0A, 0x22, 0x00, 0xF0, 0x4E, 0xFE,
+	0x80, 0x46, 0xDA, 0xF8,
+	0x00, 0x00, 0x90, 0xF8, 0xE6, 0x10, 0x49, 0x06, 0x51, 0xD5, 0x90, 0xF8,
+	0x62, 0x18, 0x90, 0xF8,
+	0x63, 0x08, 0x46, 0xE0, 0x92, 0xF8, 0xFC, 0x00, 0x92, 0xF8, 0xF8, 0x60,
+	0x00, 0xF0, 0x1F, 0x05,
+	0x92, 0xF8, 0xF9, 0x00, 0x8A, 0x46, 0x00, 0xF0, 0x0F, 0x07, 0x92, 0xF8,
+	0xE6, 0x00, 0x80, 0x06,
+	0x09, 0xD5, 0x92, 0xF8, 0x55, 0x06, 0x92, 0xF8, 0x54, 0x16, 0x04, 0xEB,
+	0x40, 0x00, 0x0A, 0x22,
+	0x00, 0xF0, 0x2A, 0xFE, 0x80, 0x46, 0xDA, 0xF8, 0x00, 0x00, 0x90, 0xF8,
+	0xE6, 0x10, 0x49, 0x06,
+	0x2D, 0xD5, 0x90, 0xF8, 0x64, 0x18, 0x90, 0xF8, 0x65, 0x08, 0x22, 0xE0,
+	0x92, 0xF8, 0xF5, 0x00,
+	0x92, 0xF8, 0xF1, 0x60, 0x00, 0xF0, 0x1F, 0x05, 0x92, 0xF8, 0xF2, 0x00,
+	0x8A, 0x46, 0x00, 0xF0,
+	0x0F, 0x07, 0x92, 0xF8, 0xE6, 0x00, 0x80, 0x06, 0x09, 0xD5, 0x92, 0xF8,
+	0x51, 0x06, 0x92, 0xF8,
+	0x50, 0x16, 0x04, 0xEB, 0x40, 0x00, 0x0A, 0x22, 0x00, 0xF0, 0x06, 0xFE,
+	0x80, 0x46, 0xDA, 0xF8,
+	0x00, 0x00, 0x90, 0xF8, 0xE6, 0x10, 0x49, 0x06, 0x09, 0xD5, 0x90, 0xF8,
+	0x60, 0x18, 0x90, 0xF8,
+	0x61, 0x08, 0x0A, 0x22, 0x04, 0xEB, 0x40, 0x00, 0x00, 0xF0, 0xF6, 0xFD,
+	0x81, 0x46, 0x4F, 0xF4,
+	0x80, 0x70, 0x86, 0x42, 0x00, 0xD9, 0x06, 0x46, 0x1F, 0x2D, 0x00, 0xD9,
+	0x1F, 0x25, 0x6D, 0x1C,
+	0x6E, 0x43, 0x70, 0x00, 0x7F, 0x1C, 0x78, 0x43, 0xC0, 0xEB, 0x40, 0x20,
+	0x00, 0xFB, 0x08, 0xF0,
+	0x00, 0xFB, 0x09, 0xF0, 0xC0, 0x13, 0xB0, 0xFA, 0x80, 0xF0, 0xC0, 0xF1,
+	0x20, 0x00, 0xC0, 0xB2,
+	0xBD, 0xE8, 0xF0, 0x87, 0x70, 0xB5, 0x06, 0x00, 0x03, 0xD0, 0xBD, 0xE8,
+	0x70, 0x40, 0x00, 0xF0,
+	0x64, 0xBD, 0x00, 0xF0, 0x18, 0xF8, 0x01, 0x28, 0x14, 0xD1, 0xA9, 0x4D,
+	0xA9, 0x4C, 0x28, 0x78,
+	0x01, 0x28, 0x09, 0xD0, 0xA8, 0x48, 0xA0, 0x60, 0x68, 0x78, 0xE0, 0x73,
+	0xE8, 0x78, 0xA0, 0x73,
+	0xE8, 0x88, 0xA0, 0x81, 0x30, 0x46, 0xE8, 0xE7, 0x6A, 0x79, 0x29, 0x79,
+	0xA2, 0x48, 0x00, 0xF0,
+	0xB6, 0xFE, 0xF0, 0xE7, 0x70, 0xBD, 0x9E, 0x4B, 0x10, 0xB5, 0xD9, 0x78,
+	0x9F, 0x4C, 0x49, 0x1C,
+	0xCA, 0xB2, 0xDA, 0x70, 0x99, 0x78, 0x01, 0x20, 0x8A, 0x42, 0x1B, 0xD8,
+	0x19, 0x79, 0x58, 0x79,
+	0x41, 0x43, 0x99, 0x48, 0xFD, 0xF7, 0xA9, 0xF9, 0xEA, 0xF7, 0x33, 0xFC,
+	0xA4, 0xF8, 0x76, 0x00,
+	0x92, 0x48, 0x00, 0x68, 0x90, 0xF8, 0xB0, 0x00, 0xC0, 0x07, 0x06, 0xD0,
+	0x94, 0xF8, 0x4D, 0x00,
+	0x20, 0xF0, 0x03, 0x00, 0x80, 0x1C, 0x84, 0xF8, 0x4D, 0x00, 0x91, 0x49,
+	0x20, 0x46, 0xEA, 0xF7,
+	0x15, 0xFE, 0x00, 0x20, 0x10, 0xBD, 0x70, 0xB5, 0x04, 0x46, 0xEA, 0xF7,
+	0x15, 0xFC, 0x8A, 0x48,
+	0xEA, 0xF7, 0x17, 0xFC, 0xA4, 0xF8, 0x76, 0x00, 0x00, 0xF0, 0x66, 0xFD,
+	0x83, 0x4D, 0x01, 0x46,
+	0x28, 0x68, 0x90, 0xF8, 0xE7, 0x00, 0xC0, 0xF3, 0x41, 0x12, 0x20, 0x46,
+	0xEA, 0xF7, 0xAC, 0xFD,
+	0x00, 0xF0, 0x5E, 0xFD, 0x02, 0x46, 0x0B, 0x46, 0x20, 0x46, 0xEA, 0xF7,
+	0xD1, 0xFD, 0xA0, 0x79,
+	0x20, 0xF0, 0x02, 0x00, 0xA0, 0x71, 0x94, 0xF8, 0x6F, 0x00, 0x20, 0xF0,
+	0x07, 0x00, 0x84, 0xF8,
+	0x6F, 0x00, 0x94, 0xF8, 0x6E, 0x00, 0x20, 0xF0, 0x0F, 0x00, 0x84, 0xF8,
+	0x6E, 0x00, 0x28, 0x68,
+	0x90, 0xF8, 0xE7, 0x00, 0xC0, 0xF3, 0x41, 0x11, 0x20, 0x46, 0xEA, 0xF7,
+	0xD3, 0xFD, 0x28, 0x68,
+	0x90, 0xF8, 0xE7, 0x00, 0x10, 0xF0, 0x60, 0x0F, 0x94, 0xF8, 0x5E, 0x00,
+	0x7E, 0xD0, 0x40, 0xF0,
+	0x01, 0x00, 0x00, 0xBF, 0x84, 0xF8, 0x5E, 0x00, 0x20, 0x46, 0x00, 0xF0,
+	0x6B, 0xFE, 0x04, 0x21,
+	0x20, 0x46, 0xEA, 0xF7, 0x04, 0xFC, 0x28, 0x68, 0x90, 0xF8, 0xF1, 0x00,
+	0xA0, 0x70, 0x28, 0x68,
+	0x21, 0x8E, 0xB0, 0xF8, 0xF6, 0x20, 0x62, 0xF3, 0x08, 0x01, 0x21, 0x86,
+	0x90, 0xF8, 0xF2, 0x00,
+	0x00, 0xF0, 0x0F, 0x01, 0x20, 0x46, 0xEA, 0xF7, 0x52, 0xFC, 0x28, 0x68,
+	0x62, 0x7D, 0x90, 0xF8,
+	0xEA, 0x10, 0x61, 0xF3, 0x03, 0x02, 0x62, 0x75, 0xB0, 0xF8, 0xED, 0x20,
+	0x21, 0x8A, 0x62, 0xF3,
+	0x0B, 0x01, 0x21, 0x82, 0x90, 0xF8, 0xF3, 0x10, 0xA2, 0x7D, 0x61, 0xF3,
+	0x03, 0x02, 0xA2, 0x75,
+	0x10, 0xF8, 0xF2, 0x1F, 0x0A, 0x09, 0xA1, 0x7C, 0x62, 0xF3, 0x01, 0x01,
+	0xA1, 0x74, 0x10, 0xF8,
+	0x0C, 0x29, 0x92, 0x09, 0x62, 0xF3, 0x87, 0x11, 0xA1, 0x74, 0x01, 0x78,
+	0xE2, 0x79, 0x61, 0xF3,
+	0x00, 0x02, 0xE2, 0x71, 0xC1, 0x78, 0x61, 0x72, 0x80, 0x79, 0x01, 0x09,
+	0xE0, 0x7A, 0x61, 0xF3,
+	0x03, 0x00, 0xE0, 0x72, 0x4B, 0x48, 0xEA, 0xF7, 0x94, 0xFB, 0xA4, 0xF8,
+	0x7C, 0x00, 0x29, 0x68,
+	0x11, 0xF8, 0xE8, 0x0F, 0xC2, 0x08, 0x94, 0xF8, 0x27, 0x00, 0x62, 0xF3,
+	0x83, 0x00, 0x84, 0xF8,
+	0x27, 0x00, 0x11, 0xF8, 0x01, 0x29, 0x52, 0x08, 0x62, 0xF3, 0x00, 0x00,
+	0x84, 0xF8, 0x27, 0x00,
+	0x4A, 0x78, 0x92, 0x08, 0x62, 0xF3, 0x41, 0x00, 0x84, 0xF8, 0x27, 0x00,
+	0x08, 0x78, 0xC0, 0xF3,
+	0x81, 0x01, 0x20, 0x46, 0xEA, 0xF7, 0xF0, 0xFB, 0x28, 0x68, 0x90, 0xF8,
+	0xE7, 0x00, 0x01, 0x09,
+	0x14, 0xF8, 0x28, 0x0F, 0x61, 0xF3, 0x04, 0x10, 0x20, 0x70, 0x37, 0x48,
+	0xEA, 0xF7, 0x69, 0xFB,
+	0xA4, 0xF8, 0x5E, 0x00, 0x28, 0x68, 0x10, 0xF8, 0xE6, 0x1F, 0x00, 0xE0,
+	0xA6, 0xE0, 0xCA, 0x08,
+	0xE1, 0x7A, 0x62, 0xF3, 0x45, 0x11, 0xE1, 0x72, 0x40, 0x78, 0x41, 0x08,
+	0x20, 0x78, 0x61, 0xF3,
+	0x45, 0x10, 0x04, 0xF8, 0x28, 0x09, 0x20, 0x46, 0x00, 0xF0, 0x2A, 0xFD,
+	0x28, 0x68, 0x90, 0xF8,
+	0xEC, 0x00, 0xC0, 0xF3, 0x81, 0x01, 0x20, 0x46, 0xEA, 0xF7, 0xB3, 0xFB,
+	0x14, 0xF8, 0x32, 0x0F,
+	0x20, 0xF0, 0x0F, 0x00, 0x0A, 0x30, 0x20, 0xF0, 0xF0, 0x00, 0xA0, 0x30,
+	0x04, 0xF8, 0x0A, 0x09,
+	0x29, 0x68, 0x11, 0xF8, 0xE6, 0x0F, 0x82, 0x09, 0xE0, 0x7A, 0x62, 0xF3,
+	0x00, 0x00, 0xE0, 0x72,
+	0x0A, 0x78, 0x52, 0x09, 0x62, 0xF3, 0x41, 0x00, 0xE0, 0x72, 0x4A, 0x79,
+	0xD2, 0x09, 0x62, 0xF3,
+	0x82, 0x00, 0xE0, 0x72, 0x88, 0x7B, 0x62, 0x79, 0x60, 0xF3, 0x04, 0x02,
+	0x62, 0x71, 0xC9, 0x7B,
+	0x20, 0x79, 0x61, 0xF3, 0x04, 0x00, 0x20, 0x71, 0x14, 0x48, 0x94, 0xF8,
+	0x37, 0x10, 0x40, 0x78,
+	0x60, 0xF3, 0x04, 0x01, 0x84, 0xF8, 0x37, 0x10, 0x11, 0x48, 0xEA, 0xF7,
+	0x1A, 0xFB, 0xA4, 0xF8,
+	0x52, 0x00, 0x28, 0x68, 0xE1, 0x88, 0xB0, 0xF8, 0xEF, 0x20, 0x62, 0xF3,
+	0x0B, 0x01, 0xE1, 0x80,
+	0x90, 0xF8, 0xEB, 0x10, 0xCA, 0x08, 0x21, 0x7C, 0x14, 0xE0, 0x00, 0x00,
+	0x4C, 0x07, 0x10, 0x00,
+	0xE6, 0x07, 0x10, 0x00, 0xB4, 0x84, 0x10, 0x00, 0x14, 0xA6, 0x01, 0x20,
+	0x00, 0x84, 0x10, 0x00,
+	0x95, 0x5F, 0x01, 0x00, 0x78, 0x8B, 0x01, 0x20, 0x20, 0xBF, 0x01, 0x20,
+	0x16, 0xBF, 0x01, 0x20,
+	0x00, 0x9B, 0x01, 0x20, 0x62, 0xF3, 0x02, 0x01, 0x21, 0x74, 0x10, 0xF8,
+	0xDF, 0x1F, 0xA2, 0x78,
+	0x61, 0xF3, 0x03, 0x02, 0xA2, 0x70, 0x01, 0x78, 0x0A, 0x09, 0xE1, 0x78,
+	0x62, 0xF3, 0x03, 0x01,
+	0xE1, 0x70, 0xC1, 0x7A, 0x0A, 0x09, 0x61, 0x78, 0x62, 0xF3, 0x02, 0x01,
+	0x61, 0x70, 0x41, 0x7A,
+	0x8A, 0x09, 0x21, 0x78, 0x62, 0xF3, 0x00, 0x01, 0x21, 0x70, 0xC1, 0x79,
+	0xCA, 0x09, 0x21, 0x7B,
+	0x62, 0xF3, 0x00, 0x01, 0x21, 0x73, 0x94, 0xF8, 0x37, 0x10, 0x41, 0xF0,
+	0x20, 0x01, 0x84, 0xF8,
+	0x37, 0x10, 0x21, 0x8F, 0x6F, 0xF3, 0x08, 0x01, 0x01, 0xF5, 0x80, 0x71,
+	0x21, 0x87, 0x00, 0x21,
+	0xC4, 0xF8, 0x3A, 0x10, 0x01, 0x7B, 0x8A, 0x09, 0xE1, 0x7A, 0x62, 0xF3,
+	0xC3, 0x01, 0xE1, 0x72,
+	0xC0, 0x79, 0x00, 0x09, 0x60, 0xF3, 0x04, 0x11, 0xE1, 0x72, 0x70, 0xBD,
+	0x20, 0xF0, 0x01, 0x00,
+	0xD8, 0xE6, 0x70, 0xB5, 0x04, 0x46, 0xEA, 0xF7, 0xAF, 0xFA, 0xFD, 0x48,
+	0xEA, 0xF7, 0xB1, 0xFA,
+	0xA4, 0xF8, 0x76, 0x00, 0x00, 0xF0, 0x00, 0xFC, 0xFA, 0x4D, 0x01, 0x46,
+	0x28, 0x68, 0x90, 0xF8,
+	0xC9, 0x00, 0xC0, 0xF3, 0x41, 0x12, 0x20, 0x46, 0xEA, 0xF7, 0x46, 0xFC,
+	0x00, 0xF0, 0xF8, 0xFB,
+	0x02, 0x46, 0x0B, 0x46, 0x20, 0x46, 0xEA, 0xF7, 0x6B, 0xFC, 0xA0, 0x79,
+	0x20, 0xF0, 0x02, 0x00,
+	0xA0, 0x71, 0x94, 0xF8, 0x6F, 0x00, 0x20, 0xF0, 0x07, 0x00, 0x84, 0xF8,
+	0x6F, 0x00, 0x94, 0xF8,
+	0x6E, 0x00, 0x20, 0xF0, 0x0F, 0x00, 0x84, 0xF8, 0x6E, 0x00, 0x28, 0x68,
+	0x90, 0xF8, 0xC9, 0x00,
+	0xC0, 0xF3, 0x41, 0x11, 0x20, 0x46, 0xEA, 0xF7, 0x6D, 0xFC, 0x28, 0x68,
+	0x90, 0xF8, 0xC9, 0x00,
+	0x10, 0xF0, 0x60, 0x0F, 0x94, 0xF8, 0x5E, 0x00, 0x7E, 0xD0, 0x40, 0xF0,
+	0x01, 0x00, 0x00, 0xBF,
+	0x84, 0xF8, 0x5E, 0x00, 0x20, 0x46, 0x00, 0xF0, 0x05, 0xFD, 0x28, 0x68,
+	0x90, 0xF8, 0xD3, 0x00,
+	0xA0, 0x70, 0x28, 0x68, 0x21, 0x8E, 0xB0, 0xF8, 0xD8, 0x20, 0x62, 0xF3,
+	0x08, 0x01, 0x21, 0x86,
+	0x90, 0xF8, 0xD4, 0x00, 0x00, 0xF0, 0x0F, 0x01, 0x20, 0x46, 0xEA, 0xF7,
+	0xF0, 0xFA, 0x28, 0x68,
+	0x62, 0x7D, 0x90, 0xF8, 0xCC, 0x10, 0x61, 0xF3, 0x03, 0x02, 0x62, 0x75,
+	0xB0, 0xF8, 0xCF, 0x20,
+	0x21, 0x8A, 0x62, 0xF3, 0x0B, 0x01, 0x21, 0x82, 0x90, 0xF8, 0xD5, 0x10,
+	0xA2, 0x7D, 0x61, 0xF3,
+	0x03, 0x02, 0xA2, 0x75, 0x90, 0xF8, 0xF2, 0x21, 0xA1, 0x89, 0x62, 0xF3,
+	0x0B, 0x01, 0xA1, 0x81,
+	0x10, 0xF8, 0xD4, 0x1F, 0x0A, 0x09, 0xA1, 0x7C, 0x62, 0xF3, 0x01, 0x01,
+	0xA1, 0x74, 0x10, 0xF8,
+	0x0C, 0x29, 0x92, 0x09, 0x62, 0xF3, 0x87, 0x11, 0xA1, 0x74, 0x01, 0x78,
+	0xE2, 0x79, 0x61, 0xF3,
+	0x00, 0x02, 0xE2, 0x71, 0xC1, 0x78, 0x61, 0x72, 0x80, 0x79, 0x01, 0x09,
+	0xE0, 0x7A, 0x61, 0xF3,
+	0x03, 0x00, 0xE0, 0x72, 0xBC, 0x48, 0xEA, 0xF7, 0x2C, 0xFA, 0xA4, 0xF8,
+	0x7C, 0x00, 0x29, 0x68,
+	0x11, 0xF8, 0xCA, 0x0F, 0xC2, 0x08, 0x94, 0xF8, 0x27, 0x00, 0x62, 0xF3,
+	0x83, 0x00, 0x84, 0xF8,
+	0x27, 0x00, 0x11, 0xF8, 0x01, 0x29, 0x52, 0x08, 0x62, 0xF3, 0x00, 0x00,
+	0x84, 0xF8, 0x27, 0x00,
+	0x4A, 0x78, 0x92, 0x08, 0x62, 0xF3, 0x41, 0x00, 0x84, 0xF8, 0x27, 0x00,
+	0x08, 0x78, 0xC0, 0xF3,
+	0x81, 0x01, 0x20, 0x46, 0xEA, 0xF7, 0x88, 0xFA, 0x28, 0x68, 0x90, 0xF8,
+	0xC9, 0x00, 0x01, 0x09,
+	0x14, 0xF8, 0x28, 0x0F, 0x61, 0xF3, 0x04, 0x10, 0x20, 0x70, 0xA8, 0x48,
+	0xEA, 0xF7, 0x01, 0xFA,
+	0xA4, 0xF8, 0x5E, 0x00, 0x28, 0x68, 0x00, 0xE0, 0xA1, 0xE0, 0x10, 0xF8,
+	0xC8, 0x1F, 0xCA, 0x08,
+	0xE1, 0x7A, 0x62, 0xF3, 0x45, 0x11, 0xE1, 0x72, 0x40, 0x78, 0x41, 0x08,
+	0x20, 0x78, 0x61, 0xF3,
+	0x45, 0x10, 0x04, 0xF8, 0x28, 0x09, 0x20, 0x46, 0x00, 0xF0, 0xC2, 0xFB,
+	0x28, 0x68, 0x90, 0xF8,
+	0xCE, 0x00, 0xC0, 0xF3, 0x81, 0x01, 0x20, 0x46, 0xEA, 0xF7, 0x4B, 0xFA,
+	0x14, 0xF8, 0x32, 0x0F,
+	0x20, 0xF0, 0x0F, 0x00, 0x0A, 0x30, 0x20, 0xF0, 0xF0, 0x00, 0xA0, 0x30,
+	0x04, 0xF8, 0x0A, 0x09,
+	0x29, 0x68, 0x11, 0xF8, 0xC8, 0x0F, 0x82, 0x09, 0xE0, 0x7A, 0x62, 0xF3,
+	0x00, 0x00, 0xE0, 0x72,
+	0x0A, 0x78, 0x52, 0x09, 0x62, 0xF3, 0x41, 0x00, 0xE0, 0x72, 0x4A, 0x79,
+	0xD2, 0x09, 0x62, 0xF3,
+	0x82, 0x00, 0xE0, 0x72, 0x88, 0x7B, 0x62, 0x79, 0x60, 0xF3, 0x04, 0x02,
+	0x62, 0x71, 0xC8, 0x7B,
+	0x21, 0x79, 0x60, 0xF3, 0x04, 0x01, 0x86, 0x48, 0x21, 0x71, 0x94, 0xF8,
+	0x37, 0x10, 0x40, 0x78,
+	0x60, 0xF3, 0x04, 0x01, 0x84, 0xF8, 0x37, 0x10, 0x82, 0x48, 0xEA, 0xF7,
+	0xB2, 0xF9, 0xA4, 0xF8,
+	0x52, 0x00, 0x28, 0x68, 0xE1, 0x88, 0xB0, 0xF8, 0xD1, 0x20, 0x62, 0xF3,
+	0x0B, 0x01, 0xE1, 0x80,
+	0x10, 0xF8, 0xCD, 0x1F, 0xCA, 0x08, 0x21, 0x7C, 0x62, 0xF3, 0x02, 0x01,
+	0x21, 0x74, 0x10, 0xF8,
+	0x12, 0x1F, 0xA2, 0x78, 0x61, 0xF3, 0x03, 0x02, 0xA2, 0x70, 0x10, 0xF8,
+	0x17, 0x19, 0x0A, 0x09,
+	0xE1, 0x78, 0x62, 0xF3, 0x03, 0x01, 0xE1, 0x70, 0x01, 0x79, 0x0A, 0x09,
+	0x61, 0x78, 0x62, 0xF3,
+	0x02, 0x01, 0x61, 0x70, 0x81, 0x78, 0x8A, 0x09, 0x21, 0x78, 0x62, 0xF3,
+	0x00, 0x01, 0x21, 0x70,
+	0x01, 0x78, 0xCA, 0x09, 0x21, 0x7B, 0x62, 0xF3, 0x00, 0x01, 0x21, 0x73,
+	0x01, 0x79, 0xCA, 0x09,
+	0x94, 0xF8, 0x37, 0x10, 0x62, 0xF3, 0x45, 0x11, 0x84, 0xF8, 0x37, 0x10,
+	0x22, 0x8F, 0x01, 0xF0,
+	0x1F, 0x01, 0x6F, 0xF3, 0x08, 0x02, 0x02, 0xF5, 0x80, 0x72, 0x22, 0x87,
+	0x83, 0x7B, 0xC2, 0x7A,
+	0x03, 0xF0, 0x1F, 0x03, 0x5B, 0x1C, 0xC3, 0xEB, 0x43, 0x23, 0x5B, 0x00,
+	0x5A, 0x43, 0xCA, 0x40,
+	0x51, 0x08, 0xC4, 0xF8, 0x3A, 0x10, 0x41, 0x79, 0x8A, 0x09, 0xE1, 0x7A,
+	0x62, 0xF3, 0xC3, 0x01,
+	0xE1, 0x72, 0x00, 0x78, 0x00, 0x09, 0x60, 0xF3, 0x04, 0x11, 0xE1, 0x72,
+	0x70, 0xBD, 0x20, 0xF0,
+	0x01, 0x00, 0xDD, 0xE6, 0x10, 0xB5, 0x04, 0x46, 0xA4, 0x22, 0x53, 0x49,
+	0x00, 0xF0, 0xA5, 0xFD,
+	0x52, 0x48, 0xC1, 0x78, 0xA0, 0x89, 0x61, 0xF3, 0x0B, 0x00, 0xA0, 0x81,
+	0x10, 0xBD, 0x70, 0xB5,
+	0x04, 0x46, 0xFF, 0xF7, 0xEF, 0xFF, 0x00, 0xF0, 0x97, 0xFA, 0x01, 0x46,
+	0x00, 0x22, 0x20, 0x46,
+	0xEA, 0xF7, 0xE2, 0xFA, 0x4A, 0x48, 0xEA, 0xF7, 0x3C, 0xF9, 0x42, 0x4D,
+	0xA4, 0xF8, 0x7C, 0x00,
+	0x28, 0x68, 0x90, 0xF8, 0xF8, 0x00, 0xA0, 0x70, 0x28, 0x68, 0x90, 0xF8,
+	0xF9, 0x00, 0x00, 0xF0,
+	0x0F, 0x01, 0x20, 0x46, 0xEA, 0xF7, 0xBB, 0xF9, 0x28, 0x68, 0x10, 0xF8,
+	0xF9, 0x1F, 0x0A, 0x09,
+	0xA1, 0x7C, 0x62, 0xF3, 0x01, 0x01, 0xA1, 0x74, 0x02, 0x78, 0x92, 0x09,
+	0x62, 0xF3, 0x87, 0x11,
+	0xA1, 0x74, 0x81, 0x78, 0x94, 0xF8, 0x2D, 0x20, 0x61, 0xF3, 0x04, 0x02,
+	0x84, 0xF8, 0x2D, 0x20,
+	0xC1, 0x78, 0x94, 0xF8, 0x2C, 0x20, 0x61, 0xF3, 0x04, 0x02, 0x84, 0xF8,
+	0x2C, 0x20, 0x40, 0x78,
+	0xA1, 0x7D, 0x60, 0xF3, 0x03, 0x01, 0xA1, 0x75, 0x00, 0x21, 0x20, 0x46,
+	0xEA, 0xF7, 0xF2, 0xFA,
+	0x14, 0xF8, 0x5E, 0x0F, 0x20, 0xF0, 0x01, 0x00, 0x04, 0xF8, 0x01, 0x0B,
+	0x28, 0x48, 0x21, 0x78,
+	0x00, 0x79, 0x60, 0xF3, 0x04, 0x01, 0x04, 0xF8, 0x2F, 0x19, 0x28, 0x68,
+	0xB0, 0xF8, 0xFD, 0x10,
+	0x20, 0x88, 0x61, 0xF3, 0x08, 0x00, 0x20, 0x80, 0x70, 0xBD, 0x70, 0xB5,
+	0x1D, 0x4E, 0x03, 0x28,
+	0x34, 0x68, 0x04, 0xF2, 0x5E, 0x62, 0x04, 0xF6, 0x6E, 0x05, 0x15, 0xD0,
+	0x04, 0x28, 0x21, 0xD0,
+	0x94, 0xF8, 0x51, 0x06, 0x94, 0xF8, 0x50, 0x16, 0x02, 0xEB, 0x40, 0x00,
+	0x00, 0xF0, 0x77, 0xFA,
+	0x30, 0x68, 0x90, 0xF8, 0x60, 0x18, 0x90, 0xF8, 0x61, 0x08, 0x00, 0xBF,
+	0x05, 0xEB, 0x40, 0x00,
+	0xBD, 0xE8, 0x70, 0x40, 0x00, 0xF0, 0x82, 0xBA, 0x94, 0xF8, 0x53, 0x06,
+	0x94, 0xF8, 0x52, 0x16,
+	0x02, 0xEB, 0x40, 0x00, 0x00, 0xF0, 0x63, 0xFA, 0x30, 0x68, 0x90, 0xF8,
+	0x62, 0x18, 0x90, 0xF8,
+	0x63, 0x08, 0xEB, 0xE7, 0x94, 0xF8, 0x55, 0x06, 0x94, 0xF8, 0x54, 0x16,
+	0x02, 0xEB, 0x40, 0x00,
+	0x00, 0xF0, 0x55, 0xFA, 0x30, 0x68, 0x90, 0xF8, 0x64, 0x18, 0x90, 0xF8,
+	0x65, 0x08, 0xDD, 0xE7,
+	0x14, 0xA6, 0x01, 0x20, 0x4C, 0x07, 0x10, 0x00, 0x78, 0x8B, 0x01, 0x20,
+	0x20, 0xBF, 0x01, 0x20,
+	0x16, 0xBF, 0x01, 0x20, 0x00, 0x9B, 0x01, 0x20, 0x5C, 0x83, 0x10, 0x00,
+	0x74, 0x07, 0x10, 0x00,
+	0x08, 0x92, 0x01, 0x20, 0x2D, 0xE9, 0xF0, 0x47, 0x85, 0x4D, 0x4F, 0xF0,
+	0x01, 0x09, 0x00, 0x26,
+	0x85, 0xF8, 0x00, 0x90, 0xAE, 0x70, 0x83, 0x4F, 0xDF, 0xF8, 0x0C, 0x82,
+	0x04, 0x46, 0xEE, 0x70,
+	0x09, 0x29, 0x66, 0xD2, 0xDF, 0xE8, 0x01, 0xF0, 0x65, 0x05, 0x09, 0x18,
+	0x44, 0x2F, 0x48, 0x5E,
+	0x62, 0x00, 0x20, 0x46, 0xFF, 0xF7, 0x36, 0xFF, 0x5B, 0xE0, 0x20, 0x46,
+	0xFF, 0xF7, 0x32, 0xFF,
+	0xB8, 0x78, 0x94, 0xF8, 0x5F, 0x10, 0x60, 0xF3, 0x04, 0x01, 0x84, 0xF8,
+	0x5F, 0x10, 0xD8, 0xF8,
+	0x00, 0x00, 0x90, 0xF8, 0xFF, 0x00, 0x12, 0xE0, 0x20, 0x46, 0xFF, 0xF7,
+	0x23, 0xFF, 0xD8, 0xF8,
+	0x00, 0x10, 0x91, 0xF8, 0x01, 0x11, 0xA1, 0x70, 0xF9, 0x78, 0x94, 0xF8,
+	0x5F, 0x20, 0x61, 0xF3,
+	0x04, 0x02, 0x84, 0xF8, 0x5F, 0x20, 0xD8, 0xF8, 0x00, 0x00, 0x90, 0xF8,
+	0x00, 0x01, 0x00, 0xF0,
+	0x03, 0x00, 0xA8, 0x70, 0x35, 0xE0, 0x20, 0x46, 0xFF, 0xF7, 0x0C, 0xFF,
+	0x00, 0x21, 0x20, 0x46,
+	0xEA, 0xF7, 0xED, 0xF8, 0x94, 0xF8, 0x5E, 0x00, 0x20, 0xF0, 0x01, 0x00,
+	0x84, 0xF8, 0x5E, 0x00,
+	0x78, 0x79, 0x94, 0xF8, 0x5F, 0x10, 0x60, 0xF3, 0x04, 0x01, 0x84, 0xF8,
+	0x5F, 0x10, 0x17, 0xE0,
+	0x20, 0x46, 0xFF, 0xF7, 0x04, 0xFF, 0x1C, 0xE0, 0x20, 0x46, 0xFF, 0xF7,
+	0x00, 0xFF, 0x00, 0x21,
+	0x20, 0x46, 0xEA, 0xF7, 0xD4, 0xF8, 0xB8, 0x79, 0x94, 0xF8, 0x5F, 0x10,
+	0x60, 0xF3, 0x04, 0x01,
+	0x84, 0xF8, 0x5F, 0x10, 0x94, 0xF8, 0x5E, 0x00, 0x20, 0xF0, 0x01, 0x00,
+	0x84, 0xF8, 0x5E, 0x00,
+	0x2E, 0x70, 0x06, 0xE0, 0x20, 0x46, 0xFF, 0xF7, 0x7C, 0xFD, 0xF9, 0xE7,
+	0x20, 0x46, 0x00, 0xF0,
+	0x59, 0xF8, 0x20, 0x46, 0x00, 0xF0, 0xAA, 0xFA, 0x94, 0xF8, 0x27, 0x00,
+	0xC0, 0x07, 0x01, 0xD0,
+	0x6E, 0x70, 0x01, 0xE0, 0x85, 0xF8, 0x01, 0x90, 0xA0, 0x89, 0xC0, 0xF3,
+	0x0B, 0x00, 0xE8, 0x80,
+	0xBD, 0xE8, 0xF0, 0x87, 0x7F, 0xB5, 0x00, 0xF0, 0x6F, 0xF9, 0x01, 0x90,
+	0x00, 0xF0, 0x70, 0xF9,
+	0xCD, 0xE9, 0x02, 0x01, 0x04, 0x21, 0x01, 0xA8, 0xEA, 0xF7, 0xBD, 0xFC,
+	0x3C, 0x4C, 0x08, 0x21,
+	0x20, 0x71, 0x02, 0xA8, 0xEA, 0xF7, 0xB7, 0xFC, 0x60, 0x71, 0x3A, 0x48,
+	0x00, 0x21, 0x80, 0x1E,
+	0x38, 0x4D, 0x40, 0xF8, 0x02, 0x1F, 0x01, 0x24, 0x41, 0x60, 0x01, 0x72,
+	0xE0, 0xB2, 0xFF, 0xF7,
+	0xF5, 0xFA, 0x28, 0x55, 0x64, 0x1C, 0x09, 0x2C, 0xF8, 0xDB, 0x34, 0x48,
+	0xFF, 0xF7, 0xDB, 0xFB,
+	0x7F, 0xBD, 0x70, 0xB5, 0x31, 0x4D, 0x04, 0x79, 0xA4, 0x35, 0x8C, 0xB1,
+	0x21, 0x46, 0x28, 0x46,
+	0xFF, 0xF7, 0x48, 0xFF, 0xA8, 0x7C, 0x00, 0xF0, 0x03, 0x00, 0x00, 0xF0,
+	0xAF, 0xF9, 0x20, 0x46,
+	0xFF, 0xF7, 0xF3, 0xFE, 0x2A, 0x49, 0x28, 0x46, 0xEA, 0xF7, 0xD8, 0xF9,
+	0x00, 0x20, 0x70, 0xBD,
+	0x01, 0x20, 0x70, 0xBD, 0x40, 0xF2, 0xFF, 0x10, 0xC1, 0xEB, 0x41, 0x21,
+	0x91, 0xFB, 0xF0, 0xF0,
+	0x00, 0x20, 0x70, 0x47, 0x10, 0xB5, 0x04, 0x46, 0xFF, 0xF7, 0x7C, 0xFE,
+	0x94, 0xF8, 0x37, 0x00,
+	0x40, 0xF0, 0x10, 0x00, 0x84, 0xF8, 0x37, 0x00, 0xA1, 0x89, 0x94, 0xF8,
+	0x33, 0x00, 0x6F, 0xF3,
+	0x0B, 0x01, 0x10, 0x31, 0xA1, 0x81, 0x21, 0x8A, 0x20, 0xF0, 0x23, 0x00,
+	0x6F, 0xF3, 0x0B, 0x01,
+	0x40, 0x31, 0x21, 0x82, 0x08, 0x21, 0xA1, 0x70, 0x94, 0xF8, 0x5F, 0x10,
+	0x40, 0xF0, 0x0C, 0x00,
+	0x21, 0xF0, 0x1F, 0x01, 0x84, 0xF8, 0x5F, 0x10, 0x21, 0x8E, 0x6F, 0xF3,
+	0x08, 0x01, 0x21, 0x86,
+	0x84, 0xF8, 0x33, 0x00, 0x0C, 0x48, 0x01, 0x21, 0x00, 0x68, 0x90, 0xF8,
+	0xE7, 0x00, 0xC0, 0xF3,
+	0x41, 0x12, 0x20, 0x46, 0xEA, 0xF7, 0x48, 0xF9, 0x94, 0xF8, 0x28, 0x00,
+	0x40, 0xF0, 0x20, 0x00,
+	0x84, 0xF8, 0x28, 0x00, 0x20, 0x46, 0xBD, 0xE8, 0x10, 0x40, 0x00, 0xF0,
+	0x71, 0xB9, 0x00, 0x00,
+	0xE6, 0x07, 0x10, 0x00, 0x16, 0xBF, 0x01, 0x20, 0x4C, 0x07, 0x10, 0x00,
+	0x5C, 0x83, 0x10, 0x00,
+	0x95, 0x5F, 0x01, 0x00, 0x70, 0xB5, 0x00, 0xF0, 0x72, 0xFA, 0xFF, 0xF7,
+	0x6B, 0xFF, 0xFF, 0xF7,
+	0x17, 0xFA, 0xFF, 0xF7, 0xD5, 0xF8, 0xFE, 0xF7, 0xD9, 0xFE, 0xFE, 0xF7,
+	0xF7, 0xF9, 0xFD, 0xF7,
+	0x67, 0xFF, 0xFE, 0xF7, 0xA8, 0xFA, 0x50, 0x48, 0x00, 0x25, 0x70, 0x21,
+	0x45, 0x60, 0x4F, 0x48,
+	0x00, 0xF0, 0x6C, 0xFC, 0x4E, 0x48, 0x04, 0x68, 0x94, 0xF8, 0xE7, 0x00,
+	0xC0, 0x06, 0x05, 0xD5,
+	0x28, 0x22, 0x04, 0xF5, 0x0F, 0x61, 0x49, 0x48, 0x00, 0xF0, 0xBF, 0xFB,
+	0x94, 0xF8, 0x33, 0x01,
+	0xC0, 0x06, 0x0D, 0xD5, 0x45, 0x48, 0x20, 0x22, 0x04, 0xF6, 0x16, 0x11,
+	0x28, 0x30, 0x00, 0xF0,
+	0xB4, 0xFB, 0x42, 0x48, 0x28, 0x22, 0x04, 0xF6, 0x3F, 0x11, 0x48, 0x30,
+	0x00, 0xF0, 0xAD, 0xFB,
+	0x40, 0x48, 0x05, 0x70, 0x70, 0xBD, 0x38, 0xB1, 0x01, 0x28, 0x07, 0xD0,
+	0x02, 0x28, 0x07, 0xD0,
+	0x17, 0x20, 0x00, 0x21, 0xFB, 0xF7, 0x65, 0xBD, 0x14, 0x20, 0xFA, 0xE7,
+	0x15, 0x20, 0xF8, 0xE7,
+	0x16, 0x20, 0xF6, 0xE7, 0x00, 0x21, 0x01, 0x60, 0x41, 0x60, 0x81, 0x60,
+	0xC1, 0x60, 0x70, 0x47,
+	0x70, 0xB5, 0x31, 0x4C, 0x34, 0x4D, 0x20, 0x68, 0x09, 0xE0, 0x00, 0xBF,
+	0x55, 0xF8, 0x20, 0x10,
+	0x32, 0x48, 0x88, 0x47, 0x00, 0x28, 0x11, 0xD0, 0x20, 0x68, 0x40, 0x1C,
+	0x20, 0x60, 0x09, 0x28,
+	0xF4, 0xD3, 0x60, 0x68, 0x2D, 0x49, 0x40, 0x1C, 0x10, 0x31, 0x00, 0x22,
+	0x60, 0x60, 0x0A, 0x70,
+	0x48, 0x60, 0x2A, 0x48, 0x01, 0x68, 0x10, 0x30, 0x88, 0x47, 0x01, 0x20,
+	0x70, 0xBD, 0x70, 0xB5,
+	0x04, 0x46, 0x00, 0x79, 0x00, 0x25, 0x60, 0xB9, 0xE0, 0x79, 0x50, 0xB9,
+	0xA0, 0x79, 0x40, 0xB9,
+	0x20, 0x7A, 0x30, 0xB9, 0x60, 0x79, 0x20, 0xB9, 0x60, 0x7A, 0x10, 0xB9,
+	0xA0, 0x7A, 0x00, 0x28,
+	0x12, 0xD0, 0x1E, 0x48, 0x34, 0x21, 0x10, 0x30, 0x00, 0xF0, 0x00, 0xFC,
+	0x94, 0xE8, 0x4E, 0x00,
+	0x1A, 0x48, 0x80, 0xE8, 0x4E, 0x00, 0x14, 0x48, 0x16, 0x49, 0x05, 0x60,
+	0x60, 0x7B, 0x08, 0x70,
+	0x16, 0x48, 0xFF, 0xF7, 0xBD, 0xFF, 0x01, 0x20, 0x70, 0xBD, 0x0F, 0x49,
+	0x50, 0xB1, 0x4A, 0x68,
+	0x52, 0x1C, 0x4A, 0x60, 0x11, 0x49, 0x10, 0x31, 0x08, 0x70, 0x10, 0x48,
+	0x4A, 0x60, 0x01, 0x68,
+	0x10, 0x30, 0x08, 0x47, 0x08, 0x68, 0x40, 0x1C, 0x08, 0x60, 0x0C, 0x48,
+	0xA8, 0xE7, 0x00, 0xF0,
+	0x3B, 0xB8, 0x00, 0xF0, 0x3D, 0xB8, 0x00, 0xF0, 0x40, 0xB8, 0x00, 0xF0,
+	0x43, 0xB8, 0x00, 0xF0,
+	0x48, 0xB8, 0x00, 0xF0, 0x4B, 0xB8, 0x00, 0x00, 0xF0, 0x07, 0x10, 0x00,
+	0x20, 0xBF, 0x01, 0x20,
+	0x4C, 0x07, 0x10, 0x00, 0xF9, 0x07, 0x10, 0x00, 0x0C, 0x7D, 0x01, 0x00,
+	0xA4, 0x84, 0x10, 0x00,
+	0x70, 0xB5, 0x00, 0x23, 0x14, 0x46, 0x08, 0xE0, 0x31, 0xF8, 0x13, 0x50,
+	0x31, 0xF8, 0x14, 0x60,
+	0x35, 0x44, 0x20, 0xF8, 0x13, 0x50, 0x5B, 0x1C, 0x64, 0x1C, 0x93, 0x42,
+	0xF4, 0xDB, 0x70, 0xBD,
+	0x30, 0xB4, 0x00, 0x24, 0x43, 0xB9, 0x0B, 0xE0, 0x30, 0xF8, 0x14, 0x30,
+	0x31, 0xF8, 0x14, 0x50,
+	0x2B, 0x44, 0x20, 0xF8, 0x14, 0x30, 0x64, 0x1C, 0x94, 0x42, 0xF5, 0xDB,
+	0x30, 0xBC, 0x70, 0x47,
+	0x30, 0xBC, 0x52, 0x00, 0x00, 0xF0, 0x01, 0xBB, 0xBF, 0x48, 0x00, 0x68,
+	0x80, 0x6A, 0x70, 0x47,
+	0xBD, 0x48, 0x00, 0x68, 0x41, 0x6A, 0x00, 0x6A, 0x70, 0x47, 0xBB, 0x48,
+	0x00, 0x68, 0xD0, 0xF8,
+	0x6A, 0x04, 0x70, 0x47, 0xB8, 0x48, 0x00, 0x68, 0xD0, 0xF8, 0x66, 0x14,
+	0xD0, 0xF8, 0x62, 0x04,
+	0x70, 0x47, 0xB5, 0x48, 0x00, 0x68, 0xD0, 0xF8, 0x38, 0x0A, 0x70, 0x47,
+	0xB2, 0x48, 0x00, 0x68,
+	0x00, 0xF5, 0x23, 0x60, 0x03, 0xC8, 0x70, 0x47, 0xF0, 0xB5, 0x00, 0x24,
+	0x25, 0x46, 0xAF, 0x4E,
+	0x4F, 0xF4, 0x00, 0x67, 0x14, 0xE0, 0x00, 0xBF, 0x30, 0xF8, 0x15, 0x30,
+	0xC3, 0xF3, 0x0B, 0x03,
+	0x5F, 0xEA, 0xD3, 0x2C, 0x00, 0xD0, 0x33, 0x43, 0x00, 0x2B, 0x00, 0xDA,
+	0x5B, 0x42, 0x9C, 0x42,
+	0x00, 0xDA, 0x9C, 0xB2, 0xBC, 0x42, 0x02, 0xD3, 0x40, 0xF2, 0xFF, 0x74,
+	0x02, 0xE0, 0x6D, 0x1C,
+	0x8D, 0x42, 0xE9, 0xDB, 0xD4, 0x40, 0x01, 0x20, 0xA0, 0x40, 0x80, 0xB2,
+	0xF0, 0xBD, 0x30, 0xB5,
+	0xA0, 0x4B, 0x9F, 0x4C, 0x5A, 0x68, 0x82, 0x42, 0x02, 0xD1, 0xDA, 0x68,
+	0x8A, 0x42, 0x0A, 0xD0,
+	0x00, 0x22, 0x06, 0xE0, 0x30, 0xF8, 0x12, 0x50, 0xC5, 0xF3, 0x0B, 0x05,
+	0x24, 0xF8, 0x12, 0x50,
+	0x52, 0x1C, 0x8A, 0x42, 0xF6, 0xDB, 0xD9, 0x60, 0x58, 0x60, 0x30, 0xBD,
+	0x30, 0xB5, 0x95, 0x4B,
+	0x95, 0x4C, 0x9A, 0x68, 0x82, 0x42, 0x02, 0xD1, 0x1A, 0x69, 0x8A, 0x42,
+	0x0D, 0xD0, 0x00, 0x22,
+	0x07, 0xE0, 0x00, 0xBF, 0x30, 0xF8, 0x12, 0x50, 0xC5, 0xF3, 0x0B, 0x05,
+	0x24, 0xF8, 0x12, 0x50,
+	0x52, 0x1C, 0x8A, 0x42, 0xF6, 0xDB, 0x19, 0x61, 0x98, 0x60, 0x30, 0xBD,
+	0x70, 0xB5, 0x04, 0x46,
+	0x8A, 0x48, 0x01, 0x68, 0x02, 0x29, 0x0A, 0xD1, 0x86, 0x4D, 0x29, 0x78,
+	0x8C, 0x42, 0x06, 0xD0,
+	0x00, 0xEB, 0x84, 0x00, 0xD0, 0xF8, 0x9C, 0x00, 0xE9, 0xF7, 0x3D, 0xFE,
+	0x2C, 0x70, 0x70, 0xBD,
+	0x10, 0xB5, 0x04, 0x46, 0x90, 0xF8, 0x28, 0x00, 0x80, 0x06, 0x1B, 0xD5,
+	0x7A, 0x48, 0x00, 0x68,
+	0x90, 0xF8, 0x70, 0x01, 0x80, 0x07, 0x01, 0xD5, 0x7D, 0x48, 0x0F, 0xE0,
+	0x7D, 0x49, 0x08, 0x68,
+	0x00, 0x28, 0x0F, 0xD1, 0xA0, 0x7C, 0x94, 0xF8, 0x27, 0x20, 0x80, 0x09,
+	0xC0, 0xEB, 0xC0, 0x00,
+	0x12, 0xF0, 0x01, 0x0F, 0x01, 0xEB, 0x00, 0x10, 0x05, 0xD0, 0x00, 0x1D,
+	0xE9, 0xF7, 0x09, 0xFE,
+	0xA4, 0xF8, 0x8C, 0x00, 0x10, 0xBD, 0x00, 0xF5, 0xAA, 0x70, 0xF7, 0xE7,
+	0x70, 0xB5, 0x04, 0x46,
+	0x90, 0xF8, 0x28, 0x00, 0x80, 0x06, 0x28, 0xD5, 0x67, 0x48, 0x00, 0x68,
+	0x90, 0xF8, 0x88, 0x01,
+	0xC0, 0x06, 0x08, 0xD5, 0x6A, 0x48, 0x28, 0x30, 0xE9, 0xF7, 0xF3, 0xFD,
+	0x24, 0xF8, 0x8E, 0x0F,
+	0x67, 0x48, 0x48, 0x30, 0x16, 0xE0, 0x67, 0x48, 0x01, 0x68, 0x00, 0x29,
+	0x15, 0xD1, 0xA1, 0x7C,
+	0x94, 0xF8, 0x27, 0x20, 0x89, 0x09, 0xC1, 0xEB, 0xC1, 0x01, 0x12, 0xF0,
+	0x01, 0x0F, 0x00, 0xEB,
+	0x01, 0x15, 0x0B, 0xD0, 0x05, 0xF1, 0x2C, 0x00, 0xE9, 0xF7, 0xDB, 0xFD,
+	0x24, 0xF8, 0x8E, 0x0F,
+	0x05, 0xF1, 0x4C, 0x00, 0xE9, 0xF7, 0xD5, 0xFD, 0x60, 0x80, 0x70, 0xBD,
+	0x05, 0xF5, 0xBE, 0x70,
+	0xE9, 0xF7, 0xCF, 0xFD, 0x24, 0xF8, 0x8E, 0x0F, 0x05, 0xF5, 0xCE, 0x70,
+	0xF2, 0xE7, 0x70, 0xB5,
+	0x04, 0x46, 0x90, 0xF8, 0x28, 0x00, 0x80, 0x06, 0x0B, 0xD5, 0x4B, 0x48,
+	0x00, 0x68, 0x90, 0xF8,
+	0x88, 0x01, 0xC0, 0x06, 0x06, 0xD5, 0x4E, 0x48, 0x70, 0x30, 0xE9, 0xF7,
+	0xBA, 0xFD, 0xA4, 0xF8,
+	0x8E, 0x00, 0x70, 0xBD, 0x4B, 0x48, 0x01, 0x68, 0x00, 0x29, 0xFA, 0xD1,
+	0xA1, 0x7C, 0x94, 0xF8,
+	0x27, 0x20, 0x89, 0x09, 0xC1, 0xEB, 0xC1, 0x01, 0x12, 0xF0, 0x01, 0x0F,
+	0x00, 0xEB, 0x01, 0x15,
+	0x0C, 0xD0, 0x05, 0xF1, 0x2C, 0x00, 0xE9, 0xF7, 0xA4, 0xFD, 0x24, 0xF8,
+	0x8E, 0x0F, 0x05, 0xF1,
+	0x4C, 0x00, 0x00, 0xBF, 0xE9, 0xF7, 0x9D, 0xFD, 0x60, 0x80, 0x70, 0xBD,
+	0x05, 0xF5, 0xBE, 0x70,
+	0xE9, 0xF7, 0x97, 0xFD, 0x24, 0xF8, 0x8E, 0x0F, 0x05, 0xF5, 0xCE, 0x70,
+	0xF2, 0xE7, 0x70, 0x47,
+	0x70, 0x47, 0x70, 0x47, 0x02, 0x00, 0x4F, 0xF0, 0x00, 0x00, 0x00, 0xD1,
+	0x08, 0x46, 0x70, 0x47,
+	0x02, 0x46, 0x00, 0x20, 0x01, 0x2A, 0x00, 0xD1, 0x08, 0x46, 0x70, 0x47,
+	0x2A, 0x49, 0x10, 0xB5,
+	0x09, 0x68, 0x91, 0xF8, 0xB0, 0x10, 0xCA, 0x07, 0x08, 0xD0, 0x2A, 0x4C,
+	0x62, 0x78, 0x01, 0x2A,
+	0x05, 0xD0, 0x02, 0x21, 0xE9, 0xF7, 0xA3, 0xFD, 0x00, 0x20, 0x60, 0x70,
+	0x10, 0xBD, 0xC1, 0xF3,
+	0xC1, 0x01, 0xF7, 0xE7, 0x20, 0x49, 0x0A, 0x68, 0x92, 0xF8, 0xB0, 0x20,
+	0x93, 0x09, 0x10, 0xF8,
+	0x3E, 0x2B, 0x63, 0xF3, 0x82, 0x02, 0x00, 0xF8, 0x3E, 0x2C, 0x0B, 0x68,
+	0x93, 0xF8, 0xB0, 0x30,
+	0x5B, 0x09, 0x63, 0xF3, 0x45, 0x12, 0x00, 0xF8, 0x3E, 0x2C, 0x09, 0x68,
+	0xB1, 0xF8, 0xB7, 0x20,
+	0x02, 0x82, 0x91, 0xF8, 0xB6, 0x20, 0x83, 0x7F, 0x62, 0xF3, 0x07, 0x13,
+	0x83, 0x77, 0x91, 0xF8,
+	0xB3, 0x20, 0x13, 0x09, 0x02, 0x7D, 0x63, 0xF3, 0x06, 0x12, 0x02, 0x75,
+	0x31, 0xF8, 0xB1, 0x3F,
+	0x02, 0x8B, 0x63, 0xF3, 0x09, 0x02, 0x02, 0x83, 0x11, 0xF8, 0x01, 0x2C,
+	0x93, 0x08, 0x82, 0x7D,
+	0x63, 0xF3, 0x86, 0x12, 0x82, 0x75, 0x8A, 0x78, 0xC3, 0x7D, 0x62, 0xF3,
+	0x03, 0x03, 0xC3, 0x75,
+	0xB1, 0xF8, 0x03, 0x30, 0xB0, 0xF8, 0x1B, 0x20, 0x63, 0xF3, 0x08, 0x02,
+	0xA0, 0xF8, 0x1B, 0x20,
+	0x09, 0x89, 0x41, 0x82, 0x70, 0x47, 0x00, 0x00, 0x4C, 0x07, 0x10, 0x00,
+	0x00, 0xF0, 0xFF, 0xFF,
+	0x00, 0x9B, 0x01, 0x20, 0xF8, 0x07, 0x10, 0x00, 0x00, 0x9D, 0x01, 0x20,
+	0xE8, 0x84, 0x10, 0x00,
+	0xE4, 0x9F, 0x01, 0x20, 0x40, 0x9D, 0x01, 0x20, 0x00, 0x20, 0xFF, 0xF7,
+	0x1E, 0xBE, 0x70, 0x47,
+	0x10, 0xB5, 0xE9, 0xF7, 0x64, 0xFF, 0x08, 0xB1, 0x01, 0x20, 0x10, 0xBD,
+	0x0B, 0x48, 0xE9, 0xF7,
+	0x47, 0xFF, 0x00, 0x20, 0x10, 0xBD, 0x10, 0xB5, 0x04, 0x46, 0x09, 0x48,
+	0x00, 0x68, 0x90, 0xF8,
+	0x70, 0x00, 0x40, 0x07, 0x01, 0xD5, 0xE9, 0xF7, 0x47, 0xFF, 0x20, 0x7B,
+	0x20, 0xB1, 0x05, 0x49,
+	0xEA, 0xF7, 0x12, 0xFC, 0x00, 0x20, 0x10, 0xBD, 0x01, 0x20, 0x10, 0xBD,
+	0x6B, 0x6A, 0x01, 0x00,
+	0x4C, 0x07, 0x10, 0x00, 0x29, 0x6E, 0x01, 0x00, 0x43, 0x48, 0x01, 0x68,
+	0x21, 0xF0, 0x04, 0x01,
+	0x01, 0x60, 0x70, 0x47, 0x00, 0xB5, 0xFF, 0xF7, 0xF7, 0xFF, 0x00, 0xBD,
+	0x00, 0xB5, 0xFF, 0xF7,
+	0xF3, 0xFF, 0x00, 0xBD, 0x00, 0xB5, 0xFF, 0xF7, 0xEF, 0xFF, 0x00, 0xBD,
+	0x10, 0xB5, 0xFF, 0xF7,
+	0xEB, 0xFF, 0xBD, 0xE8, 0x10, 0x40, 0xEA, 0xF7, 0x32, 0xBB, 0x10, 0xB5,
+	0xFF, 0xF7, 0xE4, 0xFF,
+	0xBD, 0xE8, 0x10, 0x40, 0xE9, 0xF7, 0xF8, 0xBC, 0x10, 0xB5, 0xFF, 0xF7,
+	0xDD, 0xFF, 0xBD, 0xE8,
+	0x10, 0x40, 0xEA, 0xF7, 0x28, 0xBC, 0x10, 0xB5, 0xFF, 0xF7, 0xD6, 0xFF,
+	0xBD, 0xE8, 0x10, 0x40,
+	0xEA, 0xF7, 0x66, 0xBC, 0x10, 0xB5, 0xFF, 0xF7, 0xCF, 0xFF, 0xBD, 0xE8,
+	0x10, 0x40, 0xEA, 0xF7,
+	0x90, 0xBC, 0x10, 0xB5, 0xFF, 0xF7, 0xC8, 0xFF, 0xBD, 0xE8, 0x10, 0x40,
+	0xEA, 0xF7, 0xBA, 0xBC,
+	0x10, 0xB5, 0xFF, 0xF7, 0xC1, 0xFF, 0xBD, 0xE8, 0x10, 0x40, 0xEA, 0xF7,
+	0xC8, 0xBC, 0x10, 0xB5,
+	0xFF, 0xF7, 0xBA, 0xFF, 0xBD, 0xE8, 0x10, 0x40, 0xEA, 0xF7, 0xE6, 0xBC,
+	0x10, 0xB5, 0xFF, 0xF7,
+	0xB3, 0xFF, 0xBD, 0xE8, 0x10, 0x40, 0xEA, 0xF7, 0xEF, 0xBC, 0x10, 0xB5,
+	0xFF, 0xF7, 0xAC, 0xFF,
+	0xBD, 0xE8, 0x10, 0x40, 0x00, 0xF0, 0xF2, 0xB9, 0x10, 0xB5, 0xFF, 0xF7,
+	0xA5, 0xFF, 0xBD, 0xE8,
+	0x10, 0x40, 0x00, 0xF0, 0xC7, 0xB9, 0x00, 0xB5, 0xFF, 0xF7, 0x9E, 0xFF,
+	0x00, 0xBD, 0x00, 0xB5,
+	0xFF, 0xF7, 0x9A, 0xFF, 0x00, 0xBD, 0x00, 0xB5, 0xFF, 0xF7, 0x96, 0xFF,
+	0x00, 0xBD, 0x10, 0xB5,
+	0xFF, 0xF7, 0x92, 0xFF, 0xBD, 0xE8, 0x10, 0x40, 0xEA, 0xF7, 0xFE, 0xBC,
+	0x00, 0xB5, 0xFF, 0xF7,
+	0x8B, 0xFF, 0x00, 0xBD, 0x00, 0xB5, 0xFF, 0xF7, 0x87, 0xFF, 0x00, 0xBD,
+	0x00, 0xB5, 0xFF, 0xF7,
+	0x83, 0xFF, 0x00, 0xBD, 0x00, 0xB5, 0xFF, 0xF7, 0x7F, 0xFF, 0x00, 0xBD,
+	0x00, 0xB5, 0xFF, 0xF7,
+	0x7B, 0xFF, 0x00, 0xBD, 0x70, 0x47, 0x00, 0x00, 0x10, 0xED, 0x00, 0xE0,
+	0x10, 0xB5, 0x4A, 0xF2,
+	0x33, 0x20, 0xE9, 0xF7, 0xB4, 0xFF, 0xFC, 0xF7, 0x19, 0xF8, 0xFB, 0xF7,
+	0x2D, 0xFE, 0xE9, 0xF7,
+	0x33, 0xFA, 0x00, 0x21, 0x47, 0x20, 0xFB, 0xF7, 0x74, 0xFA, 0x01, 0x20,
+	0x10, 0xBD, 0x53, 0xEA,
+	0x02, 0x0C, 0x00, 0xF0, 0x69, 0x80, 0x2D, 0xE9, 0xF0, 0x4B, 0x4F, 0xF0,
+	0x00, 0x06, 0x00, 0x2B,
+	0x1F, 0xBF, 0xB3, 0xFA, 0x83, 0xF5, 0x03, 0xFA, 0x05, 0xF4, 0x24, 0xFA,
+	0x05, 0xF6, 0x5E, 0x40,
+	0x12, 0xBF, 0x16, 0x43, 0xB2, 0xFA, 0x82, 0xF5, 0x02, 0xFA, 0x05, 0xF4,
+	0xC5, 0xF1, 0x20, 0x05,
+	0x1E, 0xBF, 0x22, 0xFA, 0x05, 0xFC, 0x44, 0xEA, 0x0C, 0x04, 0x20, 0x35,
+	0x56, 0xEA, 0x04, 0x4C,
+	0x4F, 0xEA, 0x14, 0x44, 0x18, 0xBF, 0x64, 0x1C, 0x4F, 0xF0, 0x00, 0x08,
+	0x4F, 0xF0, 0x00, 0x09,
+	0x90, 0x42, 0x71, 0xEB, 0x03, 0x0C, 0x39, 0xD3, 0x00, 0x29, 0x19, 0xBF,
+	0xB1, 0xFA, 0x81, 0xF7,
+	0x01, 0xFA, 0x07, 0xF6, 0xB0, 0xFA, 0x80, 0xF7, 0x00, 0xFA, 0x07, 0xF6,
+	0xC7, 0xF1, 0x20, 0x07,
+	0x1E, 0xBF, 0x20, 0xFA, 0x07, 0xFC, 0x46, 0xEA, 0x0C, 0x06, 0x20, 0x37,
+	0xB6, 0xFB, 0xF4, 0xFC,
+	0xA7, 0xEB, 0x05, 0x07, 0x10, 0x3F, 0x07, 0xF0, 0x1F, 0x0B, 0xCB, 0xF1,
+	0x20, 0x06, 0x0C, 0xFA,
+	0x0B, 0xFB, 0x2C, 0xFA, 0x06, 0xF6, 0x44, 0xBF, 0xB3, 0x46, 0x00, 0x26,
+	0x20, 0x2F, 0xA4, 0xBF,
+	0x5E, 0x46, 0x4F, 0xF0, 0x00, 0x0B, 0x5B, 0xEA, 0x06, 0x0C, 0x08, 0xBF,
+	0x4F, 0xF0, 0x01, 0x0B,
+	0x19, 0xEB, 0x0B, 0x09, 0xAB, 0xFB, 0x02, 0x7C, 0x48, 0xEB, 0x06, 0x08,
+	0xC0, 0x1B, 0x06, 0xFB,
+	0x02, 0xCC, 0x0B, 0xFB, 0x03, 0xCC, 0x71, 0xEB, 0x0C, 0x01, 0xC1, 0xE7,
+	0x0B, 0x46, 0x02, 0x46,
+	0x41, 0x46, 0x48, 0x46, 0xBD, 0xE8, 0xF0, 0x8B, 0x13, 0xB5, 0x4F, 0xF0,
+	0x00, 0x00, 0x4F, 0xF0,
+	0x00, 0x01, 0xAF, 0xF3, 0x00, 0x80, 0xBD, 0xE8, 0x1C, 0x40, 0x70, 0x47,
+	0xB2, 0xF1, 0x20, 0x03,
+	0x0A, 0xD5, 0xC2, 0xF1, 0x20, 0x03, 0x01, 0xFA, 0x02, 0xF1, 0x20, 0xFA,
+	0x03, 0xF3, 0x00, 0xFA,
+	0x02, 0xF0, 0x41, 0xEA, 0x03, 0x01, 0x70, 0x47, 0x00, 0xFA, 0x03, 0xF1,
+	0x4F, 0xF0, 0x00, 0x00,
+	0x70, 0x47, 0x10, 0xB5, 0x4C, 0x10, 0x84, 0xEA, 0x53, 0x04, 0x04, 0xD5,
+	0x40, 0x42, 0xC1, 0xF1,
+	0x00, 0x01, 0x38, 0xBF, 0x49, 0x1E, 0x1B, 0x42, 0x04, 0xD5, 0x52, 0x42,
+	0xC3, 0xF1, 0x00, 0x03,
+	0x38, 0xBF, 0x5B, 0x1E, 0xFF, 0xF7, 0x63, 0xFF, 0x14, 0xF0, 0x80, 0x4F,
+	0x04, 0xD0, 0x40, 0x42,
+	0xC1, 0xF1, 0x00, 0x01, 0x38, 0xBF, 0x49, 0x1E, 0x14, 0xF0, 0x00, 0x4F,
+	0x04, 0xD0, 0x52, 0x42,
+	0xC3, 0xF1, 0x00, 0x03, 0x38, 0xBF, 0x5B, 0x1E, 0x10, 0xBD, 0x03, 0x2A,
+	0x40, 0xF2, 0x30, 0x80,
+	0x10, 0xF0, 0x03, 0x0C, 0x00, 0xF0, 0x15, 0x80, 0x11, 0xF8, 0x01, 0x3B,
+	0xBC, 0xF1, 0x02, 0x0F,
+	0x62, 0x44, 0x98, 0xBF, 0x11, 0xF8, 0x01, 0xCB, 0x00, 0xF8, 0x01, 0x3B,
+	0x38, 0xBF, 0x11, 0xF8,
+	0x01, 0x3B, 0xA2, 0xF1, 0x04, 0x02, 0x98, 0xBF, 0x00, 0xF8, 0x01, 0xCB,
+	0x38, 0xBF, 0x00, 0xF8,
+	0x01, 0x3B, 0x11, 0xF0, 0x03, 0x03, 0x00, 0xF0, 0x25, 0x80, 0x08, 0x3A,
+	0xC0, 0xF0, 0x08, 0x80,
+	0x51, 0xF8, 0x04, 0x3B, 0x08, 0x3A, 0x51, 0xF8, 0x04, 0xCB, 0xA0, 0xE8,
+	0x08, 0x10, 0xF5, 0xE7,
+	0x12, 0x1D, 0x5C, 0xBF, 0x51, 0xF8, 0x04, 0x3B, 0x40, 0xF8, 0x04, 0x3B,
+	0xAF, 0xF3, 0x00, 0x80,
+	0xD2, 0x07, 0x24, 0xBF, 0x11, 0xF8, 0x01, 0x3B, 0x11, 0xF8, 0x01, 0xCB,
+	0x48, 0xBF, 0x11, 0xF8,
+	0x01, 0x2B, 0x24, 0xBF, 0x00, 0xF8, 0x01, 0x3B, 0x00, 0xF8, 0x01, 0xCB,
+	0x48, 0xBF, 0x00, 0xF8,
+	0x01, 0x2B, 0x70, 0x47, 0x10, 0xB5, 0x20, 0x3A, 0xC0, 0xF0, 0x0B, 0x80,
+	0xB1, 0xE8, 0x18, 0x50,
+	0x20, 0x3A, 0xA0, 0xE8, 0x18, 0x50, 0xB1, 0xE8, 0x18, 0x50, 0xA0, 0xE8,
+	0x18, 0x50, 0xBF, 0xF4,
+	0xF5, 0xAF, 0x5F, 0xEA, 0x02, 0x7C, 0x24, 0xBF, 0xB1, 0xE8, 0x18, 0x50,
+	0xA0, 0xE8, 0x18, 0x50,
+	0x44, 0xBF, 0x18, 0xC9, 0x18, 0xC0, 0xBD, 0xE8, 0x10, 0x40, 0x5F, 0xEA,
+	0x82, 0x7C, 0x24, 0xBF,
+	0x51, 0xF8, 0x04, 0x3B, 0x40, 0xF8, 0x04, 0x3B, 0x08, 0xBF, 0x70, 0x47,
+	0xD2, 0x07, 0x28, 0xBF,
+	0x31, 0xF8, 0x02, 0x3B, 0x48, 0xBF, 0x11, 0xF8, 0x01, 0x2B, 0x28, 0xBF,
+	0x20, 0xF8, 0x02, 0x3B,
+	0x48, 0xBF, 0x00, 0xF8, 0x01, 0x2B, 0x70, 0x47, 0x02, 0xF0, 0xFF, 0x03,
+	0x43, 0xEA, 0x03, 0x22,
+	0x42, 0xEA, 0x02, 0x42, 0x00, 0xF0, 0x02, 0xB8, 0x4F, 0xF0, 0x00, 0x02,
+	0x04, 0x29, 0xC0, 0xF0,
+	0x12, 0x80, 0x10, 0xF0, 0x03, 0x0C, 0x00, 0xF0, 0x1B, 0x80, 0xCC, 0xF1,
+	0x04, 0x0C, 0xBC, 0xF1,
+	0x02, 0x0F, 0x18, 0xBF, 0x00, 0xF8, 0x01, 0x2B, 0xA8, 0xBF, 0x20, 0xF8,
+	0x02, 0x2B, 0xA1, 0xEB,
+	0x0C, 0x01, 0x00, 0xF0, 0x0D, 0xB8, 0x5F, 0xEA, 0xC1, 0x7C, 0x24, 0xBF,
+	0x00, 0xF8, 0x01, 0x2B,
+	0x00, 0xF8, 0x01, 0x2B, 0x48, 0xBF, 0x00, 0xF8, 0x01, 0x2B, 0x70, 0x47,
+	0x4F, 0xF0, 0x00, 0x02,
+	0x00, 0xB5, 0x13, 0x46, 0x94, 0x46, 0x96, 0x46, 0x20, 0x39, 0x22, 0xBF,
+	0xA0, 0xE8, 0x0C, 0x50,
+	0xA0, 0xE8, 0x0C, 0x50, 0xB1, 0xF1, 0x20, 0x01, 0xBF, 0xF4, 0xF7, 0xAF,
+	0x09, 0x07, 0x28, 0xBF,
+	0xA0, 0xE8, 0x0C, 0x50, 0x48, 0xBF, 0x0C, 0xC0, 0x5D, 0xF8, 0x04, 0xEB,
+	0x89, 0x00, 0x28, 0xBF,
+	0x40, 0xF8, 0x04, 0x2B, 0x08, 0xBF, 0x70, 0x47, 0x48, 0xBF, 0x20, 0xF8,
+	0x02, 0x2B, 0x11, 0xF0,
+	0x80, 0x4F, 0x18, 0xBF, 0x00, 0xF8, 0x01, 0x2B, 0x70, 0x47, 0x04, 0x46,
+	0xAF, 0xF3, 0x00, 0x80,
+	0x20, 0x46, 0xE8, 0xF7, 0x93, 0xFF, 0x00, 0x00, 0x01, 0x49, 0x18, 0x20,
+	0xAB, 0xBE, 0xFE, 0xE7,
+	0x26, 0x00, 0x02, 0x00, 0x70, 0x47, 0x00, 0x00, 0x01, 0x49, 0x00, 0x20,
+	0x08, 0x60, 0x70, 0x47,
+	0x3C, 0x05, 0x00, 0x22, 0x2D, 0xE9, 0xF0, 0x41, 0x00, 0x24, 0x01, 0x27,
+	0xDF, 0xF8, 0x38, 0x80,
+	0x5F, 0xEA, 0x47, 0x75, 0x07, 0xFA, 0x04, 0xF0, 0xC6, 0xB2, 0x95, 0xF8,
+	0x2F, 0x00, 0x30, 0x42,
+	0x0C, 0xD0, 0x95, 0xF8, 0x39, 0x00, 0x30, 0x42, 0x08, 0xD0, 0x58, 0xF8,
+	0x24, 0x00, 0x00, 0xB1,
+	0x80, 0x47, 0x95, 0xF8, 0x2F, 0x00, 0xB0, 0x43, 0x85, 0xF8, 0x2F, 0x00,
+	0x64, 0x1C, 0x06, 0x2C,
+	0xE8, 0xDB, 0xBD, 0xE8, 0xF0, 0x81, 0x00, 0x00, 0xD4, 0x0E, 0x10, 0x00,
+	0x2D, 0xE9, 0xF0, 0x41,
+	0x00, 0x24, 0x01, 0x27, 0xDF, 0xF8, 0x38, 0x80, 0x5F, 0xEA, 0x47, 0x75,
+	0x07, 0xFA, 0x04, 0xF0,
+	0xC6, 0xB2, 0x95, 0xF8, 0x2E, 0x00, 0x30, 0x42, 0x0C, 0xD0, 0x95, 0xF8,
+	0x38, 0x00, 0x30, 0x42,
+	0x08, 0xD0, 0x58, 0xF8, 0x24, 0x00, 0x00, 0xB1, 0x80, 0x47, 0x95, 0xF8,
+	0x2E, 0x00, 0xB0, 0x43,
+	0x85, 0xF8, 0x2E, 0x00, 0x64, 0x1C, 0x06, 0x2C, 0xE8, 0xDB, 0xBD, 0xE8,
+	0xF0, 0x81, 0x00, 0x00,
+	0xB4, 0x0E, 0x10, 0x00, 0x01, 0x21, 0x81, 0x40, 0xC8, 0xB2, 0x4F, 0xF0,
+	0x00, 0x51, 0x91, 0xF8,
+	0x33, 0x10, 0x01, 0x42, 0x01, 0xD0, 0x01, 0x20, 0x70, 0x47, 0x00, 0x20,
+	0x70, 0x47, 0x00, 0x00,
+	0x01, 0x49, 0x01, 0x20, 0x08, 0x60, 0x70, 0x47, 0x3C, 0x05, 0x00, 0x22,
+	0x07, 0x48, 0x41, 0x78,
+	0x49, 0xB1, 0x80, 0x78, 0x38, 0xB1, 0x06, 0x48, 0x00, 0x78, 0x01, 0x28,
+	0x03, 0xD1, 0x05, 0x48,
+	0x00, 0x78, 0x01, 0x28, 0x00, 0xD0, 0x00, 0x20, 0x70, 0x47, 0x00, 0x00,
+	0x74, 0x07, 0x10, 0x00,
+	0xFD, 0x06, 0x10, 0x00, 0x5C, 0x05, 0x10, 0x00, 0x03, 0x48, 0x41, 0x78,
+	0x11, 0xB9, 0x80, 0x78,
+	0x00, 0x28, 0x00, 0xD0, 0x01, 0x20, 0x70, 0x47, 0x74, 0x07, 0x10, 0x00,
+	0x01, 0x48, 0x00, 0x78,
+	0x70, 0x47, 0x00, 0x00, 0x74, 0x06, 0x10, 0x00, 0xC0, 0x6E, 0x70, 0x47,
+	0x90, 0xF8, 0x73, 0x00,
+	0x70, 0x47, 0x90, 0xF8, 0x72, 0x00, 0x70, 0x47, 0x04, 0x48, 0x41, 0x78,
+	0x82, 0x78, 0x00, 0x78,
+	0x11, 0x44, 0x08, 0x18, 0x00, 0xD0, 0x01, 0x20, 0x70, 0x47, 0x00, 0x00,
+	0x2D, 0x06, 0x10, 0x00,
+	0x70, 0xB5, 0xD0, 0xE9, 0x00, 0x21, 0x4C, 0x08, 0x4F, 0xEA, 0x32, 0x03,
+	0x96, 0x18, 0x41, 0xEB,
+	0x01, 0x05, 0x33, 0x43, 0x2C, 0x43, 0x13, 0x43, 0x0C, 0x43, 0xC0, 0xE9,
+	0x00, 0x34, 0x70, 0xBD,
+	0x01, 0xEB, 0x81, 0x01, 0x00, 0xEB, 0xC1, 0x00, 0x29, 0x30, 0x70, 0x47,
+	0x02, 0x4A, 0x12, 0x78,
+	0x51, 0x43, 0x00, 0xEB, 0x41, 0x00, 0x70, 0x47, 0xEE, 0x06, 0x10, 0x00,
+	0x01, 0xEB, 0x81, 0x01,
+	0x00, 0xEB, 0xC1, 0x00, 0x29, 0x30, 0x70, 0x47, 0x02, 0x4A, 0x12, 0x78,
+	0x51, 0x43, 0x00, 0xEB,
+	0x41, 0x00, 0x70, 0x47, 0xEE, 0x06, 0x10, 0x00, 0x00, 0x04, 0x40, 0x00,
+	0x10, 0x21, 0x00, 0x00,
+	0x00, 0x1F, 0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00,
+	0x00, 0x04, 0x06, 0x00,
+	0x08, 0x02, 0x50, 0x00, 0x60, 0x02, 0x0C, 0x0C, 0x00, 0x00, 0x60, 0x02,
+	0x0C, 0x30, 0x0C, 0x1A,
+	0x31, 0x10, 0x0F, 0x0F, 0x00, 0x00, 0x2F, 0x00, 0x01, 0x00, 0xAA, 0x2C,
+	0x01, 0x00, 0x00, 0x00,
+	0x03, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x18, 0x00, 0x00, 0x00,
+	0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x01, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x60, 0x02, 0x01, 0x80, 0x00, 0x01, 0x00, 0x00,
+	0x00, 0x00, 0x0C, 0x00,
+	0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x07, 0x01, 0x26, 0x26, 0x12, 0x12,
+	0x11, 0x00, 0x00, 0x00,
+	0x00, 0x38, 0x00, 0x3C, 0x20, 0x3D, 0xD0, 0x41, 0xEC, 0x41, 0x08, 0x42,
+	0x1C, 0x42, 0x30, 0x42,
+	0x44, 0x42, 0x60, 0x42, 0x74, 0x42, 0x88, 0x42, 0xA4, 0x42, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
+	0x00, 0x01, 0x01, 0x02,
+	0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04,
+	0x00, 0x00, 0x00, 0x00,
+	0x1B, 0x00, 0x00, 0x80, 0x2D, 0x00, 0x00, 0x80, 0x36, 0x00, 0x00, 0x00,
+	0x41, 0x00, 0x00, 0x80,
+	0x5A, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00, 0x80,
+	0x99, 0x00, 0x00, 0x80,
+	0x82, 0x00, 0x00, 0x00, 0xB4, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x80,
+	0xD8, 0x00, 0x00, 0x00,
+	0xC3, 0x00, 0x00, 0x80, 0xF5, 0x00, 0x00, 0x80, 0xEE, 0x00, 0x00, 0x00,
+	0x29, 0x01, 0x00, 0x80,
+	0x32, 0x01, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x80,
+	0x68, 0x01, 0x00, 0x00,
+	0x73, 0x01, 0x00, 0x80, 0x45, 0x01, 0x00, 0x80, 0x5E, 0x01, 0x00, 0x00,
+	0xB0, 0x01, 0x00, 0x00,
+	0xAB, 0x01, 0x00, 0x80, 0x9D, 0x01, 0x00, 0x80, 0x86, 0x01, 0x00, 0x00,
+	0xF1, 0x01, 0x00, 0x80,
+	0xEA, 0x01, 0x00, 0x00, 0xDC, 0x01, 0x00, 0x00, 0xC7, 0x01, 0x00, 0x80,
+	0x49, 0x02, 0x00, 0x80,
+	0x52, 0x02, 0x00, 0x00, 0x64, 0x02, 0x00, 0x00, 0x7F, 0x02, 0x00, 0x80,
+	0x08, 0x02, 0x00, 0x00,
+	0x13, 0x02, 0x00, 0x80, 0x25, 0x02, 0x00, 0x80, 0x3E, 0x02, 0x00, 0x00,
+	0xD0, 0x02, 0x00, 0x00,
+	0xCB, 0x02, 0x00, 0x80, 0xFD, 0x02, 0x00, 0x80, 0xE6, 0x02, 0x00, 0x00,
+	0x91, 0x02, 0x00, 0x80,
+	0x8A, 0x02, 0x00, 0x00, 0xBC, 0x02, 0x00, 0x00, 0xA7, 0x02, 0x00, 0x80,
+	0x60, 0x03, 0x00, 0x00,
+	0x7B, 0x03, 0x00, 0x80, 0x4D, 0x03, 0x00, 0x80, 0x56, 0x03, 0x00, 0x00,
+	0x21, 0x03, 0x00, 0x80,
+	0x3A, 0x03, 0x00, 0x00, 0x0C, 0x03, 0x00, 0x00, 0x17, 0x03, 0x00, 0x80,
+	0xF9, 0x03, 0x00, 0x80,
+	0xE2, 0x03, 0x00, 0x00, 0xD4, 0x03, 0x00, 0x00, 0xCF, 0x03, 0x00, 0x80,
+	0xB8, 0x03, 0x00, 0x00,
+	0xA3, 0x03, 0x00, 0x80, 0x95, 0x03, 0x00, 0x80, 0x8E, 0x03, 0x00, 0x00,
+	0x89, 0x04, 0x00, 0x80,
+	0x92, 0x04, 0x00, 0x00, 0xA4, 0x04, 0x00, 0x00, 0xBF, 0x04, 0x00, 0x80,
+	0xC8, 0x04, 0x00, 0x00,
+	0xD3, 0x04, 0x00, 0x80, 0xE5, 0x04, 0x00, 0x80, 0xFE, 0x04, 0x00, 0x00,
+	0x10, 0x04, 0x00, 0x00,
+	0x0B, 0x04, 0x00, 0x80, 0x3D, 0x04, 0x00, 0x80, 0x26, 0x04, 0x00, 0x00,
+	0x51, 0x04, 0x00, 0x80,
+	0x4A, 0x04, 0x00, 0x00, 0x7C, 0x04, 0x00, 0x00, 0x67, 0x04, 0x00, 0x80,
+	0xA0, 0x05, 0x00, 0x00,
+	0xBB, 0x05, 0x00, 0x80, 0x8D, 0x05, 0x00, 0x80, 0x96, 0x05, 0x00, 0x00,
+	0xE1, 0x05, 0x00, 0x80,
+	0xFA, 0x05, 0x00, 0x00, 0xCC, 0x05, 0x00, 0x00, 0xD7, 0x05, 0x00, 0x80,
+	0x39, 0x05, 0x00, 0x80,
+	0x22, 0x05, 0x00, 0x00, 0x14, 0x05, 0x00, 0x00, 0x0F, 0x05, 0x00, 0x80,
+	0x78, 0x05, 0x00, 0x00,
+	0x63, 0x05, 0x00, 0x80, 0x55, 0x05, 0x00, 0x80, 0x4E, 0x05, 0x00, 0x00,
+	0xC0, 0x06, 0x00, 0x00,
+	0xDB, 0x06, 0x00, 0x80, 0xED, 0x06, 0x00, 0x80, 0xF6, 0x06, 0x00, 0x00,
+	0x81, 0x06, 0x00, 0x80,
+	0x9A, 0x06, 0x00, 0x00, 0xAC, 0x06, 0x00, 0x00, 0xB7, 0x06, 0x00, 0x80,
+	0x59, 0x06, 0x00, 0x80,
+	0x42, 0x06, 0x00, 0x00, 0x74, 0x06, 0x00, 0x00, 0x6F, 0x06, 0x00, 0x80,
+	0x18, 0x06, 0x00, 0x00,
+	0x03, 0x06, 0x00, 0x80, 0x35, 0x06, 0x00, 0x80, 0x2E, 0x06, 0x00, 0x00,
+	0xE9, 0x07, 0x00, 0x80,
+	0xF2, 0x07, 0x00, 0x00, 0xC4, 0x07, 0x00, 0x00, 0xDF, 0x07, 0x00, 0x80,
+	0xA8, 0x07, 0x00, 0x00,
+	0xB3, 0x07, 0x00, 0x80, 0x85, 0x07, 0x00, 0x80, 0x9E, 0x07, 0x00, 0x00,
+	0x70, 0x07, 0x00, 0x00,
+	0x6B, 0x07, 0x00, 0x80, 0x5D, 0x07, 0x00, 0x80, 0x46, 0x07, 0x00, 0x00,
+	0x31, 0x07, 0x00, 0x80,
+	0x2A, 0x07, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x00, 0x07, 0x07, 0x00, 0x80,
+	0x09, 0x09, 0x00, 0x80,
+	0x12, 0x09, 0x00, 0x00, 0x24, 0x09, 0x00, 0x00, 0x3F, 0x09, 0x00, 0x80,
+	0x48, 0x09, 0x00, 0x00,
+	0x53, 0x09, 0x00, 0x80, 0x65, 0x09, 0x00, 0x80, 0x7E, 0x09, 0x00, 0x00,
+	0x90, 0x09, 0x00, 0x00,
+	0x8B, 0x09, 0x00, 0x80, 0xBD, 0x09, 0x00, 0x80, 0xA6, 0x09, 0x00, 0x00,
+	0xD1, 0x09, 0x00, 0x80,
+	0xCA, 0x09, 0x00, 0x00, 0xFC, 0x09, 0x00, 0x00, 0xE7, 0x09, 0x00, 0x80,
+	0x20, 0x08, 0x00, 0x00,
+	0x3B, 0x08, 0x00, 0x80, 0x0D, 0x08, 0x00, 0x80, 0x16, 0x08, 0x00, 0x00,
+	0x61, 0x08, 0x00, 0x80,
+	0x7A, 0x08, 0x00, 0x00, 0x4C, 0x08, 0x00, 0x00, 0x57, 0x08, 0x00, 0x80,
+	0xB9, 0x08, 0x00, 0x80,
+	0xA2, 0x08, 0x00, 0x00, 0x94, 0x08, 0x00, 0x00, 0x8F, 0x08, 0x00, 0x80,
+	0xF8, 0x08, 0x00, 0x00,
+	0xE3, 0x08, 0x00, 0x80, 0xD5, 0x08, 0x00, 0x80, 0xCE, 0x08, 0x00, 0x00,
+	0x40, 0x0B, 0x00, 0x00,
+	0x5B, 0x0B, 0x00, 0x80, 0x6D, 0x0B, 0x00, 0x80, 0x76, 0x0B, 0x00, 0x00,
+	0x01, 0x0B, 0x00, 0x80,
+	0x1A, 0x0B, 0x00, 0x00, 0x2C, 0x0B, 0x00, 0x00, 0x37, 0x0B, 0x00, 0x80,
+	0xD9, 0x0B, 0x00, 0x80,
+	0xC2, 0x0B, 0x00, 0x00, 0xF4, 0x0B, 0x00, 0x00, 0xEF, 0x0B, 0x00, 0x80,
+	0x98, 0x0B, 0x00, 0x00,
+	0x83, 0x0B, 0x00, 0x80, 0xB5, 0x0B, 0x00, 0x80, 0xAE, 0x0B, 0x00, 0x00,
+	0x69, 0x0A, 0x00, 0x80,
+	0x72, 0x0A, 0x00, 0x00, 0x44, 0x0A, 0x00, 0x00, 0x5F, 0x0A, 0x00, 0x80,
+	0x28, 0x0A, 0x00, 0x00,
+	0x33, 0x0A, 0x00, 0x80, 0x05, 0x0A, 0x00, 0x80, 0x1E, 0x0A, 0x00, 0x00,
+	0xF0, 0x0A, 0x00, 0x00,
+	0xEB, 0x0A, 0x00, 0x80, 0xDD, 0x0A, 0x00, 0x80, 0xC6, 0x0A, 0x00, 0x00,
+	0xB1, 0x0A, 0x00, 0x80,
+	0xAA, 0x0A, 0x00, 0x00, 0x9C, 0x0A, 0x00, 0x00, 0x87, 0x0A, 0x00, 0x80,
+	0x80, 0x0D, 0x00, 0x00,
+	0x9B, 0x0D, 0x00, 0x80, 0xAD, 0x0D, 0x00, 0x80, 0xB6, 0x0D, 0x00, 0x00,
+	0xC1, 0x0D, 0x00, 0x80,
+	0xDA, 0x0D, 0x00, 0x00, 0xEC, 0x0D, 0x00, 0x00, 0xF7, 0x0D, 0x00, 0x80,
+	0x19, 0x0D, 0x00, 0x80,
+	0x02, 0x0D, 0x00, 0x00, 0x34, 0x0D, 0x00, 0x00, 0x2F, 0x0D, 0x00, 0x80,
+	0x58, 0x0D, 0x00, 0x00,
+	0x43, 0x0D, 0x00, 0x80, 0x75, 0x0D, 0x00, 0x80, 0x6E, 0x0D, 0x00, 0x00,
+	0xA9, 0x0C, 0x00, 0x80,
+	0xB2, 0x0C, 0x00, 0x00, 0x84, 0x0C, 0x00, 0x00, 0x9F, 0x0C, 0x00, 0x80,
+	0xE8, 0x0C, 0x00, 0x00,
+	0xF3, 0x0C, 0x00, 0x80, 0xC5, 0x0C, 0x00, 0x80, 0xDE, 0x0C, 0x00, 0x00,
+	0x30, 0x0C, 0x00, 0x00,
+	0x2B, 0x0C, 0x00, 0x80, 0x1D, 0x0C, 0x00, 0x80, 0x06, 0x0C, 0x00, 0x00,
+	0x71, 0x0C, 0x00, 0x80,
+	0x6A, 0x0C, 0x00, 0x00, 0x5C, 0x0C, 0x00, 0x00, 0x47, 0x0C, 0x00, 0x80,
+	0xC9, 0x0F, 0x00, 0x80,
+	0xD2, 0x0F, 0x00, 0x00, 0xE4, 0x0F, 0x00, 0x00, 0xFF, 0x0F, 0x00, 0x80,
+	0x88, 0x0F, 0x00, 0x00,
+	0x93, 0x0F, 0x00, 0x80, 0xA5, 0x0F, 0x00, 0x80, 0xBE, 0x0F, 0x00, 0x00,
+	0x50, 0x0F, 0x00, 0x00,
+	0x4B, 0x0F, 0x00, 0x80, 0x7D, 0x0F, 0x00, 0x80, 0x66, 0x0F, 0x00, 0x00,
+	0x11, 0x0F, 0x00, 0x80,
+	0x0A, 0x0F, 0x00, 0x00, 0x3C, 0x0F, 0x00, 0x00, 0x27, 0x0F, 0x00, 0x80,
+	0xE0, 0x0E, 0x00, 0x00,
+	0xFB, 0x0E, 0x00, 0x80, 0xCD, 0x0E, 0x00, 0x80, 0xD6, 0x0E, 0x00, 0x00,
+	0xA1, 0x0E, 0x00, 0x80,
+	0xBA, 0x0E, 0x00, 0x00, 0x8C, 0x0E, 0x00, 0x00, 0x97, 0x0E, 0x00, 0x80,
+	0x79, 0x0E, 0x00, 0x80,
+	0x62, 0x0E, 0x00, 0x00, 0x54, 0x0E, 0x00, 0x00, 0x4F, 0x0E, 0x00, 0x80,
+	0x38, 0x0E, 0x00, 0x00,
+	0x23, 0x0E, 0x00, 0x80, 0x15, 0x0E, 0x00, 0x80, 0x0E, 0x0E, 0x00, 0x00,
+	0xFF, 0x00, 0xBE, 0x94,
+	0xFE, 0xFF, 0x27, 0xC4, 0xFE, 0xFF, 0x59, 0xF2, 0xFE, 0xFF, 0x6B, 0x1F,
+	0xFF, 0xFF, 0x81, 0x4B,
+	0xFF, 0xFF, 0xC5, 0x76, 0xFF, 0xFF, 0x67, 0xA1, 0xFF, 0xFF, 0x97, 0xCB,
+	0xFF, 0xFF, 0x88, 0xF5,
+	0xFF, 0xFF, 0x6C, 0x1F, 0x00, 0x00, 0x76, 0x49, 0x00, 0x00, 0xD9, 0x73,
+	0x00, 0x00, 0xC6, 0x9E,
+	0x00, 0x00, 0x6D, 0xCA, 0x00, 0x00, 0xFC, 0xF6, 0x00, 0x00, 0x9A, 0x24,
+	0x01, 0x00, 0x66, 0x53,
+	0x01, 0x00, 0xA3, 0x8D, 0x00, 0x00, 0x71, 0x74, 0x00, 0x00, 0x02, 0x60,
+	0x00, 0x00, 0xA2, 0x4F,
+	0x00, 0x00, 0xC8, 0x42, 0x00, 0x00, 0x0C, 0x39, 0x00, 0x00, 0x21, 0x32,
+	0x00, 0x00, 0xD2, 0x2D,
+	0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x9B, 0x2C, 0x00, 0x00, 0xA9, 0x2F,
+	0x00, 0x00, 0x40, 0x35,
+	0x00, 0x00, 0x8B, 0x3D, 0x00, 0x00, 0xCB, 0x48, 0x00, 0x00, 0x59, 0x57,
+	0x00, 0x00, 0xAD, 0x69,
+	0x00, 0x00, 0x65, 0x80, 0x00, 0x00, 0x30, 0x11, 0x00, 0x00, 0x4C, 0x1C,
+	0x00, 0x00, 0x2D, 0x29,
+	0x00, 0x00, 0x86, 0x37, 0x00, 0x00, 0x24, 0x47, 0x00, 0x00, 0xE8, 0x57,
+	0x00, 0x00, 0xC4, 0x69,
+	0x00, 0x00, 0xB5, 0x7C, 0x00, 0x00, 0xC4, 0x90, 0x00, 0x00, 0x03, 0xA6,
+	0x00, 0x00, 0x8F, 0xBC,
+	0x00, 0x00, 0x8C, 0xD4, 0x00, 0x00, 0x29, 0xEE, 0x00, 0x00, 0x9C, 0x09,
+	0x01, 0x00, 0x2B, 0x27,
+	0x01, 0x00, 0x24, 0x47, 0x01, 0x00, 0xE6, 0x69, 0x01, 0x00, 0x98, 0x08,
+	0x00, 0x00, 0x26, 0x0E,
+	0x00, 0x00, 0x97, 0x14, 0x00, 0x00, 0xC3, 0x1B, 0x00, 0x00, 0x92, 0x23,
+	0x00, 0x00, 0xF4, 0x2B,
+	0x00, 0x00, 0xE2, 0x34, 0x00, 0x00, 0x5A, 0x3E, 0x00, 0x00, 0x62, 0x48,
+	0x00, 0x00, 0x02, 0x53,
+	0x00, 0x00, 0x48, 0x5E, 0x00, 0x00, 0x46, 0x6A, 0x00, 0x00, 0x14, 0x77,
+	0x00, 0x00, 0xCE, 0x84,
+	0x00, 0x00, 0x95, 0x93, 0x00, 0x00, 0x92, 0xA3, 0x00, 0x00, 0xF3, 0xB4,
+	0x00, 0x00, 0x01, 0x00,
+	0x02, 0x00, 0x01, 0x00, 0x02, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00,
+	0x02, 0x00, 0x01, 0x00,
+	0x10, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x14, 0x00,
+	0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0x0C, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0xF8, 0x47, 0x10, 0x00, 0x44, 0x4D, 0x10, 0x00, 0xC5, 0x18, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0xC3, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD1, 0x17, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0xDF, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x17, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x09, 0x18, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x6B, 0x18, 0x01, 0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0x81, 0x18, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0xB5, 0x18, 0x01, 0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0xB7, 0x18, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0xB9, 0x18, 0x01, 0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0xBB, 0x18, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xBD, 0x18, 0x01, 0x00,
+	0x02, 0x00, 0x00, 0x00,
+	0xBF, 0x18, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0xC1, 0x18, 0x01, 0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0xC3, 0x18, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x01, 0x00,
+	0xFB, 0x18, 0x01, 0x00,
+	0x65, 0x19, 0x01, 0x00, 0xFB, 0x18, 0x01, 0x00, 0x17, 0x1A, 0x01, 0x00,
+	0xFB, 0x18, 0x01, 0x00,
+	0xFB, 0x18, 0x01, 0x00, 0xFB, 0x18, 0x01, 0x00, 0xFB, 0x18, 0x01, 0x00,
+	0xFB, 0x18, 0x01, 0x00,
+	0x2F, 0x19, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0xFB, 0x18, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x61, 0x19, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x91, 0x19, 0x01, 0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0xB5, 0x19, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0xD9, 0x19, 0x01, 0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0x0F, 0x1A, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x13, 0x1A, 0x01, 0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0x43, 0x1A, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x91, 0x1A, 0x01, 0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0xA7, 0x1A, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0xFF, 0x1A, 0x01, 0x00,
+	0x02, 0x00, 0x00, 0x00,
+	0xB5, 0x1B, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x33, 0x1C, 0x01, 0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0x73, 0x1C, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x65, 0x1B, 0x01, 0x00,
+	0x02, 0x00, 0x00, 0x00,
+	0xFB, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFB, 0x18, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x5D, 0x1A, 0x01, 0x00, 0x67, 0x1A, 0x01, 0x00, 0x71, 0x1A, 0x01, 0x00,
+	0x81, 0x1A, 0x01, 0x00,
+	0xF5, 0x1D, 0x01, 0x00, 0x17, 0x1E, 0x01, 0x00, 0x1F, 0x1E, 0x01, 0x00,
+	0x3F, 0x1E, 0x01, 0x00,
+	0xA1, 0x1E, 0x01, 0x00, 0xB7, 0x1E, 0x01, 0x00, 0xC7, 0x1E, 0x01, 0x00,
+	0xD9, 0x1E, 0x01, 0x00,
+	0xEB, 0x1E, 0x01, 0x00, 0xFD, 0x1E, 0x01, 0x00, 0x0F, 0x1F, 0x01, 0x00,
+	0x21, 0x1F, 0x01, 0x00,
+	0x33, 0x1F, 0x01, 0x00, 0x45, 0x1F, 0x01, 0x00, 0x57, 0x1F, 0x01, 0x00,
+	0x69, 0x1F, 0x01, 0x00,
+	0x85, 0x86, 0x60, 0x61, 0xD0, 0x02, 0x0F, 0x01, 0x00, 0xA6, 0x02, 0x0F,
+	0x01, 0x00, 0xA8, 0x02,
+	0x0B, 0x03, 0x00, 0x72, 0x00, 0x0B, 0x01, 0x00, 0x73, 0x00, 0x08, 0x01,
+	0x00, 0x00, 0x00, 0x00,
+	0x49, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0xE3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x05, 0x00, 0x00, 0x00,
+	0x04, 0x69, 0x10, 0x00, 0x00, 0x04, 0x00, 0x00, 0xB5, 0x4E, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
+	0x04, 0x6D, 0x10, 0x00,
+	0x00, 0x04, 0x00, 0x00, 0xDD, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x02, 0x00, 0x00, 0x00,
+	0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x71, 0x10, 0x00,
+	0x00, 0x08, 0x00, 0x00,
+	0x8F, 0x15, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
+	0x03, 0x00, 0x00, 0x00,
+	0x02, 0x00, 0x00, 0x00, 0x04, 0x79, 0x10, 0x00, 0x00, 0x02, 0x00, 0x00,
+	0x01, 0x1D, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0x04, 0x7B, 0x10, 0x00, 0x80, 0x00, 0x00, 0x00, 0xB9, 0x16, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
+	0x03, 0x00, 0x00, 0x00,
+	0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
+	0x05, 0x00, 0x00, 0x00,
+	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
+	0x02, 0x00, 0x00, 0x00,
+	0x03, 0x00, 0x00, 0x00, 0xB1, 0x56, 0x01, 0x00, 0x5B, 0x56, 0x01, 0x00,
+	0x31, 0x6E, 0x01, 0x00,
+	0x23, 0x5B, 0x01, 0x00, 0x65, 0x48, 0x01, 0x00, 0x9B, 0x5D, 0x01, 0x00,
+	0x8F, 0x4D, 0x01, 0x00,
+	0x73, 0x68, 0x01, 0x00, 0xF1, 0x4E, 0x01, 0x00, 0x4D, 0x57, 0x01, 0x00,
+	0x47, 0x6E, 0x01, 0x00,
+	0x60, 0x7D, 0x01, 0x00, 0x00, 0x04, 0x10, 0x00, 0x0C, 0x04, 0x00, 0x00,
+	0x1C, 0x01, 0x00, 0x00,
+	0x98, 0x7D, 0x01, 0x00, 0x00, 0xFC, 0x10, 0x00, 0x40, 0x00, 0x00, 0x00,
+	0x78, 0x01, 0x00, 0x00,
+	0x98, 0x7D, 0x01, 0x00, 0x0C, 0x08, 0x10, 0x00, 0x88, 0x7D, 0x00, 0x00,
+	0x94, 0x01, 0x00, 0x00,
+	0x01, 0x29, 0x04, 0xFF, 0x90, 0xD0, 0x03, 0x01, 0x71, 0x14, 0x90, 0x5F,
+	0x01, 0x32, 0x01, 0x32,
+	0x02, 0x29, 0x08, 0x41, 0xA9, 0x08, 0x09, 0x1A, 0x0C, 0xB2, 0x64, 0x29,
+	0x0C, 0x69, 0x48, 0x29,
+	0x04, 0x0A, 0x11, 0x04, 0x10, 0x01, 0xFF, 0x01, 0x46, 0x07, 0xA5, 0xF0,
+	0x01, 0x20, 0x18, 0x50,
+	0x10, 0xAA, 0xFF, 0x0C, 0x59, 0x01, 0x00, 0x00, 0x30, 0xB5, 0x72, 0xB6,
+	0x01, 0x24, 0x0C, 0x4D,
+	0x2C, 0x60, 0x0C, 0x4B, 0x00, 0x22, 0x89, 0xB1, 0xC3, 0xF8, 0x00, 0x40,
+	0x4F, 0xF0, 0x00, 0x51,
+	0x00, 0xF0, 0x1F, 0x00, 0x81, 0xF8, 0x6A, 0x00, 0x06, 0x48, 0x1C, 0x38,
+	0x04, 0x60, 0x01, 0x68,
+	0x00, 0x29, 0xFC, 0xD1, 0x1A, 0x60, 0x2A, 0x60, 0x62, 0xB6, 0x30, 0xBD,
+	0x1A, 0x60, 0xED, 0xE7,
+	0xC0, 0x1B, 0x00, 0x22, 0x78, 0x0D, 0x00, 0x22, 0xD5, 0xA1, 0xA1, 0x0A,
+	0x93, 0x02, 0x00, 0x00,
+	0x2A, 0x5E, 0x5E, 0xF5, 0x6C, 0xFD, 0xFF, 0xFF, 0xA1, 0x00, 0xA1, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F,
+	0x00, 0x00, 0x00, 0x00,
+	0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x0F, 0xFF, 0x09,
+	0x9F, 0x05, 0x09, 0xFF,
+	0x09, 0x9F, 0x05, 0x1D, 0x02, 0x00, 0x00, 0x00, 0x01, 0x20, 0x40, 0x50,
+	0xAA, 0x99, 0xC8, 0x00,
+	0xC8, 0x00, 0xC8, 0x00, 0xC8, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
+	0x00, 0x01, 0x70, 0x00,
+	0x70, 0x00, 0x08, 0xB0, 0x00, 0xB0, 0x00, 0x00, 0x07, 0xAA, 0x38, 0xC8,
+	0x00, 0x04, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x08, 0x09, 0x0A,
+	0x14, 0x0A, 0x00, 0x02,
+	0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x13, 0xE8, 0x03,
+	0x64, 0x00, 0x64, 0x00,
+	0xD0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x64,
+	0x00, 0x00, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x08, 0x00, 0x02,
+	0x08, 0x00, 0x06, 0x00,
+	0x00, 0x00, 0x00, 0x08, 0x41, 0x01, 0x08, 0x00, 0x13, 0x0C, 0x41, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x81, 0x06, 0x52, 0x4F, 0x04, 0xD8, 0x10, 0x50, 0x00, 0x2F, 0x00, 0x08,
+	0xB0, 0x06, 0x03, 0x03,
+	0x00, 0x00, 0xBB, 0xBB, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xE9, 0xA6,
+	0x5E, 0x1F, 0x04, 0xD8, 0x18, 0x40, 0x00, 0x08, 0x00, 0x20, 0x50, 0x06,
+	0x07, 0x00, 0x00, 0x00,
+	0x20, 0x50, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x20,
+	0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89, 0x16,
+	0x50, 0x4F, 0x04, 0x18,
+	0x00, 0x30, 0x00, 0x06, 0x00, 0x2F, 0x00, 0x40, 0x10, 0x06, 0x00, 0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA9, 0x26,
+	0x9A, 0x1F, 0x98, 0x18,
+	0x01, 0x01, 0x30, 0x00, 0x60, 0x00, 0x60, 0x00, 0x2F, 0x00, 0x21, 0x01,
+	0x00, 0x00, 0x1F, 0x21,
+	0x01, 0x00, 0x00, 0x1F, 0x00, 0x01, 0x20, 0x00, 0x99, 0x24, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x0B,
+	0x00, 0x00, 0x00, 0x00,
+	0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x1A,
+	0x00, 0x00, 0x02, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x11, 0x1A, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x11, 0x1A, 0x00, 0x00, 0x02, 0x00, 0x01, 0x01, 0x64, 0x00,
+	0x64, 0x00, 0xD0, 0x00,
+	0x80, 0x0C, 0xF0, 0x0A, 0xD0, 0x00, 0x00, 0x15, 0x00, 0x12, 0x50, 0x01,
+	0x50, 0x01, 0x00, 0x15,
+	0x00, 0x12, 0x50, 0x01, 0x80, 0x0C, 0xF0, 0x0A, 0xD0, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x0F, 0x00, 0x06,
+	0x0A, 0x0F, 0x02, 0x64,
+	0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xFF, 0x0F, 0xFF, 0x0F,
+	0x14, 0x14, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x02, 0x64, 0x90, 0x01, 0x90, 0x01, 0x80, 0x00, 0x80, 0x00, 0xF4, 0x01,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x00, 0x64, 0x00,
+	0x80, 0x01, 0x64, 0x00,
+	0x80, 0x01, 0x96, 0x00, 0x64, 0x00, 0x20, 0x00, 0x02, 0x00, 0x96, 0x00,
+	0x64, 0x00, 0x64, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x05, 0x01, 0xF4, 0x01,
+	0x2C, 0x01, 0x02, 0xFF,
+	0x7F, 0xFF, 0x7F, 0x02, 0x32, 0x64, 0x00, 0x00, 0x02, 0x02, 0xA2, 0x30,
+	0x29, 0x64, 0x00, 0x64,
+	0x00, 0xC8, 0x00, 0x58, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x64, 0x00,
+	0x32, 0x00, 0x01, 0x00,
+	0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x05, 0x00, 0x04, 0x00,
+	0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x02, 0x10, 0x00,
+	0x20, 0x00, 0x18, 0x00,
+	0x00, 0x01, 0x62, 0x84, 0x40, 0x01, 0x20, 0x00, 0x10, 0x00, 0x64, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x20, 0x00,
+	0x40, 0x2C, 0x7D, 0x00,
+	0x2C, 0x01, 0x64, 0x00, 0x00, 0x0A, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x01, 0x64, 0x00,
+	0x2C, 0x01, 0x00, 0x20,
+	0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x5A, 0x00,
+	0x14, 0x00, 0x01, 0x03,
+	0x01, 0x0A, 0x00, 0x10, 0x11, 0x11, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x50, 0x00,
+	0x70, 0x00, 0x32, 0x00,
+	0x40, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x03, 0x00, 0x01,
+	0x00, 0x02, 0x00, 0x02,
+	0x00, 0x02, 0x64, 0x00, 0x0A, 0x64, 0x00, 0x64, 0x00, 0x0E, 0x00, 0x05,
+	0x00, 0x10, 0xC2, 0x00,
+	0x32, 0x00, 0x20, 0x31, 0x0F, 0x02, 0x20, 0x1F, 0x00, 0x0A, 0x00, 0x14,
+	0x92, 0x11, 0x15, 0x00,
+	0x13, 0x00, 0x02, 0x10, 0x0A, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x10,
+	0xE8, 0x10, 0x00, 0x40,
+	0x00, 0x62, 0x94, 0x94, 0x28, 0xF4, 0x0A, 0x00, 0x18, 0x00, 0x10, 0x00,
+	0x30, 0x00, 0x05, 0x14,
+	0x05, 0x20, 0x03, 0x10, 0xD8, 0x05, 0x32, 0xF8, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0xC8, 0x00,
+	0xC8, 0x00, 0x0A, 0x0A,
+	0x20, 0x00, 0x64, 0x00, 0x01, 0x03, 0x64, 0x00, 0x64, 0x00, 0x01, 0x03,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x40, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x08, 0x32, 0x1A, 0xFA, 0x00, 0x0A, 0x05, 0x20, 0x0A, 0x05, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x0A, 0x00, 0x14, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x03, 0x50, 0x00,
+	0x2C, 0x01, 0x32, 0xFF,
+	0x7F, 0x0B, 0x01, 0x32, 0x00, 0x20, 0x03, 0x00, 0x0A, 0x20, 0x14, 0x05,
+	0xF8, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
+	0x03, 0x04, 0x00, 0x01,
+	0x02, 0x03, 0x50, 0x01, 0x50, 0x01, 0x50, 0x01, 0x50, 0x01, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x96, 0x7D, 0x6E, 0x67,
+	0x65, 0x64, 0x64, 0x64,
+	0x64, 0x64, 0x64, 0x64, 0x64, 0x65, 0x67, 0x6E, 0x7D, 0x96, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x0F, 0x13, 0x22, 0x22, 0x22, 0x00, 0x00, 0x0F, 0x00, 0x28, 0x00, 0x3C,
+	0x00, 0x50, 0x00, 0xA0,
+	0x00, 0x40, 0x01, 0xE0, 0x01, 0xD0, 0x02, 0xBF, 0x03, 0x5F, 0x04, 0xFF,
+	0x04, 0x4F, 0x05, 0x63,
+	0x05, 0x77, 0x05, 0x90, 0x05, 0x0F, 0x00, 0x28, 0x00, 0x3C, 0x00, 0x50,
+	0x00, 0xA0, 0x00, 0x40,
+	0x01, 0xE0, 0x01, 0xD0, 0x02, 0xC0, 0x03, 0x00, 0x05, 0x3F, 0x06, 0x2F,
+	0x07, 0x1F, 0x08, 0xBF,
+	0x08, 0x5F, 0x09, 0xAF, 0x09, 0xC3, 0x09, 0xD7, 0x09, 0xF5, 0x09, 0x00,
+	0x00, 0x0A, 0x00, 0x19,
+	0x00, 0x28, 0x00, 0x6C, 0x00, 0x27, 0x01, 0xD1, 0x01, 0xD0, 0x02, 0xC6,
+	0x03, 0x72, 0x04, 0x21,
+	0x05, 0x69, 0x05, 0x86, 0x05, 0x95, 0x05, 0x9F, 0x05, 0x00, 0x00, 0x0F,
+	0x00, 0x1C, 0x00, 0x28,
+	0x00, 0x78, 0x00, 0x1C, 0x01, 0xC6, 0x01, 0xBE, 0x02, 0xAE, 0x03, 0x00,
+	0x05, 0x4F, 0x06, 0x44,
+	0x07, 0x39, 0x08, 0xDE, 0x08, 0x8A, 0x09, 0xD8, 0x09, 0xE3, 0x09, 0xF1,
+	0x09, 0xFF, 0x09, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x64, 0x00,
+	0x00, 0x00, 0x64, 0x80,
+	0x10, 0xE5, 0x00, 0x00, 0x64, 0x80, 0x40, 0x00, 0x80, 0x00, 0xC0, 0x00,
+	0x00, 0x01, 0x40, 0x01,
+	0x80, 0x01, 0xC0, 0x01, 0x00, 0x02, 0x40, 0x02, 0x80, 0x02, 0xC0, 0x02,
+	0x00, 0x03, 0x40, 0x03,
+	0x80, 0x03, 0xC0, 0x03, 0x00, 0x04, 0x3F, 0x04, 0x7F, 0x04, 0xBF, 0x04,
+	0xFF, 0x04, 0x3F, 0x05,
+	0x7F, 0x05, 0xBF, 0x05, 0xFF, 0x05, 0x3F, 0x06, 0x7F, 0x06, 0xBF, 0x06,
+	0xFF, 0x06, 0x3F, 0x07,
+	0x7F, 0x07, 0xBF, 0x07, 0xFF, 0x07, 0xFF, 0x07, 0xBF, 0x07, 0x7F, 0x07,
+	0x3F, 0x07, 0xFF, 0x06,
+	0xBF, 0x06, 0x7F, 0x06, 0x3F, 0x06, 0xFF, 0x05, 0xBF, 0x05, 0x7F, 0x05,
+	0x3F, 0x05, 0xFF, 0x04,
+	0xBF, 0x04, 0x7F, 0x04, 0x3F, 0x04, 0x00, 0x04, 0xC0, 0x03, 0x80, 0x03,
+	0x40, 0x03, 0x00, 0x03,
+	0xC0, 0x02, 0x80, 0x02, 0x40, 0x02, 0x00, 0x02, 0xC0, 0x01, 0x80, 0x01,
+	0x40, 0x01, 0x00, 0x01,
+	0xC0, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x40, 0x00, 0x60, 0x00,
+	0x80, 0x00, 0xA0, 0x00,
+	0xC0, 0x00, 0xE0, 0x00, 0x00, 0x01, 0x00, 0x01, 0xE0, 0x00, 0xC0, 0x00,
+	0xA0, 0x00, 0x80, 0x00,
+	0x60, 0x00, 0x40, 0x00, 0x20, 0x00, 0x14, 0x05, 0x14, 0x05, 0x14, 0x05,
+	0x14, 0x05, 0x14, 0x05,
+	0x14, 0x05, 0x14, 0x05, 0x14, 0x05, 0x14, 0x05, 0x14, 0x05, 0x14, 0x05,
+	0x14, 0x05, 0x14, 0x05,
+	0x14, 0x05, 0x14, 0x05, 0x14, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
+	0x00, 0x03, 0x00, 0x03,
+	0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
+	0x00, 0x03, 0x00, 0x03,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x04, 0x20,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCD, 0x00, 0xCD, 0x00, 0xCD, 0x00,
+	0xCD, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x05, 0x07,
+	0x08, 0x0C, 0x0D, 0x0F,
+	0x0F, 0x0F, 0x0E, 0x0E, 0x0E, 0x0D, 0x0D, 0x0D, 0x0A, 0x08, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA9, 0x64,
+	0x9A, 0x1F, 0x18, 0x18,
+	0x01, 0x01, 0x30, 0x00, 0x60, 0x00, 0x60, 0x00, 0x2F, 0x00, 0x21, 0x01,
+	0x00, 0x00, 0x1F, 0x20,
+	0x01, 0x00, 0x00, 0x1F, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
+	0x98, 0x24, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x46, 0x50, 0x10,
+	0x10, 0xB0, 0x20, 0xFF,
+	0xD0, 0x00, 0x06, 0x14, 0x14, 0x2A, 0x3A, 0x40, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x14, 0x6E, 0x6E, 0x47, 0x1A, 0x38, 0x00, 0x00, 0x00, 0x01, 0x0F,
+	0x1E, 0x00, 0x20, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA9, 0x24,
+	0x94, 0x1F, 0x18, 0x18,
+	0x01, 0x00, 0x25, 0x00, 0x25, 0x00, 0x50, 0x00, 0x24, 0x00, 0x70, 0x01,
+	0x00, 0x00, 0x1F, 0x80,
+	0x01, 0x00, 0x00, 0x1F, 0x00, 0x01, 0x10, 0x00, 0x55, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x75, 0x6A, 0xB0,
+};
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/fts_lib/Makefile b/drivers/input/touchscreen/stfts/fts_lib/Makefile
new file mode 100644
index 000000000000..f99659c94c2c
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the FTS touchscreen driver.
+#
+
+
+obj-$(CONFIG_TOUCHSCREEN_ST_FTS) += ftsCompensation.o ftsCore.o ftsError.o ftsFrame.o ftsIO.o ftsTest.o ftsTime.o ftsTool.o ftsFlash.o ftsGesture.o
+
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsCompensation.c b/drivers/input/touchscreen/stfts/fts_lib/ftsCompensation.c
new file mode 100644
index 000000000000..12a15edb1c93
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsCompensation.c
@@ -0,0 +1,790 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*               FTS functions for getting Initialization Data			 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+/*!
+* \file ftsCompensation.c
+* \brief Contains all the function to work with Initialization Data
+*/
+
+#include "ftsCompensation.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsFrame.h"
+#include "ftsHardware.h"
+#include "ftsIO.h"
+#include "ftsSoftware.h"
+#include "ftsTime.h"
+#include "ftsTool.h"
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/serio.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+
+/**
+* Request to the FW to load the specified Initialization Data
+* @param type type of Initialization data to load @link load_opt Load Host Data Option @endlink
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int requestCompensationData(u8 type)
+{
+	int ret = ERROR_OP_NOT_ALLOW;
+	int retry = 0;
+
+	logError(0, "%s %s: Requesting compensation data... \n", tag, __func__,
+		 retry + 1);
+	while (retry < RETRY_COMP_DATA_READ) {
+		ret = writeSysCmd(SYS_CMD_LOAD_DATA, &type, 1);
+		if (ret < OK) {
+			logError(1, "%s %s: failed at %d attemp! \n", tag,
+				 __func__, retry + 1);
+			retry += 1;
+		} else {
+			logError(0,
+				 "%s %s: Request Compensation data FINISHED! \n",
+				 tag, __func__);
+			return OK;
+		}
+	}
+
+	logError(1, "%s %s: Requesting compensation data... ERROR %08X \n", tag,
+		 __func__, ret | ERROR_REQU_COMP_DATA);
+	return ret | ERROR_REQU_COMP_DATA;
+
+}
+
+/**
+* Read Initialization Data Header and check that the type loaded match with the one previously requested
+* @param type type of Initialization data requested @link load_opt Load Host Data Option @endlink
+* @param header pointer to DataHeader variable which will contain the header
+* @param address pointer to a variable which will contain the updated address to the next data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int readCompensationDataHeader(u8 type, DataHeader *header, u64 *address)
+{
+
+	u64 offset = ADDR_FRAMEBUFFER;
+	u8 data[COMP_DATA_HEADER];
+	int ret;
+
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, offset, data,
+			      COMP_DATA_HEADER, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		logError(1,
+			 "%s %s: error while reading data header ERROR %08X \n",
+			 tag, __func__, ret);
+		return ret;
+	}
+
+	logError(0, "%s Read Data Header done! \n", tag);
+
+	if (data[0] != HEADER_SIGNATURE) {
+		logError(1,
+			 "%s %s: The Header Signature was wrong! %02X != %02X ERROR %08X \n",
+			 tag, __func__, data[0], HEADER_SIGNATURE,
+			 ERROR_WRONG_DATA_SIGN);
+		return ERROR_WRONG_DATA_SIGN;
+	}
+
+	if (data[1] != type) {
+		logError(1, "%s %s: Wrong type found! %02X!=%02X ERROR %08X\n",
+			 tag, __func__, data[1], type, ERROR_DIFF_DATA_TYPE);
+		return ERROR_DIFF_DATA_TYPE;
+	}
+
+	logError(0, "%s Type = %02X of Compensation data OK! \n", tag, type);
+
+	header->type = type;
+
+	*address = offset + COMP_DATA_HEADER;
+
+	return OK;
+
+}
+
+/**
+* Read MS Global Initialization data from the buffer such as Cx1
+* @param address pointer to a variable which contain the address from where to read the data and will contain the updated address to the next data
+* @param global pointer to MutualSenseData variable which will contain the MS initialization data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int readMutualSenseGlobalData(u64 *address, MutualSenseData *global)
+{
+
+	u8 data[COMP_DATA_GLOBAL];
+	int ret;
+
+	logError(0, "%s Address for Global data= %04X \n", tag, *address);
+
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, *address, data,
+			      COMP_DATA_GLOBAL, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		logError(1, "%s %s: error while reading info data ERROR %08X\n",
+			 tag, __func__, ret);
+		return ret;
+	}
+	logError(0, "%s Global data Read !\n", tag);
+
+	global->header.force_node = data[0];
+	global->header.sense_node = data[1];
+	global->cx1 = data[2];
+
+	logError(0, "%s force_len = %d sense_len = %d CX1 = %d \n", tag,
+		 global->header.force_node, global->header.sense_node,
+		 global->cx1);
+
+	*address += COMP_DATA_GLOBAL;
+	return OK;
+
+}
+
+/**
+* Read MS Initialization data for each node from the buffer
+* @param address a variable which contain the address from where to read the data
+* @param node pointer to MutualSenseData variable which will contain the MS initialization data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int readMutualSenseNodeData(u64 address, MutualSenseData *node)
+{
+
+	int ret;
+	int size = node->header.force_node * node->header.sense_node;
+
+	logError(0, "%s Address for Node data = %04X \n", tag, address);
+
+	node->node_data = (i8 *) kmalloc(size * (sizeof(i8)), GFP_KERNEL);
+
+	if (node->node_data == NULL) {
+		logError(1, "%s %s: can not allocate node_data... ERROR %08X",
+			 tag, __func__, ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	logError(0, "%s Node Data to read %d bytes \n", tag, size);
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, address,
+			      node->node_data, size, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		logError(1,
+			 "%s %s: error while reading node data ERROR %08X \n",
+			 tag, __func__, ret);
+		kfree(node->node_data);
+		node->node_data = NULL;
+		return ret;
+	}
+	node->node_data_size = size;
+
+	logError(0, "%s Read node data OK! \n", tag);
+
+	return size;
+
+}
+
+/**
+* Perform all the steps to read the necessary info for MS Initialization data from the buffer and store it in a MutualSenseData variable
+* @param type type of MS Initialization data to read @link load_opt Load Host Data Option @endlink
+* @param data pointer to MutualSenseData variable which will contain the MS initialization data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int readMutualSenseCompensationData(u8 type, MutualSenseData *data)
+{
+
+	int ret;
+	u64 address;
+	data->node_data = NULL;
+
+	if (!
+	    (type == LOAD_CX_MS_TOUCH || type == LOAD_CX_MS_LOW_POWER
+	     || type == LOAD_CX_MS_KEY || type == LOAD_CX_MS_FORCE)) {
+		logError(1,
+			 "%s %s: Choose a MS type of compensation data ERROR %08X\n",
+			 tag, __func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	ret = requestCompensationData(type);
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__,
+			 ERROR_REQU_COMP_DATA);
+		return (ret | ERROR_REQU_COMP_DATA);
+	}
+
+	ret = readCompensationDataHeader(type, &(data->header), &address);
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__,
+			 ERROR_COMP_DATA_HEADER);
+		return (ret | ERROR_COMP_DATA_HEADER);
+	}
+
+	ret = readMutualSenseGlobalData(&address, data);
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X \n", tag, __func__,
+			 ERROR_COMP_DATA_GLOBAL);
+		return (ret | ERROR_COMP_DATA_GLOBAL);
+	}
+
+	ret = readMutualSenseNodeData(address, data);
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__,
+			 ERROR_COMP_DATA_NODE);
+		return (ret | ERROR_COMP_DATA_NODE);
+	}
+
+	return OK;
+
+}
+
+/**
+* Read SS Global Initialization data from the buffer such as Ix1/Cx1 for force and sense
+* @param address pointer to a variable which contain the address from where to read the data and will contain the updated address to the next data
+* @param global pointer to MutualSenseData variable which will contain the SS initialization data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int readSelfSenseGlobalData(u64 *address, SelfSenseData *global)
+{
+	int ret;
+	u8 data[COMP_DATA_GLOBAL];
+
+	logError(0, "%s Address for Global data= %04X \n", tag, *address);
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, *address, data,
+			      COMP_DATA_GLOBAL, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		logError(1,
+			 "%s %s: error while reading the data... ERROR %08X \n",
+			 tag, __func__, ret);
+		return ret;
+	}
+
+	logError(0, "%s Global data Read !\n", tag);
+
+	global->header.force_node = data[0];
+	global->header.sense_node = data[1];
+	global->f_ix1 = data[2];
+	global->s_ix1 = data[3];
+	global->f_cx1 = (i8) data[4];
+	global->s_cx1 = (i8) data[5];
+	global->f_max_n = data[6];
+	global->s_max_n = data[7];
+
+	logError(0,
+		 "%s force_len = %d sense_len = %d  f_ix1 = %d   s_ix1 = %d   f_cx1 = %d   s_cx1 = %d \n",
+		 tag, global->header.force_node, global->header.sense_node,
+		 global->f_ix1, global->s_ix1, global->f_cx1, global->s_cx1);
+	logError(0, "%s max_n = %d   s_max_n = %d \n", tag, global->f_max_n,
+		 global->s_max_n);
+
+	*address += COMP_DATA_GLOBAL;
+
+	return OK;
+
+}
+
+/**
+* Read SS Initialization data for each node of force and sense channels from the buffer
+* @param address a variable which contain the address from where to read the data
+* @param node pointer to SelfSenseData variable which will contain the SS initialization data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int readSelfSenseNodeData(u64 address, SelfSenseData *node)
+{
+
+	int size = node->header.force_node * 2 + node->header.sense_node * 2;
+	u8 data[size];
+	int ret;
+
+	node->ix2_fm =
+	    (u8 *) kmalloc(node->header.force_node * (sizeof(u8)), GFP_KERNEL);
+	if (node->ix2_fm == NULL) {
+		logError(1,
+			 "%s %s: can not allocate memory for ix2_fm... ERROR %08X",
+			 tag, __func__, ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	node->cx2_fm =
+	    (i8 *) kmalloc(node->header.force_node * (sizeof(i8)), GFP_KERNEL);
+	if (node->cx2_fm == NULL) {
+		logError(1,
+			 "%s %s: can not allocate memory for cx2_fm ... ERROR %08X",
+			 tag, __func__, ERROR_ALLOC);
+		kfree(node->ix2_fm);
+		return ERROR_ALLOC;
+	}
+	node->ix2_sn =
+	    (u8 *) kmalloc(node->header.sense_node * (sizeof(u8)), GFP_KERNEL);
+	if (node->ix2_sn == NULL) {
+		logError(1,
+			 "%s %s: can not allocate memory for ix2_sn ERROR %08X",
+			 tag, __func__, ERROR_ALLOC);
+		kfree(node->ix2_fm);
+		kfree(node->cx2_fm);
+		return ERROR_ALLOC;
+	}
+	node->cx2_sn =
+	    (i8 *) kmalloc(node->header.sense_node * (sizeof(i8)), GFP_KERNEL);
+	if (node->cx2_sn == NULL) {
+		logError(1,
+			 "%s %s: can not allocate memory for cx2_sn ERROR %08X",
+			 tag, __func__, ERROR_ALLOC);
+		kfree(node->ix2_fm);
+		kfree(node->cx2_fm);
+		kfree(node->ix2_sn);
+		return ERROR_ALLOC;
+	}
+
+	logError(0, "%s Address for Node data = %02X \n", tag, address);
+
+	logError(0, "%s Node Data to read %d bytes \n", tag, size);
+
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, address, data,
+			      size, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		logError(1, "%s %s: error while reading data... ERROR %08X\n",
+			 tag, ret);
+		kfree(node->ix2_fm);
+		kfree(node->cx2_fm);
+		kfree(node->ix2_sn);
+		kfree(node->cx2_sn);
+		return ret;
+	}
+
+	logError(0, "%s Read node data ok! \n", tag);
+
+	memcpy(node->ix2_fm, data, node->header.force_node);
+	memcpy(node->ix2_sn, &data[node->header.force_node],
+	       node->header.sense_node);
+	memcpy(node->cx2_fm,
+	       &data[node->header.force_node + node->header.sense_node],
+	       node->header.force_node);
+	memcpy(node->cx2_sn,
+	       &data[node->header.force_node * 2 + node->header.sense_node],
+	       node->header.sense_node);
+
+	return OK;
+
+}
+
+/**
+* Perform all the steps to read the necessary info for SS Initialization data from the buffer and store it in a SelfSenseData variable
+* @param type type of SS Initialization data to read @link load_opt Load Host Data Option @endlink
+* @param data pointer to SelfSenseData variable which will contain the SS initialization data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int readSelfSenseCompensationData(u8 type, SelfSenseData *data)
+{
+
+	int ret;
+	u64 address;
+
+	data->ix2_fm = NULL;
+	data->cx2_fm = NULL;
+	data->ix2_sn = NULL;
+	data->cx2_sn = NULL;
+
+	if (!
+	    (type == LOAD_CX_SS_TOUCH || type == LOAD_CX_SS_TOUCH_IDLE
+	     || type == LOAD_CX_SS_KEY || type == LOAD_CX_SS_FORCE)) {
+		logError(1,
+			 "%s %s: Choose a SS type of compensation data ERROR %08X\n",
+			 tag, __func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	ret = requestCompensationData(type);
+	if (ret < 0) {
+		logError(1,
+			 "%s %s: error while requesting data... ERROR %08X\n",
+			 tag, __func__, ERROR_REQU_COMP_DATA);
+		return (ret | ERROR_REQU_COMP_DATA);
+	}
+
+	ret = readCompensationDataHeader(type, &(data->header), &address);
+	if (ret < 0) {
+		logError(1,
+			 "%s %s: error while reading data header... ERROR %08X\n",
+			 tag, __func__, ERROR_COMP_DATA_HEADER);
+		return (ret | ERROR_COMP_DATA_HEADER);
+	}
+
+	ret = readSelfSenseGlobalData(&address, data);
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__,
+			 ERROR_COMP_DATA_GLOBAL);
+		return (ret | ERROR_COMP_DATA_GLOBAL);
+	}
+
+	ret = readSelfSenseNodeData(address, data);
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__,
+			 ERROR_COMP_DATA_NODE);
+		return (ret | ERROR_COMP_DATA_NODE);
+	}
+
+	return OK;
+
+}
+
+/**
+* Read TOT MS Global Initialization data from the buffer such as number of force and sense channels
+* @param address pointer to a variable which contain the address from where to read the data and will contain the updated address to the next data
+* @param global pointer to a variable which will contain the TOT MS initialization data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+static int readTotMutualSenseGlobalData(u64 *address, TotMutualSenseData *global)
+{
+	int ret;
+	u8 data[COMP_DATA_GLOBAL];
+
+	logError(0, "%s Address for Global data= %04X \n", tag, *address);
+
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, *address, data,
+			      COMP_DATA_GLOBAL, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		logError(1, "%s %s: error while reading info data ERROR %08X\n",
+			 tag, __func__, ret);
+		return ret;
+	}
+	logError(0, "%s Global data Read !\n", tag);
+
+	global->header.force_node = data[0];
+	global->header.sense_node = data[1];
+
+	logError(0, "%s force_len = %d sense_len = %d \n", tag,
+		 global->header.force_node, global->header.sense_node);
+
+	*address += COMP_DATA_GLOBAL;
+	return OK;
+
+}
+
+/**
+* Read TOT MS Initialization data for each node from the buffer
+* @param address a variable which contain the address from where to read the data
+* @param node pointer to MutualSenseData variable which will contain the TOT MS initialization data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+static int readTotMutualSenseNodeData(u64 address, TotMutualSenseData *node)
+{
+	int ret, i;
+	int size = node->header.force_node * node->header.sense_node;
+	int toRead = size * sizeof(u16);
+	u8 data[toRead];
+
+	logError(0, "%s Address for Node data = %04X \n", tag, address);
+
+	node->node_data = (short *)kmalloc(size * (sizeof(short)), GFP_KERNEL);
+
+	if (node->node_data == NULL) {
+		logError(1, "%s %s: can not allocate node_data... ERROR %08X",
+			 tag, __func__, ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	logError(0, "%s Node Data to read %d bytes \n", tag, size);
+
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, address, data,
+			      toRead, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		logError(1,
+			 "%s %s: error while reading node data ERROR %08X \n",
+			 tag, __func__, ret);
+		kfree(node->node_data);
+		node->node_data = NULL;
+		return ret;
+	}
+	node->node_data_size = size;
+
+	for (i = 0; i < size; i++) {
+		node->node_data[i] =
+		    ((short)data[i * 2 + 1]) << 8 | data[i * 2];
+	}
+
+	logError(0, "%s Read node data OK! \n", tag);
+
+	return size;
+
+}
+
+/**
+* Perform all the steps to read the necessary info for TOT MS Initialization data from the buffer and store it in a TotMutualSenseData variable
+* @param type type of TOT MS Initialization data to read @link load_opt Load Host Data Option @endlink
+* @param data pointer to a variable which will contain the TOT MS initialization data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int readTotMutualSenseCompensationData(u8 type, TotMutualSenseData *data)
+{
+	int ret;
+	u64 address;
+	data->node_data = NULL;
+
+	if (!
+	    (type == LOAD_PANEL_CX_TOT_MS_TOUCH
+	     || type == LOAD_PANEL_CX_TOT_MS_LOW_POWER
+	     || type == LOAD_PANEL_CX_TOT_MS_KEY
+	     || type == LOAD_PANEL_CX_TOT_MS_FORCE)) {
+		logError(1,
+			 "%s %s: Choose a TOT MS type of compensation data ERROR %08X\n",
+			 tag, __func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	ret = requestCompensationData(type);
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__,
+			 ERROR_REQU_COMP_DATA);
+		return (ret | ERROR_REQU_COMP_DATA);
+	}
+
+	ret = readCompensationDataHeader(type, &(data->header), &address);
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__,
+			 ERROR_COMP_DATA_HEADER);
+		return (ret | ERROR_COMP_DATA_HEADER);
+	}
+
+	ret = readTotMutualSenseGlobalData(&address, data);
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X \n", tag, __func__,
+			 ERROR_COMP_DATA_GLOBAL);
+		return (ret | ERROR_COMP_DATA_GLOBAL);
+	}
+
+	ret = readTotMutualSenseNodeData(address, data);
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__,
+			 ERROR_COMP_DATA_NODE);
+		return (ret | ERROR_COMP_DATA_NODE);
+	}
+
+	return OK;
+
+}
+
+/**
+* Read TOT SS Global Initialization data from the buffer such as number of force and sense channels
+* @param address pointer to a variable which contain the address from where to read the data and will contain the updated address to the next data
+* @param global pointer to a variable which will contain the TOT SS initialization data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int readTotSelfSenseGlobalData(u64 *address, TotSelfSenseData *global)
+{
+	int ret;
+	u8 data[COMP_DATA_GLOBAL];
+
+	logError(0, "%s Address for Global data= %04X \n", tag, *address);
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, *address, data,
+			      COMP_DATA_GLOBAL, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		logError(1,
+			 "%s %s: error while reading the data... ERROR %08X \n",
+			 tag, __func__, ret);
+		return ret;
+	}
+
+	logError(0, "%s Global data Read !\n", tag);
+
+	global->header.force_node = data[0];
+	global->header.sense_node = data[1];
+
+	logError(0, "%s force_len = %d sense_len = %d  \n", tag,
+		 global->header.force_node, global->header.sense_node);
+
+	*address += COMP_DATA_GLOBAL;
+
+	return OK;
+
+}
+
+/**
+* Read TOT SS Global Initialization data from the buffer such as number of force and sense channels
+* @param address pointer to a variable which contain the address from where to read the data and will contain the updated address to the next data
+* @param node pointer to a variable which will contain the TOT SS initialization data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int readTotSelfSenseNodeData(u64 address, TotSelfSenseData *node)
+{
+
+	int size = node->header.force_node * 2 + node->header.sense_node * 2;
+	int toRead = size * 2;
+	u8 data[toRead];
+	int ret, i, j = 0;
+
+	node->ix_fm =
+	    (u16 *) kmalloc(node->header.force_node * (sizeof(u16)),
+			    GFP_KERNEL);
+	if (node->ix_fm == NULL) {
+		logError(1,
+			 "%s %s: can not allocate memory for ix2_fm... ERROR %08X",
+			 tag, __func__, ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	node->cx_fm =
+	    (short *)kmalloc(node->header.force_node * (sizeof(short)),
+			     GFP_KERNEL);
+	if (node->cx_fm == NULL) {
+		logError(1,
+			 "%s %s: can not allocate memory for cx2_fm ... ERROR %08X",
+			 tag, __func__, ERROR_ALLOC);
+		kfree(node->ix_fm);
+		return ERROR_ALLOC;
+	}
+	node->ix_sn =
+	    (u16 *) kmalloc(node->header.sense_node * (sizeof(u16)),
+			    GFP_KERNEL);
+	if (node->ix_sn == NULL) {
+		logError(1,
+			 "%s %s: can not allocate memory for ix2_sn ERROR %08X",
+			 tag, __func__, ERROR_ALLOC);
+		kfree(node->ix_fm);
+		kfree(node->cx_fm);
+		return ERROR_ALLOC;
+	}
+	node->cx_sn =
+	    (short *)kmalloc(node->header.sense_node * (sizeof(short)),
+			     GFP_KERNEL);
+	if (node->cx_sn == NULL) {
+		logError(1,
+			 "%s %s: can not allocate memory for cx2_sn ERROR %08X",
+			 tag, __func__, ERROR_ALLOC);
+		kfree(node->ix_fm);
+		kfree(node->cx_fm);
+		kfree(node->ix_sn);
+		return ERROR_ALLOC;
+	}
+
+	logError(0, "%s Address for Node data = %02X \n", tag, address);
+
+	logError(0, "%s Node Data to read %d bytes \n", tag, size);
+
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, address, data,
+			      toRead, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		logError(1, "%s %s: error while reading data... ERROR %08X\n",
+			 tag, ret);
+		kfree(node->ix_fm);
+		kfree(node->cx_fm);
+		kfree(node->ix_sn);
+		kfree(node->cx_sn);
+		return ret;
+	}
+
+	logError(0, "%s Read node data ok! \n", tag);
+
+	j = 0;
+	for (i = 0; i < node->header.force_node; i++) {
+		node->ix_fm[i] = ((u16) data[j + 1]) << 8 | data[j];
+		j += 2;
+	}
+
+	for (i = 0; i < node->header.sense_node; i++) {
+		node->ix_sn[i] = ((u16) data[j + 1]) << 8 | data[j];
+		j += 2;
+	}
+
+	for (i = 0; i < node->header.force_node; i++) {
+		node->cx_fm[i] = ((short)data[j + 1]) << 8 | data[j];
+		j += 2;
+	}
+
+	for (i = 0; i < node->header.sense_node; i++) {
+		node->cx_sn[i] = ((short)data[j + 1]) << 8 | data[j];
+		j += 2;
+	}
+
+	if (j != toRead) {
+		logError(1, "%s %s: parsed a wrong number of bytes %d!=%d \n",
+			 tag, __func__, j, toRead);
+	}
+
+	return OK;
+
+}
+
+/**
+* Perform all the steps to read the necessary info for TOT SS Initialization data from the buffer and store it in a TotSelfSenseData variable
+* @param type type of TOT MS Initialization data to read @link load_opt Load Host Data Option @endlink
+* @param data pointer to a variable which will contain the TOT MS initialization data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int readTotSelfSenseCompensationData(u8 type, TotSelfSenseData *data)
+{
+
+	int ret;
+	u64 address;
+
+	data->ix_fm = NULL;
+	data->cx_fm = NULL;
+	data->ix_sn = NULL;
+	data->cx_sn = NULL;
+
+	if (!
+	    (type == LOAD_PANEL_CX_TOT_SS_TOUCH
+	     || type == LOAD_PANEL_CX_TOT_SS_TOUCH_IDLE
+	     || type == LOAD_PANEL_CX_TOT_SS_KEY
+	     || type == LOAD_PANEL_CX_TOT_SS_FORCE
+	     || type == STAPI_HOST_DATA_ID_PANEL_CX_SS_HVR)) {
+		logError(1,
+			 "%s %s: Choose a TOT SS type of compensation data ERROR %08X\n",
+			 tag, __func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	ret = requestCompensationData(type);
+	if (ret < 0) {
+		logError(1,
+			 "%s %s: error while requesting data... ERROR %08X\n",
+			 tag, __func__, ERROR_REQU_COMP_DATA);
+		return (ret | ERROR_REQU_COMP_DATA);
+	}
+
+	ret = readCompensationDataHeader(type, &(data->header), &address);
+	if (ret < 0) {
+		logError(1,
+			 "%s %s: error while reading data header... ERROR %08X\n",
+			 tag, __func__, ERROR_COMP_DATA_HEADER);
+		return (ret | ERROR_COMP_DATA_HEADER);
+	}
+
+	ret = readTotSelfSenseGlobalData(&address, data);
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__,
+			 ERROR_COMP_DATA_GLOBAL);
+		return (ret | ERROR_COMP_DATA_GLOBAL);
+	}
+
+	ret = readTotSelfSenseNodeData(address, data);
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__,
+			 ERROR_COMP_DATA_NODE);
+		return (ret | ERROR_COMP_DATA_NODE);
+	}
+
+	return OK;
+
+}
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsCompensation.h b/drivers/input/touchscreen/stfts/fts_lib/ftsCompensation.h
new file mode 100644
index 000000000000..1917e7484142
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsCompensation.h
@@ -0,0 +1,110 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*               FTS functions for getting Initialization Data			 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsCompensation.h
+* \brief Contains all the definitions and structs to work with Initialization Data
+*/
+
+#ifndef FTS_COMPENSATION_H
+#define FTS_COMPENSATION_H
+
+#include "ftsCore.h"
+#include "ftsSoftware.h"
+
+#define RETRY_COMP_DATA_READ			2
+
+/*Bytes dimension of Compensation Data Format*/
+
+#define COMP_DATA_HEADER				DATA_HEADER
+#define COMP_DATA_GLOBAL				(16 - COMP_DATA_HEADER)
+
+#define HEADER_SIGNATURE				0xA5
+
+/**
+* Struct which contains the general info about Frames and Initialization Data
+*/
+typedef struct {
+	int force_node;		/*Number of Force Channels in the frame/Initialization data*/
+	int sense_node;		/*Number of Sense Channels in the frame/Initialization data*/
+	int type;				/*Type of frame/Initialization data*/
+} DataHeader;
+
+/**
+* Struct which contains the MS Initialization data
+*/
+typedef struct {
+	DataHeader header;		/*Header*/
+	i8 cx1;					/*Cx1 value (can be negative))*/
+	i8 *node_data;			/*Pointer to an array of bytes which contains the CX2 data (can be negative)*/
+	int node_data_size;	/*size of the data*/
+} MutualSenseData;
+
+/**
+* Struct which contains the SS Initialization data
+*/
+typedef struct {
+	DataHeader header;		/*Header*/
+	u8 f_ix1;				/*IX1 Force*/
+	u8 s_ix1;				/*IX1 Sense*/
+	i8 f_cx1;				/*CX1 Force (can be negative)*/
+	i8 s_cx1;				/*< CX1 Sense (can be negative)*/
+	u8 f_max_n;			/*Force MaxN*/
+	u8 s_max_n;			/*Sense MaxN*/
+
+	u8 *ix2_fm;			/*pointer to an array of bytes which contains Force Ix2 data node*/
+	u8 *ix2_sn;			/*pointer to an array of bytes which contains Sense Ix2 data node*/
+	i8 *cx2_fm;			/*pointer to an array of bytes which contains Force Cx2 data node (can be negative)*/
+	i8 *cx2_sn;			/*pointer to an array of bytes which contains Sense Cx2 data node (can be negative))*/
+
+} SelfSenseData;
+
+/**
+* Struct which contains the TOT MS Initialization data
+*/
+typedef struct {
+	DataHeader header;		/*Header*/
+	short *node_data;		/*pointer to an array of ushort which contains TOT MS Initialization data*/
+	int node_data_size;	/*size of data*/
+} TotMutualSenseData;
+
+/**
+* Struct which contains the TOT SS Initialization data
+*/
+typedef struct {
+	DataHeader header;		/*Header*/
+
+	u16 *ix_fm;			/*pointer to an array of ushort which contains TOT SS IX Force data*/
+	u16 *ix_sn;			/*pointer to an array of ushort which contains TOT SS IX Sense data*/
+	short *cx_fm;			/*pointer to an array of ushort which contains TOT SS CX Force data (can be negative)*/
+	short *cx_sn;			/*pointer to an array of ushort which contains TOT SS CX Sense data (can be negative)*/
+
+} TotSelfSenseData;
+
+int requestCompensationData(u8 type);
+int readCompensationDataHeader(u8 type, DataHeader *header, u64 *address);
+int readMutualSenseGlobalData(u64 *address, MutualSenseData *global);
+int readMutualSenseNodeData(u64 address, MutualSenseData  *node);
+int readMutualSenseCompensationData(u8 type, MutualSenseData *data);
+int readSelfSenseGlobalData(u64 *address, SelfSenseData *global);
+int readSelfSenseNodeData(u64 address, SelfSenseData *node);
+int readSelfSenseCompensationData(u8 type, SelfSenseData *data);
+int readToTMutualSenseGlobalData(u64 *address, TotMutualSenseData *global);
+int readToTMutualSenseNodeData(u64 address, TotMutualSenseData *node);
+int readTotMutualSenseCompensationData(u8 type, TotMutualSenseData *data);
+int readTotSelfSenseGlobalData(u64 *address, TotSelfSenseData *global);
+int readTotSelfSenseNodeData(u64 address, TotSelfSenseData *node);
+int readTotSelfSenseCompensationData(u8 type, TotSelfSenseData *data);
+#endif
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsCore.c b/drivers/input/touchscreen/stfts/fts_lib/ftsCore.c
new file mode 100644
index 000000000000..f1a4806f55aa
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsCore.c
@@ -0,0 +1,1365 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*							FTS Core functions							 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsCore.c
+* \brief Contains the implementation of the Core functions
+*/
+
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include "ftsCompensation.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsIO.h"
+#include "ftsTest.h"
+#include "ftsTime.h"
+#include "ftsTool.h"
+
+extern struct fts_ts_info *fts_info;
+/** @addtogroup system_info
+* @{
+*/
+SysInfo systemInfo;							/*Global System Info variable, accessible in all the driver*/
+/** @}*/
+
+static int reset_gpio = GPIO_NOT_DEFINED;	/*gpio number of the rest pin, the value is  GPIO_NOT_DEFINED if the reset pin is not connected*/
+static int system_reseted_up;			/*flag checked during resume to understand if there was a system reset and restore the proper state*/
+static int system_reseted_down;		/*flag checked during suspend to understand if there was a system reset and restore the proper state*/
+static int disable_irq_count;			/*count the number of call to disable_irq, start with 1 because at the boot IRQ are already disabled*/
+spinlock_t fts_int;						/*spinlock to controll the access to the disable_irq_counter*/
+
+/**
+* Initialize core variables of the library. Must be called during the probe before any other lib function
+* @param info pointer to fts_ts_info which contains info about the device and its hw setup
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int initCore(struct fts_ts_info *info)
+{
+	int ret = OK;
+	logError(0, "%s %s: Initialization of the Core... \n", tag, __func__);
+	ret |= openChannel(info->client);
+	ret |= resetErrorList();
+	ret |= initTestToDo();
+	setResetGpio(info->board->reset_gpio);
+	if (ret < OK) {
+		logError(0, "%s %s: Initialization Core ERROR %08X! \n", tag,
+			 __func__, ret);
+	} else {
+		logError(0, "%s %s: Initialization Finished! \n", tag,
+			 __func__);
+	}
+	return ret;
+}
+
+/**
+* Set the reset_gpio variable with the actual gpio number of the board link to the reset pin
+* @param gpio gpio number link to the reset pin of the IC
+*/
+void setResetGpio(int gpio)
+{
+	reset_gpio = gpio;
+	logError(0, "%s setResetGpio: reset_gpio = %d\n", tag, reset_gpio);
+}
+
+/**
+* Perform a system reset of the IC.
+* If the reset pin is associated to a gpio, the function execute an hw reset (toggling of reset pin) otherwise send an hw command to the IC
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int fts_system_reset(void)
+{
+	u8 readData[FIFO_EVENT_SIZE];
+	int event_to_search;
+	int res = -1;
+	int i;
+	u8 data[1] = { SYSTEM_RESET_VALUE };
+	event_to_search = (int)EVT_ID_CONTROLLER_READY;
+
+	logError(1, "%s System resetting...\n", tag);
+	if (fts_info) {
+		reinit_completion(&fts_info->tp_reset_completion);
+		atomic_set(&fts_info->system_is_resetting, 1);
+	}
+	for (i = 0; i < RETRY_SYSTEM_RESET && res < 0; i++) {
+		resetErrorList();
+		fts_disableInterruptNoSync();
+
+		if (reset_gpio == GPIO_NOT_DEFINED) {
+			res =
+			    fts_writeU8UX(FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG,
+					  ADDR_SYSTEM_RESET, data,
+					  ARRAY_SIZE(data));
+		} else {
+			gpio_set_value(reset_gpio, 0);
+			mdelay(10);
+			gpio_set_value(reset_gpio, 1);
+			res = OK;
+		}
+		if (res < OK) {
+			logError(1, "%s fts_system_reset: ERROR %08X\n", tag,
+				 ERROR_BUS_W);
+		} else {
+			res =
+			    pollForEvent(&event_to_search, 1, readData,
+					 GENERAL_TIMEOUT);
+			if (res < OK) {
+				logError(1, "%s fts_system_reset: ERROR %08X\n",
+					 tag, res);
+			}
+		}
+	}
+	if (fts_info) {
+		complete(&fts_info->tp_reset_completion);
+		atomic_set(&fts_info->system_is_resetting, 0);
+	}
+	if (res < OK) {
+		logError(1,
+			 "%s fts_system_reset...failed after 3 attempts: ERROR %08X\n",
+			 tag, (res | ERROR_SYSTEM_RESET_FAIL));
+		return (res | ERROR_SYSTEM_RESET_FAIL);
+	} else {
+		logError(1, "%s System reset DONE!\n", tag);
+		system_reseted_down = 1;
+		system_reseted_up = 1;
+		return OK;
+	}
+
+}
+
+/**
+* Return the value of system_resetted_down.
+* @return the flag value: 0 if not set, 1 if set
+*/
+int isSystemResettedDown(void)
+{
+	return system_reseted_down;
+}
+
+/**
+* Return the value of system_resetted_up.
+* @return the flag value: 0 if not set, 1 if set
+*/
+int isSystemResettedUp(void)
+{
+	return system_reseted_up;
+}
+
+/**
+* Set the value of system_reseted_down flag
+* @param val value to write in the flag
+*/
+void setSystemResetedDown(int val)
+{
+	system_reseted_down = val;
+}
+
+/**
+* Set the value of system_reseted_up flag
+* @param val value to write in the flag
+*/
+void setSystemResetedUp(int val)
+{
+	system_reseted_up = val;
+}
+
+/** @addtogroup events_group
+ * @{
+ */
+
+/**
+* Poll the FIFO looking for a specified event within a timeout. Support a retry mechanism.
+* @param event_to_search pointer to an array of int where each element correspond to a byte of the event to find. If the element of the array has value -1, the byte of the event, in the same position of the element is ignored.
+* @param event_bytes size of event_to_search
+* @param readData pointer to an array of byte which will contain the event found
+* @param time_to_wait time to wait before going in timeout
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int pollForEvent(int *event_to_search, int event_bytes, u8 *readData,
+		 int time_to_wait)
+{
+	int i, find, retry, count_err;
+	int time_to_count;
+	int err_handling = OK;
+	StopWatch clock;
+
+	u8 cmd[1] = { FIFO_CMD_READONE };
+	char temp[128] = { 0 };
+
+	find = 0;
+	retry = 0;
+	count_err = 0;
+	time_to_count = time_to_wait / TIMEOUT_RESOLUTION;
+
+	startStopWatch(&clock);
+	while (find != 1 && retry < time_to_count
+	       && fts_writeReadU8UX(cmd[0], 0, 0, readData, FIFO_EVENT_SIZE,
+				    DUMMY_FIFO) >= OK) {
+
+		if (readData[0] == EVT_ID_ERROR) {
+
+			logError(1, "%s %s\n", tag,
+				 printHex("ERROR EVENT = ", readData,
+					  FIFO_EVENT_SIZE, temp));
+			memset(temp, 0, 128);
+			count_err++;
+			err_handling = errorHandler(readData, FIFO_EVENT_SIZE);
+			if ((err_handling & 0xF0FF0000) ==
+			    ERROR_HANDLER_STOP_PROC) {
+				logError(0,
+					 "%s pollForEvent: forced to be stopped! ERROR %08X\n",
+					 tag, err_handling);
+				return err_handling;
+			}
+		} else {
+			if (readData[0] != EVT_ID_NOEVENT) {
+				logError(0, "%s %s\n", tag,
+					 printHex("READ EVENT = ", readData,
+						  FIFO_EVENT_SIZE, temp));
+				memset(temp, 0, 128);
+
+			}
+			if (readData[0] == EVT_ID_CONTROLLER_READY
+			    && event_to_search[0] != EVT_ID_CONTROLLER_READY) {
+				logError(0,
+					 "%s pollForEvent: Unmanned Controller Ready Event! Setting reset flags...\n",
+					 tag);
+				setSystemResetedUp(1);
+				setSystemResetedDown(1);
+			}
+		}
+
+		find = 1;
+
+		for (i = 0; i < event_bytes; i++) {
+
+			if (event_to_search[i] != -1
+			    && (int)readData[i] != event_to_search[i]) {
+				find = 0;
+				break;
+			}
+		}
+
+		retry++;
+		mdelay(TIMEOUT_RESOLUTION);
+	}
+	stopStopWatch(&clock);
+	if ((retry >= time_to_count) && find != 1) {
+		logError(1, "%s pollForEvent: ERROR %02X \n", tag,
+			 ERROR_TIMEOUT);
+		return ERROR_TIMEOUT;
+	} else if (find == 1) {
+		logError(0, "%s %s\n", tag,
+			 printHex("FOUND EVENT = ", readData, FIFO_EVENT_SIZE,
+				  temp));
+		memset(temp, 0, 128);
+		logError(0,
+			 "%s Event found in %d ms (%d iterations)! Number of errors found = %d \n",
+			 tag, elapsedMillisecond(&clock), retry, count_err);
+		return count_err;
+	} else {
+		logError(1, "%s pollForEvent: ERROR %08X \n", tag, ERROR_BUS_R);
+		return ERROR_BUS_R;
+	}
+}
+
+/** @}*/
+
+/**
+* Check that the FW sent the echo even after a command was sent
+* @param cmd pointer to an array of byte which contain the command previously sent
+* @param size size of cmd
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int checkEcho(u8 *cmd, int size)
+{
+	int ret, i;
+	int event_to_search[FIFO_EVENT_SIZE];
+	u8 readData[FIFO_EVENT_SIZE];
+
+	if (size < 1) {
+		logError(1, "%s checkEcho: Error Size = %d not valid! \n", tag,
+			 size, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	} else {
+		if ((size + 3) > FIFO_EVENT_SIZE)
+			size = FIFO_EVENT_SIZE - 3;
+
+		event_to_search[0] = EVT_ID_STATUS_UPDATE;
+		event_to_search[1] = EVT_TYPE_STATUS_ECHO;
+		for (i = 2; i < size + 2; i++) {
+			event_to_search[i] = cmd[i - 2];
+		}
+		ret =
+		    pollForEvent(event_to_search, size + 2, readData,
+				 TIMEOUT_ECHO);
+		if (ret < OK) {
+			logError(1,
+				 "%s checkEcho: Echo Event not found! ERROR %08X\n",
+				 tag, ret);
+			return (ret | ERROR_CHECK_ECHO_FAIL);
+		} else if (ret > OK) {
+			logError(1,
+				 "%s checkEcho: Echo Event found but with some error events before! num_error = %d \n",
+				 tag, ret);
+			return ERROR_CHECK_ECHO_FAIL;
+		}
+
+		logError(0, "%s ECHO OK!\n", tag);
+		return ret;
+	}
+
+}
+
+/** @addtogroup scan_mode
+* @{
+*/
+/**
+* Set a scan mode in the IC
+* @param mode scan mode to set; possible values @link scan_opt Scan Mode Option @endlink
+* @param settings option for the selected scan mode (for example @link active_bitmask Active Mode Bitmask @endlink)
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int setScanMode(u8 mode, u8 settings)
+{
+	u8 cmd[3] = { FTS_CMD_SCAN_MODE, mode, settings };
+	int ret, size = 3;
+
+	logError(0, "%s %s: Setting scan mode: mode = %02X settings = %02X !\n",
+		 tag, __func__, mode, settings);
+	if (mode == SCAN_MODE_LOW_POWER)
+		size = 2;
+	ret = fts_write_dma_safe(cmd, size);
+	if (ret < OK) {
+		logError(1, "%s %s: write failed...ERROR %08X !\n", tag,
+			 __func__, ret);
+		return ret | ERROR_SET_SCAN_MODE_FAIL;
+	}
+	logError(0, "%s %s: Setting scan mode OK!\n", tag, __func__);
+	return OK;
+}
+
+/** @}*/
+
+/** @addtogroup feat_sel
+* @{
+*/
+/**
+* Set a feature and its option in the IC
+* @param feat feature to set; possible values @link feat_opt Feature Selection Option @endlink
+* @param settings pointer to an array of byte which store the options for the selected feature (for example the gesture mask to activate @link gesture_opt Gesture IDs @endlink)
+* @param size in bytes of settings
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int setFeatures(u8 feat, u8 *settings, int size)
+{
+	u8 cmd[2 + size];
+	int i = 0;
+	int ret;
+	logError(0, "%s %s: Setting feature: feat = %02X !\n", tag, __func__,
+		 feat);
+	cmd[0] = FTS_CMD_FEATURE;
+	cmd[1] = feat;
+	logError(0, "%s %s: Settings = ", tag, __func__);
+	for (i = 0; i < size; i++) {
+		cmd[2 + i] = settings[i];
+		logError(0, "%02X ", settings[i]);
+	}
+	logError(0, "\n");
+	ret = fts_write_dma_safe(cmd, 2 + size);
+	if (ret < OK) {
+		logError(1, "%s %s: write failed...ERROR %08X !\n", tag,
+			 __func__, ret);
+		return ret | ERROR_SET_FEATURE_FAIL;
+	}
+	logError(0, "%s %s: Setting feature OK!\n", tag, __func__);
+	return OK;
+}
+
+/** @}*/
+
+/** @addtogroup sys_cmd
+* @{
+*/
+/**
+* Write a system command to the IC
+* @param sys_cmd System Command to execute; possible values @link sys_opt System Command Option @endlink
+* @param sett settings option for the selected system command (@link sys_special_opt	 Special Command Option @endlink, @link ito_opt	ITO Test Option @endlink, @link load_opt Load Host Data Option @endlink)
+* @param size in bytes of settings
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int writeSysCmd(u8 sys_cmd, u8 *sett, int size)
+{
+	u8 *cmd = NULL;
+	int ret;
+
+	cmd = (u8 *)kzalloc(sizeof(u8) * size + 2, GFP_KERNEL);
+	if (!cmd) {
+		ret = ERROR_ALLOC;
+		goto end;
+	}
+
+	cmd[0] = FTS_CMD_SYSTEM;
+	cmd[1] = sys_cmd;
+
+	logError(0, "%s %s: Command = %02X %02X ", tag, __func__, cmd[0],
+		 cmd[1]);
+	for (ret = 0; ret < size; ret++) {
+		cmd[2 + ret] = sett[ret];
+		logError(0, "%02X ", cmd[2 + ret]);
+	}
+	logError(0, "\n%s %s: Writing Sys command...\n", tag, __func__);
+	if (sys_cmd != SYS_CMD_LOAD_DATA) {
+		ret = fts_writeFwCmd(cmd, 2 + size);
+	} else {
+		if (size >= 1) {
+			ret = requestSyncFrame(sett[0]);
+		} else {
+			logError(1, "%s %s: No setting argument! ERROR %08X\n",
+				 tag, __func__, ERROR_OP_NOT_ALLOW);
+			ret = ERROR_OP_NOT_ALLOW;
+			goto end;
+		}
+	}
+	if (ret < OK) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__, ret);
+	} else
+		logError(0, "%s %s: FINISHED! \n", tag, __func__);
+
+end:
+	if (cmd)
+		kfree(cmd);
+	return ret;
+}
+
+/** @}*/
+
+/** @addtogroup system_info
+* @{
+*/
+/**
+* Initialize the System Info Struct with default values according to the error found during the reading
+* @param i2cError 1 if there was an I2C error while reading the System Info data from memory, other value if another error occurred
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int defaultSysInfo(int i2cError)
+{
+	int i;
+	logError(0, "%s Setting default System Info... \n", tag);
+
+	if (i2cError == 1) {
+		systemInfo.u16_fwVer = 0xFFFF;
+		systemInfo.u16_cfgProgectId = 0xFFFF;
+		for (i = 0; i < RELEASE_INFO_SIZE; i++) {
+			systemInfo.u8_releaseInfo[i] = 0xFF;
+		}
+		systemInfo.u16_cxVer = 0xFFFF;
+	} else {
+		systemInfo.u16_fwVer = 0x0000;
+		systemInfo.u16_cfgProgectId = 0x0000;
+		for (i = 0; i < RELEASE_INFO_SIZE; i++) {
+			systemInfo.u8_releaseInfo[i] = 0x00;
+		}
+		systemInfo.u16_cxVer = 0x0000;
+	}
+
+	systemInfo.u8_scrRxLen = 0;
+	systemInfo.u8_scrTxLen = 0;
+
+	logError(0, "%s default System Info DONE! \n", tag);
+	return OK;
+
+}
+
+/**
+* Read the System Info data from memory. System Info is loaded automatically after every system reset.
+* @param request if 1, will be asked to the FW to reload the data, otherwise attempt to read it directly from memory
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int readSysInfo(int request)
+{
+	int ret, i, index = 0;
+	u8 sett = LOAD_SYS_INFO;
+	u8 data[SYS_INFO_SIZE] = { 0 };
+	char temp[256] = { 0 };
+
+	if (request == 1) {
+		logError(0, "%s %s: Requesting System Info...\n", tag,
+			 __func__);
+
+		ret = writeSysCmd(SYS_CMD_LOAD_DATA, &sett, 1);
+		if (ret < OK) {
+			logError(1,
+				 "%s %s: error while writing the sys cmd ERROR %08X\n",
+				 tag, __func__, ret);
+			goto FAIL;
+		}
+	}
+
+	logError(0, "%s %s: Reading System Info...\n", tag, __func__);
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, ADDR_FRAMEBUFFER,
+			      data, SYS_INFO_SIZE, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		logError(1,
+			 "%s %s: error while reading the system data ERROR %08X\n",
+			 tag, __func__, ret);
+		goto FAIL;
+	}
+
+	logError(0, "%s %s: Parsing System Info...\n", tag, __func__);
+
+	if (data[0] != HEADER_SIGNATURE) {
+		logError(1,
+			 "%s %s: The Header Signature is wrong!  sign: %02X != %02X ERROR %08X\n",
+			 tag, __func__, data[0], HEADER_SIGNATURE,
+			 ERROR_WRONG_DATA_SIGN);
+		ret = ERROR_WRONG_DATA_SIGN;
+		goto FAIL;
+	}
+
+	if (data[1] != LOAD_SYS_INFO) {
+		logError(1,
+			 "%s %s: The Data ID is wrong!  ids: %02X != %02X ERROR %08X \n",
+			 tag, __func__, data[3], LOAD_SYS_INFO,
+			 ERROR_DIFF_DATA_TYPE);
+		ret = ERROR_DIFF_DATA_TYPE;
+		goto FAIL;
+	}
+
+	index += 4;
+	u8ToU16(&data[index], &systemInfo.u16_apiVer_rev);
+	index += 2;
+	systemInfo.u8_apiVer_minor = data[index++];
+	systemInfo.u8_apiVer_major = data[index++];
+	u8ToU16(&data[index], &systemInfo.u16_chip0Ver);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_chip0Id);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_chip1Ver);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_chip1Id);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_fwVer);
+	index += 2;
+	logError(1, "%s FW VER = %04X \n", tag, systemInfo.u16_fwVer);
+
+	u8ToU16(&data[index], &systemInfo.u16_svnRev);
+	index += 2;
+	logError(1, "%s SVN REV = %04X \n", tag, systemInfo.u16_svnRev);
+	u8ToU16(&data[index], &systemInfo.u16_cfgVer);
+	index += 2;
+	logError(1, "%s CONFIG VER = %04X \n", tag, systemInfo.u16_cfgVer);
+	u8ToU16(&data[index], &systemInfo.u16_cfgProgectId);
+	index += 2;
+	logError(1, "%s CONFIG PROJECT ID = %04X \n", tag,
+		 systemInfo.u16_cfgProgectId);
+	u8ToU16(&data[index], &systemInfo.u16_cxVer);
+	index += 2;
+	logError(1, "%s CX VER = %04X \n", tag, systemInfo.u16_cxVer);
+	u8ToU16(&data[index], &systemInfo.u16_cxProjectId);
+	index += 2;
+	logError(1, "%s CX PROJECT ID = %04X \n", tag,
+		 systemInfo.u16_cxProjectId);
+	systemInfo.u8_cfgAfeVer = data[index++];
+	systemInfo.u8_cxAfeVer = data[index++];
+	systemInfo.u8_panelCfgAfeVer = data[index++];
+	logError(1, "%s AFE VER: CFG = %02X - CX = %02X - PANEL = %02X \n", tag,
+		 systemInfo.u8_cfgAfeVer, systemInfo.u8_cxAfeVer,
+		 systemInfo.u8_panelCfgAfeVer);
+	systemInfo.u8_protocol = data[index++];
+	logError(0, "%s Protocol = %02X \n", tag, systemInfo.u8_protocol);
+
+	for (i = 0; i < DIE_INFO_SIZE; i++) {
+		systemInfo.u8_dieInfo[i] = data[index++];
+
+	}
+	logError(0, "%s %s \n", tag,
+		 printHex("Die Info =  ", systemInfo.u8_dieInfo, DIE_INFO_SIZE,
+			  temp));
+	memset(temp, 0, 256);
+
+	for (i = 0; i < RELEASE_INFO_SIZE; i++) {
+		systemInfo.u8_releaseInfo[i] = data[index++];
+	}
+
+	logError(1, "%s %s \n", tag,
+		 printHex("Release Info =  ", systemInfo.u8_releaseInfo,
+			  RELEASE_INFO_SIZE, temp));
+	memset(temp, 0, 256);
+
+	u8ToU32(&data[index], &systemInfo.u32_fwCrc);
+	index += 4;
+	u8ToU32(&data[index], &systemInfo.u32_cfgCrc);
+
+	index += 4;
+
+	index += 8;
+
+	u8ToU16(&data[index], &systemInfo.u16_scrResX);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_scrResY);
+	index += 2;
+	logError(0, "%s Screen Resolution = %d x %d \n", tag,
+		 systemInfo.u16_scrResX, systemInfo.u16_scrResY);
+	systemInfo.u8_scrTxLen = data[index++];
+	logError(0, "%s TX Len = %d \n", tag, systemInfo.u8_scrTxLen);
+	systemInfo.u8_scrRxLen = data[index++];
+	logError(0, "%s RX Len = %d \n", tag, systemInfo.u8_scrRxLen);
+	systemInfo.u8_keyLen = data[index++];
+	logError(0, "%s Key Len = %d \n", tag, systemInfo.u8_keyLen);
+	systemInfo.u8_forceLen = data[index++];
+	logError(0, "%s Force Len = %d \n", tag, systemInfo.u8_forceLen);
+
+	index += 40;
+
+	u8ToU16(&data[index], &systemInfo.u16_dbgInfoAddr);
+	index += 2;
+
+	index += 6;
+
+	u8ToU16(&data[index], &systemInfo.u16_msTchRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_msTchFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_msTchStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_msTchBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssTchTxRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssTchTxFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssTchTxStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssTchTxBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssTchRxRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssTchRxFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssTchRxStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssTchRxBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_keyRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_keyFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_keyStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_keyBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_frcRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_frcFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_frcStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_frcBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrTxRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrTxFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrTxStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrTxBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrRxRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrRxFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrRxStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrRxBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxTxRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxTxFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxTxStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxTxBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxRxRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxRxFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxRxStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxRxBaselineAddr);
+	index += 2;
+
+	logError(0, "%s Parsed %d bytes! \n", tag, index);
+
+	if (index != SYS_INFO_SIZE) {
+		logError(1, "%s %s: index = %d different from %d ERROR %08X\n",
+			 tag, __func__, index, SYS_INFO_SIZE,
+			 ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	logError(0, "%s System Info Read DONE!\n", tag);
+	return OK;
+
+FAIL:
+	defaultSysInfo(isI2cError(ret));
+	return ret;
+
+}
+
+/** @}*/
+
+/**
+ * Read data from the Config Memory
+ * @param offset Starting address in the Config Memory of data to read
+ * @param outBuf pointer of a byte array which contain the bytes to read
+ * @param len number of bytes to read
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int readConfig(u16 offset, u8 *outBuf, int len)
+{
+	int ret;
+	u64 final_address = offset + ADDR_CONFIG_OFFSET;
+
+	logError(0, "%s %s: Starting to read config memory at %08X ...", tag,
+		 __func__, final_address);
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_CONFIG_R, BITS_16, final_address, outBuf,
+			      len, DUMMY_CONFIG);
+	if (ret < OK) {
+		logError(1,
+			 "%s %s: Impossible to read Config Memory... ERROR %08X!",
+			 tag, __func__, ret);
+		return ret;
+	}
+
+	logError(0, "%s %s: Read config memory FINISHED!", tag, __func__);
+	return OK;
+}
+
+/**
+ * Disable the interrupt so the ISR of the driver can not be called
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int fts_disableInterrupt(void)
+{
+	if (getClient() != NULL) {
+		logError(0, "%s Number of disable = %d \n", tag,
+			 disable_irq_count);
+		if (disable_irq_count == 0) {
+			logError(0, "%s Excecuting Disable... \n", tag);
+			disable_irq(getClient()->irq);
+			disable_irq_count++;
+			logError(1, "%s Interrupt Disabled!\n", tag);
+		}
+		return OK;
+	} else {
+		logError(1, "%s %s: Impossible get client irq... ERROR %08X\n",
+			 tag, __func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+}
+
+/**
+ * Disable the interrupt async so the ISR of the driver can not be called
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int fts_disableInterruptNoSync(void)
+{
+	if (getClient() != NULL) {
+		spin_lock_irq(&fts_int);
+		logError(0, "%s Number of disable = %d \n", tag,
+			 disable_irq_count);
+		if (disable_irq_count == 0) {
+			logError(0, "%s Executing Disable... \n", tag);
+			disable_irq_nosync(getClient()->irq);
+			disable_irq_count++;
+		}
+
+		spin_unlock_irq(&fts_int);
+		logError(0, "%s Interrupt No Sync Disabled!\n", tag);
+		return OK;
+	} else {
+		logError(1, "%s %s: Impossible get client irq... ERROR %08X\n",
+			 tag, __func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+}
+
+/**
+ * Reset the disable_irq count
+ * @return OK
+ */
+int fts_resetDisableIrqCount(void)
+{
+	disable_irq_count = 0;
+	return OK;
+}
+
+/**
+ * Enable the interrupt so the ISR of the driver can be called
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int fts_enableInterrupt(void)
+{
+	if (getClient() != NULL) {
+
+		logError(0, "%s Number of re-enable = %d \n", tag,
+			 disable_irq_count);
+		while (disable_irq_count > 0) {
+			logError(0, "%s Excecuting Enable... \n", tag);
+			enable_irq(getClient()->irq);
+			disable_irq_count--;
+			logError(1, "%s Interrupt Enabled!\n", tag);
+		}
+		return OK;
+	} else {
+		logError(1, "%s %s: Impossible get client irq... ERROR %08X\n",
+			 tag, __func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+}
+
+/**
+*	Check if there is a crc error in the IC which prevent the fw to run.
+*	@return  OK if no CRC error, or a number >OK according the CRC error found
+*/
+int fts_crc_check(void)
+{
+	u8 val;
+	u8 crc_status;
+	int res;
+	u8 error_to_search[6] = { EVT_TYPE_ERROR_CRC_CFG_HEAD, EVT_TYPE_ERROR_CRC_CFG,
+		EVT_TYPE_ERROR_CRC_CX, EVT_TYPE_ERROR_CRC_CX_HEAD,
+		EVT_TYPE_ERROR_CRC_CX_SUB,
+		EVT_TYPE_ERROR_CRC_CX_SUB_HEAD
+	};
+
+	res =
+	    fts_writeReadU8UX(FTS_CMD_HW_REG_R, ADDR_SIZE_HW_REG, ADDR_CRC,
+			      &val, 1, DUMMY_HW_REG);
+	if (res < OK) {
+		logError(1, "%s %s Cannot read crc status ERROR %08X\n", tag,
+			 __func__, res);
+		return res;
+	}
+
+	crc_status = val & CRC_MASK;
+	if (crc_status != OK) {
+		logError(1, "%s %s CRC ERROR = %02X \n", tag, __func__,
+			 crc_status);
+		return CRC_CODE;
+	}
+
+	logError(1, "%s %s: Verifying if Config CRC Error...\n", tag, __func__);
+	res = fts_system_reset();
+	if (res >= OK) {
+		res = pollForErrorType(error_to_search, 2);
+		if (res < OK) {
+			logError(1, "%s %s: No Config CRC Error Found! \n", tag,
+				 __func__);
+			logError(1, "%s %s: Verifying if Cx CRC Error...\n",
+				 tag, __func__);
+			res = pollForErrorType(&error_to_search[2], 4);
+			if (res < OK) {
+				logError(1, "%s %s: No Cx CRC Error Found! \n",
+					 tag, __func__);
+				return OK;
+			} else {
+				logError(1,
+					 "%s %s: Cx CRC Error found! CRC ERROR = %02X\n",
+					 tag, __func__, res);
+				return CRC_CX;
+			}
+		} else {
+			logError(1,
+				 "%s %s: Config CRC Error found! CRC ERROR = %02X\n",
+				 tag, __func__, res);
+			return CRC_CONFIG;
+		}
+	} else {
+		logError(1,
+			 "%s %s: Error while executing system reset! ERROR %08X\n",
+			 tag, __func__, res);
+		return res;
+	}
+
+	return OK;
+}
+
+/**
+ * Request a host data and use the sync method to understand when the FW load it
+ * @param type the type ID of host data to load (@link load_opt	 Load Host Data Option  @endlink)
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int requestSyncFrame(u8 type)
+{
+	u8 request[3] = { FTS_CMD_SYSTEM, SYS_CMD_LOAD_DATA, type };
+	u8 readData[DATA_HEADER] = { 0 };
+	int ret, retry = 0, retry2 = 0, time_to_count;
+	int count, new_count;
+
+	logError(0, "%s %s: Starting to get a sync frame...\n", tag, __func__);
+
+	while (retry2 < RETRY_MAX_REQU_DATA) {
+		logError(0, "%s %s: Reading count...\n", tag, __func__);
+
+		ret =
+		    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16,
+				      ADDR_FRAMEBUFFER, readData, DATA_HEADER,
+				      DUMMY_FRAMEBUFFER);
+		if (ret < OK) {
+			logError(0,
+				 "%s %s: Error while reading count! ERROR %08X \n",
+				 tag, __func__, ret | ERROR_REQU_DATA);
+			ret |= ERROR_REQU_DATA;
+			retry2++;
+			continue;
+		}
+
+		if (readData[0] != HEADER_SIGNATURE) {
+			logError(1,
+				 "%s %s: Invalid Signature while reading count! ERROR %08X \n",
+				 tag, __func__, ret | ERROR_REQU_DATA);
+			ret |= ERROR_REQU_DATA;
+			retry2++;
+			continue;
+		}
+
+		count = (readData[3] << 8) | readData[2];
+		new_count = count;
+		logError(0, "%s %s: Base count = %d\n", tag, __func__, count);
+
+		logError(0, "%s %s: Requesting frame %02X  attempt = %d \n",
+			 tag, __func__, type, retry2 + 1);
+		ret = fts_write_dma_safe(request, ARRAY_SIZE(request));
+		if (ret >= OK) {
+
+			logError(0, "%s %s: Polling for new count... \n", tag,
+				 __func__);
+			time_to_count = TIMEOUT_REQU_DATA / TIMEOUT_RESOLUTION;
+			while (count == new_count && retry < time_to_count) {
+				ret =
+				    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R,
+						      BITS_16, ADDR_FRAMEBUFFER,
+						      readData, DATA_HEADER,
+						      DUMMY_FRAMEBUFFER);
+				if (ret >= OK
+				    && readData[0] == HEADER_SIGNATURE) {
+					new_count =
+					    ((readData[3] << 8) | readData[2]);
+				} else {
+					logError(0,
+						 "%s %s: invalid Signature or can not read count... ERROR %08X \n",
+						 tag, __func__, ret);
+				}
+				retry++;
+				mdelay(TIMEOUT_RESOLUTION);
+			}
+
+			if (count == new_count) {
+				logError(1,
+					 "%s %s: New count not received! ERROR %08X \n",
+					 tag, __func__,
+					 ERROR_TIMEOUT | ERROR_REQU_DATA);
+				ret = ERROR_TIMEOUT | ERROR_REQU_DATA;
+			} else {
+				logError(0,
+					 "%s %s: New count found! count = %d! Frame ready! \n",
+					 tag, __func__, new_count);
+				return OK;
+			}
+		}
+		retry2++;
+	}
+	logError(1, "%s %s: Request Data failed! ERROR %08X \n", tag, __func__,
+		 ret);
+	return ret;
+}
+
+int calculateCRC8(u8 *u8_srcBuff, int size, u8 *crc)
+{
+	u8 u8_remainder;
+	u8 bit;
+	int i = 0;
+	u8_remainder = 0x00;
+
+	logError(0, "%s %s: Start CRC computing...\n", tag, __func__);
+	if (size != 0 && u8_srcBuff != NULL) {
+		for (i = 0; i < size; i++) {
+			u8_remainder ^= u8_srcBuff[i];
+			for (bit = 8; bit > 0; --bit) {
+				if (u8_remainder & (0x1 << 7)) {
+					u8_remainder =
+					    (u8_remainder << 1) ^ 0x9B;
+				} else {
+					u8_remainder = (u8_remainder << 1);
+				}
+			}
+		}
+		*crc = u8_remainder;
+		logError(0, "%s %s: CRC value = %02X\n", tag, __func__, *crc);
+		return OK;
+	} else {
+		logError(1,
+			 "%s %s: Arguments passed not valid! Data pointer = NULL or size = 0 (%d) ERROR %08X\n",
+			 tag, __func__, size, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+}
+
+int writeLockDownInfo(u8 *data, int size, u8 lock_id)
+{
+	int ret, i;
+	u8 crc_data = 0;
+	u8 crc_head = 0;
+	u8 cmd_lockdown_prepare[8] = { LOCKDOWN_SIGNATURE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+	u8 cmd_lockdown_crc[4] = { 0x00 };
+	u8 lockdown_save[3] = { 0xA4, 0x00, 0x04 };
+	u8 *temp = NULL;
+	u8 error_to_search[4] = { EVT_TYPE_ERROR_LOCKDOWN_FLASH, EVT_TYPE_ERROR_LOCKDOWN_CRC,
+		EVT_TYPE_ERROR_LOCKDOWN_NO_DATA,
+		EVT_TYPE_ERROR_LOCKDOWN_WRITE_FULL
+	};
+
+	logError(0, "%s %s:enter", tag, __func__);
+	if (lock_id < 0x70 || lock_id > 0x77 || size <= 0
+	    || size > LOCKDOWN_LENGTH - 20) {
+		logError(1,
+			 "%s %s the lock id type is:%02X size:%d not support\n",
+			 tag, __func__, lock_id, size);
+		return ERROR_LOCKDOWN_CODE;
+	}
+
+	temp = printHex_data("Lockdown Code = ", data, size);
+	if (temp != NULL) {
+		logError(1, "%s: %s", __func__, temp);
+		kfree(temp);
+	}
+
+	logError(0, "%s: Writing Lockdown code into the IC ...\n", __func__);
+	fts_disableInterrupt();
+	for (i = 0; i < 3; i++) {
+		cmd_lockdown_prepare[1] = lock_id;
+		ret = calculateCRC8(data, size, &crc_data);
+		if (ret < OK) {
+			logError(1,
+				 "%s %s: Unable to compute data CRC.. ERROR %08X\n",
+				 tag, __func__, ret);
+			ret = (ret | ERROR_LOCKDOWN_CODE);
+			continue;
+		}
+		logError(0, "%s %s: Get the data CRC value:%02X\n", tag,
+			 __func__, crc_data);
+		ret =
+		    fts_writeU8UX(LOCKDOWN_WRITEREAD_CMD, BITS_16,
+				  ADDR_LOCKDOWN, cmd_lockdown_prepare,
+				  ARRAY_SIZE(cmd_lockdown_prepare));
+		if (ret < OK) {
+			logError(1,
+				 "%s %s: Unable to write Lockdown data prepare at %d iteration.. ERROR %08X\n",
+				 tag, __func__, i, ret);
+			ret = (ret | ERROR_LOCKDOWN_CODE);
+			continue;
+		}
+		logError(0, "%s %s: Compute 8bit header CRC...\n", tag,
+			 __func__);
+
+		cmd_lockdown_crc[0] = (u8) size;
+		cmd_lockdown_crc[1] = crc_data;
+		cmd_lockdown_crc[2] = lock_id;
+		ret = calculateCRC8(cmd_lockdown_crc, 3, &crc_head);
+		if (ret < OK) {
+			logError(1,
+				 "%s %s: Unable to compute head CRC.. ERROR %08X\n",
+				 tag, __func__, ret);
+			ret = (ret | ERROR_LOCKDOWN_CODE);
+			continue;
+		}
+		cmd_lockdown_crc[3] = crc_head;
+		logError(0, "%s %s: Get the header CRC value:%02X\n", tag,
+			 __func__, crc_head);
+
+		ret =
+		    fts_writeU8UX(LOCKDOWN_WRITEREAD_CMD, BITS_16,
+				  ADDR_LOCKDOWN + LOCKDOWN_DATA_OFFSET -
+				  LOCKDOWN_HEAD_LENGTH, cmd_lockdown_crc,
+				  ARRAY_SIZE(cmd_lockdown_crc));
+		if (ret < OK) {
+			logError(1,
+				 "%s %s: Unable to write Lockdown  head at %d iteration.. ERROR %08X\n",
+				 tag, __func__, i, ret);
+			ret = (ret | ERROR_LOCKDOWN_CODE);
+			continue;
+		}
+		mdelay(10);
+		ret =
+		    fts_writeU8UX(LOCKDOWN_WRITEREAD_CMD, BITS_16,
+				  ADDR_LOCKDOWN + LOCKDOWN_DATA_OFFSET, data,
+				  size);
+		if (ret < OK) {
+			logError(1,
+				 "%s %s: Unable to write Lockdown  head at %d iteration.. ERROR %08X\n",
+				 tag, __func__, i, ret);
+			ret = (ret | ERROR_LOCKDOWN_CODE);
+			continue;
+		}
+		mdelay(10);
+		ret = fts_write_dma_safe(lockdown_save, 3);
+		mdelay(5);
+		ret = checkEcho(lockdown_save, 3);
+		if (ret < OK) {
+			logError(1, "%s No Echo received.. ERROR %08X !\n", tag,
+				 ret);
+			continue;
+		} else {
+			logError(1, "%s Echo FOUND... OK!\n", tag, ret);
+			ret = pollForErrorType(error_to_search, 4);
+			if (ret < OK) {
+				logError(1, "%s %s: No Error Found! \n", tag,
+					 __func__);
+				ret = OK;
+			} else {
+				logError(1,
+					 "%s %s: have error when write lockdown ERROR = %02X\n",
+					 tag, __func__, ret);
+				ret = ERROR_LOCKDOWN_CODE;
+			}
+			break;
+		}
+	}
+	if (ret < OK)
+		logError(1, "%s %s end, write lockdown failed\n", tag, __func__,
+			 ret);
+	else
+		logError(1, "%s %s end, write lockdown success\n", tag,
+			 __func__, ret);
+
+	fts_enableInterrupt();
+	return ret;
+}
+
+int readLockDownInfo(u8 *lockData, u8 lock_id, int size)
+{
+	int ret = 0, i;
+	int loaded_cnt = 0;
+	int loaded_cnt_after = 0;
+	u8 *temp = NULL;
+	char *datatemp = NULL;
+	u8 cmd_lockdown[3] = { 0xA4, 0x06, 0x00 };
+
+	logError(0, "%s %s:enter", tag, __func__);
+	if (lock_id < 0x70 || lock_id > 0x77 || size <= 0
+	    || size > LOCKDOWN_LENGTH - 20) {
+		logError(1, "%s the lock id type is:%02X not support\n", tag,
+			 lock_id);
+		return ERROR_LOCKDOWN_CODE;
+	}
+
+	temp = (u8 *) kmalloc(LOCKDOWN_LENGTH * sizeof(u8), GFP_KERNEL);
+	if (temp == NULL) {
+		logError(1, "FTS temp alloc  memory failed \n");
+		return -ENOMEM;
+	}
+	memset(temp, 0, LOCKDOWN_LENGTH * sizeof(u8));
+
+	fts_disableInterrupt();
+	for (i = 0; i < 3; i++) {
+		ret =
+		    fts_writeReadU8UX(LOCKDOWN_WRITEREAD_CMD, BITS_16,
+				      ADDR_LOCKDOWN, temp, LOCKDOWN_HEAD_LENGTH,
+				      DUMMY_CONFIG);
+		if (ret < OK) {
+			logError(1,
+				 "%s %s: error while reading data ERROR %08X \n",
+				 tag, __func__, ret);
+			goto END;
+		}
+		loaded_cnt = (int)((temp[3] & 0xFF) << 8) + (temp[2] & 0xFF);
+		cmd_lockdown[2] = lock_id;
+		fts_write_dma_safe(cmd_lockdown, 3);
+		mdelay(10);
+		ret = checkEcho(cmd_lockdown, 3);
+		if (ret < OK) {
+			logError(1, "%s No Echo received.. ERROR %08X !\n", tag,
+				 ret);
+			continue;
+		} else {
+			logError(1, "%s Echo FOUND... OK!\n", tag, ret);
+		}
+		ret =
+		    fts_writeReadU8UX(LOCKDOWN_WRITEREAD_CMD, BITS_16,
+				      ADDR_LOCKDOWN, temp,
+				      size + LOCKDOWN_DATA_OFFSET,
+				      DUMMY_CONFIG);
+		if (ret < OK) {
+			logError(1,
+				 "%s %s: error while reading data ERROR %08X \n",
+				 tag, __func__, ret);
+			goto END;
+		}
+
+		loaded_cnt_after =
+		    (int)((temp[3] & 0xFF) << 8) + (temp[2] & 0xFF);
+		if (temp[4] == EVT_TYPE_ERROR_LOCKDOWN_FLASH
+		    || temp[4] == EVT_TYPE_ERROR_LOCKDOWN_NO_DATA) {
+			logError(1,
+				 "%s %s: can not read the lockdown code ERROR type:%02X\n",
+				 tag, __func__, temp[4]);
+			ret = ERROR_LOCKDOWN_CODE;
+			goto END;
+		}
+
+		logError(1,
+			 "%s %s signature:%02X id:%02X %02X beforecnt:%d,aftercnt:%d\n",
+			 tag, __func__, temp[0], temp[1], lock_id, loaded_cnt,
+			 loaded_cnt_after);
+		if (loaded_cnt_after == loaded_cnt + 1) {
+			ret = OK;
+			memcpy(lockData, &temp[LOCKDOWN_DATA_OFFSET], size);
+			break;
+		}
+
+	}
+
+	datatemp = printHex_data("Lockdown Code = ", lockData, size);
+	if (datatemp != NULL) {
+		logError(1, "%s %s", tag, datatemp);
+		kfree(datatemp);
+	}
+
+END:
+	fts_enableInterrupt();
+	kfree(temp);
+	return ret;
+}
+
+int fts_get_lockdown_info(u8 *lockData, struct fts_ts_info *info)
+{
+	int ret = 0, i;
+	int loaded_cnt = 0;
+	u8 lock_id = FTS_CMD_LOCKDOWN_ID;
+	int size = FTS_LOCKDOWN_SIZE;
+	int loaded_cnt_after = 0;
+	u8 *temp = NULL;
+	u8 cmd_lockdown[3] = { 0xA4, 0x06, 0x00 };
+	char *datatemp = NULL;
+
+	if (info == NULL)
+		return ERROR_LOCKDOWN_CODE;
+	if (info->lockdown_is_ok) {
+		logError(1, "%s %s aleady get,skip\n", tag, __func__);
+		return OK;
+	}
+	logError(0, "%s %s:enter", tag, __func__);
+	if (lock_id < 0x70 || lock_id > 0x77) {
+		logError(1, "%s the lock id type is not support\n", tag);
+		return ERROR_LOCKDOWN_CODE;
+	}
+
+	temp = (u8 *) kmalloc(1024 * sizeof(u8), GFP_KERNEL);
+	if (temp == NULL) {
+		logError(1, "FTS temp alloc  memory failed \n");
+		return -ENOMEM;
+	}
+	memset(temp, 0, 1024 * sizeof(u8));
+
+	fts_disableInterrupt();
+
+	for (i = 0; i < LOCKDOWN_CODE_RETRY; i++) {
+
+		ret =
+		    fts_writeReadU8UX(LOCKDOWN_WRITEREAD_CMD, BITS_16,
+				      ADDR_LOCKDOWN, temp, LOCKDOWN_HEAD_LENGTH,
+				      DUMMY_CONFIG);
+		if (ret < OK) {
+			logError(1,
+				 "%s %s: error while reading data ERROR %08X \n",
+				 tag, __func__, ret);
+			goto END;
+		}
+		loaded_cnt = (int)((temp[3] & 0xFF) << 8) + (temp[2] & 0xFF);
+		cmd_lockdown[2] = lock_id;
+		fts_write_dma_safe(cmd_lockdown, 3);
+		mdelay(10);
+		ret = checkEcho(cmd_lockdown, 3);
+		if (ret < OK) {
+			logError(1, "%s No Echo received.. ERROR %08X !\n", tag,
+				 ret);
+			continue;
+		} else {
+			logError(1, "%s Echo FOUND... OK!\n", tag, ret);
+		}
+		ret =
+		    fts_writeReadU8UX(LOCKDOWN_WRITEREAD_CMD, BITS_16,
+				      ADDR_LOCKDOWN, temp,
+				      size + LOCKDOWN_DATA_OFFSET,
+				      DUMMY_CONFIG);
+		if (ret < OK) {
+			logError(1,
+				 "%s %s: error while reading data ERROR %08X \n",
+				 tag, __func__, ret);
+			goto END;
+		}
+
+		loaded_cnt_after =
+		    (int)((temp[3] & 0xFF) << 8) + (temp[2] & 0xFF);
+		if (temp[4] == EVT_TYPE_ERROR_LOCKDOWN_FLASH
+		    || temp[4] == EVT_TYPE_ERROR_LOCKDOWN_NO_DATA) {
+			logError(1,
+				 "%s %s: can not read the lockdown code ERROR type:%02X\n",
+				 tag, __func__, temp[4]);
+			ret = ERROR_LOCKDOWN_CODE;
+			goto END;
+		}
+
+		logError(1,
+			 "%s %s signature:%02X id:%02X %02X beforecnt:%d,aftercnt:%d\n",
+			 tag, __func__, temp[0], temp[1], lock_id, loaded_cnt,
+			 loaded_cnt_after);
+		if (loaded_cnt_after == loaded_cnt + 1) {
+			ret = OK;
+			memcpy(lockData, &temp[LOCKDOWN_DATA_OFFSET], size);
+			break;
+		}
+
+	}
+
+	datatemp = printHex_data("Lockdown Code = ", lockData, size);
+	if (datatemp != NULL) {
+		logError(0, "%s %s", tag, datatemp);
+		kfree(datatemp);
+	}
+
+END:
+	fts_enableInterrupt();
+	kfree(temp);
+	return ret;
+
+}
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsCore.h b/drivers/input/touchscreen/stfts/fts_lib/ftsCore.h
new file mode 100644
index 000000000000..0022ceacc3d2
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsCore.h
@@ -0,0 +1,180 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*							FTS Core definitions						 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsCore.h
+* \brief Contains all the definitions and structs of Core functionalities
+*/
+
+#ifndef FTS_CORE_H
+#define FTS_CORE_H
+
+#include "ftsHardware.h"
+#include "ftsSoftware.h"
+#include "../fts.h"
+
+/*HW DATA*/
+#define GPIO_NOT_DEFINED					-1									/*value assumed by reset_gpio when the reset pin of the IC is not connected*/
+
+#define ADDR_SIZE_HW_REG					BITS_32							/*value of AddrSize for Hw register in FTI @see AddrSize*/
+
+#define DATA_HEADER							4								/*size in byte of the header loaded with the data in the frambuffer*/
+#define LOCKDOWN_CODE_RETRY  				2
+/**
+ * Type of CRC errors
+ */
+typedef enum {
+	CRC_CODE = 1,																/*CRC in the code section*/
+	CRC_CONFIG = 2,															/*CRC in the config section*/
+	CRC_CX = 3,																/*CRC in the cx section*/
+	CRC_PANEL = 4																/*CRC in the panel section*/
+} CRC_Error;
+
+/*CHIP INFO*/
+/** @defgroup system_info	System Info
+* System Info Data collect the most important informations about hw and fw
+* @{
+*/
+#define SYS_INFO_SIZE						208									/*Size in bytes of System Info data*/
+#define DIE_INFO_SIZE						16									/*num bytes of die info*/
+#define EXTERNAL_RELEASE_INFO_SIZE			8									/*num bytes of external release in config*/
+#define RELEASE_INFO_SIZE					(EXTERNAL_RELEASE_INFO_SIZE + 8)		/*num bytes of release info in sys info (first bytes are external release)*/
+/** @}*/
+
+/*RETRY MECHANISM*/
+#define RETRY_MAX_REQU_DATA					2								/*Max number of attemps performed when requesting data*/
+#define RETRY_SYSTEM_RESET					3									/*Max number of attemps performed to reset the IC*/
+
+/*LOCKDOWN INFO*/
+#define LOCKDOWN_LENGTH						384
+#define LOCKDOWN_HEAD_LENGTH				4
+#define LOCKDOWN_DATA_OFFSET				20
+#define LOCKDOWN_SIGNATURE					0x5A
+#define ADDR_LOCKDOWN						((u64)0x0000000000000000)
+#define LOCKDOWN_WRITEREAD_CMD				0xA6
+
+/** @addtogroup system_info
+* @{
+*/
+
+/**
+ * Struct which contains fundamental informations about the chip and its configuration
+ */
+typedef struct {
+	u16 u16_apiVer_rev;														/*API revision version*/
+	u8 u8_apiVer_minor;														/*API minor version*/
+	u8 u8_apiVer_major;														/*API major version*/
+	u16 u16_chip0Ver;															/*Dev0 version*/
+	u16 u16_chip0Id;															/*Dev0 ID*/
+	u16 u16_chip1Ver;															/*Dev1 version*/
+	u16 u16_chip1Id;															/*Dev1 ID*/
+	u16 u16_fwVer;																/*Fw version*/
+	u16 u16_svnRev;															/*SVN Revision*/
+	u16 u16_cfgVer;															/*Config Version*/
+	u16 u16_cfgProgectId;														/*Config Project ID*/
+	u16 u16_cxVer;																/*Cx Version*/
+	u16 u16_cxProjectId;														/*Cx Project ID*/
+	u8 u8_cfgAfeVer;															/*AFE version in Config*/
+	u8 u8_cxAfeVer;															/*AFE version in CX*/
+	u8 u8_panelCfgAfeVer;														/*AFE version in PanelMem*/
+	u8 u8_protocol;															/*Touch Report Protocol*/
+	u8 u8_dieInfo[DIE_INFO_SIZE];												/*Die information*/
+	u8 u8_releaseInfo[RELEASE_INFO_SIZE];										/*Release information*/
+	u32 u32_fwCrc;																/*Crc of FW*/
+	u32 u32_cfgCrc;															/*Crc of config*/
+
+	u16 u16_scrResX;															/*X resolution on main screen*/
+	u16 u16_scrResY;															/*Y resolution on main screen*/
+	u8 u8_scrTxLen;															/*Tx length*/
+	u8 u8_scrRxLen;															/*Rx length*/
+	u8 u8_keyLen;																/*Key Len*/
+	u8 u8_forceLen;															/*Force Len*/
+
+	u16 u16_dbgInfoAddr;														/*Offset of debug Info structure*/
+
+	u16 u16_msTchRawAddr;														/*Offset of MS touch raw frame*/
+    u16 u16_msTchFilterAddr;													/*Offset of MS touch filter frame*/
+    u16 u16_msTchStrenAddr;													/*Offset of MS touch strength frame*/
+    u16 u16_msTchBaselineAddr;													/*Offset of MS touch baseline frame*/
+
+    u16 u16_ssTchTxRawAddr;													/*Offset of SS touch force raw frame*/
+    u16 u16_ssTchTxFilterAddr;													/*Offset of SS touch force filter frame*/
+    u16 u16_ssTchTxStrenAddr;													/*Offset of SS touch force strength frame*/
+    u16 u16_ssTchTxBaselineAddr;												/*Offset of SS touch force baseline frame*/
+
+    u16 u16_ssTchRxRawAddr;													/*Offset of SS touch sense raw frame*/
+    u16 u16_ssTchRxFilterAddr;													/*Offset of SS touch sense filter frame*/
+    u16 u16_ssTchRxStrenAddr;													/*Offset of SS touch sense strength frame*/
+    u16 u16_ssTchRxBaselineAddr;												/*Offset of SS touch sense baseline frame*/
+
+    u16 u16_keyRawAddr;														/*Offset of key raw frame*/
+    u16 u16_keyFilterAddr;														/*Offset of key filter frame*/
+    u16 u16_keyStrenAddr;														/*Offset of key strength frame*/
+    u16 u16_keyBaselineAddr;													/*Offset of key baseline frame*/
+
+    u16 u16_frcRawAddr;														/*Offset of force touch raw frame*/
+    u16 u16_frcFilterAddr;														/*Offset of force touch filter frame*/
+    u16 u16_frcStrenAddr;														/*Offset of force touch strength frame*/
+    u16 u16_frcBaselineAddr;													/*Offset of force touch baseline frame*/
+
+    u16 u16_ssHvrTxRawAddr;													/*Offset of SS hover Force raw frame*/
+    u16 u16_ssHvrTxFilterAddr;													/*Offset of SS hover Force filter frame*/
+    u16 u16_ssHvrTxStrenAddr;													/*Offset of SS hover Force strength frame*/
+    u16 u16_ssHvrTxBaselineAddr;												/*Offset of SS hover Force baseline frame*/
+
+    u16 u16_ssHvrRxRawAddr;													/*Offset of SS hover Sense raw frame*/
+    u16 u16_ssHvrRxFilterAddr;													/*Offset of SS hover Sense filter frame*/
+    u16 u16_ssHvrRxStrenAddr;													/*Offset of SS hover Sense strength frame*/
+    u16 u16_ssHvrRxBaselineAddr;												/*Offset of SS hover Sense baseline frame*/
+
+    u16 u16_ssPrxTxRawAddr;													/*Offset of SS proximity force raw frame*/
+    u16 u16_ssPrxTxFilterAddr;													/*Offset of SS proximity force filter frame*/
+    u16 u16_ssPrxTxStrenAddr;													/*Offset of SS proximity force strength frame*/
+    u16 u16_ssPrxTxBaselineAddr;												/*Offset of SS proximity force baseline frame*/
+
+    u16 u16_ssPrxRxRawAddr;													/*Offset of SS proximity sense raw frame*/
+    u16 u16_ssPrxRxFilterAddr;													/*Offset of SS proximity sense filter frame*/
+    u16 u16_ssPrxRxStrenAddr;													/*Offset of SS proximity sense strength frame*/
+    u16 u16_ssPrxRxBaselineAddr;												/*Offset of SS proximity sense baseline frame*/
+} SysInfo;
+
+/** @}*/
+
+int initCore(struct fts_ts_info *info);
+void setResetGpio(int gpio);
+int fts_system_reset(void);
+int isSystemResettedUp(void);
+int isSystemResettedDown(void);
+void setSystemResetedUp(int val);
+void setSystemResetedDown(int val);
+int pollForEvent(int *event_to_search, int event_bytes, u8 *readData, int time_to_wait);
+int checkEcho(u8 *cmd, int size);
+int setScanMode(u8 mode, u8 settings);
+int setFeatures(u8 feat, u8 *settings, int size);
+int defaultSysInfo(int i2cError);
+int writeSysCmd(u8 sys_cmd, u8 *sett, int size);
+int readSysInfo(int request);
+int readConfig(u16 offset, u8 *outBuf, int len);
+int fts_disableInterrupt(void);
+int fts_disableInterruptNoSync(void);
+int fts_resetDisableIrqCount(void);
+int fts_enableInterrupt(void);
+int fts_crc_check(void);
+int requestSyncFrame(u8 type);
+int fts_get_lockdown_info(u8 *lockData, struct fts_ts_info *info);
+int writeLockDownInfo(u8 *data, int size, u8 lock_id);
+int readLockDownInfo(u8 *lockData, u8 lock_id, int size);
+
+#endif /* FTS_CORE_H */
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsError.c b/drivers/input/touchscreen/stfts/fts_lib/ftsError.c
new file mode 100644
index 000000000000..0435875f8533
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsError.c
@@ -0,0 +1,357 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*                  FTS error/info kernel log reporting					 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsError.c
+* \brief Contains all the function which handle with Error conditions
+*/
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#include "../fts.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsIO.h"
+#include "ftsTool.h"
+#include "ftsCompensation.h"
+
+static ErrorList errors;
+
+/**
+* Print messages in the kernel log
+* @param force if 1, the log is printed always otherwise only if DEBUG is defined, the log will be printed
+* @param msg string containing the message to print
+* @param ... additional parameters that are used in msg according the format of printf
+*/
+void logError(int force, const char *msg, ...)
+{
+	if (force == 1
+#ifdef DEBUG
+	    || 1
+#endif
+	    ) {
+		va_list args;
+		va_start(args, msg);
+		vprintk(msg, args);
+		va_end(args);
+	}
+}
+
+/**
+* Check if an error code is related to an I2C failure
+* @param error error code to check
+* @return 1 if the first level error code is I2C related otherwise 0
+*/
+int isI2cError(int error)
+{
+	if (((error & 0x000000FF) >= (ERROR_BUS_R & 0x000000FF)) &&
+	    ((error & 0x000000FF) <= (ERROR_BUS_O & 0x000000FF)))
+		return 1;
+	else
+		return 0;
+}
+
+/**
+ * Dump in the kernel log some debug info in case of FW hang
+ * @param outBuf (optional)pointer to bytes array where to copy the debug info, if NULL the data will just printed on the kernel log
+ * @param size dimension in bytes of outBuf, if > ERROR_DUMP_ROW_SIZE*ERROR_DUMP_COL_SIZE, only the first ERROR_DUMP_ROW_SIZE*ERROR_DUMP_COL_SIZE bytes will be copied
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int dumpErrorInfo(u8 *outBuf, int size)
+{
+	int ret, i;
+	u8 data[ERROR_DUMP_ROW_SIZE * ERROR_DUMP_COL_SIZE] = { 0 };
+	u32 sign = 0;
+
+	logError(0, "%s %s: Starting dump of error info...\n", tag, __func__);
+
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, ADDR_ERROR_DUMP,
+			      data, ERROR_DUMP_ROW_SIZE * ERROR_DUMP_COL_SIZE,
+			      DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		logError(1, "%s %s: reading data ERROR %08X\n", tag, __func__,
+			 ret);
+		return ret;
+	} else {
+		if (outBuf != NULL) {
+			sign =
+			    size >
+			    ERROR_DUMP_ROW_SIZE *
+			    ERROR_DUMP_COL_SIZE ? ERROR_DUMP_ROW_SIZE *
+			    ERROR_DUMP_COL_SIZE : size;
+			memcpy(outBuf, data, sign);
+			logError(0,
+				 "%s %s: error info copied in the buffer! \n",
+				 tag, __func__);
+		}
+		logError(1, "%s %s: Error Info = \n", tag, __func__);
+		u8ToU32(data, &sign);
+		if (sign != ERROR_DUMP_SIGNATURE)
+			logError(1,
+				 "%s %s: Wrong Error Signature! Data may be invalid! \n",
+				 tag, __func__);
+		else
+			logError(1,
+				 "%s %s: Error Signature OK! Data are valid! \n",
+				 tag, __func__);
+
+		for (i = 0; i < ERROR_DUMP_ROW_SIZE * ERROR_DUMP_COL_SIZE; i++) {
+			if (i % ERROR_DUMP_COL_SIZE == 0) {
+				logError(1, KERN_ERR "\n%s %s: %d) ", tag,
+					 __func__, i / ERROR_DUMP_COL_SIZE);
+			}
+			logError(1, "%02X ", data[i]);
+		}
+		logError(1, "\n");
+
+		logError(0, "%s %s: dump of error info FINISHED!\n", tag,
+			 __func__);
+		return OK;
+	}
+
+}
+
+/**
+* Implement recovery strategies to be used when an error event is found while polling the FIFO
+* @param event error event found during the polling
+* @param size size of event
+* @return OK if the error event doesn't require any action or the recovery strategy doesn't have any impact in the possible procedure that trigger the error, otherwise return an error code which specify the kind of error encountered. If ERROR_HANDLER_STOP_PROC the calling function must stop!
+*/
+int errorHandler(u8 *event, int size)
+{
+	int res = OK;
+	struct fts_ts_info *info = NULL;
+
+	if (getDev() != NULL)
+		info = dev_get_drvdata(getDev());
+
+	if (info != NULL && event != NULL && size > 1
+	    && event[0] == EVT_ID_ERROR) {
+		logError(0, "%s errorHandler: Starting handling...\n", tag);
+		addErrorIntoList(event, size);
+		switch (event[1]) {
+		case EVT_TYPE_ERROR_ESD:
+			res = fts_chip_powercycle(info);
+			if (res < OK) {
+				logError(1,
+					 "%s errorHandler: Error performing powercycle ERROR %08X\n",
+					 tag, res);
+			}
+
+			res = fts_system_reset();
+			if (res < OK) {
+				logError(1,
+					 "%s errorHandler: Cannot reset the device ERROR %08X\n",
+					 tag, res);
+			}
+			res = (ERROR_HANDLER_STOP_PROC | res);
+			break;
+
+		case EVT_TYPE_ERROR_WATCHDOG:
+			dumpErrorInfo(NULL, 0);
+			res = fts_system_reset();
+			if (res < OK) {
+				logError(1,
+					 "%s errorHandler: Cannot reset the device ERROR %08X\n",
+					 tag, res);
+			}
+			res = (ERROR_HANDLER_STOP_PROC | res);
+			break;
+
+		case EVT_TYPE_ERROR_ITO_FORCETOGND:
+			logError(1, "%s errorHandler: Force Short to GND!\n",
+				 tag);
+			break;
+		case EVT_TYPE_ERROR_ITO_SENSETOGND:
+			logError(1, "%s errorHandler: Sense short to GND! \n",
+				 tag);
+			break;
+		case EVT_TYPE_ERROR_ITO_FORCETOVDD:
+			logError(1, "%s errorHandler: Force short to VDD!\n",
+				 tag);
+			break;
+		case EVT_TYPE_ERROR_ITO_SENSETOVDD:
+			logError(1, "%s errorHandler: Sense short to VDD!\n",
+				 tag);
+			break;
+		case EVT_TYPE_ERROR_ITO_FORCE_P2P:
+			logError(1,
+				 "%s errorHandler: Force Pin to Pin Short!\n",
+				 tag);
+			break;
+		case EVT_TYPE_ERROR_ITO_SENSE_P2P:
+			logError(1,
+				 "%s errorHandler: Sense Pin to Pin Short!\n",
+				 tag);
+			break;
+		case EVT_TYPE_ERROR_ITO_FORCEOPEN:
+			logError(1, "%s errorHandler: Force Open !\n", tag);
+			break;
+		case EVT_TYPE_ERROR_ITO_SENSEOPEN:
+			logError(1, "%s errorHandler: Sense Open !\n", tag);
+			break;
+		case EVT_TYPE_ERROR_ITO_KEYOPEN:
+			logError(1, "%s errorHandler: Key Open !\n", tag);
+			break;
+
+		default:
+			logError(0, "%s errorHandler: No Action taken! \n",
+				 tag);
+			break;
+
+		}
+		logError(0, "%s errorHandler: handling Finished! res = %08X\n",
+			 tag, res);
+		return res;
+	} else {
+		logError(1,
+			 "%s errorHandler: event Null or not correct size! ERROR %08X \n",
+			 tag, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+}
+
+/**
+* Add an error event into the Error List
+* @param event error event to add
+* @param size size of event
+* @return OK
+*/
+int addErrorIntoList(u8 *event, int size)
+{
+	int i = 0;
+
+	logError(0, "%s Adding error in to ErrorList... \n", tag);
+
+	memcpy(&errors.list[errors.last_index * FIFO_EVENT_SIZE], event, size);
+	i = FIFO_EVENT_SIZE - size;
+	if (i > 0) {
+		logError(0,
+			 "%s Filling last %d bytes of the event with zero...\n",
+			 tag, i);
+		memset(&errors.list[errors.last_index * FIFO_EVENT_SIZE + size],
+		       0, i);
+	}
+	logError(0, "%s Adding error in to ErrorList... FINISHED!\n", tag);
+
+	errors.count += 1;
+	if (errors.count > FIFO_DEPTH)
+		logError(1,
+			 "%s ErrorList is going in overflow... the first %d event(s) were override!\n",
+			 tag, errors.count - FIFO_DEPTH);
+	errors.last_index = (errors.last_index + 1) % FIFO_DEPTH;
+
+	return OK;
+}
+
+/**
+* Reset the Error List setting the count and last_index to 0.
+* @return OK
+*/
+int resetErrorList(void)
+{
+	errors.count = 0;
+	errors.last_index = 0;
+	memset(errors.list, 0, FIFO_DEPTH * FIFO_EVENT_SIZE);
+	return OK;
+}
+
+/**
+* Get the number of error events copied into the Error List
+* @return the number of error events into the Error List
+*/
+int getErrorListCount(void)
+{
+	if (errors.count > FIFO_DEPTH)
+		return FIFO_DEPTH;
+	else
+		return errors.count;
+}
+
+
+/**
+* Scroll the Error List looking for the event specified
+* @param event_to_search event_to_search pointer to an array of int where each element correspond to a byte of the event to find. If the element of the array has value -1, the byte of the event, in the same position of the element is ignored.
+* @param event_bytes size of event_to_search
+* @return a value >=0 if the event is found which represent the index of the Error List where the event is located otherwise an error code
+*/
+int pollErrorList(int *event_to_search, int event_bytes)
+{
+	int i = 0, j = 0, find = 0;
+	int count = getErrorListCount();
+
+	logError(0, "%s Starting to poll ErrorList... \n", tag);
+	while (find != 1 && i < count) {
+		find = 1;
+		for (j = 0; j < event_bytes; j++) {
+
+			if (event_to_search[i] != -1
+			    && (int)errors.list[i * FIFO_EVENT_SIZE + j] !=
+			    event_to_search[i]) {
+				find = 0;
+				break;
+			}
+		}
+		i++;
+	}
+	if (find == 1) {
+		logError(1, "%s Error Found into ErrorList! \n", tag);
+		return i - 1;
+	} else {
+		logError(0, "%s Error Not Found into ErrorList! ERROR %08X \n",
+			 tag, ERROR_TIMEOUT);
+		return ERROR_TIMEOUT;
+	}
+}
+
+/**
+* Poll the Error List looking for any error types passed in the arguments. Return at the first match!
+* @param list pointer to a list of error types to look for
+* @param size size of list
+* @return error type found if success or ERROR_TIMEOUT
+*/
+int pollForErrorType(u8 *list, int size)
+{
+	int i = 0, j = 0, find = 0;
+	int count = getErrorListCount();
+
+	logError(0, "%s %s: Starting to poll ErrorList... count = %d \n", tag,
+		 __func__, count);
+	while (find != 1 && i < count) {
+		for (j = 0; j < size; j++) {
+			if (list[j] == errors.list[i * FIFO_EVENT_SIZE + 1]) {
+				find = 1;
+				break;
+			}
+		}
+		i++;
+	}
+	if (find == 1) {
+		logError(1, "%s %s: Error Type %02X into ErrorList! \n", tag,
+			 __func__, list[j]);
+		return list[j];
+	} else {
+		logError(0,
+			 "%s %s: Error Type Not Found into ErrorList! ERROR %08X \n",
+			 tag, __func__, ERROR_TIMEOUT);
+		return ERROR_TIMEOUT;
+	}
+}
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsError.h b/drivers/input/touchscreen/stfts/fts_lib/ftsError.h
new file mode 100644
index 000000000000..206a0b3ad400
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsError.h
@@ -0,0 +1,145 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*                  FTS error/info kernel log reporting					 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsError.h
+* \brief Contains all the definitions and structs which refer to Error conditions
+*/
+
+#ifndef FTS_ERROR_H
+#define FTS_ERROR_H
+
+#include "ftsHardware.h"
+#include "ftsSoftware.h"
+
+/** @defgroup error_codes Error Codes
+ * Error codes that can be reported by the driver functions.
+ * An error code is made up by 4 bytes, each byte indicate a logic error level.\n
+ * From the LSB to the MSB, the logic level increase going from a low level error (I2C,TIMEOUT) to an high level error (flashing procedure fail, production test fail etc)
+ * @{
+ */
+
+/*FIRST LEVEL ERROR CODE*/
+/** @defgroup first_level	First Level Error Code
+* @ingroup error_codes
+* Errors related to low level operation which are not under control of driver, such as: communication protocol (I2C/SPI), timeout, file operations ...
+* @{
+*/
+#define OK								((int)0x00000000)			/*No ERROR*/
+#define ERROR_ALLOC						((int)0x80000001)			/*allocation of memory failed*/
+#define ERROR_BUS_R						((int)0x80000002)			/*i2c/spi read failed*/
+#define ERROR_BUS_W						((int)0x80000003)			/*i2c/spi write failed*/
+#define ERROR_BUS_WR					((int)0x80000004)			/*i2c/spi write/read failed*/
+#define ERROR_BUS_O						((int)0x80000005)			/*error during opening an i2c device*/
+#define ERROR_OP_NOT_ALLOW				((int)0x80000006)			/*operation not allowed*/
+#define ERROR_TIMEOUT					((int)0x80000007)			/*timeout expired! exceed the max number of retries or the max waiting time*/
+#define ERROR_FILE_NOT_FOUND			((int)0x80000008)			/*the file that i want to open is not found*/
+#define ERROR_FILE_PARSE				((int)0x80000009)			/*error during parsing the file*/
+#define ERROR_FILE_READ					((int)0x8000000A)			/*error during reading the file*/
+#define ERROR_LABEL_NOT_FOUND			((int)0x8000000B)			/*label not found*/
+#define ERROR_FW_NO_UPDATE				((int)0x8000000C)			/*fw in the chip newer than the one in the memmh*/
+#define ERROR_FLASH_UNKNOWN				((int)0x8000000D)			/*flash status busy or unknown*/
+/** @}*/
+
+/*SECOND LEVEL ERROR CODE */
+/** @defgroup second_level Second Level Error Code
+* @ingroup error_codes
+* Errors related to simple logic operations in the IC which require one command or which are part of a more complex procedure
+* @{
+*/
+#define ERROR_DISABLE_INTER				((int)0x80000200)			/*unable to disable the interrupt*/
+#define ERROR_ENABLE_INTER				((int)0x80000300)			/*unable to activate the interrup*/
+#define ERROR_READ_CONFIG				((int)0x80000400)			/*failed to read config memory*/
+#define ERROR_GET_OFFSET				((int)0x80000500)			/*unable to read an offset from memory*/
+#define ERROR_GET_FRAME_DATA			((int)0x80000600)			/*unable to retrieve the data of a required frame*/
+#define ERROR_DIFF_DATA_TYPE			((int)0x80000700)			/*FW answers with an event that has a different address respect the request done*/
+#define ERROR_WRONG_DATA_SIGN			((int)0x80000800)			/*the signature of the host data is not HEADER_SIGNATURE*/
+#define ERROR_SET_SCAN_MODE_FAIL		((int)0x80000900)			/*setting the scanning mode failed (sense on/off etc...)*/
+#define ERROR_SET_FEATURE_FAIL			((int)0x80000A00)			/*setting a specific feature failed*/
+#define ERROR_SYSTEM_RESET_FAIL			((int)0x80000B00)			/*the comand SYSTEM RESET failed*/
+#define ERROR_FLASH_NOT_READY			((int)0x80000C00)			/*flash status not ready within a timeout*/
+#define ERROR_FW_VER_READ				((int)0x80000D00)			/*unable to retrieve fw_vers or the config_id*/
+#define ERROR_GESTURE_ENABLE_FAIL		((int)0x80000E00)			/*unable to enable/disable the gesture*/
+#define ERROR_GESTURE_START_ADD			((int)0x80000F00)			/*unable to start to add custom gesture*/
+#define ERROR_GESTURE_FINISH_ADD		((int)0x80001000)			/*unable to finish to add custom gesture*/
+#define ERROR_GESTURE_DATA_ADD			((int)0x80001100)			/*unable to add custom gesture data*/
+#define ERROR_GESTURE_REMOVE			((int)0x80001200)			/*unable to remove custom gesture data*/
+#define ERROR_FEATURE_ENABLE_DISABLE	((int)0x80001300)			/*unable to enable/disable a feature mode in the IC*/
+#define ERROR_NOISE_PARAMETERS			((int)0x80001400)			/*unable to set/read noise parameter in the IC*/
+#define ERROR_CH_LEN					((int)0x80001500)			/*unable to retrieve the force and/or sense length*/
+/** @}*/
+
+/*THIRD LEVEL ERROR CODE */
+/** @defgroup third_level	Third Level Error Code
+* @ingroup error_codes
+* Errors related to logic operations in the IC which require more commands/steps or which are part of a more complex procedure
+* @{
+*/
+#define ERROR_REQU_COMP_DATA			((int)0x80010000)			/*compensation data request failed*/
+#define ERROR_REQU_DATA					((int)0x80020000)			/*data request failed*/
+#define ERROR_COMP_DATA_HEADER			((int)0x80030000)			/*unable to retrieve the compensation data   header*/
+#define ERROR_COMP_DATA_GLOBAL			((int)0x80040000)			/*unable to retrieve the global compensation data*/
+#define ERROR_COMP_DATA_NODE			((int)0x80050000)			/*unable to retrieve the compensation data for each node*/
+#define ERROR_TEST_CHECK_FAIL			((int)0x80060000)			/*check of production limits or of fw answers failed*/
+#define ERROR_MEMH_READ					((int)0x80070000)			/*memh reading failed*/
+#define ERROR_FLASH_BURN_FAILED			((int)0x80080000)			/*flash burn failed*/
+#define ERROR_MS_TUNING					((int)0x80090000)			/*ms tuning failed*/
+#define ERROR_SS_TUNING					((int)0x800A0000)			/*ss tuning failed*/
+#define ERROR_LP_TIMER_TUNING			((int)0x800B0000)			/*lp timer calibration failed*/
+#define ERROR_SAVE_CX_TUNING			((int)0x800C0000)			/*save cx data to flash failed*/
+#define ERROR_HANDLER_STOP_PROC			((int)0x800D0000)			/*stop the poll of the FIFO if particular errors are found*/
+#define ERROR_CHECK_ECHO_FAIL			((int)0x800E0000)			/*unable to retrieve echo event*/
+#define ERROR_GET_FRAME					((int)0x800F0000)			/*unable to get frame*/
+/** @}*/
+
+/*FOURTH LEVEL ERROR CODE*/
+/** @defgroup fourth_level	Fourth Level Error Code
+* @ingroup error_codes
+* Errors related to the highest logic operations in the IC which have an important impact on the driver flow or which require several commands and steps to be executed
+* @{
+*/
+#define ERROR_PROD_TEST_DATA			((int)0x81000000)			/*production data test failed*/
+#define ERROR_FLASH_PROCEDURE			((int)0x82000000)			/*fw update procedure failed*/
+#define ERROR_PROD_TEST_ITO				((int)0x83000000)			/*production ito test failed*/
+#define ERROR_PROD_TEST_INITIALIZATION	((int)0x84000000)			/*production initialization test failed*/
+#define ERROR_GET_INIT_STATUS			((int)0x85000000)			/*mismatch of the MS or SS tuning_version*/
+#define ERROR_LOCKDOWN_CODE				((int)0x80001600)			/*unable to write/rewrite/read lockdown code in the IC*/
+
+#define EVT_TYPE_ERROR_LOCKDOWN_FLASH		0x30	    		/*FW shall not proceed with any flash write/read*/
+#define EVT_TYPE_ERROR_LOCKDOWN_CRC			0x31	    		/*FW shall discard the record and do not write to flash*/
+#define EVT_TYPE_ERROR_LOCKDOWN_NO_DATA		0x32	    		/*No data of this type exisitng in flash*/
+#define EVT_TYPE_ERROR_LOCKDOWN_WRITE_FULL	0x33	    		/*FW shall not write this new record to flash*/
+/** @}*/
+
+/**
+* Struct which store an ordered list of the errors events encountered during the polling of a FIFO.
+* The max number of error events that can be stored is equal to FIFO_DEPTH
+*/
+typedef struct {
+	u8 list[FIFO_DEPTH * FIFO_EVENT_SIZE];	 					/*byte array which contains the series of error events encountered from the last reset of the list.*/
+	int count;		                         					/*number of error events stored in the list*/
+	int last_index;		                     					/*index of the list where will be stored the next error event. Subtract -1 to have the index of the last error event!*/
+} ErrorList;
+
+void logError(int force, const char *msg, ...);
+int isI2cError(int error);
+int dumpErrorInfo(u8 *outBuf, int size);
+int errorHandler(u8 *event, int size);
+int addErrorIntoList(u8 *event, int size);
+int getErrorListCount(void);
+int resetErrorList(void);
+int pollErrorList(int *event_to_search, int event_bytes);
+int pollForErrorType(u8 *list, int size);
+#endif
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsFlash.c b/drivers/input/touchscreen/stfts/fts_lib/ftsFlash.c
new file mode 100644
index 000000000000..de7ae36591ae
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsFlash.c
@@ -0,0 +1,1032 @@
+/*
+
+ **************************************************************************
+ **                        STMicroelectronics							 **
+ **************************************************************************
+ **                        marco.cali@st.com							 **
+ **************************************************************************
+ *                                                                        *
+ *               	FTS API for Flashing the IC							  *
+ *                                                                        *
+ **************************************************************************
+ **************************************************************************
+
+ */
+
+/*!
+* \file ftsFlash.c
+* \brief Contains all the functions to handle the FW update process
+*/
+
+#include "ftsCore.h"
+#include "ftsCompensation.h"
+#include "ftsError.h"
+#include "ftsFlash.h"
+#include "ftsFrame.h"
+#include "ftsIO.h"
+#include "ftsSoftware.h"
+#include "ftsTest.h"
+#include "ftsTime.h"
+#include "ftsTool.h"
+#include "../fts.h"
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/serio.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/firmware.h>
+
+#ifdef FW_H_FILE
+#include "../fts_fw.h"
+#endif
+
+extern SysInfo systemInfo;
+extern struct fts_ts_info *fts_info;
+
+/**
+ * Read the fw version and config id from the chip
+ * @param fw_vers pointer to the variable which will contains the fw version
+ * @param config_id pointer to the variable which will contains the config id
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int getFirmwareVersion(u16 *fw_vers, u16 *config_id)
+{
+	u8 fwvers[DCHIP_FW_VER_BYTE];
+	u8 confid[CONFIG_ID_BYTE];
+	int res;
+
+	res =
+	    fts_writeReadU8UX(FTS_CMD_HW_REG_R, ADDR_SIZE_HW_REG,
+			      ADDR_DCHIP_FW_VER, fwvers, DCHIP_FW_VER_BYTE,
+			      DUMMY_HW_REG);
+	if (res < OK) {
+		logError(1,
+			 "%s getFirmwareVersion: unable to read fw_version ERROR %08X\n",
+			 tag, ERROR_FW_VER_READ);
+		return (res | ERROR_FW_VER_READ);
+	}
+
+	u8ToU16(fwvers, fw_vers);
+	if (*fw_vers != 0) {
+		res = readConfig(ADDR_CONFIG_ID, confid, CONFIG_ID_BYTE);
+		if (res < OK) {
+			logError(1,
+				 "%s getFirmwareVersion: unable to read config_id ERROR %08X\n",
+				 tag, ERROR_FW_VER_READ);
+			return (res | ERROR_FW_VER_READ);
+		}
+		u8ToU16(confid, config_id);
+	} else {
+		*config_id = 0x0000;
+	}
+
+	logError(0, "%s FW VERS = %04X\n", tag, *fw_vers);
+	logError(0, "%s CONFIG ID = %04X\n", tag, *config_id);
+	return OK;
+
+}
+
+/**
+* Retrieve the actual FW data from the system (bin file or header file)
+* @param pathToFile name of FW file to load or "NULL" if the FW data should be loaded by a .h file
+* @param data pointer to the pointer which will contains the FW data
+* @param size pointer to a variable which will contain the size of the loaded data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int getFWdata(const char *pathToFile, u8 **data, int *size)
+{
+	const struct firmware *fw = NULL;
+	struct device *dev = NULL;
+	int res, from = 0;
+	char *path = (char *)pathToFile;
+
+	logError(1, "%s getFWdata starting ...\n", tag);
+	if (strncmp(pathToFile, "NULL", 4) == 0) {
+		from = 1;
+		path = (char *)fts_info->board->default_fw_name;
+	}
+	switch (from) {
+#ifdef FW_H_FILE
+	case 1:
+		logError(1, "%s Read FW from .h file!\n", tag);
+		*size = FW_SIZE_NAME;
+		*data = (u8 *) kmalloc((*size) * sizeof(u8), GFP_KERNEL);
+		if (*data == NULL) {
+			logError(1,
+				 "%s getFWdata: Impossible to allocate memory! ERROR %08X\n",
+				 tag, ERROR_ALLOC);
+			return ERROR_ALLOC;
+		}
+		memcpy(*data, (u8 *) FW_ARRAY_NAME, (*size));
+
+		break;
+#endif
+	default:
+		logError(1, "%s Read FW from BIN file %s !\n", tag, path);
+		dev = getDev();
+
+		if (dev != NULL) {
+			res = request_firmware(&fw, path, dev);
+			if (res == 0) {
+				*size = fw->size;
+				*data =
+				    (u8 *) kmalloc((*size) * sizeof(u8),
+						   GFP_KERNEL);
+				if (*data == NULL) {
+					logError(1,
+						 "%s getFWdata: Impossible to allocate memory! ERROR %08X\n",
+						 tag, ERROR_ALLOC);
+					release_firmware(fw);
+					return ERROR_ALLOC;
+				}
+				memcpy(*data, (u8 *) fw->data, (*size));
+				release_firmware(fw);
+			} else {
+				logError(1,
+					 "%s getFWdata: No File found! ERROR %08X\n",
+					 tag, ERROR_FILE_NOT_FOUND);
+				return ERROR_FILE_NOT_FOUND;
+			}
+
+		} else {
+			logError(1,
+				 "%s getFWdata: No device found! ERROR %08X\n",
+				 tag, ERROR_OP_NOT_ALLOW);
+			return ERROR_OP_NOT_ALLOW;
+		}
+
+	}
+
+	logError(1, "%s getFWdata Finished!\n", tag);
+	return OK;
+
+}
+
+/**
+* Perform all the steps to read the FW that should be burnt in the IC from the system and parse it in order to fill a Firmware struct with the relevant info
+* @param path name of FW file to load or "NULL" if the FW data should be loaded by a .h file
+* @param fw pointer to a Firmware variable which will contains the FW data and info
+* @param keep_cx if 1, the CX area will be loaded otherwise will be skipped
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int readFwFile(const char *path, Firmware *fw, int keep_cx)
+{
+	int res;
+	int orig_size;
+	u8 *orig_data = NULL;
+
+	res = getFWdata(path, &orig_data, &orig_size);
+	if (res < OK) {
+		logError(1,
+			 "%s readFwFile: impossible retrieve FW... ERROR %08X\n",
+			 tag, ERROR_MEMH_READ);
+		return (res | ERROR_MEMH_READ);
+	}
+	res = parseBinFile(orig_data, orig_size, fw, keep_cx);
+	if (res < OK) {
+		logError(1, "%s readFwFile: impossible parse ERROR %08X\n", tag,
+			 ERROR_MEMH_READ);
+		return (res | ERROR_MEMH_READ);
+	}
+
+	return OK;
+
+}
+
+/**
+* Perform all the steps necessary to burn the FW into the IC
+* @param path name of FW file to load or "NULL" if the FW data should be loaded by a .h file
+* @param force if 1, the flashing procedure will be forced and executed regardless the additional info, otherwise the FW in the file will be burnt only if it is newer than the one running in the IC
+* @param keep_cx if 1, the CX area will be loaded and burnt otherwise will be skipped and the area will be untouched
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int flashProcedure(const char *path, int force, int keep_cx)
+{
+	Firmware fw;
+	int res;
+
+	fw.data = NULL;
+	logError(0, "%s Reading Fw file... \n", tag);
+	res = readFwFile(path, &fw, keep_cx);
+	if (res < OK) {
+		logError(1, "%s flashProcedure: ERROR %08X \n", tag,
+			 (res | ERROR_FLASH_PROCEDURE));
+		kfree(fw.data);
+		return (res | ERROR_FLASH_PROCEDURE);
+	}
+	logError(0, "%s Fw file read COMPLETED! \n", tag);
+
+	logError(0, "%s Starting flashing procedure... \n", tag);
+	res = flash_burn(fw, force, keep_cx);
+	if (res < OK && res != (ERROR_FW_NO_UPDATE | ERROR_FLASH_BURN_FAILED)) {
+		logError(1, "%s flashProcedure: ERROR %08X \n", tag,
+			 ERROR_FLASH_PROCEDURE);
+		kfree(fw.data);
+		return (res | ERROR_FLASH_PROCEDURE);
+	}
+	logError(0, "%s flashing procedure Finished!\n", tag);
+	kfree(fw.data);
+
+	return res;
+}
+
+
+/**
+* Poll the Flash Status Registers after the execution of a command to check if the Flash becomes ready within a timeout
+* @param type register to check according to the previous command sent
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int wait_for_flash_ready(u8 type)
+{
+
+	u8 cmd[5] = { FTS_CMD_HW_REG_R, 0x20, 0x00, 0x00, type };
+
+	u8 readData[2] = { 0 };
+	int i, res = -1;
+
+	logError(0, "%s Waiting for flash ready ... \n", tag);
+	for (i = 0; i < FLASH_RETRY_COUNT && res != 0; i++) {
+		res = fts_writeRead_dma_safe(cmd, ARRAY_SIZE(cmd), readData, 2);
+		if (res < OK) {
+			logError(1, "%s wait_for_flash_ready: ERROR % 08X\n",
+				 tag, ERROR_BUS_W);
+		} else {
+#ifdef I2C_INTERFACE
+			res = readData[0] & 0x80;
+#else
+			res = readData[1] & 0x80;
+#endif
+
+			logError(0, "%s flash status = %d  \n", tag, res);
+		}
+		mdelay(FLASH_WAIT_BEFORE_RETRY);
+	}
+
+	if (i == FLASH_RETRY_COUNT && res != 0) {
+		logError(1, "%s Wait for flash TIMEOUT! ERROR %08X \n", tag,
+			 ERROR_TIMEOUT);
+		return ERROR_TIMEOUT;
+	}
+
+	logError(0, "%s Flash READY! \n", tag);
+	return OK;
+}
+
+/**
+ * Put the M3 in hold
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int hold_m3(void)
+{
+	int ret;
+	u8 cmd[1] = { 0x01 };
+
+	logError(0, "%s Command m3 hold... \n", tag);
+	ret =
+	    fts_writeU8UX(FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG, ADDR_SYSTEM_RESET,
+			  cmd, 1);
+	if (ret < OK) {
+		logError(1, "%s hold_m3: ERROR %08X\n", tag, ret);
+		return ret;
+	}
+	logError(0, "%s Hold M3 DONE! \n", tag);
+
+#if !defined(I2C_INTERFACE) && defined(SPI4_WIRE)
+	logError(0, "%s Setting SPI4 mode... \n", tag);
+	cmd[0] = 0x10;
+	ret =
+	    fts_writeU8UX(FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG,
+			  ADDR_GPIO_DIRECTION, cmd, 1);
+	if (ret < OK) {
+		logError(1, "%s hold_m3: can not set gpio dir ERROR %08X\n",
+			 tag, ret);
+		return ret;
+	}
+
+	cmd[0] = 0x02;
+	ret =
+	    fts_writeU8UX(FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG, ADDR_GPIO_PULLUP,
+			  cmd, 1);
+	if (ret < OK) {
+		logError(1, "%s hold_m3: can not set gpio pull-up ERROR %08X\n",
+			 tag, ret);
+		return ret;
+	}
+
+	cmd[0] = 0x07;
+	ret =
+	    fts_writeU8UX(FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG,
+			  ADDR_GPIO_CONFIG_REG2, cmd, 1);
+	if (ret < OK) {
+		logError(1, "%s hold_m3: can not set gpio config ERROR %08X\n",
+			 tag, ret);
+		return ret;
+	}
+
+	cmd[0] = 0x30;
+	ret =
+	    fts_writeU8UX(FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG,
+			  ADDR_GPIO_CONFIG_REG0, cmd, 1);
+	if (ret < OK) {
+		logError(1, "%s hold_m3: can not set gpio config ERROR %08X\n",
+			 tag, ret);
+		return ret;
+	}
+
+	cmd[0] = SPI4_MASK;
+	ret =
+	    fts_writeU8UX(FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG, ADDR_ICR, cmd, 1);
+	if (ret < OK) {
+		logError(1, "%s hold_m3: can not set spi4 mode ERROR %08X\n",
+			 tag, ret);
+		return ret;
+	}
+	mdelay(1);
+#endif
+
+	return OK;
+}
+
+/**
+* Parse the raw data read from a FW file in order to fill properly the fields of a Firmware variable
+* @param fw_data raw FW data loaded from system
+* @param fw_size size of fw_data
+* @param fwData pointer to a Firmware variable which will contain the processed data
+* @param keep_cx if 1, the CX area will be loaded and burnt otherwise will be skipped and the area will be untouched
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int parseBinFile(u8 *fw_data, int fw_size, Firmware *fwData, int keep_cx)
+{
+
+	int dimension, index = 0;
+	u32 temp;
+	int res, i;
+
+	if (fw_size < FW_HEADER_SIZE + FW_BYTES_ALLIGN || fw_data == NULL) {
+		logError(1,
+			 "%s parseBinFile: Read only %d instead of %d... ERROR %08X\n",
+			 tag, fw_size, FW_HEADER_SIZE + FW_BYTES_ALLIGN,
+			 ERROR_FILE_PARSE);
+		res = ERROR_FILE_PARSE;
+		goto END;
+	} else {
+		u8ToU32(&fw_data[index], &temp);
+		if (temp != FW_HEADER_SIGNATURE) {
+			logError(1,
+				 "%s parseBinFile: Wrong Signature %08X ... ERROR %08X\n",
+				 tag, temp, ERROR_FILE_PARSE);
+			res = ERROR_FILE_PARSE;
+			goto END;
+		}
+		logError(0, "%s parseBinFile: Fw Signature OK!\n", tag);
+		index += FW_BYTES_ALLIGN;
+		u8ToU32(&fw_data[index], &temp);
+		if (temp != FW_FTB_VER) {
+			logError(1,
+				 "%s parseBinFile: Wrong ftb_version %08X ... ERROR %08X\n",
+				 tag, temp, ERROR_FILE_PARSE);
+			res = ERROR_FILE_PARSE;
+			goto END;
+		}
+		logError(0, "%s parseBinFile: ftb_version OK!\n", tag);
+		index += FW_BYTES_ALLIGN;
+		if (fw_data[index] != DCHIP_ID_0
+		    || fw_data[index + 1] != DCHIP_ID_1) {
+			logError(1,
+				 "%s parseBinFile: Wrong target %02X != %02X  %02X != %02X ... ERROR %08X\n",
+				 tag, fw_data[index], DCHIP_ID_0,
+				 fw_data[index + 1], DCHIP_ID_1,
+				 ERROR_FILE_PARSE);
+			res = ERROR_FILE_PARSE;
+			goto END;
+		}
+		index += FW_BYTES_ALLIGN;
+		u8ToU32(&fw_data[index], &temp);
+		logError(1, "%s parseBinFile: FILE SVN REV = %08X\n", tag,
+			 temp);
+
+		index += FW_BYTES_ALLIGN;
+		u8ToU32(&fw_data[index], &temp);
+		fwData->fw_ver = temp;
+		logError(1, "%s parseBinFile: FILE Fw Version = %04X\n", tag,
+			 fwData->fw_ver);
+
+		index += FW_BYTES_ALLIGN;
+		u8ToU32(&fw_data[index], &temp);
+		fwData->config_id = temp;
+		logError(1, "%s parseBinFile: FILE Config Project ID = %08X\n",
+			 tag, temp);
+
+		index += FW_BYTES_ALLIGN;
+		u8ToU32(&fw_data[index], &temp);
+		logError(1, "%s parseBinFile: FILE Config Version = %08X\n",
+			 tag, temp);
+
+		index += FW_BYTES_ALLIGN * 2;
+
+		index += FW_BYTES_ALLIGN;
+		logError(1, "%s parseBinFile: File External Release =  ", tag);
+		for (i = 0; i < EXTERNAL_RELEASE_INFO_SIZE; i++) {
+			fwData->externalRelease[i] = fw_data[index++];
+			logError(1, "%02X ", fwData->externalRelease[i]);
+		}
+		logError(1, "\n");
+
+		u8ToU32(&fw_data[index], &temp);
+		fwData->sec0_size = temp;
+		logError(1, "%s parseBinFile:  sec0_size = %08X (%d bytes)\n",
+			 tag, fwData->sec0_size, fwData->sec0_size);
+
+		index += FW_BYTES_ALLIGN;
+		u8ToU32(&fw_data[index], &temp);
+		fwData->sec1_size = temp;
+		logError(1, "%s parseBinFile:  sec1_size = %08X (%d bytes)\n",
+			 tag, fwData->sec1_size, fwData->sec1_size);
+
+		index += FW_BYTES_ALLIGN;
+		u8ToU32(&fw_data[index], &temp);
+		fwData->sec2_size = temp;
+		logError(1, "%s parseBinFile:  sec2_size = %08X (%d bytes) \n",
+			 tag, fwData->sec2_size, fwData->sec2_size);
+
+		index += FW_BYTES_ALLIGN;
+		u8ToU32(&fw_data[index], &temp);
+		fwData->sec3_size = temp;
+		logError(1, "%s parseBinFile:  sec3_size = %08X (%d bytes) \n",
+			 tag, fwData->sec3_size, fwData->sec3_size);
+
+		index += FW_BYTES_ALLIGN;
+
+		dimension =
+		    fwData->sec0_size + fwData->sec1_size + fwData->sec2_size +
+		    fwData->sec3_size;
+		temp = fw_size;
+
+		if (dimension + FW_HEADER_SIZE + FW_BYTES_ALLIGN != temp) {
+			logError(1,
+				 "%s parseBinFile: Read only %d instead of %d... ERROR %08X\n",
+				 tag, fw_size,
+				 dimension + FW_HEADER_SIZE + FW_BYTES_ALLIGN,
+				 ERROR_FILE_PARSE);
+			res = ERROR_FILE_PARSE;
+			goto END;
+		}
+
+		fwData->data =
+		    (u8 *) kmalloc(dimension * sizeof(u8), GFP_KERNEL);
+		if (fwData->data == NULL) {
+			logError(1, "%s parseBinFile: ERROR %08X\n", tag,
+				 ERROR_ALLOC);
+			res = ERROR_ALLOC;
+			goto END;
+		}
+
+		index += FW_BYTES_ALLIGN;
+		memcpy(fwData->data, &fw_data[index], dimension);
+		if (fwData->sec2_size != 0) {
+			u8ToU16(&fwData->data
+				[fwData->sec0_size + fwData->sec1_size +
+				 FW_CX_VERSION], &fwData->cx_ver);
+
+		} else {
+			logError(1,
+				 "%s parseBinFile: Initialize cx_ver to default value! \n",
+				 tag);
+			fwData->cx_ver = systemInfo.u16_cxVer;
+		}
+
+		logError(1, "%s parseBinFile: CX Version = %04X \n", tag,
+			 fwData->cx_ver);
+
+		fwData->data_size = dimension;
+
+		logError(0, "%s READ FW DONE %d bytes!\n", tag,
+			 fwData->data_size);
+		res = OK;
+		goto END;
+	}
+
+END:
+	kfree(fw_data);
+	return res;
+}
+
+/**
+  * Enable UVLO and Auto Power Down Mode
+  * @return OK if success or an error code which specify the type of error
+  */
+int flash_enable_uvlo_autopowerdown(void)
+{
+	u8 cmd[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00, FLASH_UVLO_ENABLE_CODE0,
+			FLASH_UVLO_ENABLE_CODE1 };
+	u8 cmd1[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00, FLASH_AUTOPOWERDOWN_ENABLE_CODE0,
+			FLASH_AUTOPOWERDOWN_ENABLE_CODE1 };
+	logError(0, "%s Command enable uvlo ...\n", tag);
+	if (fts_write_dma_safe(cmd, ARRAY_SIZE(cmd)) < OK) {
+		logError(1, "%s flash_enable_uvlo_autopowerdown: ERROR %08X\n", tag, ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+	if (fts_write_dma_safe(cmd1, ARRAY_SIZE(cmd1)) < OK) {
+		logError(1, "%s flash_enable_uvlo_autopowerdown: ERROR %08X\n", tag, ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+	logError(0, "%s Enable uvlo and flash auto power down  DONE!\n", tag);
+	return OK;
+}
+/**
+  * Unlock the flash to be programmed
+  * @return OK if success or an error code which specify the type of error
+  */
+int flash_unlock(void)
+{
+
+	u8 cmd[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00, FLASH_UNLOCK_CODE0,
+		      FLASH_UNLOCK_CODE1 };
+
+	u8 cmd1[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00, FLASH_UNLOCK_CODE2,
+		      FLASH_UNLOCK_CODE3 };
+
+	logError(0, "%s Command unlock ...\n", tag);
+	if (fts_write_dma_safe(cmd, ARRAY_SIZE(cmd)) < OK) {
+		logError(1, "%s flash_unlock: ERROR %08X\n", tag, ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	if (fts_write_dma_safe(cmd1, ARRAY_SIZE(cmd1)) < OK) {
+		logError(1, "%s Command unlock: ERROR %08X\n", tag, ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+	logError(0, "%s Unlock flash DONE!\n", tag);
+
+	return OK;
+
+}
+
+/**
+* Unlock the flash to be erased
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int flash_erase_unlock(void)
+{
+
+	u8 cmd[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00, FLASH_ERASE_UNLOCK_CODE0,
+		FLASH_ERASE_UNLOCK_CODE1
+	};
+
+	logError(0, "%s Try to erase unlock flash... \n", tag);
+
+	logError(0, "%s Command erase unlock ... \n", tag);
+	if (fts_write_dma_safe(cmd, ARRAY_SIZE(cmd)) < 0) {
+		logError(1, "%s flash_erase_unlock: ERROR %08X\n", tag,
+			 ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	logError(0, "%s Erase Unlock flash DONE! \n", tag);
+
+	return OK;
+
+}
+
+/**
+* Erase the full flash
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int flash_full_erase(void)
+{
+	int status;
+
+	u8 cmd1[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00, FLASH_ERASE_CODE0 + 1, 0x00 };
+	u8 cmd[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00, FLASH_ERASE_CODE0,
+		FLASH_ERASE_CODE1
+	};
+
+	if (fts_write_dma_safe(cmd1, ARRAY_SIZE(cmd1)) < OK) {
+		logError(1, "%s flash_erase_page_by_page: ERROR %08X\n", tag,
+			 ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	logError(0, "%s Command full erase sent ... \n", tag);
+	if (fts_write_dma_safe(cmd, ARRAY_SIZE(cmd)) < OK) {
+		logError(1, "%s flash_full_erase: ERROR %08X\n", tag,
+			 ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	status = wait_for_flash_ready(FLASH_ERASE_CODE0);
+
+	if (status != OK) {
+		logError(1, "%s flash_full_erase: ERROR %08X\n", tag,
+			 ERROR_FLASH_NOT_READY);
+		return (status | ERROR_FLASH_NOT_READY);
+	}
+
+	logError(0, "%s Full Erase flash DONE! \n", tag);
+
+	return OK;
+
+}
+
+/**
+* Erase the flash page by page, giving the possibility to skip the CX area and maintain therefore its value
+* @param keep_cx if SKIP_PANEL_INIT the Panel Init pages will be skipped, if > SKIP_PANEL_CX_INIT Cx and Panel Init pages otherwise all the pages will be deleted
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int flash_erase_page_by_page(ErasePage keep_cx)
+{
+
+	u8 status, i = 0;
+	u8 cmd1[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00, FLASH_ERASE_CODE0 + 1, 0x00 };
+	u8 cmd[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00, FLASH_ERASE_CODE0, 0xA0 };
+	u8 cmd2[9] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x01, 0x28, 0xFF, 0xFF, 0xFF, 0xFF };
+	u8 mask[4] = { 0 };
+
+	for (i = FLASH_CX_PAGE_START;
+	     i <= FLASH_CX_PAGE_END && keep_cx >= SKIP_PANEL_CX_INIT; i++) {
+		logError(0, "%s Skipping erase CX page %d! \n", tag, i);
+		fromIDtoMask(i, mask, 4);
+	}
+
+	for (i = FLASH_PANEL_PAGE_START;
+	     i <= FLASH_PANEL_PAGE_END && keep_cx >= SKIP_PANEL_INIT; i++) {
+		logError(0, "%s Skipping erase Panel Init page %d! \n", tag, i);
+		fromIDtoMask(i, mask, 4);
+	}
+
+	logError(0, "%s Setting the page mask = ", tag, i);
+	for (i = 0; i < 4; i++) {
+		cmd2[5 + i] = cmd2[5 + i] & (~mask[i]);
+		logError(0, "%02X ", cmd2[5 + i]);
+	}
+
+	logError(0, "\n%s Writing page mask... \n", tag);
+	if (fts_write_dma_safe(cmd2, ARRAY_SIZE(cmd2)) < OK) {
+		logError(1,
+			 "%s flash_erase_page_by_page: Page mask ERROR %08X\n",
+			 tag, ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	if (fts_write_dma_safe(cmd1, ARRAY_SIZE(cmd1)) < OK) {
+		logError(1,
+			 "%s flash_erase_page_by_page: Disable info ERROR %08X\n",
+			 tag, ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	logError(0, "%s Command erase pages sent ... \n", tag);
+	if (fts_write_dma_safe(cmd, ARRAY_SIZE(cmd)) < OK) {
+		logError(1, "%s flash_erase_page_by_page: Erase ERROR %08X\n",
+			 tag, ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	status = wait_for_flash_ready(FLASH_ERASE_CODE0);
+
+	if (status != OK) {
+
+		logError(1, "%s flash_erase_page_by_page: ERROR % 08X\n", tag,
+			 ERROR_FLASH_NOT_READY);
+		return (status | ERROR_FLASH_NOT_READY);
+	}
+
+	logError(0, "%s Erase flash page by page DONE! \n", tag);
+
+	return OK;
+}
+
+/**
+* Start the DMA procedure which actually transfer and burn the data loaded from memory into the Flash
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int start_flash_dma(void)
+{
+	int status;
+	u8 cmd[12] = { FLASH_CMD_WRITE_REGISTER, 0x20, 0x00, 0x00,
+		      0x6B, 0x00, 0x40, 0x42, 0x0F, 0x00, 0x00,	FLASH_DMA_CODE1 };
+
+
+	logError(0, "%s Command flash DMA ... \n", tag);
+	if (fts_write_dma_safe(cmd, ARRAY_SIZE(cmd)) < OK) {
+		logError(1, "%s start_flash_dma: ERROR %08X\n", tag,
+			 ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	status = wait_for_flash_ready(FLASH_DMA_CODE0);
+
+	if (status != OK) {
+		logError(1, "%s start_flash_dma: ERROR %08X\n", tag,
+			 ERROR_FLASH_NOT_READY);
+		return (status | ERROR_FLASH_NOT_READY);
+	}
+
+	logError(0, "%s flash DMA DONE! \n", tag);
+
+	return OK;
+}
+
+/**
+* Copy the FW data that should be burnt in the Flash into the memory and then the DMA will take care about burning it into the Flash
+* @param address address in memory where to copy the data, possible values are FLASH_ADDR_CODE, FLASH_ADDR_CONFIG, FLASH_ADDR_CX
+* @param data pointer to an array of byte which contain the data that should be copied into the memory
+* @param size size of data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int fillFlash(u32 address, u8 *data, int size)
+{
+	int remaining = size, index = 0;
+	int toWrite = 0;
+	int byteBlock = 0;
+	int wheel = 0;
+	u32 addr = 0;
+	int res;
+	int delta;
+	u8 *buff = NULL;
+	u8 buff2[12] = { 0 };
+
+	buff = (u8 *) kmalloc((DMA_CHUNK + 5) * sizeof(u8), GFP_KERNEL);
+	if (buff == NULL) {
+		logError(1, "%s fillFlash: ERROR %08X\n", tag, ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	while (remaining > 0) {
+		byteBlock = 0;
+
+		addr = 0x00100000;
+
+		while (byteBlock < FLASH_CHUNK && remaining > 0) {
+			index = 0;
+			if (remaining >= DMA_CHUNK) {
+				if ((byteBlock + DMA_CHUNK) <= FLASH_CHUNK) {
+					toWrite = DMA_CHUNK;
+					remaining -= DMA_CHUNK;
+					byteBlock += DMA_CHUNK;
+				} else {
+					delta = FLASH_CHUNK - byteBlock;
+					toWrite = delta;
+					remaining -= delta;
+					byteBlock += delta;
+				}
+			} else {
+				if ((byteBlock + remaining) <= FLASH_CHUNK) {
+					toWrite = remaining;
+					byteBlock += remaining;
+					remaining = 0;
+
+				} else {
+					delta = FLASH_CHUNK - byteBlock;
+					toWrite = delta;
+					remaining -= delta;
+					byteBlock += delta;
+				}
+			}
+
+			buff[index++] = FTS_CMD_HW_REG_W;
+			buff[index++] = (u8) ((addr & 0xFF000000) >> 24);
+			buff[index++] = (u8) ((addr & 0x00FF0000) >> 16);
+			buff[index++] = (u8) ((addr & 0x0000FF00) >> 8);
+			buff[index++] = (u8) (addr & 0x000000FF);
+
+			memcpy(&buff[index], data, toWrite);
+			if (fts_write_dma_safe(buff, index + toWrite) < OK) {
+				logError(1, "%s fillFlash: ERROR %08X\n", tag,
+					 ERROR_BUS_W);
+				kfree(buff);
+				return ERROR_BUS_W;
+			}
+			addr += toWrite;
+			data += toWrite;
+		}
+
+		byteBlock = byteBlock / 4 - 1;
+		index = 0;
+
+		buff2[index++] = FLASH_CMD_WRITE_REGISTER;
+		buff2[index++] = 0x20;
+		buff2[index++] = 0x00;
+		buff2[index++] = 0x00;
+		buff2[index++] = FLASH_DMA_CONFIG;
+		buff2[index++] = 0x00;
+		buff2[index++] = 0x00;
+
+		addr = address + ((wheel * FLASH_CHUNK) / 4);
+		buff2[index++] = (u8) ((addr & 0x000000FF));
+		buff2[index++] = (u8) ((addr & 0x0000FF00) >> 8);
+		buff2[index++] = (u8) (byteBlock & 0x000000FF);
+		buff2[index++] = (u8) ((byteBlock & 0x0000FF00) >> 8);
+		buff2[index++] = 0x00;
+
+		logError(0,
+			 "%s DMA Command = %02X , address = %02X %02X, words =  %02X %02X \n",
+			 tag, buff2[0], buff2[8], buff2[7], buff2[10],
+			 buff2[9]);
+
+		if (fts_write_dma_safe(buff2, index) < OK) {
+			logError(1,
+				 "%s   Error during filling Flash! ERROR %08X \n",
+				 tag, ERROR_BUS_W);
+			kfree(buff);
+			return ERROR_BUS_W;
+		}
+
+		res = start_flash_dma();
+		if (res < OK) {
+			logError(1,
+				 "%s   Error during flashing DMA! ERROR %08X \n",
+				 tag, res);
+			kfree(buff);
+			return res;
+		}
+		wheel++;
+	}
+	kfree(buff);
+	return OK;
+}
+
+/**
+* Execute the procedure to burn a FW in FTM4/FTI IC
+* @param fw structure which contain the FW to be burnt
+* @param force_burn if >0, the flashing procedure will be forced and executed regardless the additional info, otherwise the FW in the file will be burnt only if it is newer than the one running in the IC
+* @param keep_cx if 1, the function preserve the CX/Panel Init area otherwise will be cleared
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int flash_burn(Firmware fw, int force_burn, int keep_cx)
+{
+	int res;
+
+	if (!force_burn) {
+		if (systemInfo.u16_fwVer != fw.fw_ver)
+			goto start;
+		for (res = EXTERNAL_RELEASE_INFO_SIZE - 1; res >= 0; res--) {
+			if (fw.externalRelease[res] !=
+			    systemInfo.u8_releaseInfo[res])
+				goto start;
+		}
+		logError(1,
+			 "%s flash_burn: Firmware in the chip newer or equal to the one to burn! NO UPDATE ERROR %08X \n",
+			 tag, ERROR_FW_NO_UPDATE);
+		return (ERROR_FW_NO_UPDATE | ERROR_FLASH_BURN_FAILED);
+	} else {
+		if (force_burn == CRC_CX && fw.sec2_size == 0) {
+			for (res = EXTERNAL_RELEASE_INFO_SIZE - 1; res >= 0;
+			     res--) {
+				if (fw.externalRelease[res] >
+				    systemInfo.u8_releaseInfo[res])
+					force_burn = 0;
+				goto start;
+			}
+			logError(1,
+				 "%s flash_burn: CRC in CX but fw does not contain CX data! NO UPDATE ERROR %08X \n",
+				 tag, ERROR_FW_NO_UPDATE);
+			return (ERROR_FW_NO_UPDATE | ERROR_FLASH_BURN_FAILED);
+		}
+	}
+
+start:
+	logError(0, "%s Programming Procedure for flashing started: \n\n", tag);
+
+	logError(0, "%s 1) SYSTEM RESET: \n", tag);
+	res = fts_system_reset();
+	if (res < 0) {
+		logError(1, "%s    system reset FAILED!\n", tag);
+		if (res != (ERROR_SYSTEM_RESET_FAIL | ERROR_TIMEOUT))
+			return (res | ERROR_FLASH_BURN_FAILED);
+	} else
+		logError(0, "%s   system reset COMPLETED!\n\n", tag);
+	msleep(30); /* required by hw during flash procedure */
+	logError(0, "%s 2) HOLD M3 : \n", tag);
+	res = hold_m3();
+	if (res < OK) {
+		logError(1, "%s    hold_m3 FAILED!\n", tag);
+		return (res | ERROR_FLASH_BURN_FAILED);
+	} else
+		logError(0, "%s    hold_m3 COMPLETED!\n\n", tag);
+
+	logError(0, "%s 3) ENABLE UVLO AND AUTO POWER DOWN MODE :\n", tag);
+	res = flash_enable_uvlo_autopowerdown();
+	if (res < OK) {
+		logError(1, "%s    flash_enable_uvlo_autopowerdown FAILED!\n", tag);
+		return res | ERROR_FLASH_BURN_FAILED;
+	} else
+		logError(0, "%s    flash_enable_uvlo_autopowerdown COMPLETED!\n\n", tag);
+	logError(0, "%s 4) FLASH UNLOCK: \n", tag);
+	res = flash_unlock();
+	if (res < OK) {
+		logError(1, "%s   flash unlock FAILED! ERROR %08X\n", tag,
+			 ERROR_FLASH_BURN_FAILED);
+		return (res | ERROR_FLASH_BURN_FAILED);
+	} else {
+		logError(0, "%s   flash unlock COMPLETED!\n\n", tag);
+	}
+
+	logError(0, "%s 5) FLASH ERASE UNLOCK: \n", tag);
+	res = flash_erase_unlock();
+	if (res < 0) {
+		logError(1, "%s   flash unlock FAILED! ERROR %08X\n", tag,
+			 ERROR_FLASH_BURN_FAILED);
+		return (res | ERROR_FLASH_BURN_FAILED);
+	} else {
+		logError(0, "%s   flash unlock COMPLETED!\n\n", tag);
+	}
+
+	logError(0, "%s 6) FLASH ERASE: \n", tag);
+	if (keep_cx > 0) {
+		if (fw.sec2_size != 0 && force_burn == CRC_CX)
+			res = flash_erase_page_by_page(SKIP_PANEL_INIT);
+		else
+			res = flash_erase_page_by_page(SKIP_PANEL_CX_INIT);
+	} else {
+		res = flash_erase_page_by_page(SKIP_PANEL_INIT);
+		if (fw.sec2_size == 0)
+			logError(1,
+				 "%s WARNING!!! Erasing CX memory but no CX in fw file! touch will not work right after fw update! \n",
+				 tag);
+	}
+
+	if (res < OK) {
+		logError(1, "%s   flash erase FAILED! ERROR %08X\n", tag,
+			 ERROR_FLASH_BURN_FAILED);
+		return (res | ERROR_FLASH_BURN_FAILED);
+	} else {
+		logError(0, "%s   flash erase COMPLETED!\n\n", tag);
+	}
+
+	logError(0, "%s 7) LOAD PROGRAM: \n", tag);
+	res = fillFlash(FLASH_ADDR_CODE, &fw.data[0], fw.sec0_size);
+	if (res < OK) {
+		logError(1, "%s   load program ERROR %08X\n", tag,
+			 ERROR_FLASH_BURN_FAILED);
+		return (res | ERROR_FLASH_BURN_FAILED);
+	}
+	logError(1, "%s   load program DONE!\n", tag);
+
+	logError(0, "%s 8) LOAD CONFIG: \n", tag);
+	res =
+	    fillFlash(FLASH_ADDR_CONFIG, &(fw.data[fw.sec0_size]),
+		      fw.sec1_size);
+	if (res < OK) {
+		logError(1, "%s   load config ERROR %08X\n", tag,
+			 ERROR_FLASH_BURN_FAILED);
+		return (res | ERROR_FLASH_BURN_FAILED);
+	}
+	logError(1, "%s   load config DONE!\n", tag);
+
+	if (fw.sec2_size != 0) {
+		if ((force_burn == CRC_CX) || (keep_cx <= 0)) {
+			logError(0, "%s 8.1) LOAD CX: \n", tag);
+			res =
+			    fillFlash(FLASH_ADDR_CX,
+				      &(fw.data[fw.sec0_size + fw.sec1_size]),
+				      fw.sec2_size);
+			if (res < OK) {
+				logError(1, "%s   load cx ERROR %08X\n", tag,
+					 ERROR_FLASH_BURN_FAILED);
+				return (res | ERROR_FLASH_BURN_FAILED);
+			}
+			logError(1, "%s   load cx DONE!\n", tag);
+		}
+	}
+
+	logError(0, "%s   Flash burn COMPLETED!\n\n", tag);
+
+	logError(0, "%s 9) SYSTEM RESET: \n", tag);
+	res = fts_system_reset();
+	if (res < 0) {
+		logError(1, "%s    system reset FAILED! ERROR %08X\n", tag,
+			 ERROR_FLASH_BURN_FAILED);
+		return (res | ERROR_FLASH_BURN_FAILED);
+	}
+	logError(0, "%s   system reset COMPLETED!\n\n", tag);
+
+	logError(0, "%s 10) FINAL CHECK: \n", tag);
+	res = readSysInfo(0);
+	if (res < 0) {
+		logError(1,
+			 "%s flash_burn: Unable to retrieve Chip INFO! ERROR %08X\n",
+			 tag, ERROR_FLASH_BURN_FAILED);
+		return (res | ERROR_FLASH_BURN_FAILED);
+	}
+
+	for (res = 0; res < EXTERNAL_RELEASE_INFO_SIZE; res++) {
+		if (fw.externalRelease[res] != systemInfo.u8_releaseInfo[res]) {
+			logError(1,
+				 "%s  Firmware in the chip different from the one that was burn! \n",
+				 tag);
+			return ERROR_FLASH_BURN_FAILED;
+		}
+	}
+
+	logError(0, "%s   Final check OK! \n", tag);
+
+	return OK;
+}
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsFlash.h b/drivers/input/touchscreen/stfts/fts_lib/ftsFlash.h
new file mode 100644
index 000000000000..5a4c19221228
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsFlash.h
@@ -0,0 +1,100 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*               	FTS API for Flashing the IC							 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsFlash.h
+* \brief Contains all the definitions and structs to handle the FW update process
+*/
+
+#ifndef FTS_FLASH_H
+#define FTS_FLASH_H
+
+#include "ftsSoftware.h"
+
+/*Flash possible status*/
+#define FLASH_READY						0	/*value to indicate that the flash is ready*/
+#define FLASH_BUSY						1	/*value to indicate that the flash is busy*/
+#define FLASH_UNKNOWN					-1	/*value to indicate an unknown status of the flash*/
+
+#define FLASH_STATUS_BYTES				1	/*number of bytes to check for read the flash status*/
+
+/*Flash timing parameters*/
+#define FLASH_RETRY_COUNT				200	/*number of attemps to read the flash status*/
+#define FLASH_WAIT_BEFORE_RETRY         50	/*time to wait in ms between one status reading and another*/
+
+#ifdef FW_H_FILE
+#define PATH_FILE_FW			"NULL"
+#else
+#define PATH_FILE_FW			"st_fts.ftb"	/*new FW bin file name*/
+#endif
+
+#define FLASH_CHUNK			(64 * 1024)			/*Max number of bytes that the DMA can burn on the flash in one shot in FTI*/
+#define DMA_CHUNK			32				/*Max number of bytes that can be written in I2C to the DMA*/
+
+/**
+ * Define which kind of erase page by page should be performed
+ */
+typedef enum {
+	ERASE_ALL = 0,							/*erase all the pages*/
+	SKIP_PANEL_INIT = 1,					/*skip erase Panel Init Pages*/
+	SKIP_PANEL_CX_INIT = 2					/*skip erase Panel Init and CX Pages*/
+} ErasePage;
+
+/** @addtogroup fw_file
+ * @{
+ */
+
+/**
+* Struct which contains information and data of the FW that should be burnt into the IC
+*/
+typedef struct {
+	u8 *data;								/*pointer to an array of bytes which represent the FW data*/
+	u16 fw_ver;								/*FW version of the FW file*/
+	u16 config_id;							/*Config ID of the FW file*/
+	u16 cx_ver;								/*Cx version of the FW file*/
+	u8 externalRelease[EXTERNAL_RELEASE_INFO_SIZE];	/*External Release Info of the FW file*/
+	int data_size;							/*dimension of data (the actual data to be burnt)*/
+	u32 sec0_size;							/*dimension of section 0 (FW) in .ftb file*/
+	u32 sec1_size;							/*dimension of section 1 (Config) in .ftb file*/
+	u32 sec2_size;							/*dimension of section 2 (Cx) in .ftb file*/
+	u32 sec3_size;							/*dimension of section 3 (TBD) in .ftb file*/
+
+} Firmware;
+
+/** @}*/
+
+/** @addtogroup flash_command
+ * @{
+ */
+
+int wait_for_flash_ready(u8 type);
+int hold_m3(void);
+int flash_erase_unlock(void);
+int flash_full_erase(void);
+int flash_erase_page_by_page(ErasePage keep_cx);
+int start_flash_dma(void);
+int fillFlash(u32 address, u8 *data, int size);
+
+int flash_unlock(void);
+int getFirmwareVersion(u16 *fw_vers, u16 *config_id);
+int getFWdata(const char *pathToFile, u8 **data, int *size);
+int parseBinFile(u8 *fw_data, int fw_size, Firmware *fw, int keep_cx);
+int readFwFile(const char *path, Firmware *fw, int keep_cx);
+int flash_burn(Firmware fw, int force_burn, int keep_cx);
+int flashProcedure(const char *path, int force, int keep_cx);
+int flash_enable_uvlo_autopowerdown(void);
+#endif
+
+/** @}*/
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsFrame.c b/drivers/input/touchscreen/stfts/fts_lib/ftsFrame.c
new file mode 100644
index 000000000000..344bfa06cf2b
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsFrame.c
@@ -0,0 +1,398 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*                  FTS functions for getting frames						 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsFrame.c
+* \brief Contains all the functions to work with frames
+*/
+
+#include "ftsCompensation.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsFrame.h"
+#include "ftsHardware.h"
+#include "ftsIO.h"
+#include "ftsSoftware.h"
+#include "ftsTool.h"
+#include "ftsTime.h"
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/serio.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+
+extern SysInfo systemInfo;
+
+/**
+ * Read the channels lengths from the config memory
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int getChannelsLength(void)
+{
+	int ret;
+	u8 data[2];
+
+	if (data == NULL) {
+		logError(1, "%s getChannelsLength: ERROR %08X\n", tag,
+			 ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	ret = readConfig(ADDR_CONFIG_SENSE_LEN, data, 2);
+	if (ret < OK) {
+		logError(1, "%s getChannelsLength: ERROR %08X\n", tag, ret);
+
+		return ret;
+	}
+
+	systemInfo.u8_scrRxLen = (int)data[0];
+	systemInfo.u8_scrTxLen = (int)data[1];
+
+	logError(0, "%s Force_len = %d   Sense_Len = %d \n", tag,
+		 systemInfo.u8_scrTxLen, systemInfo.u8_scrRxLen);
+
+	return OK;
+}
+
+/**
+* Read and pack the frame data related to the nodes
+* @param address address in memory when the frame data node start
+* @param size amount of data to read
+* @param frame pointer to an array of bytes which will contain the frame node data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int getFrameData(u16 address, int size, short *frame)
+{
+	int i, j, ret;
+	u8 *data = (u8 *) kmalloc(size * sizeof(u8), GFP_KERNEL);
+	if (data == NULL) {
+		logError(1, "%s getFrameData: ERROR %08X\n", tag, ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	ret =
+	    fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, address, data,
+			      size, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		logError(1, "%s getFrameData: ERROR %08X\n", tag, ERROR_BUS_R);
+		kfree(data);
+		return ERROR_BUS_R;
+	}
+	j = 0;
+	for (i = 0; i < size; i += 2) {
+		frame[j] = (short)((data[i + 1] << 8) + data[i]);
+		j++;
+	}
+	kfree(data);
+	return OK;
+}
+
+/**
+ * Return the number of Sense Channels (Rx)
+ * @return number of Rx channels
+ */
+int getSenseLen(void)
+{
+	if (systemInfo.u8_scrRxLen == 0) {
+		getChannelsLength();
+	}
+	return systemInfo.u8_scrRxLen;
+}
+
+/**
+ * Return the number of Force Channels (Tx)
+ * @return number of Tx channels
+ */
+int getForceLen(void)
+{
+	if (systemInfo.u8_scrTxLen == 0) {
+		getChannelsLength();
+	}
+	return systemInfo.u8_scrTxLen;
+}
+
+/********************    New API     **************************/
+
+/**
+* Read a MS Frame from frame buffer memory
+* @param type type of MS frame to read
+* @param frame pointer to MutualSenseFrame variable which will contain the data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int getMSFrame3(MSFrameType type, MutualSenseFrame *frame)
+{
+	u16 offset;
+	int ret, force_len, sense_len;
+
+	force_len = getForceLen();
+	sense_len = getSenseLen();
+
+	frame->node_data = NULL;
+
+	logError(0, "%s %s: Starting to get frame %02X \n", tag, __func__,
+		 type);
+	switch (type) {
+	case MS_RAW:
+		offset = systemInfo.u16_msTchRawAddr;
+		goto LOAD_NORM;
+	case MS_FILTER:
+		offset = systemInfo.u16_msTchFilterAddr;
+
+		goto LOAD_NORM;
+	case MS_STRENGTH:
+		offset = systemInfo.u16_msTchStrenAddr;
+		goto LOAD_NORM;
+	case MS_BASELINE:
+		offset = systemInfo.u16_msTchBaselineAddr;
+LOAD_NORM:
+		if (force_len == 0 || sense_len == 0) {
+			logError(1,
+				 "%s %s: number of channels not initialized ERROR %08X\n",
+				 tag, __func__, ERROR_CH_LEN);
+			return (ERROR_CH_LEN | ERROR_GET_FRAME);
+		}
+
+		break;
+
+	case MS_KEY_RAW:
+		offset = systemInfo.u16_keyRawAddr;
+		goto LOAD_KEY;
+	case MS_KEY_FILTER:
+		offset = systemInfo.u16_keyFilterAddr;
+		goto LOAD_KEY;
+	case MS_KEY_STRENGTH:
+		offset = systemInfo.u16_keyStrenAddr;
+		goto LOAD_KEY;
+	case MS_KEY_BASELINE:
+		offset = systemInfo.u16_keyBaselineAddr;
+LOAD_KEY:
+		if (systemInfo.u8_keyLen == 0) {
+			logError(1,
+				 "%s %s: number of channels not initialized ERROR %08X\n",
+				 tag, __func__, ERROR_CH_LEN);
+			return (ERROR_CH_LEN | ERROR_GET_FRAME);
+		}
+		force_len = 1;
+		sense_len = systemInfo.u8_keyLen;
+		break;
+
+	case FRC_RAW:
+		offset = systemInfo.u16_frcRawAddr;
+		goto LOAD_FRC;
+	case FRC_FILTER:
+		offset = systemInfo.u16_frcFilterAddr;
+		goto LOAD_FRC;
+	case FRC_STRENGTH:
+		offset = systemInfo.u16_frcStrenAddr;
+		goto LOAD_FRC;
+	case FRC_BASELINE:
+		offset = systemInfo.u16_frcBaselineAddr;
+LOAD_FRC:
+		if (force_len == 0) {
+			logError(1,
+				 "%s %s: number of channels not initialized ERROR %08X\n",
+				 tag, __func__, ERROR_CH_LEN);
+			return (ERROR_CH_LEN | ERROR_GET_FRAME);
+		}
+		sense_len = 1;
+		break;
+	default:
+		logError(1, "%s %s: Invalid type ERROR %08X\n", tag, __func__,
+			 ERROR_OP_NOT_ALLOW | ERROR_GET_FRAME);
+		return ERROR_OP_NOT_ALLOW | ERROR_GET_FRAME;
+	}
+
+	frame->node_data_size = ((force_len) * sense_len);
+	frame->header.force_node = force_len;
+	frame->header.sense_node = sense_len;
+	frame->header.type = type;
+
+	logError(0, "%s %s: Force_len = %d Sense_len = %d Offset = %04X \n",
+		 tag, __func__, force_len, sense_len, offset);
+
+	frame->node_data =
+	    (short *)kmalloc(frame->node_data_size * sizeof(short), GFP_KERNEL);
+	if (frame->node_data == NULL) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__,
+			 ERROR_ALLOC | ERROR_GET_FRAME);
+		return ERROR_ALLOC | ERROR_GET_FRAME;
+	}
+
+	ret =
+	    getFrameData(offset, frame->node_data_size * BYTES_PER_NODE,
+			 (frame->node_data));
+	if (ret < OK) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__,
+			 ERROR_GET_FRAME_DATA);
+		kfree(frame->node_data);
+		frame->node_data = NULL;
+		return (ret | ERROR_GET_FRAME_DATA | ERROR_GET_FRAME);
+	}
+	logError(0, "%s Frame acquired! \n", tag);
+	return frame->node_data_size;
+
+}
+
+/**
+* Read a SS Frame from frame buffer
+* @param type type of SS frame to read
+* @param frame pointer to SelfSenseFrame variable which will contain the data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int getSSFrame3(SSFrameType type, SelfSenseFrame *frame)
+{
+	u16 offset_force, offset_sense;
+	int ret;
+
+	frame->force_data = NULL;
+	frame->sense_data = NULL;
+
+	frame->header.force_node = getForceLen();
+	frame->header.sense_node = getSenseLen();
+
+	if (frame->header.force_node == 0 || frame->header.sense_node == 0) {
+		logError(1,
+			 "%s %s: number of channels not initialized ERROR %08X\n",
+			 tag, __func__, ERROR_CH_LEN);
+		return (ERROR_CH_LEN | ERROR_GET_FRAME);
+	}
+
+	logError(0, "%s %s: Starting to get frame %02X \n", tag, __func__,
+		 type);
+	switch (type) {
+	case SS_RAW:
+		offset_force = systemInfo.u16_ssTchTxRawAddr;
+		offset_sense = systemInfo.u16_ssTchRxRawAddr;
+		break;
+	case SS_FILTER:
+		offset_force = systemInfo.u16_ssTchTxFilterAddr;
+		offset_sense = systemInfo.u16_ssTchRxFilterAddr;
+		break;
+	case SS_STRENGTH:
+		offset_force = systemInfo.u16_ssTchTxStrenAddr;
+		offset_sense = systemInfo.u16_ssTchRxStrenAddr;
+		break;
+	case SS_BASELINE:
+		offset_force = systemInfo.u16_ssTchTxBaselineAddr;
+		offset_sense = systemInfo.u16_ssTchRxBaselineAddr;
+		break;
+
+	case SS_HVR_RAW:
+		offset_force = systemInfo.u16_ssHvrTxRawAddr;
+		offset_sense = systemInfo.u16_ssHvrRxRawAddr;
+		break;
+	case SS_HVR_FILTER:
+		offset_force = systemInfo.u16_ssHvrTxFilterAddr;
+		offset_sense = systemInfo.u16_ssHvrRxFilterAddr;
+		break;
+	case SS_HVR_STRENGTH:
+		offset_force = systemInfo.u16_ssHvrTxStrenAddr;
+		offset_sense = systemInfo.u16_ssHvrRxStrenAddr;
+		break;
+	case SS_HVR_BASELINE:
+		offset_force = systemInfo.u16_ssHvrTxBaselineAddr;
+		offset_sense = systemInfo.u16_ssHvrRxBaselineAddr;
+		break;
+
+	case SS_PRX_RAW:
+		offset_force = systemInfo.u16_ssPrxTxRawAddr;
+		offset_sense = systemInfo.u16_ssPrxRxRawAddr;
+		break;
+	case SS_PRX_FILTER:
+		offset_force = systemInfo.u16_ssPrxTxFilterAddr;
+		offset_sense = systemInfo.u16_ssPrxRxFilterAddr;
+		break;
+	case SS_PRX_STRENGTH:
+		offset_force = systemInfo.u16_ssPrxTxStrenAddr;
+		offset_sense = systemInfo.u16_ssPrxRxStrenAddr;
+		break;
+	case SS_PRX_BASELINE:
+		offset_force = systemInfo.u16_ssPrxTxBaselineAddr;
+		offset_sense = systemInfo.u16_ssPrxRxBaselineAddr;
+		break;
+
+	default:
+		logError(1, "%s %s: Invalid type ERROR %08X\n", tag, __func__,
+			 ERROR_OP_NOT_ALLOW | ERROR_GET_FRAME);
+		return ERROR_OP_NOT_ALLOW | ERROR_GET_FRAME;
+	}
+
+	frame->header.type = type;
+
+	logError(0,
+		 "%s %s: Force_len = %d Sense_len = %d Offset_force = %04X Offset_sense = %04X \n",
+		 tag, __func__, frame->header.force_node,
+		 frame->header.sense_node, offset_force, offset_sense);
+
+	frame->force_data =
+	    (short *)kmalloc(frame->header.force_node * sizeof(short),
+			     GFP_KERNEL);
+	if (frame->force_data == NULL) {
+		logError(1, "%s %s: can not allocate force_data ERROR %08X\n",
+			 tag, __func__, ERROR_ALLOC | ERROR_GET_FRAME);
+		return ERROR_ALLOC | ERROR_GET_FRAME;
+	}
+
+	frame->sense_data =
+	    (short *)kmalloc(frame->header.sense_node * sizeof(short),
+			     GFP_KERNEL);
+	if (frame->sense_data == NULL) {
+		kfree(frame->force_data);
+		frame->force_data = NULL;
+		logError(1, "%s %s: can not allocate sense_data ERROR %08X\n",
+			 tag, __func__, ERROR_ALLOC | ERROR_GET_FRAME);
+		return ERROR_ALLOC | ERROR_GET_FRAME;
+	}
+
+	ret =
+	    getFrameData(offset_force,
+			 frame->header.force_node * BYTES_PER_NODE,
+			 (frame->force_data));
+	if (ret < OK) {
+		logError(1,
+			 "%s %s: error while reading force data ERROR %08X\n",
+			 tag, __func__, ERROR_GET_FRAME_DATA);
+		kfree(frame->force_data);
+		frame->force_data = NULL;
+		kfree(frame->sense_data);
+		frame->sense_data = NULL;
+		return (ret | ERROR_GET_FRAME_DATA | ERROR_GET_FRAME);
+	}
+
+	ret =
+	    getFrameData(offset_sense,
+			 frame->header.sense_node * BYTES_PER_NODE,
+			 (frame->sense_data));
+	if (ret < OK) {
+		logError(1,
+			 "%s %s: error while reading sense data ERROR %08X\n",
+			 tag, __func__, ERROR_GET_FRAME_DATA);
+		kfree(frame->force_data);
+		frame->force_data = NULL;
+		kfree(frame->sense_data);
+		frame->sense_data = NULL;
+		return (ret | ERROR_GET_FRAME_DATA | ERROR_GET_FRAME);
+	}
+
+	logError(0, "%s Frame acquired! \n", tag);
+	return frame->header.force_node + frame->header.sense_node;
+
+}
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsFrame.h b/drivers/input/touchscreen/stfts/fts_lib/ftsFrame.h
new file mode 100644
index 000000000000..94bf412d1793
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsFrame.h
@@ -0,0 +1,91 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*                  FTS functions for getting frames						 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsFrame.h
+* \brief Contains all the definitions and structs to work with frames
+*/
+
+#ifndef FTS_FRAME_H
+#define FTS_FRAME_H
+
+#include "ftsSoftware.h"
+
+/*Number of data bytes for each node */
+#define BYTES_PER_NODE							2	/*number of data bytes for each node*/
+
+#define RETRY_FRAME_DATA_READ					2	/*max number of attempts to read a frame*/
+
+/**
+* Possible types of MS frames
+*/
+typedef enum{
+	MS_RAW = 0,																	/*Mutual Sense Raw Frame*/
+	MS_FILTER = 1,																/*Mutual Sense Filtered Frame*/
+	MS_STRENGTH = 2,															/*Mutual Sense Strength Frame (Baseline-Raw)*/
+	MS_BASELINE = 3,															/*Mutual Sense Baseline Frame*/
+	MS_KEY_RAW = 4,																/*Mutual Sense Key Raw Frame*/
+	MS_KEY_FILTER = 5,															/*Mutual Sense Key Filter Frame*/
+	MS_KEY_STRENGTH = 6,														/*Mutual Sense Key Strength Frame (Baseline-Raw)*/
+	MS_KEY_BASELINE = 7,														/*Mutual Sense Key Baseline Frame*/
+	FRC_RAW = 8,																/*Force Raw Frame*/
+	FRC_FILTER = 9,																/*Force Filtered Frame*/
+	FRC_STRENGTH = 10,															/*Force Strength Frame (Baseline-Raw)*/
+	FRC_BASELINE = 11															/*Force Baseline Frame*/
+} MSFrameType;
+
+/**
+* Possible types of SS frames
+*/
+typedef enum{
+	SS_RAW = 0,																	/*Self Sense Raw Frame*/
+	SS_FILTER = 1,																/*Self Sense Filtered Frame*/
+	SS_STRENGTH = 2,															/*Self Sense Strength Frame (Baseline-Raw)*/
+	SS_BASELINE = 3,															/*Self Sense Baseline Frame*/
+	SS_HVR_RAW = 4,																/*Self Sense Hover Raw Frame*/
+	SS_HVR_FILTER = 5,															/*Self Sense Hover Filter Frame*/
+	SS_HVR_STRENGTH = 6,														/*Self Sense Hover Strength Frame (Baseline-Raw)*/
+	SS_HVR_BASELINE = 7,														/*Self Sense Hover Baseline Frame*/
+	SS_PRX_RAW = 8,																/*Self Sense Proximity Raw Frame*/
+	SS_PRX_FILTER = 9,															/*Self Sense Proximity Filtered Frame*/
+	SS_PRX_STRENGTH = 10,														/*Self Sense Proximity Strength Frame (Baseline-Raw)*/
+	SS_PRX_BASELINE = 11														/*Self Sense Proximity Baseline Frame*/
+} SSFrameType;
+
+/**
+* Struct which contains the data of a MS Frame
+*/
+typedef struct {
+	DataHeader header;	/*Header which contain basic info of the frame*/
+	short *node_data;	/*Data of the frame*/
+	int node_data_size;	/*Dimension of the data of the frame*/
+} MutualSenseFrame;
+
+/**
+* Struct which contains the data of a SS Frame
+*/
+typedef struct {
+	DataHeader header;	/*Header which contain basic info of the frame*/
+	short *force_data;	/*Force Channels Data*/
+	short *sense_data;	/*Sense Channels Data*/
+} SelfSenseFrame;
+
+int getChannelsLength(void);
+int getFrameData(u16 address, int size, short *frame);
+int getSenseLen(void);
+int getForceLen(void);
+int getMSFrame3(MSFrameType type, MutualSenseFrame *frame);
+int getSSFrame3(SSFrameType type, SelfSenseFrame *frame);
+#endif
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsGesture.c b/drivers/input/touchscreen/stfts/fts_lib/ftsGesture.c
new file mode 100644
index 000000000000..3a4e2a66bf9e
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsGesture.c
@@ -0,0 +1,349 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics 							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*                     FTS Gesture Utilities								 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsGesture.c
+* \brief Contains all the functions and variable to handle the Gesture Detection features
+*/
+
+#include "ftsSoftware.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsGesture.h"
+#include "ftsIO.h"
+#include "ftsTime.h"
+#include "ftsTool.h"
+
+static u8 gesture_mask[GESTURE_MASK_SIZE] = { 0 };
+u16 gesture_coordinates_x[GESTURE_MAX_COORDS_PAIRS_REPORT] = { 0 };
+u16 gesture_coordinates_y[GESTURE_MAX_COORDS_PAIRS_REPORT] = { 0 };
+int gesture_coords_reported = ERROR_OP_NOT_ALLOW;
+static u8 refreshGestureMask;
+struct mutex gestureMask_mutex;
+
+/**
+ * Update the gesture mask stored in the driver and have to be used in gesture mode
+ * @param mask pointer to a byte array which store the gesture mask update that want to be performed.
+ * @param size dimension in byte of mask. This size can be <= GESTURE_MASK_SIZE. If size < GESTURE_MASK_SIZE the bytes of mask are considering continuos and starting from the less significant byte.
+ * @param en 0 = enable the gestures set in mask, 1 = disable the gestures set in mask
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int updateGestureMask(u8 *mask, int size, int en)
+{
+	u8 temp;
+	int i;
+
+	if (mask != NULL) {
+		if (size <= GESTURE_MASK_SIZE) {
+			if (en == FEAT_ENABLE) {
+				mutex_lock(&gestureMask_mutex);
+				logError(0,
+					 "%s updateGestureMask: setting gesture mask to enable...\n",
+					 tag);
+				if (mask != NULL) {
+					for (i = 0; i < size; i++) {
+						gesture_mask[i] = gesture_mask[i] | mask[i];
+					}
+				}
+				refreshGestureMask = 1;
+				logError(0,
+					 "%s updateGestureMask: gesture mask to enable SET! \n",
+					 tag);
+				mutex_unlock(&gestureMask_mutex);
+				return OK;
+			}
+
+			else if (en == FEAT_DISABLE) {
+				mutex_lock(&gestureMask_mutex);
+				logError(0,
+					 "%s updateGestureMask: setting gesture mask to disable...\n",
+					 tag);
+				for (i = 0; i < size; i++) {
+					temp = gesture_mask[i] ^ mask[i];
+					gesture_mask[i] =
+					    temp & gesture_mask[i];
+				}
+				logError(0,
+					 "%s updateGestureMask: gesture mask to disable SET! \n",
+					 tag);
+				refreshGestureMask = 1;
+				mutex_unlock(&gestureMask_mutex);
+				return OK;
+			} else {
+				logError(1,
+					 "updateGestureMask: Enable parameter Invalid! %d != %d or %d ERROR %08X",
+					 tag, FEAT_DISABLE, FEAT_ENABLE,
+					 ERROR_OP_NOT_ALLOW);
+				return ERROR_OP_NOT_ALLOW;
+			}
+		} else {
+			logError(1,
+				 "%s updateGestureMask: Size not valid! %d > %d ERROR %08X \n",
+				 tag, size, GESTURE_MASK_SIZE);
+			return ERROR_OP_NOT_ALLOW;
+		}
+	} else {
+		logError(1, "%s updateGestureMask: Mask NULL! ERROR %08X \n",
+			 tag, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+}
+
+/**
+ * Enable in the FW the gesture mask to be used in gesture mode
+ * @param mask pointer to a byte array which store the gesture mask update that want to be sent to the FW, if NULL, will be used gesture_mask set previously without any changes.
+ * @param size dimension in byte of mask. This size can be <= GESTURE_MASK_SIZE. If size < GESTURE_MASK_SIZE the bytes of mask are considering continuos and starting from the less significant byte.
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int enableGesture(u8 *mask, int size)
+{
+	int i, res;
+
+	logError(0, "%s Trying to enable gesture... \n", tag);
+
+	if (size <= GESTURE_MASK_SIZE) {
+		mutex_lock(&gestureMask_mutex);
+		if (mask != NULL) {
+			for (i = 0; i < size; i++) {
+				gesture_mask[i] = gesture_mask[i] | mask[i];
+			}
+		}
+
+		res =
+		    setFeatures(FEAT_SEL_GESTURE, gesture_mask,
+				GESTURE_MASK_SIZE);
+		if (res < OK) {
+			logError(1, "%s enableGesture: ERROR %08X \n", tag,
+				 res);
+			goto END;
+		}
+
+		logError(0, "%s enableGesture DONE! \n", tag);
+		res = OK;
+
+END:
+		mutex_unlock(&gestureMask_mutex);
+		return res;
+	} else {
+		logError(1,
+			 "%s enableGesture: Size not valid! %d > %d ERROR %08X \n",
+			 tag, size, GESTURE_MASK_SIZE);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+}
+
+/**
+ * Disable in the FW the gesture mask to be used in gesture mode
+ * @param mask pointer to a byte array which store the gesture mask update that want to be sent to the FW, if NULL, all the gestures will be disabled.
+ * @param size dimension in byte of mask. This size can be <= GESTURE_MASK_SIZE. If size < GESTURE_MASK_SIZE the bytes of mask are considering continuos and starting from the less significant byte.
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int disableGesture(u8 *mask, int size)
+{
+	u8 temp;
+	int i, res;
+	u8 *pointer;
+
+	logError(0, "%s Trying to disable gesture... \n", tag);
+
+	if (size <= GESTURE_MASK_SIZE) {
+		mutex_lock(&gestureMask_mutex);
+		if (mask != NULL) {
+			for (i = 0; i < size; i++) {
+
+				temp = gesture_mask[i] ^ mask[i];
+				gesture_mask[i] = temp & gesture_mask[i];
+			}
+
+			pointer = gesture_mask;
+		} else {
+			i = 0;
+			pointer = (u8 *)&i;
+		}
+
+		res = setFeatures(FEAT_SEL_GESTURE, pointer, GESTURE_MASK_SIZE);
+		if (res < OK) {
+			logError(1, "%s disableGesture: ERROR %08X \n", tag,
+				 res);
+			goto END;
+		}
+
+		logError(0, "%s disableGesture DONE! \n", tag);
+
+		res = OK;
+
+END:
+		mutex_unlock(&gestureMask_mutex);
+		return res;
+	} else {
+		logError(1,
+			 "%s disableGesture: Size not valid! %d > %d ERROR %08X \n",
+			 tag, size, GESTURE_MASK_SIZE);
+		return ERROR_OP_NOT_ALLOW;
+	}
+}
+
+/**
+ * Perform all the steps required to put the chip in gesture mode
+ * @param reload if set to 1, before entering in gesture mode it will re-enable in the FW the last defined gesture mask
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int enterGestureMode(int reload)
+{
+	int res, ret;
+
+	res = fts_disableInterruptNoSync();
+	if (res < OK) {
+		logError(1, "%s enterGestureMode: ERROR %08X \n", tag,
+			 res | ERROR_DISABLE_INTER);
+		return res | ERROR_DISABLE_INTER;
+	}
+
+	if (reload == 1 || refreshGestureMask == 1) {
+
+		res = enableGesture(NULL, 0);
+		if (res < OK) {
+			logError(1,
+				 "%s enterGestureMode: enableGesture ERROR %08X \n",
+				 tag, res);
+			goto END;
+		}
+
+		refreshGestureMask = 0;
+	}
+
+	res = setScanMode(SCAN_MODE_LOW_POWER, 0);
+	if (res < OK) {
+		logError(1,
+			 "%s enterGestureMode: enter gesture mode ERROR %08X \n",
+			 tag, res);
+		goto END;
+	}
+
+	res = OK;
+END:
+	ret = fts_enableInterrupt();
+	if (ret < OK) {
+		logError(1,
+			 "%s enterGestureMode: fts_enableInterrupt ERROR %08X \n",
+			 tag, res | ERROR_ENABLE_INTER);
+		res |= ret | ERROR_ENABLE_INTER;
+	}
+
+	return res;
+}
+
+/**
+ * Check if one or more Gesture IDs are currently enabled in gesture_mask
+ * @return FEAT_ENABLE if one or more gesture ids are enabled, FEAT_DISABLE if all the gesture ids are currently disabled
+ */
+int isAnyGestureActive(void)
+{
+	int res = 0;
+
+	while (res < (GESTURE_MASK_SIZE - 1) && gesture_mask[res] == 0) {
+		res++;
+	}
+
+	if (gesture_mask[res] != 0) {
+		logError(0,
+			 "%s %s: Active Gestures Found! gesture_mask[%d] = %02X !\n",
+			 tag, __func__, res, gesture_mask[res]);
+		return FEAT_ENABLE;
+	} else {
+		logError(0, "%s %s: All Gestures Disabled!\n", tag, __func__);
+		return FEAT_DISABLE;
+	}
+}
+
+/**
+ * Read from the frame buffer the gesture coordinates pairs of the points draw by an user when a gesture is detected
+ * @param event pointer to a byte array which contains the gesture event reported by the fw when a gesture is detected
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int readGestureCoords(u8 *event)
+{
+	int i = 0;
+	u64 address = 0;
+	int res;
+
+	u8 val[GESTURE_MAX_COORDS_PAIRS_REPORT * 4];
+
+	if (event[0] == EVT_ID_USER_REPORT && event[1] == EVT_TYPE_USER_GESTURE) {
+		address = (event[4] << 8) | event[3];
+		gesture_coords_reported = event[5];
+		if (gesture_coords_reported > GESTURE_MAX_COORDS_PAIRS_REPORT) {
+			logError(1,
+				 "%s %s:  FW reported more than %d points for the gestures! Decreasing to %d \n",
+				 tag, __func__, gesture_coords_reported,
+				 GESTURE_MAX_COORDS_PAIRS_REPORT);
+			gesture_coords_reported =
+			    GESTURE_MAX_COORDS_PAIRS_REPORT;
+		}
+
+		logError(1, "%s %s: Offset: %08X , coords pairs = %d\n", tag,
+			 __func__, address, gesture_coords_reported);
+
+		res = fts_writeReadU8UX(FTS_CMD_FRAMEBUFFER_R, BITS_16, address, val, (gesture_coords_reported * 2 * 2), DUMMY_FRAMEBUFFER);
+		if (res < OK) {
+			logError(1,
+				 "%s %s: Cannot read the coordinates! ERROR %08X  \n",
+				 tag, __func__, res);
+			gesture_coords_reported = ERROR_OP_NOT_ALLOW;
+			return res;
+		}
+
+		for (i = 0; i < gesture_coords_reported; i++) {
+			gesture_coordinates_x[i] =
+			    (((u16) val[i * 2 + 1]) & 0x0F) << 8 |
+			    (((u16) val[i * 2]) & 0xFF);
+			gesture_coordinates_y[i] = (((u16)
+						     val[gesture_coords_reported
+							 * 2 + i * 2 +
+							 1]) & 0x0F) << 8 |
+			    (((u16)
+			      val[gesture_coords_reported * 2 + i * 2]) & 0xFF);
+		}
+
+		logError(1, "%s %s: Reading Gesture Coordinates DONE!  \n", tag,
+			 __func__);
+		return OK;
+
+	} else {
+		logError(1,
+			 "%s %s: The event passsed as argument is invalid! ERROR %08X  \n",
+			 tag, __func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+}
+
+/**
+ * Return the coordinates of the points stored during the last detected gesture
+ * @param x output parameter which will store the address of the array containing the x coordinates
+ * @param y output parameter which will store the address of the array containing the y coordinates
+ * @return the number of points (x,y) stored and therefore the size of the x and y array returned.
+ */
+int getGestureCoords(u16 **x, u16 **y)
+{
+	*x = gesture_coordinates_x;
+	*y = gesture_coordinates_y;
+	logError(1,
+		 "%s %s: Number of gesture coordinates pairs returned = %d  \n",
+		 tag, __func__, gesture_coords_reported);
+	return gesture_coords_reported;
+}
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsGesture.h b/drivers/input/touchscreen/stfts/fts_lib/ftsGesture.h
new file mode 100644
index 000000000000..226c3b0b1b60
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsGesture.h
@@ -0,0 +1,38 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics 							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*                     FTS Gesture Utilities								 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsGesture.h
+* \brief Contains all the macro and prototypes to handle the Gesture Detection features
+*/
+
+#ifndef FTS_GESTURE_H_
+#define FTS_GESTURE_H_
+
+#include "ftsHardware.h"
+
+#define	GESTURE_MASK_SIZE					4
+
+#define	GESTURE_MAX_COORDS_PAIRS_REPORT		100
+
+int updateGestureMask(u8 *mask, int size, int en);
+int disableGesture(u8 *mask, int size);
+int enableGesture(u8 *mask, int size);
+int enterGestureMode(int reload);
+int isAnyGestureActive(void);
+int readGestureCoords(u8 *event);
+int getGestureCoords(u16 **x, u16 **y);
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsHardware.h b/drivers/input/touchscreen/stfts/fts_lib/ftsHardware.h
new file mode 100644
index 000000000000..40c9e014cff7
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsHardware.h
@@ -0,0 +1,191 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*							HW related data								 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsHardware.h
+* \brief Contains all the definitions and information related to the IC from an hardware point of view
+*/
+
+#ifndef FTS_HARDWARE_H
+#define FTS_HARDWARE_H
+
+/*DIGITAL CHIP INFO*/
+#define DCHIP_ID_0								0x36				/*LSB chip ID for FTM5*/
+#define DCHIP_ID_1								0x39				/*MSB chip ID for FTM5*/
+
+#define DCHIP_FW_VER_BYTE						2					/*number of bytes of the fw versions*/
+
+/*CHUNKS*/
+#define READ_CHUNK								1024				/*chunk dimension of a single i2c read, max allowed value is 2kB*/
+#define WRITE_CHUNK								1024				/*chunk dimension of a single i2c write, max allowed value is 2kB*/
+#define MEMORY_CHUNK							1024				/*chunk dimenasion of a single i2c write on mem, max allowed value is 2kB*/
+
+/*PROTOCOL INFO*/
+#define I2C_INTERFACE		/*comment if the chip use SPI bus*/
+#ifdef I2C_INTERFACE
+#define I2C_SAD									0x49				/*slave address of the IC*/
+#else
+#define SPI4_WIRE													/*comment if the master is SPI3 wires (MOSI and MISO share same line)*/
+#define SPI_DELAY_CS							10					/*time in usec to wait before rising the CS*/
+#define SPI_CLOCK_FREQ							7000000				/*clock frequency in Hz of the SPI bus*/
+#endif
+
+#define IER_ENABLE								0x41				/*value to write in IER_ADDR to enable the interrupts*/
+#define IER_DISABLE								0x00				/*value to write in IER_ADDR to disable the interrupts*/
+
+/*FLASH COMMAND*/
+/** @defgroup flash_command Flash Commands
+ *	All the commands that works with the flash of the IC
+ *	@{
+ */
+#define FLASH_CMD_UNLOCK						0xF7
+
+#define FLASH_CMD_READ_REGISTER                 0xFA
+#define FLASH_CMD_WRITE_REGISTER				0xFA
+
+/*FLASH UNLOCK PARAMETER*/
+#define FLASH_UNLOCK_CODE0						0x25
+#define FLASH_UNLOCK_CODE1						0x20
+#define FLASH_UNLOCK_CODE2		0x6B
+#define FLASH_UNLOCK_CODE3		0x00
+
+#define FLASH_UVLO_ENABLE_CODE0		0x1B
+#define FLASH_UVLO_ENABLE_CODE1		0x66
+#define FLASH_AUTOPOWERDOWN_ENABLE_CODE0 0x68
+#define FLASH_AUTOPOWERDOWN_ENABLE_CODE1 0x13
+/*FLASH ERASE and DMA PARAMETER*/
+#define FLASH_ERASE_START						0x80
+#define FLASH_ERASE_CODE1                       0xC0
+#define FLASH_DMA_CODE1                         0xC0
+#define FLASH_ERASE_UNLOCK_CODE0				0xDE
+#define FLASH_ERASE_UNLOCK_CODE1				0x03
+#define FLASH_ERASE_CODE0                       0x6A
+#define FLASH_DMA_CODE0                      	0x71
+#define FLASH_DMA_CONFIG                        0x72
+#define FLASH_NUM_PAGE							32					/*number of pages in main flash*/
+
+#define FLASH_CX_PAGE_START						28					/*starting page which contain Cx data*/
+#define FLASH_CX_PAGE_END						30					/*last page which contain Cx data*/
+#define FLASH_PANEL_PAGE_START					26					/*starting page which contain Panel Init data*/
+#define FLASH_PANEL_PAGE_END					27					/*last page which contain Panel Init data*/
+
+/** @} */
+
+/*FLASH ADDRESS*/
+
+#define FLASH_ADDR_CODE							0x00000000			/*starting address (words) in the flash of the code in FTI*/
+#define FLASH_ADDR_CONFIG						0x00007C00			/*starting address (words) in the flash of the config in FTI*/
+#define FLASH_ADDR_CX							0x00007000			/*starting address (words) in the flash of the Init data in FTI*/
+
+/*SIZES FW, CODE, CONFIG, MEMH*/
+/** @defgroup fw_file FW file info
+ *	All the info related to the fw file
+ *	@{
+ */
+
+#define FW_HEADER_SIZE							64					/*dimension of the header of the .fts file*/
+#define FW_HEADER_SIGNATURE						0xAA55AA55			/*header signature*/
+#define FW_FTB_VER								0x00000001			/*.ftb version*/
+#define FW_BYTES_ALLIGN							4					/*allignment of the info*/
+#define FW_BIN_VER_OFFSET						16					/*offset of the fw version in the .ftb file*/
+#define FW_BIN_CONFIG_ID_OFFSET					20					/*offset of the config id in the .ftb file*/
+#define FW_CX_VERSION							(16 + 4)				/*offset of CX version in the sec2 of FW file*/
+
+/** @} */
+
+/*FIFO*/
+#define FIFO_EVENT_SIZE							8					/*number of bytes of one event*/
+#define FIFO_DEPTH								32					/*max number of events that the FIFO can collect before going in overflow in FTM5*/
+
+#ifdef I2C_INTERFACE
+#define FIFO_CMD_READALL						0x86				/*command to read all the events in the FIFO*/
+#else
+#define FIFO_CMD_READALL						0x87				/*command to read all the events in the FIFO*/
+#endif
+#define FIFO_CMD_READONE						FIFO_CMD_READALL	/*commad to read one event from FIFO*/
+
+/*OP CODES FOR MEMORY (based on protocol)*/
+#ifdef I2C_INTERFACE
+#define FTS_CMD_HW_REG_R						0xFA				/*command to read an hw register if FTI*/
+#define FTS_CMD_HW_REG_W						0xFA				/*command to write an hw register if FTI*/
+#define FTS_CMD_FRAMEBUFFER_R					0xA6				/*command to read the framebuffer if FTI*/
+#define FTS_CMD_CONFIG_R						0xA8				/*command to read the config memory if FTI*/
+#define FTS_CMD_CONFIG_W						0xA8				/*command to write the config memory if FTI*/
+#else
+#define FTS_CMD_HW_REG_R						0xFB				/*command to read an hw register if FTI*/
+#define FTS_CMD_HW_REG_W						0xFA				/*command to write an hw register if FTI*/
+#define FTS_CMD_FRAMEBUFFER_R					0xA7				/*command to read the framebuffer if FTI*/
+#define FTS_CMD_CONFIG_R						0xA9				/*command to read the config memory if FTI*/
+#define FTS_CMD_CONFIG_W						0xA8				/*command to write the config memory if FTI*/
+#endif
+
+/*DUMMY BYTES DATA*/
+
+#ifndef I2C_INTERFACE
+#define DUMMY_HW_REG							1					/*1 if the first byte read from HW register is dummy*/
+#define DUMMY_FRAMEBUFFER						1					/*1 if the first byte read from Frame buffer is dummy*/
+#define DUMMY_CONFIG							1					/*1 if the first byte read from Config Memory is dummy*/
+#define DUMMY_FIFO								1					/*1 if the first byte read from FIFO is dummy*/
+#else
+#define DUMMY_HW_REG							0					/*1 if the first byte read from HW register is dummy*/
+#define DUMMY_FRAMEBUFFER						0					/*1 if the first byte read from Frame buffer is dummy*/
+#define DUMMY_CONFIG							0					/*1 if the first byte read from Config Memory is dummy*/
+#define DUMMY_FIFO								0					/*1 if the first byte read from FIFO is dummy*/
+#endif
+
+/** @defgroup hw_adr HW Address
+ * @ingroup address
+ * Important addresses of hardware registers (and sometimes their important values)
+ * @{
+ */
+
+/*IMPORTANT HW ADDRESSES (u64)*/
+#define ADDR_FRAMEBUFFER			((u64)0x0000000000000000)			/*frame buffer address in memory*/
+#define ADDR_ERROR_DUMP				((u64)0x000000000000EF80)			/*start address dump error log*/
+
+/*SYSTEM RESET INFO*/
+#define ADDR_SYSTEM_RESET			((u64)0x0000000020000024)			/*address of System control register in FTI*/
+#define SYSTEM_RESET_VALUE						0x80				/*value to write in SYSTEM_RESET_ADDRESS to perform a system reset in FTM5*/
+
+/*REMAP REGISTER*/
+#define ADDR_BOOT_OPTION			((u64)0x0000000020000025)			/*address of Boot option register in SONIA*/
+
+/*INTERRUPT INFO*/
+#define ADDR_IER					((u64)0x0000000020000029)			/*address of the Interrupt enable register in FTMI*/
+
+/*Chip ID/Fw Version*/
+#define ADDR_DCHIP_ID				((u64)0x0000000020000000)			/*chip id address for FTI*/
+#define ADDR_DCHIP_FW_VER			((u64)0x0000000020000004)			/*fw version address for FTI*/
+
+/*INTERFACE REGISTER*/
+#define ADDR_ICR					((u64)0x000000002000002D)			/*address of Device control register to set the comunication protocol (SPI/I2C)*/
+#define SPI4_MASK					0x02							/*bit to set spi4*/
+
+/*CRC ADDR*/
+#define ADDR_CRC					((u64)0x0000000020000078)			/*address of the CRC control register in FTI*/
+#define CRC_MASK								0x03				/*bitmask which reveal if there is a CRC error in the flash*/
+
+#define ADDR_CONFIG_OFFSET			((u64)0x0000000000000000)			/*config address in memory if FTI*/
+
+#define ADDR_GPIO_INPUT				((u64)0x0000000020000030)			/*address of GPIO input register*/
+#define ADDR_GPIO_DIRECTION			((u64)0x0000000020000032)			/*address of GPIO direction register*/
+#define ADDR_GPIO_PULLUP			((u64)0x0000000020000034)			/*address of GPIO pullup register*/
+#define ADDR_GPIO_CONFIG_REG0		((u64)0x000000002000003D)			/*address of GPIO config register*/
+#define ADDR_GPIO_CONFIG_REG2		((u64)0x000000002000003F)			/*address of GPIO config register*/
+
+
+/**@}*/
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsIO.c b/drivers/input/touchscreen/stfts/fts_lib/ftsIO.c
new file mode 100644
index 000000000000..08ed56551e63
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsIO.c
@@ -0,0 +1,911 @@
+/*
+
+ **************************************************************************
+ **                        STMicroelectronics							 **
+ **************************************************************************
+ **                        marco.cali@st.com							 **
+ **************************************************************************
+ *                                                                        *
+ *                     I2C/SPI Communication							  *
+ *                                                                        *
+ **************************************************************************
+ **************************************************************************
+
+ */
+
+/*!
+* \file ftsIO.c
+* \brief Contains all the functions which handle with the I2C/SPI communication
+*/
+
+#include "ftsSoftware.h"
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/of_gpio.h>
+
+#ifdef I2C_INTERFACE
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+static u16 I2CSAD;
+#include <linux/spi/spidev.h>
+#endif
+
+static void *client;
+
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsHardware.h"
+#include "ftsIO.h"
+
+extern struct fts_ts_info *fts_info;
+static struct mutex rw_lock;
+static u8 *buf1;
+static u8 *buf2;
+
+
+/**
+* Initialize the static client variable of the fts_lib library in order to allow any i2c/spi transaction in the driver. (Must be called in the probe)
+* @param clt pointer to i2c_client or spi_device struct which identify the bus slave device
+* @return OK
+*/
+int openChannel(void *clt)
+{
+	client = clt;
+#ifdef I2C_INTERFACE
+	I2CSAD = ((struct i2c_client *)clt)->addr;
+	logError(0, "%s openChannel: SAD: %02X \n", tag, I2CSAD);
+#else
+	logError(1, "%s %s: spi_master: flags = %04X !\n", tag, __func__,
+		 ((struct spi_device *)client)->master->flags);
+	logError(1,
+		 "%s %s: spi_device: max_speed = %d chip select = %02X bits_per_words = %d mode = %04X !\n",
+		 tag, __func__, ((struct spi_device *)client)->max_speed_hz,
+		 ((struct spi_device *)client)->chip_select,
+		 ((struct spi_device *)client)->bits_per_word,
+		 ((struct spi_device *)client)->mode);
+	logError(1, "%s openChannel: completed! \n", tag);
+#endif
+	mutex_init(&rw_lock);
+
+	if (!buf1)
+		buf1 = (u8 *)kzalloc(PAGE_SIZE, GFP_ATOMIC);
+	if (!buf2)
+		buf2 = (u8 *)kzalloc(PAGE_SIZE, GFP_ATOMIC);
+	if (!buf1 || !buf2)
+		return ERROR_ALLOC;
+
+	return OK;
+}
+
+#ifdef I2C_INTERFACE
+/**
+* Change the I2C slave address which will be used during the transaction (For Debug Only)
+* @param sad new slave address id
+* @return OK
+*/
+int changeSAD(u8 sad)
+{
+	I2CSAD = sad;
+	return OK;
+}
+#endif
+
+/**
+* Retrieve the pointer to the device struct of the IC
+* @return a the device struct pointer if client was previously set or NULL in all the other cases
+*/
+struct device *getDev(void)
+{
+	if (client != NULL)
+		return &(getClient()->dev);
+	else
+		return NULL;
+}
+
+#ifdef I2C_INTERFACE
+/**
+* Retrieve the pointer of the i2c_client struct representing the IC as i2c slave
+* @return client if it was previously set or NULL in all the other cases
+*/
+struct i2c_client *getClient(void)
+{
+	if (client != NULL)
+		return (struct i2c_client *)client;
+	else
+		return NULL;
+}
+#else
+/**
+* Retrieve the pointer of the spi_device struct representing the IC as spi slave
+* @return client if it was previously set or NULL in all the other cases
+*/
+struct spi_device *getClient()
+{
+	if (client != NULL)
+		return (struct spi_device *)client;
+	else
+		return NULL;
+}
+#endif
+
+/****************** New I2C API *********************/
+
+/**
+* Perform a direct bus read
+* @param outBuf pointer of a byte array which should contain the byte read from the IC
+* @param byteToRead number of bytes to read
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int fts_read(u8 *outBuf, int byteToRead)
+{
+	int ret = -1;
+	int retry = 0;
+
+#ifdef I2C_INTERFACE
+	struct i2c_msg I2CMsg[1];
+
+	I2CMsg[0].addr = (__u16) I2CSAD;
+	I2CMsg[0].flags = (__u16) I2C_M_RD;
+	I2CMsg[0].len = (__u16) byteToRead;
+	I2CMsg[0].buf = (__u8 *) outBuf;
+#else
+	struct spi_message msg;
+	struct spi_transfer transfer[1] = { {0} };
+
+	spi_message_init(&msg);
+
+	transfer[0].len = byteToRead;
+	transfer[0].delay_usecs = SPI_DELAY_CS;
+	transfer[0].tx_buf = NULL;
+	transfer[0].rx_buf = outBuf;
+	spi_message_add_tail(&transfer[0], &msg);
+#endif
+
+	if (client == NULL)
+		return ERROR_BUS_O;
+	while (retry < I2C_RETRY && ret < OK) {
+
+#ifdef I2C_INTERFACE
+		ret = i2c_transfer(getClient()->adapter, I2CMsg, 1);
+#else
+		ret = spi_sync(getClient(), &msg);
+#endif
+
+		retry++;
+		if (ret < OK)
+			mdelay(I2C_WAIT_BEFORE_RETRY);
+	}
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__, ERROR_BUS_R);
+		return ERROR_BUS_R;
+	}
+	return OK;
+
+}
+
+/**
+* Perform a bus write followed by a bus read without a stop condition
+* @param cmd byte array containing the command to write
+* @param cmdLength size of cmd
+* @param outBuf pointer of a byte array which should contain the bytes read from the IC
+* @param byteToRead number of bytes to read
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int fts_writeRead(u8 *cmd, int cmdLength, u8 *outBuf, int byteToRead)
+{
+	int ret = -1;
+	int retry = 0;
+
+#ifdef I2C_INTERFACE
+	struct i2c_msg I2CMsg[2];
+
+	I2CMsg[0].addr = (__u16) I2CSAD;
+	I2CMsg[0].flags = (__u16) 0;
+	I2CMsg[0].len = (__u16) cmdLength;
+	I2CMsg[0].buf = (__u8 *) cmd;
+
+	I2CMsg[1].addr = (__u16) I2CSAD;
+	I2CMsg[1].flags = I2C_M_RD;
+	I2CMsg[1].len = byteToRead;
+	I2CMsg[1].buf = (__u8 *) outBuf;
+
+#else
+	struct spi_message msg;
+	struct spi_transfer transfer[2] = { {0}, {0} };
+
+	spi_message_init(&msg);
+
+	transfer[0].len = cmdLength;
+	transfer[0].tx_buf = cmd;
+	transfer[0].rx_buf = NULL;
+	spi_message_add_tail(&transfer[0], &msg);
+
+	transfer[1].len = byteToRead;
+	transfer[1].delay_usecs = SPI_DELAY_CS;
+	transfer[1].tx_buf = NULL;
+	transfer[1].rx_buf = outBuf;
+	spi_message_add_tail(&transfer[1], &msg);
+
+#endif
+
+	if (client == NULL)
+		return ERROR_BUS_O;
+
+	while (retry < I2C_RETRY && ret < OK) {
+#ifdef I2C_INTERFACE
+		ret = i2c_transfer(getClient()->adapter, I2CMsg, 2);
+#else
+		ret = spi_sync(getClient(), &msg);
+#endif
+
+		retry++;
+		if (ret < OK)
+			mdelay(I2C_WAIT_BEFORE_RETRY);
+	}
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__, ERROR_BUS_WR);
+		return ERROR_BUS_WR;
+	}
+	return OK;
+}
+
+/**
+* Perform a bus write
+* @param cmd byte array containing the command to write
+* @param cmdLength size of cmd
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int fts_write(u8 *cmd, int cmdLength)
+{
+	int ret = -1;
+	int retry = 0;
+
+#ifdef I2C_INTERFACE
+	struct i2c_msg I2CMsg[1];
+
+	I2CMsg[0].addr = (__u16) I2CSAD;
+	I2CMsg[0].flags = (__u16) 0;
+	I2CMsg[0].len = (__u16) cmdLength;
+	I2CMsg[0].buf = (__u8 *) cmd;
+#else
+	struct spi_message msg;
+	struct spi_transfer transfer[1] = { {0} };
+
+	spi_message_init(&msg);
+
+	transfer[0].len = cmdLength;
+	transfer[0].delay_usecs = SPI_DELAY_CS;
+	transfer[0].tx_buf = cmd;
+	transfer[0].rx_buf = NULL;
+	spi_message_add_tail(&transfer[0], &msg);
+#endif
+
+	if (client == NULL)
+		return ERROR_BUS_O;
+	while (retry < I2C_RETRY && ret < OK) {
+#ifdef I2C_INTERFACE
+		ret = i2c_transfer(getClient()->adapter, I2CMsg, 1);
+#else
+		ret = spi_sync(getClient(), &msg);
+#endif
+
+		retry++;
+		if (ret < OK)
+			mdelay(I2C_WAIT_BEFORE_RETRY);
+	}
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__, ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+	return OK;
+}
+#ifdef CONFIG_I2C_BY_DMA
+/**
+ * same as above but can be used when enable DMA.
+ */
+int fts_read_dma_safe(u8 *outBuf, int byteToRead)
+{
+
+	int ret;
+	struct fts_dma_buf *dma = fts_info->dma_buf;
+	u8 *malcBuf = dma->rdBuf;
+	u8 *tmpBuf = NULL;
+	u8 *finalBuf;
+
+	mutex_lock(&dma->dmaBufLock);
+	/*use malloc buf*/
+	if (byteToRead > 1) {
+		   /*extend malloc buf*/
+		if (unlikely(byteToRead > PAGE_SIZE)) {
+			tmpBuf = kzalloc(byteToRead, GFP_KERNEL);
+			if (!tmpBuf) {
+				logError(1, "%s %s:ERROR alloc mem failed!", tag, __func__);
+				mutex_unlock(&dma->dmaBufLock);
+				return ERROR_ALLOC;
+			}
+			finalBuf = tmpBuf;
+		} else {
+			finalBuf = malcBuf;
+		}
+	} else {
+		finalBuf = outBuf;
+	}
+
+	ret = fts_read(finalBuf, byteToRead);
+	if ((ret == OK) && (byteToRead > 1)) {
+		memcpy(outBuf, finalBuf, byteToRead);
+	}
+	if (unlikely(tmpBuf))
+		kfree(tmpBuf);
+	mutex_unlock(&dma->dmaBufLock);
+
+	return ret;
+}
+
+int fts_writeRead_dma_safe(u8 *cmd, int cmdLength, u8 *outBuf, int byteToRead)
+{
+	int ret;
+	struct fts_dma_buf *dma = fts_info->dma_buf;
+	u8 *malcRdBuf = dma->rdBuf;
+	u8 *malcWrBuf = dma->wrBuf;
+	u8 *rdBuf, *tmpRdBuf = NULL;
+	u8 *wrBuf, *tmpWrBuf = NULL;
+
+	mutex_lock(&dma->dmaBufLock);
+	if (cmdLength > 1) {
+		if (unlikely(cmdLength > PAGE_SIZE)) {
+			tmpWrBuf = kzalloc(cmdLength, GFP_KERNEL);
+			if (!tmpWrBuf) {
+				logError(1, "%s %s:ERROR alloc mem failed!", tag, __func__);
+				mutex_unlock(&dma->dmaBufLock);
+				return ERROR_ALLOC;
+			}
+			wrBuf = tmpWrBuf;
+		} else {
+			wrBuf = malcWrBuf;
+		}
+		memcpy(wrBuf, cmd, cmdLength);
+	} else {
+		wrBuf = cmd;
+	}
+
+	if (byteToRead > 1) {
+		if (unlikely(byteToRead > PAGE_SIZE)) {
+			tmpRdBuf = kzalloc(byteToRead, GFP_KERNEL);
+			if (!tmpRdBuf) {
+				logError(1, "%s %s:ERROR alloc mem failed!", tag, __func__);
+				if (tmpWrBuf)
+					kfree(tmpWrBuf);
+				mutex_unlock(&dma->dmaBufLock);
+				return ERROR_ALLOC;
+			}
+			rdBuf = tmpRdBuf;
+		} else {
+			rdBuf = malcRdBuf;
+		}
+	} else {
+		rdBuf = outBuf;
+	}
+
+	ret = fts_writeRead(wrBuf, cmdLength, rdBuf, byteToRead);
+	if ((ret == OK) && (byteToRead > 1))
+		memcpy(outBuf, rdBuf, byteToRead);
+
+	if (unlikely(tmpRdBuf))
+		kfree(tmpRdBuf);
+	if (unlikely(tmpWrBuf))
+		kfree(tmpWrBuf);
+	mutex_unlock(&dma->dmaBufLock);
+
+	return ret;
+}
+
+int fts_write_dma_safe(u8 *cmd, int cmdLength)
+{
+	int ret;
+	struct fts_dma_buf *dma = fts_info->dma_buf;
+	u8 *malcBuf = dma->wrBuf;
+	u8 *tmpBuf = NULL;
+	u8 *finalBuf;
+
+	mutex_lock(&dma->dmaBufLock);
+	/*use malloc buf*/
+	if (cmdLength > 1) {
+		/*extend malloc buf*/
+		if (unlikely(cmdLength > PAGE_SIZE)) {
+			tmpBuf = kzalloc(cmdLength, GFP_KERNEL);
+			if (!tmpBuf) {
+				logError(1, "%s %s:ERROR alloc mem failed!", tag, __func__);
+				mutex_unlock(&dma->dmaBufLock);
+				return ERROR_ALLOC;
+			}
+			finalBuf = tmpBuf;
+		} else {
+			finalBuf = malcBuf;
+		}
+		memcpy(finalBuf, cmd, cmdLength);
+	} else {
+		finalBuf = cmd;
+	}
+
+	ret = fts_write(finalBuf, cmdLength);
+
+	if (unlikely(tmpBuf))
+		kfree(tmpBuf);
+	mutex_unlock(&dma->dmaBufLock);
+
+
+	return ret;
+}
+#else
+int fts_read_dma_safe(u8 *outBuf, int byteToRead)
+{
+	return fts_read(outBuf, byteToRead);
+}
+int fts_writeRead_dma_safe(u8 *cmd, int cmdLength, u8 *outBuf, int byteToRead)
+{
+	return fts_writeRead(cmd, cmdLength, outBuf, byteToRead);
+}
+int fts_write_dma_safe(u8 *cmd, int cmdLength)
+{
+	return fts_write(cmd, cmdLength);
+}
+#endif
+
+/**
+* Write a FW command to the IC and check automatically the echo event
+* @param cmd byte array containing the command to send
+* @param cmdLength size of cmd
+* @return OK if success, or an error code which specify the type of error encountered
+*/
+int fts_writeFwCmd(u8 *cmd, int cmdLength)
+{
+	int ret = -1;
+	int ret2 = -1;
+	int retry = 0;
+#ifdef I2C_INTERFACE
+	struct i2c_msg I2CMsg[1];
+
+	I2CMsg[0].addr = (__u16) I2CSAD;
+	I2CMsg[0].flags = (__u16) 0;
+	I2CMsg[0].len = (__u16) cmdLength;
+	I2CMsg[0].buf = (__u8 *) cmd;
+#else
+	struct spi_message msg;
+	struct spi_transfer transfer[1] = { {0} };
+
+	spi_message_init(&msg);
+
+	transfer[0].len = cmdLength;
+	transfer[0].delay_usecs = SPI_DELAY_CS;
+	transfer[0].tx_buf = cmd;
+	transfer[0].rx_buf = NULL;
+	spi_message_add_tail(&transfer[0], &msg);
+#endif
+
+	if (client == NULL)
+		return ERROR_BUS_O;
+	resetErrorList();
+	while (retry < I2C_RETRY && (ret < OK || ret2 < OK)) {
+#ifdef I2C_INTERFACE
+		ret = i2c_transfer(getClient()->adapter, I2CMsg, 1);
+#else
+		ret = spi_sync(getClient(), &msg);
+#endif
+		retry++;
+		if (ret >= 0)
+			ret2 = checkEcho(cmd, cmdLength);
+		if (ret < OK || ret2 < OK)
+			mdelay(I2C_WAIT_BEFORE_RETRY);
+	}
+	if (ret < 0) {
+		logError(1, "%s fts_writeFwCmd: ERROR %08X\n", tag,
+			 ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+	if (ret2 < OK) {
+		logError(1, "%s fts_writeFwCmd: check echo ERROR %08X\n", tag,
+			 ret2);
+		return ret2;
+	}
+	return OK;
+}
+
+/**
+* Perform two bus write and one bus read without any stop condition
+* In case of FTI this function is not supported and the same sequence can be achieved calling fts_write followed by an fts_writeRead.
+* @param writeCmd1 byte array containing the first command to write
+* @param writeCmdLength size of writeCmd1
+* @param readCmd1 byte array containing the second command to write
+* @param readCmdLength size of readCmd1
+* @param outBuf pointer of a byte array which should contain the bytes read from the IC
+* @param byteToRead number of bytes to read
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int fts_writeThenWriteRead(u8 *writeCmd1, int writeCmdLength, u8 *readCmd1,
+			   int readCmdLength, u8 *outBuf, int byteToRead)
+{
+	int ret = -1;
+	int retry = 0;
+
+#ifdef I2C_INTERFACE
+	struct i2c_msg I2CMsg[3];
+
+	I2CMsg[0].addr = (__u16) I2CSAD;
+	I2CMsg[0].flags = (__u16) 0;
+	I2CMsg[0].len = (__u16) writeCmdLength;
+	I2CMsg[0].buf = (__u8 *) writeCmd1;
+
+	I2CMsg[1].addr = (__u16) I2CSAD;
+	I2CMsg[1].flags = (__u16) 0;
+	I2CMsg[1].len = (__u16) readCmdLength;
+	I2CMsg[1].buf = (__u8 *) readCmd1;
+
+	I2CMsg[2].addr = (__u16) I2CSAD;
+	I2CMsg[2].flags = I2C_M_RD;
+	I2CMsg[2].len = byteToRead;
+	I2CMsg[2].buf = (__u8 *) outBuf;
+#else
+	struct spi_message msg;
+	struct spi_transfer transfer[3] = { {0}, {0}, {0} };
+
+	spi_message_init(&msg);
+
+	transfer[0].len = writeCmdLength;
+	transfer[0].tx_buf = writeCmd1;
+	transfer[0].rx_buf = NULL;
+	spi_message_add_tail(&transfer[0], &msg);
+
+	transfer[1].len = readCmdLength;
+	transfer[1].tx_buf = readCmd1;
+	transfer[1].rx_buf = NULL;
+	spi_message_add_tail(&transfer[1], &msg);
+
+	transfer[2].len = byteToRead;
+	transfer[2].delay_usecs = SPI_DELAY_CS;
+	transfer[2].tx_buf = NULL;
+	transfer[2].rx_buf = outBuf;
+	spi_message_add_tail(&transfer[2], &msg);
+#endif
+
+	if (client == NULL)
+		return ERROR_BUS_O;
+	while (retry < I2C_RETRY && ret < OK) {
+#ifdef I2C_INTERFACE
+		ret = i2c_transfer(getClient()->adapter, I2CMsg, 3);
+#else
+		ret = spi_sync(getClient(), &msg);
+#endif
+		retry++;
+		if (ret < OK)
+			mdelay(I2C_WAIT_BEFORE_RETRY);
+	}
+
+	if (ret < 0) {
+		logError(1, "%s %s: ERROR %08X\n", tag, __func__, ERROR_BUS_WR);
+		return ERROR_BUS_WR;
+	}
+	return OK;
+
+}
+
+/**
+* Perform a chunked write with one byte op code and 1 to 8 bytes address
+* @param cmd byte containing the op code to write
+* @param addrSize address size in byte
+* @param address the starting address
+* @param data pointer of a byte array which contain the bytes to write
+* @param dataSize size of data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+/* this function works only if the address is max 8 bytes */
+int fts_writeU8UX(u8 cmd, AddrSize addrSize, u64 address, u8 *data,
+		  int dataSize)
+{
+
+	u8 *finalCmd = buf1;
+	int remaining = dataSize;
+	int toWrite = 0, i = 0;
+
+	mutex_lock(&rw_lock);
+	if (addrSize <= sizeof(u64)) {
+
+		while (remaining > 0) {
+			if (remaining >= WRITE_CHUNK) {
+				toWrite = WRITE_CHUNK;
+				remaining -= WRITE_CHUNK;
+			} else {
+				toWrite = remaining;
+				remaining = 0;
+			}
+
+			finalCmd[0] = cmd;
+			logError(0, "%s %s: addrSize = %d \n", tag, __func__,
+				 addrSize);
+			for (i = 0; i < addrSize; i++) {
+				finalCmd[i + 1] =
+				    (u8) ((address >> ((addrSize - 1 - i) * 8))
+					  & 0xFF);
+				logError(1, "%s %s: cmd[%d] = %02X \n", tag,
+					 __func__, i + 1, finalCmd[i + 1]);
+			}
+
+			memcpy(&finalCmd[addrSize + 1], data, toWrite);
+
+			if (fts_write(finalCmd, 1 + addrSize + toWrite) < OK) {
+				logError(1, "%s %s: ERROR %08X \n", tag,
+					 __func__, ERROR_BUS_W);
+				mutex_unlock(&rw_lock);
+				return ERROR_BUS_W;
+			}
+
+			address += toWrite;
+
+			data += toWrite;
+		}
+	} else {
+		logError(1,
+			 "%s %s: address size bigger than max allowed %d... ERROR %08X \n",
+			 tag, __func__, sizeof(u64), ERROR_OP_NOT_ALLOW);
+	}
+	mutex_unlock(&rw_lock);
+
+	return OK;
+}
+
+/**
+* Perform a chunked write read with one byte op code and 1 to 8 bytes address and dummy byte support.
+* @param cmd byte containing the op code to write
+* @param addrSize address size in byte
+* @param address the starting address
+* @param outBuf pointer of a byte array which contain the bytes to read
+* @param byteToRead number of bytes to read
+* @param hasDummyByte  if the first byte of each reading is dummy (must be skipped) set to 1, otherwise if it is valid set to 0 (or any other value)
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int fts_writeReadU8UX(u8 cmd, AddrSize addrSize, u64 address, u8 *outBuf,
+		      int byteToRead, int hasDummyByte)
+{
+	u8 *finalCmd = buf1;
+	u8 *buff = buf2;
+	int remaining = byteToRead;
+	int toRead = 0, i = 0;
+
+	mutex_lock(&rw_lock);
+	while (remaining > 0) {
+		if (remaining >= READ_CHUNK) {
+			toRead = READ_CHUNK;
+			remaining -= READ_CHUNK;
+		} else {
+			toRead = remaining;
+			remaining = 0;
+		}
+
+		finalCmd[0] = cmd;
+		for (i = 0; i < addrSize; i++) {
+			finalCmd[i + 1] =
+			    (u8) ((address >> ((addrSize - 1 - i) * 8)) & 0xFF);
+		}
+
+		if (hasDummyByte == 1) {
+			if (fts_writeRead
+			    (finalCmd, 1 + addrSize, buff, toRead + 1) < OK) {
+				logError(1,
+					 "%s %s: read error... ERROR %08X \n",
+					 tag, __func__, ERROR_BUS_WR);
+				mutex_unlock(&rw_lock);
+				return ERROR_BUS_WR;
+			}
+			memcpy(outBuf, buff + 1, toRead);
+		} else {
+			if (fts_writeRead(finalCmd, 1 + addrSize, buff, toRead)
+			    < OK) {
+				logError(1,
+					 "%s %s: read error... ERROR %08X \n",
+					 tag, __func__, ERROR_BUS_WR);
+				mutex_unlock(&rw_lock);
+				return ERROR_BUS_WR;
+			}
+			memcpy(outBuf, buff, toRead);
+		}
+
+		address += toRead;
+
+		outBuf += toRead;
+	}
+
+	mutex_unlock(&rw_lock);
+
+	return OK;
+}
+
+/**
+* Perform a chunked write followed by a second write with one byte op code  for each write and 1 to 8 bytes address (the sum of the 2 address size of the two writes can not exceed 8 bytes)
+* @param cmd1 byte containing the op code of first write
+* @param addrSize1 address size in byte of first write
+* @param cmd2 byte containing the op code of second write
+* @param addrSize2 address size in byte of second write
+* @param address the starting address
+* @param data pointer of a byte array which contain the bytes to write
+* @param dataSize size of data
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int fts_writeU8UXthenWriteU8UX(u8 cmd1, AddrSize addrSize1, u8 cmd2,
+			       AddrSize addrSize2, u64 address, u8 *data,
+			       int dataSize)
+{
+	u8 *finalCmd1 = NULL;
+	u8 *finalCmd2 = buf1;
+	int remaining = dataSize;
+	int toWrite = 0, i = 0, ret = OK;
+
+	mutex_lock(&rw_lock);
+	finalCmd1 = (u8 *)kzalloc(sizeof(u8) * 10, GFP_KERNEL);
+	if (!finalCmd1) {
+		ret =  ERROR_ALLOC;
+		goto end;
+	}
+
+	while (remaining > 0) {
+		if (remaining >= WRITE_CHUNK) {
+			toWrite = WRITE_CHUNK;
+			remaining -= WRITE_CHUNK;
+		} else {
+			toWrite = remaining;
+			remaining = 0;
+		}
+
+		finalCmd1[0] = cmd1;
+		for (i = 0; i < addrSize1; i++) {
+			finalCmd1[i + 1] =
+			    (u8) ((address >>
+				   ((addrSize1 + addrSize2 - 1 -
+				     i) * 8)) & 0xFF);
+		}
+
+		finalCmd2[0] = cmd2;
+		for (i = addrSize1; i < addrSize1 + addrSize2; i++) {
+			finalCmd2[i - addrSize1 + 1] =
+			    (u8) ((address >>
+				   ((addrSize1 + addrSize2 - 1 -
+				     i) * 8)) & 0xFF);
+		}
+
+		memcpy(&finalCmd2[addrSize2 + 1], data, toWrite);
+
+		if (fts_write(finalCmd1, 1 + addrSize1) < OK) {
+			logError(1, "%s %s: first write error... ERROR %08X \n",
+				 tag, __func__, ERROR_BUS_W);
+			ret = ERROR_BUS_W;
+			goto end;
+		}
+
+		if (fts_write(finalCmd2, 1 + addrSize2 + toWrite) < OK) {
+			logError(1,
+				 "%s %s: second write error... ERROR %08X \n",
+				 tag, __func__, ERROR_BUS_W);
+			ret = ERROR_BUS_W;
+			goto end;
+		}
+
+		address += toWrite;
+
+		data += toWrite;
+	}
+
+end:
+	if (finalCmd1)
+		kfree(finalCmd1);
+	mutex_unlock(&rw_lock);
+
+	return ret;
+}
+
+/**
+* Perform a chunked write  followed by a write read with one byte op code and 1 to 8 bytes address for each write and dummy byte support.
+* @param cmd1 byte containing the op code of first write
+* @param addrSize1 address size in byte of first write
+* @param cmd2 byte containing the op code of second write read
+* @param addrSize2 address size in byte of second write	read
+* @param address the starting address
+* @param outBuf pointer of a byte array which contain the bytes to read
+* @param byteToRead number of bytes to read
+* @param hasDummyByte  if the first byte of each reading is dummy (must be skipped) set to 1, otherwise if it is valid set to 0 (or any other value)
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int fts_writeU8UXthenWriteReadU8UX(u8 cmd1, AddrSize addrSize1, u8 cmd2,
+				   AddrSize addrSize2, u64 address, u8 *outBuf,
+				   int byteToRead, int hasDummyByte)
+{
+	u8 *finalCmd1 = NULL;
+	u8 *finalCmd2 = NULL;
+	u8 *buff = buf1;
+	int remaining = byteToRead;
+	int toRead = 0, i = 0, ret = OK;
+
+	mutex_lock(&rw_lock);
+	finalCmd1 = (u8 *)kzalloc(sizeof(u8) * 10, GFP_KERNEL);
+	if (!finalCmd1) {
+		ret =  ERROR_ALLOC;
+		goto end;
+	}
+	finalCmd2 = (u8 *)kzalloc(sizeof(u8) * 10, GFP_KERNEL);
+	if (!finalCmd2) {
+		ret =  ERROR_ALLOC;
+		goto end;
+	}
+
+	while (remaining > 0) {
+		if (remaining >= READ_CHUNK) {
+			toRead = READ_CHUNK;
+			remaining -= READ_CHUNK;
+		} else {
+			toRead = remaining;
+			remaining = 0;
+		}
+
+		finalCmd1[0] = cmd1;
+		for (i = 0; i < addrSize1; i++) {
+			finalCmd1[i + 1] =
+			    (u8) ((address >>
+				   ((addrSize1 + addrSize2 - 1 -
+				     i) * 8)) & 0xFF);
+		}
+
+		finalCmd2[0] = cmd2;
+		for (i = addrSize1; i < addrSize1 + addrSize2; i++) {
+			finalCmd2[i - addrSize1 + 1] =
+			    (u8) ((address >>
+				   ((addrSize1 + addrSize2 - 1 -
+				     i) * 8)) & 0xFF);
+		}
+
+		if (fts_write(finalCmd1, 1 + addrSize1) < OK) {
+			logError(1, "%s %s: first write error... ERROR %08X \n",
+				 tag, __func__, ERROR_BUS_W);
+			ret = ERROR_BUS_W;
+			goto end;
+		}
+
+		if (hasDummyByte == 1) {
+			if (fts_writeRead
+			    (finalCmd2, 1 + addrSize2, buff, toRead + 1) < OK) {
+				logError(1,
+					 "%s %s: read error... ERROR %08X \n",
+					 tag, __func__, ERROR_BUS_WR);
+				ret = ERROR_BUS_WR;
+				goto end;
+			}
+			memcpy(outBuf, buff + 1, toRead);
+		} else {
+			if (fts_writeRead
+			    (finalCmd2, 1 + addrSize2, buff, toRead) < OK) {
+				logError(1,
+					 "%s %s: read error... ERROR %08X \n",
+					 tag, __func__, ERROR_BUS_WR);
+				ret = ERROR_BUS_WR;
+				goto end;
+			}
+			memcpy(outBuf, buff, toRead);
+		}
+
+		address += toRead;
+
+		outBuf += toRead;
+	}
+
+end:
+	if (finalCmd1)
+		kfree(finalCmd1);
+	if (finalCmd2)
+		kfree(finalCmd2);
+	mutex_unlock(&rw_lock);
+	return ret;
+}
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsIO.h b/drivers/input/touchscreen/stfts/fts_lib/ftsIO.h
new file mode 100644
index 000000000000..954c2f5148de
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsIO.h
@@ -0,0 +1,59 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*                     I2C/SPI Communication								 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+/*!
+* \file ftsIO.h
+* \brief Contains all the definitions and prototypes used and implemented in ftsIO.c
+*/
+
+#ifndef FTS_IO_H
+#define FTS_IO_H
+
+#include "ftsSoftware.h"
+
+#define I2C_RETRY					3
+#define I2C_WAIT_BEFORE_RETRY		2
+
+#ifdef I2C_INTERFACE
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+struct i2c_client *getClient(void);
+#else
+#include <linux/spi/spi.h>
+struct spi_device *getClient(void);
+#endif
+
+
+
+int openChannel(void *clt);
+struct device *getDev(void);
+
+
+
+/*************** NEW I2C API ****************/
+int changeSAD(u8 sad);
+int fts_read(u8 *outBuf, int byteToRead);
+int fts_writeRead(u8 *cmd, int cmdLength, u8 *outBuf, int byteToRead);
+int fts_write(u8 *cmd, int cmdLength);
+int fts_read_dma_safe(u8 *outBuf, int byteToRead);
+int fts_writeRead_dma_safe(u8 *cmd, int cmdLength, u8 *outBuf, int byteToRead);
+int fts_write_dma_safe(u8 *cmd, int cmdLength);
+int fts_writeFwCmd(u8 *cmd, int cmdLenght);
+int fts_writeThenWriteRead(u8 *writeCmd1, int writeCmdLength, u8 *readCmd1,
+			   int readCmdLength, u8 *outBuf, int byteToRead);
+int fts_writeU8UX(u8 cmd, AddrSize addrSize, u64 address, u8 *data, int dataSize);
+int fts_writeReadU8UX(u8 cmd, AddrSize addrSize, u64 address, u8 *outBuf, int byteToRead, int hasDummyByte);
+int fts_writeU8UXthenWriteU8UX(u8 cmd1, AddrSize addrSize1, u8 cmd2, AddrSize addrSize2, u64 address, u8 *data, int dataSize);
+int fts_writeU8UXthenWriteReadU8UX(u8 cmd1, AddrSize addrSize1, u8 cmd2, AddrSize addrSize2, u64 address, u8 *outBuf, int count, int hasDummyByte);
+#endif
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsSoftware.h b/drivers/input/touchscreen/stfts/fts_lib/ftsSoftware.h
new file mode 100644
index 000000000000..b270a2bcded1
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsSoftware.h
@@ -0,0 +1,379 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*							FW related data								 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsSoftware.h
+* \brief Contains all the definitions and information related to the IC from a fw/driver point of view
+*/
+
+
+#ifndef FTS_SOFTWARE_H
+#define FTS_SOFTWARE_H
+#include <linux/types.h>
+#include "ftsHardware.h"
+
+typedef signed char i8;									/*basic type that represent one signed byte (or 8 bits)*/
+
+/**
+ *	Enumerator which contains all the possible address length expressed in bytes.
+ */
+typedef enum {
+	NO_ADDR = 0,
+	BITS_8 = 1,
+	BITS_16 = 2,
+	BITS_24 = 3,
+	BITS_32 = 4,
+	BITS_40 = 5,
+	BITS_48 = 6,
+	BITS_56 = 7,
+	BITS_64 = 8
+} AddrSize;
+
+/********************  NEW API  *********************/
+
+/** @defgroup host_command Fw Host op codes
+ * Valid op codes for fw commands
+ * @{
+ */
+
+/** @defgroup scan_mode	Scan Mode
+* @ingroup host_command
+* Set the scanning mode required according to the parameters
+* @{
+*/
+#define FTS_CMD_SCAN_MODE					0xA0	/*OP Code to set scan mode*/
+/** @} */
+
+/** @defgroup feat_sel	 Feature Select
+* @ingroup host_command
+* Set the system defined features to enable/disable according the parameters
+* @{
+*/
+#define FTS_CMD_FEATURE						0xA2	/*OP code to set features*/
+/** @} */
+
+/** @defgroup sys_cmd  System Command
+* @ingroup host_command
+* Execute a system command to perform core tasks
+* @{
+*/
+#define FTS_CMD_SYSTEM						0xA4	/*OP code to write s system command*/
+
+#define FTS_CMD_LOCKDOWN_ID				0x70
+#define FTS_CMD_CUSTOM			0xC0
+/** @} */
+
+/** @} */
+
+/*SCAN MODE OPTION (0xA0)*/
+/** @defgroup scan_opt	 Scan Mode Option
+* @ingroup scan_mode
+* Valid scanning modes and their options
+* @{
+*/
+#define SCAN_MODE_ACTIVE					0x00	/*Select the Active scanning mode*/
+#define SCAN_MODE_LOW_POWER					0x01	/*Select the low power scanning mode*/
+#define SCAN_MODE_JIG_1						0x02	/*Select the Jig test 1*/
+#define SCAN_MODE_LOCKED					0x03	/*Select the Scan mode which will be locked*/
+/** @}*/
+
+/** @defgroup active_bitmask Active Mode Bitmask
+* @ingroup scan_opt
+* Bitmask to use to enables the specific scanning with the SCAN_MODE_ACTIVE option
+* @{
+*/
+#define ACTIVE_MULTI_TOUCH					0x01	/*Bit 0 MS/SS scan*/
+#define ACTIVE_KEY							0x02	/*Bit 1 Key scan*/
+#define ACTIVE_HOVER						0x04	/*Bit 2 Hover scan*/
+#define ACTIVE_PROXIMITY					0x08	/*Bit 3 Proximity scan*/
+#define ACTIVE_FORCE						0x10	/*Bit 4 Force scan*/
+/** @}*/
+
+/** @defgroup locked_opt Locked Mode Option
+* @ingroup scan_opt
+* Options to enable and lock specific scanning with the SCAN_MODE_LOCKED option
+* @{
+*/
+#define LOCKED_ACTIVE						0x00	/*Active Scan Mode*/
+#define LOCKED_HOVER						0x01	/*Hover Scan Mode*/
+#define LOCKED_IDLE							0x02	/*Idle Scan Mode*/
+#define LOCKED_LP_DETECT					0x10	/*Low Power SS*/
+#define LOCKED_LP_ACTIVE					0x11	/*Low Power MS*/
+/** @}*/
+
+/** @defgroup feat_opt	 Feature Selection Option
+* @ingroup feat_sel
+* System defined features that can be enable/disable
+* @{
+*/
+#define FEAT_SEL_GLOVE						0x00	/*Glove Mode*/
+#define FEAT_SEL_COVER						0x01	/*Cover Mode*/
+#define FEAT_SEL_CHARGER					0x02	/*Charger Mode*/
+#define FEAT_SEL_GESTURE					0x03	/*Gesture Mode*/
+#define FEAT_SEL_GRIP						0x04	/*Grip Detection*/
+#define FEAT_SEL_STYLUS						0x07	/*Stylus Mode (this is a driver define, not available in FW)*/
+/** @}*/
+
+#define FEAT_ENABLE							1		/*General value to enable a feature*/
+#define FEAT_DISABLE						0		/*General value to disable a feature*/
+
+/** @defgroup charger_opt	 Charger Mode Option
+* @ingroup feat_sel
+* Option for Charger Mode, it is a bitmask where the each bit indicate a different kind of chager
+* @{
+*/
+#define	CHARGER_CABLE						0x01	/*normal usb charger*/
+#define CHARGER_WIRLESS						0x02	/*wireless charger*/
+/** @}*/
+
+/** @defgroup gesture_opt	 Gesture Mode Option
+* @ingroup feat_sel
+* Gesture IDs of the predefined gesture recognized by the fw.
+* The ID represent also the position of the corresponding bit in the gesture mask
+* @{
+*/
+#define GEST_ID_UP_1F						0x01	/*Bottom to Top line*/
+#define GEST_ID_DOWN_1F						0x02	/*Top to bottom line*/
+#define GEST_ID_LEFT_1F						0x03	/*Right to left line*/
+#define GEST_ID_RIGHT_1F					0x04	/*Left to right line*/
+#define	GEST_ID_DBLTAP						0x05	/*Double Tap*/
+#define GEST_ID_O							0x06	/*'O'*/
+#define GEST_ID_C							0x07	/*'C'*/
+#define GEST_ID_M							0x08	/*'M'*/
+#define GEST_ID_W							0x09	/*'W'*/
+#define GEST_ID_E							0x0A	/*'e'*/
+#define GEST_ID_L							0x0B	/*'L'*/
+#define GEST_ID_F							0x0C	/*'F'*/
+#define GEST_ID_V							0x0D	/*'V'*/
+#define GEST_ID_AT							0x0E	/*'@'*/
+#define GEST_ID_S							0x0F	/*'S'*/
+#define GEST_ID_Z							0x10	/*'Z'*/
+#define GEST_ID_LEFTBRACE					0x11	/*'<'*/
+#define GEST_ID_RIGHTBRACE					0x12	/*'>'*/
+#define GEST_ID_CARET						0x13	/*'^'*/
+#define GEST_ID_LONG_PRESS					0x18	/*'^'*/
+#define GEST_ID_SINGTAP						0x19	/*'^'*/
+/** @}*/
+
+/** @defgroup sys_opt	 System Command Option
+* @ingroup sys_cmd
+* Valid System Command Parameters
+* @{
+*/
+#define SYS_CMD_SPECIAL						0x00	/*Special Commands*/
+#define SYS_CMD_INT							0x01	/*FW Interrupt Control*/
+#define SYS_CMD_FORCE_CAL					0x02	/*Force Calibration*/
+#define SYS_CMD_CX_TUNING					0x03	/*CX initialization*/
+#define SYS_CMD_ITO							0x04	/*ITO test*/
+#define SYS_CMD_SAVE_FLASH					0x05	/*Saving to flash*/
+#define SYS_CMD_LOAD_DATA					0x06	/*Load Host data memory*/
+#define SYS_CMD_SPECIAL_TUNING				0x08	/*Perform some special tuning*/
+/** @} */
+
+/** @defgroup sys_special_opt	 Special Command Option
+* @ingroup sys_cmd
+* Valid special command
+* @{
+*/
+#define SPECIAL_SYS_RESET					0x00	/*System Reset triggered by the FW*/
+#define SPECIAL_FIFO_FLUSH					0x01	/*Flush of the FIFO*/
+#define SPECIAL_PANEL_INIT					0x02	/*Panel Initialization*/
+#define SPECIAL_FULL_PANEL_INIT				0x03	/*Full panel initialization*/
+/** @} */
+
+#define CAL_MS_TOUCH						0x00	/*Mutual Sense Touch*/
+#define CAL_MS_LOW_POWER					0x01	/*Mutual Sense Touch in low power mode*/
+#define CAL_SS_TOUCH						0x02	/*Self Sense Touch*/
+#define CAL_SS_IDLE							0x03	/*Self Sense Touch in idle mode*/
+#define CAL_MS_KEY							0x04	/*Mutual Sense Key*/
+#define CAL_SS_KEY							0x05	/*Self Sense Key*/
+#define CAL_MS_FORCE						0x06	/*Mutual Sense Force*/
+#define CAL_SS_FORCE						0x07	/*Self Sense Force*/
+
+/** @defgroup ito_opt	 ITO Test Option
+* @ingroup sys_cmd
+* Valid option for the ITO test
+* @{
+*/
+#define ITO_FORCE_OPEN						0x00	/*Check if some force channels is open*/
+#define ITO_SENSE_OPEN						0x01	/*Check if some sense channels is open*/
+#define ITO_FORCE_GROUND					0x02	/*Check if some force channels is short to ground*/
+#define ITO_SENSE_GROUND					0x03	/*Check if some sense channels is short to ground*/
+#define ITO_FORCE_VDD						0x04	/*Check if some force channels is short to VDD*/
+#define ITO_SENSE_VDD						0x05	/*Check if some sense channels is short to VDD*/
+#define ITO_FORCE_FORCE						0x06	/*Check force to force channels*/
+#define ITO_FORCE_SENSE						0x07	/*Check force to sense channels*/
+#define ITO_SENSE_SENSE						0x08	/*Check sense to sense channels*/
+#define ITO_KEY_FORCE_OPEN					0x09	/*Check if some force channels used for the key is open*/
+#define ITO_KEY_SENSE_OPEN					0x0A	/*Check if some sense channels used for the key is open*/
+/** @}*/
+
+/** @defgroup save_opt	 Save to Flash Option
+* @ingroup sys_cmd
+* Valid option for saving data to the Flash
+* @{
+*/
+#define	SAVE_FW_CONF						0x01	/*Save the confing to the flash*/
+#define SAVE_CX								0x02	/*Save the CX to the flash*/
+#define SAVE_PANEL_CONF						0x04	/*Save the Panel configuration to the flash*/
+/** @}*/
+
+/** @defgroup load_opt	 Load Host Data Option
+* @ingroup sys_cmd
+* Valid option to ask to the FW to load host data into the memory
+* @{
+*/
+#define LOAD_SYS_INFO						0x01	/*Load System Info*/
+#define LOAD_CX_MS_TOUCH					0x10	/*Load MS Init Data for Active Mode*/
+#define LOAD_CX_MS_LOW_POWER				0x11	/*Load MS Init Data for Low Power Mode*/
+#define LOAD_CX_SS_TOUCH					0x12	/*Load SS Init Data for Active Mode*/
+#define LOAD_CX_SS_TOUCH_IDLE				0x13	/*Load SS Init Data for Low Power Mode*/
+#define LOAD_CX_MS_KEY						0x14	/*Load MS Init Data for Key*/
+#define LOAD_CX_SS_KEY						0x15	/*Load SS Init Data for Key*/
+#define LOAD_CX_MS_FORCE					0x16	/*Load MS Init Data for Force*/
+#define LOAD_CX_SS_FORCE					0x17	/*Load SS Init Data for Force*/
+#define LOAD_CX_SS_HOVER					0x18	/*Load SS Hover Init Data for* Force */
+#define LOAD_SYNC_FRAME_RAW					0x30	/*Load a Synchronized Raw Frame*/
+#define LOAD_SYNC_FRAME_FILTER				0x31	/*Load a Synchronized Filter Frame*/
+#define LOAD_SYNC_FRAME_STRENGTH			0x33	/*Load a Synchronized Strength Frame*/
+#define LOAD_SYNC_FRAME_BASELINE			0x32	/*Load a Synchronized Baseline Frame*/
+#define LOAD_PANEL_CX_TOT_MS_TOUCH			0x50	/*Load TOT MS Init Data for Active Mode*/
+#define LOAD_PANEL_CX_TOT_MS_LOW_POWER		0x51	/*Load TOT MS Init Data for Low Power Mode*/
+#define LOAD_PANEL_CX_TOT_SS_TOUCH			0x52	/*Load TOT SS Init Data for Active Mode*/
+#define LOAD_PANEL_CX_TOT_SS_TOUCH_IDLE		0x53	/*Load TOT SS Init Data for Low Power Mode*/
+#define LOAD_PANEL_CX_TOT_MS_KEY			0x54	/*Load TOT MS Init Data for Key*/
+#define LOAD_PANEL_CX_TOT_SS_KEY			0x55	/*Load TOT SS Init Data for Key*/
+#define LOAD_PANEL_CX_TOT_MS_FORCE			0x56	/*Load TOT MS Init Data for Force*/
+#define LOAD_PANEL_CX_TOT_SS_FORCE			0x57	/*Load TOT SS Init Data for Force*/
+#define STAPI_HOST_DATA_ID_PANEL_CX_SS_HVR 	0x58		/*Load HOVER TOT SS Init Data for Activity*/
+
+/** @}*/
+
+#define	SPECIAL_TUNING_LP_TIMER				0x01	/*Perform LP Timer calibration*/
+#define SPECIAL_TUNING_IOFF					0x02	/*Perform Ioff calibration*/
+
+/** @}*/
+
+/** @defgroup events_group	 FW Event IDs and Types
+* Event IDs and Types pushed by the FW into the FIFO
+* @{
+*/
+#define EVT_ID_NOEVENT						0x00	/*No Events*/
+#define EVT_ID_CONTROLLER_READY				0x03	/*Controller ready, issued after a system reset.*/
+#define EVT_ID_ENTER_POINT					0x13	/*Touch enter in the sensing area*/
+#define EVT_ID_MOTION_POINT					0x23	/*Touch motion (a specific touch changed position)*/
+#define EVT_ID_LEAVE_POINT					0x33	/*Touch leave the sensing area*/
+#define EVT_ID_STATUS_UPDATE				0x43	/*FW report a system condition change*/
+#define EVT_ID_USER_REPORT					0x53	/*User related events triggered (keys, gestures, proximity etc)*/
+#define EVT_ID_DEBUG						0xE3	/*Debug Info*/
+#define EVT_ID_ERROR						0xF3	/*Error Event*/
+
+#define NUM_EVT_ID							(((EVT_ID_ERROR & 0xF0) >> 4) + 1)	/*Max number of unique event IDs supported*/
+/** @}*/
+
+/** @defgroup status_type	 Status Event Types
+* @ingroup events_group
+* Types of EVT_ID_STATUS_UPDATE events
+* @{
+*/
+#define EVT_TYPE_STATUS_ECHO				0x01	/*Echo event, contain the first 5 bytes of the FW command sent*/
+#define EVT_TYPE_STATUS_FRAME_DROP			0x03	/*Some frame was skipped during the elaboration*/
+#define EVT_TYPE_STATUS_FORCE_CAL			0x05	/*Force Calibration has triggered*/
+#define EVT_TYPE_STATUS_WATER				0x06	/*Water Mode*/
+#define EVT_TYPE_STATUS_SS_RAW_SAT			0x07	/*Self Sense data saturated*/
+#define EVT_TYPE_STATUS_POCKET				0x09
+/** @} */
+
+/** @defgroup user_type	 User Event Types
+* @ingroup events_group
+* Types of EVT_ID_USER_REPORT events generated by thw FW
+* @{
+*/
+#define EVT_TYPE_USER_KEY					0x00	/*Keys pressed/relesed event report*/
+#define EVT_TYPE_USER_PROXIMITY				0x01	/*Proximity detection event report*/
+#define EVT_TYPE_USER_GESTURE				0x02	/*Gesture detection event report*/
+#define EVT_TYPE_USER_EARDET				0x03	/*ear detection event report*/
+
+/** @}*/
+
+/** @defgroup error_type  Error Event Types
+* @ingroup events_group
+* Types of EVT_ID_ERROR events reported by the FW
+* @{
+*/
+#define EVT_TYPE_ERROR_WATCHDOG				0x06	/*Watchdog timer expired*/
+
+#define EVT_TYPE_ERROR_CRC_CFG_HEAD			0x20	/*CRC error in the Config Area Header*/
+#define EVT_TYPE_ERROR_CRC_CFG				0x21	/*CRC error in the Config Area*/
+#define EVT_TYPE_ERROR_CRC_PANEL_HEAD		0x22	/*CRC error in the Panel Area Header*/
+#define EVT_TYPE_ERROR_CRC_PANEL			0x23	/*CRC error in the Panel Area*/
+
+#define EVT_TYPE_ERROR_ITO_FORCETOGND		0x60	/*Force channel/s short to ground*/
+#define EVT_TYPE_ERROR_ITO_SENSETOGND		0x61	/*Sense channel/s short to ground*/
+#define EVT_TYPE_ERROR_ITO_FORCETOVDD		0x62	/*Force channel/s short to VDD*/
+#define EVT_TYPE_ERROR_ITO_SENSETOVDD		0x63	/*Sense channel/s short to VDD*/
+#define EVT_TYPE_ERROR_ITO_FORCE_P2P		0x64	/*Pin to Pin short Force channel/s*/
+#define EVT_TYPE_ERROR_ITO_SENSE_P2P		0x65	/*Pin to Pin short Sense channel/s*/
+#define EVT_TYPE_ERROR_ITO_FORCEOPEN		0x66	/*Force Panel open*/
+#define EVT_TYPE_ERROR_ITO_SENSEOPEN		0x67	/*Sense Panel open*/
+#define EVT_TYPE_ERROR_ITO_KEYOPEN			0x68	/*Key open*/
+
+#define EVT_TYPE_ERROR_CRC_CX_HEAD			0xA0	/*CRC error in the CX Area Header*/
+#define EVT_TYPE_ERROR_CRC_CX				0xA1	/*CRC error in the CX Area*/
+#define EVT_TYPE_ERROR_CRC_CX_SUB_HEAD		0xA5	/*CRC error in the CX Subsection Area Header*/
+#define EVT_TYPE_ERROR_CRC_CX_SUB			0xA6	/*CRC error in the CX Subsection Area*/
+
+#define EVT_TYPE_ERROR_ESD					0xF0	/*ESD error*/
+/** @}*/
+
+/** @defgroup address Chip Address
+ * Collection of HW and SW Addresses useful to collect different kind of data
+ * @{
+ */
+
+/** @defgroup config_adr SW Address
+ * @ingroup address
+ * Important addresses of data stored into Config memory (and sometimes their dimensions)
+ * @{
+ */
+#define ADDR_CONFIG_ID						0x0010	/*Starting Address of the config ID*/
+#define CONFIG_ID_BYTE						2		/*Number of bytes of config ID*/
+#define ADDR_CONFIG_SENSE_LEN				0x0030	/*Address where is stored the number of sense channels*/
+#define ADDR_CONFIG_FORCE_LEN				0x0031	/*Address where is stored the number of force channels*/
+/** @}*/
+
+/** @}*/
+
+#define ERROR_DUMP_ROW_SIZE					32		/*number of rows of the error memory*/
+#define ERROR_DUMP_COL_SIZE					4		/*number of bytes for each row of the error memory*/
+#define ERROR_DUMP_SIGNATURE				0xFA5005AF	/*first row signature of a proper dump*/
+
+#define TOUCH_TYPE_INVALID					0x00	/*Invalid touch type*/
+#define TOUCH_TYPE_FINGER					0x01	/*Finger touch*/
+#define TOUCH_TYPE_GLOVE					0x02	/*Glove touch*/
+#define TOUCH_TYPE_STYLUS					0x03	/*Stylus touch*/
+#define TOUCH_TYPE_PALM						0x04	/*Palm touch*/
+#define TOUCH_TYPE_HOVER					0x05	/*Hovering touch*/
+
+#define FTS_KEY_0							0x01	/*Key 0 bit*/
+#define FTS_KEY_1							0x02	/*Key 1 bit*/
+#define FTS_KEY_2							0x04	/*Key 2 bit*/
+#define FTS_KEY_3							0x08	/*Key 3 bit*/
+#define FTS_KEY_4							0x10	/*Key 4 bit*/
+#define FTS_KEY_5							0x20	/*Key 5 bit*/
+#define FTS_KEY_6							0x40	/*Key 6 bit*/
+#define FTS_KEY_7							0x80	/*Key 7 bit*/
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsTest.c b/drivers/input/touchscreen/stfts/fts_lib/ftsTest.c
new file mode 100644
index 000000000000..293743b51ce6
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsTest.c
@@ -0,0 +1,5938 @@
+/*
+
+ **************************************************************************
+ **                        STMicroelectronics							 **
+ **************************************************************************
+ **                        marco.cali@st.com							 **
+ **************************************************************************
+ *                                                                        *
+ *							FTS API for MP test							  *
+ *                                                                        *
+ **************************************************************************
+ **************************************************************************
+
+ */
+
+/*!
+ * \file ftsTest.c
+ * \brief Contains all the functions related to the Mass Production Test
+ */
+
+#include "ftsCompensation.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsFrame.h"
+#include "ftsHardware.h"
+#include "ftsIO.h"
+#include "ftsSoftware.h"
+#include "ftsTest.h"
+#include "ftsTime.h"
+#include "ftsTool.h"
+#include "../fts.h"
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/serio.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/firmware.h>
+
+#ifdef LIMITS_H_FILE
+#include "../fts_limits.h"
+#endif
+
+TestToDo tests;
+static LimitFile limit_file;
+
+/**
+ * Initialize the testToDo variable with the default tests to perform during the Mass Production Test
+ * @return OK
+ */
+int initTestToDo(void)
+{
+	/*** Initialize Limit File ***/
+	limit_file.size = 0;
+	limit_file.data = NULL;
+	strncpy(limit_file.name, " ", MAX_LIMIT_FILE_NAME -1);
+	limit_file.name[MAX_LIMIT_FILE_NAME - 1] = '\0';
+	tests.SelfHoverForceRaw=1;		/* /< SS Hover Force Raw min/Max test */
+	tests.SelfHoverSenceRaw=1;		/* /< SS Hover Sence Raw min/Max test */
+	tests.SelfHoverForceIxTotal=1;	/* /< SS Hover Total Force Ix min/Max (for each node)* test */
+	tests.SelfHoverSenceIxTotal=1;
+	tests.MutualRawAdjITO = 0;
+	tests.MutualRaw = 0;
+	tests.MutualRawEachNode = 1;
+	tests.MutualRawGap = 0;
+	tests.MutualRawAdj = 0;
+	tests.MutualRawLP = 0;
+	tests.MutualRawGapLP = 0;
+	tests.MutualRawAdjLP = 0;
+	tests.MutualCx1 = 0;
+	tests.MutualCx2 = 0;
+	tests.MutualCx2Adj = 0;
+	tests.MutualCxTotal = 0;
+	tests.MutualCxTotalAdj = 0;
+
+	tests.MutualCx1LP = 0;
+	tests.MutualCx2LP = 1;
+	tests.MutualCx2AdjLP = 1;
+	tests.MutualCxTotalLP = 0;
+	tests.MutualCxTotalAdjLP = 0;
+#ifdef PHONE_KEY
+	tests.MutualKeyRaw = 0;
+#else
+	tests.MutualKeyRaw = 0;
+#endif
+	tests.MutualKeyCx1 = 0;
+	tests.MutualKeyCx2 = 0;
+#ifdef PHONE_KEY
+	tests.MutualKeyCxTotal = 0;
+#else
+	tests.MutualKeyCxTotal = 0;
+#endif
+	tests.SelfForceRaw = 1;
+	tests.SelfForceRawGap = 0;
+	tests.SelfForceRawLP = 0;
+	tests.SelfForceRawGapLP = 0;
+	tests.SelfForceIx1 = 0;
+	tests.SelfForceIx2 = 0;
+	tests.SelfForceIx2Adj = 0;
+	tests.SelfForceIxTotal = 1;
+	tests.SelfForceIxTotalAdj = 0;
+	tests.SelfForceCx1 = 0;
+	tests.SelfForceCx2 = 0;
+	tests.SelfForceCx2Adj = 0;
+	tests.SelfForceCxTotal = 0;
+	tests.SelfForceCxTotalAdj = 0;
+	tests.SelfSenseRaw = 1;
+	tests.SelfSenseRawGap = 0;
+	tests.SelfSenseRawLP = 0;
+	tests.SelfSenseRawGapLP = 0;
+	tests.SelfSenseIx1 = 0;
+	tests.SelfSenseIx2 = 0;
+	tests.SelfSenseIx2Adj = 0;
+	tests.SelfSenseIxTotal = 1;
+	tests.SelfSenseIxTotalAdj = 0;
+	tests.SelfSenseCx1 = 0;
+	tests.SelfSenseCx2 = 0;
+	tests.SelfSenseCx2Adj = 0;
+	tests.SelfSenseCxTotal = 0;
+	tests.SelfSenseCxTotalAdj = 0;
+	return OK;
+}
+
+/**
+ * Compute the Horizontal adjacent matrix doing the abs of the difference between the column i with the i-1 one. \n
+ * Both the original data matrix and the adj matrix are disposed as 1 dimension array one row after the other \n
+ * The resulting matrix has one column less than the starting original one \n
+ * @param data pointer to the array of signed bytes containing the original data
+ * @param row number of rows of the original data
+ * @param column number of columns of the original data
+ * @param result pointer of a pointer to an array of unsigned bytes which will contain the adj matrix
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int computeAdjHoriz(i8 *data, int row, int column, u8 **result)
+{
+	int i, j;
+	int size = row * (column - 1);
+
+	if (column < 2) {
+		logError(1, "%s computeAdjHoriz: ERROR % 08X\n", tag,
+			 ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u8 *) kmalloc(size * sizeof(u8), GFP_KERNEL);
+
+	if (*result == NULL) {
+		logError(1, "%s computeAdjHoriz: ERROR %08X\n", tag,
+			 ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 0; i < row; i++) {
+		for (j = 1; j < column; j++) {
+			*(*result + (i * (column - 1) + (j - 1))) =
+				abs(data[i * column + j] -
+				    data[i * column + (j - 1)]);
+		}
+	}
+
+	return OK;
+}
+
+/**
+ * Compute the Horizontal adjacent matrix of short values doing the abs of the difference between the column i with the i-1 one.
+ * Both the original data matrix and the adj matrix are disposed as 1 dimension array one row after the other \n
+ * The resulting matrix has one column less than the starting original one \n
+ * @param data pointer to the array of signed bytes containing the original data
+ * @param row number of rows of the original data
+ * @param column number of columns of the original data
+ * @param result pointer of a pointer to an array of unsigned bytes which will contain the adj matrix
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int computeAdjHorizTotal(short *data, int row, int column, u16 **result)
+{
+	int i, j;
+	int size = row * (column - 1);
+
+	if (column < 2) {
+		logError(1, "%s computeAdjHorizTotal: ERROR % 08X\n", tag,
+			 ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u16 *) kmalloc(size * sizeof(u16), GFP_KERNEL);
+
+	if (*result == NULL) {
+		logError(1, "%s computeAdjHorizTotal: ERROR %08X\n", tag,
+			 ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 0; i < row; i++) {
+		for (j = 1; j < column; j++) {
+			*(*result + (i * (column - 1) + (j - 1))) =
+				abs(data[i * column + j] -
+				    data[i * column + (j - 1)]);
+		}
+	}
+
+	return OK;
+}
+
+/**
+ * Compute the Vertical adjacent matrix doing the abs of the difference between the row i with the i-1 one.
+ * Both the original data matrix and the adj matrix are disposed as 1 dimension array one row after the other. \n
+ * The resulting matrix has one column less than the starting original one \n
+ * @param data pointer to the array of signed bytes containing the original data
+ * @param row number of rows of the original data
+ * @param column number of columns of the original data
+ * @param result pointer of a pointer to an array of unsigned bytes which will contain the adj matrix
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int computeAdjVert(i8 *data, int row, int column, u8 **result)
+{
+	int i, j;
+	int size = (row - 1) * (column);
+
+	if (row < 2) {
+		logError(1, "%s computeAdjVert: ERROR % 08X\n", tag,
+			 ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u8 *) kmalloc(size * sizeof(u8), GFP_KERNEL);
+
+	if (*result == NULL) {
+		logError(1, "%s computeAdjVert: ERROR %08X\n", tag,
+			 ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 1; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			*(*result + ((i - 1) * column + j)) =
+				abs(data[i * column + j] -
+				    data[(i - 1) * column + j]);
+		}
+	}
+
+	return OK;
+}
+
+/**
+ * Compute the Vertical adjacent matrix of short values doing the abs of the difference between the row i with the i-1 one.
+ * Both the original data matrix and the adj matrix are disposed as 1 dimension array one row after the other. \n
+ * The resulting matrix has one column less than the starting original one \n
+ * @param data pointer to the array of signed bytes containing the original data
+ * @param row number of rows of the original data
+ * @param column number of columns of the original data
+ * @param result pointer of a pointer to an array of unsigned bytes which will contain the adj matrix
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int computeAdjVertTotal(short *data, int row, int column, u16 **result)
+{
+	int i, j;
+	int size = (row - 1) * (column);
+
+	if (row < 2) {
+		logError(1, "%s computeAdjVertTotal: ERROR %08X\n", tag,
+			 ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u16 *) kmalloc(size * sizeof(u16), GFP_KERNEL);
+
+	if (*result == NULL) {
+		logError(1, "%s computeAdjVertTotal: ERROR %08X\n", tag,
+			 ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 1; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			*(*result + ((i - 1) * column + j)) =
+				abs(data[i * column + j] -
+				    data[(i - 1) * column + j]);
+		}
+	}
+
+	return OK;
+}
+
+/**
+ * Compute the Horizontal adjacent matrix doing the abs of the difference between the column i with the i-1 one. \n
+ * Both the original data matrix and the adj matrix are disposed as 1 dimension array one row after the other \n
+ * The resulting matrix has one column less than the starting original one \n
+ * @param data pointer to the array of unsigned bytes containing the original data
+ * @param row number of rows of the original data
+ * @param column number of columns of the original data
+ * @param result pointer of a pointer to an array of unsigned bytes which will contain the adj matrix
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int computeAdjHorizFromU(u8 *data, int row, int column, u8 **result)
+{
+	int i, j;
+	int size = row * (column - 1);
+
+	if (column < 2) {
+		logError(1, "%s computeAdjHoriz: ERROR %08X\n", tag,
+			 ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u8 *) kmalloc(size * sizeof(u8), GFP_KERNEL);
+
+	if (*result == NULL) {
+		logError(1, "%s computeAdjHoriz: ERROR %08X\n", tag,
+			 ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 0; i < row; i++) {
+		for (j = 1; j < column; j++) {
+			*(*result + (i * (column - 1) + (j - 1))) =
+				abs(data[i * column + j] -
+				    data[i * column + (j - 1)]);
+		}
+	}
+
+	return OK;
+}
+
+/**
+ * Compute the Horizontal adjacent matrix of u16 values doing the abs of the difference between the column i with the i-1 one.
+ * Both the original data matrix and the adj matrix are disposed as 1 dimension array one row after the other \n
+ * The resulting matrix has one column less than the starting original one \n
+ * @param data pointer to the array of unsigned bytes containing the original data
+ * @param row number of rows of the original data
+ * @param column number of columns of the original data
+ * @param result pointer of a pointer to an array of unsigned bytes which will contain the adj matrix
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int computeAdjHorizTotalFromU(u16 *data, int row, int column, u16 **result)
+{
+	int i, j;
+	int size = row * (column - 1);
+
+	if (column < 2) {
+		logError(1, "%s computeAdjHorizTotal: ERROR %08X\n", tag,
+			 ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u16 *) kmalloc(size * sizeof(u16), GFP_KERNEL);
+
+	if (*result == NULL) {
+		logError(1, "%s computeAdjHorizTotal: ERROR %08X\n", tag,
+			 ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 0; i < row; i++) {
+		for (j = 1; j < column; j++) {
+			*(*result + (i * (column - 1) + (j - 1))) =
+				abs(data[i * column + j] -
+				    data[i * column + (j - 1)]);
+		}
+	}
+
+	return OK;
+}
+
+/**
+ * Compute the Vertical adjacent matrix doing the abs of the difference between the row i with the i-1 one.
+ * Both the original data matrix and the adj matrix are disposed as 1 dimension array one row after the other. \n
+ * The resulting matrix has one column less than the starting original one \n
+ * @param data pointer to the array of unsigned bytes containing the original data
+ * @param row number of rows of the original data
+ * @param column number of columns of the original data
+ * @param result pointer of a pointer to an array of unsigned bytes which will contain the adj matrix
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int computeAdjVertFromU(u8 *data, int row, int column, u8 **result)
+{
+	int i, j;
+	int size = (row - 1) * (column);
+
+	if (row < 2) {
+		logError(1, "%s computeAdjVert: ERROR %08X\n", tag,
+			 ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u8 *) kmalloc(size * sizeof(u8), GFP_KERNEL);
+
+	if (*result == NULL) {
+		logError(1, "%s computeAdjVert: ERROR %08X\n", tag,
+			 ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 1; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			*(*result + ((i - 1) * column + j)) =
+				abs(data[i * column + j] -
+				    data[(i - 1) * column + j]);
+		}
+	}
+
+	return OK;
+}
+
+/**
+ * Compute the Vertical adjacent matrix of u16 values doing the abs of the difference between the row i with the i-1 one.
+ * Both the original data matrix and the adj matrix are disposed as 1 dimension array one row after the other. \n
+ * The resulting matrix has one column less than the starting original one \n
+ * @param data pointer to the array of unsigned bytes containing the original data
+ * @param row number of rows of the original data
+ * @param column number of columns of the original data
+ * @param result pointer of a pointer to an array of unsigned bytes which will contain the adj matrix
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int computeAdjVertTotalFromU(u16 *data, int row, int column, u16 **result)
+{
+	int i, j;
+	int size = (row - 1) * (column);
+
+	if (row < 2) {
+		logError(1, "%s computeAdjVertTotal: ERROR %08X\n", tag,
+			 ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u16 *) kmalloc(size * sizeof(u16), GFP_KERNEL);
+
+	if (*result == NULL) {
+		logError(1, "%s computeAdjVertTotal: ERROR %08X\n", tag,
+			 ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 1; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			*(*result + ((i - 1) * column + j)) =
+				abs(data[i * column + j] -
+				    data[(i - 1) * column + j]);
+		}
+	}
+
+	return OK;
+}
+
+int computeTotal(u8 *data, u8 main, int row, int column, int m, int n,
+		 u16 **result)
+{
+	int i, j;
+	int size = (row) * (column);
+	*result = (u16 *) kmalloc(size * sizeof(u16), GFP_KERNEL);
+
+	if (*result == NULL) {
+		logError(1, "%s computeTotal : ERROR %02X\n", tag, ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			*(*result + (i * column + j)) =
+				m * main + n * data[i * column + j];
+		}
+	}
+
+	return OK;
+}
+
+/**
+ * Check that each value of a matrix of short doesn't exceed a min and a Max value (these values are included in the interval). \n
+ * The matrix is stored as 1 dimension array one row after the other. \n
+ * @param data pointer to the array of short containing the data to check
+ * @param row number of rows of data
+ * @param column number of columns of data
+ * @param min minimum value allowed
+ * @param max Maximum value allowed
+ * @return the number of elements that overcome the specified interval (0 = OK)
+ */
+int checkLimitsMinMax(short *data, int row, int column, int min, int max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] < min
+			    || data[i * column + j] > max) {
+				logError(1,
+					 "%s checkLimitsMinMax: Node[%d,%d] = %d exceed limit [%d, %d] \n",
+					 tag, i, j, data[i * column + j], min,
+					 max);
+				count++;
+			}
+		}
+	}
+
+	return count;
+}
+
+/**
+ * Check that the difference between the max and min of a matrix of short is less or equal to a threshold.\n
+ * The matrix is stored as 1 dimension array one row after the other.
+ * @param data pointer to the array of short containing the data to check
+ * @param row number of rows of data
+ * @param column number of columns of data
+ * @param threshold threshold value allowed
+ * @return OK if the difference is <= to threshold otherwise ERROR_TEST_CHECK_FAIL
+ */
+static int checkLimitsGap(short *data, int row, int column, int threshold)
+{
+	int i, j;
+	int min_node;
+	int max_node;
+
+	if (row == 0 || column == 0) {
+		logError(1,
+			 "%s checkLimitsGap: invalid number of rows = %d or columns = %d  ERROR %08X\n",
+			 tag, row, column, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	min_node = data[0];
+	max_node = data[0];
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] < min_node) {
+				min_node = data[i * column + j];
+			} else {
+				if (data[i * column + j] > max_node)
+					max_node = data[i * column + j];
+			}
+		}
+	}
+
+	if (max_node - min_node > threshold) {
+		logError(1, "%s checkLimitsGap: GAP = %d exceed limit  %d \n",
+			 tag, max_node - min_node, threshold);
+		return ERROR_TEST_CHECK_FAIL;
+	} else
+		return OK;
+}
+
+/**
+ * Check that each value of a matrix of i8 doesn't exceed a specific min and Max value  set for each node (these values are included in the interval). \n
+ * The matrixes of data, min and max values are stored as 1 dimension arrays one row after the other.
+ * @param data pointer to the array of short containing the data to check
+ * @param row number of rows of data
+ * @param column number of columns of data
+ * @param min pointer to a matrix which specify the minimum value allowed for each node
+ * @param max pointer to a matrix which specify the Maximum value allowed for each node
+ * @return the number of elements that overcome the specified interval (0 = OK)
+ */
+int checkLimitsMap(i8 *data, int row, int column, int *min, int *max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] < min[i * column + j]
+			    || data[i * column + j] > max[i * column + j]) {
+				logError(1,
+					 "%s checkLimitsMap: Node[%d,%d] = %d exceed limit [%d, %d] \n",
+					 tag, i, j, data[i * column + j],
+					 min[i * column + j],
+					 max[i * column + j]);
+				count++;
+			}
+		}
+	}
+
+	return count;
+}
+
+/**
+ * Check that each value of a matrix of short doesn't exceed a specific min and Max value  set for each node (these values are included in the interval).
+ * The matrixes of data, min and max values are stored as 1 dimension arrays one row after the other.
+ * @param data pointer to the array of short containing the data to check
+ * @param row number of rows of data
+ * @param column number of columns of data
+ * @param min pointer to a matrix which specify the minimum value allowed for each node
+ * @param max pointer to a matrix which specify the Maximum value allowed for each node
+ * @return the number of elements that overcome the specified interval (0 = OK)
+ */
+int checkLimitsMapTotal(short *data, int row, int column, int *min, int *max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] < min[i * column + j]
+			    || data[i * column + j] > max[i * column + j]) {
+				logError(1,
+					 "%s checkLimitsMapTotal: Node[%d,%d] = %d exceed limit [%d, %d] \n",
+					 tag, i, j, data[i * column + j],
+					 min[i * column + j],
+					 max[i * column + j]);
+				count++;
+			}
+		}
+	}
+
+	return count;
+}
+
+/**
+ * Check that each value of a matrix of u8 doesn't exceed a specific min and Max value  set for each node (these values are included in the interval). \n
+ * The matrixes of data, min and max values are stored as 1 dimension arrays one row after the other.
+ * @param data pointer to the array of short containing the data to check
+ * @param row number of rows of data
+ * @param column number of columns of data
+ * @param min pointer to a matrix which specify the minimum value allowed for each node
+ * @param max pointer to a matrix which specify the Maximum value allowed for each node
+ * @return the number of elements that overcome the specified interval (0 = OK)
+ */
+int checkLimitsMapFromU(u8 *data, int row, int column, int *min, int *max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] < min[i * column + j]
+			    || data[i * column + j] > max[i * column + j]) {
+				logError(1,
+					 "%s checkLimitsMap: Node[%d,%d] = %d exceed limit [%d, %d] \n",
+					 tag, i, j, data[i * column + j],
+					 min[i * column + j],
+					 max[i * column + j]);
+				count++;
+			}
+		}
+	}
+
+	return count;
+}
+
+/**
+ * Check that each value of a matrix of u16 doesn't exceed a specific min and Max value  set for each node (these values are included in the interval).
+ * The matrixes of data, min and max values are stored as 1 dimension arrays one row after the other.
+ * @param data pointer to the array of short containing the data to check
+ * @param row number of rows of data
+ * @param column number of columns of data
+ * @param min pointer to a matrix which specify the minimum value allowed for each node
+ * @param max pointer to a matrix which specify the Maximum value allowed for each node
+ * @return the number of elements that overcome the specified interval (0 = OK)
+ */
+int checkLimitsMapTotalFromU(u16 *data, int row, int column, int *min,
+			     int *max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] < min[i * column + j]
+			    || data[i * column + j] > max[i * column + j]) {
+				logError(1,
+					 "%s checkLimitsMapTotal: Node[%d,%d] = %d exceed limit [%d, %d] \n",
+					 tag, i, j, data[i * column + j],
+					 min[i * column + j],
+					 max[i * column + j]);
+				count++;
+			}
+			logError(1,
+				 "%s checkLimitsMapTotal: Node[%d,%d] = %d\n",
+				 tag, i, j, data[i * column + j],
+				 min[i * column + j],
+				 max[i * column + j]);
+		}
+	}
+
+	return count;
+}
+
+/**
+ * Check that each value of a matrix of u8 doesn't exceed a specific Max value  set for each node (max value is included in the interval).
+ * The matrixes of data and max values are stored as 1 dimension arrays one row after the other.
+ * @param data pointer to the array of short containing the data to check
+ * @param row number of rows of data
+ * @param column number of columns of data
+ * @param max pointer to a matrix which specify the Maximum value allowed for each node
+ * @return the number of elements that overcome the specified interval (0 = OK)
+ */
+int checkLimitsMapAdj(u8 *data, int row, int column, int *max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] > max[i * column + j]) {
+				logError(1,
+					 "%s checkLimitsMapAdj: Node[%d,%d] = %d exceed limit > %d \n",
+					 tag, i, j, data[i * column + j],
+					 max[i * column + j]);
+				count++;
+			}
+		}
+	}
+
+	return count;
+}
+
+/**
+ * Check that each value of a matrix of u16 doesn't exceed a specific Max value set for each node (max value is included in the interval).
+ * The matrixes of data and max values are stored as 1 dimension arrays one row after the other.
+ * @param data pointer to the array of short containing the data to check
+ * @param row number of rows of data
+ * @param column number of columns of data
+ * @param max pointer to a matrix which specify the Maximum value allowed for each node
+ * @return the number of elements that overcome the specified interval (0 = OK)
+ */
+int checkLimitsMapAdjTotal(u16 *data, int row, int column, int *max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] > max[i * column + j]) {
+				logError(1,
+					 "%s checkLimitsMapAdjTotal: Node[%d,%d] = %d exceed limit > %d \n",
+					 tag, i, j, data[i * column + j],
+					 max[i * column + j]);
+				count++;
+			}
+		}
+	}
+
+	return count;
+}
+
+/**
+ * Perform an ITO test setting all the possible options (see @link ito_opt ITO Options @endlink)
+ * @return the number of elements that overcome the specified interval (0 = OK)
+ */
+int production_test_ito(char *path_limits, TestToDo *todo)
+{
+	int res = OK;
+	u8 sett[2] = { 0x00, 0x00 };
+	MutualSenseFrame msRawFrame;
+	int *thresholds = NULL;
+	u16 *adj = NULL;
+	int trows, tcolumns;
+	logError(1, "%s ITO Production test is starting...\n", tag);
+	memset(&msRawFrame, 0x00, sizeof(msRawFrame));
+	res = fts_system_reset();
+
+	if (res < 0) {
+		logError(1, "%s %s: ERROR %08X \n", tag, __func__,
+			 ERROR_PROD_TEST_ITO);
+		return (res | ERROR_PROD_TEST_ITO);
+	}
+
+	sett[0] = SPECIAL_TUNING_IOFF;
+	logError(0, "%s Trimming Ioff... \n", tag);
+	res = writeSysCmd(SYS_CMD_SPECIAL_TUNING, sett, 2);
+
+	if (res < OK) {
+		logError(1, "%s production_test_ito: Trimm Ioff ERROR %08X \n",
+			 tag, (res | ERROR_PROD_TEST_ITO));
+		return (res | ERROR_PROD_TEST_ITO);
+	}
+
+	sett[0] = 0xFF;
+	sett[1] = 0xFF;
+	logError(0, "%s ITO Check command sent... \n", tag);
+	res = writeSysCmd(SYS_CMD_ITO, sett, 2);
+
+	if (res < OK) {
+		logError(1, "%s production_test_ito: ERROR %08X \n", tag,
+			 (res | ERROR_PROD_TEST_ITO));
+		return (res | ERROR_PROD_TEST_ITO);
+	}
+
+	logError(0, "%s ITO Command = OK! \n", tag);
+
+	if (todo->MutualRawAdjITO == 1) {
+		logError(1, "%s MS RAW ITO ADJ TEST: \n", tag);
+		logError(0, "%s Collecting MS Raw data... \n", tag);
+		res |= getMSFrame3(MS_RAW, &msRawFrame);
+
+		if (res < OK) {
+			logError(1, "%s %s: getMSFrame failed... ERROR %08X \n",
+				 tag, __func__, ERROR_PROD_TEST_ITO);
+			goto ERROR;
+		}
+
+		logError(0, "%s MS RAW ITO ADJ HORIZONTAL TEST: \n", tag);
+		res =
+			computeAdjHorizTotal(msRawFrame.node_data,
+					     msRawFrame.header.force_node,
+					     msRawFrame.header.sense_node, &adj);
+
+		if (res < OK) {
+			logError(1,
+				 "%s %s: computeAdjHoriz failed... ERROR %08X \n",
+				 tag, __func__, ERROR_PROD_TEST_ITO);
+			goto ERROR;
+		}
+
+		res =
+			parseProductionTestLimits(path_limits, &limit_file,
+						  MS_RAW_ITO_ADJH, &thresholds,
+						  &trows, &tcolumns);
+
+		if (res < OK
+		    || (trows != msRawFrame.header.force_node
+			|| tcolumns != msRawFrame.header.sense_node - 1)) {
+			logError(1,
+				 "%s %s: parseProductionTestLimits MS_RAW_ITO_ADJH failed... ERROR %08X \n",
+				 tag, __func__, ERROR_PROD_TEST_DATA);
+			goto ERROR;
+		}
+
+		res =
+			checkLimitsMapAdjTotal(adj, msRawFrame.header.force_node,
+					       msRawFrame.header.sense_node - 1,
+					       thresholds);
+
+		if (res != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsAdj MS RAW ITO ADJH failed... ERROR COUNT = %d \n",
+				 tag, res);
+			logError(0,
+				 "%s MS RAW ITO ADJ HORIZONTAL TEST:.................FAIL \n\n",
+				 tag);
+			print_frame_short("MS Raw ITO frame =",
+					  array1dTo2d_short
+					  (msRawFrame.node_data,
+					   msRawFrame.node_data_size,
+					   msRawFrame.header.sense_node),
+					  msRawFrame.header.force_node,
+					  msRawFrame.header.sense_node);
+			res = ERROR_PROD_TEST_ITO;
+			goto ERROR;
+		} else
+			logError(0,
+				 "%s MS RAW ITO ADJ HORIZONTAL TEST:.................OK  \n",
+				 tag);
+
+		kfree(thresholds);
+		thresholds = NULL;
+		kfree(adj);
+		adj = NULL;
+		logError(0, "%s MS RAW ITO ADJ VERTICAL TEST: \n", tag);
+		res =
+			computeAdjVertTotal(msRawFrame.node_data,
+					    msRawFrame.header.force_node,
+					    msRawFrame.header.sense_node, &adj);
+
+		if (res < OK) {
+			logError(1,
+				 "%s %s: computeAdjVert failed... ERROR %08X \n",
+				 tag, __func__, ERROR_PROD_TEST_ITO);
+			goto ERROR;
+		}
+
+		res =
+			parseProductionTestLimits(path_limits, &limit_file,
+						  MS_RAW_ITO_ADJV, &thresholds,
+						  &trows, &tcolumns);
+
+		if (res < OK
+		    || (trows != msRawFrame.header.force_node - 1
+			|| tcolumns != msRawFrame.header.sense_node)) {
+			logError(1,
+				 "%s %s: parseProductionTestLimits MS_RAW_ITO_ADJV failed... ERROR %08X \n",
+				 tag, __func__, ERROR_PROD_TEST_ITO);
+			goto ERROR;
+		}
+
+		res =
+			checkLimitsMapAdjTotal(adj,
+					       msRawFrame.header.force_node - 1,
+					       msRawFrame.header.sense_node,
+					       thresholds);
+
+		if (res != OK) {
+			logError(1,
+				 "%s %s: checkLimitsAdj MS RAW ITO ADJV failed... ERROR COUNT = %d \n",
+				 tag, __func__, res);
+			logError(0,
+				 "%s MS RAW ITO ADJ VERTICAL TEST:.................FAIL \n\n",
+				 tag);
+			print_frame_short("MS Raw ITO frame =",
+					  array1dTo2d_short
+					  (msRawFrame.node_data,
+					   msRawFrame.node_data_size,
+					   msRawFrame.header.sense_node),
+					  msRawFrame.header.force_node,
+					  msRawFrame.header.sense_node);
+			res = ERROR_PROD_TEST_ITO;
+			goto ERROR;
+		} else
+			logError(0,
+				 "%s MS RAW ITO ADJ VERTICAL TEST:.................OK  \n",
+				 tag);
+
+		kfree(thresholds);
+		thresholds = NULL;
+		kfree(adj);
+		adj = NULL;
+	} else
+		logError(0,
+			 "%s MS RAW ITO ADJ TEST:.................SKIPPED  \n",
+			 tag);
+
+ERROR:
+
+	if (thresholds != NULL) {
+		kfree(thresholds);
+		thresholds = NULL;
+	}
+	if (adj != NULL) {
+		kfree(adj);
+		adj = NULL;
+	}
+	if (msRawFrame.node_data != NULL) {
+		kfree(msRawFrame.node_data);
+		msRawFrame.node_data = NULL;
+	}
+	freeLimitsFile(&limit_file);
+	res |= fts_system_reset();
+
+	if (res < OK) {
+		logError(1, "%s production_test_ito: ERROR %08X \n", tag,
+			 ERROR_PROD_TEST_ITO);
+		res = (res | ERROR_PROD_TEST_ITO);
+	}
+
+	return res;
+}
+
+/**
+ * Perform the Initialization of the IC
+ * @param type type of initialization to do (see @link sys_special_opt Initialization Options (Full or Panel) @endlink)
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int production_test_initialization(u8 type)
+{
+	int res;
+	logError(1, "%s INITIALIZATION Production test is starting,type:%d\n", tag, type);
+
+	if (type != SPECIAL_PANEL_INIT && type != SPECIAL_FULL_PANEL_INIT) {
+		logError(1,
+			 "%s production_test_initialization: Type incompatible! Type = %02X ERROR %08X \n",
+			 tag, type,
+			 ERROR_OP_NOT_ALLOW | ERROR_PROD_TEST_INITIALIZATION);
+		return (ERROR_OP_NOT_ALLOW | ERROR_PROD_TEST_INITIALIZATION);
+	}
+
+	res = fts_system_reset();
+
+	if (res < 0) {
+		logError(1, "%s production_test_initialization: ERROR %08X \n",
+			 tag, ERROR_PROD_TEST_INITIALIZATION);
+		return (res | ERROR_PROD_TEST_INITIALIZATION);
+	}
+
+	logError(0, "%s INITIALIZATION command sent... %02X \n", tag, type);
+	res = writeSysCmd(SYS_CMD_SPECIAL, &type, 1);
+
+	if (res < OK) {
+		logError(1, "%s production_test_initialization: ERROR %08X \n",
+			 tag, (res | ERROR_PROD_TEST_INITIALIZATION));
+		return (res | ERROR_PROD_TEST_INITIALIZATION);
+	}
+
+	logError(0, "%s Refresh Sys Info...\n", tag);
+	res |= readSysInfo(1);
+
+	if (res < 0) {
+		logError(1,
+			 "%s production_test_initialization: read sys info ERROR %08X\n",
+			 tag, ERROR_PROD_TEST_INITIALIZATION);
+		res = (res | ERROR_PROD_TEST_INITIALIZATION);
+	}
+
+	return res;
+}
+
+/**
+ * Perform a FULL (ITO + INIT + DATA CHECK) Mass Production Test of the IC
+ * @param pathThresholds name of Production Limit file to load or "NULL" if the limits data should be loaded by a .h file
+ * @param stop_on_fail if 1, the test flow stops at the first data check failure otherwise it keeps going performing all the selected test
+ * @param saveInit if >0 (possible values: NO_INIT, SPECIAL_PANEL_INIT or SPECIAL_FULL_PANEL_INIT), the Initialization of the IC is executed otherwise it is skipped
+ * @param todo pointer to a TestToDo variable which select the test to do
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int production_test_main(char *pathThresholds, int stop_on_fail, int saveInit,
+			 TestToDo *todo)
+{
+	int res, ret;
+	logError(0, "%s MAIN Production test is starting...\n", tag);
+	logError(0, "%s \n", tag);
+	logError(0, "%s ITO TEST: \n", tag);
+	res = production_test_ito(pathThresholds, todo);
+
+	if (res < 0) {
+		logError(0, "%s Error during ITO TEST! ERROR %08X\n", tag, res);
+		goto END;
+	} else {
+		logError(0, "%s ITO TEST OK!\n", tag);
+	}
+
+	logError(0, "%s \n", tag);
+	logError(0, "%s INITIALIZATION TEST : \n", tag);
+
+	if (saveInit != NO_INIT) {
+		res = production_test_initialization((u8) saveInit);
+
+		if (res < 0) {
+			logError(0,
+				 "%s Error during  INITIALIZATION TEST! ERROR %08X\n",
+				 tag, res);
+
+			if (stop_on_fail)
+				goto END;
+		} else {
+			logError(0, "%s INITIALIZATION TEST OK!\n", tag);
+		}
+	} else
+		logError(0,
+			 "%s INITIALIZATION TEST :................. SKIPPED  \n",
+			 tag);
+
+	logError(0, "%s \n", tag);
+
+	if (saveInit == 1) {
+		logError(0, "%s Cleaning up...\n", tag);
+		ret = fts_system_reset();
+
+		if (ret < 0) {
+			logError(1,
+				 "%s production_test_main: system reset ERROR %08X\n",
+				 tag, ret);
+			res |= ret;
+
+			if (stop_on_fail)
+				goto END;
+		}
+
+		logError(0, "%s \n", tag);
+	}
+
+	logError(1, "%s PRODUCTION DATA TEST: \n", tag);
+	ret = production_test_data(pathThresholds, stop_on_fail, todo);
+
+	if (ret < 0) {
+		logError(0,
+			 "%s Error during PRODUCTION DATA TEST! ERROR %08X\n",
+			 tag, ret);
+	} else {
+		logError(0, "%s PRODUCTION DATA TEST OK!\n", tag);
+	}
+
+	res |= ret;
+END:
+
+	if (res < 0) {
+		logError(0,
+			 "%s MAIN Production test finished.................FAILED \n",
+			 tag);
+		return res;
+	} else {
+		logError(0,
+			 "%s MAIN Production test finished.................OK\n",
+			 tag);
+		return OK;
+	}
+}
+
+/**
+ * Perform all the test selected in a TestTodo variable related to MS raw data (touch, keys etc..)
+ * @param path_limits name of Production Limit file to load or "NULL" if the limits data should be loaded by a .h file
+ * @param stop_on_fail if 1, the test flow stops at the first data check failure otherwise it keeps going performing all the selected test
+ * @param todo pointer to a TestToDo variable which select the test to do
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int production_test_ms_raw(char *path_limits, int stop_on_fail, TestToDo *todo)
+{
+	int ret, count_fail = 0;
+	MutualSenseFrame msRawFrame;
+	int *thresholds = NULL;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	int trows, tcolumns;
+	u16 *adj = NULL;
+	/******************************* Mutual Sense Test *******************************/
+	logError(0, "%s \n", tag);
+
+	if (todo->MutualRaw == 1 || todo->MutualRawGap == 1
+	    || todo->MutualRawAdj == 1 || todo->MutualRawEachNode == 1) {
+		ret = setScanMode(SCAN_MODE_LOCKED, LOCKED_ACTIVE);
+		mdelay(WAIT_FOR_FRESH_FRAMES);
+		ret |= setScanMode(SCAN_MODE_ACTIVE, 0x00);
+		mdelay(WAIT_AFTER_SENSEOFF);
+		ret |= getMSFrame3(MS_RAW, &msRawFrame);
+
+		if (ret < OK) {
+			logError(1,
+				 "%s production_test_data: getMSFrame failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			return (ret | ERROR_PROD_TEST_DATA);
+		}
+
+
+		if (todo->MutualRaw == 1) {
+			logError(1, "%s MS RAW MIN MAX TEST:  \n", tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  MS_RAW_MIN_MAX,
+							  &thresholds, &trows,
+							  &tcolumns);
+
+			if (ret < OK || (trows != 1 || tcolumns != 2)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_RAW_MIN_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsMinMax(msRawFrame.node_data,
+						  msRawFrame.header.force_node,
+						  msRawFrame.header.sense_node,
+						  thresholds[0], thresholds[1]);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMinMax MS RAW failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s MS RAW MIN MAX TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS RAW MIN MAX TEST:.................OK  \n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			logError(0,
+				 "%s MS RAW MIN MAX TEST:.................SKIPPED  \n",
+				 tag);
+		if (todo->MutualRawEachNode == 1) {
+			logError(1, "%s MS RAW EACH NODE MIN MAX TEST:\n", tag);
+			ret = parseProductionTestLimits(path_limits, &limit_file, MS_RAW_EACH_NODE_MIN, &thresholds_min, &trows, &tcolumns);
+			if (ret < OK || (trows != msRawFrame.header.force_node || tcolumns != msRawFrame.header.sense_node)) {
+				logError(1, "%s production_test_data: parseProductionTestLimits MS_RAW_EACH_NODE_MIN failed... ERROR %08X\n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			ret = parseProductionTestLimits(path_limits, &limit_file, MS_RAW_EACH_NODE_MAX, &thresholds_max, &trows, &tcolumns);
+			if (ret < OK || (trows != msRawFrame.header.force_node ||
+					 tcolumns != msRawFrame.header.sense_node)) {
+				logError(1, "%s production_test_data: parseProductionTestLimits MS_RAW_EACH_NODE_MAX failed... ERROR %08X\n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			ret = checkLimitsMapTotal(msRawFrame.node_data, msRawFrame.header.force_node, msRawFrame.header.sense_node, thresholds_min, thresholds_max);
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMinMaxEachNodeData failed... ERROR COUNT = %d\n",
+					 tag, ret);
+				logError(0,
+					 "%s MS_RAW EACH NODE MIN MAX TEST:.................FAIL\n\n", tag);
+				count_fail += 1;
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else {
+				logError(0, "%s MS_RAW_EACH_NODE_MAX TEST:.................OK\n", tag);
+			}
+			if (thresholds_min != NULL) {
+				kfree(thresholds_min);
+				thresholds_min = NULL;
+			}
+			if (thresholds_max != NULL) {
+				kfree(thresholds_max);
+				thresholds_max = NULL;
+			}
+		} else {
+			logError(0, "%s MS RAW EACH NODE MIN MAX TEST:.................SKIPPED\n", tag);
+		}
+
+		logError(0, "%s \n", tag);
+
+		if (todo->MutualRawGap == 1) {
+			logError(1, "%s MS RAW GAP TEST: \n", tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  MS_RAW_GAP, &thresholds,
+							  &trows, &tcolumns);
+
+			if (ret < OK || (trows != 1 || tcolumns != 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_RAW_GAP failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsGap(msRawFrame.node_data,
+					       msRawFrame.header.force_node,
+					       msRawFrame.header.sense_node,
+					       thresholds[0]);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsGap MS RAW failed... ERROR = %08X \n",
+					 tag, ret);
+				count_fail += 1;
+
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS RAW GAP TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			logError(0,
+				 "%s MS RAW GAP TEST:.................SKIPPED  \n",
+				 tag);
+
+		logError(0, "%s \n", tag);
+
+		if (todo->MutualRawAdj == 1) {
+			logError(1, "%s MS RAW ADJ HORIZONTAL TEST: \n", tag);
+			ret =
+				computeAdjHorizTotal(msRawFrame.node_data,
+						     msRawFrame.header.force_node,
+						     msRawFrame.header.sense_node,
+						     &adj);
+
+			if (ret < OK) {
+				logError(1,
+					 "%s production_test_data: computeAdjHoriz failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  MS_RAW_ADJH, &thresholds,
+							  &trows, &tcolumns);
+
+			if (ret < OK
+			    || (trows != msRawFrame.header.force_node
+				|| tcolumns !=
+				msRawFrame.header.sense_node - 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_RAW_ADJH failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsMapAdjTotal(adj,
+						       msRawFrame.header.force_node,
+						       msRawFrame.header.
+						       sense_node - 1, thresholds);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsAdj MS RAW ADJH failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s MS RAW ADJ HORIZONTAL TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS RAW ADJ HORIZONTAL TEST:.................OK  \n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+			kfree(adj);
+			adj = NULL;
+			logError(0, "%s MS RAW ADJ VERTICAL TEST: \n", tag);
+			ret =
+				computeAdjVertTotal(msRawFrame.node_data,
+						    msRawFrame.header.force_node,
+						    msRawFrame.header.sense_node,
+						    &adj);
+
+			if (ret < OK) {
+				logError(1,
+					 "%s production_test_data: computeAdjVert failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  MS_RAW_ADJV, &thresholds,
+							  &trows, &tcolumns);
+
+			if (ret < OK
+			    || (trows != msRawFrame.header.force_node - 1
+				|| tcolumns != msRawFrame.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_RAW_ADJV failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsMapAdjTotal(adj,
+						       msRawFrame.header.
+						       force_node - 1,
+						       msRawFrame.header.sense_node,
+						       thresholds);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsAdj MS RAW ADJV failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s MS RAW ADJ VERTICAL TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS RAW ADJ VERTICAL TEST:.................OK  \n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+			kfree(adj);
+			adj = NULL;
+		} else
+			logError(0,
+				 "%s MS RAW ADJ TEST:.................SKIPPED  \n",
+				 tag);
+	} else
+		logError(0, "%s MS RAW FRAME TEST:.................SKIPPED  \n",
+			 tag);
+
+	logError(0, "%s \n", tag);
+
+	if (todo->MutualKeyRaw == 1) {
+		logError(1, "%s MS KEY RAW TEST:\n", tag);
+		ret = production_test_ms_key_raw(path_limits);
+
+		if (ret < 0) {
+			logError(1,
+				 "%s production_test_data: production_test_ms_key_raw failed... ERROR = %08X \n",
+				 tag, ret);
+			count_fail += 1;
+
+			if (count_fail == 1) {
+				logError(0,
+					 "%s MS RAW DATA TEST:.................FAIL fails_count = %d\n\n",
+					 tag, count_fail);
+				goto ERROR_LIMITS;
+			}
+		}
+	} else
+		logError(0, "%s MS KEY RAW TEST:.................SKIPPED  \n",
+			 tag);
+
+	ret = production_test_ms_raw_lp(path_limits, stop_on_fail, todo);
+
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: production_test_ms_raw_lp failed... ERROR = %08X \n",
+			 tag, ret);
+		count_fail += 1;
+
+		if (count_fail == 1) {
+			logError(0,
+				 "%s MS RAW DATA TEST:.................FAIL fails_count = %d\n\n",
+				 tag, count_fail);
+			goto ERROR_LIMITS;
+		}
+	}
+
+ERROR:
+	logError(0, "%s \n", tag);
+
+	if (count_fail == 0) {
+		if (msRawFrame.node_data != NULL) {
+			kfree(msRawFrame.node_data);
+			msRawFrame.node_data = NULL;
+		}
+
+		logError(0,
+			 "%s MS RAW DATA TEST finished!.................OK\n",
+			 tag);
+		return OK;
+	} else {
+		print_frame_short("MS Raw frame =",
+				  array1dTo2d_short(msRawFrame.node_data,
+						    msRawFrame.node_data_size,
+						    msRawFrame.header.
+						    sense_node),
+				  msRawFrame.header.force_node,
+				  msRawFrame.header.sense_node);
+
+		if (msRawFrame.node_data != NULL) {
+			kfree(msRawFrame.node_data);
+			msRawFrame.node_data = NULL;
+		}
+		if (thresholds != NULL) {
+			kfree(thresholds);
+			thresholds = NULL;
+		}
+		if (adj != NULL) {
+			kfree(adj);
+			adj = NULL;
+		}
+		logError(0,
+			 "%s MS RAW DATA TEST:.................FAIL fails_count = %d\n\n",
+			 tag, count_fail);
+		return (ERROR_PROD_TEST_DATA | ERROR_TEST_CHECK_FAIL);
+	}
+
+ERROR_LIMITS:
+
+	if (msRawFrame.node_data != NULL) {
+		kfree(msRawFrame.node_data);
+		msRawFrame.node_data = NULL;
+	}
+	if (thresholds != NULL) {
+		kfree(thresholds);
+		thresholds = NULL;
+	}
+	return ret;
+}
+
+/**
+ * Perform all the test selected in a TestTodo variable related to MS low power raw data
+ * @param path_limits name of Production Limit file to load or "NULL" if the limits data should be loaded by a .h file
+ * @param stop_on_fail if 1, the test flow stops at the first data check failure otherwise it keeps going performing all the selected test
+ * @param todo pointer to a TestToDo variable which select the test to do
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int production_test_ms_raw_lp(char *path_limits, int stop_on_fail,
+			      TestToDo *todo)
+{
+	int ret, count_fail = 0;
+	MutualSenseFrame msRawFrame;
+	int *thresholds = NULL;
+	int trows, tcolumns;
+	u16 *adj = NULL;
+	memset(&msRawFrame, 0x00, sizeof(msRawFrame));
+	/******************************* Mutual Sense Test *******************************/
+	logError(0, "%s \n", tag);
+
+	if (todo->MutualRawLP == 1 || todo->MutualRawGapLP == 1
+	    || todo->MutualRawAdjLP == 1) {
+		ret = setScanMode(SCAN_MODE_LOCKED, LOCKED_LP_ACTIVE);
+		mdelay(WAIT_FOR_FRESH_FRAMES);
+		ret |= setScanMode(SCAN_MODE_ACTIVE, 0x00);
+		mdelay(WAIT_AFTER_SENSEOFF);
+		ret |= getMSFrame3(MS_RAW, &msRawFrame);
+
+		if (ret < 0) {
+			logError(1,
+				 "%s production_test_data: getMSFrame failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			return (ret | ERROR_PROD_TEST_DATA);
+		}
+
+
+		if (todo->MutualRawLP == 1) {
+			logError(1, "%s MS RAW LP MIN MAX TEST:  \n", tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  MS_RAW_LP_MIN_MAX,
+							  &thresholds, &trows,
+							  &tcolumns);
+
+			if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_RAW_LP_MIN_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsMinMax(msRawFrame.node_data,
+						  msRawFrame.header.force_node,
+						  msRawFrame.header.sense_node,
+						  thresholds[0], thresholds[1]);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMinMax MS RAW LP failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s MS RAW LP MIN MAX TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS RAW LP MIN MAX TEST:.................OK  \n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			logError(0,
+				 "%s MS RAW LP MIN MAX TEST:.................SKIPPED  \n",
+				 tag);
+
+		logError(0, "%s \n", tag);
+
+		if (todo->MutualRawGapLP == 1) {
+			logError(1, "%s MS RAW LP GAP TEST: \n", tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  MS_RAW_LP_GAP,
+							  &thresholds, &trows,
+							  &tcolumns);
+
+			if (ret < 0 || (trows != 1 || tcolumns != 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_RAW_LP_GAP failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsGap(msRawFrame.node_data,
+					       msRawFrame.header.force_node,
+					       msRawFrame.header.sense_node,
+					       thresholds[0]);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsGap MS RAW LP failed... ERROR = %08X \n",
+					 tag, ret);
+				count_fail += 1;
+
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS RAW LP GAP TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			logError(0,
+				 "%s MS RAW LP GAP TEST:.................SKIPPED  \n",
+				 tag);
+
+		logError(0, "%s \n", tag);
+
+		if (todo->MutualRawAdjLP == 1) {
+			logError(1, "%s MS RAW LP ADJ HORIZONTAL TEST: \n",
+				 tag);
+			ret =
+				computeAdjHorizTotal(msRawFrame.node_data,
+						     msRawFrame.header.force_node,
+						     msRawFrame.header.sense_node,
+						     &adj);
+
+			if (ret < 0) {
+				logError(1,
+					 "%s production_test_data: computeAdjHoriz failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  MS_RAW_LP_ADJH,
+							  &thresholds, &trows,
+							  &tcolumns);
+
+			if (ret < 0
+			    || (trows != msRawFrame.header.force_node
+				|| tcolumns !=
+				msRawFrame.header.sense_node - 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_RAW_LP_ADJH failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsMapAdjTotal(adj,
+						       msRawFrame.header.force_node,
+						       msRawFrame.header.
+						       sense_node - 1, thresholds);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsAdj MS RAW LP ADJH failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s MS RAW LP ADJ HORIZONTAL TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS RAW LP ADJ HORIZONTAL TEST:.................OK  \n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+			kfree(adj);
+			adj = NULL;
+			logError(0, "%s MS RAW LP ADJ VERTICAL TEST: \n", tag);
+			ret =
+				computeAdjVertTotal(msRawFrame.node_data,
+						    msRawFrame.header.force_node,
+						    msRawFrame.header.sense_node,
+						    &adj);
+
+			if (ret < 0) {
+				logError(1,
+					 "%s production_test_data: computeAdjVert failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  MS_RAW_LP_ADJV,
+							  &thresholds, &trows,
+							  &tcolumns);
+
+			if (ret < 0
+			    || (trows != msRawFrame.header.force_node - 1
+				|| tcolumns != msRawFrame.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_RAW_ADJV failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsMapAdjTotal(adj,
+						       msRawFrame.header.
+						       force_node - 1,
+						       msRawFrame.header.sense_node,
+						       thresholds);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsAdj MS RAW ADJV failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s MS RAW LP ADJ VERTICAL TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS RAW LP ADJ VERTICAL TEST:.................OK  \n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+			kfree(adj);
+			adj = NULL;
+		} else
+			logError(0,
+				 "%s MS RAW LP ADJ TEST:.................SKIPPED  \n",
+				 tag);
+	} else
+		logError(0,
+			 "%s MS RAW LP FRAME TEST:.................SKIPPED  \n",
+			 tag);
+
+ERROR:
+	logError(0, "%s \n", tag);
+
+	if (count_fail == 0) {
+		if (msRawFrame.node_data != NULL) {
+			kfree(msRawFrame.node_data);
+			msRawFrame.node_data = NULL;
+		}
+
+		logError(0,
+			 "%s MS RAW DATA TEST finished!.................OK\n",
+			 tag);
+		return OK;
+	} else {
+		if (msRawFrame.node_data != NULL) {
+			print_frame_short("MS Raw LP frame =",
+					  array1dTo2d_short
+					  (msRawFrame.node_data,
+					   msRawFrame.node_data_size,
+					   msRawFrame.header.sense_node),
+					  msRawFrame.header.force_node,
+					  msRawFrame.header.sense_node);
+			kfree(msRawFrame.node_data);
+			msRawFrame.node_data = NULL;
+		}
+
+		if (thresholds != NULL) {
+			kfree(thresholds);
+			thresholds = NULL;
+		}
+		if (adj != NULL) {
+			kfree(adj);
+			adj = NULL;
+		}
+		logError(0,
+			 "%s MS RAW LP DATA TEST:.................FAIL fails_count = %d\n\n",
+			 tag, count_fail);
+		return (ERROR_PROD_TEST_DATA | ERROR_TEST_CHECK_FAIL);
+	}
+
+ERROR_LIMITS:
+
+	if (msRawFrame.node_data != NULL) {
+		kfree(msRawFrame.node_data);
+		msRawFrame.node_data = NULL;
+	}
+	if (thresholds != NULL) {
+		kfree(thresholds);
+		thresholds = NULL;
+	}
+	return ret;
+}
+
+/**
+ * Perform MS raw test for keys data
+ * @param path_limits name of Production Limit file to load or "NULL" if the limits data should be loaded by a .h file
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int production_test_ms_key_raw(char *path_limits)
+{
+	int ret;
+	MutualSenseFrame msRawFrame;
+	int *thresholds = NULL;
+	int trows, tcolumns;
+	/******************************* Mutual Sense Test *******************************/
+	logError(1, "%s MS KEY RAW DATA TEST is starting...\n", tag);
+	ret = setScanMode(SCAN_MODE_ACTIVE, 0x01);
+	mdelay(WAIT_FOR_FRESH_FRAMES);
+	ret |= setScanMode(SCAN_MODE_ACTIVE, 0x00);
+	mdelay(WAIT_AFTER_SENSEOFF);
+	ret |= getMSFrame3(MS_KEY_RAW, &msRawFrame);
+
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: getMSKeyFrame failed... ERROR %08X \n",
+			 tag, ERROR_PROD_TEST_DATA);
+		return (ret | ERROR_PROD_TEST_DATA);
+	}
+
+	ret =
+		parseProductionTestLimits(path_limits, &limit_file,
+					  MS_KEY_RAW_MIN_MAX, &thresholds, &trows,
+					  &tcolumns);
+
+	if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+		logError(1,
+			 "%s production_test_data: parseProductionTestLimits MS_KEY_RAW_MIN_MAX failed... ERROR %08X \n",
+			 tag, ERROR_PROD_TEST_DATA);
+		ret |= ERROR_PROD_TEST_DATA;
+		goto ERROR_LIMITS;
+	}
+
+	ret =
+		checkLimitsMinMax(msRawFrame.node_data,
+				  msRawFrame.header.force_node,
+				  msRawFrame.header.sense_node, thresholds[0],
+				  thresholds[1]);
+
+	if (ret != OK) {
+		logError(1,
+			 "%s production_test_data: checkLimitsMinMax MS KEY RAW failed... ERROR COUNT = %d \n",
+			 tag, ret);
+		goto ERROR;
+	} else
+		logError(0, "%s MS KEY RAW TEST:.................OK \n\n", tag);
+
+	kfree(thresholds);
+	thresholds = NULL;
+	kfree(msRawFrame.node_data);
+	msRawFrame.node_data = NULL;
+	return OK;
+ERROR:
+	print_frame_short("MS Key Raw frame =",
+			  array1dTo2d_short(msRawFrame.node_data,
+					    msRawFrame.node_data_size,
+					    msRawFrame.header.sense_node),
+			  msRawFrame.header.force_node,
+			  msRawFrame.header.sense_node);
+
+	if (msRawFrame.node_data != NULL) {
+		kfree(msRawFrame.node_data);
+		msRawFrame.node_data = NULL;
+	}
+	if (thresholds != NULL) {
+		kfree(thresholds);
+		thresholds = NULL;
+	}
+	logError(0, "%s MS KEY RAW TEST:.................FAIL \n\n", tag);
+	return (ERROR_PROD_TEST_DATA | ERROR_TEST_CHECK_FAIL);
+ERROR_LIMITS:
+
+	if (msRawFrame.node_data != NULL) {
+		kfree(msRawFrame.node_data);
+		msRawFrame.node_data = NULL;
+	}
+	if (thresholds != NULL) {
+		kfree(thresholds);
+		thresholds = NULL;
+	}
+	return ret;
+}
+
+/**
+ * Perform all the tests selected in a TestTodo variable related to MS Init data (touch, keys etc..)
+ * @param path_limits name of Production Limit file to load or "NULL" if the limits data should be loaded by a .h file
+ * @param stop_on_fail if 1, the test flow stops at the first data check failure otherwise it keeps going performing all the selected test
+ * @param todo pointer to a TestToDo variable which select the test to do
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int production_test_ms_cx(char *path_limits, int stop_on_fail, TestToDo *todo)
+{
+	int ret;
+	int count_fail = 0;
+	int *thresholds = NULL;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	int trows, tcolumns;
+	MutualSenseData msCompData;
+	TotMutualSenseData totCompData;
+	u8 *adjhor = NULL;
+	u8 *adjvert = NULL;
+	u16 container;
+	u16 *total_adjhor = NULL;
+	u16 *total_adjvert = NULL;
+	logError(0, "%s \n", tag);
+	ret = readMutualSenseCompensationData(LOAD_CX_MS_TOUCH, &msCompData);
+
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: readMutualSenseCompensationData failed... ERROR %08X \n",
+			 tag, ERROR_PROD_TEST_DATA);
+		return (ret | ERROR_PROD_TEST_DATA);
+	}
+
+	ret =
+		readTotMutualSenseCompensationData(LOAD_PANEL_CX_TOT_MS_TOUCH,
+				&totCompData);
+
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: readTotMutualSenseCompensationData failed... ERROR %08X \n",
+			 tag, ERROR_PROD_TEST_DATA);
+		kfree(msCompData.node_data);
+		msCompData.node_data = NULL;
+		return (ret | ERROR_PROD_TEST_DATA);
+	}
+
+
+	if (todo->MutualCx1 == 1) {
+		logError(1, "%s MS CX1 TEST: \n", tag);
+		ret =
+			parseProductionTestLimits(path_limits, &limit_file,
+						  MS_CX1_MIN_MAX, &thresholds,
+						  &trows, &tcolumns);
+
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_CX1_MIN_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (u16) msCompData.cx1;
+		ret =
+			checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					  thresholds[1]);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMinMax MS CX1 failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0, "%s MS CX1 TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0, "%s MS CX1 TEST:.................OK \n\n",
+				 tag);
+	} else
+		logError(0, "%s MS CX1 TEST:.................SKIPPED \n\n",
+			 tag);
+
+	kfree(thresholds);
+	thresholds = NULL;
+
+	if (todo->MutualCx2 == 1) {
+		logError(1, "%s MS CX2 MIN MAX TEST: \n", tag);
+		ret = parseProductionTestLimits(path_limits, &limit_file, MS_CX2_MAP_MIN, &thresholds_min, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != msCompData.header.force_node
+			|| tcolumns != msCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_CX2_MAP_MIN failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(path_limits, &limit_file, MS_CX2_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != msCompData.header.force_node
+			|| tcolumns != msCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_CX2_MAP_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMap(msCompData.node_data, msCompData.header.force_node, msCompData.header.sense_node, thresholds_min, thresholds_max);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMap MS CX2 MIN MAX failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s MS CX2 MIN MAX TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s MS CX2 MIN MAX TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		logError(0,
+			 "%s MS CX2 MIN MAX TEST:.................SKIPPED \n\n",
+			 tag);
+
+
+	if (todo->MutualCx2Adj == 1) {
+		logError(1, "%s MS CX2 ADJ TEST: \n", tag);
+		ret =
+			computeAdjHoriz(msCompData.node_data,
+					msCompData.header.force_node,
+					msCompData.header.sense_node, &adjhor);
+
+		if (ret < 0) {
+			logError(1,
+				 "%s production_test_data: computeAdjHoriz failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		logError(0, "%s MS CX2 ADJ HORIZ computed! \n", tag);
+		ret =
+			parseProductionTestLimits(path_limits, &limit_file,
+						  MS_CX2_ADJH_MAP_MAX,
+						  &thresholds_max, &trows,
+						  &tcolumns);
+
+		if (ret < 0
+		    || (trows != msCompData.header.force_node
+			|| tcolumns != msCompData.header.sense_node - 1)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_CX2_ADJH_MAP_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret =
+			checkLimitsMapAdj(adjhor, msCompData.header.force_node,
+					  msCompData.header.sense_node - 1,
+					  thresholds_max);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMapAdj CX2 ADJH failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s MS CX2 ADJ HORIZ TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s MS CX2 ADJ HORIZ TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjhor);
+		adjhor = NULL;
+		logError(0, "%s MS CX2 ADJ VERT TEST: \n", tag);
+		ret =
+			computeAdjVert(msCompData.node_data,
+				       msCompData.header.force_node,
+				       msCompData.header.sense_node, &adjvert);
+
+		if (ret < 0) {
+			logError(1,
+				 "%s production_test_data: computeAdjVert failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		logError(0, "%s MS CX2 ADJ VERT computed! \n", tag);
+		ret =
+			parseProductionTestLimits(path_limits, &limit_file,
+						  MS_CX2_ADJV_MAP_MAX,
+						  &thresholds_max, &trows,
+						  &tcolumns);
+
+		if (ret < 0
+		    || (trows != msCompData.header.force_node - 1
+			|| tcolumns != msCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_CX2_ADJV_MAP_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret =
+			checkLimitsMapAdj(adjvert, msCompData.header.force_node - 1,
+					  msCompData.header.sense_node - 1,
+					  thresholds_max);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMapAdj CX2 ADJV failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s MS CX2 ADJ HORIZ TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s MS CX2 ADJ VERT TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjvert);
+		adjvert = NULL;
+	} else
+		logError(0, "%s MS CX2 ADJ TEST:.................SKIPPED \n\n",
+			 tag);
+
+
+	if (todo->MutualCxTotal == 1 || todo->MutualCxTotalAdj == 1) {
+
+		if (todo->MutualCxTotal == 1) {
+			logError(1, "%s MS TOTAL CX MIN MAX TEST: \n", tag);
+			ret = parseProductionTestLimits(path_limits, &limit_file, MS_TOTAL_CX_MAP_MIN, &thresholds_min, &trows, &tcolumns);
+
+			if (ret < 0
+			    || (trows != totCompData.header.force_node
+				|| tcolumns != totCompData.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_TOTAL_CX_MAP_MIN failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(path_limits, &limit_file, MS_TOTAL_CX_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+			if (ret < 0
+			    || (trows != totCompData.header.force_node
+				|| tcolumns != totCompData.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_TOTAL_CX_MAP_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(totCompData.node_data, totCompData.header.force_node, totCompData.header.sense_node, thresholds_min, thresholds_max);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMap  MS TOTAL CX TEST failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s MS TOTAL CX MIN MAX TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS TOTAL CX MIN MAX TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			logError(0,
+				 "%s MS TOTAL CX MIN MAX TEST:.................SKIPPED \n\n",
+				 tag);
+
+
+		if (todo->MutualCxTotalAdj == 1) {
+			logError(1, "%s MS TOTAL CX ADJ HORIZ TEST: \n", tag);
+			ret =
+				computeAdjHorizTotal(totCompData.node_data,
+						     totCompData.header.force_node,
+						     totCompData.header.sense_node,
+						     &total_adjhor);
+
+			if (ret < 0) {
+				logError(1,
+					 "%s production_test_data: computeAdjHoriz failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			logError(0, "%s MS TOTAL CX ADJ HORIZ computed! \n",
+				 tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  MS_TOTAL_CX_ADJH_MAP_MAX,
+							  &thresholds_max, &trows,
+							  &tcolumns);
+
+			if (ret < 0
+			    || (trows != totCompData.header.force_node
+				|| tcolumns !=
+				totCompData.header.sense_node - 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_TOTAL_CX_ADJH_MAP_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsMapAdjTotal(total_adjhor,
+						       totCompData.header.
+						       force_node,
+						       totCompData.header.
+						       sense_node - 1,
+						       thresholds_max);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMapAdj MS TOTAL CX ADJH failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s MS TOTAL CX ADJ HORIZ TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS TOTAL CX ADJ HORIZ TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjhor);
+			total_adjhor = NULL;
+			logError(0, "%s MS TOTAL CX ADJ VERT TEST: \n", tag);
+			ret =
+				computeAdjVertTotal(totCompData.node_data,
+						    totCompData.header.force_node,
+						    totCompData.header.sense_node,
+						    &total_adjvert);
+
+			if (ret < 0) {
+				logError(1,
+					 "%s production_test_data: computeAdjVert failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			logError(0, "%s MS TOTAL CX ADJ VERT computed! \n",
+				 tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  MS_TOTAL_CX_ADJV_MAP_MAX,
+							  &thresholds_max, &trows,
+							  &tcolumns);
+
+			if (ret < 0
+			    || (trows != totCompData.header.force_node - 1
+				|| tcolumns != totCompData.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_TOTAL_CX_ADJV_MAP_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsMapAdjTotal(total_adjvert,
+						       totCompData.header.
+						       force_node - 1,
+						       totCompData.header.
+						       sense_node - 1,
+						       thresholds_max);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMapAdj MS TOTAL CX ADJV failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s MS TOTAL CX ADJ HORIZ TEST:.................FAIL \n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS TOTAL CX ADJ VERT TEST:.................OK \n",
+					 tag);
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjvert);
+			total_adjvert = NULL;
+		} else
+			logError(0,
+				 "%s MS TOTAL CX ADJ TEST:.................SKIPPED \n",
+				 tag);
+
+		kfree(totCompData.node_data);
+		totCompData.node_data = NULL;
+	} else
+		logError(0, "%s MS TOTAL CX TEST:.................SKIPPED \n",
+			 tag);
+
+	if ((todo->MutualCx1LP | todo->MutualCx2LP | todo->MutualCx2AdjLP |
+	     todo->MutualCxTotalLP | todo->MutualCxTotalAdjLP) == 1) {
+		ret = production_test_ms_cx_lp(path_limits, stop_on_fail, todo);
+		if (ret < OK) {
+			count_fail += 1;
+			logError(1,
+				 "%s production_test_data: production_test_cx_lp failed... ERROR = %08X\n",
+				 tag, ret);
+			logError(0,
+				 "%s MS CX testes finished!.................FAILED  fails_count = %d\n\n",
+				 tag, count_fail);
+			return ret;
+		}
+	} else
+		logError(0, "%s MS KEY CX TEST:.................SKIPPED\n",
+			 tag);
+
+	if ((todo->MutualKeyCx1 |
+	     todo->MutualKeyCx2 | todo->MutualKeyCxTotal) == 1) {
+		ret =
+			production_test_ms_key_cx(path_limits, stop_on_fail, todo);
+
+		if (ret < 0) {
+			count_fail += 1;
+			logError(1,
+				 "%s production_test_data: production_test_ms_key_cx failed... ERROR = %08X \n",
+				 tag, ret);
+			logError(0,
+				 "%s MS CX testes finished!.................FAILED  fails_count = %d\n\n",
+				 tag, count_fail);
+			return ret;
+		}
+	} else
+		logError(0, "%s MS KEY CX TEST:.................SKIPPED \n",
+			 tag);
+
+ERROR:
+	logError(0, "%s \n", tag);
+
+	if (count_fail == 0) {
+		logError(0, "%s MS CX testes finished!.................OK\n",
+			 tag);
+		kfree(msCompData.node_data);
+		msCompData.node_data = NULL;
+		return OK;
+	} else {
+		print_frame_i8("MS Init Data (Cx2) =",
+			       array1dTo2d_i8(msCompData.node_data,
+					      msCompData.node_data_size,
+					      msCompData.header.sense_node),
+			       msCompData.header.force_node,
+			       msCompData.header.sense_node);
+		print_frame_short(" TOT MS Init Data (Cx) =",
+				  array1dTo2d_short(totCompData.node_data,
+						    totCompData.node_data_size,
+						    totCompData.header.
+						    sense_node),
+				  totCompData.header.force_node,
+				  totCompData.header.sense_node);
+		logError(0,
+			 "%s MS CX testes finished!.................FAILED  fails_count = %d\n\n",
+			 tag, count_fail);
+
+		if (thresholds != NULL) {
+			kfree(thresholds);
+			thresholds = NULL;
+		}
+		if (thresholds_min != NULL) {
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+		}
+		if (thresholds_max != NULL) {
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		}
+		if (adjhor != NULL) {
+			kfree(adjhor);
+			adjhor = NULL;
+		}
+		if (adjvert != NULL) {
+			kfree(adjvert);
+			adjvert = NULL;
+		}
+		if (totCompData.node_data != NULL) {
+			kfree(totCompData.node_data);
+			totCompData.node_data = NULL;
+		}
+		if (total_adjhor != NULL) {
+			kfree(total_adjhor);
+			total_adjhor = NULL;
+		}
+		if (total_adjvert != NULL) {
+			kfree(total_adjvert);
+			total_adjvert = NULL;
+		}
+		if (msCompData.node_data != NULL) {
+			kfree(msCompData.node_data);
+			msCompData.node_data = NULL;
+		}
+		return (ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA);
+	}
+
+ERROR_LIMITS:
+
+	if (thresholds != NULL) {
+		kfree(thresholds);
+		thresholds = NULL;
+	}
+	if (thresholds_min != NULL) {
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+	}
+	if (thresholds_max != NULL) {
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	}
+	if (adjhor != NULL) {
+		kfree(adjhor);
+		adjhor = NULL;
+	}
+	if (adjvert != NULL) {
+		kfree(adjvert);
+		adjvert = NULL;
+	}
+	if (totCompData.node_data != NULL) {
+		kfree(totCompData.node_data);
+		totCompData.node_data = NULL;
+	}
+	if (total_adjhor != NULL) {
+		kfree(total_adjhor);
+		total_adjhor = NULL;
+	}
+	if (total_adjvert != NULL) {
+		kfree(total_adjvert);
+		total_adjvert = NULL;
+	}
+	if (msCompData.node_data != NULL) {
+		kfree(msCompData.node_data);
+		msCompData.node_data = NULL;
+	}
+	return ret;
+}
+
+/**
+ * Perform all the tests selected in a TestTodo variable related to MS Init data of the keys
+ * @param path_limits name of Production Limit file to load or "NULL" if the limits data should be loaded by a .h file
+ * @param stop_on_fail if 1, the test flow stops at the first data check failure otherwise it keeps going performing all the selected test
+ * @param todo pointer to a TestToDo variable which select the test to do
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int production_test_ms_key_cx(char *path_limits, int stop_on_fail,
+			      TestToDo *todo)
+{
+	int ret;
+	int count_fail = 0;
+	int num_keys = 0;
+	int *thresholds = NULL;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	int trows, tcolumns;
+	MutualSenseData msCompData;
+	TotMutualSenseData totCompData;
+	short container;
+	ret = readMutualSenseCompensationData(LOAD_CX_MS_KEY, &msCompData);
+
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: readMutualSenseCompensationData failed... ERROR %08X \n",
+			 tag, ERROR_PROD_TEST_DATA);
+		return (ret | ERROR_PROD_TEST_DATA);
+	}
+
+	if (msCompData.header.force_node > msCompData.header.sense_node)
+		num_keys = msCompData.header.force_node;
+	else
+		num_keys = msCompData.header.sense_node;
+
+
+	if (todo->MutualKeyCx1 == 1) {
+		logError(1, "%s MS KEY CX1 TEST: \n", tag);
+		ret =
+			parseProductionTestLimits(path_limits, &limit_file,
+						  MS_KEY_CX1_MIN_MAX, &thresholds,
+						  &trows, &tcolumns);
+
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_KEY_CX1_MIN_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (short)msCompData.cx1;
+		ret =
+			checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					  thresholds[1]);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMinMax MS CX1 failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s MS KEY CX1 TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s MS KEY CX1 TEST:.................OK \n\n",
+				 tag);
+	} else
+		logError(0, "%s MS KEY CX1 TEST:.................SKIPPED \n\n",
+			 tag);
+
+	kfree(thresholds);
+	thresholds = NULL;
+
+	if (todo->MutualKeyCx2 == 1) {
+		logError(1, "%s MS KEY CX2 TEST: \n", tag);
+		ret = parseProductionTestLimits(path_limits, &limit_file, MS_KEY_CX2_MAP_MIN, &thresholds_min, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != msCompData.header.force_node
+			|| tcolumns != msCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_KEY_CX2_MAP_MIN failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(path_limits, &limit_file, MS_KEY_CX2_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != msCompData.header.force_node
+			|| tcolumns != msCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_KEY_CX2_MAP_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMap(msCompData.node_data, msCompData.header.force_node, msCompData.header.sense_node, thresholds_min, thresholds_max);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMap MS KEY CX2 failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s MS KEY CX2 TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s MS KEY CX2 TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		logError(0, "%s MS CX2 TEST:.................SKIPPED \n\n",
+			 tag);
+
+
+	if (todo->MutualKeyCxTotal == 1) {
+		logError(1, "%s MS KEY TOTAL CX TEST: \n", tag);
+		ret =
+			readTotMutualSenseCompensationData(LOAD_PANEL_CX_TOT_MS_KEY,
+					&totCompData);
+
+		if (ret < 0) {
+			logError(1,
+				 "%s production_test_data: computeTotalCx failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(path_limits, &limit_file, MS_KEY_TOTAL_CX_MAP_MIN, &thresholds_min, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != totCompData.header.force_node
+			|| tcolumns != totCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_KEY_TOTAL_CX_MAP_MIN failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(path_limits, &limit_file, MS_KEY_TOTAL_CX_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != totCompData.header.force_node
+			|| tcolumns != totCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_KEY_TOTAL_CX_MAP_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapTotal(totCompData.node_data, totCompData.header.force_node, totCompData.header.sense_node, thresholds_min, thresholds_max);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMap  MS TOTAL KEY CX TEST failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s MS KEY TOTAL CX TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s MS KEY TOTAL CX TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(totCompData.node_data);
+		totCompData.node_data = NULL;
+	} else
+		logError(0,
+			 "%s MS KEY TOTAL CX TEST:.................SKIPPED \n",
+			 tag);
+
+ERROR:
+	logError(0, "%s \n", tag);
+
+	if (count_fail == 0) {
+		logError(0,
+			 "%s MS KEY CX testes finished!.................OK\n",
+			 tag);
+		kfree(msCompData.node_data);
+		msCompData.node_data = NULL;
+		return OK;
+	} else {
+		print_frame_i8("MS Key Init Data (Cx2) =",
+			       array1dTo2d_i8(msCompData.node_data,
+					      msCompData.node_data_size,
+					      msCompData.header.sense_node),
+			       msCompData.header.force_node,
+			       msCompData.header.sense_node);
+		logError(0,
+			 "%s MS Key CX testes finished!.................FAILED  fails_count = %d\n\n",
+			 tag, count_fail);
+
+		if (thresholds != NULL) {
+			kfree(thresholds);
+			thresholds = NULL;
+		}
+		if (thresholds_min != NULL) {
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+		}
+		if (thresholds_max != NULL) {
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		}
+		if (msCompData.node_data != NULL) {
+			kfree(msCompData.node_data);
+			msCompData.node_data = NULL;
+		}
+		if (totCompData.node_data != NULL) {
+			kfree(totCompData.node_data);
+			totCompData.node_data = NULL;
+		}
+		return (ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA);
+	}
+
+ERROR_LIMITS:
+
+	if (thresholds != NULL) {
+		kfree(thresholds);
+		thresholds = NULL;
+	}
+	if (thresholds_min != NULL) {
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+	}
+	if (thresholds_max != NULL) {
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	}
+	if (msCompData.node_data != NULL) {
+		kfree(msCompData.node_data);
+		msCompData.node_data = NULL;
+	}
+	if (totCompData.node_data != NULL) {
+		kfree(totCompData.node_data);
+		totCompData.node_data = NULL;
+	}
+	return ret;
+}
+
+/**
+  * Perform all the tests selected in a TestTodo variable related to MS LowPower
+  * Init data (touch, keys etc..)
+  * @param path_limits name of Production Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @param stop_on_fail if 1, the test flow stops at the first data check
+  * failure otherwise it keeps going performing all the selected test
+  * @param todo pointer to a TestToDo variable which select the test to do
+  * @return OK if success or an error code which specify the type of error
+  */
+int production_test_ms_cx_lp(char *path_limits, int stop_on_fail, TestToDo *todo)
+{
+	int ret;
+	int count_fail = 0;
+
+	int *thresholds = NULL;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	int trows, tcolumns;
+
+	MutualSenseData msCompData;
+	TotMutualSenseData totCompData;
+
+	u8 *adjhor = NULL;
+
+	u8 *adjvert = NULL;
+
+	u16 container;
+	/* u16 *total_cx = NULL; */
+	u16 *total_adjhor = NULL;
+	u16 *total_adjvert = NULL;
+
+
+	/* MS CX TEST */
+	logError(0, "%s\n", tag);
+
+	ret = readMutualSenseCompensationData(LOAD_CX_MS_LOW_POWER, &msCompData);
+	/* read MS compensation data */
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: readMutualSenseCompensationData failed... ERROR %08X\n",
+			 tag, ERROR_PROD_TEST_DATA);
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	ret = readTotMutualSenseCompensationData(LOAD_PANEL_CX_TOT_MS_LOW_POWER,
+						 &totCompData);
+	/* read  TOT MS compensation data */
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: readTotMutualSenseCompensationData failed... ERROR %08X\n",
+			 tag, ERROR_PROD_TEST_DATA);
+		kfree(msCompData.node_data);
+		msCompData.node_data = NULL;
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	if (todo->MutualCx1LP == 1) {
+		logError(1, "%s MS LP CX1 TEST:\n", tag);
+		ret = parseProductionTestLimits(path_limits, &limit_file,
+						MS_CX1_LP_MIN_MAX, &thresholds,
+						&trows, &tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_CX1_LP_MIN_MAX failed... ERROR %08X\n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (u16)msCompData.cx1;
+		ret = checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					thresholds[1]);
+		/* check the limits */
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMinMax MS LP CX1 failed... ERROR COUNT = %d\n",
+				 tag, ret);
+			logError(0, "%s MS LP CX1 TEST:.................FAIL\n\n",
+				 tag);
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0, "%s MS LP CX1 TEST:.................OK\n\n",
+				 tag);
+	} else
+		logError(0, "%s MS LP CX1 TEST:.................SKIPPED\n\n",
+			 tag);
+
+	kfree(thresholds);
+	thresholds = NULL;
+
+	if (todo->MutualCx2LP == 1) {
+		logError(1, "%s MS LP CX2 MIN MAX TEST:\n", tag);
+		ret = parseProductionTestLimits(path_limits, &limit_file,
+						MS_CX2_LP_MAP_MIN, &thresholds_min,
+						&trows, &tcolumns);
+						/* load min thresholds */
+		if (ret < 0 || (trows != msCompData.header.force_node ||
+				tcolumns != msCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_CX2_LP_MAP_MIN failed... ERROR %08X\n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(path_limits, &limit_file,
+						MS_CX2_LP_MAP_MAX, &thresholds_max,
+						&trows, &tcolumns);
+						/* load max thresholds */
+		if (ret < 0 || (trows != msCompData.header.force_node ||
+				tcolumns != msCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_CX2_LP_MAP_MAX failed... ERROR %08X\n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMap(msCompData.node_data,
+				     msCompData.header.force_node,
+				     msCompData.header.sense_node,
+				     thresholds_min, thresholds_max);
+					 /* check the limits */
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMap MS LP CX2 MIN MAX failed... ERROR COUNT = %d\n",
+				 tag, ret);
+			logError(0,
+				 "%s MS LP CX2 MIN MAX TEST:.................FAIL\n\n",
+				 tag);
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s MS LP CX2 MIN MAX TEST:.................OK\n\n",
+				 tag);
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		logError(0,
+			 "%s MS LP CX2 MIN MAX TEST:.................SKIPPED\n\n",
+			 tag);
+
+	if (todo->MutualCx2AdjLP == 1) {
+		logError(1, "%s MS LP CX2 ADJ TEST:\n", tag);
+		/* MS CX2 ADJ HORIZ */
+		logError(0, "%s MS LP CX2 ADJ HORIZ TEST:\n", tag);
+
+		ret = computeAdjHoriz(msCompData.node_data,
+				      msCompData.header.force_node,
+				      msCompData.header.sense_node,
+				      &adjhor);
+		if (ret < 0) {
+			logError(1,
+				 "%s production_test_data: computeAdjHoriz failed... ERROR %08X\n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		logError(0, "%s MS LP CX2 ADJ HORIZ computed!\n", tag);
+
+		ret = parseProductionTestLimits(path_limits, &limit_file,
+						MS_CX2_ADJH_LP_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		if (ret < 0 || (trows != msCompData.header.force_node ||
+				tcolumns != msCompData.header.sense_node - 1)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_CX2_ADJH_LP_MAP_MAX failed... ERROR %08X\n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjhor, msCompData.header.force_node,
+					msCompData.header.sense_node - 1,
+					thresholds_max);
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMapAdj CX2 ADJH LP failed... ERROR COUNT = %d\n",
+				 tag, ret);
+			logError(0,
+				 "%s MS LP CX2 ADJ HORIZ TEST:.................FAIL\n\n",
+				 tag);
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s MS LP CX2 ADJ HORIZ TEST:.................OK\n\n",
+				 tag);
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjhor);
+		adjhor = NULL;
+
+		/* MS CX2 ADJ VERT */
+		logError(0, "%s MS LP CX2 ADJ VERT TEST:\n", tag);
+
+		ret = computeAdjVert(msCompData.node_data,
+				     msCompData.header.force_node,
+				     msCompData.header.sense_node,
+				     &adjvert);
+		if (ret < 0) {
+			logError(1,
+				 "%s production_test_data: computeAdjVert failed... ERROR %08X\n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		logError(0, "%s MS LP CX2 ADJ VERT computed!\n", tag);
+
+		ret = parseProductionTestLimits(path_limits, &limit_file,
+						MS_CX2_ADJV_LP_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		if (ret < 0 || (trows != msCompData.header.force_node - 1 ||
+				tcolumns != msCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits MS_CX2_ADJV_LP_MAP_MAX failed... ERROR %08X\n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjvert, msCompData.header.force_node -
+					1, msCompData.header.sense_node - 1,
+					thresholds_max);
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMapAdj CX2 ADJV LP failed... ERROR COUNT = %d\n",
+				 tag, ret);
+			logError(0,
+				 "%s MS LP CX2 ADJ HORIZ TEST:.................FAIL\n\n",
+				 tag);
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s MS LP CX2 ADJ VERT TEST:.................OK\n\n",
+				 tag);
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjvert);
+		adjvert = NULL;
+	} else
+		logError(0, "%s MS LP CX2 ADJ TEST:.................SKIPPED\n\n",
+			 tag);
+
+	/* START OF TOTAL CHECK */
+
+	if (todo->MutualCxTotalLP == 1 || todo->MutualCxTotalAdjLP == 1) {
+		if (todo->MutualCxTotalLP == 1) {
+			logError(1, "%s MS TOTAL LP CX MIN MAX TEST:\n", tag);
+			ret = parseProductionTestLimits(path_limits,
+							&limit_file,
+							MS_TOTAL_CX_LP_MAP_MIN,
+							&thresholds_min,
+							&trows, &tcolumns);
+			/* load min thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns !=
+					totCompData.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_TOTAL_CX_LP_MAP_MIN failed... ERROR %08X\n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(path_limits,
+							&limit_file,
+							MS_TOTAL_CX_LP_MAP_MAX,
+							&thresholds_max,
+							&trows, &tcolumns);
+			/* load max thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns !=
+					totCompData.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_TOTAL_CX_LP_MAP_MAX failed... ERROR %08X\n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(totCompData.node_data,
+						  totCompData.header.force_node,
+						  totCompData.header.sense_node,
+						  thresholds_min,
+						  thresholds_max);
+			/* check the limits */
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMap  MS TOTAL CX LP TEST failed... ERROR COUNT = %d\n",
+					 tag, ret);
+				logError(0,
+					 "%s MS TOTAL CX LP MIN MAX TEST:.................FAIL\n\n",
+					 tag);
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS TOTAL CX LP MIN MAX TEST:.................OK\n\n",
+					 tag);
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			logError(0,
+				 "%s MS TOTAL CX LP MIN MAX TEST:.................SKIPPED\n\n",
+				 tag);
+
+
+		if (todo->MutualCxTotalAdjLP == 1) {
+			/* MS TOTAL CX ADJ HORIZ */
+			logError(1, "%s MS TOTAL CX ADJ HORIZ LP TEST:\n", tag);
+
+			ret = computeAdjHorizTotal(totCompData.node_data,
+						   totCompData.header.force_node,
+						   totCompData.header.sense_node,
+						   &total_adjhor);
+			if (ret < 0) {
+				logError(1,
+					 "%s production_test_data: computeAdjHoriz failed... ERROR %08X\n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			logError(0, "%s MS TOTAL CX ADJ HORIZ LP computed!\n",
+				 tag);
+
+			ret = parseProductionTestLimits(path_limits,
+							&limit_file,
+							MS_TOTAL_CX_ADJH_LP_MAP_MAX,
+							&thresholds_max,
+							&trows, &tcolumns);
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns !=
+					totCompData.header.sense_node - 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_TOTAL_CX_ADJH_LP_MAP_MAX failed... ERROR %08X\n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjhor,
+						     totCompData.header.
+						     force_node,
+						     totCompData.header.
+						     sense_node - 1,
+						     thresholds_max);
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMapAdj MS TOTAL CX ADJH LP failed... ERROR COUNT = %d\n",
+					 tag, ret);
+				logError(0,
+					 "%s MS TOTAL CX ADJ HORIZ LP TEST:.................FAIL\n\n",
+					 tag);
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS TOTAL CX ADJ HORIZ LP TEST:.................OK\n\n",
+					 tag);
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjhor);
+			total_adjhor = NULL;
+
+			/* MS TOTAL CX ADJ VERT */
+			logError(0, "%s MS TOTAL CX ADJ VERT LP TEST:\n", tag);
+
+			ret = computeAdjVertTotal(totCompData.node_data,
+						  totCompData.header.force_node,
+						  totCompData.header.sense_node,
+						  &total_adjvert);
+			if (ret < 0) {
+				logError(1,
+					 "%s production_test_data: computeAdjVert failed... ERROR %08X\n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			logError(0, "%s MS TOTAL CX ADJ VERT LP computed!\n", tag);
+
+			ret = parseProductionTestLimits(path_limits,
+							&limit_file,
+							MS_TOTAL_CX_ADJV_LP_MAP_MAX,
+							&thresholds_max,
+							&trows, &tcolumns);
+			if (ret < 0 || (trows != totCompData.header.force_node -
+					1 || tcolumns !=
+					totCompData.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits MS_TOTAL_CX_ADJV_LP_MAP_MAX failed... ERROR %08X\n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjvert,
+						     totCompData.header.
+						     force_node - 1,
+						     totCompData.header.
+						     sense_node - 1,
+						     thresholds_max);
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMapAdj MS TOTAL CX ADJV failed... ERROR COUNT = %d\n",
+					 tag, ret);
+				logError(0,
+					 "%s MS TOTAL CX ADJ HORIZ LP TEST:.................FAIL\n",
+					 tag);
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s MS TOTAL CX ADJ VERT LP TEST:.................OK\n",
+					 tag);
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjvert);
+			total_adjvert = NULL;
+		} else
+			logError(0,
+				 "%s MS TOTAL CX ADJ LP TEST:.................SKIPPED\n",
+				 tag);
+
+		kfree(totCompData.node_data);
+		totCompData.node_data = NULL;
+	} else
+		logError(0, "%s MS TOTAL CX LP TEST:.................SKIPPED\n",
+			 tag);
+
+
+
+ERROR:
+	logError(0, "%s\n", tag);
+	if (count_fail == 0) {
+		logError(0, "%s MS LP CX testes finished!.................OK\n",
+			 tag);
+		kfree(msCompData.node_data);
+		msCompData.node_data = NULL;
+		return OK;
+	} else {
+		print_frame_i8("MS LP Init Data (Cx2) =", array1dTo2d_i8(
+				       msCompData.node_data,
+				       msCompData.node_data_size,
+				       msCompData.header.sense_node),
+			       msCompData.header.force_node,
+			       msCompData.header.sense_node);
+		print_frame_short(" TOT MS LP Init Data (Cx) =", array1dTo2d_short(
+					  totCompData.node_data,
+					  totCompData.node_data_size,
+					  totCompData.header.sense_node),
+				  totCompData.header.force_node,
+				  totCompData.header.sense_node);
+		logError(0,
+			 "%s MS LP CX testes finished!.................FAILED  fails_count = %d\n\n",
+			 tag, count_fail);
+		if (thresholds != NULL) {
+			kfree(thresholds);
+			thresholds = NULL;
+		}
+		if (thresholds_min != NULL) {
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+		}
+		if (thresholds_max != NULL) {
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		}
+		if (adjhor != NULL) {
+			kfree(adjhor);
+			adjhor = NULL;
+		}
+		if (adjvert != NULL) {
+			kfree(adjvert);
+			adjvert = NULL;
+		}
+		if (totCompData.node_data != NULL) {
+			kfree(totCompData.node_data);
+			totCompData.node_data = NULL;
+		}
+		if (total_adjhor != NULL) {
+			kfree(total_adjhor);
+			total_adjhor = NULL;
+		}
+		if (total_adjvert != NULL) {
+			kfree(total_adjvert);
+			total_adjvert = NULL;
+		}
+		if (msCompData.node_data != NULL) {
+			kfree(msCompData.node_data);
+			msCompData.node_data = NULL;
+		}
+		return ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA;
+	}
+
+ERROR_LIMITS:
+	if (thresholds != NULL) {
+		kfree(thresholds);
+		thresholds = NULL;
+	}
+	if (thresholds_min != NULL) {
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+	}
+	if (thresholds_max != NULL) {
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	}
+	if (adjhor != NULL) {
+		kfree(adjhor);
+		adjhor = NULL;
+	}
+	if (adjvert != NULL) {
+		kfree(adjvert);
+		adjvert = NULL;
+	}
+	if (totCompData.node_data != NULL) {
+		kfree(totCompData.node_data);
+		totCompData.node_data = NULL;
+	}
+	if (total_adjhor != NULL) {
+		kfree(total_adjhor);
+		total_adjhor = NULL;
+	}
+	if (total_adjvert != NULL) {
+		kfree(total_adjvert);
+		total_adjvert = NULL;
+	}
+	if (msCompData.node_data != NULL) {
+		kfree(msCompData.node_data);
+		msCompData.node_data = NULL;
+	}
+	return ret;
+}
+
+static int production_test_ss_hover_raw(char *path_limits, int stop_on_fail,
+			      TestToDo *todo){
+	int ret;
+	int rows, columns;
+	int *thresholds = NULL;
+	int trows, tcolumns;
+	u8 hover_cnt[4] = {0xa8, 0x0b, 0x01, 0x00};
+
+	SelfSenseFrame ssHoverRawFrame;
+	int count_fail = 0;
+
+	ret = fts_write_dma_safe(hover_cnt, sizeof(hover_cnt));
+	if (ret != OK) {
+		logError(1,
+			 "%s hover clear count ERROR = %d\n", tag, ret);
+		goto ERROR_LIMITS;
+	}
+
+	logError(0, "%s Getting SS Hover Frame...\n", tag);
+	ret = setScanMode(SCAN_MODE_LOCKED, LOCKED_HOVER);
+	msleep(WAIT_FOR_FRESH_FRAMES);
+	ret |= setScanMode(SCAN_MODE_ACTIVE, 0x00);
+	msleep(WAIT_AFTER_SENSEOFF);
+	ret |= getSSFrame3(SS_HVR_RAW, &ssHoverRawFrame);
+	/* SS Hover RAW FORCE TEST */
+	logError(0, "%s SS Hover RAW FORCE TEST:\n", tag);
+
+	logError(0, "%s SS RAW FORCE MIN MAX TEST:\n", tag);
+	if (todo->SelfHoverForceRaw == 1) {
+		columns = 1;
+		rows = ssHoverRawFrame.header.force_node;
+		ret = parseProductionTestLimits(path_limits,
+						&limit_file,
+						SS_HOVER_RAW_FORCE_MIN_MAX,
+						&thresholds, &trows,
+						&tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_HOVER_RAW_FORCE_MIN_MAX failed... ERROR %08X\n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMinMax(ssHoverRawFrame.force_data, rows,columns, thresholds[0], thresholds[1]);
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMinMax SS HOVER RAW FORCE failed... ERROR COUNT = %d\n",tag, ret);
+			logError(0,
+				 "%s SS Hover RAW FORCE MIN MAX TEST:.................FAIL\n\n", tag);
+			count_fail += 1;
+			print_frame_short("SS Raw force frame =",
+					  array1dTo2d_short(
+						  ssHoverRawFrame.force_data,
+						  rows *
+						  columns,
+						  columns), rows,
+					  columns);
+			if (stop_on_fail) {
+				ret = ERROR_PROD_TEST_DATA |
+				      ERROR_TEST_CHECK_FAIL;
+				goto ERROR_LIMITS;
+			}
+		} else
+			logError(0,
+				 "%s SS RAW FORCE MIN MAX TEST:.................OK\n\n",
+				 tag);
+
+		kfree(thresholds);
+		thresholds = NULL;
+	} else
+			logError(0,
+				 "%s SS RAW FORCE MIN MAX TEST:.................SKIPPED\n\n",
+				 tag);
+	logError(0, "%s\n", tag);
+	/* SS Hover RAW SENSE TEST */
+	logError(0, "%s SS Hover RAW SENSE TEST:\n", tag);
+
+	logError(0, "%s SS RAW SENSE MIN MAX TEST:\n", tag);
+	if (todo->SelfHoverSenceRaw == 1) {
+		columns = ssHoverRawFrame.header.sense_node;
+		rows = 1;
+		ret = parseProductionTestLimits(path_limits,
+						&limit_file,
+						SS_HOVER_RAW_SENSE_MIN_MAX,
+						&thresholds, &trows,
+						&tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_RAW_SENSE_MIN_MAX failed... ERROR %08X\n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMinMax(ssHoverRawFrame.sense_data, rows, columns, thresholds[0], thresholds[1]);
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMinMax SS Hover RAW SENSE failed... ERROR COUNT = %d\n",
+				 tag, ret);
+			logError(0,
+				 "%s SS Hover RAW SENSE MIN MAX TEST:.................FAIL\n",
+				 tag);
+			count_fail += 1;
+			print_frame_short("SS Hover Raw sense frame =",
+					  array1dTo2d_short(
+						  ssHoverRawFrame.sense_data,
+						  rows *
+						  columns,
+						  columns), rows,
+					  columns);
+			if (stop_on_fail) {
+				ret = ERROR_PROD_TEST_DATA |
+					  ERROR_TEST_CHECK_FAIL;
+				goto ERROR_LIMITS;
+			}
+		} else
+			logError(0,
+				 "%s SS Hover RAW SENSE MIN MAX TEST:.................OK\n",tag);
+
+		kfree(thresholds);
+		thresholds = NULL;
+	}
+
+ERROR_LIMITS:
+	if (ssHoverRawFrame.force_data != NULL)
+		kfree(ssHoverRawFrame.force_data);
+	if (ssHoverRawFrame.sense_data != NULL)
+		kfree(ssHoverRawFrame.sense_data);
+	if (thresholds != NULL)
+		kfree(thresholds);
+
+	return ret;
+}
+
+/**
+ * Perform all the test selected in a TestTodo variable related to SS raw data (touch, keys etc..)
+ * @param path_limits name of Production Limit file to load or "NULL" if the limits data should be loaded by a .h file
+ * @param stop_on_fail if 1, the test flow stops at the first data check failure otherwise it keeps going performing all the selected test
+ * @param todo pointer to a TestToDo variable which select the test to do
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int production_test_ss_raw(char *path_limits, int stop_on_fail, TestToDo *todo)
+{
+	int ret;
+	int count_fail = 0;
+	int rows, columns;
+	SelfSenseFrame ssRawFrame;
+	int *thresholds = NULL;
+	int trows, tcolumns;
+	logError(0, "%s \n", tag);
+	/******************************* Self Sense Test *******************************/
+	logError(0, "%s Getting SS Frame... \n", tag);
+	ret = setScanMode(SCAN_MODE_LOCKED, LOCKED_ACTIVE);
+	mdelay(WAIT_FOR_FRESH_FRAMES);
+	ret |= setScanMode(SCAN_MODE_ACTIVE, 0x00);
+	mdelay(WAIT_AFTER_SENSEOFF);
+	ret |= getSSFrame3(SS_RAW, &ssRawFrame);
+
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: getSSFrame failed... ERROR %08X \n",
+			 tag, ERROR_PROD_TEST_DATA);
+		return (ret | ERROR_PROD_TEST_DATA);
+	}
+
+
+	if (todo->SelfForceRaw == 1 || todo->SelfForceRawGap == 1) {
+		columns = 1;
+		rows = ssRawFrame.header.force_node;
+		logError(0, "%s SS RAW FORCE MIN MAX TEST:  \n", tag);
+
+		if (todo->SelfForceRaw == 1) {
+			logError(1, "%s SS RAW FORCE MIN MAX TEST:  \n", tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  SS_RAW_FORCE_MIN_MAX,
+							  &thresholds, &trows,
+							  &tcolumns);
+
+			if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_RAW_FORCE_MIN_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsMinMax(ssRawFrame.force_data, rows,
+						  columns, thresholds[0],
+						  thresholds[1]);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMinMax SS RAW FORCE failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS RAW (PROXIMITY) FORCE MIN MAX TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+				print_frame_short("SS Raw force frame =",
+						  array1dTo2d_short
+						  (ssRawFrame.force_data,
+						   rows * columns, columns),
+						  rows, columns);
+
+				if (stop_on_fail) {
+					ret =
+						ERROR_PROD_TEST_DATA |
+						ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				logError(0,
+					 "%s SS RAW (PROXIMITY) FORCE MIN MAX TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			logError(0,
+				 "%s SS RAW (PROXIMITY) FORCE MIN MAX TEST:.................SKIPPED \n\n",
+				 tag);
+
+		logError(0, "%s \n", tag);
+
+		if (todo->SelfForceRawGap == 1) {
+			logError(1, "%s SS RAW FORCE GAP TEST:  \n", tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  SS_RAW_FORCE_GAP,
+							  &thresholds, &trows,
+							  &tcolumns);
+
+			if (ret < 0 || (trows != 1 || tcolumns != 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_RAW_FORCE_GAP failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsGap(ssRawFrame.force_data, rows, columns,
+					       thresholds[0]);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsGap SS RAW FORCE GAP failed... ERROR = %08X \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS RAW FORCE GAP TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+				print_frame_short("SS Raw force frame =",
+						  array1dTo2d_short
+						  (ssRawFrame.force_data,
+						   rows * columns, columns),
+						  rows, columns);
+
+				if (stop_on_fail) {
+					ret =
+						ERROR_PROD_TEST_DATA |
+						ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				logError(0,
+					 "%s SS RAW (PROXIMITY) FORCE GAP TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			logError(0,
+				 "%s SS RAW (PROXIMITY) FORCE GAP TEST:.................SKIPPED \n\n",
+				 tag);
+
+		kfree(ssRawFrame.force_data);
+		ssRawFrame.force_data = NULL;
+	} else
+		logError(0,
+			 "%s SS RAW (PROXIMITY) FORCE TEST:.................SKIPPED \n\n",
+			 tag);
+
+	logError(0, "%s \n", tag);
+
+	if (todo->SelfSenseRaw == 1 || todo->SelfSenseRawGap == 1) {
+		columns = ssRawFrame.header.sense_node;
+		rows = 1;
+
+		if (todo->SelfSenseRaw == 1) {
+			logError(1, "%s SS RAW SENSE MIN MAX TEST:  \n", tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  SS_RAW_SENSE_MIN_MAX,
+							  &thresholds, &trows,
+							  &tcolumns);
+
+			if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_RAW_SENSE_MIN_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsMinMax(ssRawFrame.sense_data, rows,
+						  columns, thresholds[0],
+						  thresholds[1]);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMinMax SS RAW SENSE failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS RAW SENSE MIN MAX TEST:.................FAIL \n",
+					 tag);
+				count_fail += 1;
+				print_frame_short("SS Raw sense frame =",
+						  array1dTo2d_short
+						  (ssRawFrame.sense_data,
+						   rows * columns, columns),
+						  rows, columns);
+
+				if (stop_on_fail) {
+					ret =
+						ERROR_PROD_TEST_DATA |
+						ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				logError(0,
+					 "%s SS RAW (PROXIMITY) SENSE MIN MAX TEST:.................OK \n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			logError(0,
+				 "%s SS RAW (PROXIMITY) SENSE MIN MAX TEST:.................SKIPPED \n",
+				 tag);
+
+		logError(0, "%s \n", tag);
+
+		if (todo->SelfSenseRawGap == 1) {
+			logError(1, "%s SS RAW SENSE GAP TEST:  \n", tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  SS_RAW_SENSE_GAP,
+							  &thresholds, &trows,
+							  &tcolumns);
+
+			if (ret < 0 || (trows != 1 || tcolumns != 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_RAW_SENSE_GAP failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsGap(ssRawFrame.sense_data, rows, columns,
+					       thresholds[0]);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsGap SS RAW SENSE GAP failed... ERROR = %08X \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS RAW SENSE GAP TEST:.................FAIL \n",
+					 tag);
+				count_fail += 1;
+				print_frame_short("SS Raw sense frame =",
+						  array1dTo2d_short
+						  (ssRawFrame.sense_data,
+						   rows * columns, columns),
+						  rows, columns);
+
+				if (stop_on_fail) {
+					ret =
+						ERROR_PROD_TEST_DATA |
+						ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				logError(0,
+					 "%s SS RAW (PROXIMITY) SENSE GAP TEST:.................OK \n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			logError(0,
+				 "%s SS RAW (PROXIMITY) SENSE GAP TEST:.................SKIPPED \n",
+				 tag);
+
+		kfree(ssRawFrame.sense_data);
+		ssRawFrame.sense_data = NULL;
+	}
+
+	ret = production_test_ss_raw_lp(path_limits, stop_on_fail, todo);
+
+	if (ret < OK) {
+		logError(1,
+			 "%s production_test_data: production_test_ss_raw_lp failed... ERROR = %08X \n",
+			 tag, ret);
+		count_fail += 1;
+	}
+	if (todo->SelfHoverForceRaw == 1 || todo->SelfHoverSenceRaw) {
+		ret = production_test_ss_hover_raw(path_limits, stop_on_fail, todo);
+		if (ret < OK) {
+			logError(1,
+				 "%s production_test_data: production_test_ss_hover_raw failed... ERROR = %08X\n",
+				 tag, ret);
+			count_fail += 1;
+		}
+	}
+
+	logError(0, "%s \n", tag);
+
+	if (count_fail == 0) {
+		logError(0, "%s SS RAW testes finished!.................OK\n\n",
+			 tag);
+		return OK;
+	} else {
+		logError(0,
+			 "%s SS RAW testes finished!.................FAILED  fails_count = %d\n\n",
+			 tag, count_fail);
+		return (ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA);
+	}
+
+ERROR_LIMITS:
+
+	if (ssRawFrame.force_data != NULL)
+		kfree(ssRawFrame.force_data);
+
+	if (ssRawFrame.sense_data != NULL)
+		kfree(ssRawFrame.sense_data);
+
+	if (thresholds != NULL)
+		kfree(thresholds);
+
+	return ret;
+}
+
+/**
+ * Perform all the test selected in a TestTodo variable related to SS raw data low power
+ * @param path_limits name of Production Limit file to load or "NULL" if the limits data should be loaded by a .h file
+ * @param stop_on_fail if 1, the test flow stops at the first data check failure otherwise it keeps going performing all the selected test
+ * @param todo pointer to a TestToDo variable which select the test to do
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int production_test_ss_raw_lp(char *path_limits, int stop_on_fail,
+			      TestToDo *todo)
+{
+	int ret;
+	int count_fail = 0;
+	int rows, columns;
+	SelfSenseFrame ssRawFrame;
+	int *thresholds = NULL;
+	int trows, tcolumns;
+	logError(0, "%s \n", tag);
+	/******************************* Self Sense Test *******************************/
+	ret = setScanMode(SCAN_MODE_LOCKED, LOCKED_LP_DETECT);
+	mdelay(WAIT_FOR_FRESH_FRAMES);
+	ret |= setScanMode(SCAN_MODE_ACTIVE, 0x00);
+	mdelay(WAIT_AFTER_SENSEOFF);
+	ret |= getSSFrame3(SS_RAW, &ssRawFrame);
+
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: getSSFrame failed... ERROR %08X \n",
+			 tag, ERROR_PROD_TEST_DATA);
+		return (ret | ERROR_PROD_TEST_DATA);
+	}
+
+
+	if (todo->SelfForceRawLP == 1 || todo->SelfForceRawGapLP == 1) {
+		columns = 1;
+		rows = ssRawFrame.header.force_node;
+
+		if (todo->SelfForceRawLP == 1) {
+			logError(1, "%s SS RAW LP FORCE MIN MAX TEST:  \n", tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  SS_RAW_LP_FORCE_MIN_MAX,
+							  &thresholds, &trows,
+							  &tcolumns);
+
+			if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_RAW_FORCE_MIN_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsMinMax(ssRawFrame.force_data, rows,
+						  columns, thresholds[0],
+						  thresholds[1]);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMinMax SS RAW FORCE failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS RAW LP FORCE MIN MAX TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+				print_frame_short("SS Raw LP force frame =",
+						  array1dTo2d_short
+						  (ssRawFrame.force_data,
+						   rows * columns, columns),
+						  rows, columns);
+
+				if (stop_on_fail) {
+					ret =
+						ERROR_PROD_TEST_DATA |
+						ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				logError(0,
+					 "%s SS RAW LP FORCE MIN MAX TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			logError(0,
+				 "%s SS RAW LP FORCE MIN MAX TEST:.................SKIPPED \n\n",
+				 tag);
+
+		logError(0, "%s \n", tag);
+
+		if (todo->SelfForceRawGapLP == 1) {
+			logError(1, "%s SS RAW LP FORCE GAP TEST:  \n", tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  SS_RAW_LP_FORCE_GAP,
+							  &thresholds, &trows,
+							  &tcolumns);
+
+			if (ret < OK || (trows != 1 || tcolumns != 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_RAW_FORCE_GAP failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsGap(ssRawFrame.force_data, rows, columns,
+					       thresholds[0]);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsGap SS RAW FORCE GAP failed... ERROR = %08X \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS RAW LP FORCE GAP TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+				print_frame_short("SS Raw LP force frame =",
+						  array1dTo2d_short
+						  (ssRawFrame.force_data,
+						   rows * columns, columns),
+						  rows, columns);
+
+				if (stop_on_fail) {
+					ret =
+						ERROR_PROD_TEST_DATA |
+						ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				logError(0,
+					 "%s SS RAW LP FORCE GAP TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			logError(0,
+				 "%s SS RAW LP FORCE GAP TEST:.................SKIPPED \n\n",
+				 tag);
+
+		kfree(ssRawFrame.force_data);
+		ssRawFrame.force_data = NULL;
+	} else
+		logError(0,
+			 "%s SS RAW LP FORCE TEST:.................SKIPPED \n\n",
+			 tag);
+
+	logError(0, "%s \n", tag);
+
+	if (todo->SelfSenseRawLP == 1 || todo->SelfSenseRawGapLP == 1) {
+		columns = ssRawFrame.header.sense_node;
+		rows = 1;
+		logError(0, "%s SS RAW LP SENSE MIN MAX TEST:  \n", tag);
+
+		if (todo->SelfSenseRawLP == 1) {
+			logError(1, "%s SS RAW LP SENSE MIN MAX TEST:  \n", tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  SS_RAW_LP_SENSE_MIN_MAX,
+							  &thresholds, &trows,
+							  &tcolumns);
+
+			if (ret < OK || (trows != 1 || tcolumns != 2)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_RAW_SENSE_MIN_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsMinMax(ssRawFrame.sense_data, rows,
+						  columns, thresholds[0],
+						  thresholds[1]);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMinMax SS RAW SENSE failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS RAW LP SENSE MIN MAX TEST:.................FAIL \n",
+					 tag);
+				count_fail += 1;
+				print_frame_short("SS Raw LP sense frame =",
+						  array1dTo2d_short
+						  (ssRawFrame.sense_data,
+						   rows * columns, columns),
+						  rows, columns);
+
+				if (stop_on_fail) {
+					ret =
+						ERROR_PROD_TEST_DATA |
+						ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				logError(0,
+					 "%s SS RAW SENSE MIN MAX TEST:.................OK \n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			logError(0,
+				 "%s SS RAW LP SENSE MIN MAX TEST:.................SKIPPED \n",
+				 tag);
+
+		logError(0, "%s \n", tag);
+
+		if (todo->SelfSenseRawGapLP == 1) {
+			logError(1, "%s SS RAW LP SENSE GAP TEST:  \n", tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  SS_RAW_LP_SENSE_GAP,
+							  &thresholds, &trows,
+							  &tcolumns);
+
+			if (ret < OK || (trows != 1 || tcolumns != 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_RAW_SENSE_GAP failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsGap(ssRawFrame.sense_data, rows, columns,
+					       thresholds[0]);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsGap SS RAW SENSE GAP failed... ERROR = %08X \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS RAW LP SENSE GAP TEST:.................FAIL \n",
+					 tag);
+				count_fail += 1;
+				print_frame_short("SS Raw LP sense frame =",
+						  array1dTo2d_short
+						  (ssRawFrame.sense_data,
+						   rows * columns, columns),
+						  rows, columns);
+
+				if (stop_on_fail) {
+					ret =
+						ERROR_PROD_TEST_DATA |
+						ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				logError(0,
+					 "%s SS RAW LP SENSE GAP TEST:.................OK \n",
+					 tag);
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			logError(0,
+				 "%s SS RAW LP SENSE GAP TEST:.................SKIPPED \n",
+				 tag);
+
+		kfree(ssRawFrame.sense_data);
+		ssRawFrame.sense_data = NULL;
+	}
+
+	logError(0, "%s \n", tag);
+
+	if (count_fail == 0) {
+		logError(0,
+			 "%s SS RAW LP testes finished!.................OK\n\n",
+			 tag);
+		return OK;
+	} else {
+		logError(0,
+			 "%s SS RAW LP testes finished!.................FAILED  fails_count = %d\n\n",
+			 tag, count_fail);
+		return (ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA);
+	}
+
+ERROR_LIMITS:
+
+	if (ssRawFrame.force_data != NULL)
+		kfree(ssRawFrame.force_data);
+
+	if (ssRawFrame.sense_data != NULL)
+		kfree(ssRawFrame.sense_data);
+
+	if (thresholds != NULL)
+		kfree(thresholds);
+
+	return ret;
+}
+
+static int production_test_ss_hover_ix(char *path_limits, int stop_on_fail, TestToDo *todo){
+	TotSelfSenseData ssHoverCompData;
+	int ret;
+	int trows, tcolumns;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	int count_fail = 0;
+
+	/* ret = readSelfSenseCompensationData(LOAD_CX_SS_HOVER, &ssHoverCompData); */
+	ret = readTotSelfSenseCompensationData(STAPI_HOST_DATA_ID_PANEL_CX_SS_HVR, &ssHoverCompData);
+	/* read the SS compensation data */
+	if (ret < 0) {
+		logError(1,
+		"%s production_test_data: readSelfSenseCompensationData failed... ERROR %08X\n",tag, ERROR_PROD_TEST_DATA);
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	logError(0, "%s SS Hover TOTAL IX FORCE TEST:\n", tag);
+	logError(0, "%s SS Hover TOTAL IX FORCE MIN MAX TEST:\n", tag);
+	if (todo->SelfHoverForceIxTotal == 1) {
+		ret = parseProductionTestLimits(path_limits, &limit_file, SS_HOVER_TOTAL_IX_FORCE_MAP_MIN, &thresholds_min, &trows, &tcolumns);
+					/* load the min thresholds */
+		if (ret < 0 || (trows != ssHoverCompData.header.force_node || tcolumns != 1)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_TOTAL_IX_FORCE_MAP_MIN failed... ERROR %08X\n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(path_limits, &limit_file,SS_TOTAL_IX_FORCE_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+					/* load the max thresholds */
+		if (ret < 0 || (trows !=
+				ssHoverCompData.header.force_node ||
+				tcolumns != 1)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_TOTAL_IX_FORCE_MAP_MAX failed... ERROR %08X\n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapTotalFromU(ssHoverCompData.ix_fm,ssHoverCompData.header.
+						   force_node, 1,
+						   thresholds_min,
+						   thresholds_max);
+		/* check the values with thresholds */
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMap  SS TOTAL IX FORCE failed... ERROR COUNT = %d\n",
+				 tag, ret);
+			logError(0,
+				 "%s SS TOTAL IX FORCE MIN MAX TEST:.................FAIL\n\n",
+				 tag);
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s SS TOTAL IX FORCE MIN MAX TEST:.................OK\n\n",
+				 tag);
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+	logError(0,
+			 "%s SS Hover TOTAL IX FORCE MIN MAX TEST:.................SKIPPED\n",
+			 tag);
+
+	logError(0, "%s SS HOVER TOTAL IX SENSE MIN MAX TEST:\n", tag);
+		if (todo->SelfHoverSenceIxTotal == 1) {
+			ret = parseProductionTestLimits(path_limits,
+							&limit_file,
+							SS_TOTAL_IX_SENSE_MAP_MIN,
+							&thresholds_min,
+							&trows, &tcolumns);
+			/* load the min thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					ssHoverCompData.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_IX_SENSE_MAP_MIN failed... ERROR %08X\n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(path_limits,
+							&limit_file,
+							SS_TOTAL_IX_SENSE_MAP_MAX,
+							&thresholds_max,
+							&trows, &tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					ssHoverCompData.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_IX_SENSE_MAP_MAX failed... ERROR %08X\n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotalFromU(ssHoverCompData.ix_sn, 1,
+						       ssHoverCompData.header.
+						       sense_node,
+						       thresholds_min,
+						       thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMap SS TOTAL IX SENSE failed... ERROR COUNT = %d\n",
+					 tag, ret);
+				logError(0,
+					 "%s SS Hover TOTAL IX SENSE MIN MAX TEST:.................FAIL\n\n",
+					 tag);
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s SS TOTAL IX SENSE MIN MAX TEST:.................OK\n\n",
+					 tag);
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			logError(0,
+				 "%s SS Hover TOTAL IX SENSE MIN MAX TEST:.................SKIPPED\n",
+				 tag);
+ERROR:
+	logError(0, "%s\n", tag);
+	if (count_fail == 0) {
+		kfree(ssHoverCompData.ix_fm);
+		ssHoverCompData.ix_fm = NULL;
+		kfree(ssHoverCompData.ix_sn);
+		ssHoverCompData.ix_sn = NULL;
+		kfree(ssHoverCompData.cx_fm);
+		ssHoverCompData.cx_fm = NULL;
+		kfree(ssHoverCompData.cx_sn);
+		ssHoverCompData.cx_sn = NULL;
+		logError(0,
+			 "%s SS Hover IX  testes finished!.................OK\n\n",
+			 tag);
+		return OK;
+	} else {
+		print_frame_u16("TOT SS hover Init Data Ix_fm = ", array1dTo2d_u16(
+					ssHoverCompData.ix_fm,
+					ssHoverCompData.header.force_node, 1),
+				ssHoverCompData.header.force_node, 1);
+		print_frame_short("TOT SS hover hover Init Data Cx_fm = ",
+				  array1dTo2d_short(ssHoverCompData.cx_fm,
+							ssHoverCompData.header.
+							force_node, 1),
+				  ssHoverCompData.header.force_node, 1);
+		print_frame_u16("TOT SS hover Init Data Ix_sn = ", array1dTo2d_u16(
+					ssHoverCompData.ix_sn,
+					ssHoverCompData.header.sense_node,
+					ssHoverCompData.header.sense_node), 1,
+				ssHoverCompData.header.sense_node);
+		print_frame_short("TOT SS hover Init Data Cx_sn = ",
+				  array1dTo2d_short(ssHoverCompData.cx_sn,
+							ssHoverCompData.header.
+							sense_node,
+							ssHoverCompData.header.
+							sense_node),
+				  1, ssHoverCompData.header.sense_node);
+		logError(0,
+			 "%s SS hover IX CX testes finished!.................FAILED  fails_count = %d\n\n",
+			 tag, count_fail);
+		if (thresholds_min != NULL)
+			kfree(thresholds_min);
+		if (thresholds_max != NULL)
+			kfree(thresholds_max);
+		if (ssHoverCompData.ix_fm != NULL)
+			kfree(ssHoverCompData.ix_fm);
+		if (ssHoverCompData.ix_sn != NULL)
+			kfree(ssHoverCompData.ix_sn);
+		if (ssHoverCompData.cx_fm != NULL)
+			kfree(ssHoverCompData.cx_fm);
+		if (ssHoverCompData.cx_sn != NULL)
+			kfree(ssHoverCompData.cx_sn);
+		return ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA;
+	}
+ERROR_LIMITS:
+	if (thresholds_min != NULL)
+		kfree(thresholds_min);
+	if (thresholds_max != NULL)
+		kfree(thresholds_max);
+	if (ssHoverCompData.ix_fm != NULL)
+		kfree(ssHoverCompData.ix_fm);
+	if (ssHoverCompData.ix_sn != NULL)
+		kfree(ssHoverCompData.ix_sn);
+	if (ssHoverCompData.cx_fm != NULL)
+		kfree(ssHoverCompData.cx_fm);
+	if (ssHoverCompData.cx_sn != NULL)
+		kfree(ssHoverCompData.cx_sn);
+	return ret;
+}
+
+/**
+ * Perform all the tests selected in a TestTodo variable related to SS Init data (touch, keys etc..)
+ * @param path_limits name of Production Limit file to load or "NULL" if the limits data should be loaded by a .h file
+ * @param stop_on_fail if 1, the test flow stops at the first data check failure otherwise it keeps going performing all the selected test
+ * @param todo pointer to a TestToDo variable which select the test to do
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int production_test_ss_ix_cx(char *path_limits, int stop_on_fail,
+			     TestToDo *todo)
+{
+	int ret;
+	int count_fail = 0;
+	int *thresholds = NULL;
+	int trows, tcolumns;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	SelfSenseData ssCompData;
+	TotSelfSenseData totCompData;
+	u8 *adjhor = NULL;
+	u8 *adjvert = NULL;
+	short container;
+	u16 *total_adjhor = NULL;
+	u16 *total_adjvert = NULL;
+	logError(0, "%s \n", tag);
+	ret = readSelfSenseCompensationData(LOAD_CX_SS_TOUCH, &ssCompData);
+
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: readSelfSenseCompensationData failed... ERROR %08X \n",
+			 tag, ERROR_PROD_TEST_DATA);
+		return (ret | ERROR_PROD_TEST_DATA);
+	}
+
+	ret =
+		readTotSelfSenseCompensationData(LOAD_PANEL_CX_TOT_SS_TOUCH,
+				&totCompData);
+
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: readTotSelfSenseCompensationData failed... ERROR %08X \n",
+			 tag, ERROR_PROD_TEST_DATA);
+		kfree(ssCompData.ix2_fm);
+		kfree(ssCompData.ix2_sn);
+		kfree(ssCompData.cx2_fm);
+		kfree(ssCompData.cx2_sn);
+		return (ret | ERROR_PROD_TEST_DATA);
+	}
+
+	/********************************************************* SS FORCE IX ****************************************************************/
+
+	if (todo->SelfForceIx1 == 1) {
+		logError(1, "%s SS IX1 FORCE TEST:  \n", tag);
+		ret =
+			parseProductionTestLimits(path_limits, &limit_file,
+						  SS_IX1_FORCE_MIN_MAX, &thresholds,
+						  &trows, &tcolumns);
+
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_IX1_FORCE_MIN_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (short)ssCompData.f_ix1;
+		ret =
+			checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					  thresholds[1]);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMinMax SS IX1 FORCE TEST failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s SS IX1 FORCE TEST:.................OK \n\n",
+				 tag);
+	} else
+		logError(0,
+			 "%s SS IX1 FORCE TEST:.................SKIPPED \n\n",
+			 tag);
+
+	kfree(thresholds);
+	thresholds = NULL;
+
+	if (todo->SelfForceIx2 == 1) {
+		logError(1, "%s SS IX2 FORCE MIN MAX TEST:  \n", tag);
+		ret = parseProductionTestLimits(path_limits, &limit_file, SS_IX2_FORCE_MAP_MIN, &thresholds_min, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != ssCompData.header.force_node
+			|| tcolumns != 1)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_IX2_FORCE_MAP_MIN failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(path_limits, &limit_file, SS_IX2_FORCE_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != ssCompData.header.force_node
+			|| tcolumns != 1)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_IX2_FORCE_MAP_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapFromU(ssCompData.ix2_fm, ssCompData.header.force_node, 1, thresholds_min, thresholds_max);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMap SS IX2 FORCE failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s SS IX2 FORCE MIN MAX TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s SS IX2 FORCE MIN MAX TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		logError(0,
+			 "%s SS IX2 FORCE MIN MAX TEST:.................SKIPPED \n\n",
+			 tag);
+
+
+	if (todo->SelfForceIx2Adj == 1) {
+		logError(1, "%s SS IX2 FORCE ADJ TEST:  \n", tag);
+		ret =
+			computeAdjVertFromU(ssCompData.ix2_fm,
+					    ssCompData.header.force_node, 1,
+					    &adjvert);
+
+		if (ret < 0) {
+			logError(1,
+				 "%s production_test_data: computeAdjVert SS IX2 FORCE ADJV failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		logError(0, "%s SS IX2 FORCE ADJV computed! \n", tag);
+		ret = parseProductionTestLimits(path_limits, &limit_file, SS_IX2_FORCE_ADJV_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != ssCompData.header.force_node - 1
+			|| tcolumns != 1)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_IX2_FORCE_ADJV_MAP_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjvert, ssCompData.header.force_node - 1, 1, thresholds_max);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMap SS IX2 FORCE failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s SS IX2 FORCE ADJV TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s SS IX2 FORCE ADJV TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjvert);
+		adjvert = NULL;
+	} else
+		logError(0,
+			 "%s SS IX2 FORCE ADJ TEST:.................SKIPPED \n\n",
+			 tag);
+
+
+	if (todo->SelfForceIxTotal == 1 || todo->SelfForceIxTotalAdj == 1) {
+
+		if (todo->SelfForceIxTotal == 1) {
+			logError(1, "%s SS TOTAL IX FORCE MIN MAX TEST:  \n", tag);
+			ret = parseProductionTestLimits(path_limits, &limit_file, SS_TOTAL_IX_FORCE_MAP_MIN, &thresholds_min, &trows, &tcolumns);
+
+			if (ret < 0
+			    || (trows != totCompData.header.force_node
+				|| tcolumns != 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_IX_FORCE_MAP_MIN failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(path_limits, &limit_file, SS_TOTAL_IX_FORCE_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+			if (ret < 0
+			    || (trows != totCompData.header.force_node
+				|| tcolumns != 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_IX_FORCE_MAP_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotalFromU(totCompData.ix_fm, totCompData.header.force_node, 1, thresholds_min, thresholds_max);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMap  SS TOTAL IX FORCE failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS TOTAL IX FORCE MIN MAX TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s SS TOTAL IX FORCE MIN MAX TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			logError(0,
+				 "%s SS TOTAL IX FORCE MIN MAX TEST:.................SKIPPED \n",
+				 tag);
+
+
+		if (todo->SelfForceIxTotalAdj == 1) {
+			logError(1, "%s SS TOTAL IX FORCE ADJVERT TEST:  \n",
+				 tag);
+			ret =
+				computeAdjVertTotalFromU(totCompData.ix_fm,
+							 totCompData.header.
+							 force_node, 1,
+							 &total_adjvert);
+
+			if (ret < 0) {
+				logError(1,
+					 "%s production_test_data: computeAdjVert SS TOTAL IX FORCE ADJV failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			logError(0, "%s SS TOTAL IX FORCE ADJV computed! \n",
+				 tag);
+			ret = parseProductionTestLimits(path_limits, &limit_file, SS_TOTAL_IX_FORCE_ADJV_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+			if (ret < 0
+			    || (trows != totCompData.header.force_node - 1
+				|| tcolumns != 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_IX_FORCE_ADJV_MAP_MAX... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjvert, totCompData.header.force_node - 1, 1, thresholds_max);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMap SS TOTAL IX FORCE failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS TOTAL IX FORCE ADJV TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s SS TOTAL IX FORCE ADJV TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjvert);
+			total_adjvert = NULL;
+		} else
+			logError(0,
+				 "%s SS TOTAL IX FORCE ADJ TEST:.................SKIPPED  \n",
+				 tag);
+	} else
+		logError(0,
+			 "%s SS TOTAL IX FORCE TEST:.................SKIPPED \n\n",
+			 tag);
+
+	/********************************************************* SS SENSE IX ****************************************************************/
+
+	if (todo->SelfSenseIx1 == 1) {
+		logError(1, "%s SS IX1 SENSE TEST:  \n", tag);
+		ret =
+			parseProductionTestLimits(path_limits, &limit_file,
+						  SS_IX1_SENSE_MIN_MAX, &thresholds,
+						  &trows, &tcolumns);
+
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_IX1_SENSE_MIN_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (short)ssCompData.s_ix1;
+		ret = checkLimitsMinMax(&container, 1, 1, thresholds[0], thresholds[1]);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMinMax SS IX1 SENSE TEST failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s SS IX1 SENSE TEST:.................OK \n\n",
+				 tag);
+	} else
+		logError(0,
+			 "%s SS IX1 SENSE TEST:.................SKIPPED \n\n",
+			 tag);
+
+	kfree(thresholds);
+	thresholds = NULL;
+
+	if (todo->SelfSenseIx2 == 1) {
+		logError(1, "%s SS IX2 SENSE MIN MAX TEST:  \n", tag);
+		ret = parseProductionTestLimits(path_limits, &limit_file, SS_IX2_SENSE_MAP_MIN, &thresholds_min, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != 1
+			|| tcolumns != ssCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_IX2_SENSE_MAP_MIN failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(path_limits, &limit_file, SS_IX2_SENSE_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != 1
+			|| tcolumns != ssCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_IX2_SENSE_MAP_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapFromU(ssCompData.ix2_sn, 1, ssCompData.header.sense_node, thresholds_min, thresholds_max);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMap SS IX2 SENSE failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s SS IX2 SENSE MIN MAX TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s SS IX2 SENSE MIN MAX TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		logError(0,
+			 "%s SS IX2 SENSE MIN MAX TEST:.................SKIPPED \n\n",
+			 tag);
+
+
+	if (todo->SelfSenseIx2Adj == 1) {
+		logError(1, "%s SS IX2 SENSE ADJHORIZ TEST:  \n", tag);
+		ret =
+			computeAdjHorizFromU(ssCompData.ix2_sn, 1,
+					     ssCompData.header.sense_node, &adjhor);
+
+		if (ret < 0) {
+			logError(1,
+				 "%s production_test_data: computeAdjHoriz SS IX2 SENSE ADJH failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		logError(0, "%s SS IX2 SENSE ADJ HORIZ computed! \n", tag);
+		ret = parseProductionTestLimits(path_limits, &limit_file, SS_IX2_SENSE_ADJH_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != 1
+			|| tcolumns != ssCompData.header.sense_node - 1)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_IX2_SENSE_ADJH_MAP_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjhor, 1, ssCompData.header.sense_node - 1, thresholds_max);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMapAdj SS IX2 SENSE ADJH failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s SS IX2 SENSE ADJH TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s SS IX2 SENSE ADJH TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjhor);
+		adjhor = NULL;
+	} else
+		logError(0,
+			 "%s SS IX2 SENSE ADJ TEST:.................SKIPPED  \n",
+			 tag);
+
+
+	if (todo->SelfSenseIxTotal == 1 || todo->SelfSenseIxTotalAdj == 1) {
+
+		if (todo->SelfSenseIxTotal == 1) {
+			logError(1, "%s SS TOTAL IX SENSE MIN MAX TEST:  \n", tag);
+			ret = parseProductionTestLimits(path_limits, &limit_file, SS_TOTAL_IX_SENSE_MAP_MIN, &thresholds_min, &trows, &tcolumns);
+
+			if (ret < 0
+			    || (trows != 1
+				|| tcolumns != totCompData.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_IX_SENSE_MAP_MIN failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(path_limits, &limit_file, SS_TOTAL_IX_SENSE_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+			if (ret < 0
+			    || (trows != 1
+				|| tcolumns != totCompData.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_IX_SENSE_MAP_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotalFromU(totCompData.ix_sn, 1, totCompData.header.sense_node, thresholds_min, thresholds_max);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMap SS TOTAL IX SENSE failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS TOTAL IX SENSE MIN MAX TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s SS TOTAL IX SENSE MIN MAX TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			logError(0,
+				 "%s SS TOTAL IX SENSE MIN MAX TEST:.................SKIPPED  \n",
+				 tag);
+
+
+		if (todo->SelfSenseIxTotalAdj == 1) {
+			logError(1, "%s SS TOTAL IX SENSE ADJHORIZ TEST:  \n",
+				 tag);
+			ret =
+				computeAdjHorizTotalFromU(totCompData.ix_sn, 1,
+							  totCompData.header.
+							  sense_node,
+							  &total_adjhor);
+
+			if (ret < 0) {
+				logError(1,
+					 "%s production_test_data: computeAdjHoriz SS TOTAL IX SENSE ADJH failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			logError(0,
+				 "%s SS TOTAL IX SENSE ADJ HORIZ computed! \n",
+				 tag);
+			ret = parseProductionTestLimits(path_limits, &limit_file, SS_TOTAL_IX_SENSE_ADJH_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+			if (ret < 0
+			    || (trows != 1
+				|| tcolumns !=
+				totCompData.header.sense_node - 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_IX_SENSE_ADJH_MAP_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjhor, 1, totCompData.header.sense_node - 1, thresholds_max);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMapAdj SS TOTAL IX SENSE ADJH failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS TOTAL IX SENSE ADJH TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s SS TOTAL IX SENSE ADJH TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjhor);
+			total_adjhor = NULL;
+		} else
+			logError(0,
+				 "%s SS TOTAL IX SENSE ADJ TEST:.................SKIPPED  \n",
+				 tag);
+	} else
+		logError(0,
+			 "%s SS TOTAL IX SENSE TEST:.................SKIPPED  \n",
+			 tag);
+
+	/********************************************************* SS SENSE CX ****************************************************************/
+
+	if (todo->SelfForceCx1 == 1) {
+		logError(1, "%s SS CX1 FORCE TEST:  \n", tag);
+		ret =
+			parseProductionTestLimits(path_limits, &limit_file,
+						  SS_CX1_FORCE_MIN_MAX, &thresholds,
+						  &trows, &tcolumns);
+
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_CX1_FORCE_MIN_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (short)ssCompData.f_cx1;
+		ret =
+			checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					  thresholds[1]);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMinMax SS CX1 FORCE TEST failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s SS CX1 FORCE TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds);
+		thresholds = NULL;
+	} else
+		logError(0,
+			 "%s SS CX1 FORCE TEST:.................SKIPPED \n\n",
+			 tag);
+
+
+	if (todo->SelfForceCx2 == 1) {
+		logError(1, "%s SS CX2 FORCE MIN MAX TEST:  \n", tag);
+		ret = parseProductionTestLimits(path_limits, &limit_file, SS_CX2_FORCE_MAP_MIN, &thresholds_min, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != ssCompData.header.force_node
+			|| tcolumns != 1)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_CX2_FORCE_MAP_MIN failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(path_limits, &limit_file, SS_CX2_FORCE_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != ssCompData.header.force_node
+			|| tcolumns != 1)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_CX2_FORCE_MAP_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMap(ssCompData.cx2_fm, ssCompData.header.force_node, 1, thresholds_min, thresholds_max);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMap SS CX2 FORCE failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s SS CX2 FORCE MIN MAX TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s SS CX2 FORCE MIN MAX TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		logError(0,
+			 "%s SS CX2 FORCE MIN MAX TEST:.................SKIPPED  \n",
+			 tag);
+
+
+	if (todo->SelfForceCx2Adj == 1) {
+		logError(1, "%s SS CX2 FORCE ADJVERT TEST:  \n", tag);
+		ret = computeAdjVert(ssCompData.cx2_fm, ssCompData.header.force_node, 1, &adjvert);
+
+		if (ret < 0) {
+			logError(1,
+				 "%s production_test_data: computeAdjVert SS CX2 FORCE ADJV failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		logError(0, "%s SS CX2 FORCE ADJV computed! \n", tag);
+		ret = parseProductionTestLimits(path_limits, &limit_file, SS_CX2_FORCE_ADJV_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != ssCompData.header.force_node - 1
+			|| tcolumns != 1)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_CX2_FORCE_ADJV_MAP_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjvert, ssCompData.header.force_node - 1, 1, thresholds_max);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMap SS IX2 FORCE failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s SS CX2 FORCE ADJV TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s SS CX2 FORCE ADJV TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjvert);
+		adjvert = NULL;
+	} else
+		logError(0,
+			 "%s SS CX2 FORCE ADJ TEST:.................SKIPPED \n\n",
+			 tag);
+
+
+	if (todo->SelfForceCxTotal == 1 || todo->SelfForceCxTotalAdj == 1) {
+
+		if (todo->SelfForceCxTotal == 1) {
+			logError(1, "%s SS TOTAL CX FORCE MIN MAX TEST:  \n", tag);
+			ret = parseProductionTestLimits(path_limits, &limit_file, SS_TOTAL_CX_FORCE_MAP_MIN, &thresholds_min, &trows, &tcolumns);
+
+			if (ret < 0
+			    || (trows != totCompData.header.force_node
+				|| tcolumns != 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_CX_FORCE_MAP_MIN failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(path_limits, &limit_file, SS_TOTAL_CX_FORCE_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+			if (ret < 0
+			    || (trows != totCompData.header.force_node
+				|| tcolumns != 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_CX_FORCE_MAP_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(totCompData.cx_fm, totCompData.header.force_node, 1, thresholds_min, thresholds_max);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMap SS TOTAL FORCE failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS TOTAL FORCE MIN MAX TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s SS TOTAL FORCE MIN MAX TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			logError(0,
+				 "%s SS TOTAL CX FORCE MIN MAX TEST:.................SKIPPED  \n",
+				 tag);
+
+
+		if (todo->SelfForceCxTotalAdj == 1) {
+			logError(1, "%s SS TOTAL CX FORCE ADJVERT TEST:  \n",
+				 tag);
+			ret = computeAdjVertTotal(totCompData.cx_fm, totCompData.header.force_node, 1, &total_adjvert);
+
+			if (ret < 0) {
+				logError(1,
+					 "%s production_test_data: computeAdjVert SS TOTAL CX FORCE ADJV failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			logError(0, "%s SS TOTAL CX FORCE ADJV computed! \n",
+				 tag);
+			ret =
+				parseProductionTestLimits(path_limits, &limit_file,
+							  SS_TOTAL_CX_FORCE_ADJV_MAP_MAX,
+							  &thresholds_max, &trows,
+							  &tcolumns);
+
+			if (ret < 0
+			    || (trows != totCompData.header.force_node - 1
+				|| tcolumns != 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_CX_FORCE_ADJV_MAP_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret =
+				checkLimitsMapAdjTotal(total_adjvert,
+						       totCompData.
+						       header.force_node - 1, 1,
+						       thresholds_max);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMap SS TOTAL CX FORCE failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS TOTAL CX FORCE ADJV TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s SS TOTAL CX FORCE ADJV TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjvert);
+			total_adjvert = NULL;
+		} else
+			logError(0,
+				 "%s SS TOTAL CX FORCE ADJ TEST:.................SKIPPED  \n",
+				 tag);
+	} else
+		logError(0,
+			 "%s SS TOTAL CX FORCE TEST:.................SKIPPED \n\n",
+			 tag);
+
+	/********************************************************* SS SENSE CX ****************************************************************/
+
+	if (todo->SelfSenseCx1 == 1) {
+		logError(1, "%s SS CX1 SENSE TEST:  \n", tag);
+		ret =
+			parseProductionTestLimits(path_limits, &limit_file,
+						  SS_CX1_SENSE_MIN_MAX, &thresholds,
+						  &trows, &tcolumns);
+
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_CX1_SENSE_MIN_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (short)ssCompData.s_cx1;
+		ret =
+			checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					  thresholds[1]);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMinMax SS CX1 SENSE TEST failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s SS CX1 SENSE TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds);
+		thresholds = NULL;
+	} else
+		logError(0,
+			 "%s SS CX1 SENSE TEST:.................SKIPPED \n\n",
+			 tag);
+
+
+	if (todo->SelfSenseCx2 == 1) {
+		logError(1, "%s SS CX2 SENSE MIN MAX TEST:  \n", tag);
+		ret = parseProductionTestLimits(path_limits, &limit_file, SS_CX2_SENSE_MAP_MIN, &thresholds_min, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != 1
+			|| tcolumns != ssCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_CX2_SENSE_MAP_MIN failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(path_limits, &limit_file, SS_CX2_SENSE_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != 1
+			|| tcolumns != ssCompData.header.sense_node)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_CX2_SENSE_MAP_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMap(ssCompData.cx2_sn, 1, ssCompData.header.sense_node, thresholds_min, thresholds_max);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMap SS CX2 SENSE failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s SS CX2 SENSE MIN MAX TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s SS CX2 SENSE MIN MAX TEST:.................OK \n\n",
+				 tag);
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		logError(0,
+			 "%s SS CX2 SENSE MIN MAX TEST:.................SKIPPED  \n",
+			 tag);
+
+
+	if (todo->SelfSenseCx2Adj == 1) {
+		logError(1, "%s SS CX2 SENSE ADJHORIZ TEST:  \n", tag);
+		ret =
+			computeAdjHoriz(ssCompData.cx2_sn, 1,
+					ssCompData.header.sense_node, &adjhor);
+
+		if (ret < 0) {
+			logError(1,
+				 "%s production_test_data: computeAdjHoriz SS CX2 SENSE ADJH failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		logError(0, "%s SS CX2 SENSE ADJH computed! \n", tag);
+		ret = parseProductionTestLimits(path_limits, &limit_file, SS_CX2_SENSE_ADJH_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+		if (ret < 0
+		    || (trows != 1
+			|| tcolumns != ssCompData.header.sense_node - 1)) {
+			logError(1,
+				 "%s production_test_data: parseProductionTestLimits SS_IX2_SENSE_MAP_MAX failed... ERROR %08X \n",
+				 tag, ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjhor, 1, ssCompData.header.sense_node - 1, thresholds_max);
+
+		if (ret != OK) {
+			logError(1,
+				 "%s production_test_data: checkLimitsMapAdj SS CX2 SENSE ADJH failed... ERROR COUNT = %d \n",
+				 tag, ret);
+			logError(0,
+				 "%s SS CX2 SENSE ADJH TEST:.................FAIL \n\n",
+				 tag);
+			count_fail += 1;
+
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			logError(0,
+				 "%s SS CX2 SENSE ADJH TEST:.................OK \n",
+				 tag);
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjhor);
+		adjhor = NULL;
+	} else
+		logError(0,
+			 "%s SS CX2 SENSE ADJ TEST:.................SKIPPED \n\n",
+			 tag);
+
+
+	if (todo->SelfSenseCxTotal == 1 || todo->SelfSenseCxTotalAdj == 1) {
+
+		if (todo->SelfSenseCxTotal == 1) {
+			logError(1, "%s SS TOTAL CX SENSE MIN MAX TEST:  \n", tag);
+			ret = parseProductionTestLimits(path_limits, &limit_file, SS_TOTAL_CX_SENSE_MAP_MIN, &thresholds_min, &trows, &tcolumns);
+
+			if (ret < 0
+			    || (trows != 1
+				|| tcolumns != totCompData.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_CX_SENSE_MAP_MIN failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(path_limits, &limit_file, SS_TOTAL_CX_SENSE_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+			if (ret < 0
+			    || (trows != 1
+				|| tcolumns != totCompData.header.sense_node)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_CX_SENSE_MAP_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(totCompData.cx_sn, 1, totCompData.header.sense_node, thresholds_min, thresholds_max);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMap SS TOTAL CX SENSE failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS TOTAL CX SENSE MIN MAX TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s SS TOTAL CX SENSE MIN MAX TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			logError(0,
+				 "%s SS TOTAL CX SENSE MIN MAX TEST:.................SKIPPED  \n",
+				 tag);
+
+
+		if (todo->SelfSenseCxTotalAdj == 1) {
+			logError(1, "%s SS TOTAL CX SENSE ADJHORIZ TEST:  \n",
+				 tag);
+			ret =
+				computeAdjHorizTotal(totCompData.cx_sn, 1,
+						     totCompData.header.sense_node,
+						     &total_adjhor);
+
+			if (ret < 0) {
+				logError(1,
+					 "%s production_test_data: computeAdjHoriz SS TOTAL CX SENSE ADJH failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			logError(0,
+				 "%s SS TOTAL CX SENSE ADJ HORIZ computed! \n",
+				 tag);
+			ret = parseProductionTestLimits(path_limits, &limit_file, SS_TOTAL_CX_SENSE_ADJH_MAP_MAX, &thresholds_max, &trows, &tcolumns);
+
+			if (ret < 0
+			    || (trows != 1
+				|| tcolumns !=
+				totCompData.header.sense_node - 1)) {
+				logError(1,
+					 "%s production_test_data: parseProductionTestLimits SS_TOTAL_CX_SENSE_ADJH_MAP_MAX failed... ERROR %08X \n",
+					 tag, ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjhor, 1, totCompData.header.sense_node - 1, thresholds_max);
+
+			if (ret != OK) {
+				logError(1,
+					 "%s production_test_data: checkLimitsMapAdj SS TOTAL CX SENSE ADJH failed... ERROR COUNT = %d \n",
+					 tag, ret);
+				logError(0,
+					 "%s SS TOTAL CX SENSE ADJH TEST:.................FAIL \n\n",
+					 tag);
+				count_fail += 1;
+
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				logError(0,
+					 "%s SS TOTAL CX SENSE ADJH TEST:.................OK \n\n",
+					 tag);
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjhor);
+			total_adjhor = NULL;
+		} else
+			logError(0,
+				 "%s SS TOTAL CX SENSE ADJ TEST:.................SKIPPED  \n",
+				 tag);
+	} else
+		logError(0,
+			 "%s SS TOTAL CX SENSE TEST:.................SKIPPED  \n",
+			 tag);
+	if (todo->SelfHoverForceIxTotal == 1 || todo->SelfHoverSenceIxTotal == 1) {
+		ret = production_test_ss_hover_ix(path_limits, stop_on_fail, todo);
+		if (ret < OK) {
+			logError(1,
+				 "%s production_test_data: production_test_ss_hover_ix_cx failed... ERROR = %08X\n",
+				 tag, ret);
+			count_fail += 1;
+		}
+	}
+
+ERROR:
+	logError(0, "%s \n", tag);
+
+	if (count_fail == 0) {
+		kfree(ssCompData.ix2_fm);
+		ssCompData.ix2_fm = NULL;
+		kfree(ssCompData.ix2_sn);
+		ssCompData.ix2_sn = NULL;
+		kfree(ssCompData.cx2_fm);
+		ssCompData.cx2_fm = NULL;
+		kfree(ssCompData.cx2_sn);
+		ssCompData.cx2_sn = NULL;
+		kfree(totCompData.ix_fm);
+		totCompData.ix_fm = NULL;
+		kfree(totCompData.ix_sn);
+		totCompData.ix_sn = NULL;
+		kfree(totCompData.cx_fm);
+		totCompData.cx_fm = NULL;
+		kfree(totCompData.cx_sn);
+		totCompData.cx_sn = NULL;
+		logError(0,
+			 "%s SS IX CX testes finished!.................OK\n\n",
+			 tag);
+		return OK;
+	} else {
+		print_frame_u8("SS Init Data Ix2_fm = ",
+			       array1dTo2d_u8(ssCompData.ix2_fm,
+					      ssCompData.header.force_node, 1),
+			       ssCompData.header.force_node, 1);
+		print_frame_i8("SS Init Data Cx2_fm = ",
+			       array1dTo2d_i8(ssCompData.cx2_fm,
+					      ssCompData.header.force_node, 1),
+			       ssCompData.header.force_node, 1);
+		print_frame_u8("SS Init Data Ix2_sn = ",
+			       array1dTo2d_u8(ssCompData.ix2_sn,
+					      ssCompData.header.sense_node,
+					      ssCompData.header.sense_node), 1,
+			       ssCompData.header.sense_node);
+		print_frame_i8("SS Init Data Cx2_sn = ",
+			       array1dTo2d_i8(ssCompData.cx2_sn,
+					      ssCompData.header.sense_node,
+					      ssCompData.header.sense_node), 1,
+			       ssCompData.header.sense_node);
+		print_frame_u16("TOT SS Init Data Ix_fm = ",
+				array1dTo2d_u16(totCompData.ix_fm,
+						totCompData.header.force_node,
+						1),
+				totCompData.header.force_node, 1);
+		print_frame_short("TOT SS Init Data Cx_fm = ",
+				  array1dTo2d_short(totCompData.cx_fm,
+						    totCompData.header.
+						    force_node, 1),
+				  totCompData.header.force_node, 1);
+		print_frame_u16("TOT SS Init Data Ix_sn = ",
+				array1dTo2d_u16(totCompData.ix_sn,
+						totCompData.header.sense_node,
+						totCompData.header.sense_node),
+				1, totCompData.header.sense_node);
+		print_frame_short("TOT SS Init Data Cx_sn = ",
+				  array1dTo2d_short(totCompData.cx_sn,
+						    totCompData.header.
+						    sense_node,
+						    totCompData.header.
+						    sense_node), 1,
+				  totCompData.header.sense_node);
+		logError(0,
+			 "%s SS IX CX testes finished!.................FAILED  fails_count = %d\n\n",
+			 tag, count_fail);
+
+		if (thresholds != NULL)
+			kfree(thresholds);
+
+		if (thresholds_min != NULL)
+			kfree(thresholds_min);
+
+		if (thresholds_max != NULL)
+			kfree(thresholds_max);
+
+		if (adjhor != NULL)
+			kfree(adjhor);
+
+		if (adjvert != NULL)
+			kfree(adjvert);
+
+		if (total_adjhor != NULL)
+			kfree(total_adjhor);
+
+		if (total_adjvert != NULL)
+			kfree(total_adjvert);
+
+		if (ssCompData.ix2_fm != NULL)
+			kfree(ssCompData.ix2_fm);
+
+		if (ssCompData.ix2_sn != NULL)
+			kfree(ssCompData.ix2_sn);
+
+		if (ssCompData.cx2_fm != NULL)
+			kfree(ssCompData.cx2_fm);
+
+		if (ssCompData.cx2_sn != NULL)
+			kfree(ssCompData.cx2_sn);
+
+		if (totCompData.ix_fm != NULL)
+			kfree(totCompData.ix_fm);
+
+		if (totCompData.ix_sn != NULL)
+			kfree(totCompData.ix_sn);
+
+		if (totCompData.cx_fm != NULL)
+			kfree(totCompData.cx_fm);
+
+		if (totCompData.cx_sn != NULL)
+			kfree(totCompData.cx_sn);
+
+		return (ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA);
+	}
+
+ERROR_LIMITS:
+
+	if (thresholds != NULL)
+		kfree(thresholds);
+
+	if (thresholds_min != NULL)
+		kfree(thresholds_min);
+
+	if (thresholds_max != NULL)
+		kfree(thresholds_max);
+
+	if (adjhor != NULL)
+		kfree(adjhor);
+
+	if (adjvert != NULL)
+		kfree(adjvert);
+
+	if (total_adjhor != NULL)
+		kfree(total_adjhor);
+
+	if (total_adjvert != NULL)
+		kfree(total_adjvert);
+
+	if (ssCompData.ix2_fm != NULL)
+		kfree(ssCompData.ix2_fm);
+
+	if (ssCompData.ix2_sn != NULL)
+		kfree(ssCompData.ix2_sn);
+
+	if (ssCompData.cx2_fm != NULL)
+		kfree(ssCompData.cx2_fm);
+
+	if (ssCompData.cx2_sn != NULL)
+		kfree(ssCompData.cx2_sn);
+
+	if (totCompData.ix_fm != NULL)
+		kfree(totCompData.ix_fm);
+
+	if (totCompData.ix_sn != NULL)
+		kfree(totCompData.ix_sn);
+
+	if (totCompData.cx_fm != NULL)
+		kfree(totCompData.cx_fm);
+
+	if (totCompData.cx_sn != NULL)
+		kfree(totCompData.cx_sn);
+
+	return ret;
+}
+
+/**
+ * Perform a complete Data Test check of the IC
+ * @param path_limits name of Production Limit file to load or "NULL" if the limits data should be loaded by a .h file
+ * @param stop_on_fail if 1, the test flow stops at the first data check failure otherwise it keeps going performing all the selected test
+ * @param todo pointer to a TestToDo variable which select the test to do
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int production_test_data(char *path_limits, int stop_on_fail, TestToDo *todo)
+{
+	int res = OK, ret;
+
+	if (todo == NULL) {
+		logError(1,
+			 "%s production_test_data: No TestToDo specified!! ERROR = %08X \n",
+			 tag, (ERROR_OP_NOT_ALLOW | ERROR_PROD_TEST_DATA));
+		return (ERROR_OP_NOT_ALLOW | ERROR_PROD_TEST_DATA);
+	}
+
+	logError(1, "%s DATA Production test is starting...\n", tag);
+	ret = production_test_ms_raw(path_limits, stop_on_fail, todo);
+	res |= ret;
+
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: production_test_ms_raw failed... ERROR = %08X \n",
+			 tag, ret);
+
+		if (stop_on_fail == 1)
+			goto END;
+	}
+
+	ret = production_test_ms_cx(path_limits, stop_on_fail, todo);
+	res |= ret;
+
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: production_test_ms_cx failed... ERROR = %08X \n",
+			 tag, ret);
+
+		if (stop_on_fail == 1)
+			goto END;
+	}
+
+	ret = production_test_ss_raw(path_limits, stop_on_fail, todo);
+	res |= ret;
+
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: production_test_ss_raw failed... ERROR = %08X \n",
+			 tag, ret);
+
+		if (stop_on_fail == 1)
+			goto END;
+	}
+
+	ret = production_test_ss_ix_cx(path_limits, stop_on_fail, todo);
+	res |= ret;
+
+	if (ret < 0) {
+		logError(1,
+			 "%s production_test_data: production_test_ss_ix_cx failed... ERROR = %08X \n",
+			 tag, ret);
+
+		if (stop_on_fail == 1)
+			goto END;
+	}
+
+END:
+	freeLimitsFile(&limit_file);
+
+	if (res < OK)
+		logError(0, "%s DATA Production test failed!\n", tag);
+	else
+		logError(0, "%s DATA Production test finished!\n", tag);
+
+	return res;
+}
+
+/**
+ * Retrieve the actual Test Limit data from the system (bin file or header file)
+ * @param path name of Production Test Limit file to load or "NULL" if the limits data should be loaded by a .h file
+ * @param file pointer to the LimitFile struct which will contains the limits data
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int getLimitsFile(char *path, LimitFile *file)
+{
+	const struct firmware *fw = NULL;
+	struct device *dev = NULL;
+	int fd = -1;
+	logError(0, "%s Get Limits File starting... %s\n", tag, path);
+
+	if (file->data != NULL) {
+		logError(0,
+			 "%s Pointer to Limits Data already contains something... freeing its content!\n",
+			 tag);
+		kfree(file->data);
+		file->data = NULL;
+		file->size = 0;
+	}
+
+	strncpy(file->name, path, MAX_LIMIT_FILE_NAME -1);
+	file->name[MAX_LIMIT_FILE_NAME - 1] = '\0';
+
+	if (strncmp(path, "NULL", 4) == 0) {
+#ifdef LIMITS_H_FILE
+		logError(0, "%s Loading Limits File from .h!\n", tag);
+		file->size = LIMITS_SIZE_NAME;
+		file->data =
+			(char *)kmalloc((file->size) * sizeof(char), GFP_KERNEL);
+
+		if (file->data != NULL) {
+			memcpy(file->data, (char *)(LIMITS_ARRAY_NAME),
+			       file->size);
+			return OK;
+		} else {
+			logError(1,
+				 "%s Error while allocating data... ERROR %08X \n",
+				 tag, path, ERROR_ALLOC);
+			return ERROR_ALLOC;
+		}
+
+#else
+		logError(1, "%s limit file path NULL... ERROR %08X \n", tag,
+			 ERROR_FILE_NOT_FOUND);
+		return ERROR_FILE_NOT_FOUND;
+#endif
+	} else {
+		dev = getDev();
+
+		if (dev != NULL) {
+			logError(0, "%s Loading Limits File from .csv!\n", tag);
+			fd = request_firmware(&fw, path, dev);
+
+			if (fd == 0) {
+				logError(0, "%s Start to copy %s...\n", tag,
+					 path);
+				file->size = fw->size;
+				file->data =
+					(char *)kmalloc((file->size) * sizeof(char),
+							GFP_KERNEL);
+
+				if (file->data != NULL) {
+					memcpy(file->data, (char *)fw->data,
+					       file->size);
+					logError(0,
+						 "%s Limit file Size = %d \n",
+						 tag, file->size);
+					release_firmware(fw);
+					return OK;
+				} else {
+					logError(1,
+						 "%s Error while allocating data... ERROR %08X \n",
+						 tag, path, ERROR_ALLOC);
+					release_firmware(fw);
+					return ERROR_ALLOC;
+				}
+			} else {
+				logError(1,
+					 "%s Request the file %s failed... ERROR %08X \n",
+					 tag, path, ERROR_FILE_NOT_FOUND);
+				return ERROR_FILE_NOT_FOUND;
+			}
+		} else {
+			logError(1,
+				 "%s Error while getting the device ERROR %08X \n",
+				 tag, ERROR_FILE_READ);
+			return ERROR_FILE_READ;
+		}
+	}
+}
+
+/**
+ * Reset and release the memory which store a Production Limit File previously loaded
+ * @param file pointer to the LimitFile struct to free
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+
+int freeLimitsFile(LimitFile *file)
+{
+	logError(0, "%s Freeing Limit File ...\n", tag);
+
+	if (file != NULL) {
+		if (file->data != NULL) {
+			kfree(file->data);
+			file->data = NULL;
+		} else
+			logError(0, "%s Limit File was already freed!\n", tag);
+
+		file->size = 0;
+		strncpy(file->name, " ", MAX_LIMIT_FILE_NAME);
+		return OK;
+	} else {
+		logError(1, "%s Passed a NULL argument! ERROR %08X \n", tag,
+			 ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+}
+
+/**
+ * Reset and release the memory which store the current Limit File previously loaded
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+
+int freeCurrentLimitsFile(void)
+{
+	return freeLimitsFile(&limit_file);
+}
+
+/**
+ * Parse the raw data read from a Production test limit file in order to find the specified information
+ * If no limits file data are passed, the function loads and stores the limit file from the system
+ * @param path name of Production Test Limit file to load or "NULL" if the limits data should be loaded by a .h file
+ * @param file pointer to LimitFile struct that should be parsed or NULL if the limit file in the system should be loaded and then parsed
+ * @param label string which identify a particular set of data in the file that want to be loaded
+ * @param data pointer to the pointer which will contains the specified limits data as 1 dimension matrix with data arranged row after row
+ * @param row pointer to a int variable which will contain the number of row of data
+ * @param column pointer to a int variable which will contain the number of column of data
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int parseProductionTestLimits(char *path, LimitFile *file, char *label,
+			      int **data, int *row, int *column)
+{
+	int find = 0;
+	char *token = NULL;
+	int i = 0;
+	int j = 0;
+	int z = 0;
+	char *line2 = NULL;
+	char line[800];
+	char *buf = NULL;
+	int n, size, pointer = 0, ret = OK;
+	char *data_file = NULL;
+
+	if (file == NULL || strcmp(path, file->name) != 0 || file->size == 0) {
+		logError(0,
+			 "%s No limit File data passed... try to get them from the system!\n",
+			 tag);
+		ret = getLimitsFile(LIMITS_FILE, &limit_file);
+
+		if (ret < OK) {
+			logError(1,
+				 "%s parseProductionTestLimits: ERROR %08X\n",
+				 tag, ERROR_FILE_NOT_FOUND);
+			return ERROR_FILE_NOT_FOUND;
+		}
+
+		size = limit_file.size;
+		data_file = limit_file.data;
+	} else {
+		logError(0, "%s Limit File data passed as arguments!\n", tag);
+		size = file->size;
+		data_file = file->data;
+	}
+
+	logError(0, "%s The size of the limits file is %d bytes...\n", tag,
+		 size);
+
+	while (find == 0) {
+		if (readLine(&data_file[pointer], line, size - pointer, &n) < 0) {
+			find = -1;
+			break;
+		}
+
+		pointer += n;
+
+		if (line[0] == '*') {
+			line2 = kstrdup(line, GFP_KERNEL);
+
+			if (line2 == NULL) {
+				logError(1,
+					 "%s parseProductionTestLimits: kstrdup ERROR %08X\n",
+					 tag, ERROR_ALLOC);
+				ret = ERROR_ALLOC;
+				goto END;
+			}
+
+			buf = line2;
+			line2 += 1;
+			token = strsep(&line2, ",");
+
+			if (strcmp(token, label) == 0) {
+				find = 1;
+				token = strsep(&line2, ",");
+
+				if (token != NULL) {
+					sscanf(token, "%d", row);
+					logError(0, "%s Row = %d\n", tag, *row);
+				} else {
+					logError(1,
+						 "%s parseProductionTestLimits 1: ERROR %08X\n",
+						 tag, ERROR_FILE_PARSE);
+					ret = ERROR_FILE_PARSE;
+					goto END;
+				}
+
+				token = strsep(&line2, ",");
+
+				if (token != NULL) {
+					sscanf(token, "%d", column);
+					logError(0, "%s Column = %d\n", tag,
+						 *column);
+				} else {
+					logError(1,
+						 "%s parseProductionTestLimits 2: ERROR %08X\n",
+						 tag, ERROR_FILE_PARSE);
+					ret = ERROR_FILE_PARSE;
+					goto END;
+				}
+
+				kfree(buf);
+				buf = NULL;
+				*data = (int *)kmalloc(((*row) * (*column)) * sizeof(int), GFP_KERNEL);
+				j = 0;
+
+				if (*data == NULL) {
+					logError(1,
+						 "%s parseProductionTestLimits: ERROR %08X\n",
+						 tag, ERROR_ALLOC);
+					ret = ERROR_ALLOC;
+					goto END;
+				}
+
+				for (i = 0; i < *row; i++) {
+					if (readLine
+					    (&data_file[pointer], line,
+					     size - pointer, &n) < 0) {
+						logError(1,
+							 "%s parseProductionTestLimits : ERROR %08X\n",
+							 tag, ERROR_FILE_READ);
+						ret = ERROR_FILE_READ;
+						goto END;
+					}
+
+					pointer += n;
+					line2 = kstrdup(line, GFP_KERNEL);
+
+					if (line2 == NULL) {
+						logError(1,
+							 "%s parseProductionTestLimits: kstrdup ERROR %08X\n",
+							 tag, ERROR_ALLOC);
+						ret = ERROR_ALLOC;
+						goto END;
+					}
+
+					buf = line2;
+					token = strsep(&line2, ",");
+
+					for (z = 0;
+					     (z < *column) && (token != NULL);
+					     z++) {
+						sscanf(token, "%d",
+						       ((*data) + j));
+						j++;
+						token = strsep(&line2, ",");
+					}
+
+					kfree(buf);
+					buf = NULL;
+				}
+
+				if (j == ((*row) * (*column))) {
+					logError(0, "%s READ DONE!\n", tag);
+					ret = OK;
+					goto END;
+				}
+
+				logError(1,
+					 "%s parseProductionTestLimits 3: ERROR %08X\n",
+					 tag, ERROR_FILE_PARSE);
+				ret = ERROR_FILE_PARSE;
+				goto END;
+			}
+
+			kfree(buf);
+			buf = NULL;
+		}
+	}
+
+	logError(1, "%s parseProductionTestLimits: ERROR %08X\n", tag,
+		 ERROR_LABEL_NOT_FOUND);
+	ret = ERROR_LABEL_NOT_FOUND;
+END:
+
+	if (buf != NULL)
+		kfree(buf);
+
+	return ret;
+}
+
+/**
+ * Read one line of a text file passed as array of byte and terminate it with a termination character '\0'
+ * @param data text file as array of bytes
+ * @param line pointer to an array of char that will contain the line read
+ * @param size size of data
+ * @param n pointer to a int variable which will contain the number of characters of the line
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int readLine(char *data, char *line, int size, int *n)
+{
+	int i = 0;
+
+	if (size < 1)
+		return -EINVAL;
+
+	while (data[i] != '\n' && i < size) {
+		line[i] = data[i];
+		i++;
+	}
+
+	*n = i + 1;
+	line[i] = '\0';
+	return OK;
+}
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsTest.h b/drivers/input/touchscreen/stfts/fts_lib/ftsTest.h
new file mode 100644
index 000000000000..127dce0478ee
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsTest.h
@@ -0,0 +1,293 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*						FTS API for MP test								 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsTest.h
+* \brief Contains all the definitions and structs related to the Mass Production Test
+*/
+
+#ifndef FTS_TEST_H
+#define FTS_TEST_H
+
+#include "ftsSoftware.h"
+
+#ifndef LIMITS_H_FILE
+#define LIMITS_FILE						"stm_fts_production_limits.csv"			/*Name of the Production Test Limit File*/
+#else
+#define LIMITS_FILE						"NULL"
+#endif
+
+#define WAIT_FOR_FRESH_FRAMES			200										/*Time in ms to wait after start to sensing before reading a frame*/
+#define WAIT_AFTER_SENSEOFF				50										/*Time in ms to wait after stop sensing and before reading a frame from memory*/
+
+#define NO_INIT							0										/*No Initialization required during the MP*/
+
+#define RETRY_INIT_BOOT					3										/*number of retry of the initialization process at boot*/
+
+/** @defgroup mp_test Mass Production Test
+ * Mass production test API.
+ * Mass Production Test (MP) should be executed at least one time in the life of every device \n
+ * It used to verify that tit is not present any hardware damage and initialize some value of the chip in order to guarantee the working performance \n
+ * The MP test is made up by 3 steps:
+ * - ITO test = production_test_ito() \n
+ * - Initialization = production_test_initialization() \n
+ * - Data Test = production_test_data(), it is possible to select which items test thanks to the TestToDo struct\n
+ * To execute the Data Test it is mandatory load some thresholds that are stored in the Limit File.
+ * @{
+ */
+
+/** @defgroup limit_file Limit File
+ * @ingroup mp_test
+ * Production Test Limit File is a csv which contains thresholds of the data to test.
+ * This file can be loaded from the file system or stored as a header file according to the LIMITS_H_FILE define \n
+ * For each selectable test item there can be one or more associated labels which store the corresponding thresholds \n
+ * @{
+ */
+
+/** @defgroup test_labels Test Items Labels
+ * @ingroup limit_file
+ * Labels present in the Limit File and associated to the test items of TestToDo
+ * @{
+ */
+#define MS_RAW_MIN_MAX					"MS_RAW_DATA_MIN_MAX"
+#define MS_RAW_EACH_NODE_MIN			"MS_RAW_DATA_EACH_MIN"
+#define MS_RAW_EACH_NODE_MAX			"MS_RAW_DATA_EACH_MAX"
+#define MS_RAW_GAP						"MS_RAW_DATA_GAP"
+#define MS_RAW_ADJH						"MS_RAW_DATA_ADJ_HORIZONTAL"
+#define MS_RAW_ADJV						"MS_RAW_DATA_ADJ_VERTICAL"
+#define MS_RAW_ITO_ADJH					"MS_RAW_ITO_DATA_ADJ_HORIZONTAL"
+#define MS_RAW_ITO_ADJV					"MS_RAW_ITO_DATA_ADJ_VERTICAL"
+#define MS_RAW_LP_MIN_MAX				"MS_RAW_LOWPOWER_DATA_MIN_MAX"
+#define MS_RAW_LP_GAP					"MS_RAW_LOWPOWER_DATA_GAP"
+#define MS_RAW_LP_ADJH					"MS_RAW_LOWPOWER_DATA_ADJ_HORIZONTAL"
+#define MS_RAW_LP_ADJV					"MS_RAW_LOWPOWER_DATA_ADJ_VERTICAL"
+#define MS_CX1_MIN_MAX					"MS_TOUCH_ACTIVE_CX1_MIN_MAX"
+#define MS_CX2_MAP_MIN					"MS_TOUCH_ACTIVE_CX2_MIN"
+#define MS_CX2_MAP_MAX					"MS_TOUCH_ACTIVE_CX2_MAX"
+#define MS_CX2_ADJH_MAP_MAX				"MS_TOUCH_ACTIVE_CX2_ADJ_HORIZONTAL"
+#define MS_CX2_ADJV_MAP_MAX				"MS_TOUCH_ACTIVE_CX2_ADJ_VERTICAL"
+#define MS_TOTAL_CX_MAP_MIN				"MS_TOUCH_ACTIVE_TOTAL_CX_MIN"
+#define MS_TOTAL_CX_MAP_MAX				"MS_TOUCH_ACTIVE_TOTAL_CX_MAX"
+#define MS_TOTAL_CX_ADJH_MAP_MAX		"MS_TOUCH_ACTIVE_TOTAL_CX_ADJ_HORIZONTAL"
+#define MS_TOTAL_CX_ADJV_MAP_MAX		"MS_TOUCH_ACTIVE_TOTAL_CX_ADJ_VERTICAL"
+#define MS_CX1_LP_MIN_MAX		"MS_TOUCH_LOWPOWER_CX1_MIN_MAX"
+#define MS_CX2_LP_MAP_MIN		"MS_TOUCH_LOWPOWER_CX2_MIN"
+#define MS_CX2_LP_MAP_MAX		"MS_TOUCH_LOWPOWER_CX2_MAX"
+#define MS_CX2_ADJH_LP_MAP_MAX	"MS_TOUCH_LOWPOWER_CX2_ADJ_HORIZONTAL"
+#define MS_CX2_ADJV_LP_MAP_MAX	"MS_TOUCH_LOWPOWER_CX2_ADJ_VERTICAL"
+#define MS_TOTAL_CX_LP_MAP_MIN	"MS_TOUCH_LOWPOWER_TOTAL_CX_MIN"
+#define MS_TOTAL_CX_LP_MAP_MAX	"MS_TOUCH_LOWPOWER_TOTAL_CX_MAX"
+#define MS_TOTAL_CX_ADJH_LP_MAP_MAX "MS_TOUCH_LOWPOWER_TOTAL_CX_ADJ_HORIZONTAL"
+#define MS_TOTAL_CX_ADJV_LP_MAP_MAX "MS_TOUCH_LOWPOWER_TOTAL_CX_ADJ_VERTICAL"
+#define SS_RAW_FORCE_MIN_MAX			"SS_RAW_DATA_FORCE_MIN_MAX"
+#define SS_RAW_SENSE_MIN_MAX			"SS_RAW_DATA_SENSE_MIN_MAX"
+#define SS_RAW_FORCE_GAP				"SS_RAW_DATA_FORCE_GAP"
+#define SS_RAW_SENSE_GAP				"SS_RAW_DATA_SENSE_GAP"
+#define SS_RAW_LP_FORCE_MIN_MAX			"SS_RAW_LOWPOWER_DATA_FORCE_MIN_MAX"
+#define SS_RAW_LP_SENSE_MIN_MAX			"SS_RAW_LOWPOWER_DATA_SENSE_MIN_MAX"
+#define SS_RAW_LP_FORCE_GAP				"SS_RAW_LOWPOWER_DATA_FORCE_GAP"
+#define SS_RAW_LP_SENSE_GAP				"SS_RAW_LOWPOWER_DATA_SENSE_GAP"
+#define SS_IX1_FORCE_MIN_MAX			"SS_TOUCH_ACTIVE_IX1_FORCE_MIN_MAX"
+#define SS_IX1_SENSE_MIN_MAX			"SS_TOUCH_ACTIVE_IX1_SENSE_MIN_MAX"
+#define SS_CX1_FORCE_MIN_MAX			"SS_TOUCH_ACTIVE_CX1_FORCE_MIN_MAX"
+#define SS_CX1_SENSE_MIN_MAX			"SS_TOUCH_ACTIVE_CX1_SENSE_MIN_MAX"
+#define SS_IX2_FORCE_MAP_MIN			"SS_TOUCH_ACTIVE_IX2_FORCE_MIN"
+#define SS_IX2_FORCE_MAP_MAX			"SS_TOUCH_ACTIVE_IX2_FORCE_MAX"
+#define SS_IX2_SENSE_MAP_MIN			"SS_TOUCH_ACTIVE_IX2_SENSE_MIN"
+#define SS_IX2_SENSE_MAP_MAX			"SS_TOUCH_ACTIVE_IX2_SENSE_MAX"
+#define SS_IX2_FORCE_ADJV_MAP_MAX		"SS_TOUCH_ACTIVE_IX2_ADJ_VERTICAL"
+#define SS_IX2_SENSE_ADJH_MAP_MAX		"SS_TOUCH_ACTIVE_IX2_ADJ_HORIZONTAL"
+#define SS_CX2_FORCE_MAP_MIN			"SS_TOUCH_ACTIVE_CX2_FORCE_MIN"
+#define SS_CX2_FORCE_MAP_MAX			"SS_TOUCH_ACTIVE_CX2_FORCE_MAX"
+#define SS_CX2_SENSE_MAP_MIN			"SS_TOUCH_ACTIVE_CX2_SENSE_MIN"
+#define SS_CX2_SENSE_MAP_MAX			"SS_TOUCH_ACTIVE_CX2_SENSE_MAX"
+#define SS_CX2_FORCE_ADJV_MAP_MAX		"SS_TOUCH_ACTIVE_CX2_ADJ_VERTICAL"
+#define SS_CX2_SENSE_ADJH_MAP_MAX		"SS_TOUCH_ACTIVE_CX2_ADJ_HORIZONTAL"
+
+#define SS_TOTAL_IX_FORCE_MAP_MIN		"SS_TOUCH_ACTIVE_TOTAL_IX_FORCE_MIN"
+#define SS_TOTAL_IX_FORCE_MAP_MAX		"SS_TOUCH_ACTIVE_TOTAL_IX_FORCE_MAX"
+#define SS_TOTAL_IX_SENSE_MAP_MIN		"SS_TOUCH_ACTIVE_TOTAL_IX_SENSE_MIN"
+#define SS_TOTAL_IX_SENSE_MAP_MAX		"SS_TOUCH_ACTIVE_TOTAL_IX_SENSE_MAX"
+#define SS_TOTAL_IX_FORCE_ADJV_MAP_MAX	"SS_TOUCH_ACTIVE_TOTAL_IX_ADJ_VERTICAL"
+#define SS_TOTAL_IX_SENSE_ADJH_MAP_MAX	"SS_TOUCH_ACTIVE_TOTAL_IX_ADJ_HORIZONTAL"
+#define SS_TOTAL_CX_FORCE_MAP_MIN		"SS_TOUCH_ACTIVE_TOTAL_CX_FORCE_MIN"
+#define SS_TOTAL_CX_FORCE_MAP_MAX		"SS_TOUCH_ACTIVE_TOTAL_CX_FORCE_MAX"
+#define SS_TOTAL_CX_SENSE_MAP_MIN		"SS_TOUCH_ACTIVE_TOTAL_CX_SENSE_MIN"
+#define SS_TOTAL_CX_SENSE_MAP_MAX		"SS_TOUCH_ACTIVE_TOTAL_CX_SENSE_MAX"
+#define SS_TOTAL_CX_FORCE_ADJV_MAP_MAX	"SS_TOUCH_ACTIVE_TOTAL_CX_ADJ_VERTICAL"
+#define SS_TOTAL_CX_SENSE_ADJH_MAP_MAX	"SS_TOUCH_ACTIVE_TOTAL_CX_ADJ_HORIZONTAL"
+
+#define MS_KEY_RAW_MIN_MAX				"MS_KEY_RAW_DATA_MIN_MAX"
+#define MS_KEY_CX1_MIN_MAX				"MS_KEY_CX1_MIN_MAX"
+#define MS_KEY_CX2_MAP_MIN				"MS_KEY_CX2_MIN"
+#define MS_KEY_CX2_MAP_MAX				"MS_KEY_CX2_MAX"
+#define MS_KEY_TOTAL_CX_MAP_MIN			"MS_KEY_TOTAL_CX_MIN"
+#define MS_KEY_TOTAL_CX_MAP_MAX			"MS_KEY_TOTAL_CX_MAX"
+
+#define SS_IX1_FORCE_W                  "IX1_FORCE_W"
+#define SS_IX2_FORCE_W                  "IX2_FORCE_W"
+#define SS_IX1_SENSE_W                  "IX1_SENSE_W"
+#define SS_IX2_SENSE_W                  "IX2_SENSE_W"
+
+/* SS HOVER*/
+#define SS_HOVER_RAW_FORCE_MIN_MAX			"SS_RAW_HOVER_DATA_FORCE_MIN_MAX"
+#define SS_HOVER_TOTAL_IX_FORCE_MAP_MIN		"SS_HOVER_TOTAL_IX_FORCE_MIN"
+#define SS_HOVER_TOTAL_IX_FORCE_MAP_MAX		"SS_HOVER_TOTAL_IX_FORCE_MAX"
+#define SS_HOVER_RAW_SENSE_MIN_MAX			"SS_RAW_HOVER_DATA_SENSE_MIN_MAX"
+#define SS_HOVER_TOTAL_IX_SENSE_MAP_MIN		"SS_HOVER_TOTAL_IX_SENSE_MIN"
+#define SS_HOVER_TOTAL_IX_SENSE_MAP_MAX		"SS_HOVER_TOTAL_IX_SENSE_MAX"
+
+/** @}*/
+
+/**
+* Struct used to specify which test perform during the Mass Production Test.
+* For each test item selected in this structure, there should be one or more labels associated in the Limit file from where load the thresholds
+*/
+typedef struct {
+	int MutualRaw;																/*MS Raw min/Max test*/
+	int MutualRawEachNode;
+    int MutualRawGap;															/*MS Raw Gap(max-min) test*/
+	int MutualRawAdj;															/*MS Raw Adjacent test*/
+	int MutualRawLP;															/*MS Low Power Raw min/Max test*/
+    int MutualRawGapLP;															/*MS Low Power Raw Gap(max-min) test*/
+	int MutualRawAdjLP;															/*MS Low Power Raw Adjacent test*/
+	int MutualRawAdjITO;														/*MS Raw Adjacent test during ITO test*/
+
+	int MutualCx1;																/*MS Cx1 min/Max test*/
+	int MutualCx2;																/*MS Cx2 min/Max (for each node) test*/
+	int MutualCx2Adj;															/*MS Vertical and Horizontal Adj Cx2 min/Max (for each node) test*/
+	int MutualCxTotal;															/*MS Total Cx min/Max (for each node) test*/
+	int MutualCxTotalAdj;														/*MS Total vertical and Horizontal Adj Cx2 min/Max (for each node) test*/
+	int MutualCx1LP;	/* /< MS LowPower Cx1 min/Max test */
+	int MutualCx2LP;	/* /< MS LowPower Cx2 min/Max (for each node) test */
+	int MutualCx2AdjLP;	/* /< MS LowPower Vertical and Horizontal Adj Cx2 min/Max
+				 * (for each node) test */
+	int MutualCxTotalLP;	/* /< MS Total LowPower Cx min/Max (for each node) test
+				 * */
+	int MutualCxTotalAdjLP;	/* /< MS Total LowPower vertical and Horizontal Adj Cx2
+				 * min/Max (for each node) test */
+
+	int MutualKeyRaw;															/*MS Raw Key min/Max test*/
+	int MutualKeyCx1;															/*MS Cx1 Key min/Max test*/
+	int MutualKeyCx2;															/*MS Cx2 Key min/Max (for each node) test*/
+	int MutualKeyCxTotal;														/*MS Total Cx Key min/Max (for each node) test*/
+
+	int SelfHoverForceRaw;														/* SS Hover Force Raw min/Max test */
+	int SelfHoverSenceRaw;														/*SS Hover Sence Raw min/Max test */
+	int SelfHoverForceIxTotal;													/*SS Hover Total Force Ix min/Max (for each node)* test */
+	int SelfHoverSenceIxTotal;													/*SS Hover Total Sence Ix min/Max (for each node)* test */
+
+	int SelfForceRaw;															/*SS Force Raw min/Max test*/
+    int SelfForceRawGap;														/*SS Force Raw Gap(max-min) test*/
+	int SelfForceRawLP;															/*SS Low Power Force Raw min/Max test*/
+    int SelfForceRawGapLP;														/*SS Low Power Force Raw Gap(max-min) test*/
+
+	int SelfForceIx1;															/*SS Force Ix1 min/Max test*/
+	int SelfForceIx2;															/*SS Force Ix2 min/Max (for each node) test*/
+	int SelfForceIx2Adj;														/*SS Vertical Adj Force Ix2 min/Max (for each node) test*/
+	int SelfForceIxTotal;														/*SS Total Force Ix min/Max (for each node) test*/
+	int SelfForceIxTotalAdj;													/*SS Total Vertical Adj Force Ix min/Max (for each node) test*/
+	int SelfForceCx1;															/*SS Force Cx1 min/Max test*/
+	int SelfForceCx2;															/*SS Force Cx2 min/Max (for each node) test*/
+	int SelfForceCx2Adj;														/*SS Vertical Adj Force Cx2 min/Max (for each node) test*/
+	int SelfForceCxTotal;														/*SS Total Force Cx min/Max (for each node) test*/
+	int SelfForceCxTotalAdj;													/*SS Total Vertical Adj Force Cx min/Max (for each node) test*/
+
+	int SelfSenseRaw;															/*SS Sense Raw min/Max test*/
+    int SelfSenseRawGap;														/*SS Sense Raw Gap(max-min) test*/
+	int SelfSenseRawLP;															/*SS Low Power Sense Raw min/Max test*/
+    int SelfSenseRawGapLP;														/*SS Low Power Sense Raw Gap(max-min) test*/
+
+	int SelfSenseIx1;															/*SS Sense Ix1 min/Max test*/
+	int SelfSenseIx2;															/*SS Sense Ix2 min/Max (for each node) test*/
+	int SelfSenseIx2Adj;														/*SS Horizontal Adj Sense Ix2 min/Max (for each node) test*/
+	int SelfSenseIxTotal;														/*SS Total Horizontal Sense Ix min/Max (for each node) test*/
+	int SelfSenseIxTotalAdj;													/*SS Total Horizontal Adj Sense Ix min/Max (for each node) test*/
+	int SelfSenseCx1;															/*SS Sense Cx1 min/Max test*/
+	int SelfSenseCx2;															/*SS Sense Cx2 min/Max (for each node) test*/
+	int SelfSenseCx2Adj;														/*SS Horizontal Adj Sense Cx2 min/Max (for each node) test*/
+	int SelfSenseCxTotal;														/*SS Total Sense Cx min/Max (for each node) test*/
+	int SelfSenseCxTotalAdj;													/*SS Total Horizontal Adj Sense Cx min/Max (for each node) test*/
+
+} TestToDo;
+
+#define MAX_LIMIT_FILE_NAME					100									/*max number of chars of the limit file name*/
+
+/**
+ * Struct which store the data coming from a Production Limit File
+ */
+typedef struct {
+	char *data;
+	int size;
+	char name[MAX_LIMIT_FILE_NAME];
+} LimitFile;
+
+int initTestToDo(void);
+/**@}*/
+
+/**@}*/
+
+int computeAdjHoriz(i8 *data, int row, int column, u8 **result);
+int computeAdjHorizTotal(short *data, int row, int column, u16 **result);
+int computeAdjVert(i8 *data, int row, int column, u8 **result);
+int computeAdjVertTotal(short *data, int row, int column, u16 **result);
+int computeAdjHorizFromU(u8 *data, int row, int column, u8 **result);
+int computeAdjHorizTotalFromU(u16 *data, int row, int column, u16 **result);
+int computeAdjVertFromU(u8 *data, int row, int column, u8 **result);
+int computeAdjVertTotalFromU(u16 *data, int row, int column, u16 **result);
+int checkLimitsMinMax(short *data, int row, int column, int min, int max);
+int checkLimitsMap(i8 *data, int row, int column, int *min, int *max);
+int checkLimitsMapTotal(short *data, int row, int column, int *min, int *max);
+int checkLimitsMapFromU(u8 *data, int row, int column, int *min, int *max);
+int checkLimitsMapTotalFromU(u16 *data, int row, int column, int *min,
+			     int *max);
+int checkLimitsMapAdj(u8 *data, int row, int column, int *max);
+int checkLimitsMapAdjTotal(u16 *data, int row, int column, int *max);
+
+/**  @defgroup mp_api MP API
+ * @ingroup mp_test
+ * Functions to execute the MP test.
+ * The parameters of these functions allow to customize their behavior in order to satisfy different scenarios
+ * @{
+ */
+int production_test_ito(char *path_limits, TestToDo *todo);
+int production_test_initialization(u8 type);
+int production_test_main(char *pathThresholds, int stop_on_fail, int saveInit, TestToDo *todo);
+int production_test_ms_raw(char *path_limits, int stop_on_fail, TestToDo *todo);
+int production_test_ms_raw_lp(char *path_limits, int stop_on_fail, TestToDo *todo);
+int production_test_ms_cx(char *path_limits, int stop_on_fail, TestToDo *todo);
+int production_test_ms_cx_lp(char *path_limits, int stop_on_fail, TestToDo *todo);
+int production_test_ss_raw(char *path_limits, int stop_on_fail, TestToDo *todo);
+int production_test_ss_raw_lp(char *path_limits, int stop_on_fail, TestToDo *todo);
+int production_test_ss_ix_cx(char *path_limits, int stop_on_fail, TestToDo *todo);
+int production_test_data(char *path_limits, int stop_on_fail, TestToDo *todo);
+int production_test_ms_key_cx(char *path_limits, int stop_on_fail, TestToDo *todo);
+int production_test_ms_key_raw(char *path_limits);
+int computeTotal(u8 *data, u8 main, int row, int column, int m, int n,
+		 u16 **result);
+/** @}*/
+
+/**
+ * @addtogroup limit_file
+ * @{
+ */
+int parseProductionTestLimits(char *path, LimitFile *file, char *label, int **data, int *row, int *column);
+int readLine(char *data, char *line, int size, int *n);
+int getLimitsFile(char *path, LimitFile *file);
+int freeLimitsFile(LimitFile *file);
+int freeCurrentLimitsFile(void);
+/**@}*/
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsTime.c b/drivers/input/touchscreen/stfts/fts_lib/ftsTime.c
new file mode 100644
index 000000000000..fdfe308ff4f9
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsTime.c
@@ -0,0 +1,79 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*                  FTS Utility for mesuring/handling the time			 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsTime.c
+* \brief Contains all functions to handle and measure the time in the driver
+*/
+
+#include "ftsTime.h"
+
+#include <linux/errno.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+
+/**
+* Take the starting time and save it in a StopWatch variable
+* @param w pointer of a StopWatch struct
+*/
+void startStopWatch(StopWatch *w)
+{
+	ktime_get_coarse_real_ts64(&w->start);
+}
+
+/**
+* Take the stop time and save it in a StopWatch variable
+* @param w pointer of a StopWatch struct
+*/
+void stopStopWatch(StopWatch *w)
+{
+	ktime_get_coarse_real_ts64(&w->end);
+}
+
+/**
+* Compute the amount of time spent from when the startStopWatch and then the stopStopWatch were called on the StopWatch variable
+* @param w pointer of a StopWatch struct
+* @return amount of time in ms (the return value is meaningless if the startStopWatch and stopStopWatch were not called before)
+*/
+int elapsedMillisecond(StopWatch *w)
+{
+	int result;
+
+	result = ((w->end.tv_sec - w->start.tv_sec) * 1000) +
+		 (w->end.tv_nsec - w->start.tv_nsec) / 1000000;
+	return result;
+}
+
+/**
+* Compute the amount of time spent from when the startStopWatch and then the stopStopWatch were called on the StopWatch variable
+* @param w pointer of a StopWatch struct
+* @return amount of time in ns (the return value is meaningless if the startStopWatch and stopStopWatch were not called before)
+*/
+
+int elapsedNanosecond(StopWatch *w)
+{
+	int result;
+
+	result = ((w->end.tv_sec - w->start.tv_sec) * 1000000000) +
+		 (w->end.tv_nsec - w->start.tv_nsec);
+	return result;
+}
\ No newline at end of file
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsTime.h b/drivers/input/touchscreen/stfts/fts_lib/ftsTime.h
new file mode 100644
index 000000000000..5b9384fa75a0
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsTime.h
@@ -0,0 +1,55 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*                  FTS Utility for measuring/handling the time			 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsTime.h
+* \brief Contains all the definitions and structs to handle and measure the time in the driver
+*/
+
+#ifndef FTS_TIME_H
+#define FTS_TIME_H
+
+#include <linux/time.h>
+#include <linux/ktime.h>
+
+/** @defgroup timeouts	 Timeouts
+* Definitions of all the Timeout used in several operations
+* @{
+*/
+#define TIMEOUT_RESOLUTION							2									/*timeout resolution in ms (all timeout should be multiples of this unit)*/
+#define GENERAL_TIMEOUT								(50 * TIMEOUT_RESOLUTION)				/*general timeout in ms*/
+#define RELEASE_INFO_TIMEOUT						(15 * TIMEOUT_RESOLUTION)				/* timeout to request release info in ms*/
+
+#define TIMEOUT_REQU_COMP_DATA						(100 * TIMEOUT_RESOLUTION)				/*timeout to request compensation data in ms*/
+#define TIMEOUT_REQU_DATA							(100 * TIMEOUT_RESOLUTION)				/*timeout to request data in ms*/
+#define TIMEOUT_ITO_TEST_RESULT						(100 * TIMEOUT_RESOLUTION)				/*timeout to perform ito test in ms*/
+#define TIMEOUT_INITIALIZATION_TEST_RESULT			(5000 * TIMEOUT_RESOLUTION)				/*timeout to perform initialization test in ms*/
+#define TIMEOUT_ECHO								TIMEOUT_INITIALIZATION_TEST_RESULT	/*timeout of the echo command, should be the max of all the possible commands (used in worst case)*/
+/** @}*/
+
+/**
+*	Struct used to measure the time elapsed between a starting and ending point.
+*/
+typedef struct {
+	struct timespec64 start;	/* /< store the starting time */
+	struct timespec64 end;	/* /< store the finishing time */
+} StopWatch;
+
+void startStopWatch(StopWatch *w);
+void stopStopWatch(StopWatch *w);
+int elapsedMillisecond(StopWatch *w);
+int elapsedNanosecond(StopWatch *w);
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsTool.c b/drivers/input/touchscreen/stfts/fts_lib/ftsTool.c
new file mode 100644
index 000000000000..1fab953f1b89
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsTool.c
@@ -0,0 +1,650 @@
+/*
+
+ **************************************************************************
+ **                        STMicroelectronics							 **
+ **************************************************************************
+ **                        marco.cali@st.com							**
+ **************************************************************************
+ *                                                                        *
+ *                     FTS Utility Functions							  *
+ *                                                                        *
+ **************************************************************************
+ **************************************************************************
+
+ */
+
+/*!
+* \file ftsTool.c
+* \brief Contains all the functions to support common operation inside the driver
+*/
+
+#include "ftsCompensation.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsHardware.h"
+#include "ftsIO.h"
+#include "ftsSoftware.h"
+#include "ftsTime.h"
+#include "ftsTool.h"
+#include "../fts.h"
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/serio.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+
+/**
+* Print an array of byte in a HEX string and attach at the beginning a label. The function allocate memory that should be free outside the function itself
+* @param label string to attach at the beginning
+* @param buff pointer to the byte array that should be printed as HEX string
+* @param count size of buff
+* @return pointer to the array of characters that compose the HEX string. This point should be free outside when the string is no more needed
+*/
+char *printHex(char *label, u8 *buff, int count, u8 *result)
+{
+	int i, offset;
+
+	offset = strlen(label);
+
+	strncpy(result, label, offset - 1);
+	result[offset - 1] = '\0';
+
+	for (i = 0; i < count; i++) {
+		snprintf(&result[offset], 4, "%02X ", buff[i]);
+		offset += 3;
+	}
+
+	return result;
+}
+
+char *printHex_data(char *label, u8 *buff, int count)
+{
+	int i, offset;
+	char *result = NULL;
+
+	offset = strlen(label);
+	result =
+	    (char *)kmalloc(((offset + 4 * count) + 1) * sizeof(char),
+			    GFP_KERNEL);
+	if (result != NULL) {
+		strncpy(result, label, offset - 1);
+		result[offset - 1] = '\0';
+
+		for (i = 0; i < count; i++) {
+			snprintf(&result[offset], 4, "%02X ", buff[i]);
+			offset += 3;
+		}
+
+		strlcat(result, "\n", ((offset + 4 * count) + 1) * sizeof(char));
+	}
+	return result;
+}
+
+/**
+ * Clear the FIFO from any event
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int flushFIFO(void)
+{
+
+	int ret;
+	u8 sett = SPECIAL_FIFO_FLUSH;
+	ret = writeSysCmd(SYS_CMD_SPECIAL, &sett, 1);
+	if (ret < OK) {
+		logError(1, "%s flushFIFO: ERROR %08X \n", tag, ret);
+		return ret;
+	}
+
+	logError(0, "%s FIFO flushed! \n", tag);
+	return OK;
+
+}
+
+/**
+* Convert an array of bytes to an array of u16 taking two bytes at time, src has LSB first.
+* @param src pointer to the source byte array
+* @param src_length size of src
+* @param dst pointer to the destination array.
+* @return the final size of dst (half of the source) or ERROR_OP_NOT_ALLOW if the size of src is not multiple of 2.
+*/
+int u8ToU16n(u8 *src, int src_length, u16 *dst)
+{
+	int i, j;
+
+	if (src_length % 2 != 0) {
+		return ERROR_OP_NOT_ALLOW;
+	} else {
+		j = 0;
+		dst =
+		    (u16 *) kmalloc((src_length / 2) * sizeof(u16), GFP_KERNEL);
+		for (i = 0; i < src_length; i += 2) {
+			dst[j] =
+			    ((src[i + 1] & 0x00FF) << 8) + (src[i] & 0x00FF);
+			j++;
+		}
+	}
+
+	return (src_length / 2);
+}
+
+/**
+* Convert an array of 2 bytes to a u16, src has LSB first (little endian).
+* @param src pointer to the source byte array
+* @param dst pointer to the destination u16.
+* @return OK
+*/
+int u8ToU16(u8 *src, u16 *dst)
+{
+	*dst = (u16) (((src[1] & 0x00FF) << 8) + (src[0] & 0x00FF));
+	return OK;
+}
+
+/**
+* Convert an array of 2 bytes to a u16, src has MSB first (big endian).
+* @param src pointer to the source byte array
+* @param dst pointer to the destination u16.
+* @return OK
+*/
+int u8ToU16_be(u8 *src, u16 *dst)
+{
+	*dst = (u16) (((src[0] & 0x00FF) << 8) + (src[1] & 0x00FF));
+	return OK;
+}
+
+/**
+* Convert an array of u16 to an array of u8, dst has MSB first (big endian).
+* @param src pointer to the source array of u16
+* @param src_length size of src
+* @param dst pointer to the destination array of u8. This array should be free when no need anymore
+* @return size of dst (src size multiply by 2)
+*/
+int u16ToU8n_be(u16 *src, int src_length, u8 *dst)
+{
+	int i, j;
+	dst = (u8 *) kmalloc((2 * src_length) * sizeof(u8), GFP_KERNEL);
+	j = 0;
+	for (i = 0; i < src_length; i++) {
+		dst[j] = (u8) (src[i] & 0xFF00) >> 8;
+		dst[j + 1] = (u8) (src[i] & 0x00FF);
+		j += 2;
+	}
+
+	return src_length * 2;
+}
+
+/**
+* Convert a u16 to an array of 2 u8, dst has MSB first (big endian).
+* @param src u16 to convert
+* @param dst pointer to the destination array of 2 u8.
+* @return OK
+*/
+int u16ToU8_be(u16 src, u8 *dst)
+{
+	dst[0] = (u8) ((src & 0xFF00) >> 8);
+	dst[1] = (u8) (src & 0x00FF);
+	return OK;
+}
+
+/**
+* Convert a u16 to an array of 2 u8, dst has LSB first (little endian).
+* @param src u16 to convert
+* @param dst pointer to the destination array of 2 u8.
+* @return OK
+*/
+int u16ToU8(u16 src, u8 *dst)
+{
+	dst[1] = (u8) ((src & 0xFF00) >> 8);
+	dst[0] = (u8) (src & 0x00FF);
+	return OK;
+}
+
+/**
+* Convert an array of bytes to a u32, src has LSB first (little endian).
+* @param src array of bytes to convert
+* @param dst pointer to the destination u32 variable.
+* @return OK
+*/
+int u8ToU32(u8 *src, u32 *dst)
+{
+	*dst =
+	    (u32) (((src[3] & 0xFF) << 24) + ((src[2] & 0xFF) << 16) +
+		   ((src[1] & 0xFF) << 8) + (src[0] & 0xFF));
+	return OK;
+}
+
+/**
+* Convert a u32 to an array of 4 bytes, dst has LSB first (little endian).
+* @param src u32 value to convert
+* @param dst pointer to the destination array of 4 bytes.
+* @return OK
+*/
+int u32ToU8(u32 src, u8 *dst)
+{
+	dst[3] = (u8) ((src & 0xFF000000) >> 24);
+	dst[2] = (u8) ((src & 0x00FF0000) >> 16);
+	dst[1] = (u8) ((src & 0x0000FF00) >> 8);
+	dst[0] = (u8) (src & 0x000000FF);
+	return OK;
+}
+
+/**
+* Convert a u32 to an array of 4 bytes, dst has MSB first (big endian).
+* @param src u32 value to convert
+* @param dst pointer to the destination array of 4 bytes.
+* @return OK
+*/
+int u32ToU8_be(u32 src, u8 *dst)
+{
+	dst[0] = (u8) ((src & 0xFF000000) >> 24);
+	dst[1] = (u8) ((src & 0x00FF0000) >> 16);
+	dst[2] = (u8) ((src & 0x0000FF00) >> 8);
+	dst[3] = (u8) (src & 0x000000FF);
+	return OK;
+}
+
+/**
+* Execute a function passed as argment and retry it defined number of times if not successfull
+* @param code pointer to a function which return an int and doesn't have any parameters
+* @param wait_before_retry interval of time in ms to wait between one trial and another one
+* @param retry_count max number of retry to attemp
+* @return last return value obtained from the last execution of the code function
+*/
+int attempt_function(int (*code) (void), unsigned long wait_before_retry,
+		     int retry_count)
+{
+	int result;
+	int count = 0;
+
+	do {
+		result = code();
+		count++;
+		mdelay(wait_before_retry);
+	} while (count < retry_count && result < 0);
+
+	if (count == retry_count)
+		return (result | ERROR_TIMEOUT);
+	else
+		return result;
+
+}
+
+/**
+ * Enable all the possible sensing mode supported by the FW
+ * @return OK if success or an error code which specify the type of error encountered
+ */
+int senseOn(void)
+{
+	int ret;
+
+	ret = setScanMode(SCAN_MODE_ACTIVE, 0x01);
+	if (ret < OK) {
+		logError(1, "%s senseOn: ERROR %08X\n", tag, ret);
+		return ret;
+	}
+
+	logError(0, "%s senseOn: SENSE ON\n", tag);
+	return OK;
+}
+
+/**
+ * Disable  all the sensing mode
+ * @return  OK if success or an error code which specify the type of error encountered
+ */
+int senseOff(void)
+{
+	int ret;
+
+	ret = setScanMode(SCAN_MODE_ACTIVE, 0x00);;
+	if (ret < OK) {
+		logError(1, "%s senseOff: ERROR %08X\n", tag, ret);
+		return ret;
+	}
+
+	logError(0, "%s senseOff: SENSE OFF\n", tag);
+	return OK;
+}
+
+/**
+ *	Clean up the IC status executing a system reset and giving the possibility to re-enabling the sensing
+ *  @param enableTouch if 1, re-enable the sensing and the interrupt of the IC
+ *  @return OK if success or an error code which specify the type of error encountered
+ */
+int cleanUp(int enableTouch)
+{
+	int res;
+
+	logError(0, "%s cleanUp: system reset...\n", tag);
+	res = fts_system_reset();
+	if (res < OK)
+		return res;
+	if (enableTouch) {
+		logError(0, "%s cleanUp: enabling touches...\n", tag);
+		res = senseOn();
+		if (res < OK)
+			return res;
+		logError(0, "%s cleanUp: enabling interrupts...\n", tag);
+		res = fts_enableInterrupt();
+		if (res < OK)
+			return res;
+	}
+	return OK;
+
+}
+
+/**
+* Transform an array of short in a matrix of short with a defined number of columns and the resulting number of rows
+* @param data array of bytes to convert
+* @param size size of data
+* @param columns number of columns that the resulting matrix should have.
+* @return a reference to a matrix of short where for each row there are columns elements
+*/
+short **array1dTo2d_short(short *data, int size, int columns)
+{
+
+	int i;
+	short **matrix =
+	    (short **)kmalloc(((int)(size / columns)) * sizeof(short *),
+			      GFP_KERNEL);
+	if (matrix != NULL) {
+		for (i = 0; i < (int)(size / columns); i++) {
+			matrix[i] =
+			    (short *)kmalloc(columns * sizeof(short),
+					     GFP_KERNEL);
+		}
+
+		for (i = 0; i < size; i++) {
+			matrix[i / columns][i % columns] = data[i];
+		}
+	}
+
+	return matrix;
+}
+
+/**
+* Transform an array of u16 in a matrix of u16 with a defined number of columns and the resulting number of rows
+* @param data array of bytes to convert
+* @param size size of data
+* @param columns number of columns that the resulting matrix should have.
+* @return a reference to a matrix of u16 where for each row there are columns elements
+*/
+u16 **array1dTo2d_u16(u16 *data, int size, int columns)
+{
+
+	int i;
+	u16 **matrix = (u16 **) kmalloc(((int)(size / columns)) * sizeof(u16 *),
+					GFP_KERNEL);
+	if (matrix != NULL) {
+		for (i = 0; i < (int)(size / columns); i++) {
+			matrix[i] =
+			    (u16 *) kmalloc(columns * sizeof(u16), GFP_KERNEL);
+		}
+
+		for (i = 0; i < size; i++) {
+			matrix[i / columns][i % columns] = data[i];
+		}
+	}
+
+	return matrix;
+}
+
+/**
+* Transform an array of u8 in a matrix of u8 with a defined number of columns and the resulting number of rows
+* @param data array of bytes to convert
+* @param size size of data
+* @param columns number of columns that the resulting matrix should have.
+* @return a reference to a matrix of short where for each row there are columns elements
+*/
+u8 **array1dTo2d_u8(u8 *data, int size, int columns)
+{
+
+	int i;
+	u8 **matrix =
+	    (u8 **) kmalloc(((int)(size / columns)) * sizeof(u8 *), GFP_KERNEL);
+	if (matrix != NULL) {
+		for (i = 0; i < (int)(size / columns); i++) {
+			matrix[i] =
+			    (u8 *) kmalloc(columns * sizeof(u8), GFP_KERNEL);
+		}
+
+		for (i = 0; i < size; i++) {
+			matrix[i / columns][i % columns] = data[i];
+		}
+	}
+
+	return matrix;
+}
+
+/**
+* Transform an array of i8 in a matrix of i8 with a defined number of columns and the resulting number of rows
+* @param data array of bytes to convert
+* @param size size of data
+* @param columns number of columns that the resulting matrix should have.
+* @return a reference to a matrix of short where for each row there are columns elements
+*/
+i8 **array1dTo2d_i8(i8 *data, int size, int columns)
+{
+
+	int i;
+	i8 **matrix =
+	    (i8 **) kmalloc(((int)(size / columns)) * sizeof(i8 *), GFP_KERNEL);
+	if (matrix != NULL) {
+		for (i = 0; i < (int)(size / columns); i++) {
+			matrix[i] =
+			    (i8 *) kmalloc(columns * sizeof(i8), GFP_KERNEL);
+		}
+
+		for (i = 0; i < size; i++) {
+			matrix[i / columns][i % columns] = data[i];
+		}
+	}
+
+	return matrix;
+}
+
+/**
+* Print in the kernel log a label followed by a matrix of short row x columns and free its memory
+* @param label pointer to the string to print before the actual matrix
+* @param matrix reference to the matrix of short which contain the actual data
+* @param row number of rows on which the matrix should be print
+* @param column number of columns for each row
+*/
+void print_frame_short(char *label, short **matrix, int row, int column)
+{
+	int i, j;
+	logError(1, "%s %s \n", tag, label);
+	for (i = 0; i < row; i++) {
+		logError(1, "%s ", tag);
+		for (j = 0; j < column; j++) {
+			printk("%d ", matrix[i][j]);
+		}
+		logError(1, "\n");
+		kfree(matrix[i]);
+	}
+	kfree(matrix);
+}
+
+/**
+* Print in the kernel log a label followed by a matrix of u16 row x columns and free its memory
+* @param label pointer to the string to print before the actual matrix
+* @param matrix reference to the matrix of u16 which contain the actual data
+* @param row number of rows on which the matrix should be print
+* @param column number of columns for each row
+*/
+void print_frame_u16(char *label, u16 **matrix, int row, int column)
+{
+	int i, j;
+	logError(1, "%s %s \n", tag, label);
+	for (i = 0; i < row; i++) {
+		logError(0, "%s ", tag);
+		for (j = 0; j < column; j++) {
+			printk("%d ", matrix[i][j]);
+		}
+		logError(0, "\n");
+		kfree(matrix[i]);
+	}
+	kfree(matrix);
+}
+
+/**
+* Print in the kernel log a label followed by a matrix of u8 row x columns and free its memory
+* @param label pointer to the string to print before the actual matrix
+* @param matrix reference to the matrix of u8 which contain the actual data
+* @param row number of rows on which the matrix should be print
+* @param column number of columns for each row
+*/
+void print_frame_u8(char *label, u8 **matrix, int row, int column)
+{
+	int i, j;
+	logError(1, "%s %s \n", tag, label);
+	for (i = 0; i < row; i++) {
+		logError(1, "%s ", tag);
+		for (j = 0; j < column; j++) {
+			printk("%d ", matrix[i][j]);
+		}
+		logError(1, "\n");
+		kfree(matrix[i]);
+	}
+	kfree(matrix);
+}
+
+/**
+* Print in the kernel log a label followed by a matrix of i8 row x columns and free its memory
+* @param label pointer to the string to print before the actual matrix
+* @param matrix reference to the matrix of u8 which contain the actual data
+* @param row number of rows on which the matrix should be print
+* @param column number of columns for each row
+*/
+void print_frame_i8(char *label, i8 **matrix, int row, int column)
+{
+	int i, j;
+	logError(1, "%s %s \n", tag, label);
+	for (i = 0; i < row; i++) {
+		logError(1, "%s ", tag);
+		for (j = 0; j < column; j++) {
+			printk("%d ", matrix[i][j]);
+		}
+		logError(1, "\n");
+		kfree(matrix[i]);
+	}
+	kfree(matrix);
+}
+
+/**
+* Print in the kernel log a label followed by a matrix of u32 row x columns and free its memory
+* @param label pointer to the string to print before the actual matrix
+* @param matrix reference to the matrix of u32 which contain the actual data
+* @param row number of rows on which the matrix should be print
+* @param column number of columns for each row
+*/
+void print_frame_u32(char *label, u32 **matrix, int row, int column)
+{
+	int i, j;
+	logError(1, "%s %s \n", tag, label);
+	for (i = 0; i < row; i++) {
+		logError(0, "%s ", tag);
+		for (j = 0; j < column; j++) {
+			printk("%d ", matrix[i][j]);
+		}
+		logError(0, "\n");
+		kfree(matrix[i]);
+	}
+	kfree(matrix);
+}
+
+/**
+* Print in the kernel log a label followed by a matrix of int row x columns and free its memory
+* @param label pointer to the string to print before the actual matrix
+* @param matrix reference to the matrix of int which contain the actual data
+* @param row number of rows on which the matrix should be print
+* @param column number of columns for each row
+*/
+void print_frame_int(char *label, int **matrix, int row, int column)
+{
+	int i, j;
+	logError(1, "%s %s \n", tag, label);
+	for (i = 0; i < row; i++) {
+		logError(0, "%s ", tag);
+		for (j = 0; j < column; j++) {
+			printk("%d ", matrix[i][j]);
+		}
+		logError(0, "\n");
+		kfree(matrix[i]);
+	}
+	kfree(matrix);
+}
+
+/**
+* Convert an array of bytes to an u64, src has MSB first (big endian).
+* @param src array of bytes
+* @param dest pointer to the destination u64.
+* @param size size of src (can be <= 8)
+* @return OK if success or ERROR_OP_NOT_ALLOW if size exceed 8
+*/
+int u8ToU64_be(u8 *src, u64 *dest, int size)
+{
+	int i = 0;
+
+	if (size > sizeof(u64)) {
+		return ERROR_OP_NOT_ALLOW;
+	} else {
+		*dest = 0;
+
+		for (i = 0; i < size; i++) {
+			*dest |= (u64) (src[i]) << ((size - 1 - i) * 8);
+		}
+
+		return OK;
+	}
+}
+
+/**
+* Convert an u64 to an array of bytes, dest has MSB first (big endian).
+* @param src value of u64
+* @param dest pointer to the destination array of bytes.
+* @param size size of src (can be <= 8)
+* @return OK if success or ERROR_OP_NOT_ALLOW if size exceed 8
+*/
+int u64ToU8_be(u64 src, u8 *dest, int size)
+{
+	int i = 0;
+	if (size > sizeof(u64)) {
+		return ERROR_OP_NOT_ALLOW;
+	} else {
+		for (i = 0; i < size; i++) {
+			dest[i] = (u8) ((src >> ((size - 1 - i) * 8)) & 0xFF);
+		}
+	}
+
+	return OK;
+}
+
+/*********** NEW API *************/
+
+/**
+ * Convert a value of an id in a bitmask with a 1 in the position of the value of the id
+ * @param id Value of the ID to convert
+ * @param mask pointer to the bitmask that will be updated with the value of id
+ * @param size dimension in bytes of mask
+ * @return OK if success or ERROR_OP_NOT_ALLOW if size of mask is not enough to contain ID
+ */
+int fromIDtoMask(u8 id, u8 *mask, int size)
+{
+	if (((int)((id) / 8)) < size) {
+		logError(0, "%s %s: ID = %d Index = %d Position = %d !\n", tag,
+			 __func__, id, ((int)((id) / 8)), (id % 8));
+		mask[((int)((id) / 8))] |= 0x01 << (id % 8);
+		return OK;
+	} else {
+		logError(1,
+			 "%s %s: Bitmask too small! Impossible contain ID = %d %d>=%d! ERROR %08X\n",
+			 tag, __func__, id, ((int)((id) / 8)), size,
+			 ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+}
diff --git a/drivers/input/touchscreen/stfts/fts_lib/ftsTool.h b/drivers/input/touchscreen/stfts/fts_lib/ftsTool.h
new file mode 100644
index 000000000000..86e20fa94f60
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_lib/ftsTool.h
@@ -0,0 +1,56 @@
+/*
+
+**************************************************************************
+**                        STMicroelectronics							**
+**************************************************************************
+**                        marco.cali@st.com								**
+**************************************************************************
+*                                                                        *
+*                     FTS Utility Functions								 *
+*                                                                        *
+**************************************************************************
+**************************************************************************
+
+*/
+
+/*!
+* \file ftsTool.h
+* \brief Contains all the definitions to support common operations inside the driver
+*/
+
+#ifndef FTS_TOOL_H
+#define FTS_TOOL_H
+
+char *printHex(char *label, u8 *buff, int count, u8 *result);
+char *printHex_data(char *label, u8 *buff, int count);
+int u8ToU16(u8 *src, u16 *dst);
+int u8ToU16_be(u8 *src, u16 *dst);
+int u8ToU16n(u8 *src, int src_length, u16 *dst);
+int u16ToU8(u16 src, u8 *dst);
+int u16ToU8_be(u16 src, u8 *dst);
+int u16ToU8n_be(u16 *src, int src_length, u8 *dst);
+int u8ToU32(u8 *src, u32 *dst);
+int u32ToU8(u32 src, u8 *dst);
+int u32ToU8_be(u32 src, u8 *dst);
+int u8ToU64_be(u8 *src, u64 *dest, int size);
+int u64ToU8_be(u64 src, u8 *dest, int size);
+int attempt_function(int(*code)(void), unsigned long wait_before_retry,
+		     int retry_count);
+int senseOn(void);
+int senseOff(void);
+void print_frame_short(char *label, short **matrix, int row, int column);
+short **array1dTo2d_short(short *data, int size, int columns);
+void print_frame_u16(char *label, u16 **matrix, int row, int column);
+u16 **array1dTo2d_u16(u16 *data, int size, int columns);
+u8 **array1dTo2d_u8(u8 *data, int size, int columns);
+i8 **array1dTo2d_i8(i8 *data, int size, int columns);
+void print_frame_u8(char *label, u8 **matrix, int row, int column);
+void print_frame_i8(char *label, i8 **matrix, int row, int column);
+void print_frame_u32(char *label, u32 **matrix, int row, int column);
+void print_frame_int(char *label, int **matrix, int row, int column);
+int cleanUp(int enableTouch);
+int flushFIFO(void);
+
+int fromIDtoMask(u8 id, u8 *mask, int size);
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/fts_limits.h b/drivers/input/touchscreen/stfts/fts_limits.h
new file mode 100644
index 000000000000..46e09629061b
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_limits.h
@@ -0,0 +1,2109 @@
+/*!
+* \file fts_limits.h
+* \brief Contains the size and the byte array of the production test limit file which contains thresholds used to test data
+*/
+
+#ifndef FTS_LIMITS_H
+#define FTS_LIMITS_H
+/*This is an auto generated header file*/
+/*--->Remember to change the name of the two variables!<---*/
+const uint32_t myArray2_size = 16725;
+
+/**
+ * Array containing the production limit file
+ */
+const uint8_t myArray2[] = {
+	0x2A, 0x53, 0x54, 0x4F, 0x50, 0x5F, 0x4F, 0x4E, 0x5F, 0x46, 0x41, 0x49,
+	    0x4C, 0x2C, 0x31, 0x2C,
+	0x31, 0x0A, 0x31, 0x0A, 0x2A, 0x53, 0x54, 0x4F, 0x50, 0x5F, 0x4F, 0x4E,
+	    0x5F, 0x45, 0x52, 0x52,
+	0x4F, 0x52, 0x2C, 0x31, 0x2C, 0x31, 0x0A, 0x31, 0x0A, 0x2A, 0x46, 0x4F,
+	    0x52, 0x43, 0x45, 0x5F,
+	0x46, 0x57, 0x5F, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x2C, 0x31, 0x2C,
+	    0x31, 0x0A, 0x30, 0x0A,
+	0x2A, 0x53, 0x53, 0x5F, 0x49, 0x58, 0x31, 0x5F, 0x46, 0x4F, 0x52, 0x43,
+	    0x45, 0x5F, 0x57, 0x2C,
+	0x31, 0x2C, 0x31, 0x0A, 0x32, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x49, 0x58,
+	    0x32, 0x5F, 0x46, 0x4F,
+	0x52, 0x43, 0x45, 0x5F, 0x57, 0x2C, 0x31, 0x2C, 0x31, 0x0A, 0x31, 0x0A,
+	    0x2A, 0x53, 0x53, 0x5F,
+	0x49, 0x58, 0x31, 0x5F, 0x53, 0x45, 0x4E, 0x53, 0x45, 0x5F, 0x57, 0x2C,
+	    0x31, 0x2C, 0x31, 0x0A,
+	0x32, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x49, 0x58, 0x32, 0x5F, 0x53, 0x45,
+	    0x4E, 0x53, 0x45, 0x5F,
+	0x57, 0x2C, 0x31, 0x2C, 0x31, 0x0A, 0x31, 0x0A, 0x2A, 0x4D, 0x53, 0x5F,
+	    0x52, 0x41, 0x57, 0x5F,
+	0x44, 0x41, 0x54, 0x41, 0x5F, 0x4D, 0x49, 0x4E, 0x5F, 0x4D, 0x41, 0x58,
+	    0x2C, 0x31, 0x2C, 0x32,
+	0x0A, 0x31, 0x30, 0x30, 0x30, 0x2C, 0x31, 0x35, 0x30, 0x30, 0x30, 0x0A,
+	    0x2A, 0x4D, 0x53, 0x5F,
+	0x52, 0x41, 0x57, 0x5F, 0x44, 0x41, 0x54, 0x41, 0x5F, 0x47, 0x41, 0x50,
+	    0x2C, 0x31, 0x2C, 0x31,
+	0x0A, 0x33, 0x30, 0x30, 0x30, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x54, 0x4F,
+	    0x55, 0x43, 0x48, 0x5F,
+	0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x43, 0x58, 0x31, 0x5F, 0x4D,
+	    0x49, 0x4E, 0x5F, 0x4D,
+	0x41, 0x58, 0x2C, 0x31, 0x2C, 0x32, 0x0A, 0x30, 0x2C, 0x36, 0x33, 0x0A,
+	    0x2A, 0x4D, 0x53, 0x5F,
+	0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45,
+	    0x5F, 0x43, 0x58, 0x32,
+	0x5F, 0x4D, 0x49, 0x4E, 0x2C, 0x32, 0x32, 0x2C, 0x32, 0x37, 0x0A, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x0A, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x0A, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x0A, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x0A, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x0A, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x0A, 0x2A,
+	0x4D, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54,
+	    0x49, 0x56, 0x45, 0x5F,
+	0x43, 0x58, 0x32, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x32, 0x32, 0x2C, 0x32,
+	    0x37, 0x0A, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x0A, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x0A,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x0A, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x0A, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x0A, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x0A,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43,
+	    0x48, 0x5F, 0x41, 0x43,
+	0x54, 0x49, 0x56, 0x45, 0x5F, 0x43, 0x58, 0x32, 0x5F, 0x41, 0x44, 0x4A,
+	    0x5F, 0x48, 0x4F, 0x52,
+	0x49, 0x5A, 0x4F, 0x4E, 0x54, 0x41, 0x4C, 0x2C, 0x32, 0x32, 0x2C, 0x32,
+	    0x36, 0x0A, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x0A,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x0A, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x0A,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x0A, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F,
+	    0x41, 0x43, 0x54, 0x49,
+	0x56, 0x45, 0x5F, 0x43, 0x58, 0x32, 0x5F, 0x41, 0x44, 0x4A, 0x5F, 0x56,
+	    0x45, 0x52, 0x54, 0x49,
+	0x43, 0x41, 0x4C, 0x2C, 0x32, 0x31, 0x2C, 0x32, 0x37, 0x0A, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x0A, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x0A, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x0A, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x0A,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x0A, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x0A, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x0A, 0x2A,
+	0x4D, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54,
+	    0x49, 0x56, 0x45, 0x5F,
+	0x54, 0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x43, 0x58, 0x5F, 0x4D, 0x49, 0x4E,
+	    0x2C, 0x32, 0x32, 0x2C,
+	0x32, 0x37, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x0A, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x0A, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x0A, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x0A, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x0A, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x54,
+	    0x4F, 0x55, 0x43, 0x48,
+	0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x54, 0x4F, 0x54, 0x41,
+	    0x4C, 0x5F, 0x43, 0x58,
+	0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x32, 0x32, 0x2C, 0x32, 0x37, 0x0A, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x0A, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x0A, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x0A, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x0A,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x0A, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x0A, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x0A, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x0A,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41,
+	    0x43, 0x54, 0x49, 0x56,
+	0x45, 0x5F, 0x54, 0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x43, 0x58, 0x5F, 0x41,
+	    0x44, 0x4A, 0x5F, 0x48,
+	0x4F, 0x52, 0x49, 0x5A, 0x4F, 0x4E, 0x54, 0x41, 0x4C, 0x2C, 0x32, 0x32,
+	    0x2C, 0x32, 0x36, 0x0A,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x0A, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x0A,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x0A, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x0A,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x0A, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43,
+	    0x48, 0x5F, 0x41, 0x43,
+	0x54, 0x49, 0x56, 0x45, 0x5F, 0x54, 0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x43,
+	    0x58, 0x5F, 0x41, 0x44,
+	0x4A, 0x5F, 0x56, 0x45, 0x52, 0x54, 0x49, 0x43, 0x41, 0x4C, 0x2C, 0x32,
+	    0x31, 0x2C, 0x32, 0x37,
+	0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x0A, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x0A, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x0A, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x0A,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x2C, 0x36,
+	0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x2C, 0x36, 0x34,
+	0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36, 0x34,
+	    0x2C, 0x36, 0x34, 0x2C,
+	0x36, 0x34, 0x2C, 0x36, 0x34, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x4B, 0x45,
+	    0x59, 0x5F, 0x52, 0x41,
+	0x57, 0x5F, 0x44, 0x41, 0x54, 0x41, 0x5F, 0x4D, 0x49, 0x4E, 0x5F, 0x4D,
+	    0x41, 0x58, 0x2C, 0x31,
+	0x2C, 0x32, 0x0A, 0x30, 0x2C, 0x38, 0x30, 0x30, 0x30, 0x0A, 0x2A, 0x4D,
+	    0x53, 0x5F, 0x4B, 0x45,
+	0x59, 0x5F, 0x43, 0x58, 0x31, 0x5F, 0x4D, 0x49, 0x4E, 0x5F, 0x4D, 0x41,
+	    0x58, 0x2C, 0x31, 0x2C,
+	0x32, 0x0A, 0x30, 0x2C, 0x36, 0x34, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x4B,
+	    0x45, 0x59, 0x5F, 0x43,
+	0x58, 0x32, 0x5F, 0x4D, 0x49, 0x4E, 0x2C, 0x31, 0x2C, 0x33, 0x0A, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x4B, 0x45, 0x59, 0x5F, 0x43, 0x58, 0x32,
+	    0x5F, 0x4D, 0x41, 0x58,
+	0x2C, 0x31, 0x2C, 0x33, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C, 0x36,
+	    0x34, 0x0A, 0x2A, 0x4D,
+	0x53, 0x5F, 0x4B, 0x45, 0x59, 0x5F, 0x54, 0x4F, 0x54, 0x41, 0x4C, 0x5F,
+	    0x43, 0x58, 0x5F, 0x4D,
+	0x49, 0x4E, 0x2C, 0x31, 0x2C, 0x33, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x0A, 0x2A, 0x4D, 0x53,
+	0x5F, 0x4B, 0x45, 0x59, 0x5F, 0x54, 0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x43,
+	    0x58, 0x5F, 0x4D, 0x41,
+	0x58, 0x2C, 0x31, 0x2C, 0x33, 0x0A, 0x36, 0x34, 0x2C, 0x36, 0x34, 0x2C,
+	    0x36, 0x34, 0x0A, 0x2A,
+	0x53, 0x53, 0x5F, 0x52, 0x41, 0x57, 0x5F, 0x44, 0x41, 0x54, 0x41, 0x5F,
+	    0x46, 0x4F, 0x52, 0x43,
+	0x45, 0x5F, 0x4D, 0x49, 0x4E, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C,
+	    0x32, 0x0A, 0x31, 0x30,
+	0x30, 0x30, 0x2C, 0x31, 0x35, 0x30, 0x30, 0x30, 0x0A, 0x2A, 0x53, 0x53,
+	    0x5F, 0x52, 0x41, 0x57,
+	0x5F, 0x44, 0x41, 0x54, 0x41, 0x5F, 0x46, 0x4F, 0x52, 0x43, 0x45, 0x5F,
+	    0x47, 0x41, 0x50, 0x2C,
+	0x31, 0x2C, 0x31, 0x0A, 0x33, 0x30, 0x30, 0x0A, 0x2A, 0x53, 0x53, 0x5F,
+	    0x54, 0x4F, 0x55, 0x43,
+	0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x49, 0x58, 0x31,
+	    0x5F, 0x46, 0x4F, 0x52,
+	0x43, 0x45, 0x5F, 0x4D, 0x49, 0x4E, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31,
+	    0x2C, 0x32, 0x0A, 0x30,
+	0x2C, 0x36, 0x33, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43,
+	    0x48, 0x5F, 0x41, 0x43,
+	0x54, 0x49, 0x56, 0x45, 0x5F, 0x49, 0x58, 0x32, 0x5F, 0x46, 0x4F, 0x52,
+	    0x43, 0x45, 0x5F, 0x4D,
+	0x49, 0x4E, 0x2C, 0x32, 0x32, 0x2C, 0x31, 0x0A, 0x30, 0x0A, 0x30, 0x0A,
+	    0x30, 0x0A, 0x30, 0x0A,
+	0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A,
+	    0x30, 0x0A, 0x30, 0x0A,
+	0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A,
+	    0x30, 0x0A, 0x30, 0x0A,
+	0x30, 0x0A, 0x30, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43,
+	    0x48, 0x5F, 0x41, 0x43,
+	0x54, 0x49, 0x56, 0x45, 0x5F, 0x49, 0x58, 0x32, 0x5F, 0x46, 0x4F, 0x52,
+	    0x43, 0x45, 0x5F, 0x4D,
+	0x41, 0x58, 0x2C, 0x32, 0x32, 0x2C, 0x31, 0x0A, 0x32, 0x35, 0x35, 0x0A,
+	    0x32, 0x35, 0x35, 0x0A,
+	0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A,
+	    0x32, 0x35, 0x35, 0x0A,
+	0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A,
+	    0x32, 0x35, 0x35, 0x0A,
+	0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A,
+	    0x32, 0x35, 0x35, 0x0A,
+	0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A,
+	    0x32, 0x35, 0x35, 0x0A,
+	0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A,
+	    0x32, 0x35, 0x35, 0x0A,
+	0x2A, 0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43,
+	    0x54, 0x49, 0x56, 0x45,
+	0x5F, 0x49, 0x58, 0x32, 0x5F, 0x41, 0x44, 0x4A, 0x5F, 0x56, 0x45, 0x52,
+	    0x54, 0x49, 0x43, 0x41,
+	0x4C, 0x2C, 0x32, 0x31, 0x2C, 0x31, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32,
+	    0x35, 0x35, 0x0A, 0x32,
+	0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32,
+	    0x35, 0x35, 0x0A, 0x32,
+	0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32,
+	    0x35, 0x35, 0x0A, 0x32,
+	0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32,
+	    0x35, 0x35, 0x0A, 0x32,
+	0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32,
+	    0x35, 0x35, 0x0A, 0x32,
+	0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x2A,
+	    0x53, 0x53, 0x5F, 0x54,
+	0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F,
+	    0x54, 0x4F, 0x54, 0x41,
+	0x4C, 0x5F, 0x49, 0x58, 0x5F, 0x46, 0x4F, 0x52, 0x43, 0x45, 0x5F, 0x4D,
+	    0x49, 0x4E, 0x2C, 0x32,
+	0x32, 0x2C, 0x31, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A,
+	    0x30, 0x0A, 0x30, 0x0A,
+	0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A,
+	    0x30, 0x0A, 0x30, 0x0A,
+	0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A,
+	    0x30, 0x0A, 0x30, 0x0A,
+	0x2A, 0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43,
+	    0x54, 0x49, 0x56, 0x45,
+	0x5F, 0x54, 0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x49, 0x58, 0x5F, 0x46, 0x4F,
+	    0x52, 0x43, 0x45, 0x5F,
+	0x4D, 0x41, 0x58, 0x2C, 0x32, 0x32, 0x2C, 0x31, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41,
+	    0x43, 0x54, 0x49, 0x56,
+	0x45, 0x5F, 0x54, 0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x49, 0x58, 0x5F, 0x41,
+	    0x44, 0x4A, 0x5F, 0x56,
+	0x45, 0x52, 0x54, 0x49, 0x43, 0x41, 0x4C, 0x2C, 0x32, 0x31, 0x2C, 0x31,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41,
+	    0x43, 0x54, 0x49, 0x56,
+	0x45, 0x5F, 0x43, 0x58, 0x31, 0x5F, 0x46, 0x4F, 0x52, 0x43, 0x45, 0x5F,
+	    0x4D, 0x49, 0x4E, 0x5F,
+	0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C, 0x32, 0x0A, 0x30, 0x2C, 0x36, 0x33,
+	    0x0A, 0x2A, 0x53, 0x53,
+	0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56,
+	    0x45, 0x5F, 0x43, 0x58,
+	0x32, 0x5F, 0x46, 0x4F, 0x52, 0x43, 0x45, 0x5F, 0x4D, 0x49, 0x4E, 0x2C,
+	    0x32, 0x32, 0x2C, 0x31,
+	0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30,
+	    0x0A, 0x30, 0x0A, 0x30,
+	0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30,
+	    0x0A, 0x30, 0x0A, 0x30,
+	0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30,
+	    0x0A, 0x2A, 0x53, 0x53,
+	0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56,
+	    0x45, 0x5F, 0x43, 0x58,
+	0x32, 0x5F, 0x46, 0x4F, 0x52, 0x43, 0x45, 0x5F, 0x4D, 0x41, 0x58, 0x2C,
+	    0x32, 0x32, 0x2C, 0x31,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x2A, 0x53, 0x53,
+	    0x5F, 0x54, 0x4F, 0x55,
+	0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x43, 0x58,
+	    0x32, 0x5F, 0x41, 0x44,
+	0x4A, 0x5F, 0x56, 0x45, 0x52, 0x54, 0x49, 0x43, 0x41, 0x4C, 0x2C, 0x32,
+	    0x31, 0x2C, 0x31, 0x0A,
+	0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A,
+	    0x32, 0x35, 0x35, 0x0A,
+	0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A,
+	    0x32, 0x35, 0x35, 0x0A,
+	0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A,
+	    0x32, 0x35, 0x35, 0x0A,
+	0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A,
+	    0x32, 0x35, 0x35, 0x0A,
+	0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A,
+	    0x32, 0x35, 0x35, 0x0A,
+	0x32, 0x35, 0x35, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43,
+	    0x48, 0x5F, 0x41, 0x43,
+	0x54, 0x49, 0x56, 0x45, 0x5F, 0x54, 0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x43,
+	    0x58, 0x5F, 0x46, 0x4F,
+	0x52, 0x43, 0x45, 0x5F, 0x4D, 0x49, 0x4E, 0x2C, 0x32, 0x32, 0x2C, 0x31,
+	    0x0A, 0x30, 0x0A, 0x30,
+	0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30,
+	    0x0A, 0x30, 0x0A, 0x30,
+	0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30,
+	    0x0A, 0x30, 0x0A, 0x30,
+	0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x30, 0x0A, 0x2A, 0x53, 0x53,
+	    0x5F, 0x54, 0x4F, 0x55,
+	0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x54, 0x4F,
+	    0x54, 0x41, 0x4C, 0x5F,
+	0x43, 0x58, 0x5F, 0x46, 0x4F, 0x52, 0x43, 0x45, 0x5F, 0x4D, 0x41, 0x58,
+	    0x2C, 0x32, 0x32, 0x2C,
+	0x31, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35,
+	    0x35, 0x0A, 0x32, 0x35,
+	0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35,
+	    0x35, 0x0A, 0x32, 0x35,
+	0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35,
+	    0x35, 0x0A, 0x32, 0x35,
+	0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35,
+	    0x35, 0x0A, 0x32, 0x35,
+	0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35,
+	    0x35, 0x0A, 0x32, 0x35,
+	0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x2A, 0x53,
+	    0x53, 0x5F, 0x54, 0x4F,
+	0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x54,
+	    0x4F, 0x54, 0x41, 0x4C,
+	0x5F, 0x43, 0x58, 0x5F, 0x41, 0x44, 0x4A, 0x5F, 0x56, 0x45, 0x52, 0x54,
+	    0x49, 0x43, 0x41, 0x4C,
+	0x2C, 0x32, 0x31, 0x2C, 0x31, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35,
+	    0x35, 0x0A, 0x32, 0x35,
+	0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35,
+	    0x35, 0x0A, 0x32, 0x35,
+	0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35,
+	    0x35, 0x0A, 0x32, 0x35,
+	0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35,
+	    0x35, 0x0A, 0x32, 0x35,
+	0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35,
+	    0x35, 0x0A, 0x32, 0x35,
+	0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x32, 0x35, 0x35, 0x0A, 0x2A, 0x53,
+	    0x53, 0x5F, 0x52, 0x41,
+	0x57, 0x5F, 0x44, 0x41, 0x54, 0x41, 0x5F, 0x53, 0x45, 0x4E, 0x53, 0x45,
+	    0x5F, 0x4D, 0x49, 0x4E,
+	0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C, 0x32, 0x0A, 0x31, 0x30, 0x30,
+	    0x30, 0x2C, 0x31, 0x35,
+	0x30, 0x30, 0x30, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x52, 0x41, 0x57, 0x5F,
+	    0x44, 0x41, 0x54, 0x41,
+	0x5F, 0x53, 0x45, 0x4E, 0x53, 0x45, 0x5F, 0x47, 0x41, 0x50, 0x2C, 0x31,
+	    0x2C, 0x31, 0x0A, 0x33,
+	0x30, 0x30, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48,
+	    0x5F, 0x41, 0x43, 0x54,
+	0x49, 0x56, 0x45, 0x5F, 0x49, 0x58, 0x31, 0x5F, 0x53, 0x45, 0x4E, 0x53,
+	    0x45, 0x5F, 0x4D, 0x49,
+	0x4E, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C, 0x32, 0x0A, 0x30, 0x2C,
+	    0x36, 0x33, 0x0A, 0x2A,
+	0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54,
+	    0x49, 0x56, 0x45, 0x5F,
+	0x49, 0x58, 0x32, 0x5F, 0x53, 0x45, 0x4E, 0x53, 0x45, 0x5F, 0x4D, 0x49,
+	    0x4E, 0x2C, 0x31, 0x2C,
+	0x32, 0x37, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x2A, 0x53, 0x53,
+	    0x5F, 0x54, 0x4F, 0x55,
+	0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x49, 0x58,
+	    0x32, 0x5F, 0x53, 0x45,
+	0x4E, 0x53, 0x45, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C, 0x32, 0x37,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	    0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	    0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	    0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	    0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	    0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	    0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x0A, 0x2A, 0x53, 0x53,
+	    0x5F, 0x54, 0x4F, 0x55,
+	0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x49, 0x58,
+	    0x32, 0x5F, 0x41, 0x44,
+	0x4A, 0x5F, 0x48, 0x4F, 0x52, 0x49, 0x5A, 0x4F, 0x4E, 0x54, 0x41, 0x4C,
+	    0x2C, 0x31, 0x2C, 0x32,
+	0x36, 0x0A, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x0A, 0x2A, 0x53,
+	    0x53, 0x5F, 0x54, 0x4F,
+	0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x54,
+	    0x4F, 0x54, 0x41, 0x4C,
+	0x5F, 0x49, 0x58, 0x5F, 0x53, 0x45, 0x4E, 0x53, 0x45, 0x5F, 0x4D, 0x49,
+	    0x4E, 0x2C, 0x31, 0x2C,
+	0x32, 0x37, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	    0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x2A, 0x53, 0x53,
+	    0x5F, 0x54, 0x4F, 0x55,
+	0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x54, 0x4F,
+	    0x54, 0x41, 0x4C, 0x5F,
+	0x49, 0x58, 0x5F, 0x53, 0x45, 0x4E, 0x53, 0x45, 0x5F, 0x4D, 0x41, 0x58,
+	    0x2C, 0x31, 0x2C, 0x32,
+	0x37, 0x0A, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x0A, 0x2A, 0x53,
+	0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49,
+	    0x56, 0x45, 0x5F, 0x54,
+	0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x49, 0x58, 0x5F, 0x41, 0x44, 0x4A, 0x5F,
+	    0x48, 0x4F, 0x52, 0x49,
+	0x5A, 0x4F, 0x4E, 0x54, 0x41, 0x4C, 0x2C, 0x31, 0x2C, 0x32, 0x36, 0x0A,
+	    0x32, 0x35, 0x35, 0x2C,
+	0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C,
+	    0x32, 0x35, 0x35, 0x2C,
+	0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C,
+	    0x32, 0x35, 0x35, 0x2C,
+	0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C,
+	    0x32, 0x35, 0x35, 0x2C,
+	0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C,
+	    0x32, 0x35, 0x35, 0x2C,
+	0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C,
+	    0x32, 0x35, 0x35, 0x2C,
+	0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C,
+	    0x32, 0x35, 0x35, 0x2C,
+	0x32, 0x35, 0x35, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43,
+	    0x48, 0x5F, 0x41, 0x43,
+	0x54, 0x49, 0x56, 0x45, 0x5F, 0x43, 0x58, 0x31, 0x5F, 0x53, 0x45, 0x4E,
+	    0x53, 0x45, 0x5F, 0x4D,
+	0x49, 0x4E, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C, 0x32, 0x0A, 0x30,
+	    0x2C, 0x36, 0x33, 0x0A,
+	0x2A, 0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43,
+	    0x54, 0x49, 0x56, 0x45,
+	0x5F, 0x43, 0x58, 0x32, 0x5F, 0x53, 0x45, 0x4E, 0x53, 0x45, 0x5F, 0x4D,
+	    0x49, 0x4E, 0x2C, 0x31,
+	0x2C, 0x32, 0x37, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C,
+	    0x30, 0x2C, 0x30, 0x2C,
+	0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C,
+	    0x30, 0x2C, 0x30, 0x2C,
+	0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C,
+	    0x30, 0x2C, 0x30, 0x2C,
+	0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x2A, 0x53,
+	    0x53, 0x5F, 0x54, 0x4F,
+	0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x43,
+	    0x58, 0x32, 0x5F, 0x53,
+	0x45, 0x4E, 0x53, 0x45, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C, 0x32,
+	    0x37, 0x0A, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35,
+	    0x35, 0x2C, 0x32, 0x35,
+	0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x0A, 0x2A, 0x53,
+	    0x53, 0x5F, 0x54, 0x4F,
+	0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x43,
+	    0x58, 0x32, 0x5F, 0x41,
+	0x44, 0x4A, 0x5F, 0x48, 0x4F, 0x52, 0x49, 0x5A, 0x4F, 0x4E, 0x54, 0x41,
+	    0x4C, 0x2C, 0x31, 0x2C,
+	0x32, 0x36, 0x0A, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32,
+	    0x35, 0x35, 0x2C, 0x32,
+	0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32,
+	    0x35, 0x35, 0x2C, 0x32,
+	0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32,
+	    0x35, 0x35, 0x2C, 0x32,
+	0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32,
+	    0x35, 0x35, 0x2C, 0x32,
+	0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32,
+	    0x35, 0x35, 0x2C, 0x32,
+	0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32,
+	    0x35, 0x35, 0x2C, 0x32,
+	0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x0A, 0x2A,
+	    0x53, 0x53, 0x5F, 0x54,
+	0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F,
+	    0x54, 0x4F, 0x54, 0x41,
+	0x4C, 0x5F, 0x43, 0x58, 0x5F, 0x53, 0x45, 0x4E, 0x53, 0x45, 0x5F, 0x4D,
+	    0x49, 0x4E, 0x2C, 0x31,
+	0x2C, 0x32, 0x37, 0x0A, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C,
+	    0x30, 0x2C, 0x30, 0x2C,
+	0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C,
+	    0x30, 0x2C, 0x30, 0x2C,
+	0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C,
+	    0x30, 0x2C, 0x30, 0x2C,
+	0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0A, 0x2A, 0x53,
+	    0x53, 0x5F, 0x54, 0x4F,
+	0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x54,
+	    0x4F, 0x54, 0x41, 0x4C,
+	0x5F, 0x43, 0x58, 0x5F, 0x53, 0x45, 0x4E, 0x53, 0x45, 0x5F, 0x4D, 0x41,
+	    0x58, 0x2C, 0x31, 0x2C,
+	0x32, 0x37, 0x0A, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32,
+	    0x35, 0x35, 0x2C, 0x32,
+	0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32,
+	    0x35, 0x35, 0x2C, 0x32,
+	0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32,
+	    0x35, 0x35, 0x2C, 0x32,
+	0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32,
+	    0x35, 0x35, 0x2C, 0x32,
+	0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32,
+	    0x35, 0x35, 0x2C, 0x32,
+	0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32,
+	    0x35, 0x35, 0x2C, 0x32,
+	0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32,
+	    0x35, 0x35, 0x0A, 0x2A,
+	0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54,
+	    0x49, 0x56, 0x45, 0x5F,
+	0x54, 0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x43, 0x58, 0x5F, 0x41, 0x44, 0x4A,
+	    0x5F, 0x48, 0x4F, 0x52,
+	0x49, 0x5A, 0x4F, 0x4E, 0x54, 0x41, 0x4C, 0x2C, 0x31, 0x2C, 0x32, 0x36,
+	    0x0A, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	    0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	    0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	    0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	    0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	    0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	    0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x0A,
+};
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/fts_proc.c b/drivers/input/touchscreen/stfts/fts_proc.c
new file mode 100644
index 000000000000..850247991e0e
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/fts_proc.c
@@ -0,0 +1,2451 @@
+/*
+
+ **************************************************************************
+ **                        STMicroelectronics							 **
+ **************************************************************************
+ **                        marco.cali@st.com							 **
+ **************************************************************************
+ *                                                                        *
+ *                     Utilities published in /proc/fts					  *
+ *                                                                        *
+ **************************************************************************
+ **************************************************************************
+
+ */
+
+/*!
+* \file fts_proc.c
+* \brief contains the function and variables needed to publish a file node in the file system which allow to communicate with the IC from userspace
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include "fts.h"
+#include "fts_lib/ftsCompensation.h"
+#include "fts_lib/ftsCore.h"
+#include "fts_lib/ftsIO.h"
+#include "fts_lib/ftsError.h"
+#include "fts_lib/ftsFrame.h"
+#include "fts_lib/ftsFlash.h"
+#include "fts_lib/ftsTest.h"
+#include "fts_lib/ftsTime.h"
+#include "fts_lib/ftsTool.h"
+
+#define DRIVER_TEST_FILE_NODE								"driver_test"
+#define CHUNK_PROC											1024
+#define DIAGNOSTIC_NUM_FRAME								10
+
+/** @defgroup proc_file_code	 Proc File Node
+* @ingroup file_nodes
+* The /proc/fts/driver_test file node provide expose the most important API implemented into the driver to execute any possible operation into the IC \n
+* Thanks to a series of Operation Codes, each of them, with a different set of parameter, it is possible to select a function to execute\n
+* The result of the function is usually returned into the shell as an ASCII hex string where each byte is encoded in two chars.\n
+* @{
+*/
+
+/*Bus operations*/
+#define CMD_READ											0x00
+#define CMD_WRITE											0x01
+#define CMD_WRITEREAD										0x02
+#define CMD_WRITETHENWRITEREAD								0x03
+#define CMD_WRITEU8UX										0x04
+#define CMD_WRITEREADU8UX									0x05
+#define CMD_WRITEU8UXTHENWRITEU8UX							0x06
+#define CMD_WRITEU8UXTHENWRITEREADU8UX						0x07
+#define CMD_GETLIMITSFILE									0x08
+#define CMD_GETFWFILE										0x09
+#define CMD_VERSION											0x0A
+#define CMD_READCONFIG										0x0B
+
+/*GUI utils byte ver*/
+#define CMD_READ_BYTE										0xF0
+#define CMD_WRITE_BYTE										0xF1
+#define CMD_WRITEREAD_BYTE									0xF2
+#define CMD_WRITETHENWRITEREAD_BYTE							0xF3
+#define CMD_WRITEU8UX_BYTE									0xF4
+#define CMD_WRITEREADU8UX_BYTE								0xF5
+#define CMD_WRITEU8UXTHENWRITEU8UX_BYTE						0xF6
+#define CMD_WRITEU8UXTHENWRITEREADU8UX_BYTE					0xF7
+#define CMD_GETLIMITSFILE_BYTE								0xF8
+#define CMD_GETFWFILE_BYTE									0xF9
+#define CMD_VERSION_BYTE									0xFA
+#define CMD_CHANGE_OUTPUT_MODE								0xFF
+
+/*Core/Tools*/
+#define CMD_POLLFOREVENT									0x11
+#define CMD_SYSTEMRESET										0x12
+#define CMD_CLEANUP											0x13
+#define CMD_POWERCYCLE										0x14
+#define CMD_READSYSINFO										0x15
+#define CMD_FWWRITE											0x16
+#define CMD_INTERRUPT										0x17
+
+/*Frame*/
+#define CMD_GETFORCELEN										0x20
+#define CMD_GETSENSELEN										0x21
+#define CMD_GETMSFRAME										0x23
+#define CMD_GETSSFRAME										0x24
+
+/*Compensation*/
+#define CMD_REQCOMPDATA										0x30
+#define CMD_READCOMPDATAHEAD								0x31
+#define CMD_READMSCOMPDATA									0x32
+#define CMD_READSSCOMPDATA									0x33
+#define CMD_READTOTMSCOMPDATA								0x35
+#define CMD_READTOTSSCOMPDATA								0x36
+
+/*FW Update*/
+#define CMD_GETFWVER										0x40
+#define CMD_FLASHUNLOCK										0x42
+#define CMD_READFWFILE										0x43
+#define CMD_FLASHPROCEDURE									0x44
+#define CMD_FLASHERASEUNLOCK								0x45
+#define CMD_FLASHERASEPAGE									0x46
+
+/*MP test*/
+#define CMD_ITOTEST											0x50
+#define CMD_INITTEST										0x51
+#define CMD_MSRAWTEST										0x52
+#define CMD_MSINITDATATEST									0x53
+#define CMD_SSRAWTEST										0x54
+#define CMD_SSINITDATATEST									0x55
+#define CMD_MAINTEST										0x56
+#define CMD_FREELIMIT										0x57
+
+/*Diagnostic*/
+#define CMD_DIAGNOSTIC										0x60
+
+
+#define CMD_CHANGE_SAD										0x70
+
+static u8 bin_output;
+/** @}*/
+
+/** @defgroup scriptless Scriptless Protocol
+ * @ingroup proc_file_code
+ * Scriptless Protocol allows ST Software (such as FingerTip Studio etc) to communicate with the IC from an user space.
+ * This mode gives access to common bus operations (write, read etc) and support additional functionalities. \n
+ * The protocol is based on exchange of binary messages included between a start and an end byte
+ * @{
+ */
+
+#define MESSAGE_START_BYTE									0x7B
+#define MESSAGE_END_BYTE									0x7D
+#define MESSAGE_MIN_HEADER_SIZE								8
+
+/**
+ * Possible actions that can be requested by an host
+ */
+typedef enum {
+	ACTION_WRITE = (u16) 0x0001,
+	ACTION_READ = (u16) 0x0002,
+	ACTION_WRITE_READ = (u16) 0x0003,
+	ACTION_GET_VERSION = (u16) 0x0004,
+	ACTION_WRITEU8UX = (u16) 0x0011,
+	ACTION_WRITEREADU8UX = (u16) 0x0012,
+	ACTION_WRITETHENWRITEREAD = (u16) 0x0013,
+	ACTION_WRITEU8XTHENWRITEREADU8UX = (u16) 0x0014,
+	ACTION_WRITEU8UXTHENWRITEU8UX = (u16) 0x0015,
+	ACTION_GET_FW = (u16) 0x1000,
+	ACTION_GET_LIMIT = (u16) 0x1001
+} Actions;
+
+/**
+ * Struct used to contain info of the message received by the host in Scriptless mode
+ */
+typedef struct {
+	u16 msg_size;
+	u16 counter;
+	Actions action;
+	u8 dummy;
+} Message;
+
+/** @}*/
+
+extern TestToDo tests;
+extern SysInfo systemInfo;
+
+static int limit;
+static int chunk;
+static int printed;
+static struct proc_dir_entry *fts_dir;
+static u8 *driver_test_buff;
+char buf_chunk[CHUNK_PROC];
+static Message mess;
+
+/************************ SEQUENTIAL FILE UTILITIES **************************/
+/**
+* This function is called at the beginning of the stream to a sequential file or every time into the sequential were already written PAGE_SIZE bytes and the stream need to restart
+* @param s pointer to the sequential file on which print the data
+* @param pos pointer to the offset where write the data
+* @return NULL if there is no data to print or the pointer to the beginning of the data that need to be printed
+*/
+static void *fts_seq_start(struct seq_file *s, loff_t *pos)
+{
+	logError(0,
+		 "%s %s: Entering start(), pos = %Ld limit = %d printed = %d \n",
+		 tag, __func__, *pos, limit, printed);
+
+	if (driver_test_buff == NULL && *pos == 0) {
+		logError(1, "%s %s: No data to print!\n", tag, __func__);
+		driver_test_buff = (u8 *) kmalloc(13 * sizeof(u8), GFP_KERNEL);
+
+		snprintf(driver_test_buff, PAGE_SIZE, "{ %08X }\n", ERROR_OP_NOT_ALLOW);
+
+		limit = strlen(driver_test_buff);
+	} else {
+		if (*pos != 0)
+			*pos += chunk - 1;
+
+		if (*pos >= limit) {
+			return NULL;
+		}
+	}
+
+	chunk = CHUNK_PROC;
+	if (limit - *pos < CHUNK_PROC)
+		chunk = limit - *pos;
+	memset(buf_chunk, 0, CHUNK_PROC);
+	memcpy(buf_chunk, &driver_test_buff[(int)*pos], chunk);
+
+	return buf_chunk;
+}
+
+/**
+* This function actually print a chunk amount of data in the sequential file
+* @param s pointer to the sequential file where to print the data
+* @param v pointer to the data to print
+* @return 0
+*/
+static int fts_seq_show(struct seq_file *s, void *v)
+{
+	seq_write(s, (u8 *) v, chunk);
+	printed += chunk;
+	return 0;
+}
+
+/**
+* This function update the pointer and the counters to the next data to be printed
+* @param s pointer to the sequential file where to print the data
+* @param v pointer to the data to print
+* @param pos pointer to the offset where write the next data
+* @return NULL if there is no data to print or the pointer to the beginning of the next data that need to be printed
+*/
+static void *fts_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	(*pos) += chunk;
+	chunk = CHUNK_PROC;
+
+	if (*pos >= limit)
+		return NULL;
+	else {
+		if (limit - *pos < CHUNK_PROC)
+			chunk = limit - *pos;
+	}
+
+	memset(buf_chunk, 0, CHUNK_PROC);
+	memcpy(buf_chunk, &driver_test_buff[(int)*pos], chunk);
+	return buf_chunk;
+}
+
+/**
+* This function is called when there are no more data to print  the stream need to be terminated or when PAGE_SIZE data were already written into the sequential file
+* @param s pointer to the sequential file where to print the data
+* @param v pointer returned by fts_seq_next
+*/
+static void fts_seq_stop(struct seq_file *s, void *v)
+{
+
+	if (v) {
+		/*logError(0, "%s %s: v is %X.\n", tag, __func__, v);*/
+	} else {
+		limit = 0;
+		chunk = 0;
+		printed = 0;
+		if (driver_test_buff != NULL) {
+			kfree(driver_test_buff);
+			driver_test_buff = NULL;
+
+		} else {
+			/*logError(0, "%s %s: driver_test_buff is already null.\n", tag, __func__);*/
+		}
+	}
+
+}
+
+/**
+* Struct where define and specify the functions which implements the flow for writing on a sequential file
+*/
+static struct seq_operations fts_seq_ops = {
+	.start = fts_seq_start,
+	.next = fts_seq_next,
+	.stop = fts_seq_stop,
+	.show = fts_seq_show
+};
+
+/**
+* This function open a sequential file
+* @param inode Inode in the file system that was called and triggered this function
+* @param file file associated to the file node
+* @return error code, 0 if success
+*/
+static int fts_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &fts_seq_ops);
+};
+
+/*****************************************************************************/
+
+/**************************** DRIVER TEST ************************************/
+
+/** @addtogroup proc_file_code
+ * @{
+ */
+
+/**
+ * Receive the OP code and the inputs from shell when the file node is called, parse it and then execute the corresponding function
+ * echo cmd+parameters > /proc/fts/driver_test to execute the select command
+ * cat /proc/fts/driver_test			to obtain the result into the shell \n
+ * the string returned in the shell is made up as follow: \n
+ * { = start byte \n
+ * the answer content and format strictly depend on the cmd executed. In general can be: an HEX string or a byte array (e.g in case of 0xF- commands) \n
+ * } = end byte \n
+ */
+static ssize_t fts_driver_test_write(struct file *file, const char __user *buf,
+				     size_t count, loff_t *pos)
+{
+	int numberParam = 0;
+	struct fts_ts_info *info = dev_get_drvdata(getDev());
+	char *p = NULL;
+	char pbuf[count];
+	char path[100] = { 0 };
+	int res = -1, j, index = 0;
+	int size = 6;
+	int temp, byte_call = 0;
+	u16 byteToRead = 0;
+	u32 fileSize = 0;
+	u8 *readData = NULL;
+	u8 *cmd = NULL;
+	u32 funcToTest[((count + 1) / 3)];
+	u64 addr = 0;
+	MutualSenseFrame frameMS;
+	SelfSenseFrame frameSS;
+
+	DataHeader dataHead;
+	MutualSenseData compData;
+	SelfSenseData comData;
+	TotMutualSenseData totCompData;
+	TotSelfSenseData totComData;
+
+	u64 address;
+	u16 fw_version;
+	u16 config_id;
+
+	Firmware fw;
+	LimitFile lim;
+
+	mess.dummy = 0;
+	mess.action = 0;
+	mess.msg_size = 0;
+
+	cmd = (u8 *)kzalloc(sizeof(u8) * count, GFP_KERNEL);
+	if (!cmd) {
+		res = ERROR_ALLOC;
+		goto END;
+	}
+	if (access_ok(buf, count) < OK
+	    || copy_from_user(pbuf, buf, count) != 0) {
+		res = ERROR_ALLOC;
+		goto END;
+	}
+
+	p = pbuf;
+	if (count > MESSAGE_MIN_HEADER_SIZE - 1 && p[0] == MESSAGE_START_BYTE) {
+		logError(0, "%s Enter in Byte Mode! \n", tag);
+		byte_call = 1;
+		mess.msg_size = (p[1] << 8) | p[2];
+		mess.counter = (p[3] << 8) | p[4];
+		mess.action = (p[5] << 8) | p[6];
+		logError(0,
+			 "%s Message received: size = %d, counter_id = %d, action = %04X \n",
+			 tag, mess.msg_size, mess.counter, mess.action);
+		size = MESSAGE_MIN_HEADER_SIZE + 2;
+		if (count < mess.msg_size || p[count - 2] != MESSAGE_END_BYTE) {
+			logError(1,
+				 "%s number of byte received or end byte wrong! msg_size = %d != %d, last_byte = %02X != %02X ... ERROR %08X\n",
+				 tag, mess.msg_size, count, p[count - 1],
+				 MESSAGE_END_BYTE, ERROR_OP_NOT_ALLOW);
+			res = ERROR_OP_NOT_ALLOW;
+			goto END;
+
+		} else {
+			numberParam = mess.msg_size - MESSAGE_MIN_HEADER_SIZE + 1;
+			size = MESSAGE_MIN_HEADER_SIZE + 2;
+			switch (mess.action) {
+			case ACTION_READ:
+				cmd[0] = funcToTest[0] = CMD_READ_BYTE;
+				break;
+
+			case ACTION_WRITE:
+				cmd[0] = funcToTest[0] = CMD_WRITE_BYTE;
+				break;
+
+			case ACTION_WRITE_READ:
+				cmd[0] = funcToTest[0] = CMD_WRITEREAD_BYTE;
+				break;
+
+			case ACTION_GET_VERSION:
+				cmd[0] = funcToTest[0] = CMD_VERSION_BYTE;
+				break;
+
+			case ACTION_WRITETHENWRITEREAD:
+				cmd[0] = funcToTest[0] =
+				    CMD_WRITETHENWRITEREAD_BYTE;
+				break;
+
+			case ACTION_WRITEU8UX:
+				cmd[0] = funcToTest[0] = CMD_WRITEU8UX_BYTE;
+				break;
+
+			case ACTION_WRITEREADU8UX:
+				cmd[0] = funcToTest[0] = CMD_WRITEREADU8UX_BYTE;
+				break;
+
+			case ACTION_WRITEU8UXTHENWRITEU8UX:
+				cmd[0] = funcToTest[0] =
+				    CMD_WRITEU8UXTHENWRITEU8UX_BYTE;
+				break;
+
+			case ACTION_WRITEU8XTHENWRITEREADU8UX:
+				cmd[0] = funcToTest[0] =
+				    CMD_WRITEU8UXTHENWRITEREADU8UX_BYTE;
+				break;
+
+			case ACTION_GET_FW:
+				cmd[0] = funcToTest[0] = CMD_GETFWFILE_BYTE;
+				break;
+
+			case ACTION_GET_LIMIT:
+				cmd[0] = funcToTest[0] = CMD_GETLIMITSFILE_BYTE;
+				break;
+
+			default:
+				logError(1,
+					 "%s Invalid Action = %d ... ERROR %08X\n",
+					 tag, mess.action, ERROR_OP_NOT_ALLOW);
+				res = ERROR_OP_NOT_ALLOW;
+				goto END;
+			}
+
+			if (numberParam - 1 != 0)
+				memcpy(&cmd[1], &p[7], numberParam - 1);
+		}
+	} else {
+		if (((count + 1) / 3) >= 1) {
+			sscanf(p, "%02X ", &funcToTest[0]);
+			p += 3;
+			cmd[0] = (u8) funcToTest[0];
+			numberParam = 1;
+		} else {
+			res = ERROR_OP_NOT_ALLOW;
+			goto END;
+		}
+
+		logError(1, "%s functionToTest[0] = %02X cmd[0]= %02X\n", tag,
+			 funcToTest[0], cmd[0]);
+		switch (funcToTest[0]) {
+		case CMD_GETFWFILE:
+		case CMD_GETLIMITSFILE:
+			if (count - 2 - 1 > 1) {
+				numberParam = 2;
+				sscanf(p, "%100s", path);
+			}
+			break;
+
+		default:
+			for (; numberParam < (count + 1) / 3; numberParam++) {
+				sscanf(p, "%02X ", &funcToTest[numberParam]);
+				p += 3;
+				cmd[numberParam] = (u8) funcToTest[numberParam];
+				logError(1,
+					 "%s functionToTest[%d] = %02X cmd[%d]= %02X\n",
+					 tag, numberParam,
+					 funcToTest[numberParam], numberParam,
+					 cmd[numberParam]);
+			}
+		}
+
+	}
+
+	fw.data = NULL;
+	lim.data = NULL;
+
+	logError(1, "%s Number of Parameters = %d \n", tag, numberParam);
+
+	if (numberParam >= 1) {
+		switch (funcToTest[0]) {
+		case CMD_VERSION_BYTE:
+			logError(0, "%s %s: Get Version Byte \n", tag, __func__,
+				 res);
+			byteToRead = 2;
+			mess.dummy = 0;
+			readData =
+			    (u8 *) kmalloc(byteToRead * sizeof(u8), GFP_KERNEL);
+			size += byteToRead;
+			if (readData != NULL) {
+				readData[0] = (u8) (FTS_TS_DRV_VER >> 24);
+				readData[1] = (u8) (FTS_TS_DRV_VER >> 16);
+				res = OK;
+				logError(0, "%s %s: Version = %02X%02X \n", tag,
+					 __func__, readData[0], readData[1]);
+			} else {
+				res = ERROR_ALLOC;
+				logError(1,
+					 "%s %s: Impossible allocate memory... ERROR %08X \n",
+					 tag, __func__, res);
+			}
+			break;
+
+		case CMD_VERSION:
+			byteToRead = 2 * sizeof(u32);
+			mess.dummy = 0;
+			readData =
+			    (u8 *) kmalloc(byteToRead * sizeof(u8), GFP_KERNEL);
+			u32ToU8_be(FTS_TS_DRV_VER, readData);
+			fileSize = 0;
+#ifdef FW_H_FILE
+			fileSize |= 0x00010000;
+#endif
+
+#ifdef LIMITS_H_FILE
+			fileSize |= 0x00020000;
+#endif
+
+#ifdef USE_ONE_FILE_NODE
+			fileSize |= 0x00040000;
+#endif
+
+#ifdef FW_UPDATE_ON_PROBE
+			fileSize |= 0x00080000;
+#endif
+
+#ifdef PRE_SAVED_METHOD
+			fileSize |= 0x00100000;
+#endif
+
+#ifdef USE_GESTURE_MASK
+			fileSize |= 0x00100000;
+#endif
+
+#ifdef I2C_INTERFACE
+			fileSize |= 0x00200000;
+#endif
+
+#ifdef PHONE_KEY
+			fileSize |= 0x00000100;
+#endif
+
+#ifdef GESTURE_MODE
+			fromIDtoMask(FEAT_SEL_GESTURE, (u8 *)&fileSize, 4);
+#endif
+
+#ifdef GRIP_MODE
+			fromIDtoMask(FEAT_SEL_GRIP, (u8 *)&fileSize, 4);
+#endif
+
+#ifdef CHARGER_MODE
+			fromIDtoMask(FEAT_SEL_CHARGER, (u8 *)&fileSize, 4);
+#endif
+
+#ifdef GLOVE_MODE
+			fromIDtoMask(FEAT_SEL_GLOVE, (u8 *)&fileSize, 4);
+#endif
+
+#ifdef COVER_MODE
+			fromIDtoMask(FEAT_SEL_COVER, (u8 *)&fileSize, 4);
+#endif
+
+#ifdef STYLUS_MODE
+			fromIDtoMask(FEAT_SEL_STYLUS, (u8 *)&fileSize, 4);
+#endif
+
+			u32ToU8_be(fileSize, &readData[4]);
+			res = OK;
+			size += (byteToRead * sizeof(u8));
+			break;
+
+		case CMD_WRITEREAD:
+		case CMD_WRITEREAD_BYTE:
+			if (numberParam >= 5) {
+				temp = numberParam - 4;
+				if (cmd[numberParam - 1] == 0) {
+					mess.dummy = 0;
+				} else
+					mess.dummy = 1;
+
+				u8ToU16_be(&cmd[numberParam - 3], &byteToRead);
+				logError(0, "%s bytesToRead = %d \n", tag,
+					 byteToRead + mess.dummy);
+
+				readData =
+				    (u8 *) kmalloc((byteToRead + mess.dummy) *
+						   sizeof(u8), GFP_KERNEL);
+				res =
+				    fts_writeRead_dma_safe(&cmd[1], temp, readData,
+						  byteToRead + mess.dummy);
+				size += (byteToRead * sizeof(u8));
+
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_WRITE:
+		case CMD_WRITE_BYTE:
+			if (numberParam >= 2) {
+				temp = numberParam - 1;
+				res = fts_write_dma_safe(&cmd[1], temp);
+
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READ:
+		case CMD_READ_BYTE:
+			if (numberParam >= 3) {
+				if (numberParam == 3
+				    || (numberParam == 4
+					&& cmd[numberParam - 1] == 0)) {
+					mess.dummy = 0;
+				} else
+					mess.dummy = 1;
+				u8ToU16_be(&cmd[1], &byteToRead);
+				readData =
+				    (u8 *) kmalloc((byteToRead + mess.dummy) *
+						   sizeof(u8), GFP_KERNEL);
+				res =
+				    fts_read_dma_safe(readData, byteToRead + mess.dummy);
+				size += (byteToRead * sizeof(u8));
+
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_WRITETHENWRITEREAD:
+		case CMD_WRITETHENWRITEREAD_BYTE:
+			if (numberParam >= 6) {
+				u8ToU16_be(&cmd[numberParam - 2], &byteToRead);
+				readData =
+				    (u8 *) kmalloc(byteToRead * sizeof(u8),
+						   GFP_KERNEL);
+				res =
+				    fts_writeThenWriteRead(&cmd[3], cmd[1],
+							   &cmd[3 +
+								(int)cmd[1]],
+							   cmd[2], readData,
+							   byteToRead);
+				size += (byteToRead * sizeof(u8));
+
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_WRITEU8UX:
+		case CMD_WRITEU8UX_BYTE:
+			if (numberParam >= 4) {
+				if (cmd[2] <= sizeof(u64)) {
+					u8ToU64_be(&cmd[3], &addr, cmd[2]);
+					logError(0, "%s addr = %016X %ld \n",
+						 tag, addr, addr);
+					res =
+					    fts_writeU8UX(cmd[1], cmd[2], addr,
+							  &cmd[3 + cmd[2]],
+							  (numberParam -
+							   cmd[2] - 3));
+				} else {
+					logError(1, "%s Wrong address size!\n",
+						 tag);
+					res = ERROR_OP_NOT_ALLOW;
+				}
+
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_WRITEREADU8UX:
+		case CMD_WRITEREADU8UX_BYTE:
+			if (numberParam >= 6) {
+
+				if (cmd[2] <= sizeof(u64)) {
+
+					u8ToU64_be(&cmd[3], &addr, cmd[2]);
+					u8ToU16_be(&cmd[numberParam - 3],
+						   &byteToRead);
+					readData =
+					    (u8 *) kmalloc(byteToRead *
+							   sizeof(u8),
+							   GFP_KERNEL);
+					logError(0,
+						 "%s addr = %016X byteToRead = %d \n",
+						 tag, addr, byteToRead);
+					res =
+					    fts_writeReadU8UX(cmd[1], cmd[2],
+							      addr, readData,
+							      byteToRead,
+							      cmd[numberParam -
+								  1]);
+					size += (byteToRead * sizeof(u8));
+
+				} else {
+					logError(1, "%s Wrong address size!\n",
+						 tag);
+					res = ERROR_OP_NOT_ALLOW;
+				}
+
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_WRITEU8UXTHENWRITEU8UX:
+		case CMD_WRITEU8UXTHENWRITEU8UX_BYTE:
+			if (numberParam >= 6) {
+				if ((cmd[2] + cmd[4]) <= sizeof(u64)) {
+					u8ToU64_be(&cmd[5], &addr,
+						   cmd[2] + cmd[4]);
+					logError(0, "%s addr = %016X %ld \n",
+						 tag, addr, addr);
+					res =
+					    fts_writeU8UXthenWriteU8UX(cmd[1],
+								       cmd[2],
+								       cmd[3],
+								       cmd[4],
+								       addr,
+								       &cmd[5 +
+									    cmd
+									    [2]
+									    +
+									    cmd
+									    [4]],
+								       (numberParam
+									-
+									cmd[2] -
+									cmd[4] -
+									5));
+				} else {
+					logError(1, "%s Wrong address size! \n",
+						 tag);
+					res = ERROR_OP_NOT_ALLOW;
+				}
+
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_WRITEU8UXTHENWRITEREADU8UX:
+		case CMD_WRITEU8UXTHENWRITEREADU8UX_BYTE:
+			if (numberParam >= 8) {
+				if ((cmd[2] + cmd[4]) <= sizeof(u64)) {
+					u8ToU64_be(&cmd[5], &addr,
+						   cmd[2] + cmd[4]);
+					logError(1,
+						 "%s %s: cmd[5] = %02X, addr =  %016X \n",
+						 tag, __func__, cmd[5], addr);
+					u8ToU16_be(&cmd[numberParam - 3],
+						   &byteToRead);
+					readData =
+					    (u8 *) kmalloc(byteToRead *
+							   sizeof(u8),
+							   GFP_KERNEL);
+					res =
+					    fts_writeU8UXthenWriteReadU8UX(cmd
+									   [1],
+									   cmd
+									   [2],
+									   cmd
+									   [3],
+									   cmd
+									   [4],
+									   addr,
+									   readData,
+									   byteToRead,
+									   cmd
+									   [numberParam
+									    -
+									    1]);
+					size += (byteToRead * sizeof(u8));
+				} else {
+					logError(1,
+						 "%s Wrong total address size! \n",
+						 tag);
+					res = ERROR_OP_NOT_ALLOW;
+				}
+
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+
+			break;
+
+		case CMD_CHANGE_OUTPUT_MODE:
+			if (numberParam >= 2) {
+				bin_output = cmd[1];
+				logError(0,
+					 "%s Setting Scriptless output mode: %d \n",
+					 tag, bin_output);
+				res = OK;
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_FWWRITE:
+			if (numberParam >= 3) {
+				if (numberParam >= 2) {
+					temp = numberParam - 1;
+					res = fts_writeFwCmd(&cmd[1], temp);
+				} else {
+					logError(1, "%s Wrong parameters! \n",
+						 tag);
+					res = ERROR_OP_NOT_ALLOW;
+				}
+
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_INTERRUPT:
+			if (numberParam >= 2) {
+				if (cmd[1] == 1)
+					res = fts_enableInterrupt();
+				else
+					res = fts_disableInterrupt();
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READCONFIG:
+			if (numberParam == 5) {
+				byteToRead =
+				    ((funcToTest[3] << 8) | funcToTest[4]);
+				readData =
+				    (u8 *) kmalloc(byteToRead * sizeof(u8),
+						   GFP_KERNEL);
+				res =
+				    readConfig((u16)
+					       ((((u8) funcToTest[1] & 0x00FF)
+						 << 8) +
+						((u8) funcToTest[2] & 0x00FF)),
+					       readData, byteToRead);
+				size += (byteToRead * sizeof(u8));
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_POLLFOREVENT:
+			if (numberParam >= 5) {
+				temp = (int)funcToTest[1];
+				if (numberParam == 5 + (temp - 1) && temp != 0) {
+					readData =
+					    (u8 *) kmalloc(FIFO_EVENT_SIZE *
+							   sizeof(u8),
+							   GFP_KERNEL);
+					res =
+					    pollForEvent((int *)&funcToTest[2],
+							 temp, readData,
+							 ((funcToTest[temp + 2]
+							   & 0x00FF) << 8) +
+							 (funcToTest[temp + 3] &
+							  0x00FF));
+					if (res >= OK)
+						res = OK;
+					size += (FIFO_EVENT_SIZE * sizeof(u8));
+					byteToRead = FIFO_EVENT_SIZE;
+				} else {
+					logError(1, "%s Wrong parameters! \n",
+						 tag);
+					res = ERROR_OP_NOT_ALLOW;
+				}
+
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_SYSTEMRESET:
+			res = fts_system_reset();
+
+			break;
+
+		case CMD_READSYSINFO:
+			if (numberParam == 2) {
+				res = readSysInfo(funcToTest[1]);
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+
+			break;
+
+		case CMD_CLEANUP:
+			if (numberParam == 2) {
+				res = cleanUp(funcToTest[1]);
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+
+			break;
+
+		case CMD_GETFORCELEN:
+			temp = getForceLen();
+			if (temp < OK)
+				res = temp;
+			else {
+				size += (1 * sizeof(u8));
+				res = OK;
+			}
+			break;
+
+		case CMD_GETSENSELEN:
+			temp = getSenseLen();
+			if (temp < OK)
+				res = temp;
+			else {
+				size += (1 * sizeof(u8));
+				res = OK;
+			}
+			break;
+
+		case CMD_GETMSFRAME:
+			if (numberParam == 2) {
+				logError(0, "%s Get 1 MS Frame \n", tag);
+				setScanMode(SCAN_MODE_ACTIVE, 0x01);
+				mdelay(WAIT_FOR_FRESH_FRAMES);
+				setScanMode(SCAN_MODE_ACTIVE, 0x00);
+				mdelay(WAIT_AFTER_SENSEOFF);
+				flushFIFO();
+				res =
+				    getMSFrame3((MSFrameType) cmd[1], &frameMS);
+				if (res < 0) {
+					logError(0,
+						 "%s Error while taking the MS frame... ERROR %08X \n",
+						 tag, res);
+
+				} else {
+					logError(0,
+						 "%s The frame size is %d words\n",
+						 tag, res);
+					size += (res * sizeof(short) + 2);
+					/* set res to OK because if getMSFrame is
+					   successful res = number of words read
+					 */
+					res = OK;
+					print_frame_short("MS frame =",
+							  array1dTo2d_short
+							  (frameMS.node_data,
+							   frameMS.
+							   node_data_size,
+							   frameMS.header.
+							   sense_node),
+							  frameMS.header.
+							  force_node,
+							  frameMS.header.
+							  sense_node);
+				}
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+			/*read self raw */
+		case CMD_GETSSFRAME:
+			if (numberParam == 2) {
+				logError(0, "%s Get 1 SS Frame \n", tag);
+				flushFIFO();
+				setScanMode(SCAN_MODE_ACTIVE, 0x01);
+				mdelay(WAIT_FOR_FRESH_FRAMES);
+				setScanMode(SCAN_MODE_ACTIVE, 0x00);
+				mdelay(WAIT_AFTER_SENSEOFF);
+				res =
+				    getSSFrame3((SSFrameType) cmd[1], &frameSS);
+
+				if (res < OK) {
+					logError(0,
+						 "%s Error while taking the SS frame... ERROR %08X \n",
+						 tag, res);
+
+				} else {
+					logError(0,
+						 "%s The frame size is %d words\n",
+						 tag, res);
+					size += (res * sizeof(short) + 2);
+					/* set res to OK because if getMSFrame is
+					   successful res = number of words read
+					 */
+					res = OK;
+					print_frame_short("SS force frame =",
+							  array1dTo2d_short
+							  (frameSS.force_data,
+							   frameSS.header.
+							   force_node, 1),
+							  frameSS.header.
+							  force_node, 1);
+					print_frame_short("SS sense frame =",
+							  array1dTo2d_short
+							  (frameSS.sense_data,
+							   frameSS.header.
+							   sense_node,
+							   frameSS.header.
+							   sense_node), 1,
+							  frameSS.header.
+							  sense_node);
+				}
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_REQCOMPDATA:
+			if (numberParam == 2) {
+				logError(0,
+					 "%s Requesting Compensation Data \n",
+					 tag);
+				res = requestCompensationData(cmd[1]);
+
+				if (res < OK) {
+					logError(0,
+						 "%s Error requesting compensation data ERROR %08X \n",
+						 tag, res);
+				} else {
+					logError(0,
+						 "%s Requesting Compensation Data Finished! \n",
+						 tag);
+				}
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READCOMPDATAHEAD:
+			if (numberParam == 2) {
+				logError(0,
+					 "%s Requesting Compensation Data \n",
+					 tag);
+				res = requestCompensationData(cmd[1]);
+				if (res < OK) {
+					logError(0,
+						 "%s Error requesting compensation data ERROR %08X \n",
+						 tag, res);
+				} else {
+					logError(0,
+						 "%s Requesting Compensation Data Finished! \n",
+						 tag);
+					res =
+					    readCompensationDataHeader((u8)
+								       funcToTest
+								       [1],
+								       &dataHead,
+								       &address);
+					if (res < OK) {
+						logError(0,
+							 "%s Read Compensation Data Header ERROR %08X\n",
+							 tag, res);
+					} else {
+						logError(0,
+							 "%s Read Compensation Data Header OK!\n",
+							 tag);
+						size += (1 * sizeof(u8));
+					}
+				}
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READMSCOMPDATA:
+			if (numberParam == 2) {
+				logError(0, "%s Get MS Compensation Data \n",
+					 tag);
+				res =
+				    readMutualSenseCompensationData(cmd[1],
+								    &compData);
+
+				if (res < OK) {
+					logError(0,
+						 "%s Error reading MS compensation data ERROR %08X \n",
+						 tag, res);
+				} else {
+					logError(0,
+						 "%s MS Compensation Data Reading Finished! \n",
+						 tag);
+					size =
+					    ((compData.node_data_size +
+					      10) * sizeof(i8));
+					print_frame_i8("MS Data (Cx2) =",
+						       array1dTo2d_i8(compData.
+								      node_data,
+								      compData.
+								      node_data_size,
+								      compData.
+								      header.
+								      sense_node),
+						       compData.header.
+						       force_node,
+						       compData.header.
+						       sense_node);
+				}
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READSSCOMPDATA:
+			if (numberParam == 2) {
+				logError(0, "%s Get SS Compensation Data... \n",
+					 tag);
+				res =
+				    readSelfSenseCompensationData(cmd[1],
+								  &comData);
+				if (res < OK) {
+					logError(0,
+						 "%s Error reading SS compensation data ERROR %08X\n",
+						 tag, res);
+				} else {
+					logError(0,
+						 "%s SS Compensation Data Reading Finished! \n",
+						 tag);
+					size =
+					    ((comData.header.force_node +
+					      comData.header.sense_node) * 2 +
+					     13) * sizeof(i8);
+					print_frame_i8("SS Data Ix2_fm = ",
+						       array1dTo2d_i8(comData.
+								      ix2_fm,
+								      comData.
+								      header.
+								      force_node,
+								      comData.
+								      header.
+								      force_node),
+						       1,
+						       comData.header.
+						       force_node);
+					print_frame_i8("SS Data Cx2_fm = ",
+						       array1dTo2d_i8(comData.
+								      cx2_fm,
+								      comData.
+								      header.
+								      force_node,
+								      comData.
+								      header.
+								      force_node),
+						       1,
+						       comData.header.
+						       force_node);
+					print_frame_i8("SS Data Ix2_sn = ",
+						       array1dTo2d_i8(comData.
+								      ix2_sn,
+								      comData.
+								      header.
+								      sense_node,
+								      comData.
+								      header.
+								      sense_node),
+						       1,
+						       comData.header.
+						       sense_node);
+					print_frame_i8("SS Data Cx2_sn = ",
+						       array1dTo2d_i8(comData.
+								      cx2_sn,
+								      comData.
+								      header.
+								      sense_node,
+								      comData.
+								      header.
+								      sense_node),
+						       1,
+						       comData.header.
+						       sense_node);
+				}
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READTOTMSCOMPDATA:
+			if (numberParam == 2) {
+				logError(0,
+					 "%s Get TOT MS Compensation Data \n",
+					 tag);
+				res =
+				    readTotMutualSenseCompensationData(cmd[1],
+								       &totCompData);
+
+				if (res < OK) {
+					logError(0,
+						 "%s Error reading TOT MS compensation data ERROR %08X \n",
+						 tag, res);
+				} else {
+					logError(0,
+						 "%s TOT MS Compensation Data Reading Finished! \n",
+						 tag);
+					size =
+					    (totCompData.node_data_size *
+					     sizeof(short) + 9);
+					print_frame_short("MS Data (TOT Cx) =",
+							  array1dTo2d_short
+							  (totCompData.
+							   node_data,
+							   totCompData.
+							   node_data_size,
+							   totCompData.header.
+							   sense_node),
+							  totCompData.header.
+							  force_node,
+							  totCompData.header.
+							  sense_node);
+				}
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READTOTSSCOMPDATA:
+			if (numberParam == 2) {
+				logError(0,
+					 "%s Get TOT SS Compensation Data... \n",
+					 tag);
+				res =
+				    readTotSelfSenseCompensationData(cmd[1],
+								     &totComData);
+				if (res < OK) {
+					logError(0,
+						 "%s Error reading TOT SS compensation data ERROR %08X\n",
+						 tag, res);
+				} else {
+					logError(0,
+						 "%s TOT SS Compensation Data Reading Finished! \n",
+						 tag);
+					size =
+					    ((totComData.header.force_node +
+					      totComData.header.sense_node) *
+					     2 * sizeof(short) + 9);
+					print_frame_u16("SS Data TOT Ix_fm = ",
+							array1dTo2d_u16
+							(totComData.ix_fm,
+							 totComData.header.
+							 force_node,
+							 totComData.header.
+							 force_node), 1,
+							totComData.header.
+							force_node);
+					print_frame_short
+					    ("SS Data TOT Cx_fm = ",
+					     array1dTo2d_short(totComData.cx_fm,
+							       totComData.
+							       header.
+							       force_node,
+							       totComData.
+							       header.
+							       force_node), 1,
+					     totComData.header.force_node);
+					print_frame_u16("SS Data TOT Ix_sn = ",
+							array1dTo2d_u16
+							(totComData.ix_sn,
+							 totComData.header.
+							 sense_node,
+							 totComData.header.
+							 sense_node), 1,
+							totComData.header.
+							sense_node);
+					print_frame_short
+					    ("SS Data TOT Cx_sn = ",
+					     array1dTo2d_short(totComData.cx_sn,
+							       totComData.
+							       header.
+							       sense_node,
+							       totComData.
+							       header.
+							       sense_node), 1,
+					     totComData.header.sense_node);
+				}
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_GETFWVER:
+			res = getFirmwareVersion(&fw_version, &config_id);
+			if (res < OK) {
+				logError(1,
+					 "%s Error reading firmware version and config id ERROR %02X\n",
+					 tag, res);
+			} else {
+				logError(0,
+					 "%s getFirmwareVersion Finished! \n",
+					 tag);
+				size += (4) * sizeof(u8);
+			}
+			break;
+
+		case CMD_FLASHUNLOCK:
+			res = flash_unlock();
+			if (res < OK) {
+				logError(1,
+					 "%s Impossible Unlock Flash ERROR %08X\n",
+					 tag, res);
+			} else {
+				logError(0, "%s Flash Unlock OK!\n", tag);
+			}
+			break;
+
+		case CMD_READFWFILE:
+			if (numberParam == 2) {
+				logError(0, "%s Reading FW File... \n", tag);
+				res =
+				    readFwFile(PATH_FILE_FW, &fw,
+					       funcToTest[1]);
+				if (res < OK) {
+					logError(0,
+						 "%s Error reading FW File ERROR %08X\n",
+						 tag, res);
+				} else {
+					logError(0,
+						 "%s Read FW File Finished! \n",
+						 tag);
+				}
+				kfree(fw.data);
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_FLASHPROCEDURE:
+			if (numberParam == 3) {
+				logError(0,
+					 "%s Starting Flashing Procedure... \n",
+					 tag);
+				res =
+				    flashProcedure(PATH_FILE_FW, cmd[1],
+						   cmd[2]);
+				if (res < OK) {
+					logError(0,
+						 "%s Error during flash procedure ERROR %08X\n",
+						 tag, res);
+				} else {
+					logError(0,
+						 "%s Flash Procedure Finished! \n",
+						 tag);
+				}
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_FLASHERASEUNLOCK:
+			res = flash_erase_unlock();
+			if (res < OK) {
+				logError(0,
+					 "%s Error during flash erase unlock... ERROR %08X\n",
+					 tag, res);
+			} else {
+				logError(0,
+					 "%s Flash Erase Unlock Finished! \n",
+					 tag);
+			}
+			break;
+
+		case CMD_FLASHERASEPAGE:
+			if (numberParam == 2) {
+				logError(0,
+					 "%s Starting Flashing Page Erase... \n",
+					 tag);
+				res = flash_erase_page_by_page(cmd[1]);
+				if (res < OK) {
+					logError(0,
+						 "%s Error during flash page erase... ERROR %08X\n",
+						 tag, res);
+				} else {
+					logError(0,
+						 "%s Flash Page Erase Finished! \n",
+						 tag);
+				}
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+			/*ITO TEST */
+		case CMD_ITOTEST:
+			res = production_test_ito(LIMITS_FILE, &tests);
+			break;
+
+			/*Initialization */
+		case CMD_INITTEST:
+			if (numberParam == 2) {
+				res = production_test_initialization(cmd[1]);
+
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_MSRAWTEST:
+			if (numberParam == 2)
+				res =
+				    production_test_ms_raw(LIMITS_FILE, cmd[1],
+							   &tests);
+			else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_MSINITDATATEST:
+			if (numberParam == 2)
+				res =
+				    production_test_ms_cx(LIMITS_FILE, cmd[1],
+							  &tests);
+			else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_SSRAWTEST:
+			if (numberParam == 2)
+				res =
+				    production_test_ss_raw(LIMITS_FILE, cmd[1],
+							   &tests);
+			else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_SSINITDATATEST:
+			if (numberParam == 2)
+				res =
+				    production_test_ss_ix_cx(LIMITS_FILE,
+							     cmd[1], &tests);
+			else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+			/*PRODUCTION TEST */
+		case CMD_MAINTEST:
+			if (numberParam == 3)
+				res =
+				    production_test_main(LIMITS_FILE, cmd[1],
+							 cmd[2], &tests);
+			else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_FREELIMIT:
+			res = freeCurrentLimitsFile();
+			break;
+
+		case CMD_POWERCYCLE:
+			res = fts_chip_powercycle(info);
+			break;
+
+		case CMD_GETLIMITSFILE:
+			if (numberParam >= 1) {
+				lim.data = NULL;
+				lim.size = 0;
+				if (numberParam == 1)
+					res = getLimitsFile(LIMITS_FILE, &lim);
+				else
+					res = getLimitsFile(path, &lim);
+				readData = lim.data;
+				fileSize = lim.size;
+				size += (fileSize * sizeof(u8));
+				if (byte_call == 1)
+					size += sizeof(u32);
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_GETLIMITSFILE_BYTE:
+			if (numberParam >= 3) {
+				lim.data = NULL;
+				lim.size = 0;
+
+				u8ToU16_be(&cmd[1], &byteToRead);
+				addr = ((u64) byteToRead) * 4;
+
+				res = getLimitsFile(LIMITS_FILE, &lim);
+
+				readData = lim.data;
+				fileSize = lim.size;
+
+				if (fileSize > addr) {
+					logError(1,
+						 "%s Limits dimension expected by Host is less than actual size: expected = %d, real = %d \n",
+						 tag, byteToRead, fileSize);
+					res = ERROR_OP_NOT_ALLOW;
+				}
+
+				size += (addr * sizeof(u8));
+
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_GETFWFILE:
+			if (numberParam >= 1) {
+
+				if (numberParam == 1)
+					res =
+					    getFWdata(PATH_FILE_FW, &readData,
+						      &fileSize);
+				else
+					res =
+					    getFWdata(path, &readData,
+						      &fileSize);
+
+				size += (fileSize * sizeof(u8));
+				if (byte_call == 1)
+					size += sizeof(u32);
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_GETFWFILE_BYTE:
+			if (numberParam == 3) {
+
+				u8ToU16_be(&cmd[1], &byteToRead);
+				addr = ((u64) byteToRead) * 4;
+
+				res =
+				    getFWdata(PATH_FILE_FW, &readData,
+					      &fileSize);
+				if (fileSize > addr) {
+					logError(1,
+						 "%s FW dimension expected by Host is less than actual size: expected = %d, real = %d \n",
+						 tag, byteToRead, fileSize);
+					res = ERROR_OP_NOT_ALLOW;
+				}
+
+				size += (addr * sizeof(u8));
+
+			} else {
+				logError(1, "%s Wrong number of parameters! \n",
+					 tag);
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+/*
+* finish all the diagnostic command with a goto ERROR in order to skip the modification on driver_test_buff
+* remember to set properly the limit and printed variables in order to make the seq_file logic to work
+*/
+		case CMD_DIAGNOSTIC:
+			index = 0;
+			size = 0;
+			fileSize = 256 * 1024 * sizeof(char);
+			driver_test_buff = (u8 *) kzalloc(fileSize, GFP_KERNEL);
+			readData =
+			    (u8 *)
+			    kmalloc((ERROR_DUMP_ROW_SIZE *
+				     ERROR_DUMP_COL_SIZE) * sizeof(u8),
+				    GFP_KERNEL);
+			if (driver_test_buff == NULL || readData == NULL) {
+				res = ERROR_ALLOC;
+				logError(1,
+					 "%s Impossible allocate memory for buffers! ERROR %08X! \n",
+					 tag, res);
+				goto END;
+			}
+			j = snprintf(&driver_test_buff[index], fileSize - index,
+				     "DIAGNOSTIC TEST:\n1) I2C Test: ");
+			index += j;
+
+			res =
+			    fts_writeReadU8UX(FTS_CMD_HW_REG_R,
+					      ADDR_SIZE_HW_REG, ADDR_DCHIP_ID,
+					      (u8 *)&temp, 2, DUMMY_HW_REG);
+			if (res < OK) {
+				logError(1,
+					 "%s Error during I2C test: ERROR %08X! \n",
+					 tag, res);
+				j = snprintf(&driver_test_buff[index],
+					     fileSize - index, "ERROR %08X \n",
+					     res);
+				index += j;
+				res = ERROR_OP_NOT_ALLOW;
+				goto END_DIAGNOSTIC;
+			}
+
+			temp &= 0xFFFF;
+			logError(1, "%s Chip ID = %04X! \n", tag, temp);
+			j = snprintf(&driver_test_buff[index], fileSize - index,
+				     "DATA = %04X, expected = %02X%02X \n",
+				     temp, DCHIP_ID_1, DCHIP_ID_0);
+			index += j;
+			if (temp != ((DCHIP_ID_1 << 8) | DCHIP_ID_0)) {
+				logError(1,
+					 "%s Wrong CHIP ID, Diagnostic failed! \n",
+					 tag, res);
+				res = ERROR_OP_NOT_ALLOW;
+				goto END_DIAGNOSTIC;
+			}
+
+			j = snprintf(&driver_test_buff[index], fileSize - index,
+				     "Present Driver Mode: %08X \n",
+				     info->mode);
+			index += j;
+
+			j = snprintf(&driver_test_buff[index], fileSize - index,
+				     "2) FW running: Sensing On...");
+			index += j;
+			logError(1, "%s Sensing On! \n", tag, temp);
+			readData[0] = FTS_CMD_SCAN_MODE;
+			readData[1] = SCAN_MODE_ACTIVE;
+			readData[2] = 0x1;
+			fts_write(readData, 3);
+			res = checkEcho(readData, 3);
+			if (res < OK) {
+				logError(1,
+					 "%s No Echo received.. ERROR %08X !\n",
+					 tag, res);
+				j = snprintf(&driver_test_buff[index],
+					     fileSize - index,
+					     "No echo found... ERROR %08X!\n",
+					     res);
+				index += j;
+				goto END_DIAGNOSTIC;
+			} else {
+				logError(1, "%s Echo FOUND... OK!\n", tag, res);
+				j = snprintf(&driver_test_buff[index],
+					     fileSize - index,
+					     "Echo FOUND... OK!\n");
+				index += j;
+			}
+
+			logError(1, "%s Reading Frames...! \n", tag, temp);
+			j = snprintf(&driver_test_buff[index], fileSize - index,
+				     "3) Read Frames: \n");
+			index += j;
+			for (temp = 0; temp < DIAGNOSTIC_NUM_FRAME; temp++) {
+				logError(1, "%s Iteration n. %d...\n", tag,
+					 temp + 1);
+				j = snprintf(&driver_test_buff[index],
+					     fileSize - index,
+					     "Iteration n. %d...\n", temp + 1);
+				index += j;
+				for (addr = 0; addr < 3; addr++) {
+					switch (addr) {
+					case 0:
+						j = snprintf(&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "MS RAW FRAME =");
+						index += j;
+						res |=
+						    getMSFrame3(MS_RAW,
+								&frameMS);
+						break;
+					case 2:
+						j = snprintf(&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "MS STRENGTH FRAME =");
+						index += j;
+						res |=
+						    getMSFrame3(MS_STRENGTH,
+								&frameMS);
+						break;
+					case 1:
+						j = snprintf(&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "MS BASELINE FRAME =");
+						index += j;
+						res |=
+						    getMSFrame3(MS_BASELINE,
+								&frameMS);
+						break;
+					}
+					if (res < OK) {
+						j = snprintf(&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "No data! ERROR %08X \n",
+							     res);
+						index += j;
+					} else {
+						for (address = 0;
+						     address <
+						     frameMS.node_data_size;
+						     address++) {
+							if (address %
+							    frameMS.header.
+							    sense_node == 0) {
+								j = snprintf
+								    (&driver_test_buff
+								     [index],
+								     fileSize -
+								     index,
+								     "\n");
+								index += j;
+							}
+							j = snprintf
+							    (&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "%5d, ",
+							     frameMS.
+							     node_data
+							     [address]);
+							index += j;
+						}
+						j = snprintf(&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "\n");
+						index += j;
+					}
+					if (frameMS.node_data != NULL)
+						kfree(frameMS.node_data);
+				}
+				for (addr = 0; addr < 3; addr++) {
+					switch (addr) {
+					case 0:
+						j = snprintf(&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "SS RAW FRAME = \n");
+						index += j;
+						res |=
+						    getSSFrame3(SS_RAW,
+								&frameSS);
+						break;
+					case 2:
+						j = snprintf(&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "SS STRENGTH FRAME = \n");
+						index += j;
+						res |=
+						    getSSFrame3(SS_STRENGTH,
+								&frameSS);
+						break;
+					case 1:
+						j = snprintf(&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "SS BASELINE FRAME = \n");
+						index += j;
+						res |=
+						    getSSFrame3(SS_BASELINE,
+								&frameSS);
+						break;
+					}
+					if (res < OK) {
+						j = snprintf(&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "No data! ERROR %08X \n",
+							     res);
+						index += j;
+					} else {
+						for (address = 0;
+						     address <
+						     frameSS.header.force_node;
+						     address++) {
+							j = snprintf
+							    (&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "%d\n",
+							     frameSS.
+							     force_data
+							     [address]);
+
+							index += j;
+						}
+						for (address = 0;
+						     address <
+						     frameSS.header.sense_node;
+						     address++) {
+							j = snprintf
+							    (&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "%d, ",
+							     frameSS.
+							     sense_data
+							     [address]);
+
+							index += j;
+						}
+						j = snprintf(&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "\n");
+						index += j;
+					}
+					if (frameSS.force_data != NULL)
+						kfree(frameSS.force_data);
+					if (frameSS.sense_data != NULL)
+						kfree(frameSS.sense_data);
+				}
+			}
+
+			logError(1, "%s Reading error info... \n", tag, temp);
+			j = snprintf(&driver_test_buff[index], fileSize - index,
+				     "4) FW INFO DUMP: ");
+			index += j;
+			temp = dumpErrorInfo(readData, ERROR_DUMP_ROW_SIZE * ERROR_DUMP_COL_SIZE);
+			if (temp < OK) {
+				logError(1,
+					 "%s Error during dump: ERROR %08X! \n",
+					 tag, res);
+				j = snprintf(&driver_test_buff[index],
+					     fileSize - index, "ERROR %08X \n",
+					     temp);
+				index += j;
+			} else {
+				logError(1, "%s DUMP OK! \n", tag, res);
+				for (temp = 0;
+				     temp <
+				     ERROR_DUMP_ROW_SIZE * ERROR_DUMP_COL_SIZE;
+				     temp++) {
+					if (temp % ERROR_DUMP_COL_SIZE == 0) {
+						j = snprintf(&driver_test_buff
+							     [index],
+							     fileSize - index,
+							     "\n%2d - ",
+							     temp /
+							     ERROR_DUMP_COL_SIZE);
+						index += j;
+					}
+					j = snprintf(&driver_test_buff[index],
+						     fileSize - index, "%02X ",
+						     readData[temp]);
+					index += j;
+				}
+			}
+			res |= temp;
+
+END_DIAGNOSTIC:
+			if (res < OK) {
+				j = snprintf(&driver_test_buff[index],
+					     fileSize - index,
+					     "\nRESULT = FAIL \n");
+				index += j;
+			} else {
+				j = snprintf(&driver_test_buff[index],
+					     fileSize - index,
+					     "\nRESULT = FINISHED \n");
+				index += j;
+			}
+			limit = index;
+			printed = 0;
+			goto ERROR;
+			break;
+		case CMD_CHANGE_SAD:
+			res = changeSAD(cmd[1]);
+			break;
+
+		default:
+			logError(1, "%s COMMAND ID NOT VALID!!! \n", tag);
+			res = ERROR_OP_NOT_ALLOW;
+			break;
+		}
+
+	} else {
+		logError(1,
+			 "%s NO COMMAND SPECIFIED!!! do: 'echo [cmd_code] [args] > stm_fts_cmd' before looking for result!\n",
+			 tag);
+		res = ERROR_OP_NOT_ALLOW;
+
+	}
+
+END:
+	if (driver_test_buff != NULL) {
+		logError(1,
+			 "%s Consecutive echo on the file node, free the buffer with the previous result\n",
+			 tag);
+		kfree(driver_test_buff);
+	}
+
+	if (byte_call == 0) {
+		size *= 2;
+		size += 2;
+	} else {
+		if (bin_output != 1) {
+			size *= 2;
+			size -= 1;
+		} else
+			size += 1;
+	}
+
+	logError(0, "%s Size = %d\n", tag, size);
+	driver_test_buff = (u8 *) kzalloc(size, GFP_KERNEL);
+	logError(0, "%s Finish to allocate memory! \n", tag);
+	if (driver_test_buff == NULL) {
+		logError(0,
+			 "%s Unable to allocate driver_test_buff! ERROR %08X\n",
+			 tag, ERROR_ALLOC);
+		goto ERROR;
+	}
+
+	if (byte_call == 0) {
+		index = 0;
+		snprintf(&driver_test_buff[index], 3, "{ ");
+		index += 2;
+		snprintf(&driver_test_buff[index], 9, "%08X", res);
+
+		index += 8;
+		if (res >= OK) {
+			/*all the other cases are already fine printing only the res. */
+			switch (funcToTest[0]) {
+			case CMD_VERSION:
+			case CMD_READ:
+			case CMD_WRITEREAD:
+			case CMD_WRITETHENWRITEREAD:
+			case CMD_WRITEREADU8UX:
+			case CMD_WRITEU8UXTHENWRITEREADU8UX:
+			case CMD_READCONFIG:
+			case CMD_POLLFOREVENT:
+				if (mess.dummy == 1)
+					j = 1;
+				else
+					j = 0;
+				for (; j < byteToRead + mess.dummy; j++) {
+					snprintf(&driver_test_buff[index], 3, "%02X", readData[j]);
+					index += 2;
+				}
+				break;
+			case CMD_GETFWFILE:
+			case CMD_GETLIMITSFILE:
+				logError(0, "%s Start To parse! \n", tag);
+				for (j = 0; j < fileSize; j++) {
+					snprintf(&driver_test_buff[index], 3,
+						 "%02X", readData[j]);
+					index += 2;
+				}
+				logError(0, "%s Finish to parse! \n", tag);
+				break;
+			case CMD_GETFORCELEN:
+			case CMD_GETSENSELEN:
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 (u8) temp);
+				index += 2;
+
+				break;
+
+			case CMD_GETMSFRAME:
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 (u8) frameMS.header.force_node);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 (u8) frameMS.header.sense_node);
+				index += 2;
+
+				for (j = 0; j < frameMS.node_data_size; j++) {
+					snprintf(&driver_test_buff[index], 5,
+						 "%02X%02X",
+						 (frameMS.
+						  node_data[j] & 0xFF00) >> 8,
+						 frameMS.node_data[j] & 0xFF);
+					index += 4;
+				}
+
+				kfree(frameMS.node_data);
+				break;
+
+			case CMD_GETSSFRAME:
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 (u8) frameSS.header.force_node);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 (u8) frameSS.header.sense_node);
+				index += 2;
+				for (j = 0; j < frameSS.header.force_node; j++) {
+					snprintf(&driver_test_buff[index], 5,
+						 "%02X%02X",
+						 (frameSS.
+						  force_data[j] & 0xFF00) >> 8,
+						 frameSS.force_data[j] & 0xFF);
+					index += 4;
+				}
+
+				for (j = 0; j < frameSS.header.sense_node; j++) {
+					snprintf(&driver_test_buff[index], 5,
+						 "%02X%02X",
+						 (frameSS.
+						  sense_data[j] & 0xFF00) >> 8,
+						 frameSS.sense_data[j] & 0xFF);
+					index += 4;
+				}
+
+				kfree(frameSS.force_data);
+				kfree(frameSS.sense_data);
+				break;
+
+			case CMD_READMSCOMPDATA:
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 (u8) compData.header.type);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 (u8) compData.header.force_node);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 (u8) compData.header.sense_node);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 compData.cx1 & 0xFF);
+				index += 2;
+
+				for (j = 0; j < compData.node_data_size; j++) {
+					snprintf(&driver_test_buff[index], 3,
+						 "%02X",
+						 compData.node_data[j] & 0xFF);
+					index += 2;
+				}
+
+				kfree(compData.node_data);
+				break;
+
+			case CMD_READSSCOMPDATA:
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 (u8) comData.header.type);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 comData.header.force_node);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 comData.header.sense_node);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 comData.f_ix1 & 0xFF);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 comData.s_ix1 & 0xFF);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 comData.f_cx1 & 0xFF);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 comData.s_cx1 & 0xFF);
+				index += 2;
+
+				for (j = 0; j < comData.header.force_node; j++) {
+					snprintf(&driver_test_buff[index], 3,
+						 "%02X",
+						 comData.ix2_fm[j] & 0xFF);
+					index += 2;
+
+				}
+
+				for (j = 0; j < comData.header.sense_node; j++) {
+					snprintf(&driver_test_buff[index], 3,
+						 "%02X",
+						 comData.ix2_sn[j] & 0xFF);
+					index += 2;
+
+				}
+
+				for (j = 0; j < comData.header.force_node; j++) {
+					snprintf(&driver_test_buff[index], 3,
+						 "%02X",
+						 comData.cx2_fm[j] & 0xFF);
+
+					index += 2;
+				}
+
+				for (j = 0; j < comData.header.sense_node; j++) {
+					snprintf(&driver_test_buff[index], 3,
+						 "%02X",
+						 comData.cx2_sn[j] & 0xFF);
+					index += 2;
+				}
+
+				kfree(comData.ix2_fm);
+				kfree(comData.ix2_sn);
+				kfree(comData.cx2_fm);
+				kfree(comData.cx2_sn);
+				break;
+
+			case CMD_READTOTMSCOMPDATA:
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 (u8) totCompData.header.type);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 (u8) totCompData.header.force_node);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 (u8) totCompData.header.sense_node);
+
+				index += 2;
+
+				for (j = 0; j < totCompData.node_data_size; j++) {
+					snprintf(&driver_test_buff[index], 5,
+						 "%02X%02X",
+						 (totCompData.
+						  node_data[j] & 0xFF00) >> 8,
+						 totCompData.
+						 node_data[j] & 0xFF);
+					index += 4;
+				}
+
+				kfree(totCompData.node_data);
+				break;
+
+			case CMD_READTOTSSCOMPDATA:
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 (u8) totComData.header.type);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 totComData.header.force_node);
+				index += 2;
+
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 totComData.header.sense_node);
+				index += 2;
+
+				for (j = 0; j < totComData.header.force_node;
+				     j++) {
+					snprintf(&driver_test_buff[index], 5,
+						 "%02X%02X",
+						 (totComData.
+						  ix_fm[j] & 0xFF00) >> 8,
+						 totComData.ix_fm[j] & 0xFF);
+					index += 4;
+				}
+
+				for (j = 0; j < totComData.header.sense_node;
+				     j++) {
+					snprintf(&driver_test_buff[index], 5,
+						 "%02X%02X",
+						 (totComData.
+						  ix_sn[j] & 0xFF00) >> 8,
+						 totComData.ix_sn[j] & 0xFF);
+					index += 4;
+				}
+
+				for (j = 0; j < totComData.header.force_node;
+				     j++) {
+					snprintf(&driver_test_buff[index], 5,
+						 "%02X%02X",
+						 (totComData.
+						  cx_fm[j] & 0xFF00) >> 8,
+						 totComData.cx_fm[j] & 0xFF);
+
+					index += 4;
+				}
+
+				for (j = 0; j < totComData.header.sense_node;
+				     j++) {
+					snprintf(&driver_test_buff[index], 5,
+						 "%02X%02X",
+						 (totComData.
+						  cx_sn[j] & 0xFF00) >> 8,
+						 totComData.cx_sn[j] & 0xFF);
+					index += 4;
+				}
+
+				kfree(totComData.ix_fm);
+				kfree(totComData.ix_sn);
+				kfree(totComData.cx_fm);
+				kfree(totComData.cx_sn);
+				break;
+
+			case CMD_GETFWVER:
+				snprintf(&driver_test_buff[index], 5, "%04X",
+					 fw_version);
+				index += 4;
+
+				snprintf(&driver_test_buff[index], 5, "%04X",
+					 config_id);
+				index += 4;
+				break;
+
+			case CMD_READCOMPDATAHEAD:
+				snprintf(&driver_test_buff[index], 3, "%02X",
+					 dataHead.type);
+				index += 2;
+				break;
+
+			default:
+				break;
+			}
+		}
+
+		snprintf(&driver_test_buff[index], 4, " }\n");
+		limit = size - 1;
+		printed = 0;
+	} else {
+
+		driver_test_buff[index++] = MESSAGE_START_BYTE;
+		if (bin_output == 1) {
+
+			driver_test_buff[index++] = (size & 0xFF00) >> 8;
+			driver_test_buff[index++] = (size & 0x00FF);
+
+			driver_test_buff[index++] =
+			    (mess.counter & 0xFF00) >> 8;
+			driver_test_buff[index++] = (mess.counter & 0x00FF);
+
+			driver_test_buff[index++] = (mess.action & 0xFF00) >> 8;
+			driver_test_buff[index++] = (mess.action & 0x00FF);
+
+			driver_test_buff[index++] = (res & 0xFF00) >> 8;
+			driver_test_buff[index++] = (res & 0x00FF);
+
+		} else {
+			if (funcToTest[0] == CMD_GETLIMITSFILE_BYTE
+			    || funcToTest[0] == CMD_GETFWFILE_BYTE)
+				snprintf(&driver_test_buff[index], 5,
+					 "%02X%02X",
+					 (((fileSize + 3) / 4) & 0xFF00) >> 8,
+					 ((fileSize + 3) / 4) & 0x00FF);
+			else
+				snprintf(&driver_test_buff[index], 5,
+					 "%02X%02X", (size & 0xFF00) >> 8,
+					 size & 0xFF);
+			index += 4;
+			index +=
+			    snprintf(&driver_test_buff[index], 5, "%04X",
+				     (u16) mess.counter);
+			index +=
+			    snprintf(&driver_test_buff[index], 5, "%04X",
+				     (u16) mess.action);
+			index +=
+			    snprintf(&driver_test_buff[index], 5, "%02X%02X",
+				     (res & 0xFF00) >> 8, res & 0xFF);
+		}
+
+		switch (funcToTest[0]) {
+		case CMD_VERSION_BYTE:
+		case CMD_READ_BYTE:
+		case CMD_WRITEREAD_BYTE:
+		case CMD_WRITETHENWRITEREAD_BYTE:
+		case CMD_WRITEREADU8UX_BYTE:
+		case CMD_WRITEU8UXTHENWRITEREADU8UX_BYTE:
+			if (bin_output == 1) {
+				if (mess.dummy == 1)
+					memcpy(&driver_test_buff[index],
+					       &readData[1], byteToRead);
+				else
+					memcpy(&driver_test_buff[index],
+					       readData, byteToRead);
+				index += byteToRead;
+			} else {
+				j = mess.dummy;
+				for (; j < byteToRead + mess.dummy; j++)
+					index +=
+					    snprintf(&driver_test_buff[index],
+						     3, "%02X",
+						     (u8) readData[j]);
+			}
+			break;
+
+		case CMD_GETLIMITSFILE_BYTE:
+		case CMD_GETFWFILE_BYTE:
+			if (bin_output == 1) {
+				driver_test_buff[1] =
+				    (((fileSize + 3) / 4) & 0xFF00) >> 8;
+				driver_test_buff[2] =
+				    (((fileSize + 3) / 4) & 0x00FF);
+
+				if (readData != NULL) {
+					memcpy(&driver_test_buff[index],
+					       readData, fileSize);
+				} else {
+					logError(0,
+						 "%s readData = NULL... returning junk data!",
+						 tag);
+				}
+				index += addr;
+			} else {
+				for (j = 0; j < fileSize; j++) {
+					index +=
+					    snprintf(&driver_test_buff[index],
+						     3, "%02X",
+						     (u8) readData[j]);
+				}
+				for (; j < addr; j++)
+					index += snprintf(&driver_test_buff[index], 3, "%02X", 0);
+			}
+			break;
+		default:
+			break;
+		}
+
+		driver_test_buff[index++] = MESSAGE_END_BYTE;
+		driver_test_buff[index] = '\n';
+		limit = size;
+		printed = 0;
+	}
+ERROR:
+	numberParam = 0;
+	if (readData != NULL)
+		kfree(readData);
+	if (cmd)
+		kfree(cmd);
+	return count;
+}
+
+/** @}*/
+
+/**
+ * file_operations struct which define the functions for the canonical operation on a device file node (open. read, write etc.)
+ */
+static struct proc_ops fts_driver_test_ops = {
+	.proc_open = fts_open,
+	.proc_read = seq_read,
+	.proc_write = fts_driver_test_write,
+	.proc_lseek = seq_lseek,
+	.proc_release = seq_release
+};
+
+/*****************************************************************************/
+
+/**
+* This function is called in the probe to initialize and create the directory /proc/fts and the driver test file node DRIVER_TEST_FILE_NODE into the /proc file system
+* @return OK if success or an error code which specify the type of error encountered
+*/
+int fts_proc_init(void)
+{
+	struct proc_dir_entry *entry;
+
+	int retval = 0;
+
+	fts_dir = proc_mkdir_data("fts", 0777, NULL, NULL);
+	if (fts_dir == NULL) {
+		retval = -ENOMEM;
+		goto out;
+	}
+
+	entry = proc_create(DRIVER_TEST_FILE_NODE, 0644, fts_dir,
+			&fts_driver_test_ops);
+
+	if (entry) {
+		logError(1, "%s %s: proc entry CREATED! \n", tag, __func__);
+	} else {
+		logError(1, "%s %s: error creating proc entry! \n", tag,
+			 __func__);
+		retval = -ENOMEM;
+		goto badfile;
+	}
+	return OK;
+badfile:
+	remove_proc_entry("fts", NULL);
+out:
+	return retval;
+}
+
+/**
+* Delete and Clean from the file system, all the references to the driver test file node
+* @return OK
+*/
+int fts_proc_remove(void)
+{
+	remove_proc_entry(DRIVER_TEST_FILE_NODE, fts_dir);
+	remove_proc_entry("fts", NULL);
+	return OK;
+}
diff --git a/drivers/input/touchscreen/stfts/google/Kconfig b/drivers/input/touchscreen/stfts/google/Kconfig
new file mode 100644
index 000000000000..f33f56ee7667
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/Kconfig
@@ -0,0 +1,12 @@
+#
+# STMicroelectronics TOUCH driver configuration
+#
+
+config TOUCHSCREEN_ST_FTS
+	tristate "STMicroelectronics multitouch touchscreen - FingerTipS (FTM5)"
+	depends on I2C || SPI
+	help
+	  Say Y here to enable STMicroelectronics (FTM5) touchscreen support.
+	  If unsure, say N.
+	  To compile this driver as a module, choose M here: the module
+	  will be called ftm5.
diff --git a/drivers/input/touchscreen/stfts/google/Makefile b/drivers/input/touchscreen/stfts/google/Makefile
new file mode 100644
index 000000000000..b67bc9df9e77
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+
+obj-$(CONFIG_TOUCHSCREEN_ST_FTS)		+= fts.o fts_proc.o fts_lib/
diff --git a/drivers/input/touchscreen/stfts/google/fts.c b/drivers/input/touchscreen/stfts/google/fts.c
new file mode 100644
index 000000000000..6fb9bae7fe0d
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts.c
@@ -0,0 +1,7104 @@
+/**
+  * fts.c
+  *
+  * FTS Capacitive touch screen controller (FingerTipS)
+  *
+  * Copyright (C) 2016, STMicroelectronics Limited.
+  * Authors: AMG(Analog Mems Group)
+  *
+  *		marco.cali@st.com
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+  * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+  * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+  * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+  * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM
+  * THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * THIS SOFTWARE IS SPECIFICALLY DESIGNED FOR EXCLUSIVE USE WITH ST PARTS.
+  */
+
+
+/*!
+  * \file fts.c
+  * \brief It is the main file which contains all the most important functions
+  * generally used by a device driver the driver
+  */
+#include <linux/device.h>
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/interrupt.h>
+#include <linux/hrtimer.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/spi/spi.h>
+#include <linux/completion.h>
+#include <linux/device.h>
+#include <linux/of.h>
+
+#include <linux/gpio/consumer.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/consumer.h>
+
+#ifdef KERNEL_ABOVE_2_6_38
+#include <linux/input/mt.h>
+#endif
+
+#include <drm/drm_panel.h>
+#include <video/display_timing.h>
+
+#include "fts.h"
+#include "fts_lib/ftsCompensation.h"
+#include "fts_lib/ftsCore.h"
+#include "fts_lib/ftsIO.h"
+#include "fts_lib/ftsError.h"
+#include "fts_lib/ftsFlash.h"
+#include "fts_lib/ftsFrame.h"
+#include "fts_lib/ftsGesture.h"
+#include "fts_lib/ftsTest.h"
+#include "fts_lib/ftsTime.h"
+#include "fts_lib/ftsTool.h"
+
+/* Touch simulation MT slot */
+#define TOUCHSIM_SLOT_ID		0
+#define TOUCHSIM_TIMER_INTERVAL_NS	8333333
+
+/* Switch GPIO values */
+#define FTS_SWITCH_GPIO_VALUE_AP_MASTER		0
+#define FTS_SWITCH_GPIO_VALUE_SLPI_MASTER	1
+
+/**
+  * Event handler installer helpers
+  */
+#define event_id(_e)		(EVT_ID_##_e >> 4)
+#define handler_name(_h)	fts_##_h##_event_handler
+
+#define install_handler(_i, _evt, _hnd) \
+	do { \
+		_i->event_dispatch_table[event_id(_evt)] = handler_name(_hnd); \
+	} while (0)
+
+
+/* Use decimal-formatted raw data */
+#define RAW_DATA_FORMAT_DEC
+
+#ifdef KERNEL_ABOVE_2_6_38
+#define TYPE_B_PROTOCOL
+#endif
+
+#ifdef GESTURE_MODE
+extern struct mutex gestureMask_mutex;
+#endif
+
+#ifdef GESTURE_MODE
+static u8 mask[GESTURE_MASK_SIZE + 2];
+extern u16 gesture_coordinates_x[GESTURE_MAX_COORDS_PAIRS_REPORT];
+extern u16 gesture_coordinates_y[GESTURE_MAX_COORDS_PAIRS_REPORT];
+extern int gesture_coords_reported;
+extern struct mutex gestureMask_mutex;
+#endif
+
+static int fts_init_sensing(struct fts_ts_info *info);
+static int fts_mode_handler(struct fts_ts_info *info, int force);
+static void fts_pinctrl_setup(struct fts_ts_info *info, bool active);
+
+static int fts_chip_initialization(struct fts_ts_info *info, int init_type);
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+static void fts_offload_push_coord_frame(struct fts_ts_info *info);
+#endif
+
+/**
+  * Release all the touches in the linux input subsystem
+  * @param info pointer to fts_ts_info which contains info about device/hw setup
+  */
+void release_all_touches(struct fts_ts_info *info)
+{
+	unsigned int type = MT_TOOL_FINGER;
+	int i;
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	/* If the previous coord_frame that was pushed to touch_offload had
+	 * active coords (eg. there are fingers still on the screen), push an
+	 * empty coord_frame to touch_offload for clearing coords in twoshay.*/
+	if (info->offload.offload_running && info->touch_offload_active_coords) {
+		for (i = 0; i < TOUCH_ID_MAX; i++) {
+			info->offload.coords[i].status = COORD_STATUS_INACTIVE;
+		}
+		fts_offload_push_coord_frame(info);
+	} else {
+#endif
+
+	mutex_lock(&info->input_report_mutex);
+
+	for (i = 0; i < TOUCH_ID_MAX; i++) {
+#ifdef STYLUS_MODE
+		if (test_bit(i, &info->stylus_id))
+			type = MT_TOOL_PEN;
+		else
+			type = MT_TOOL_FINGER;
+#endif
+		input_mt_slot(info->input_dev, i);
+		input_report_abs(info->input_dev, ABS_MT_PRESSURE, 0);
+		input_mt_report_slot_state(info->input_dev, type, 0);
+		input_report_abs(info->input_dev, ABS_MT_TRACKING_ID, -1);
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+		info->offload.coords[i].status = COORD_STATUS_INACTIVE;
+		info->offload.coords[i].major = 0;
+		info->offload.coords[i].minor = 0;
+		info->offload.coords[i].pressure = 0;
+		info->offload.coords[i].rotation = 0;
+#endif
+	}
+	input_report_key(info->input_dev, BTN_TOUCH, 0);
+	input_sync(info->input_dev);
+
+	mutex_unlock(&info->input_report_mutex);
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	}
+#endif
+
+	info->touch_id = 0;
+	info->palm_touch_mask = 0;
+	info->grip_touch_mask = 0;
+#ifdef STYLUS_MODE
+	info->stylus_id = 0;
+#endif
+}
+
+/**
+  * @defgroup file_nodes Driver File Nodes
+  * Driver publish a series of file nodes used to provide several utilities
+  * to the host and give him access to different API.
+  * @{
+  */
+
+/**
+  * @defgroup device_file_nodes Device File Nodes
+  * @ingroup file_nodes
+  * Device File Nodes \n
+  * There are several file nodes that are associated to the device and which
+  *  are designed to be used by the host to enable/disable features or trigger
+  * some system specific actions \n
+  * Usually their final path depend on the definition of device tree node of
+  * the IC (e.g /sys/devices/soc.0/f9928000.i2c/i2c-6/6-0049)
+  * @{
+  */
+/***************************************** FW UPGGRADE
+ * ***************************************************/
+
+/**
+  * File node function to Update firmware from shell \n
+  * echo path_to_fw X Y > fwupdate   perform a fw update \n
+  * where: \n
+  * path_to_fw = file name or path of the the FW to burn, if "NULL" the default
+  * approach selected in the driver will be used\n
+  * X = 0/1 to force the FW update whichever fw_version and config_id;
+  * 0=perform a fw update only if the fw in the file is newer than the fw in the
+  * chip \n
+  * Y = 0/1 keep the initialization data; 0 = will erase the initialization data
+  * from flash, 1 = will keep the initialization data
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * X1X2X3X4 = 4 bytes in HEX format which represent an error code (00000000 no
+  * error) \n
+  * } = end byte
+  */
+static ssize_t fwupdate_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	/* default(if not specified by user) set force = 0 and keep_cx to 1 */
+	int force = 0;
+	int keep_cx = CX_KEEP;
+	char path[100 + 1]; /* extra byte to hold '\0'*/
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	/* reading out firmware upgrade parameters */
+	if (sscanf(buf, "%100s %d %d", path, &force, &keep_cx) >= 1) {
+		dev_info(dev, "%s: file = %s, force = %d, keep_cx = %d\n", __func__,
+			path, force, keep_cx);
+		fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, true);
+
+		if (info->sensor_sleep)
+			ret = ERROR_BUS_WR;
+		else {
+#ifdef COMPUTE_INIT_METHOD
+			if (keep_cx == CX_ERASE) {
+				fts_system_reset(info);
+				flushFIFO(info);
+				/* Set MPFlag to MP_FLAG_NEED_FPI since we will overwrite MS CX and
+				 * SS IX by firmware golden value (if exist).
+				 */
+				ret = saveMpFlag(info, MP_FLAG_NEED_FPI);
+				if (ret < OK)
+					dev_err(info->dev,
+						"Error while saving MP FLAG! ERROR %08X\n", ret);
+				else
+					dev_info(info->dev, "MP FLAG saving OK!\n");
+			}
+#endif
+			ret = flashProcedure(info, path, force, keep_cx);
+		}
+
+		info->fwupdate_stat = ret;
+
+		fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+
+		if (ret == ERROR_BUS_WR)
+			dev_err(dev, "%s: bus is not accessible. ERROR %08X\n",
+				__func__, ret);
+		else if (ret < OK)
+			dev_err(dev, "%s Unable to upgrade firmware! ERROR %08X\n",
+				__func__, ret);
+	} else
+		dev_err(dev, "%s: Wrong number of parameters! ERROR %08X\n",
+			__func__, ERROR_OP_NOT_ALLOW);
+	return count;
+}
+
+static ssize_t fwupdate_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	/* fwupdate_stat: ERROR code Returned by flashProcedure. */
+	return scnprintf(buf, PAGE_SIZE, "{ %08X }\n", info->fwupdate_stat);
+}
+
+/***************************************** UTILITIES
+  * (current fw_ver/conf_id, active mode, file fw_ver/conf_id)
+  ***************************************************/
+/**
+  * File node to show on terminal external release version in Little Endian \n
+  * (first the less significant byte) \n
+  * cat appid	show the external release version of the FW running in the IC
+  */
+static ssize_t appid_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	int written = 0;
+	char temp[35];
+
+	written += scnprintf(buf + written, PAGE_SIZE - written,
+			     "REL: %s\n",
+			     printHex("",
+				      info->systemInfo.u8_releaseInfo,
+				      EXTERNAL_RELEASE_INFO_SIZE,
+				      temp,
+				      sizeof(temp)));
+	written += scnprintf(buf + written, PAGE_SIZE - written,
+			     "FW: %04X\nCFG: %04X\nAFE: %02X\nProject: %04X\n",
+			     info->systemInfo.u16_fwVer,
+			     info->systemInfo.u16_cfgVer,
+			     info->systemInfo.u8_cfgAfeVer,
+			     info->systemInfo.u16_cfgProjectId);
+	written += scnprintf(buf + written, PAGE_SIZE - written,
+			     "FW file: %s\n", info->board->fw_name);
+
+	written += scnprintf(buf + written, PAGE_SIZE - written,
+			     "Extended display info: ");
+	if (!info->extinfo.is_read)
+		written += scnprintf(buf + written, PAGE_SIZE - written,
+			     "[pending]");
+	else if (info->extinfo.size == 0)
+		written += scnprintf(buf + written, PAGE_SIZE - written,
+			     "[none]");
+	else if (info->extinfo.size * 2 < PAGE_SIZE - written) {
+		bin2hex(buf + written, info->extinfo.data, info->extinfo.size);
+		written += info->extinfo.size * 2;
+	}
+
+	written += scnprintf(buf + written, PAGE_SIZE - written,
+			     "\nMPFlag: %02X\n",
+			     info->systemInfo.u8_mpFlag);
+
+	return written;
+}
+
+/**
+  * File node to show on terminal the mode that is active on the IC \n
+  * cat mode_active		    to show the bitmask which indicate
+  * the modes/features which are running on the IC in a specific instant of time
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * X1 = 1 byte in HEX format which represent the actual running scan mode
+  * (@link scan_opt Scan Mode Options @endlink) \n
+  * X2 = 1 byte in HEX format which represent the bitmask on which is running
+  * the actual scan mode \n
+  * X3X4 = 2 bytes in HEX format which represent a bitmask of the features that
+  * are enabled at this moment (@link feat_opt Feature Selection Options
+  * @endlink) \n
+  * } = end byte
+  * @see fts_mode_handler()
+  */
+static ssize_t mode_active_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	dev_info(dev, "Current mode active = %08X\n", info->mode);
+	return scnprintf(buf, PAGE_SIZE, "{ %08X }\n", info->mode);
+}
+
+/**
+  * File node to show the fw_ver and config_id of the FW file
+  * cat fw_file_test			show on the kernel log external release
+  * of the FW stored in the fw file/header file
+  */
+static ssize_t fw_file_test_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	Firmware fw;
+	int ret;
+	char temp[100] = { 0 };
+
+	fw.data = NULL;
+	ret = readFwFile(info, info->board->fw_name, &fw, 0);
+
+	if (ret < OK)
+		dev_err(dev, "Error during reading FW file! ERROR %08X\n", ret);
+	else
+		dev_info(dev, "%s, size = %d bytes\n",
+			 printHex("EXT Release = ",
+				  info->systemInfo.u8_releaseInfo,
+				  EXTERNAL_RELEASE_INFO_SIZE,
+				  temp,
+				  sizeof(temp)),
+			 fw.data_size);
+	kfree(fw.data);
+	return 0;
+}
+
+static ssize_t status_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	u8 *dump = NULL;
+	int dumpSize = ERROR_DUMP_ROW_SIZE * ERROR_DUMP_COL_SIZE;
+	u8 reg;
+	int written = 0;
+	int res;
+	int i;
+
+	if (fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, true) < 0) {
+		dev_err(dev, "%s: bus is not accessible.\n", __func__);
+		written += scnprintf(buf, PAGE_SIZE,
+				     "Bus is not accessible.\n");
+		goto exit;
+	}
+
+	written += scnprintf(buf + written, PAGE_SIZE - written,
+			     "Mode: 0x%08X\n", info->mode);
+
+	res = fts_writeReadU8UX(info, FTS_CMD_HW_REG_R, ADDR_SIZE_HW_REG,
+				ADDR_ICR, &reg, 1, DUMMY_HW_REG);
+	if (res < 0)
+		dev_err(dev, "%s: failed to read ICR.\n", __func__);
+	else
+		written += scnprintf(buf + written, PAGE_SIZE - written,
+			     "ICR: 0x%02X\n", reg);
+
+	dump = kzalloc(dumpSize, GFP_KERNEL);
+	if (!dump) {
+		written += strlcat(buf + written, "Buffer allocation failed!\n",
+				   PAGE_SIZE - written);
+		goto exit;
+	}
+
+	res = dumpErrorInfo(info, dump,
+			    ERROR_DUMP_ROW_SIZE * ERROR_DUMP_COL_SIZE);
+	if (res >= 0) {
+		written += strlcat(buf + written, "Error dump:",
+				   PAGE_SIZE - written);
+		for (i = 0; i < dumpSize; i++) {
+			if (i % 8 == 0)
+				written += scnprintf(buf + written,
+						     PAGE_SIZE - written,
+						     "\n%02X: ", i);
+			written += scnprintf(buf + written,
+					     PAGE_SIZE - written,
+					     "%02X ", dump[i]);
+		}
+		written += strlcat(buf + written, "\n", PAGE_SIZE - written);
+	}
+
+exit:
+	kfree(dump);
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+	return written;
+}
+
+#if 0
+/**
+  * File node to obtain and show strength frame
+  * cat strength_frame			to obtain strength data \n
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * X1X2X3X4 = 4 bytes in HEX format which represent an error code (00000000 no
+  *error) \n
+  * **** if error code is all 0s **** \n
+  * FF = 1 byte in HEX format number of rows \n
+  * SS = 1 byte in HEX format number of columns \n
+  * N1, ... = the decimal value of each node separated by a coma \n
+  * ********************************* \n
+  * } = end byte
+  */
+static ssize_t fts_strength_frame_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	MutualSenseFrame frame;
+	int res, count, j, size = (6 * 2) + 1, index = 0;
+	char *all_strbuff = NULL;
+	/* char buff[CMD_STR_LEN] = {0}; */
+	/* struct i2c_client *client = to_i2c_client(dev); */
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	frame.node_data = NULL;
+
+	res = fts_enableInterrupt(info, false);
+	if (res < OK)
+		goto END;
+
+	res = senseOn(info);
+	if (res < OK) {
+		dev_err(dev, "%s: could not start scanning! ERROR %08X\n",
+			__func__, res);
+		goto END;
+	}
+	mdelay(WAIT_FOR_FRESH_FRAMES);
+	res = senseOff(info);
+	if (res < OK) {
+		dev_err(dev, "%s: could not finish scanning! ERROR %08X\n",
+			__func__, res);
+		goto END;
+	}
+
+	mdelay(WAIT_AFTER_SENSEOFF);
+	flushFIFO(info);
+
+	res = getMSFrame3(info, MS_STRENGTH, &frame);
+	if (res < OK) {
+		dev_err(dev, "%s: could not get the frame! ERROR %08X\n",
+			__func__, res);
+		goto END;
+	} else {
+		size += (res * 6);
+		dev_info(dev, "The frame size is %d words\n", res);
+		res = OK;
+		print_frame_short(info, "MS Strength frame =",
+				  array1dTo2d_short(
+				  frame.node_data, frame.node_data_size,
+				  frame.header.sense_node),
+				  frame.header.force_node,
+				  frame.header.sense_node);
+	}
+
+END:
+	flushFIFO(info);
+	release_all_touches(info);
+	fts_mode_handler(info, 1);
+
+	all_strbuff = (char *)kzalloc(size * sizeof(char), GFP_KERNEL);
+
+	if (all_strbuff != NULL) {
+		snprintf(&all_strbuff[index], 11, "{ %08X", res);
+
+		index += 10;
+
+		if (res >= OK) {
+			snprintf(&all_strbuff[index], 3, "%02X",
+				 (u8)frame.header.force_node);
+			index += 2;
+			snprintf(&all_strbuff[index], 3, "%02X",
+				 (u8)frame.header.sense_node);
+
+			index += 2;
+
+			for (j = 0; j < frame.node_data_size; j++) {
+				snprintf(&all_strbuff[index], 10, "%d,%n",
+					 frame.node_data[j], &count);
+				index += count;
+			}
+
+			kfree(frame.node_data);
+		}
+
+		snprintf(&all_strbuff[index], 3, " }");
+		index += 2;
+
+		count = snprintf(buf, TSP_BUF_SIZE, "%s\n", all_strbuff);
+		kfree(all_strbuff);
+	} else
+		dev_err(dev, "%s: Unable to allocate all_strbuff! ERROR %08X\n",
+			__func__, ERROR_ALLOC);
+
+	fts_enableInterrupt(info, true);
+	return count;
+}
+#endif
+
+/***************************************** FEATURES
+  ***************************************************/
+
+/* TODO: edit this function according to the features policy to allow during
+  * the screen on/off, following is shown an example but check always with ST
+  * for more details */
+/**
+  * Check if there is any conflict in enable/disable a particular feature
+  * considering the features already enabled and running
+  * @param info pointer to fts_ts_info which contains info about the device
+  * and its hw setup
+  * @param feature code of the feature that want to be tested
+  * @return OK if is possible to enable/disable feature, ERROR_OP_NOT_ALLOW
+  * in case of any other conflict
+  */
+int check_feature_feasibility(struct fts_ts_info *info, unsigned int feature)
+{
+	int res = OK;
+
+/* Example based on the status of the screen and on the feature
+  * that is trying to enable */
+	/*res=ERROR_OP_NOT_ALLOW;
+	  * if(info->resume_bit ==0){
+	  *      switch(feature){
+	  #ifdef GESTURE_MODE
+	  *              case FEAT_SEL_GESTURE:
+	  *                      res = OK;
+	  *              break;
+	  #endif
+	  *              default:
+	  *                      dev_err(dev, "%s: Feature not allowed in this
+	  * operating mode! ERROR %08X\n", __func__, res);
+	  *              break;
+	  *
+	  *      }
+	  * }else{
+	  *      switch(feature){
+	  #ifdef GESTURE_MODE
+	  *              case FEAT_SEL_GESTURE:
+	  #endif
+	  *              case FEAT__SEL_GLOVE: // glove mode can only activate
+	  *during sense on
+	  *                      res = OK;
+	  *              break;
+	  *
+	  *              default:
+	  *                      dev_err(dev, "%s: Feature not allowed in this
+	  * operating mode! ERROR %08X\n", __func__, res);
+	  *              break;
+	  *
+	  *      }
+	  * }*/
+
+
+/* Example based only on the feature that is going to be activated */
+	switch (feature) {
+	case FEAT_SEL_GESTURE:
+		if (info->cover_enabled == 1) {
+			res = ERROR_OP_NOT_ALLOW;
+			dev_err(info->dev, "%s: Feature not allowed when in Cover mode! ERROR %08X\n",
+				__func__, res);
+			/* for example here can be placed a code for disabling
+			  * the cover mode when gesture is activated */
+		}
+		break;
+
+	case FEAT_SEL_GLOVE:
+		if (info->gesture_enabled == 1) {
+			res = ERROR_OP_NOT_ALLOW;
+			dev_err(info->dev, "%s: Feature not allowed when Gestures enabled! ERROR %08X\n",
+				__func__, res);
+			/* for example here can be placed a code for disabling
+			  * the gesture mode when cover is activated
+			  * (that means that cover mode has
+			  * an higher priority on gesture mode) */
+		}
+		break;
+
+	default:
+		dev_info(info->dev, "%s: Feature Allowed!\n", __func__);
+	}
+
+	return res;
+}
+
+#ifdef USE_ONE_FILE_NODE
+/**
+  * File node to enable some feature
+  * echo XX 00/01 > feature_enable		to enable/disable XX
+  * (possible values @link feat_opt Feature Selection Options @endlink) feature
+  * cat feature_enable		to show the result of enabling/disabling process
+  * echo 01/00 > feature_enable; cat feature_enable		to perform
+  * both actions stated before in just one call \n
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * X1X2X3X4 = 4 bytes in HEX format which represent an error code (00000000 =
+  * no error) \n
+  * } = end byte
+  */
+static ssize_t feature_enable_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	char *p = (char *)buf;
+	unsigned int temp, temp2;
+	int res = OK;
+
+	if (fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, true) < 0) {
+		res = ERROR_BUS_WR;
+		dev_err(dev, "%s: bus is not accessible.", __func__);
+		fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+		return count;
+	}
+
+	if ((count - 2 + 1) / 3 != 1)
+		dev_err(dev, "fts_feature_enable: Number of parameter wrong! %d > %d\n",
+			(count - 2 + 1) / 3, 1);
+	else {
+		if (sscanf(p, "%02X %02X ", &temp, &temp2) == 2) {
+			p += 3;
+			res = check_feature_feasibility(info, temp);
+			if (res >= OK) {
+				switch (temp) {
+		#ifdef GESTURE_MODE
+				case FEAT_SEL_GESTURE:
+					info->gesture_enabled = temp2;
+					dev_info(dev, "fts_feature_enable: Gesture Enabled = %d\n",
+						info->gesture_enabled);
+					break;
+		#endif
+
+		#ifdef GLOVE_MODE
+				case FEAT_SEL_GLOVE:
+					info->glove_enabled = temp2;
+					dev_info(dev, "fts_feature_enable: Glove Enabled = %d\n",
+						info->glove_enabled);
+					break;
+		#endif
+
+		#ifdef STYLUS_MODE
+				case FEAT_SEL_STYLUS:
+					info->stylus_enabled = temp2;
+					dev_info(dev, "fts_feature_enable: Stylus Enabled = %d\n",
+						info->stylus_enabled);
+					break;
+		#endif
+
+		#ifdef COVER_MODE
+				case FEAT_SEL_COVER:
+					info->cover_enabled = temp2;
+					dev_info(dev, "fts_feature_enable: Cover Enabled = %d\n",
+						info->cover_enabled);
+					break;
+		#endif
+
+		#ifdef CHARGER_MODE
+				case FEAT_SEL_CHARGER:
+					info->charger_enabled = temp2;
+					dev_info(dev, "fts_feature_enable: Charger Enabled = %d\n",
+						info->charger_enabled);
+					break;
+		#endif
+
+		#ifdef GRIP_MODE
+				case FEAT_SEL_GRIP:
+					info->grip_enabled = temp2;
+					dev_info(dev, "fts_feature_enable: Grip Enabled = %d\n",
+						info->grip_enabled);
+					break;
+		#endif
+
+
+
+				default:
+					dev_err(dev, "fts_feature_enable: Feature %08X not valid! ERROR %08X\n",
+						temp, ERROR_OP_NOT_ALLOW);
+					res = ERROR_OP_NOT_ALLOW;
+				}
+				info->feature_feasibility = res;
+			}
+			if (info->feature_feasibility >= OK)
+				info->feature_feasibility = fts_mode_handler(info, 1);
+			else
+				dev_err(dev, "%s: Call echo XX 00/01 > feature_enable with a correct feature value (XX)! ERROR %08X\n",
+					__func__, res);
+		} else
+			dev_err(dev, "%s: Error when reading with sscanf!\n",
+				__func__);
+	}
+
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+	return count;
+}
+
+
+
+static ssize_t feature_enable_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	int count = 0;
+
+	if (info->feature_feasibility < OK)
+		dev_err(dev, "%s: Call before echo XX 00/01 > feature_enable with a correct feature value (XX)! ERROR %08X\n",
+			__func__, info->feature_feasibility);
+
+	count += scnprintf(buf + count,
+			   PAGE_SIZE - count, "{ %08X }\n",
+			   info->feature_feasibility);
+
+	info->feature_feasibility = ERROR_OP_NOT_ALLOW;
+	return count;
+}
+
+#else
+
+
+#ifdef GRIP_MODE
+/**
+  * File node to set the grip mode
+  * echo 01/00 > grip_mode	to enable/disable glove mode \n
+  * cat grip_mode		to show the status of the grip_enabled switch \n
+  * echo 01/00 > grip_mode; cat grip_mode		to enable/disable grip
+  *mode
+  * and see the switch status in just one call \n
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * X1X2X3X4 = 4 bytes in HEX format which represent the value
+  * info->grip_enabled (1 = enabled; 0= disabled) \n
+  * } = end byte
+  */
+static ssize_t grip_mode_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int count = 0;
+
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	dev_info(dev, "%s: grip_enabled = %d\n", __func__,
+		 info->grip_enabled);
+
+	count += scnprintf(buf + count,
+			   PAGE_SIZE - count, "{ %08X }\n",
+			   info->grip_enabled);
+
+	return count;
+}
+
+
+static ssize_t grip_mode_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	char *p = (char *)buf;
+	unsigned int temp;
+	int res;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	if (fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, true) < 0) {
+		res = ERROR_BUS_WR;
+		dev_err(dev, "%s: bus is not accessible.", __func__);
+		fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+		return count;
+	}
+
+	/* in case of a different elaboration of the input, just modify
+	  * this initial part of the code according to customer needs */
+	if ((count + 1) / 3 != 1)
+		dev_err(dev, "%s: Number of bytes of parameter wrong! %zu != 1 byte\n",
+			__func__, (count + 1) / 3);
+	else {
+		if (sscanf(p, "%02X ", &temp) == 1) {
+			p += 3;
+
+/* standard code that should be always used when a feature is enabled! */
+/* first step : check if the wanted feature can be enabled */
+/* second step: call fts_mode_handler to actually enable it */
+/* NOTE: Disabling a feature is always allowed by default */
+			res = check_feature_feasibility(info, FEAT_SEL_GRIP);
+			if (res >= OK || temp == FEAT_DISABLE) {
+				info->grip_enabled = temp;
+				res = fts_mode_handler(info, 1);
+				if (res < OK)
+					dev_err(dev, "%s: Error during fts_mode_handler! ERROR %08X\n",
+						__func__, res);
+			}
+		} else
+			dev_err(dev, "%s: Error when reading with sscanf!\n",
+				__func__);
+	}
+
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+	return count;
+}
+#endif
+
+#ifdef CHARGER_MODE
+/**
+  * File node to set the glove mode
+  * echo XX/00 > charger_mode		to value >0 to enable
+  * (possible values: @link charger_opt Charger Options @endlink),
+  * 00 to disable charger mode \n
+  * cat charger_mode	to show the status of the charger_enabled switch \n
+  * echo 01/00 > charger_mode; cat charger_mode		to enable/disable
+  * charger mode and see the switch status in just one call \n
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * X1X2X3X4 = 4 bytes in HEX format which represent the value
+  * info->charger_enabled (>0 = enabled; 0= disabled) \n
+  * } = end byte
+  */
+static ssize_t charger_mode_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int count = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	dev_info(dev, "%s: charger_enabled = %d\n", __func__,
+		 info->charger_enabled);
+
+	count += scnprintf(buf + count,
+			   PAGE_SIZE - count, "{ %08X }\n",
+			   info->charger_enabled);
+	return count;
+}
+
+
+static ssize_t charger_mode_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	char *p = (char *)buf;
+	unsigned int temp;
+	int res;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	if (fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, true) < 0) {
+		res = ERROR_BUS_WR;
+		dev_err(dev, "%s: bus is not accessible.\n", __func__);
+		fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+		return count;
+	}
+
+/* in case of a different elaboration of the input, just modify this
+  * initial part of the code according to customer needs */
+	if ((count + 1) / 3 != 1)
+		dev_err(dev, "%s: Number of bytes of parameter wrong! %zu != 1 byte\n",
+			__func__, (count + 1) / 3);
+	else {
+		if (sscanf(p, "%02X ", &temp) == 1) {
+			p += 3;
+
+/** standard code that should be always used when a feature is enabled!
+  * first step : check if the wanted feature can be enabled
+  * second step: call fts_mode_handler to actually enable it
+  * NOTE: Disabling a feature is always allowed by default
+  */
+			res = check_feature_feasibility(info, FEAT_SEL_CHARGER);
+			if (res >= OK || temp == FEAT_DISABLE) {
+				info->charger_enabled = temp;
+				res = fts_mode_handler(info, 1);
+				if (res < OK)
+					dev_err(dev, "%s: Error during fts_mode_handler! ERROR %08X\n",
+						__func__, res);
+			}
+		} else
+			dev_err(dev, "%s: Error when reading with sscanf!\n",
+				__func__);
+
+	}
+
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+	return count;
+}
+#endif
+
+#ifdef GLOVE_MODE
+/**
+  * File node to set the glove mode
+  * echo 01/00 > glove_mode	to enable/disable glove mode \n
+  * cat glove_mode	to show the status of the glove_enabled switch \n
+  * echo 01/00 > glove_mode; cat glove_mode	to enable/disable glove mode and
+  *  see the switch status in just one call \n
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * X1X2X3X4 = 4 bytes in HEX format which represent the of value
+  * info->glove_enabled (1 = enabled; 0= disabled) \n
+  * } = end byte
+  */
+static ssize_t glove_mode_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int count = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	dev_info(dev, "%s: glove_enabled = %d\n", __func__, info->glove_enabled);
+
+	count += scnprintf(buf + count,
+			   PAGE_SIZE - count, "{ %08X }\n",
+			   info->glove_enabled);
+
+	return count;
+}
+
+
+static ssize_t glove_mode_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	char *p = (char *)buf;
+	unsigned int temp;
+	int res;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	if (fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, true) < 0) {
+		res = ERROR_BUS_WR;
+		dev_err(dev, "%s: bus is not accessible.\n", __func__);
+		fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+		return count;
+	}
+
+/* in case of a different elaboration of the input, just modify this
+  * initial part of the code according to customer needs */
+	if ((count + 1) / 3 != 1)
+		dev_err(dev, "%s: Number of bytes of parameter wrong! %zu != 1 byte\n",
+			__func__, (count + 1) / 3);
+	else {
+		if (sscanf(p, "%02X ", &temp) == 1) {
+			p += 3;
+
+/* standard code that should be always used when a feature is enabled! */
+/* first step : check if the wanted feature can be enabled */
+/* second step: call fts_mode_handler to actually enable it */
+/* NOTE: Disabling a feature is always allowed by default */
+			res = check_feature_feasibility(info, FEAT_SEL_GLOVE);
+			if (res >= OK || temp == FEAT_DISABLE) {
+				info->glove_enabled = temp;
+				res = fts_mode_handler(info, 1);
+				if (res < OK)
+					dev_err(dev, "%s: Error during fts_mode_handler! ERROR %08X\n",
+						__func__, res);
+			}
+		} else
+			dev_err(dev, "%s: Error when reading with sscanf!\n",
+				__func__);
+	}
+
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+	return count;
+}
+#endif
+
+
+#ifdef COVER_MODE
+/* echo 01/00 > cover_mode     to enable/disable cover mode */
+/* cat cover_mode	to show the status of the cover_enabled switch
+ * (example output in the terminal = "AA00000001BB" if the switch is enabled) */
+/* echo 01/00 > cover_mode; cat cover_mode	to enable/disable cover mode and
+  * see the switch status in just one call */
+/* NOTE: the cover can be handled also using a notifier, in this case the body
+  * of these functions should be copied in the notifier callback */
+/**
+  * File node to set the cover mode
+  * echo 01/00 > cover_mode	to enable/disable cover mode \n
+  * cat cover_mode	to show the status of the cover_enabled switch \n
+  * echo 01/00 > cover_mode; cat cover_mode	to enable/disable cover mode
+  * and see the switch status in just one call \n
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * X1X2X3X4 = 4 bytes in HEX format which is the value of info->cover_enabled
+  * (1 = enabled; 0= disabled)\n
+  * } = end byte \n
+  * NOTE: \n
+  * the cover can be handled also using a notifier, in this case the body of
+  * these functions should be copied in the notifier callback
+  */
+static ssize_t cover_mode_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int count = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	dev_info(dev, "%s: cover_enabled = %d\n", __func__, info->cover_enabled);
+
+	count += scnprintf(buf + count,
+			   PAGE_SIZE - count, "{ %08X }\n",
+			   info->cover_enabled);
+
+	return count;
+}
+
+
+static ssize_t cover_mode_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	char *p = (char *)buf;
+	unsigned int temp;
+	int res;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	if (fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, true) < 0) {
+		res = ERROR_BUS_WR;
+		dev_err(dev, "%s: bus is not accessible.\n", __func__);
+		fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+		return count;
+	}
+
+/* in case of a different elaboration of the input, just modify this
+  * initial part of the code according to customer needs */
+	if ((count + 1) / 3 != 1)
+		dev_err(dev, "%s: Number of bytes of parameter wrong! %zu != 1 byte\n",
+			__func__, (count + 1) / 3);
+	else {
+		if (sscanf(p, "%02X ", &temp) == 1) {
+			p += 3;
+
+/* standard code that should be always used when a feature is enabled! */
+/* first step : check if the wanted feature can be enabled */
+/* second step: call fts_mode_handler to actually enable it */
+/* NOTE: Disabling a feature is always allowed by default */
+			res = check_feature_feasibility(info, FEAT_SEL_COVER);
+			if (res >= OK || temp == FEAT_DISABLE) {
+				info->cover_enabled = temp;
+				res = fts_mode_handler(info, 1);
+				if (res < OK)
+					dev_err(dev, "%s: Error during fts_mode_handler! ERROR %08X\n",
+						__func__, res);
+			}
+		} else
+			dev_err(dev, "%s: Error when reading with sscanf!\n",
+				__func__);
+	}
+
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+	return count;
+}
+#endif
+
+#ifdef STYLUS_MODE
+/**
+  * File node to enable the stylus report
+  * echo 01/00 > stylus_mode		to enable/disable stylus mode \n
+  * cat stylus_mode	to show the status of the stylus_enabled switch \n
+  * echo 01/00 > stylus_mode; cat stylus_mode	to enable/disable stylus mode
+  * and see the switch status in just one call \n
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * X1X2X3X4 = 4 bytes in HEX format which is the value of info->stylus_enabled
+  * (1 = enabled; 0= disabled)\n
+  * } = end byte
+  */
+static ssize_t stylus_mode_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int count = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	dev_info(dev, "%s: stylus_enabled = %d\n", __func__, info->stylus_enabled);
+
+	count += scnprintf(buf + count,
+			   PAGE_SIZE - count, "{ %08X }\n",
+			   info->stylus_enabled);
+
+	return count;
+}
+
+
+static ssize_t stylus_mode_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	char *p = (char *)buf;
+	unsigned int temp;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+
+/* in case of a different elaboration of the input, just modify this
+  * initial part of the code according to customer needs */
+	if ((count + 1) / 3 != 1)
+		dev_err(dev, "%s: Number of bytes of parameter wrong! %zu != 1 byte\n",
+			__func__, (count + 1) / 3);
+	else {
+		if (sscanf(p, "%02X ", &temp) == 1) {
+			p += 3;
+			info->stylus_enabled = temp;
+		} else
+			dev_err(dev, "%s: Error when reading with sscanf!\n",
+				__func__);
+	}
+
+	return count;
+}
+#endif
+
+#endif
+
+/***************************************** GESTURES
+  ***************************************************/
+#ifdef GESTURE_MODE
+#ifdef USE_GESTURE_MASK	/* if this define is used, a gesture bit mask
+			  * is used as method to select the gestures to
+			  * enable/disable */
+
+/**
+  * File node used by the host to set the gesture mask to enable or disable
+  * echo EE X1 X2 ~~ > gesture_mask  set the gesture to disable/enable;
+  * EE = 00(disable) or 01(enable) \n
+  * X1 ~~  = gesture mask (example 06 00 ~~ 00 this gesture mask represents
+  * the gestures with ID = 1 and 2) can be specified
+  * from 1 to GESTURE_MASK_SIZE bytes, \n
+  * if less than GESTURE_MASK_SIZE bytes are passed as arguments,
+  * the omit bytes of the mask maintain the previous settings  \n
+  * if one or more gestures is enabled the driver will automatically
+  * enable the gesture mode, If all the gestures are disabled the driver
+  * automatically will disable the gesture mode \n
+  * cat gesture_mask   set inside the specified mask and return an error code
+  * for the operation \n
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * X1X2X3X4 = 4 bytes in HEX format which represent an error code for enabling
+  * the mask (00000000 = no error)\n
+  * } = end byte \n\n
+  * if USE_GESTURE_MASK is not define the usage of the function become: \n\n
+  * echo EE X1 X2 ~~ > gesture_mask   set the gesture to disable/enable;
+  * EE = 00(disable) or 01(enable) \n
+  * X1 ~~ = gesture IDs (example 01 02 05 represent the gestures with ID = 1, 2
+  * and 5)
+  * there is no limit of the IDs passed as arguments, (@link gesture_opt Gesture
+  * IDs @endlink) \n
+  * if one or more gestures is enabled the driver will automatically enable
+  * the gesture mode. If all the gestures are disabled the driver automatically
+  * will disable the gesture mode. \n
+  * cat gesture_mask     to show the status of the gesture enabled switch \n
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * X1X2X3X4 = 4 bytes in HEX format which is the value of info->gesture_enabled
+  * (1 = enabled; 0= disabled)\n
+  * } = end byte
+  */
+static ssize_t gesture_mask_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int count = 0, res, temp;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	if (fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, true) < 0) {
+		res = ERROR_BUS_WR;
+		dev_err(dev, "%s: bus is not accessible.\n", __func__);
+		scnprintf(buf, PAGE_SIZE, "{ %08X }\n", res);
+		fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+		return count;
+	}
+
+	if (mask[0] == 0) {
+		res = ERROR_OP_NOT_ALLOW;
+		dev_err(dev, "%s: Call before echo enable/disable xx xx .... > gesture_mask with a correct number of parameters! ERROR %08X\n",
+			__func__, res);
+	} else {
+		if (mask[1] == FEAT_ENABLE || mask[1] == FEAT_DISABLE)
+			res = updateGestureMask(&mask[2], mask[0], mask[1]);
+		else
+			res = ERROR_OP_NOT_ALLOW;
+
+		if (res < OK)
+			dev_err(dev, "%s: ERROR %08X\n", __func__, res);
+	}
+	res |= check_feature_feasibility(info, FEAT_SEL_GESTURE);
+	temp = isAnyGestureActive();
+	if (res >= OK || temp == FEAT_DISABLE)
+		info->gesture_enabled = temp;
+
+	dev_info(dev, "%s: Gesture Enabled = %d\n", __func__,
+		 info->gesture_enabled);
+
+	count += scnprintf(buf + count,
+			   PAGE_SIZE - count, "{ %08X }\n", res);
+	mask[0] = 0;
+
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+	return count;
+}
+
+
+static ssize_t gesture_mask_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	char *p = (char *)buf;
+	int n;
+	unsigned int temp;
+
+	if ((count + 1) / 3 > GESTURE_MASK_SIZE + 1) {
+		dev_err(dev, "%s: Number of bytes of parameter wrong! %zu > (enable/disable + %d )\n",
+			__func__, (count + 1) / 3, GESTURE_MASK_SIZE);
+		mask[0] = 0;
+	} else {
+		mask[0] = ((count + 1) / 3) - 1;
+		for (n = 1; n <= (count + 1) / 3; n++) {
+			if (sscanf(p, "%02X ", &temp) == 1) {
+				p += 3;
+				mask[n] = (u8)temp;
+				dev_info(dev, "mask[%d] = %02X\n", n, mask[n]);
+			} else
+				dev_err(dev, "%s: Error when reading with sscanf!\n",
+					__func__);
+		}
+	}
+
+	return count;
+}
+
+#else	/* if this define is not used, to select the gestures to enable/disable
+	  * are used the IDs of the gestures */
+/* echo EE X1 X2 ... > gesture_mask     set the gesture to disable/enable;
+  * EE = 00(disable) or 01(enable); X1 ... = gesture IDs
+  * (example 01 02 05... represent the gestures with ID = 1, 2 and 5)
+  * there is no limit of the parameters that can be passed,
+  * of course the gesture IDs should be valid (all the valid IDs are listed in
+  * ftsGesture.h) */
+/* cat gesture_mask	enable/disable the given gestures, if one or more
+  * gestures is enabled the driver will automatically enable the gesture mode.
+  * If all the gestures are disabled the driver automatically will disable the
+  * gesture mode.
+  * At the end an error code will be printed
+  *  (example output in the terminal = "AA00000000BB" if there are no errors) */
+/* echo EE X1 X2 ... > gesture_mask; cat gesture_mask	perform in one command
+  * both actions stated before */
+/**
+  * File node used by the host to set the gesture mask to enable or disable
+  * echo EE X1 X2 ~~ > gesture_mask	set the gesture to disable/enable;
+  * EE = 00(disable) or 01(enable) \n
+  * X1 ~ = gesture IDs (example 01 02 05 represent the gestures with ID = 1, 2
+  * and 5)
+  * there is no limit of the IDs passed as arguments, (@link gesture_opt Gesture
+  * IDs @endlink) \n
+  * if one or more gestures is enabled the driver will automatically enable
+  * the gesture mode, If all the gestures are disabled the driver automatically
+  * will disable the gesture mode \n
+  * cat gesture_mask	 to show the status of the gesture enabled switch \n
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * X1X2X3X4 = 4 bytes in HEX format which is the value of info->gesture_enabled
+  * (1 = enabled; 0= disabled)\n
+  * } = end byte
+  */
+static ssize_t gesture_mask_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int count = 0;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	dev_info(dev, "%s: gesture_enabled = %d\n", __func__,
+		info->gesture_enabled);
+
+	count += scnprintf(buf + count,
+			   PAGE_SIZE - count, "{ %08X }\n",
+			   info->gesture_enabled);
+
+
+	return count;
+}
+
+
+static ssize_t gesture_mask_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	char *p = (char *)buf;
+	int n;
+	unsigned int temp;
+	int res;
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	if (fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, true) < 0) {
+		res = ERROR_BUS_WR;
+		dev_err(dev, "%s: bus is not accessible.\n", __func__);
+		fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+		return count;
+	}
+
+	if ((count + 1) / 3 < 2 || (count + 1) / 3 > GESTURE_MASK_SIZE + 1) {
+		dev_err(dev, "%s: Number of bytes of parameter wrong! %d < or > (enable/disable + at least one gestureID or max %d bytes)\n",
+			__func__, (count + 1) / 3, GESTURE_MASK_SIZE);
+		mask[0] = 0;
+	} else {
+		memset(mask, 0, GESTURE_MASK_SIZE + 2);
+		mask[0] = ((count + 1) / 3) - 1;
+		if (sscanf(p, "%02X ", &temp) == 1) {
+			p += 3;
+			mask[1] = (u8)temp;
+			for (n = 1; n < (count + 1) / 3; n++) {
+				if (sscanf(p, "%02X ", &temp) == 1) {
+					p += 3;
+					fromIDtoMask((u8)temp, &mask[2],
+						GESTURE_MASK_SIZE);
+				} else {
+					dev_err(dev, "%s: Error when reading with sscanf!\n",
+						__func__);
+					mask[0] = 0;
+					goto END;
+				}
+			}
+
+			for (n = 0; n < GESTURE_MASK_SIZE + 2; n++)
+				dev_info(dev, "mask[%d] = %02X\n", n, mask[n]);
+		} else {
+			dev_err(dev, "%s: Error when reading with sscanf!\n",
+				__func__);
+			mask[0] = 0;
+		}
+	}
+
+END:
+	if (mask[0] == 0) {
+		res = ERROR_OP_NOT_ALLOW;
+		dev_err(dev, "%s: Call before echo enable/disable xx xx .... > gesture_mask with a correct number of parameters! ERROR %08X\n",
+			__func__, res);
+	} else {
+		if (mask[1] == FEAT_ENABLE || mask[1] == FEAT_DISABLE)
+			res = updateGestureMask(&mask[2], mask[0], mask[1]);
+		else
+			res = ERROR_OP_NOT_ALLOW;
+
+		if (res < OK)
+			dev_err(dev, "%s: ERROR %08X\n", __func__, res);
+	}
+
+	res = check_feature_feasibility(info, FEAT_SEL_GESTURE);
+	temp = isAnyGestureActive();
+	if (res >= OK || temp == FEAT_DISABLE)
+		info->gesture_enabled = temp;
+	res = fts_mode_handler(info, 0);
+
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+	return count;
+}
+
+
+#endif
+
+
+/**
+  * File node to read the coordinates of the last gesture drawn by the user \n
+  * cat gesture_coordinates	to obtain the gesture coordinates \n
+  * the string returned in the shell follow this up as follow: \n
+  * { = start byte \n
+  * X1X2X3X4 = 4 bytes in HEX format which represent an error code (00000000 =
+  *OK) \n
+  * \n if error code = 00000000 \n
+  * CC = 1 byte in HEX format number of coords (pair of x,y) returned \n
+  * XXiYYi ... = XXi 2 bytes in HEX format for x[i] and
+  * YYi 2 bytes in HEX format for y[i] (big endian) \n
+  * \n
+  * } = end byte
+  */
+static ssize_t gesture_coordinates_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int size = PAGE_SIZE;
+	int count = 0, res, i = 0;
+
+	dev_info(dev, "%s: Getting gestures coordinates...\n", __func__);
+
+	if (gesture_coords_reported < OK) {
+		dev_err(dev, "%s: invalid coordinates! ERROR %08X\n",
+			 __func__, gesture_coords_reported);
+		res = gesture_coords_reported;
+	} else {
+		size += gesture_coords_reported * 2 * 4 + 2;
+		/* coords are pairs of x,y (*2) where each coord is
+		  * short(2bytes=4char)(*4) + 1 byte(2char) num of coords (+2)
+		  **/
+		res = OK;	/* set error code to OK */
+	}
+
+
+	count += scnprintf(buf + count,
+			   size - count, "{ %08X", res);
+
+	if (res >= OK) {
+		count += scnprintf(buf + count,
+				   size - count, "%02X",
+				   gesture_coords_reported);
+
+		for (i = 0; i < gesture_coords_reported; i++) {
+			count += scnprintf(buf + count,
+					   size - count,
+					   "%04X",
+					   gesture_coordinates_x[i]);
+			count += scnprintf(buf + count,
+					   size - count,
+					   "%04X",
+					   gesture_coordinates_y[i]);
+		}
+	}
+
+	count += scnprintf(buf + count, size - count, " }\n");
+	dev_info(dev, "%s: Getting gestures coordinates FINISHED!\n", __func__);
+
+	return count;
+}
+#endif
+
+/* Touch simulation hr timer expiry callback */
+static enum hrtimer_restart touchsim_timer_cb(struct hrtimer *timer)
+{
+	struct fts_touchsim *touchsim = container_of(timer,
+						struct fts_touchsim,
+						hr_timer);
+	enum hrtimer_restart retval = HRTIMER_NORESTART;
+
+	if (touchsim->is_running) {
+		hrtimer_forward_now(timer,
+				ns_to_ktime(TOUCHSIM_TIMER_INTERVAL_NS));
+		retval = HRTIMER_RESTART;
+	}
+
+	/* schedule the task to report touch coordinates to kernel
+	 *  input subsystem
+	 */
+	queue_work(touchsim->wq, &touchsim->work);
+
+	return retval;
+}
+
+/* Compute the next touch coordinate(x,y) */
+static void touchsim_refresh_coordinates(struct fts_touchsim *touchsim)
+{
+	struct fts_ts_info *info  = container_of(touchsim,
+						struct fts_ts_info,
+						touchsim);
+
+	const int x_start = info->board->x_axis_max / 10;
+	const int x_max   = (info->board->x_axis_max * 9) / 10;
+	const int y_start = info->board->y_axis_max / 4;
+	const int y_max   = info->board->y_axis_max / 2;
+
+	touchsim->x += touchsim->x_step;
+	touchsim->y += touchsim->y_step;
+
+	if (touchsim->x < x_start || touchsim->x > x_max)
+		touchsim->x_step *= -1;
+
+	if (touchsim->y < y_start || touchsim->y > y_max)
+		touchsim->y_step *= -1;
+}
+
+/* Report touch contact */
+static void touchsim_report_contact_event(struct input_dev *dev, int slot_id,
+						int x, int y, int z)
+{
+	/* report the cordinates to the input subsystem */
+	input_mt_slot(dev, slot_id);
+	input_report_key(dev, BTN_TOUCH, true);
+	input_mt_report_slot_state(dev, MT_TOOL_FINGER, true);
+	input_report_abs(dev, ABS_MT_POSITION_X, x);
+	input_report_abs(dev, ABS_MT_POSITION_Y, y);
+	input_report_abs(dev, ABS_MT_PRESSURE, z);
+}
+
+/* Work callback to report the touch co-ordinates to input subsystem */
+static void touchsim_work(struct work_struct *work)
+{
+	struct fts_touchsim *touchsim =	container_of(work,
+						struct fts_touchsim,
+						work);
+	struct fts_ts_info *info  = container_of(touchsim,
+						struct fts_ts_info,
+						touchsim);
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	ktime_t timestamp = ktime_get();
+#endif
+
+	/* prevent CPU from entering deep sleep */
+	cpu_latency_qos_update_request(&info->pm_qos_req, 100);
+
+	/* Notify the PM core that the wakeup event will take 1 sec */
+	__pm_wakeup_event(info->wakesrc, jiffies_to_msecs(HZ));
+
+	/* get the next touch coordinates */
+	touchsim_refresh_coordinates(touchsim);
+
+	/* send the touch co-ordinates */
+	touchsim_report_contact_event(info->input_dev, TOUCHSIM_SLOT_ID,
+					touchsim->x, touchsim->y, 1);
+
+	input_sync(info->input_dev);
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	heatmap_read(&info->v4l2, ktime_to_ns(timestamp));
+#endif
+
+	cpu_latency_qos_update_request(&info->pm_qos_req, PM_QOS_DEFAULT_VALUE);
+}
+
+/* Start the touch simulation */
+static int touchsim_start(struct fts_touchsim *touchsim)
+{
+	struct fts_ts_info *info  = container_of(touchsim,
+						struct fts_ts_info,
+						touchsim);
+	int res;
+
+	if (!touchsim->wq) {
+		dev_err(info->dev, "%s: touch simulation test wq is not available!\n",
+			__func__);
+		return -EFAULT;
+	}
+
+	if (touchsim->is_running) {
+		dev_err(info->dev, "%s: test in progress!\n", __func__);
+		return -EBUSY;
+	}
+
+	/* setup the initial touch coordinates*/
+	touchsim->x = info->board->x_axis_max / 10;
+	touchsim->y = info->board->y_axis_max / 4;
+
+	touchsim->is_running = true;
+
+	touchsim->x_step = 2;
+	touchsim->y_step = 2;
+
+	/* Disable touch interrupts from hw */
+	res = fts_enableInterrupt(info, false);
+	if ( res != OK)
+		dev_err(info->dev, "%s: fts_enableInterrupt: ERROR %08X\n", __func__, res);
+
+	/* Release all touches in the linux input subsystem */
+	release_all_touches(info);
+
+	/* setup and start a hr timer to be fired every 120Hz(~8.333333ms) */
+	hrtimer_setup(&touchsim->hr_timer, touchsim_timer_cb,
+		      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
+	hrtimer_start(&touchsim->hr_timer,
+			ns_to_ktime(TOUCHSIM_TIMER_INTERVAL_NS),
+			HRTIMER_MODE_ABS);
+
+	return OK;
+}
+
+/* Stop the touch simulation test */
+static int touchsim_stop(struct fts_touchsim *touchsim)
+{
+	struct fts_ts_info *info  = container_of(touchsim,
+						struct fts_ts_info,
+						touchsim);
+	int res;
+
+	if (!touchsim->is_running) {
+		dev_err(info->dev, "%s: test is not in progress!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Set the flag here to make sure flushed work doesn't
+	 * re-start the timer
+	 */
+	touchsim->is_running = false;
+
+	hrtimer_cancel(&touchsim->hr_timer);
+
+	/* flush any pending work */
+	flush_workqueue(touchsim->wq);
+
+	/* Release all touches in the linux input subsystem */
+	release_all_touches(info);
+
+	/* re enable the hw touch interrupt */
+	res = fts_enableInterrupt(info, true);
+	if ( res != OK)
+		dev_err(info->dev, "%s: fts_enableInterrupt: ERROR %08X\n", __func__, res);
+
+
+	return OK;
+}
+
+/** sysfs file node to handle the touch simulation test request.
+  *  "cat touchsim" shows if the test is running
+  *  Possible outputs:
+  *  1 = test running.
+  *  0 = test not running.
+  */
+static ssize_t touchsim_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%u\n",
+			info->touchsim.is_running ? 1 : 0);
+}
+
+/** sysfs file node to handle the touch simulation test request.
+  * "echo <cmd> > touchsim"  to execute a command
+  *  Possible commands (cmd):
+  *  1 = start the test if not already running.
+  *  0 = stop the test if its running.
+  */
+static ssize_t touchsim_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf,
+					  size_t count)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	ssize_t retval = count;
+	u8 result;
+
+	if (!mutex_trylock(&info->diag_cmd_lock)) {
+		dev_err(dev, "%s: Blocking concurrent access\n", __func__);
+		retval = -EBUSY;
+		goto out;
+	}
+
+	if (kstrtou8(buf, 16, &result)) {
+		dev_err(dev, "%s:bad input. valid inputs are either 0 or 1!\n",
+			 __func__);
+		retval = -EINVAL;
+		goto unlock;
+	}
+
+	if (result == 1)
+		touchsim_start(&info->touchsim);
+	else if (result == 0)
+		touchsim_stop(&info->touchsim);
+	else
+		dev_err(dev, "%s:Invalid cmd(%u). valid cmds are either 0 or 1!\n",
+			__func__, result);
+unlock:
+	mutex_unlock(&info->diag_cmd_lock);
+out:
+	return retval;
+}
+
+/** sysfs file node to show motion filter mode
+  *  "echo 0/1 > default_mf" to change
+  *  "cat default_mf" to show
+  *  Possible commands:
+  *  0 = Dynamic change motion filter
+  *  1 = Default motion filter by FW
+  */
+static ssize_t default_mf_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", info->use_default_mf ? 1 : 0);
+}
+
+static ssize_t default_mf_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf,
+					  size_t count)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	bool val = false;
+	ssize_t retval = count;
+
+	if (!mutex_trylock(&info->diag_cmd_lock)) {
+		dev_err(dev, "%s: Blocking concurrent access\n", __func__);
+		retval = -EBUSY;
+		goto out;
+	}
+
+	if (kstrtobool(buf, &val) < 0) {
+		dev_err(dev, "%s: bad input. valid inputs are either 0 or 1!\n",
+			 __func__);
+		retval = -EINVAL;
+		goto unlock;
+	}
+
+	info->use_default_mf = val;
+
+unlock:
+	mutex_unlock(&info->diag_cmd_lock);
+out:
+	return retval;
+}
+
+/***************************************** PRODUCTION TEST
+  ***************************************************/
+
+/**
+  * File node to execute the Mass Production Test or to get data from the IC
+  * (raw or ms/ss init data)
+  * echo cmd > stm_fts_cmd	to execute a command \n
+  * cat stm_fts_cmd	to show the result of the command \n
+  * echo cmd > stm_fts_cmd; cat stm_fts_cmd	to execute and show the result
+  * in just one call \n
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * X1X2X3X4 = 4 bytes in HEX format which represent an error_code (00000000 =
+  * OK)\n
+  * (optional) data = data coming from the command executed represented as HEX
+  * string \n
+  *                   Not all the command return additional data \n
+  * } = end byte \n
+  * \n
+  * Possible commands (cmd): \n
+  * - 00 = MP Test -> return error_code \n
+  * - 01 = ITO Test -> return error_code \n
+  * - 03 = MS Raw Test -> return error_code \n
+  * - 04 = MS Init Data Test -> return error_code \n
+  * - 05 = SS Raw Test -> return error_code \n
+  * - 06 = SS Init Data Test -> return error_code \n
+  * - 13 = Read 1 MS Raw Frame -> return additional data: MS frame row after row
+  * \n
+  * - 14 = Read MS Init Data -> return additional data: MS init data row after
+  * row \n
+  * - 15 = Read 1 SS Raw Frame -> return additional data: SS frame,
+  * force channels followed by sense channels \n
+  * - 16 = Read SS Init Data -> return additional data: SS Init data,
+  * first IX for force and sense channels and then CX for force and sense
+  * channels \n
+  * - F0 = Perform a system reset -> return error_code \n
+  * - F1 = Perform a system reset and reenable the sensing and the interrupt
+  */
+static ssize_t stm_fts_cmd_write(struct file *fp, struct kobject *kobj,
+				 struct bin_attribute *battr, char *buf,
+				 loff_t offset, size_t count)
+{
+	u8 result, n = 0;
+	struct device *dev = kobj_to_dev(kobj);
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	char *p, *temp_buf, *token;
+	size_t token_len = 0;
+	ssize_t retval = count;
+
+	if (offset != 0)
+		return count;
+
+	if (!count) {
+		dev_err(dev, "%s: Invalid input buffer length!\n", __func__);
+		retval = -EINVAL;
+		goto out;
+	}
+
+	if (!info) {
+		dev_err(dev, "%s: Unable to access driver data\n", __func__);
+		retval = -EINVAL;
+		goto out;
+	}
+
+	if (!mutex_trylock(&info->diag_cmd_lock)) {
+		dev_err(dev, "%s: Blocking concurrent access\n", __func__);
+		retval = -EBUSY;
+		goto out;
+	}
+
+	memset(info->typeOfCommand, 0, sizeof(info->typeOfCommand));
+
+	temp_buf = kstrdup(buf, GFP_KERNEL);
+	if (!temp_buf) {
+		dev_err(dev, "%s: memory allocation failed!",
+			__func__);
+		retval = -ENOMEM;
+		goto unlock;
+	}
+
+	p = temp_buf;
+
+	/* Parse the input string to retrieve 2 hex-digit width cmds/args
+	 * separated by one or more spaces.
+	 * Any input not equal to 2 hex-digit width are ignored.
+	 * A single 2 hex-digit width  command w/ or w/o space is allowed.
+	 * Inputs not in the valid hex range are also ignored.
+	 * In case of encountering any of the above failure, the entire input
+	 * buffer is discarded.
+	 */
+	while (p && (n < CMD_STR_LEN)) {
+
+		while (isspace(*p)) {
+			p++;
+		}
+
+		token = strsep(&p, " ");
+
+		if (!token || *token == '\0') {
+			break;
+		}
+
+		token_len = strlen(token);
+
+		/* handle last token case */
+		if (token_len == 3 && token[2] == '\n')
+			token[2] = '\0';
+		else if (token_len != 2) {
+			dev_err(dev, "%s: bad len. len=%zu\n",
+				 __func__, token_len);
+			n = 0;
+			break;
+		}
+
+		if (kstrtou8(token, 16, &result)) {
+			/* Conversion failed due to bad input.
+			* Discard the entire buffer.
+			*/
+			dev_err(dev, "%s: bad input\n", __func__);
+			n = 0;
+			break;
+		}
+
+		/* found a valid cmd/args */
+		info->typeOfCommand[n] = result;
+		dev_info(dev, "%s: typeOfCommand[%d]=%02X\n",
+			__func__, n, info->typeOfCommand[n]);
+
+		n++;
+	}
+
+	if (n == 0) {
+		dev_err(dev, "%s: Found invalid cmd/arg\n", __func__);
+		retval = -EINVAL;
+	}
+
+	info->numberParameters = n;
+	dev_info(dev, "%s: Number of Parameters = %d\n", __func__, info->numberParameters);
+
+	kfree(temp_buf);
+
+unlock:
+	mutex_unlock(&info->diag_cmd_lock);
+out:
+	return retval;
+}
+
+static ssize_t stm_fts_cmd_read(struct file *fp, struct kobject *kobj,
+				struct bin_attribute *battr, char *buf,
+				loff_t offset, size_t count)
+{
+	int res, j, doClean = 0, index = 0;
+	int size = (6 * 2) + 1;
+	int nodes = 0;
+	int init_type = SPECIAL_PANEL_INIT;
+	u8 *all_strbuff;
+	struct device *dev = kobj_to_dev(kobj);
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	const char *limits_file = info->board->limits_name;
+	char *label[2];
+
+	MutualSenseData compData;
+	SelfSenseData comData;
+	MutualSenseFrame frameMS;
+	SelfSenseFrame frameSS;
+	u16 ito_max_val[2] = {0x00};
+
+	u8 report = 0;
+
+	if (offset > 0)
+		goto offset_reading;
+
+	if (info->stm_fts_cmd_buff) {
+		memset(info->stm_fts_cmd_buff, 0, MAX_RAWDATA_STR_SIZE);
+		dev_warn(dev, "info->stm_fts_cmd_buff existed.\n");
+	} else {
+		info->stm_fts_cmd_buff = (u8 *)kmalloc(MAX_RAWDATA_STR_SIZE,
+						       GFP_KERNEL);
+	}
+	all_strbuff = info->stm_fts_cmd_buff;
+
+	if (!info) {
+		dev_err(dev, "%s: Unable to access driver data\n", __func__);
+		return  -EINVAL;
+	}
+
+	if (!mutex_trylock(&info->diag_cmd_lock)) {
+		dev_err(dev, "%s: Blocking concurrent access\n", __func__);
+		return -EBUSY;
+	}
+
+	if (fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, true) < 0) {
+		res = ERROR_BUS_WR;
+		dev_err(dev, "%s: bus is not accessible.\n", __func__);
+		scnprintf(buf, PAGE_SIZE, "{ %08X }\n", res);
+		fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+		mutex_unlock(&info->diag_cmd_lock);
+		return 0;
+	}
+
+	if (info->numberParameters >= 1) {
+		res = fts_enableInterrupt(info, false);
+		if (res < 0) {
+			dev_err(dev, "fts_enableInterrupt: ERROR %08X\n", res);
+			res = (res | ERROR_DISABLE_INTER);
+			goto END;
+		}
+
+		switch (info->typeOfCommand[0]) {
+		/*ITO TEST*/
+		case 0x01:
+			frameMS.node_data = NULL;
+			res = production_test_ito(info, limits_file,
+						  &frameMS, ito_max_val);
+			/* report MS raw frame only if was successfully
+			 * acquired */
+			if (frameMS.node_data != NULL) {
+				size += (frameMS.node_data_size *
+						sizeof(short) + 2) * 2;
+				report = 1;
+			}
+			break;
+
+		/*PRODUCTION TEST*/
+		case 0x02:
+			if (info->systemInfo.u8_cfgAfeVer !=
+				info->systemInfo.u8_cxAfeVer) {
+				res = ERROR_OP_NOT_ALLOW;
+				dev_err(dev, "Miss match in CX version! MP test not allowed with wrong CX memory! ERROR %08X\n",
+					res);
+				break;
+			}
+			res = production_test_initialization(info, init_type);
+			break;
+
+		case 0x00:
+#ifndef COMPUTE_INIT_METHOD
+			if (info->systemInfo.u8_cfgAfeVer !=
+				info->systemInfo.u8_cxAfeVer) {
+				res = ERROR_OP_NOT_ALLOW;
+				dev_err(dev, "Miss match in CX version! MP test not allowed with wrong CX memory! ERROR %08X\n",
+					res);
+				break;
+			}
+#else
+			if (info->systemInfo.u8_mpFlag != MP_FLAG_FACTORY) {
+				init_type = SPECIAL_FULL_PANEL_INIT;
+				dev_info(dev, "Select Full Panel Init!\n");
+			} else {
+				init_type = NO_INIT;
+				dev_info(dev, "Skip Full Panel Init!\n");
+			}
+#endif
+			res = production_test_main(info, limits_file, 1,
+						   init_type, MP_FLAG_FACTORY);
+			break;
+
+		/*read mutual raw*/
+		case 0x13:
+			dev_info(dev, "Get 1 MS Frame\n");
+			if (info->numberParameters >= 2 &&
+				info->typeOfCommand[1] == LOCKED_LP_ACTIVE)
+				setScanMode(info, SCAN_MODE_LOCKED, LOCKED_LP_ACTIVE);
+			else
+				setScanMode(info, SCAN_MODE_LOCKED, LOCKED_ACTIVE);
+			msleep(WAIT_FOR_FRESH_FRAMES);
+			/* Skip sensing off when typeOfCommand[2]=0x01
+			 * to avoid sense on force cal after reading raw data
+			 */
+			if (!(info->numberParameters >= 3 &&
+				info->typeOfCommand[2] == 0x01)) {
+				setScanMode(info, SCAN_MODE_ACTIVE, 0x00);
+				msleep(WAIT_AFTER_SENSEOFF);
+				/* Delete the events related to some touch
+				 * (allow to call this function while touching
+				 * the screen without having a flooding of the
+				 * FIFO)
+				 */
+				flushFIFO(info);
+			}
+#ifdef READ_FILTERED_RAW
+			res = getMSFrame3(info, MS_FILTER, &frameMS);
+#else
+			res = getMSFrame3(info, MS_RAW, &frameMS);
+#endif
+			if (res < 0) {
+				dev_err(dev, "Error while taking the MS frame... ERROR %08X\n",
+					res);
+			} else {
+				dev_info(dev, "The frame size is %d words\n",
+					res);
+#ifdef RAW_DATA_FORMAT_DEC
+				size += 3 * 2 +
+				    (7 * frameMS.header.sense_node + 1)
+				    * frameMS.header.force_node;
+#else
+				size += (res * sizeof(short) + 2) * 2;
+#endif
+				/* set res to OK because if getMSFrame is
+				 * successful res = number of words read
+				 */
+				res = OK;
+				if (info->typeOfCommand[1] == LOCKED_ACTIVE)
+					label[0] = "CmRaw =";
+				else if (info->typeOfCommand[1] ==
+					 LOCKED_LP_ACTIVE)
+					label[0] = "CmRaw_LP =";
+				else
+					label[0] = "MS Frame =";
+				print_frame_short(info,
+					label[0],
+					array1dTo2d_short(
+					frameMS.node_data,
+					frameMS.node_data_size,
+					frameMS.header.sense_node),
+					frameMS.header.force_node,
+					frameMS.header.sense_node);
+			}
+			break;
+		/*read self raw*/
+		case 0x15:
+			dev_info(dev, "Get 1 SS Frame\n");
+			if (info->numberParameters >= 2 &&
+				info->typeOfCommand[1] == LOCKED_LP_DETECT)
+				setScanMode(info, SCAN_MODE_LOCKED, LOCKED_LP_DETECT);
+			else
+				setScanMode(info, SCAN_MODE_LOCKED, LOCKED_ACTIVE);
+			msleep(WAIT_FOR_FRESH_FRAMES);
+			/* Skip sensing off when typeOfCommand[2]=0x01
+			 * to avoid sense on force cal after reading raw data
+			 */
+			if (!(info->numberParameters >= 3 &&
+				info->typeOfCommand[2] == 0x01)) {
+				setScanMode(info, SCAN_MODE_ACTIVE, 0x00);
+				msleep(WAIT_AFTER_SENSEOFF);
+				flushFIFO(info);
+				/* delete the events related to some touch
+				 * (allow to call this function while touching
+				 * the screen without having a flooding of the
+				 * FIFO)
+				 */
+			}
+			if (info->numberParameters >= 2 &&
+				info->typeOfCommand[1] == LOCKED_LP_DETECT)
+#ifdef READ_FILTERED_RAW
+				res = getSSFrame3(info, SS_DETECT_FILTER,
+						  &frameSS);
+#else
+				res = getSSFrame3(info, SS_DETECT_RAW,
+						  &frameSS);
+#endif
+			else
+#ifdef READ_FILTERED_RAW
+				res = getSSFrame3(info, SS_FILTER, &frameSS);
+#else
+				res = getSSFrame3(info, SS_RAW, &frameSS);
+#endif
+			if (res < OK) {
+				dev_err(dev, "Error while taking the SS frame... ERROR %08X\n",
+					res);
+			} else {
+				dev_info(dev, "The frame size is %d words\n", res);
+#ifdef RAW_DATA_FORMAT_DEC
+				size += 3 * 2 + 5 +
+					(frameSS.header.sense_node +
+					 frameSS.header.force_node) * 7;
+#else
+				size += (res * sizeof(short) + 2) * 2;
+#endif
+				/* set res to OK because if getMSFrame is
+				 * successful res = number of words read
+				 */
+				res = OK;
+				if (info->typeOfCommand[1] == LOCKED_ACTIVE) {
+					label[0] = "CsRaw_Tx =";
+					label[1] = "CsRaw_Rx =";
+				} else if (info->typeOfCommand[1] ==
+					   LOCKED_LP_DETECT) {
+					label[0] = "CsRaw_Tx_LP =";
+					label[1] = "CsRaw_Rx_LP =";
+				} else {
+					label[0] = "SS force frame =";
+					label[1] = "SS sense frame =";
+				}
+				print_frame_short(info,
+					label[0],
+					array1dTo2d_short(
+					frameSS.force_data,
+					frameSS.header.force_node,
+					frameSS.header.force_node),
+					1, frameSS.header.force_node);
+				print_frame_short(info,
+					label[1],
+					array1dTo2d_short(
+					frameSS.sense_data,
+					frameSS.header.sense_node,
+					frameSS.header.sense_node),
+					1, frameSS.header.sense_node);
+			}
+			break;
+
+		case 0x14:	/* read mutual comp data */
+			dev_info(dev, "Get MS Compensation Data\n");
+			res = readMutualSenseCompensationData(info,
+							      LOAD_CX_MS_TOUCH,
+							      &compData);
+
+			if (res < 0)
+				dev_err(dev, "Error reading MS compensation data ERROR %08X\n",
+					res);
+			else {
+				dev_info(dev, "MS Compensation Data Reading Finished!\n");
+				size += ((compData.node_data_size + 3) *
+					 sizeof(u8)) * 2;
+				print_frame_i8(info, "MS Data (Cx2) =",
+					       array1dTo2d_i8(
+						       compData.node_data,
+						       compData.
+						       node_data_size,
+						       compData.header.
+						       sense_node),
+					       compData.header.force_node,
+					       compData.header.sense_node);
+			}
+			break;
+
+		case 0x16:	/* read self comp data */
+			dev_info(dev, "Get SS Compensation Data...\n");
+			res = readSelfSenseCompensationData(info,
+							    LOAD_CX_SS_TOUCH,
+							    &comData);
+			if (res < 0)
+				dev_err(dev, "Error reading SS compensation data ERROR %08X\n",
+					res);
+			else {
+				dev_info(dev, "SS Compensation Data Reading Finished!\n");
+				size += ((comData.header.force_node +
+					  comData.header.sense_node) * 2 + 8) *
+					sizeof(u8) * 2;
+				print_frame_u8(info, "SS Data Ix2_fm = ",
+					       array1dTo2d_u8(comData.ix2_fm,
+							      comData.header.
+							      force_node, 1),
+					       comData.header.force_node, 1);
+				print_frame_i8(info, "SS Data Cx2_fm = ",
+					       array1dTo2d_i8(comData.cx2_fm,
+							      comData.header.
+							      force_node, 1),
+					       comData.header.force_node, 1);
+				print_frame_u8(info, "SS Data Ix2_sn = ",
+					       array1dTo2d_u8(comData.ix2_sn,
+							      comData.header.
+							      sense_node,
+							      comData.header.
+							      sense_node), 1,
+					       comData.header.sense_node);
+				print_frame_i8(info, "SS Data Cx2_sn = ",
+					       array1dTo2d_i8(comData.cx2_sn,
+							      comData.header.
+							      sense_node,
+							      comData.header.
+							      sense_node), 1,
+					       comData.header.sense_node);
+			}
+			break;
+		case 0x17:	/* Read mutual strength */
+			dev_info(dev, "Get 1 MS Strength\n");
+			/* Skip sensing off when typeOfCommand[1]=0x01
+			 * to avoid sense on force cal after reading raw data
+			 */
+			if (!(info->numberParameters >= 2 &&
+				info->typeOfCommand[1] == 0x01)) {
+				setScanMode(info, SCAN_MODE_ACTIVE, 0xFF);
+				msleep(WAIT_FOR_FRESH_FRAMES);
+				setScanMode(info, SCAN_MODE_ACTIVE, 0x00);
+				msleep(WAIT_AFTER_SENSEOFF);
+				/* Flush outstanding touch events */
+				flushFIFO(info);
+			}
+			nodes = getMSFrame3(info, MS_STRENGTH, &frameMS);
+			if (nodes < 0) {
+				res = nodes;
+				dev_err(dev, "Error while taking the MS strength... ERROR %08X\n",
+					res);
+			} else {
+				dev_info(dev, "The frame size is %d words\n", nodes);
+#ifdef RAW_DATA_FORMAT_DEC
+				size += 3 * 2 +
+				    (7 * frameMS.header.sense_node + 1)
+				    * frameMS.header.force_node;
+#else
+				size += (nodes * sizeof(short) + 2) * 2;
+#endif
+				print_frame_short(info, "MS strength =",
+				    array1dTo2d_short(frameMS.node_data,
+						frameMS.node_data_size,
+						frameMS.header.sense_node),
+				    frameMS.header.force_node,
+				    frameMS.header.sense_node);
+				res = OK;
+			}
+			break;
+		case 0x03:	/* MS Raw DATA TEST */
+			res = fts_system_reset(info);
+			if (res >= OK)
+				res = production_test_ms_raw(info,
+							     limits_file, 1);
+			break;
+
+		case 0x04:	/* MS CX DATA TEST */
+			res = fts_system_reset(info);
+			if (res >= OK)
+				res = production_test_ms_cx(info,
+							    limits_file, 1);
+			break;
+
+		case 0x05:	/* SS RAW DATA TEST */
+			res = fts_system_reset(info);
+			if (res >= OK)
+				res = production_test_ss_raw(info,
+							     limits_file, 1);
+			break;
+
+		case 0x06:	/* SS IX CX DATA TEST */
+			res = fts_system_reset(info);
+			if (res >= OK)
+				res = production_test_ss_ix_cx(info,
+							       limits_file, 1);
+			break;
+
+
+		case 0xF0:
+		case 0xF1:	/* TOUCH ENABLE/DISABLE */
+			doClean = (int)(info->typeOfCommand[0] & 0x01);
+			res = cleanUp(info, doClean);
+			break;
+
+		default:
+			dev_err(dev, "COMMAND NOT VALID!! Insert a proper value ...\n");
+			res = ERROR_OP_NOT_ALLOW;
+			break;
+		}
+
+		doClean = fts_mode_handler(info, 1);
+		if (info->typeOfCommand[0] != 0xF0)
+			doClean |= fts_enableInterrupt(info, true);
+		if (doClean < 0)
+			dev_err(dev, "%s: ERROR %08X\n", __func__,
+				 (doClean | ERROR_ENABLE_INTER));
+	} else {
+		dev_err(dev, "NO COMMAND SPECIFIED!!! do: 'echo [cmd_code] [args] > stm_fts_cmd' before looking for result!\n");
+		res = ERROR_OP_NOT_ALLOW;
+	}
+
+END:
+	/* here start the reporting phase, assembling the data
+	  * to send in the file node */
+	size = MAX_RAWDATA_STR_SIZE;
+	index = 0;
+	index += scnprintf(all_strbuff + index, size - index, "{ %08X", res);
+
+	if (res >= OK || report) {
+		/*all the other cases are already fine printing only the res.*/
+		switch (info->typeOfCommand[0]) {
+		case 0x01:
+		case 0x13:
+		case 0x17:
+
+			if (frameMS.node_data == NULL)
+				break;
+
+#ifdef RAW_DATA_FORMAT_DEC
+			index += scnprintf(all_strbuff + index, size - index,
+					   "%3d",
+					   (u8)frameMS.header.force_node);
+			index += scnprintf(all_strbuff + index, size - index,
+					   "%3d",
+					   (u8)frameMS.header.sense_node);
+			if (info->typeOfCommand[0] == 0x01) {
+				index += scnprintf(all_strbuff + index,
+						size - index, " %d ",
+						ito_max_val[0]);
+				index += scnprintf(all_strbuff + index,
+						size - index, "%d ",
+						ito_max_val[1]);
+			}
+#else
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   (u8)frameMS.header.force_node);
+
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   (u8)frameMS.header.sense_node);
+			if (info->typeOfCommand[0] == 0x01) {
+				index += scnprintf(all_strbuff + index,
+						size - index,
+						"%02X%02X",
+						(ito_max_val[0] & 0xFF00) >> 8,
+						ito_max_val[0] & 0xFF);
+
+				index += scnprintf(all_strbuff + index,
+						size - index,
+						"%02X%02X",
+						(ito_max_val[1] & 0xFF00) >> 8,
+						ito_max_val[1] & 0xFF);
+			}
+#endif
+
+			for (j = 0; j < frameMS.node_data_size; j++) {
+#ifdef RAW_DATA_FORMAT_DEC
+				if (j % frameMS.header.sense_node == 0)
+					index += scnprintf(all_strbuff + index,
+							   size - index, "\n");
+				index += scnprintf(all_strbuff + index,
+						   size - index, "%d ",
+						   frameMS.node_data[j]);
+#else
+				index += scnprintf(all_strbuff + index,
+					   size - index,
+					   "%02X%02X",
+					   (frameMS.node_data[j] & 0xFF00) >> 8,
+					   frameMS.node_data[j] & 0xFF);
+#endif
+			}
+
+			kfree(frameMS.node_data);
+			break;
+
+		case 0x15:
+#ifdef RAW_DATA_FORMAT_DEC
+			index += scnprintf(all_strbuff + index, size - index,
+					   "%3d",
+					   (u8)frameSS.header.force_node);
+			index += scnprintf(all_strbuff + index, size - index,
+					   "%3d",
+					   (u8)frameSS.header.sense_node);
+			index += scnprintf(all_strbuff + index, size - index,
+					   "\n");
+#else
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   (u8)frameSS.header.force_node);
+
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   (u8)frameSS.header.sense_node);
+#endif
+
+			/* Copying self raw data Force */
+			for (j = 0; j < frameSS.header.force_node; j++) {
+#ifdef RAW_DATA_FORMAT_DEC
+				index += scnprintf(all_strbuff + index,
+						   size - index,
+						   "%d ",
+						   frameSS.force_data[j]);
+#else
+				index += scnprintf(all_strbuff + index,
+					  size - index,
+					  "%02X%02X",
+					  (frameSS.force_data[j] & 0xFF00) >> 8,
+					  frameSS.force_data[j] & 0xFF);
+#endif
+			}
+
+
+
+#ifdef RAW_DATA_FORMAT_DEC
+			index += scnprintf(all_strbuff + index, size - index,
+					   "\n");
+#endif
+
+			/* Copying self raw data Sense */
+			for (j = 0; j < frameSS.header.sense_node; j++) {
+#ifdef RAW_DATA_FORMAT_DEC
+				index += scnprintf(all_strbuff + index,
+						   size - index, "%d ",
+						   frameSS.sense_data[j]);
+#else
+				index += scnprintf(all_strbuff + index,
+					  size - index,
+					  "%02X%02X",
+					  (frameSS.sense_data[j] & 0xFF00) >> 8,
+					  frameSS.sense_data[j] & 0xFF);
+#endif
+			}
+
+			kfree(frameSS.force_data);
+			kfree(frameSS.sense_data);
+			break;
+
+		case 0x14:
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   (u8)compData.header.force_node);
+
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   (u8)compData.header.sense_node);
+
+			/* Cpying CX1 value */
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   (compData.cx1) & 0xFF);
+
+			/* Copying CX2 values */
+			for (j = 0; j < compData.node_data_size; j++) {
+				index += scnprintf(all_strbuff + index,
+						size - index,
+						"%02X",
+						(compData.node_data[j]) & 0xFF);
+			}
+
+			kfree(compData.node_data);
+			break;
+
+		case 0x16:
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   comData.header.force_node);
+
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   comData.header.sense_node);
+
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   (comData.f_ix1) & 0xFF);
+
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   (comData.s_ix1) & 0xFF);
+
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   (comData.f_cx1) & 0xFF);
+
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   (comData.s_cx1) & 0xFF);
+
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   (comData.f_ix0) & 0xFF);
+
+			index += scnprintf(all_strbuff + index,
+					   size - index, "%02X",
+					   (comData.s_ix0) & 0xFF);
+
+			/* Copying IX2 Force */
+			for (j = 0; j < comData.header.force_node; j++) {
+				index += scnprintf(all_strbuff + index,
+						   size - index,
+						   "%02X",
+						   comData.ix2_fm[j] & 0xFF);
+			}
+
+			/* Copying IX2 Sense */
+			for (j = 0; j < comData.header.sense_node; j++) {
+				index += scnprintf(all_strbuff + index,
+						   size - index,
+						   "%02X",
+						   comData.ix2_sn[j] & 0xFF);
+			}
+
+			/* Copying CX2 Force */
+			for (j = 0; j < comData.header.force_node; j++) {
+				index += scnprintf(all_strbuff + index,
+						   size - index,
+						   "%02X",
+						   comData.cx2_fm[j] & 0xFF);
+			}
+
+			/* Copying CX2 Sense */
+			for (j = 0; j < comData.header.sense_node; j++) {
+				index += scnprintf(all_strbuff + index,
+						   size - index,
+						   "%02X",
+						   comData.cx2_sn[j] & 0xFF);
+			}
+
+			kfree(comData.ix2_fm);
+			kfree(comData.ix2_sn);
+			kfree(comData.cx2_fm);
+			kfree(comData.cx2_sn);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	index += scnprintf(all_strbuff + index, size - index, " }\n");
+	info->numberParameters = 0;
+	/* need to reset the number of parameters in order to wait the
+	 * next command, comment if you want to repeat the last command sent
+	 * just doing a cat */
+	/* dev_err(dev, "numberParameters = %d\n", info->numberParameters); */
+
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+	mutex_unlock(&info->diag_cmd_lock);
+
+	info->stm_fts_cmd_buff_len = index;
+
+offset_reading:
+	if (info->stm_fts_cmd_buff_len == 0) {
+		kfree(info->stm_fts_cmd_buff);
+		info->stm_fts_cmd_buff = NULL;
+		return 0;
+	} else if (info->stm_fts_cmd_buff_len > PAGE_SIZE) {
+		index = PAGE_SIZE;
+	} else {
+		index = info->stm_fts_cmd_buff_len;
+	}
+	dev_info(dev, "%s: remaining length: %lld, offset: %lld.\n", __func__,
+		info->stm_fts_cmd_buff_len, offset);
+
+	memcpy(buf, info->stm_fts_cmd_buff + offset, index);
+	info->stm_fts_cmd_buff_len = info->stm_fts_cmd_buff_len - index;
+
+	return index;
+}
+
+static ssize_t autotune_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	int ret = 0;
+	bool val = false;
+
+	if ((kstrtobool(buf, &val) < 0) || !val) {
+		ret = -EINVAL;
+		goto err_args;
+	}
+
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, true);
+
+	ret = production_test_main(info, info->board->limits_name, 1,
+				   SPECIAL_FULL_PANEL_INIT, MP_FLAG_BOOT);
+
+	cleanUp(info, true);
+
+	info->autotune_stat = ret;
+
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+
+err_args:
+
+	return ret < 0 ? ret : count;
+}
+
+static ssize_t autotune_show(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "{ %08X }\n", info->autotune_stat);
+}
+
+static ssize_t infoblock_getdata_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	int count = 0;
+	int res = 0;
+	u8 control_reg = 0;
+	u8 flash_status = 0;
+	u8 *data = NULL;
+	int addr = 0;
+	int i = 0;
+
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, true);
+
+	res = fts_writeReadU8UX(info, FTS_CMD_HW_REG_R, ADDR_SIZE_HW_REG,
+				ADDR_FLASH_STATUS, &control_reg,
+				1, DUMMY_HW_REG);
+
+	if (res < OK) {
+		count += scnprintf(&buf[count], PAGE_SIZE - count,
+				   "ADDR_FLASH_STATUS read failed\n");
+		goto END;
+	}
+	flash_status = (control_reg & 0xFC);
+
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "The value:0x%X 0x%X\n", control_reg, flash_status);
+
+	res = fts_writeU8UX(info, FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG,
+			    ADDR_FLASH_STATUS, &flash_status, 1);
+	if (res < OK) {
+		count += scnprintf(&buf[count], PAGE_SIZE - count,
+				   "ADDR_FLASH_STATUS write failed\n");
+		goto END;
+	}
+	data = kmalloc(INFO_BLOCK_SIZE * sizeof(u8), GFP_KERNEL);
+	if (data == NULL) {
+		count += scnprintf(&buf[count], PAGE_SIZE - count,
+				   "kmalloc failed\n");
+		goto END;
+	}
+	res = fts_writeReadU8UX(info, FTS_CMD_HW_REG_R, ADDR_SIZE_HW_REG,
+				ADDR_INFOBLOCK, data, INFO_BLOCK_SIZE,
+				DUMMY_HW_REG);
+	if (res < OK) {
+		count += scnprintf(&buf[count], PAGE_SIZE - count,
+				   "ADDR_INFOBLOCK read failed\n");
+		goto END;
+	}
+	addr = INFO_BLOCK_LOCKDOWN;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "Lock down info the first 4bytes:0X%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "Lock down info the second 4bytes:0X%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	count += scnprintf(&buf[count], PAGE_SIZE - count, "0x%04X\n", addr);
+	addr = INFO_BLOCK_AOFFSET;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "Aoffset magic number:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "Aoffset crc:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "Aoffset ~crcr:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "Aoffset len:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "Aoffset ~len:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "Aoffset ver:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count, "0x%04X\n", addr);
+	for (i = 0; i < 38; i++) {
+		count += scnprintf(&buf[count], PAGE_SIZE - count,
+				   "Aoffset CH[%d] Quar:0X%02X,Half:0X%02X,Full:0X%02X%02X\n",
+				   i, data[addr+3], data[addr+2], data[addr+1],
+				   data[addr]);
+		addr += 4;
+	}
+	count += scnprintf(&buf[count], PAGE_SIZE - count, "0x%04X\n", addr);
+	for (i = 0; i < 4; i++) {
+		count += scnprintf(&buf[count], PAGE_SIZE - count,
+				   "Aoffset CA[%d] Quar:0X%02X,Half:0X%02X,Full:0X%02X%02X\n",
+				   i, data[addr+3], data[addr+2], data[addr+1],
+				   data[addr]);
+		addr += 4;
+	}
+	addr = INFO_BLOCK_OSC;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "OscTrim magic number:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "OscTrim crc:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "OscTrim len:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "OscTrim ~crcr:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "OscTrim ~len:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "OscTrim ver:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "OscTrim major ver:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "OscTrim cen bg:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "OscTrim frequency bg:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "OscTrim frequency afe:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "OscTrim cen bg valid:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+	addr += 4;
+	count += scnprintf(&buf[count], PAGE_SIZE - count,
+			   "OscTrim cen afe valid:0x%02X%02X%02X%02X\n",
+			   data[addr+3], data[addr+2], data[addr+1],
+			   data[addr]);
+
+END:
+	kfree(data);
+
+	if (control_reg != flash_status)
+		fts_writeU8UX(info, FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG,
+			      ADDR_FLASH_STATUS, &control_reg, 1);
+
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+
+	return count;
+}
+
+/* sysfs file node to store heatmap mode
+ * "echo cmd > heatmap_mode" to change
+ * Possible commands:
+ * 0 = FTS_HEATMAP_OFF
+ * 1 = FTS_HEATMAP_PARTIAL
+ * 2 = FTS_HEATMAP_FULL
+ */
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+static ssize_t heatmap_mode_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+	int result;
+	int val;
+
+	result = kstrtoint(buf, 10, &val);
+	if (result < 0 || val < FTS_HEATMAP_OFF || val > FTS_HEATMAP_FULL) {
+		dev_err(dev, "%s: Invalid input.\n", __func__);
+		return -EINVAL;
+	}
+
+	info->heatmap_mode = val;
+	return count;
+}
+
+static ssize_t heatmap_mode_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n",
+			 info->heatmap_mode);
+}
+#endif
+
+static DEVICE_ATTR_RO(infoblock_getdata);
+static DEVICE_ATTR_RW(fwupdate);
+static DEVICE_ATTR_RO(appid);
+static DEVICE_ATTR_RO(mode_active);
+static DEVICE_ATTR_RO(fw_file_test);
+static DEVICE_ATTR_RO(status);
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+static DEVICE_ATTR_RW(heatmap_mode);
+#endif
+#ifdef USE_ONE_FILE_NODE
+static DEVICE_ATTR_RW(feature_enable);
+#else
+
+
+#ifdef GRIP_MODE
+static DEVICE_ATTR_RW(grip_mode);
+#endif
+
+#ifdef CHARGER_MODE
+static DEVICE_ATTR_RW(charger_mode);
+#endif
+
+#ifdef GLOVE_MODE
+static DEVICE_ATTR_RW(glove_mode);
+#endif
+
+#ifdef COVER_MODE
+static DEVICE_ATTR_RW(cover_mode);
+#endif
+
+#ifdef STYLUS_MODE
+static DEVICE_ATTR_RW(stylus_mode);
+#endif
+
+#endif
+
+#ifdef GESTURE_MODE
+static DEVICE_ATTR_RW(gesture_mask);
+static DEVICE_ATTR_RO(gesture_coordinates);
+#endif
+static DEVICE_ATTR_RW(autotune);
+
+static DEVICE_ATTR_RW(touchsim);
+
+static DEVICE_ATTR_RW(default_mf);
+
+static BIN_ATTR_RW(stm_fts_cmd, 0);
+
+static struct bin_attribute *fts_bin_attr_group[] = {
+	&bin_attr_stm_fts_cmd,
+	NULL,
+};
+
+static struct attribute *fts_attr_group[] = {
+	 &dev_attr_infoblock_getdata.attr,
+	&dev_attr_fwupdate.attr,
+	&dev_attr_appid.attr,
+	&dev_attr_mode_active.attr,
+	&dev_attr_fw_file_test.attr,
+	&dev_attr_status.attr,
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	&dev_attr_heatmap_mode.attr,
+#endif
+#ifdef USE_ONE_FILE_NODE
+	&dev_attr_feature_enable.attr,
+#else
+
+#ifdef GRIP_MODE
+	&dev_attr_grip_mode.attr,
+#endif
+#ifdef CHARGER_MODE
+	&dev_attr_charger_mode.attr,
+#endif
+#ifdef GLOVE_MODE
+	&dev_attr_glove_mode.attr,
+#endif
+#ifdef COVER_MODE
+	&dev_attr_cover_mode.attr,
+#endif
+#ifdef STYLUS_MODE
+	&dev_attr_stylus_mode.attr,
+#endif
+
+#endif
+
+#ifdef GESTURE_MODE
+	&dev_attr_gesture_mask.attr,
+	&dev_attr_gesture_coordinates.attr,
+#endif
+	&dev_attr_autotune.attr,
+	&dev_attr_touchsim.attr,
+	&dev_attr_default_mf.attr,
+	NULL,
+};
+/** @}*/
+/** @}*/
+
+
+/**
+  * @defgroup isr Interrupt Service Routine (Event Handler)
+  * The most important part of the driver is the ISR (Interrupt Service Routine)
+  * called also as Event Handler \n
+  * As soon as the interrupt pin goes low, fts_interrupt_handler() is called and
+  * the chain to read and parse the event read from the FIFO start.\n
+  * For any different kind of EVT_ID there is a specific event handler
+  * which will take the correct action to report the proper info to the host. \n
+  * The most important events are the one related to touch information, status
+  * update or user report.
+  * @{
+  */
+
+/**
+  * Report to the linux input system the pressure and release of a button
+  * handling concurrency
+  * @param info pointer to fts_ts_info which contains info about the device
+  * and its hw setup
+  * @param key_code	button value
+  */
+void fts_input_report_key(struct fts_ts_info *info, int key_code)
+{
+	mutex_lock(&info->input_report_mutex);
+	input_report_key(info->input_dev, key_code, 1);
+	input_sync(info->input_dev);
+	input_report_key(info->input_dev, key_code, 0);
+	input_sync(info->input_dev);
+	mutex_unlock(&info->input_report_mutex);
+}
+
+/**
+  * Palm data dump work function which perform capture the MS raw, strength,
+  * current scan mode and touch count.
+  */
+static void fts_palm_data_dump_work(struct work_struct *work)
+{
+	struct delayed_work *dwork = container_of(work, struct delayed_work,
+						  work);
+	struct fts_ts_info *info = container_of(dwork, struct fts_ts_info,
+						palm_data_dump_work);
+	const MSFrameType ms_type[] =
+#ifdef READ_FILTERED_RAW
+		{ MS_FILTER, MS_STRENGTH };
+#else
+		{ MS_RAW, MS_STRENGTH };
+#endif
+	const SSFrameType ss_type[] =
+#ifdef READ_FILTERED_RAW
+		{ SS_FILTER, SS_STRENGTH };
+#else
+		{ SS_RAW, SS_STRENGTH };
+#endif
+	char *ms_tag[] = { "MS raw", "MS strength" };
+	char *ss_tag[] = { "SS raw", "SS strength" };
+	MutualSenseFrame frameMS;
+	SelfSenseFrame frameSS;
+	int i, ret;
+
+	// Dump heatmap
+	for (i = 0; i < ARRAY_SIZE(ms_type); i++) {
+		ret = getMSFrame3(info, ms_type[i], &frameMS);
+		if (ret < 0) {
+			dev_err(info->dev,
+				"Error while taking the %s... ERROR %08X\n",
+				ms_tag[i], ret);
+		} else {
+			print_frame_short(info, ms_tag[i],
+				array1dTo2d_short(frameMS.node_data,
+					frameMS.node_data_size,
+					frameMS.header.sense_node),
+				frameMS.header.force_node,
+				frameMS.header.sense_node);
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ss_type); i++) {
+		ret = getSSFrame3(info, ss_type[i], &frameSS);
+		if (ret < 0) {
+			dev_err(info->dev,
+				"Error while taking the %s... ERROR %08X\n",
+				ss_tag[i], ret);
+		} else {
+			dev_info(info->dev, "%s\n", ss_tag[i]);
+			print_frame_short(info, "SS force",
+				array1dTo2d_short(
+					frameSS.force_data,
+					frameSS.header.force_node,
+					frameSS.header.force_node),
+				1, frameSS.header.force_node);
+			print_frame_short(info, "SS sense",
+				array1dTo2d_short(
+					frameSS.sense_data,
+					frameSS.header.sense_node,
+					frameSS.header.sense_node),
+				1, frameSS.header.sense_node);
+		}
+	}
+
+	if (info->enable_palm_data_dump)
+		queue_delayed_work(info->event_wq,
+				   &info->palm_data_dump_work,
+				   msecs_to_jiffies(1000));
+}
+
+
+
+/**
+  * Event Handler for no events (EVT_ID_NOEVENT)
+  */
+static bool fts_nop_event_handler(struct fts_ts_info *info, unsigned
+				  char *event)
+{
+	dev_info(info->dev, "%s: Doing nothing for event = %02X %02X %02X %02X %02X %02X %02X %02X\n",
+		__func__, event[0], event[1], event[2], event[3],
+		event[4],
+		event[5], event[6], event[7]);
+	return false;
+}
+
+/**
+  * Event handler for enter and motion events (EVT_ID_ENTER_POINT,
+  * EVT_ID_MOTION_POINT )
+  * report touch coordinates and additional information
+  * to the linux input system
+  */
+static bool fts_enter_pointer_event_handler(struct fts_ts_info *info, unsigned
+					    char *event)
+{
+	unsigned char touchId;
+	unsigned int touch_condition = 1, tool = MT_TOOL_FINGER;
+	int x, y, z, major, minor, distance;
+	u8 touchType;
+
+	if (!info->resume_bit)
+		goto no_report;
+
+	mutex_lock(&info->input_report_mutex);
+
+	touchType = event[1] & 0x0F;
+	touchId = (event[1] & 0xF0) >> 4;
+	if (touchId >= TOUCH_ID_MAX) {
+		mutex_unlock(&info->input_report_mutex);
+		dev_err(info->dev, "%s : Invalid touch ID = %d ! No Report...\n",
+			__func__, touchId);
+		goto no_report;
+	}
+
+	x = (((int)event[3] & 0x0F) << 8) | (event[2]);
+	y = ((int)event[4] << 4) | ((event[3] & 0xF0) >> 4);
+	z = (int)event[5];
+	if (z <= 0) {
+		/* Should not happen, because zero pressure implies contact has
+		 * left, so this function should not be invoked. For safety, to
+		 * prevent this touch from being dropped, set to smallest
+		 * pressure value instead
+		 */
+#ifndef SKIP_PRESSURE
+		dev_err(info->dev, "%s: Pressure is %i, but pointer is not leaving.\n",
+		       __func__, z);
+#endif
+		z = 1; /* smallest non-zero pressure value */
+	}
+	major = (int)((((event[0] & 0x0C) << 2) | ((event[6] & 0xF0) >> 4)) * AREA_SCALE);
+	minor = (int)((((event[7] & 0xC0) >> 2) | (event[6] & 0x0F)) * AREA_SCALE);
+	/* TODO: check with fw how they will report distance */
+	distance = 0;	/* if the tool is touching the display
+			  * the distance should be 0 */
+
+	if (x > info->board->x_axis_max)
+		x = info->board->x_axis_max;
+
+	if (y > info->board->y_axis_max)
+		y = info->board->y_axis_max;
+
+	switch (touchType) {
+#ifdef STYLUS_MODE
+	case TOUCH_TYPE_STYLUS:
+		dev_info(info->dev, "%s : It is a stylus!\n", __func__);
+		if (info->stylus_enabled == 1) {
+			/* if stylus_enabled is not ==1
+			  * it will be reported as normal touch */
+			tool = MT_TOOL_PEN;
+			touch_condition = 1;
+			__set_bit(touchId, &info->stylus_id);
+			break;
+		}
+#endif
+	/* TODO: customer can implement a different strategy for each kind of
+	 * touch */
+	case TOUCH_TYPE_FINGER:
+	case TOUCH_TYPE_GLOVE:
+		dev_dbg(info->dev, "%s : It is a touch type %d!\n", __func__, touchType);
+		if (info->palm_touch_mask)
+			tool = MT_TOOL_PALM;
+		else
+			tool = MT_TOOL_FINGER;
+		touch_condition = 1;
+		__set_bit(touchId, &info->touch_id);
+		__clear_bit(touchId, &info->palm_touch_mask);
+		__clear_bit(touchId, &info->grip_touch_mask);
+		break;
+	case TOUCH_TYPE_PALM:
+		dev_dbg(info->dev, "%s : It is a touch type %d!\n", __func__, touchType);
+		tool = MT_TOOL_PALM;
+		touch_condition = 1;
+		__set_bit(touchId, &info->touch_id);
+		__set_bit(touchId, &info->palm_touch_mask);
+		__clear_bit(touchId, &info->grip_touch_mask);
+		break;
+	case TOUCH_TYPE_GRIP:
+		dev_dbg(info->dev, "%s : It is a touch type %d!\n", __func__, touchType);
+		tool = MT_TOOL_PALM;
+		touch_condition = 1;
+		__set_bit(touchId, &info->touch_id);
+		__clear_bit(touchId, &info->palm_touch_mask);
+		__set_bit(touchId, &info->grip_touch_mask);
+		break;
+
+	case TOUCH_TYPE_HOVER:
+		tool = MT_TOOL_FINGER;
+		touch_condition = 0;	/* need to hover */
+		z = 0;	/* no pressure */
+		__set_bit(touchId, &info->touch_id);
+		distance = DISTANCE_MAX;/* check with fw report the hovering
+					  * distance */
+		break;
+
+	default:
+		mutex_unlock(&info->input_report_mutex);
+		dev_err(info->dev, "%s : Invalid touch type = %d ! No Report...\n",
+			__func__, touchType);
+		goto no_report;
+	}
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	info->offload.coords[touchId].x = x;
+	info->offload.coords[touchId].y = y;
+	info->offload.coords[touchId].major = major;
+	info->offload.coords[touchId].minor = minor;
+	info->offload.coords[touchId].rotation = 0; /* not supported by firmware */
+	info->offload.coords[touchId].status = COORD_STATUS_FINGER;
+
+#ifndef SKIP_PRESSURE
+	info->offload.coords[touchId].pressure = z;
+#else
+	/* Select a reasonable constant pressure */
+	info->offload.coords[touchId].pressure = 0x30;
+#endif
+
+	if (!info->offload.offload_running) {
+#endif
+
+	input_mt_slot(info->input_dev, touchId);
+	input_report_key(info->input_dev, BTN_TOUCH, touch_condition);
+	input_mt_report_slot_state(info->input_dev, tool, 1);
+	input_report_abs(info->input_dev, ABS_MT_POSITION_X, x);
+	input_report_abs(info->input_dev, ABS_MT_POSITION_Y, y);
+	input_report_abs(info->input_dev, ABS_MT_TOUCH_MAJOR, major);
+	input_report_abs(info->input_dev, ABS_MT_TOUCH_MINOR, minor);
+#ifndef SKIP_PRESSURE
+	input_report_abs(info->input_dev, ABS_MT_PRESSURE, z);
+#endif
+
+#ifndef SKIP_DISTANCE
+	input_report_abs(info->input_dev, ABS_MT_DISTANCE, distance);
+#endif
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	}
+#endif
+
+	/* dev_info(info->dev, "%s :  Event 0x%02x - ID[%d], (x, y) = (%3d, %3d)
+	 * Size = %d\n",
+	 *	__func__, *event, touchId, x, y, touchType); */
+	mutex_unlock(&info->input_report_mutex);
+
+	return true;
+no_report:
+	return false;
+}
+
+/**
+  * Event handler for leave event (EVT_ID_LEAVE_POINT )
+  * Report to the linux input system that one touch left the display
+  */
+static bool fts_leave_pointer_event_handler(struct fts_ts_info *info, unsigned
+					    char *event)
+{
+	unsigned char touchId;
+	unsigned int tool = MT_TOOL_FINGER;
+	u8 touchType;
+
+	mutex_lock(&info->input_report_mutex);
+
+	touchType = event[1] & 0x0F;
+	touchId = (event[1] & 0xF0) >> 4;
+	if (touchId >= TOUCH_ID_MAX) {
+		mutex_unlock(&info->input_report_mutex);
+		dev_err(info->dev, "%s : Invalid touch ID = %d ! No Report...\n",
+			__func__, touchId);
+		return false;
+	}
+
+	switch (touchType) {
+#ifdef STYLUS_MODE
+	case TOUCH_TYPE_STYLUS:
+		dev_info(info->dev, "%s : It is a stylus!\n", __func__);
+		if (info->stylus_enabled == 1) {
+			/* if stylus_enabled is not ==1 it will be reported as
+			 * normal touch */
+			tool = MT_TOOL_PEN;
+			__clear_bit(touchId, &info->stylus_id);
+			break;
+		}
+#endif
+
+	case TOUCH_TYPE_FINGER:
+	/* dev_info(info->dev, "%s : It is a finger!\n", __func__); */
+	case TOUCH_TYPE_GLOVE:
+	/* dev_info(info->dev, "%s : It is a glove!\n", __func__); */
+	case TOUCH_TYPE_PALM:
+	/* dev_info(info->dev, "%s : It is a palm!\n", __func__); */
+	case TOUCH_TYPE_GRIP:
+	/* dev_info(info->dev, "%s : It is a grip!\n", __func__); */
+	case TOUCH_TYPE_HOVER:
+		tool = MT_TOOL_FINGER;
+		__clear_bit(touchId, &info->touch_id);
+		__clear_bit(touchId, &info->palm_touch_mask);
+		__clear_bit(touchId, &info->grip_touch_mask);
+		break;
+
+	default:
+		mutex_unlock(&info->input_report_mutex);
+		dev_err(info->dev, "%s : Invalid touch type = %d ! No Report...\n",
+			__func__, touchType);
+		return false;
+	}
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	info->offload.coords[touchId].status = COORD_STATUS_INACTIVE;
+	if (!info->offload.offload_running) {
+#endif
+
+	input_mt_slot(info->input_dev, touchId);
+	input_report_abs(info->input_dev, ABS_MT_PRESSURE, 0);
+	input_mt_report_slot_state(info->input_dev, tool, 0);
+	input_report_abs(info->input_dev, ABS_MT_TRACKING_ID, -1);
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	}
+#endif
+
+	mutex_unlock(&info->input_report_mutex);
+
+	return true;
+}
+
+/* EventId : EVT_ID_MOTION_POINT */
+#define fts_motion_pointer_event_handler fts_enter_pointer_event_handler
+/* remap the motion event handler to the same function which handle the enter
+ * event */
+
+/**
+  * Event handler for error events (EVT_ID_ERROR)
+  * Handle unexpected error events implementing recovery strategy and
+  * restoring the sensing status that the IC had before the error occurred
+  */
+static bool fts_error_event_handler(struct fts_ts_info *info, unsigned
+				    char *event)
+{
+	int error = 0;
+
+	dev_info(info->dev, "%s: Received event %02X %02X %02X %02X %02X %02X %02X %02X\n",
+		 __func__, event[0], event[1], event[2], event[3], event[4],
+		 event[5],
+		 event[6], event[7]);
+
+	switch (event[1]) {
+	case EVT_TYPE_ERROR_ESD:/* esd */
+	{/* before reset clear all slot */
+		release_all_touches(info);
+
+		fts_chip_powercycle(info);
+
+		error = fts_system_reset(info);
+		error |= fts_mode_handler(info, 0);
+		error |= fts_enableInterrupt(info, true);
+		if (error < OK)
+			dev_err(info->dev, "%s Cannot restore the device ERROR %08X\n",
+				__func__, error);
+	}
+	break;
+	case EVT_TYPE_ERROR_HARD_FAULT:	/* hard fault */
+	case EVT_TYPE_ERROR_WATCHDOG:	/* watch dog timer */
+	{
+		dumpErrorInfo(info, NULL, 0);
+		/* before reset clear all slots */
+		release_all_touches(info);
+		error = fts_system_reset(info);
+		error |= fts_mode_handler(info, 0);
+		error |= fts_enableInterrupt(info, true);
+		if (error < OK)
+			dev_err(info->dev, "%s Cannot reset the device ERROR %08X\n",
+				__func__, error);
+	}
+	break;
+	}
+	return false;
+}
+
+/**
+  * Event handler for controller ready event (EVT_ID_CONTROLLER_READY)
+  * Handle controller events received after unexpected reset of the IC updating
+  * the resets flag and restoring the proper sensing status
+  */
+static bool fts_controller_ready_event_handler(struct fts_ts_info *info,
+					       unsigned char *event)
+{
+	int error;
+
+	dev_info(info->dev, "%s: Received event %02X %02X %02X %02X %02X %02X %02X %02X\n",
+		__func__, event[0], event[1], event[2], event[3], event[4],
+		event[5], event[6], event[7]);
+	release_all_touches(info);
+	setSystemResetedUp(info, 1);
+	setSystemResetedDown(info, 1);
+	error = fts_mode_handler(info, 0);
+	if (error < OK)
+		dev_err(info->dev, "%s Cannot restore the device status ERROR %08X\n",
+			__func__, error);
+	return false;
+}
+
+/**
+  * Event handler for status events (EVT_ID_STATUS_UPDATE)
+  * Handle status update events
+  */
+static bool fts_status_event_handler(struct fts_ts_info *info, unsigned
+				     char *event)
+{
+	u8 grid_touch_status;
+
+	switch (event[1]) {
+	case EVT_TYPE_STATUS_ECHO:
+		dev_dbg(info->dev, "%s: Echo event of command = %02X %02X %02X %02X %02X %02X\n",
+			__func__, event[2], event[3], event[4], event[5],
+			event[6], event[7]);
+		break;
+
+	case EVT_TYPE_STATUS_GPIO_CHAR_DET:
+		dev_info(info->dev, "%s: GPIO Charger Detect ="
+			" %02X %02X %02X %02X %02X %02X\n",
+			__func__, event[2], event[3], event[4], event[5],
+			event[6], event[7]);
+		break;
+
+	case EVT_TYPE_STATUS_FORCE_CAL:
+		switch (event[2]) {
+		case 0x01:
+			dev_info(info->dev, "%s: Sense on Force cal = %02X %02X"
+				" %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x02:
+			dev_info(info->dev, "%s: Host command Force cal = %02X %02X"
+				" %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x10:
+			dev_info(info->dev, "%s: Mutual frame drop Force cal = %02X %02X"
+			" %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x11:
+			dev_info(info->dev, "%s: Mutual pure raw Force cal = %02X %02X"
+			" %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x20:
+			dev_info(info->dev, "%s: Self detect negative Force cal = %02X"
+			" %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x21:
+			dev_info(info->dev, "%s: Self touch negative Force cal = %02X"
+			" %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x22:
+			dev_info(info->dev, "%s: Self detect frame flatness Force cal ="
+			" %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x23:
+			dev_info(info->dev, "%s: Self touch frame flatness Force cal ="
+			" %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x30:
+			dev_info(info->dev, "%s: Invalid mutual Force cal = %02X"
+			" %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x31:
+			dev_info(info->dev, "%s: Invalid differential mutual Force cal ="
+			" %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x32:
+			dev_info(info->dev, "%s: Invalid Self Force cal = %02X"
+			" %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x33:
+			dev_info(info->dev, "%s: Invalid Self island Force cal = %02X"
+			" %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x34:
+			dev_info(info->dev, "%s: Invalid Self force touch Force cal ="
+			" %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x35:
+			dev_info(info->dev, "%s: Mutual frame flatness Force cal ="
+			" %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		default:
+			dev_info(info->dev, "%s: Unknown force cal = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+		}
+		break;
+
+	case EVT_TYPE_STATUS_FRAME_DROP:
+			dev_info(info->dev, "%s: Frame drop = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+		break;
+
+	case EVT_TYPE_STATUS_SS_RAW_SAT:
+		if (event[2] == 1)
+			dev_info(info->dev, "%s: SS Raw Saturated = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+		else
+			dev_info(info->dev, "%s: SS Raw No more Saturated = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+		break;
+
+	case EVT_TYPE_STATUS_WATER:
+		switch (event[2]) {
+		case 0x00:
+			dev_info(info->dev, "%s: Water Mode Entry by BLD with real"
+				" raw frame = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x01:
+			dev_info(info->dev, "%s: Water Mode Entry by BLD with rom"
+				" raw frame = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x02:
+			dev_info(info->dev, "%s: Water Mode Entry by MID with real"
+				" raw frame = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x03:
+			dev_info(info->dev, "%s: Water Mode leave by BLD with real"
+				" raw frame = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x04:
+			dev_info(info->dev, "%s: Water Mode leave by BLD with rom"
+				" raw frame = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x05:
+			dev_info(info->dev, "%s: Water Mode leave by MID with real"
+				" raw frame = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		default:
+			dev_info(info->dev, "%s: Unknown water mode = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+		}
+		break;
+
+	case EVT_TYPE_STATUS_PRE_WAT_DET:
+		if (event[2] == 1)
+			dev_info(info->dev, "%s: Previous Water entry ="
+			" %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+		else
+			dev_info(info->dev, "%s: Previous Water leave ="
+				" %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+		break;
+
+	case EVT_TYPE_STATUS_NOISE:
+		if(info->scanning_frequency != event[3]) {
+			dev_info(info->dev, "%s: Scanning frequency changed from %02X to %02X\n",
+				__func__, info->scanning_frequency, event[3]);
+			dev_info(info->dev, "%s: Noise Status Event = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3],
+				event[4], event[5], event[6], event[7]);
+			info->scanning_frequency = event[3];
+		} else {
+			dev_dbg(info->dev, "%s: Noise Status Event = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+		}
+		break;
+
+	case EVT_TYPE_STATUS_STIMPAD:
+		switch (event[2]) {
+		case 0x00:
+			dev_dbg(info->dev, "%s: Stimpad disable event"
+				" = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x01:
+			dev_dbg(info->dev, "%s: Stimpad enable event"
+				" = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x02:
+			dev_dbg(info->dev, "%s: Stimpad disable by signature invalid"
+				" = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x03:
+			dev_dbg(info->dev, "%s: Stimpad disable by nodes count invalid"
+				" raw frame = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		default:
+			dev_dbg(info->dev, "%s: Unknown stimpad status = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+		}
+		break;
+
+	case EVT_TYPE_STATUS_NO_TOUCH:
+		dev_info(info->dev, "%s: No Touch Status Event = %02X %02X"
+		" %02X %02X %02X %02X\n",
+			__func__, event[2], event[3], event[4], event[5],
+			event[6], event[7]);
+		break;
+
+	case EVT_TYPE_STATUS_IDLE:
+		dev_info(info->dev, "%s: Idle Status Event = %02X %02X"
+		" %02X %02X %02X %02X\n",
+			__func__, event[2], event[3], event[4], event[5],
+			event[6], event[7]);
+		break;
+
+	case EVT_TYPE_STATUS_PALM_TOUCH:
+		switch (event[2]) {
+		case 0x01:
+			dev_info(info->dev, "%s: Palm block entry event"
+				" = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			info->enable_palm_data_dump = true;
+			queue_delayed_work(info->event_wq,
+					   &info->palm_data_dump_work,
+					   msecs_to_jiffies(3000));
+			break;
+
+		case 0x02:
+			dev_info(info->dev, "%s: Palm block release event"
+				" = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			info->enable_palm_data_dump = false;
+			cancel_delayed_work(&info->palm_data_dump_work);
+			break;
+
+		default:
+			dev_info(info->dev, "%s: Unknown palm touch status = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+		}
+		break;
+
+	case EVT_TYPE_STATUS_GRIP_TOUCH:
+		grid_touch_status = (event[2] & 0xF0) >> 4;
+		switch (grid_touch_status) {
+		case 0x01:
+			dev_info(info->dev, "%s: Grip Touch entry event"
+				" = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x02:
+			dev_info(info->dev, "%s: Grip Touch release event"
+				" = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		default:
+			dev_info(info->dev, "%s: Unknown grip touch status = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+		}
+		break;
+
+	case EVT_TYPE_STATUS_GOLDEN_RAW_VAL:
+		switch (event[2]) {
+		case 0x01:
+			dev_info(info->dev, "%s: Golden Raw Validation Pass"
+				" = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		case 0x02:
+			dev_info(info->dev, "%s: Golden Raw Validation Fail"
+				" = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+			break;
+
+		default:
+			dev_info(info->dev, "%s: Unknown golden raw validation status = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+		}
+		break;
+
+	case EVT_TYPE_STATUS_GOLDEN_RAW_ERR:
+		dev_info(info->dev, "%s: Golden Raw Data Abnormal"
+				" = %02X %02X %02X %02X %02X %02X\n",
+				__func__, event[2], event[3], event[4],
+				event[5], event[6], event[7]);
+		break;
+
+	default:
+		dev_info(info->dev, "%s: Received unknown status event = %02X %02X %02X %02X %02X %02X %02X %02X\n",
+			__func__, event[0], event[1], event[2], event[3],
+			event[4], event[5], event[6], event[7]);
+		break;
+	}
+	return false;
+}
+
+
+/* key events reported in the user report */
+#ifdef PHONE_KEY
+/* TODO: the customer should handle the events coming from the keys according
+ * his needs
+  * (this is just an sample code that report the click of a button after a
+  * press->release action) */
+/**
+  * Event handler for status events (EVT_TYPE_USER_KEY)
+  * Handle keys update events, the third byte of the event is a bitmask,
+  * if the bit set means that the corresponding key is pressed.
+  */
+static void fts_key_event_handler(struct fts_ts_info *info,
+				  unsigned char *event)
+{
+	/* int value; */
+	dev_info(info->dev, "%s: Received event %02X %02X %02X %02X %02X %02X %02X %02X\n",
+		__func__, event[0], event[1], event[2], event[3], event[4],
+		event[5], event[6], event[7]);
+
+	if (event[0] == EVT_ID_USER_REPORT && event[1] == EVT_TYPE_USER_KEY) {
+		/* event[2] contain the bitmask of the keys that are actually
+		 * pressed */
+
+		if ((event[2] & FTS_KEY_0) == 0 && (info->key_mask & FTS_KEY_0) > 0) {
+			dev_info(info->dev, "%s: Button HOME pressed and released!\n",
+				__func__);
+			fts_input_report_key(info, KEY_HOMEPAGE);
+		}
+
+		if ((event[2] & FTS_KEY_1) == 0 && (info->key_mask & FTS_KEY_1) > 0) {
+			dev_info(info->dev, "%s: Button Back pressed and released!\n",
+				__func__);
+			fts_input_report_key(info, KEY_BACK);
+		}
+
+		if ((event[2] & FTS_KEY_2) == 0 && (info->key_mask & FTS_KEY_2) > 0) {
+			dev_info(info->dev, "%s: Button Menu pressed!\n", __func__);
+			fts_input_report_key(info, KEY_MENU);
+		}
+
+		info->key_mask = event[2];
+	} else
+		dev_err(info->dev, "%s: Invalid event passed as argument!\n", __func__);
+}
+#endif
+
+/* gesture event must be handled in the user event handler */
+#ifdef GESTURE_MODE
+/* TODO: Customer should implement their own actions in respond of a gesture
+ * event.
+  * This is an example that simply print the gesture received and simulate
+  * the click on a different button for each gesture. */
+/**
+  * Event handler for gesture events (EVT_TYPE_USER_GESTURE)
+  * Handle gesture events and simulate the click on a different button
+  * for any gesture detected (@link gesture_opt Gesture IDs @endlink)
+  */
+static void fts_gesture_event_handler(struct fts_ts_info *info, unsigned
+				      char *event)
+{
+	int value;
+	int needCoords = 0;
+
+	dev_info(info->dev, "gesture event data: %02X %02X %02X %02X %02X %02X %02X %02X\n",
+		event[0], event[1], event[2], event[3], event[4],
+		event[5], event[6], event[7]);
+
+	if (event[0] == EVT_ID_USER_REPORT && event[1] ==
+	    EVT_TYPE_USER_GESTURE) {
+		needCoords = 1;
+		/* default read the coordinates for all gestures excluding
+		 * double tap */
+
+		switch (event[2]) {
+		case GEST_ID_DBLTAP:
+			value = KEY_WAKEUP;
+			dev_info(info->dev, "%s: double tap !\n", __func__);
+			needCoords = 0;
+			break;
+
+		case GEST_ID_AT:
+			value = KEY_WWW;
+			dev_info(info->dev, "%s: @ !\n", __func__);
+			break;
+
+		case GEST_ID_C:
+			value = KEY_C;
+			dev_info(info->dev, "%s: C !\n", __func__);
+			break;
+
+		case GEST_ID_E:
+			value = KEY_E;
+			dev_info(info->dev, "%s: e !\n", __func__);
+			break;
+
+		case GEST_ID_F:
+			value = KEY_F;
+			dev_info(info->dev, "%s: F !\n", __func__);
+			break;
+
+		case GEST_ID_L:
+			value = KEY_L;
+			dev_info(info->dev, "%s: L !\n", __func__);
+			break;
+
+		case GEST_ID_M:
+			value = KEY_M;
+			dev_info(info->dev, "%s: M !\n", __func__);
+			break;
+
+		case GEST_ID_O:
+			value = KEY_O;
+			dev_info(info->dev, "%s: O !\n", __func__);
+			break;
+
+		case GEST_ID_S:
+			value = KEY_S;
+			dev_info(info->dev, "%s: S !\n", __func__);
+			break;
+
+		case GEST_ID_V:
+			value = KEY_V;
+			dev_info(info->dev, "%s:  V !\n", __func__);
+			break;
+
+		case GEST_ID_W:
+			value = KEY_W;
+			dev_info(info->dev, "%s:  W !\n", __func__);
+			break;
+
+		case GEST_ID_Z:
+			value = KEY_Z;
+			dev_info(info->dev, "%s:  Z !\n", __func__);
+			break;
+
+		case GEST_ID_RIGHT_1F:
+			value = KEY_RIGHT;
+			dev_info(info->dev, "%s:  -> !\n", __func__);
+			break;
+
+		case GEST_ID_LEFT_1F:
+			value = KEY_LEFT;
+			dev_info(info->dev, "%s:  <- !\n", __func__);
+			break;
+
+		case GEST_ID_UP_1F:
+			value = KEY_UP;
+			dev_info(info->dev, "%s:  UP !\n", __func__);
+			break;
+
+		case GEST_ID_DOWN_1F:
+			value = KEY_DOWN;
+			dev_info(info->dev, "%s:  DOWN !\n", __func__);
+			break;
+
+		case GEST_ID_CARET:
+			value = KEY_APOSTROPHE;
+			dev_info(info->dev, "%s:  ^ !\n", __func__);
+			break;
+
+		case GEST_ID_LEFTBRACE:
+			value = KEY_LEFTBRACE;
+			dev_info(info->dev, "%s:  < !\n", __func__);
+			break;
+
+		case GEST_ID_RIGHTBRACE:
+			value = KEY_RIGHTBRACE;
+			dev_info(info->dev, "%s:  > !\n", __func__);
+			break;
+
+		default:
+			dev_err(info->dev, "%s:  No valid GestureID!\n", __func__);
+			goto gesture_done;
+		}
+
+		if (needCoords == 1)
+			readGestureCoords(info, event);
+
+		fts_input_report_key(info, value);
+
+gesture_done:
+		return;
+	} else
+		dev_err(info->dev, "%s: Invalid event passed as argument!\n", __func__);
+}
+#endif
+
+
+/**
+  * Event handler for user report events (EVT_ID_USER_REPORT)
+  * Handle user events reported by the FW due to some interaction triggered
+  * by an external user (press keys, perform gestures, etc.)
+  */
+static bool fts_user_report_event_handler(struct fts_ts_info *info, unsigned
+					  char *event)
+{
+	switch (event[1]) {
+#ifdef PHONE_KEY
+	case EVT_TYPE_USER_KEY:
+		fts_key_event_handler(info, event);
+		break;
+#endif
+
+	case EVT_TYPE_USER_PROXIMITY:
+		if (event[2] == 0)
+			dev_err(info->dev, "%s No proximity!\n", __func__);
+		else
+			dev_err(info->dev, "%s Proximity Detected!\n", __func__);
+		break;
+
+#ifdef GESTURE_MODE
+	case EVT_TYPE_USER_GESTURE:
+		fts_gesture_event_handler(info, event);
+		break;
+#endif
+	default:
+		dev_err(info->dev, "%s: Received unhandled user report event = %02X %02X %02X %02X %02X %02X %02X %02X\n",
+			__func__, event[0], event[1], event[2], event[3],
+			event[4], event[5], event[6], event[7]);
+		break;
+	}
+	return false;
+}
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+static void heatmap_enable(struct fts_ts_info *info)
+{
+	u8 command[] = {FTS_CMD_SYSTEM, SYS_CMD_LOAD_DATA,
+					LOCAL_HEATMAP_MODE};
+	dev_info(info->dev, "%s\n", __func__);
+	fts_write(info, command, ARRAY_SIZE(command));
+}
+
+static bool read_heatmap_raw(struct v4l2_heatmap *v4l2)
+{
+	struct fts_ts_info *info =
+		container_of(v4l2, struct fts_ts_info, v4l2);
+	unsigned int num_elements;
+	/* index for looping through the heatmap buffer read over the bus */
+	unsigned int local_i;
+
+	int result;
+
+	/* old value of the counter, for comparison */
+	static uint16_t counter;
+
+	strength_t heatmap_value;
+	/* final position of the heatmap value in the full heatmap frame */
+	unsigned int frame_i;
+
+	int heatmap_x, heatmap_y;
+	int max_x = v4l2->format.width;
+	int max_y = v4l2->format.height;
+
+	struct heatmap_report report = {0};
+
+	if (info->v4l2_mutual_strength_updated &&
+	    info->mutual_strength_heatmap.size_x == max_x &&
+	    info->mutual_strength_heatmap.size_y == max_y) {
+		memcpy(v4l2->frame, info->mutual_strength_heatmap.data,
+		       max_x * max_y * 2);
+		info->v4l2_mutual_strength_updated = false;
+		return true;
+	}
+
+	if (info->heatmap_mode == FTS_HEATMAP_PARTIAL) {
+		result = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R,
+					   BITS_16, ADDR_FRAMEBUFFER,
+					   (uint8_t *)&report,
+					   sizeof(report), DUMMY_FRAMEBUFFER);
+		if (result != OK) {
+			dev_err(info->dev, "%s: i2c read failed, fts_writeRead returned %i",
+				__func__, result);
+			return false;
+		}
+		if (report.mode != LOCAL_HEATMAP_MODE) {
+			dev_err(info->dev, "Touch IC not in local heatmap mode: %X %X %i",
+				report.prefix, report.mode, report.counter);
+			heatmap_enable(info);
+			return false;
+		}
+
+		le16_to_cpus(&report.counter); /* enforce little-endian order */
+		if (report.counter == counter && counter != 0) {
+			/*
+			 * We shouldn't make ordered comparisons because of
+			 * potential overflow, but at least the value
+			 * should have changed. If the value remains the same,
+			 * but we are processing a new interrupt,
+			 * this could indicate slowness in the interrupt
+			 * handler.
+			 */
+			if (info->mf_state != FTS_MF_UNFILTERED)
+				dev_warn(info->dev, "Heatmap frame has stale counter value %i",
+					counter);
+		}
+		counter = report.counter;
+		num_elements = report.size_x * report.size_y;
+		if (num_elements > LOCAL_HEATMAP_WIDTH * LOCAL_HEATMAP_HEIGHT) {
+			dev_err(info->dev, "Unexpected heatmap size: %i x %i",
+				report.size_x, report.size_y);
+			return false;
+		}
+
+		/* set all to zero, will only write to non-zero locations in
+		 * the loop
+		 */
+		memset(v4l2->frame, 0, v4l2->format.sizeimage);
+		/* populate the data buffer, rearranging into final locations */
+		for (local_i = 0; local_i < num_elements; local_i++) {
+			/* enforce little-endian order */
+			le16_to_cpus(&report.data[local_i]);
+			heatmap_value = report.data[local_i];
+
+			if (heatmap_value == 0) {
+				/* Already set to zero. Nothing to do */
+				continue;
+			}
+
+			heatmap_x = report.offset_x + (local_i % report.size_x);
+			heatmap_y = report.offset_y + (local_i / report.size_x);
+
+			if (heatmap_x < 0 || heatmap_x >= max_x ||
+			    heatmap_y < 0 || heatmap_y >= max_y) {
+				dev_err(info->dev, "Invalid x or y: (%i, %i), value=%i, ending loop\n",
+				heatmap_x, heatmap_y, heatmap_value);
+				return false;
+			}
+			frame_i = heatmap_y * max_x + heatmap_x;
+			v4l2->frame[frame_i] = heatmap_value;
+		}
+	} else if (info->heatmap_mode == FTS_HEATMAP_FULL) {
+		MutualSenseFrame ms_frame = { 0 };
+		uint32_t frame_index = 0, x, y;
+		uint32_t x_val, y_val;
+
+		result = getMSFrame3(info, MS_STRENGTH, &ms_frame);
+		if (result <= 0) {
+			dev_err(info->dev, "getMSFrame3 failed with result=0x%08X.\n",
+				result);
+			return false;
+		}
+
+		for (y = 0; y < max_y; y++) {
+			for (x = 0; x < max_x; x++) {
+				/* Rotate frame counter-clockwise and invert
+				 * if necessary.
+				 */
+				if (info->board->sensor_inverted_x)
+					x_val = (max_x - 1) - x;
+				else
+					x_val = x;
+				if (info->board->sensor_inverted_y)
+					y_val = (max_y - 1) - y;
+				else
+					y_val = y;
+
+				if (info->board->tx_rx_dir_swap)
+					heatmap_value =
+					    (strength_t)ms_frame.node_data[
+						y_val * max_x + x_val];
+				else
+					heatmap_value =
+					    (strength_t)ms_frame.node_data[
+						x_val * max_y + y_val];
+
+				v4l2->frame[frame_index++] = heatmap_value;
+			}
+		}
+
+		kfree(ms_frame.node_data);
+	} else
+		return false;
+
+	return true;
+}
+#endif
+
+/* Update a state machine used to toggle control of the touch IC's motion
+ * filter.
+ */
+static int update_motion_filter(struct fts_ts_info *info,
+				unsigned long touch_id)
+{
+	/* Motion filter timeout, in milliseconds */
+	const u32 mf_timeout_ms = 500;
+	u8 next_state;
+	u8 touches = hweight32(touch_id); /* Count the active touches */
+
+	if (info->use_default_mf)
+		return 0;
+
+	/* Determine the next filter state. The motion filter is enabled by
+	 * default and it is disabled while a single finger is touching the
+	 * screen. If another finger is touched down or if a timeout expires,
+	 * the motion filter is reenabled and remains enabled until all fingers
+	 * are lifted.
+	 */
+	next_state = info->mf_state;
+	switch (info->mf_state) {
+	case FTS_MF_FILTERED:
+		if (touches == 1) {
+			next_state = FTS_MF_UNFILTERED;
+			info->mf_downtime = ktime_get();
+		}
+		break;
+	case FTS_MF_UNFILTERED:
+		if (touches == 0) {
+			next_state = FTS_MF_FILTERED;
+		} else if (touches > 1 ||
+			   ktime_after(ktime_get(),
+				       ktime_add_ms(info->mf_downtime,
+						    mf_timeout_ms))) {
+			next_state = FTS_MF_FILTERED_LOCKED;
+		}
+		break;
+	case FTS_MF_FILTERED_LOCKED:
+		if (touches == 0) {
+			next_state = FTS_MF_FILTERED;
+		}
+		break;
+	}
+
+	/* Send command to update filter state */
+	if ((next_state == FTS_MF_UNFILTERED) !=
+	    (info->mf_state == FTS_MF_UNFILTERED)) {
+		u8 cmd[3] = {0xC0, 0x05, 0x00};
+		dev_dbg(info->dev, "%s: setting motion filter = %s.\n", __func__,
+			 (next_state == FTS_MF_UNFILTERED) ? "false" : "true");
+		cmd[2] = (next_state == FTS_MF_UNFILTERED) ? 0x01 : 0x00;
+		fts_write(info, cmd, sizeof(cmd));
+	}
+	info->mf_state = next_state;
+
+	return 0;
+}
+
+int fts_enable_grip(struct fts_ts_info *info, bool enable)
+{
+	uint8_t enable_cmd[] = {
+		0xC0, 0x03, 0x10, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00};
+	uint8_t disable_cmd[] = {
+		0xC0, 0x03, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+	uint8_t left_size_cmd[] =
+		{0xC0, 0x03, 0x20, 0x00/* unit: px */, 0x00, 0x00, 0x00, 0x5F, 0x09};
+	uint8_t right_size_cmd[] =
+		{0xC0, 0x03, 0x21, 0x00/* unit: px */, 0x00, 0x00, 0x00, 0x5F, 0x09};
+	int res;
+
+	if (enable) {
+		if (info->board->fw_grip_area) {
+			left_size_cmd[3] = info->board->fw_grip_area;
+			right_size_cmd[3] = info->board->fw_grip_area;
+			res = fts_write(info, left_size_cmd, sizeof(left_size_cmd));
+			res = fts_write(info, right_size_cmd, sizeof(right_size_cmd));
+		}
+		res = fts_write(info, enable_cmd, sizeof(enable_cmd));
+	} else {
+		if (info->board->fw_grip_area) {
+			res = fts_write(info, left_size_cmd, sizeof(left_size_cmd));
+			res = fts_write(info, right_size_cmd, sizeof(right_size_cmd));
+		}
+		res = fts_write(info, disable_cmd, sizeof(disable_cmd));
+	}
+	if (res < 0)
+		dev_err(info->dev, "%s: fts_write failed with res=%d.\n",
+			__func__, res);
+
+	return res;
+}
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+
+static void fts_offload_resume_work(struct work_struct *work)
+{
+	struct delayed_work *dwork = container_of(work, struct delayed_work,
+						  work);
+	struct fts_ts_info *info = container_of(dwork, struct fts_ts_info,
+						offload_resume_work);
+
+	if (info->offload.config.filter_grip == 1)
+		fts_enable_grip(info, false);
+
+}
+
+static void fts_populate_coordinate_channel(struct fts_ts_info *info,
+					struct touch_offload_frame *frame,
+					int channel)
+{
+	int j;
+	int active_coords = 0;
+
+	struct TouchOffloadDataCoord *dc =
+		(struct TouchOffloadDataCoord *)frame->channel_data[channel];
+	memset(dc, 0, frame->channel_data_size[channel]);
+	dc->header.channel_type = TOUCH_DATA_TYPE_COORD;
+	dc->header.channel_size = TOUCH_OFFLOAD_FRAME_SIZE_COORD;
+
+	for (j = 0; j < MAX_COORDS; j++) {
+		dc->coords[j].x = info->offload.coords[j].x;
+		dc->coords[j].y = info->offload.coords[j].y;
+		dc->coords[j].major = info->offload.coords[j].major;
+		dc->coords[j].minor = info->offload.coords[j].minor;
+		dc->coords[j].pressure = info->offload.coords[j].pressure;
+		dc->coords[j].rotation = info->offload.coords[j].rotation;
+		dc->coords[j].status = info->offload.coords[j].status;
+		if (dc->coords[j].status != COORD_STATUS_INACTIVE)
+			active_coords += 1;
+	}
+
+	info->touch_offload_active_coords = active_coords;
+}
+
+static void fts_update_v4l2_mutual_strength(struct fts_ts_info *info,
+					    uint32_t size_x,
+					    uint32_t size_y,
+					    int16_t *heatmap)
+{
+	if (!info->mutual_strength_heatmap.data) {
+		info->mutual_strength_heatmap.data = devm_kmalloc(info->dev,
+			size_x * size_y * 2, GFP_KERNEL);
+		if (!info->mutual_strength_heatmap.data) {
+			dev_err(info->dev,
+				"%s: kmalloc for mutual_strength_heatmap (%d) failed.\n",
+				__func__, size_x * size_y * 2);
+		} else {
+			info->mutual_strength_heatmap.size_x = size_x;
+			info->mutual_strength_heatmap.size_y = size_y;
+			dev_info(info->dev,
+				 "%s: kmalloc for mutual_strength_heatmap (%d).\n",
+				 __func__, size_x * size_y * 2);
+		}
+	}
+
+	if (info->mutual_strength_heatmap.data) {
+		if (info->mutual_strength_heatmap.size_x == size_x &&
+		    info->mutual_strength_heatmap.size_y == size_y) {
+			memcpy(info->mutual_strength_heatmap.data,
+			       heatmap, size_x * size_y * 2);
+			info->mutual_strength_heatmap.timestamp =
+				info->timestamp;
+			info->v4l2_mutual_strength_updated = true;
+		} else {
+			dev_info(info->dev,
+				 "%s: unmatched heatmap size (%d,%d) (%d,%d).\n",
+				 __func__, size_x, size_y,
+				 info->mutual_strength_heatmap.size_x,
+				 info->mutual_strength_heatmap.size_y);
+		}
+	}
+}
+
+static void fts_populate_mutual_channel(struct fts_ts_info *info,
+					struct touch_offload_frame *frame,
+					int channel)
+{
+	MutualSenseFrame ms_frame = { 0 };
+	uint32_t frame_index = 0, x, y;
+	uint32_t x_val, y_val;
+	uint16_t heatmap_value;
+	int result;
+	uint32_t data_type = 0;
+	uint32_t max_x = 0;
+	uint32_t max_y = 0;
+	struct TouchOffloadData2d *mutual_strength =
+		(struct TouchOffloadData2d *)frame->channel_data[channel];
+
+	switch (frame->channel_type[channel] & ~TOUCH_SCAN_TYPE_MUTUAL) {
+	case TOUCH_DATA_TYPE_RAW:
+		data_type = MS_RAW;
+		break;
+	case TOUCH_DATA_TYPE_FILTERED:
+		data_type = MS_FILTER;
+		break;
+	case TOUCH_DATA_TYPE_STRENGTH:
+		data_type = MS_STRENGTH;
+		break;
+	case TOUCH_DATA_TYPE_BASELINE:
+		data_type = MS_BASELINE;
+		break;
+	}
+	if (info->board->tx_rx_dir_swap) {
+		mutual_strength->tx_size = getSenseLen(info);
+		mutual_strength->rx_size = getForceLen(info);
+	} else {
+		mutual_strength->tx_size = getForceLen(info);
+		mutual_strength->rx_size = getSenseLen(info);
+	}
+	mutual_strength->header.channel_type = frame->channel_type[channel];
+	mutual_strength->header.channel_size =
+		TOUCH_OFFLOAD_FRAME_SIZE_2D(mutual_strength->rx_size,
+					    mutual_strength->tx_size);
+
+	result = getMSFrame3(info, data_type, &ms_frame);
+	if (result <= 0) {
+		dev_err(info->dev, "getMSFrame3 failed with result=0x%08X.\n",
+			result);
+	} else {
+		max_x = mutual_strength->tx_size;
+		max_y = mutual_strength->rx_size;
+
+		for (y = 0; y < max_y; y++) {
+			for (x = 0; x < max_x; x++) {
+				/* Rotate frame counter-clockwise and invert
+				 * if necessary.
+				 */
+				if (info->board->sensor_inverted_x)
+					x_val = (max_x - 1) - x;
+				else
+					x_val = x;
+				if (info->board->sensor_inverted_y)
+					y_val = (max_y - 1) - y;
+				else
+					y_val = y;
+
+				if (info->board->tx_rx_dir_swap)
+					heatmap_value = ms_frame.node_data[
+						y_val * max_x + x_val];
+				else
+					heatmap_value = ms_frame.node_data[
+						x_val * max_y + y_val];
+
+				((uint16_t *)
+				 mutual_strength->data_flex)[frame_index++] =
+				    heatmap_value;
+			}
+		}
+	}
+
+	if (data_type == MS_STRENGTH) {
+		fts_update_v4l2_mutual_strength(info, max_x, max_y,
+		    (int16_t *) mutual_strength->data_flex);
+	}
+
+	kfree(ms_frame.node_data);
+}
+
+static void fts_populate_self_channel(struct fts_ts_info *info,
+					struct touch_offload_frame *frame,
+					int channel)
+{
+	SelfSenseFrame ss_frame = { 0 };
+	int i;
+	int result;
+	uint32_t data_type = 0;
+	struct TouchOffloadData1d *self_strength =
+		(struct TouchOffloadData1d *)frame->channel_data[channel];
+	if (info->board->tx_rx_dir_swap) {
+		self_strength->tx_size = getSenseLen(info);
+		self_strength->rx_size = getForceLen(info);
+	} else {
+		self_strength->tx_size = getForceLen(info);
+		self_strength->rx_size = getSenseLen(info);
+	}
+	self_strength->header.channel_type = frame->channel_type[channel];
+	self_strength->header.channel_size =
+		TOUCH_OFFLOAD_FRAME_SIZE_1D(self_strength->rx_size,
+					    self_strength->tx_size);
+
+	switch (frame->channel_type[channel] & ~TOUCH_SCAN_TYPE_SELF) {
+	case TOUCH_DATA_TYPE_RAW:
+		data_type = SS_RAW;
+		break;
+	case TOUCH_DATA_TYPE_FILTERED:
+		data_type = SS_FILTER;
+		break;
+	case TOUCH_DATA_TYPE_STRENGTH:
+		data_type = SS_STRENGTH;
+		break;
+	case TOUCH_DATA_TYPE_BASELINE:
+		data_type = SS_BASELINE;
+		break;
+	}
+	result = getSSFrame3(info, data_type, &ss_frame);
+	if (result <= 0) {
+		dev_err(info->dev, "getSSFrame3 failed with result=0x%08X.\n",
+			result);
+	} else {
+		uint16_t *tx_src, *rx_src, *tx_dst, *rx_dst;
+		if (info->board->tx_rx_dir_swap) {
+			tx_src = ss_frame.sense_data;
+			rx_src = ss_frame.force_data;
+		} else {
+			tx_src = ss_frame.force_data;
+			rx_src = ss_frame.sense_data;
+		}
+		/* tx, rx data order is fixed in TouchOffloadData1d */
+		tx_dst = (uint16_t *)self_strength->data_flex;
+		rx_dst = (uint16_t *)&self_strength->data_flex[
+					2 * self_strength->tx_size];
+
+		/* If the tx data is flipped, copy in left-to-right order */
+		if (info->board->sensor_inverted_x) {
+			for (i = 0; i < self_strength->tx_size; i++)
+				tx_dst[i] =
+					tx_src[self_strength->tx_size - 1 - i];
+		} else {
+			memcpy(tx_dst, tx_src, 2 * self_strength->tx_size);
+		}
+
+		/* If the rx data is flipped, copy in top-to-bottom order */
+		if (info->board->sensor_inverted_y) {
+			for (i = 0; i < self_strength->rx_size; i++)
+				rx_dst[i] =
+					rx_src[self_strength->rx_size - 1 - i];
+		} else {
+			memcpy(rx_dst, rx_src, 2 * self_strength->rx_size);
+		}
+	}
+	kfree(ss_frame.force_data);
+	kfree(ss_frame.sense_data);
+}
+
+static void fts_populate_driver_status_channel(struct fts_ts_info *info,
+					struct touch_offload_frame *frame,
+					int channel)
+{
+	struct TouchOffloadDriverStatus *ds =
+		(struct TouchOffloadDriverStatus *)frame->channel_data[channel];
+	memset(ds, 0, frame->channel_data_size[channel]);
+	ds->header.channel_type = (u32)CONTEXT_CHANNEL_TYPE_DRIVER_STATUS;
+	ds->header.channel_size = sizeof(struct TouchOffloadDriverStatus);
+
+	ds->contents.screen_state = 1;
+	ds->screen_state = info->sensor_sleep ? 0 : 1;
+
+	ds->display_refresh_rate = 60;
+#ifdef DYNAMIC_REFRESH_RATE
+	ds->contents.display_refresh_rate = 1;
+	ds->display_refresh_rate = info->display_refresh_rate;
+#endif
+}
+
+static void fts_populate_frame(struct fts_ts_info *info,
+				struct touch_offload_frame *frame,
+				int populate_channel_types)
+{
+	static u64 index;
+	int i;
+
+	frame->header.index = index++;
+	frame->header.timestamp = info->timestamp;
+
+	/* Populate all channels */
+	for (i = 0; i < frame->num_channels; i++) {
+		if ((frame->channel_type[i] & populate_channel_types) ==
+		    TOUCH_DATA_TYPE_COORD)
+			fts_populate_coordinate_channel(info, frame, i);
+		else if ((frame->channel_type[i] & TOUCH_SCAN_TYPE_MUTUAL &
+			  populate_channel_types) != 0)
+			fts_populate_mutual_channel(info, frame, i);
+		else if ((frame->channel_type[i] & TOUCH_SCAN_TYPE_SELF &
+			  populate_channel_types) != 0)
+			fts_populate_self_channel(info, frame, i);
+		else if ((frame->channel_type[i] ==
+			  CONTEXT_CHANNEL_TYPE_DRIVER_STATUS) != 0)
+			fts_populate_driver_status_channel(info, frame, i);
+		else if ((frame->channel_type[i] ==
+			  CONTEXT_CHANNEL_TYPE_STYLUS_STATUS) != 0) {
+			/* Stylus context is not required by this driver */
+			dev_err(info->dev,
+				  "%s: Driver does not support stylus status",
+				  __func__);
+		}
+	}
+}
+
+static void fts_offload_set_running(struct fts_ts_info *info, bool running)
+{
+	if (info->offload.offload_running != running) {
+		info->offload.offload_running = running;
+		if (running) {
+			dev_info(info->dev, "%s: disabling FW grip.\n",
+				 __func__);
+			fts_enable_grip(info, false);
+		} else {
+			dev_info(info->dev, "%s: enabling FW grip.\n",
+				 __func__);
+			fts_enable_grip(info, true);
+		}
+	}
+}
+
+#endif /* CONFIG_TOUCHSCREEN_OFFLOAD */
+
+/**
+  * Bottom Half Interrupt Handler function
+  * This handler is called each time there is at least one new event in the FIFO
+  * and the interrupt pin of the IC goes low. It will read all the events from
+  * the FIFO and dispatch them to the proper event handler according the event
+  * ID
+  */
+static irqreturn_t fts_interrupt_handler(int irq, void *handle)
+{
+	struct fts_ts_info *info = handle;
+	int error = 0, count = 0;
+	unsigned char regAdd = FIFO_CMD_READALL;
+	unsigned char data[FIFO_EVENT_SIZE * FIFO_DEPTH];
+	unsigned char eventId;
+	const unsigned char EVENTS_REMAINING_POS = 7;
+	const unsigned char EVENTS_REMAINING_MASK = 0x1F;
+	unsigned char events_remaining = 0;
+	unsigned char *evt_data;
+	bool processed_pointer_event = false;
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	struct touch_offload_frame *frame = NULL;
+#endif
+
+	/* It is possible that interrupts were disabled while the handler is
+	 * executing, before acquiring the mutex. If so, simply return.
+	 */
+	if (fts_set_bus_ref(info, FTS_BUS_REF_IRQ, true) < 0) {
+		fts_set_bus_ref(info, FTS_BUS_REF_IRQ, false);
+		return IRQ_HANDLED;
+	}
+
+	/* prevent CPU from entering deep sleep */
+	cpu_latency_qos_update_request(&info->pm_qos_req, 100);
+
+	__pm_wakeup_event(info->wakesrc, jiffies_to_msecs(HZ));
+
+	/* Read the first FIFO event and the number of events remaining */
+	error = fts_writeReadU8UX(info, regAdd, 0, 0, data, FIFO_EVENT_SIZE,
+				  DUMMY_FIFO);
+	events_remaining = data[EVENTS_REMAINING_POS] & EVENTS_REMAINING_MASK;
+	events_remaining = (events_remaining > FIFO_DEPTH - 1) ?
+			   FIFO_DEPTH - 1 : events_remaining;
+
+	/* Drain the rest of the FIFO, up to 31 events */
+	if (error == OK && events_remaining > 0) {
+		error = fts_writeReadU8UX(info, regAdd, 0, 0,
+					  &data[FIFO_EVENT_SIZE],
+					  FIFO_EVENT_SIZE * events_remaining,
+					  DUMMY_FIFO);
+	}
+	if (error != OK) {
+		dev_err(info->dev, "Error (%08X) while reading from FIFO in fts_event_handler\n",
+			error);
+	} else {
+		for (count = 0; count < events_remaining + 1; count++) {
+			evt_data = &data[count * FIFO_EVENT_SIZE];
+
+			if (evt_data[0] == EVT_ID_NOEVENT)
+				break;
+
+			eventId = evt_data[0] >> 4;
+
+			/* Ensure event ID is within bounds */
+			if (eventId < NUM_EVT_ID) {
+				processed_pointer_event |=
+					info->event_dispatch_table[eventId](
+						info, evt_data);
+			}
+		}
+	}
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	if (!info->offload.offload_running) {
+#endif
+	mutex_lock(&info->input_report_mutex);
+	if (info->touch_id == 0)
+		input_report_key(info->input_dev, BTN_TOUCH, 0);
+
+	input_set_timestamp(info->input_dev, info->timestamp);
+	input_sync(info->input_dev);
+	mutex_unlock(&info->input_report_mutex);
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	}
+
+	if (processed_pointer_event) {
+		error = touch_offload_reserve_frame(&info->offload, &frame);
+		if (error != 0) {
+			dev_dbg(info->dev,
+				"%s: Could not reserve a frame: error=%d.\n",
+				__func__, error);
+
+			/* Stop offload when there are no buffers available */
+			fts_offload_set_running(info, false);
+		} else {
+			fts_offload_set_running(info, true);
+
+			fts_populate_frame(info, frame, 0xFFFFFFFF);
+
+			error = touch_offload_queue_frame(&info->offload,
+							  frame);
+			if (error != 0) {
+				dev_err(info->dev,
+					"%s: Failed to queue reserved frame: error=%d.\n",
+					__func__, error);
+			}
+		}
+	}
+#endif
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	if (processed_pointer_event && !info->offload.offload_running)
+		heatmap_read(&info->v4l2, ktime_to_ns(info->timestamp));
+
+	/* Disable the firmware motion filter during single touch */
+	if (!info->offload.offload_running)
+		update_motion_filter(info, info->touch_id);
+#endif
+
+	cpu_latency_qos_update_request(&info->pm_qos_req, PM_QOS_DEFAULT_VALUE);
+	fts_set_bus_ref(info, FTS_BUS_REF_IRQ, false);
+	return IRQ_HANDLED;
+}
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+static void fts_offload_push_coord_frame(struct fts_ts_info *info) {
+	struct touch_offload_frame *frame = NULL;
+	int error = 0;
+
+	dev_info(info->dev, "%s: active coords %d.\n",
+	 	 __func__, info->touch_offload_active_coords);
+
+	error = touch_offload_reserve_frame(&info->offload, &frame);
+	if (error != 0) {
+		dev_dbg(info->dev,
+			"%s: Could not reserve a frame: error=%d.\n",
+			__func__, error);
+
+	} else {
+		fts_populate_frame(info, frame, TOUCH_DATA_TYPE_COORD);
+
+		error = touch_offload_queue_frame(&info->offload,
+						  frame);
+		if (error != 0) {
+			dev_err(info->dev,
+				"%s: Failed to queue reserved frame: error=%d.\n",
+				__func__, error);
+		}
+	}
+}
+
+static void fts_offload_report(void *handle,
+			       struct TouchOffloadIocReport *report)
+{
+	struct fts_ts_info *info = (struct fts_ts_info *)handle;
+	bool touch_down = 0;
+	unsigned long touch_id = 0;
+	int i;
+
+	mutex_lock(&info->input_report_mutex);
+
+	input_set_timestamp(info->input_dev, report->timestamp);
+
+	for (i = 0; i < MAX_COORDS; i++) {
+		if (report->coords[i].status == COORD_STATUS_FINGER) {
+			input_mt_slot(info->input_dev, i);
+			touch_down = 1;
+			__set_bit(i, &touch_id);
+			input_report_key(info->input_dev, BTN_TOUCH,
+					 touch_down);
+			input_mt_report_slot_state(info->input_dev,
+						   MT_TOOL_FINGER, 1);
+			input_report_abs(info->input_dev, ABS_MT_POSITION_X,
+					 report->coords[i].x);
+			input_report_abs(info->input_dev, ABS_MT_POSITION_Y,
+					 report->coords[i].y);
+			input_report_abs(info->input_dev, ABS_MT_TOUCH_MAJOR,
+					 report->coords[i].major);
+			input_report_abs(info->input_dev, ABS_MT_TOUCH_MINOR,
+					 report->coords[i].minor);
+
+#ifndef SKIP_PRESSURE
+			if ((int)report->coords[i].pressure <= 0) {
+				dev_err(info->dev,
+					"%s: Pressure is %i, but pointer %d is not leaving.\n",
+					__func__, (int)report->coords[i].pressure, i);
+			}
+			input_report_abs(info->input_dev, ABS_MT_PRESSURE,
+					 report->coords[i].pressure);
+#endif
+			input_report_abs(info->input_dev, ABS_MT_ORIENTATION,
+					 report->coords[i].rotation);
+
+		} else {
+			input_mt_slot(info->input_dev, i);
+			input_report_abs(info->input_dev, ABS_MT_PRESSURE, 0);
+			input_mt_report_slot_state(info->input_dev,
+						   MT_TOOL_FINGER, 0);
+			input_report_abs(info->input_dev, ABS_MT_TRACKING_ID,
+					 -1);
+
+			input_report_abs(info->input_dev, ABS_MT_ORIENTATION, 0);
+		}
+	}
+
+	input_report_key(info->input_dev, BTN_TOUCH, touch_down);
+
+	input_sync(info->input_dev);
+
+	mutex_unlock(&info->input_report_mutex);
+
+	if (touch_down)
+		heatmap_read(&info->v4l2, ktime_to_ns(report->timestamp));
+
+	/* Disable the firmware motion filter during single touch */
+	update_motion_filter(info, touch_id);
+}
+#endif /* CONFIG_TOUCHSCREEN_OFFLOAD */
+
+/*
+ * Read the display panel's extinfo from the display driver.
+ *
+ * The display driver finds out the extinfo is available for a panel based on
+ * the device tree, but cannot read the extinfo itself until the DSI bus is
+ * initialized. Since the extinfo is not guaranteed to be available at the time
+ * the touch driver is probed or even when the automatic firmware update work is
+ * run. The display driver's API for reading extinfo does allow a client to
+ * query the size of the expected data and whether it is available.
+ *
+ * This function retrieves the extinfo from the display driver with an optional
+ * retry period to poll the display driver before giving up.
+ *
+ * @return	0 if success, -EBUSY if timeout
+ */
+#if 1
+static int fts_read_panel_extinfo(struct fts_ts_info *info, int wait_seconds)
+{
+	return 0;
+}
+#else
+static int fts_read_panel_extinfo(struct fts_ts_info *info, int wait_seconds)
+{
+	const int RETRIES_PER_S = 4;
+	const int MS_PER_RETRY = 1000 / RETRIES_PER_S;
+	ssize_t len = -EBUSY;
+	int retries = (wait_seconds <= 0) ? 0 : wait_seconds * RETRIES_PER_S;
+	int ret = 0;
+
+	/* Was extinfo previously retrieved? */
+	if (info->extinfo.is_read)
+		return 0;
+
+	/* Extinfo should not be retrieved if the driver was unable to identify
+	 * the panel via its panelmap. Consider the extinfo zero-length.
+	 */
+	if (!info->board->panel) {
+		info->extinfo.is_read = true;
+		info->extinfo.size = 0;
+		return 0;
+	}
+
+	/* Obtain buffer size */
+	len = dsi_panel_read_vendor_extinfo(info->board->panel, NULL, 0);
+	if (len == 0) {
+		/* No extinfo to be consumed */
+		info->extinfo.size = 0;
+		info->extinfo.is_read = true;
+		return 0;
+	} else if (len < 0) {
+		ret = len;
+		dev_err(info->dev, "%s: dsi_panel_read_vendor_extinfo returned unexpected error = %d.\n",
+		       __func__, ret);
+		goto error;
+	} else {
+		info->extinfo.data = kzalloc(len, GFP_KERNEL);
+		if (!info->extinfo.data) {
+			dev_err(info->dev, "%s: failed to allocate extinfo. len=%d.\n",
+			       __func__, len);
+			ret = -ENOMEM;
+			goto error;
+		}
+		info->extinfo.size = len;
+	}
+
+	/* Read vendor extinfo data */
+	do {
+		len = dsi_panel_read_vendor_extinfo(info->board->panel,
+						    info->extinfo.data,
+						    info->extinfo.size);
+		if (len == -EBUSY) {
+			dev_dbg(info->dev, "%s: sleeping %dms.\n", __func__,
+				 MS_PER_RETRY);
+			msleep(MS_PER_RETRY);
+		} else if (len == info->extinfo.size) {
+			info->extinfo.is_read = true;
+			dev_dbg(info->dev, "%s: Ultimately waited %d seconds.\n",
+				 __func__,
+				 wait_seconds - (retries / RETRIES_PER_S));
+			return 0;
+		} else {
+			dev_err(info->dev, "%s: dsi_panel_read_vendor_extinfo returned error = %d\n",
+			       __func__, len);
+			ret = len;
+			goto error;
+		}
+	} while (--retries > 0);
+
+	/* Time out after retrying for wait_seconds */
+	dev_err(info->dev, "%s: Timed out after waiting %d seconds.\n", __func__,
+	       wait_seconds);
+	ret = -EBUSY;
+
+error:
+	kfree(info->extinfo.data);
+	info->extinfo.data = NULL;
+	info->extinfo.size = 0;
+	info->extinfo.is_read = false;
+	return ret;
+}
+#endif
+
+/*
+ * Determine the display panel based on the device tree and any extinfo read
+ * from the panel.
+ *
+ * Basic panel detection (e.g., unique part numbers) is performed by polling for
+ * connected drm_panels. Next, an override table from the device tree is used to
+ * parse the panel's extended info to distinguish between panel varients that
+ * require different firmware.
+ */
+static int fts_identify_panel(struct fts_ts_info *info)
+{
+	/* Formatting of EXTINFO rows provided in the device trees */
+	const int EXTINFO_ROW_ELEMS = 5;
+	const int EXTINFO_ROW_SIZE = EXTINFO_ROW_ELEMS * sizeof(u32);
+
+	struct device_node *np = info->dev->of_node;
+	u32 panel_index = info->board->initial_panel_index;
+	int extinfo_rows;
+	u32 filter_panel_index, filter_extinfo_index, filter_extinfo_mask;
+	u32 filter_extinfo_value, filter_extinfo_fw;
+	const char *name;
+	int i;
+	int ret = 0;
+
+	if (!info->extinfo.is_read) {
+		/* Extinfo was not read. Attempt one read before aborting */
+		ret = fts_read_panel_extinfo(info, 0);
+		if (ret < 0) {
+			dev_err(info->dev, "%s: fts_read_panel_extinfo failed with ret=%d.\n",
+				__func__, ret);
+			goto get_panel_info_failed;
+		}
+	}
+
+	/* Read the extinfo override table to determine if there are is any
+	 * reason to select a different firmware for the panel.
+	 */
+	if (of_property_read_bool(np, "st,extinfo_override_table")) {
+		extinfo_rows = of_property_count_elems_of_size(
+					np, "st,extinfo_override_table",
+					EXTINFO_ROW_SIZE);
+
+		for (i = 0; i < extinfo_rows; i++) {
+			of_property_read_u32_index(
+					np, "st,extinfo_override_table",
+					i * EXTINFO_ROW_ELEMS + 0,
+					&filter_panel_index);
+
+			of_property_read_u32_index(
+					np, "st,extinfo_override_table",
+					i * EXTINFO_ROW_ELEMS + 1,
+					&filter_extinfo_index);
+
+			of_property_read_u32_index(
+					np, "st,extinfo_override_table",
+					i * EXTINFO_ROW_ELEMS + 2,
+					&filter_extinfo_mask);
+
+			of_property_read_u32_index(
+					np, "st,extinfo_override_table",
+					i * EXTINFO_ROW_ELEMS + 3,
+					&filter_extinfo_value);
+
+			of_property_read_u32_index(
+					np, "st,extinfo_override_table",
+					i * EXTINFO_ROW_ELEMS + 4,
+					&filter_extinfo_fw);
+
+			if (panel_index != filter_panel_index)
+				continue;
+			else if (filter_extinfo_index >= info->extinfo.size) {
+				dev_err(info->dev, "%s: extinfo index is out of bounds (%d >= %d) in row %d of extinfo_override_table.\n",
+					__func__, filter_extinfo_index,
+					info->extinfo.size, i);
+				continue;
+			} else if ((info->extinfo.data[filter_extinfo_index] &
+				      filter_extinfo_mask) ==
+				   filter_extinfo_value) {
+				/* Override the panel_index as specified in the
+				 * override table.
+				 */
+				panel_index = filter_extinfo_fw;
+				dev_info(info->dev, "%s: Overriding with row=%d, panel_index=%d.\n",
+					 __func__, i, panel_index);
+				break;
+			}
+		}
+	} else {
+		dev_err(info->dev, "%s: of_property_read_bool(np, \"st,extinfo_override_table\") failed.\n",
+			__func__);
+	}
+
+	//---------------------------------------------------------------------
+	// Read firmware name, limits file name, and sensor inversion based on
+	// the final panel index. In order to handle the case where the DRM
+	// panel was not detected from the list in the device tree, fall back to
+	// using predefined FW and limits paths hardcoded into the driver.
+	// --------------------------------------------------------------------
+get_panel_info_failed:
+	name = NULL;
+	of_property_read_string_index(np, "st,firmware_names",
+				      panel_index, &name);
+	if (!name)
+		info->board->fw_name = PATH_FILE_FW;
+	else
+		info->board->fw_name = name;
+	dev_info(info->dev, "firmware name = %s\n", info->board->fw_name);
+
+	name = NULL;
+	of_property_read_string_index(np, "st,limits_names",
+				      panel_index, &name);
+	if (!name)
+		info->board->limits_name = LIMITS_FILE;
+	else
+		info->board->limits_name = name;
+	dev_info(info->dev, "limits name = %s\n", info->board->limits_name);
+
+	return ret;
+}
+
+/**
+  *	Implement the fw update and initialization flow of the IC that should
+  *	be executed at every boot up. The function perform a fw update of the
+  *	IC in case of crc error or a new fw version and then understand if the
+  *	IC need to be re-initialized again.
+  *
+  *	@return  OK if success or an error code which specify the type of error
+  *	encountered
+  */
+static int fts_fw_update(struct fts_ts_info *info)
+{
+	u8 error_to_search[4] = { EVT_TYPE_ERROR_CRC_CX_HEAD,
+				  EVT_TYPE_ERROR_CRC_CX,
+				  EVT_TYPE_ERROR_CRC_CX_SUB_HEAD,
+				  EVT_TYPE_ERROR_CRC_CX_SUB };
+	int ret;
+	int error = 0;
+	int init_type = NO_INIT;
+	int index;
+	int prop_len = 0;
+	struct device_node *np = info->dev->of_node;
+
+#if defined(PRE_SAVED_METHOD) || defined(COMPUTE_INIT_METHOD)
+	/* Not decided yet.
+	 * Still need the firmware CX AFE version to decide the final value.
+	 */
+	int keep_cx = CX_CHECK_AFE_VER;
+#else
+	int keep_cx = CX_ERASE;
+#endif
+
+	/* Read extinfo from display driver. Wait for up to ten seconds if
+	 * there is extinfo to read but is not yet available.
+	 */
+	ret = fts_read_panel_extinfo(info, 10);
+	if (ret < 0)
+		dev_err(info->dev, "%s: Failed or timed out during read of extinfo. ret=%d\n",
+			__func__, ret);
+
+	/* Identify panel given extinfo that may have been received. */
+	ret = fts_identify_panel(info);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: Encountered error while identifying display panel. ret=%d\n",
+			__func__, ret);
+		goto out;
+	}
+
+	dev_info(info->dev, "Fw Auto Update is starting...\n");
+
+	/* Check CRC status */
+	ret = fts_crc_check(info);
+	if (ret > OK) {
+		dev_err(info->dev, "%s: CRC Error or NO FW!\n", __func__);
+		info->reflash_fw = 1;
+	} else {
+		dev_info(info->dev, "%s: NO CRC Error or Impossible to read CRC register!\n",
+			__func__);
+	}
+
+	if (of_property_read_bool(np, "st,force-pi-cfg-ver-map")) {
+		prop_len = of_property_count_u32_elems(np,
+			"st,force-pi-cfg-ver-map");
+		info->board->force_pi_cfg_ver = devm_kzalloc(info->dev,
+			sizeof(u32) * prop_len, GFP_KERNEL);
+		if (info->board->force_pi_cfg_ver != NULL) {
+			for (index = 0; index < prop_len; index++) {
+				of_property_read_u32_index(np,
+					"st,force-pi-cfg-ver-map",
+					index,
+					&info->board->force_pi_cfg_ver[index]);
+				dev_info(info->dev, "%s: force PI config version: %04X",
+					__func__,
+					info->board->force_pi_cfg_ver[index]);
+				if(info->systemInfo.u16_cfgVer ==
+					info->board->force_pi_cfg_ver[index]) {
+					dev_info(info->dev, "%s System config version %04X, do panel init",
+					__func__, info->systemInfo.u16_cfgVer);
+					init_type = SPECIAL_PANEL_INIT;
+				}
+			}
+		} else {
+			dev_err(info->dev, "%s: force_pi_cfg_ver is NULL", __func__);
+		}
+	} else {
+		dev_info(info->dev, "%s: of_property_read_bool(np, \"st,force-pi-cfg-ver-map\") failed.\n",
+		__func__);
+	}
+
+	if (info->board->auto_fw_update) {
+		ret = flashProcedure(info, info->board->fw_name, info->reflash_fw,
+				     keep_cx);
+		if ((ret & 0xF000000F) == ERROR_FILE_NOT_FOUND) {
+			dev_err(info->dev, "%s: firmware file not found. Bypassing update.\n",
+				__func__);
+			ret = 0;
+			goto out;
+		} else if ((ret & 0xFF000000) == ERROR_FLASH_PROCEDURE) {
+			dev_err(info->dev, "%s: firmware update failed; retrying. ERROR %08X\n",
+				__func__, ret);
+			/* Power cycle the touch IC */
+			fts_chip_powercycle(info);
+			ret = flashProcedure(info, info->board->fw_name,
+					     info->reflash_fw, keep_cx);
+			if ((ret & 0xFF000000) == ERROR_FLASH_PROCEDURE) {
+				dev_err(info->dev, "%s: firmware update failed again! ERROR %08X\n",
+					__func__, ret);
+				dev_err(info->dev, "Fw Auto Update Failed!\n");
+			}
+		}
+		info->reflash_fw = 0;
+	}
+
+	dev_info(info->dev, "%s: Verifying if CX CRC Error...\n", __func__);
+	ret = fts_system_reset(info);
+	if (ret >= OK) {
+		ret = pollForErrorType(info, error_to_search, 4);
+		if (ret < OK) {
+			dev_info(info->dev, "%s: No Cx CRC Error Found!\n", __func__);
+			dev_info(info->dev, "%s: Verifying if Panel CRC Error...\n",
+				__func__);
+			error_to_search[0] = EVT_TYPE_ERROR_CRC_PANEL_HEAD;
+			error_to_search[1] = EVT_TYPE_ERROR_CRC_PANEL;
+			ret = pollForErrorType(info, error_to_search, 2);
+			if (ret < OK) {
+				dev_info(info->dev, "%s: No Panel CRC Error Found!\n",
+					__func__);
+			} else {
+				dev_err(info->dev, "%s: Panel CRC Error FOUND! CRC ERROR = %02X\n",
+					__func__, ret);
+				init_type = SPECIAL_PANEL_INIT;
+			}
+		} else {
+			dev_err(info->dev, "%s: Cx CRC Error FOUND! CRC ERROR = %02X\n",
+				__func__, ret);
+
+			/** This path of the code is used only in case there is
+			  * a CRC error in code or config which not allow the fw
+			  * to compute the CRC in the CX before
+			  */
+#ifndef COMPUTE_INIT_METHOD
+			dev_info(info->dev, "%s: Try to recovery with CX in fw file...\n",
+				__func__);
+			ret = flashProcedure(info, info->board->fw_name, CRC_CX, 0);
+			dev_info(info->dev, "%s: Refresh panel init data", __func__);
+#else
+			dev_info(info->dev, "%s: Select Full Panel Init...\n", __func__);
+			init_type = SPECIAL_FULL_PANEL_INIT;
+#endif
+		}
+	} else {
+		/* Skip initialization because the real state is unknown */
+		dev_err(info->dev, "%s: Error while executing system reset! ERROR %08X\n",
+			__func__, ret);
+	}
+
+	if (init_type != SPECIAL_FULL_PANEL_INIT) {
+#if defined(PRE_SAVED_METHOD) || defined(COMPUTE_INIT_METHOD)
+		if ((info->systemInfo.u8_cfgAfeVer !=
+			info->systemInfo.u8_cxAfeVer)
+#ifdef COMPUTE_INIT_METHOD
+			|| ((info->systemInfo.u8_mpFlag != MP_FLAG_BOOT) &&
+				(info->systemInfo.u8_mpFlag != MP_FLAG_FACTORY) &&
+				(info->systemInfo.u8_mpFlag != MP_FLAG_NEED_FPI) &&
+				/* If skip_fpi_for_unset_mpflag is not set,
+				 * bypass MP_FLAG_UNSET check.
+				 * If skip_fpi_for_unset_mpflag is set,
+				 * then check if mpFlag != MP_FLAG_UNSET.
+				 */
+				((info->board->skip_fpi_for_unset_mpflag == false) ||
+				 (info->systemInfo.u8_mpFlag != MP_FLAG_UNSET))
+				)
+#endif
+			) {
+			init_type = SPECIAL_FULL_PANEL_INIT;
+			dev_err(info->dev,
+				"%s: Different CX AFE Ver: %02X != %02X or MpFlag = %02X... Execute FULL Panel Init!\n",
+				__func__, info->systemInfo.u8_cfgAfeVer,
+				info->systemInfo.u8_cxAfeVer,
+				info->systemInfo.u8_mpFlag);
+		} else
+#endif
+		if (info->systemInfo.u8_cfgAfeVer !=
+			info->systemInfo.u8_panelCfgAfeVer) {
+			init_type = SPECIAL_PANEL_INIT;
+			dev_err(info->dev, "%s: Different Panel AFE Ver: %02X != %02X... Execute Panel Init!\n",
+				__func__, info->systemInfo.u8_cfgAfeVer,
+				info->systemInfo.u8_panelCfgAfeVer);
+		}
+	}
+
+out:
+
+	if (init_type != NO_INIT) { /* initialization status not correct or
+				     * after FW complete update, do
+				     * initialization.
+				     */
+		error = fts_chip_initialization(info, init_type);
+		if (error < OK) {
+			dev_err(info->dev, "%s: Cannot initialize the chip ERROR %08X\n",
+				__func__, error);
+		}
+
+		/* Reset after initialization */
+		ret = fts_system_reset(info);
+		if (ret < OK) {
+			dev_err(info->dev, "%s: Reset failed, ERROR %08X\n", __func__,
+				ret);
+		}
+	}
+
+	error = fts_init_sensing(info);
+	if (error < OK) {
+		dev_err(info->dev, "Cannot initialize the hardware device ERROR %08X\n",
+			error);
+	}
+
+	dev_err(info->dev, "Fw Update Finished! error = %08X\n", error);
+	return error;
+}
+
+/**
+  *	Function called by the delayed workthread executed after the probe in
+  * order to perform the fw update flow
+  *	@see  fts_fw_update()
+  */
+static void fts_fw_update_auto(struct work_struct *work)
+{
+	struct delayed_work *fwu_work = container_of(work, struct delayed_work,
+						     work);
+	struct fts_ts_info *info = container_of(fwu_work, struct fts_ts_info,
+						fwu_work);
+
+	fts_set_bus_ref(info, FTS_BUS_REF_FW_UPDATE, true);
+	fts_fw_update(info);
+	fts_set_bus_ref(info, FTS_BUS_REF_FW_UPDATE, false);
+}
+
+/**
+ *  Save the golden MS raw data to the touch IC if firmware has separated it
+ *  from the PI process.
+ */
+int save_golden_ms_raw(struct fts_ts_info *info)
+{
+	u8 cmd[3] = {0xC0, 0x01, 0x01};
+	int ret = 0;
+
+	ret = fts_write(info, cmd, 3);
+	if (ret < 0)
+		dev_err(info->dev, "Fail to save golden MS raw, ret = %d", ret);
+	else {
+		mdelay(150);	/* Time to secure the saving process (90 ms) */
+		dev_info(info->dev, "Golden MS raw is saved!");
+	}
+	return ret;
+}
+
+/* TODO: define if need to do the full mp at the boot */
+/**
+  *	Execute the initialization of the IC (supporting a retry mechanism),
+  * checking also the resulting data
+  *	@see  production_test_main()
+  */
+static int fts_chip_initialization(struct fts_ts_info *info, int init_type)
+{
+	int ret2 = 0;
+	int retry;
+	int initretrycnt = 0;
+#ifdef COMPUTE_INIT_METHOD
+	const char *limits_file = info->board->limits_name;
+#endif
+
+	/* initialization error, retry initialization */
+	for (retry = 0; retry < RETRY_INIT_BOOT; retry++) {
+#ifndef COMPUTE_INIT_METHOD
+		ret2 = production_test_initialization(info, init_type);
+		if (ret2 == OK &&
+		    info->board->separate_save_golden_ms_raw_cmd)
+			save_golden_ms_raw(info);
+#else
+		ret2 = production_test_main(info, limits_file, 1, init_type,
+					    MP_FLAG_BOOT);
+#endif
+		if (ret2 == OK)
+			break;
+		initretrycnt++;
+		dev_err(info->dev, "initialization cycle count = %04d - ERROR %08X\n",
+			initretrycnt, ret2);
+		fts_chip_powercycle(info);
+	}
+
+	if (ret2 < OK)	/* initialization error */
+		dev_err(info->dev, "fts initialization failed %d times\n",
+			RETRY_INIT_BOOT);
+
+	return ret2;
+}
+
+
+static irqreturn_t fts_isr(int irq, void *handle)
+{
+	struct fts_ts_info *info = handle;
+
+	info->timestamp = ktime_get();
+
+	return IRQ_WAKE_THREAD;
+}
+
+/**
+  * Initialize the dispatch table with the event handlers for any possible event
+  * ID
+  * Set IRQ pin behavior (level triggered low)
+  * Register top half interrupt handler function.
+  * @see fts_interrupt_handler()
+  */
+static int fts_interrupt_install(struct fts_ts_info *info)
+{
+	int i, error = 0;
+
+	info->event_dispatch_table = kzalloc(sizeof(event_dispatch_handler_t) *
+					     NUM_EVT_ID, GFP_KERNEL);
+
+	if (!info->event_dispatch_table) {
+		dev_err(info->dev, "OOM allocating event dispatch table\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < NUM_EVT_ID; i++)
+		info->event_dispatch_table[i] = fts_nop_event_handler;
+
+	install_handler(info, ENTER_POINT, enter_pointer);
+	install_handler(info, LEAVE_POINT, leave_pointer);
+	install_handler(info, MOTION_POINT, motion_pointer);
+	install_handler(info, ERROR, error);
+	install_handler(info, CONTROLLER_READY, controller_ready);
+	install_handler(info, STATUS_UPDATE, status);
+	install_handler(info, USER_REPORT, user_report);
+
+	/* disable interrupts in any case */
+	error = fts_enableInterrupt(info, false);
+	if (error) {
+		return error;
+	}
+
+	error = request_threaded_irq(info->client->irq, fts_isr,
+			fts_interrupt_handler, IRQF_ONESHOT | IRQF_TRIGGER_LOW,
+			FTS_TS_DRV_NAME, info);
+	info->irq_enabled = true;
+
+	if (error) {
+		dev_err(info->dev, "Request irq failed\n");
+		kfree(info->event_dispatch_table);
+	}
+
+	return error;
+}
+
+/**
+  *	Clean the dispatch table and the free the IRQ.
+  *	This function is called when the driver need to be removed
+  */
+static void fts_interrupt_uninstall(struct fts_ts_info *info)
+{
+	fts_enableInterrupt(info, false);
+
+	kfree(info->event_dispatch_table);
+
+	free_irq(info->client->irq, info);
+}
+
+/**@}*/
+
+/**
+  * This function try to attempt to communicate with the IC for the first time
+  * during the boot up process in order to read the necessary info for the
+  * following stages.
+  * The function execute a system reset, read fundamental info (system info)
+  * @return OK if success or an error code which specify the type of error
+  */
+static int fts_init(struct fts_ts_info *info)
+{
+	int error;
+
+
+	error = fts_system_reset(info);
+	if (error < OK && isI2cError(error)) {
+		dev_err(info->dev, "Cannot reset the device! ERROR %08X\n", error);
+		return error;
+	} else {
+		if (error == (ERROR_TIMEOUT | ERROR_SYSTEM_RESET_FAIL)) {
+			dev_err(info->dev, "Setting default Sys INFO!\n");
+			error = defaultSysInfo(info, 0);
+		} else {
+			error = readSysInfo(info, 0);	/* system reset OK */
+			if (error < OK) {
+				if (!isI2cError(error))
+					error = OK;
+				dev_err(info->dev, "Cannot read Sys Info! ERROR %08X\n",
+					error);
+			}
+		}
+	}
+
+	return error;
+}
+
+/**
+  * Execute a power cycle in the IC, toggling the power lines (AVDD and DVDD)
+  * @param info pointer to fts_ts_info struct which contain information of the
+  * regulators
+  * @return 0 if success or another value if fail
+  */
+int fts_chip_powercycle(struct fts_ts_info *info)
+{
+	int error = 0;
+
+	dev_info(info->dev, "%s: Power Cycle Starting...\n", __func__);
+	dev_info(info->dev, "%s: Disabling IRQ...\n", __func__);
+	/** if IRQ pin is short with DVDD a call to the ISR will triggered when
+	  * the regulator is turned off if IRQ not disabled */
+	fts_enableInterrupt(info, false);
+
+	if (info->vdd_reg) {
+		error = regulator_disable(info->vdd_reg);
+		if (error < 0)
+			dev_err(info->dev, "%s: Failed to disable DVDD regulator\n",
+				__func__);
+	}
+
+	if (info->avdd_reg) {
+		error = regulator_disable(info->avdd_reg);
+		if (error < 0)
+			dev_err(info->dev, "%s: Failed to disable AVDD regulator\n",
+				__func__);
+	}
+
+	if (info->board->reset_gpio)
+		gpiod_set_value(info->board->reset_gpio, 1);
+	else
+		mdelay(300);
+
+	/* in FTI power up first the digital and then the analog */
+	if (info->vdd_reg) {
+		error = regulator_enable(info->vdd_reg);
+		if (error < 0)
+			dev_err(info->dev, "%s: Failed to enable DVDD regulator\n",
+				__func__);
+	}
+
+	mdelay(1);
+
+	if (info->avdd_reg) {
+		error = regulator_enable(info->avdd_reg);
+		if (error < 0)
+			dev_err(info->dev, "%s: Failed to enable AVDD regulator\n",
+				__func__);
+	}
+
+	mdelay(5);	/* time needed by the regulators for reaching the regime
+			 * values */
+
+
+	if (info->board->reset_gpio) {
+		mdelay(10);	/* time to wait before bring up the reset
+				  * gpio after the power up of the regulators */
+		gpiod_set_value(info->board->reset_gpio, 0);
+	}
+
+	release_all_touches(info);
+
+	dev_info(info->dev, "%s: Power Cycle Finished! ERROR CODE = %08x\n",
+		__func__, error);
+	setSystemResetedUp(info, 1);
+	setSystemResetedDown(info, 1);
+	return error;
+}
+
+
+/**
+  * Complete the boot up process, initializing the sensing of the IC according
+  * to the current setting chosen by the host
+  * Register the notifier for the suspend/resume actions and the event handler
+  * @return OK if success or an error code which specify the type of error
+  */
+static int fts_init_sensing(struct fts_ts_info *info)
+{
+	int error = 0;
+
+	error |= fts_interrupt_install(info);	  /* register event handler */
+	error |= fts_mode_handler(info, 0);	  /* enable the features and
+						   * sensing */
+	error |= fts_enableInterrupt(info, true); /* enable the interrupt */
+
+	if (error < OK)
+		dev_err(info->dev, "%s Init after Probe error (ERROR = %08X)\n",
+			__func__, error);
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	heatmap_enable(info);
+#endif
+
+	return error;
+}
+
+/* TODO: change this function according with the needs of customer in terms
+  * of feature to enable/disable */
+
+/**
+  * @ingroup mode_section
+  * @{
+  */
+/**
+  * The function handle the switching of the mode in the IC enabling/disabling
+  * the sensing and the features set from the host
+  * @param info pointer to fts_ts_info which contains info about the device and
+  * its hw setup
+  * @param force if 1, the enabling/disabling command will be send even
+  * if the feature was already enabled/disabled otherwise it will judge if
+  * the feature changed status or the IC had a system reset
+  * @return OK if success or an error code which specify the type of error
+  */
+static int fts_mode_handler(struct fts_ts_info *info, int force)
+{
+	int res = OK;
+	int ret = OK;
+	u8 settings[4] = { 0 };
+
+	/* disable irq wake because resuming from gesture mode */
+	if (IS_POWER_MODE(info->mode, SCAN_MODE_LOW_POWER) &&
+	    (info->resume_bit == 1))
+		disable_irq_wake(info->client->irq);
+
+	info->mode = MODE_NOTHING;	/* initialize the mode to nothing
+					  * in order to be updated depending
+					  * on the features enabled */
+
+	dev_dbg(info->dev, "%s: Mode Handler starting...\n", __func__);
+	switch (info->resume_bit) {
+	case 0:	/* screen down */
+		dev_dbg(info->dev, "%s: Screen OFF...\n", __func__);
+		/* do sense off in order to avoid the flooding of the fifo with
+		  * touch events if someone is touching the panel during suspend
+		  **/
+		dev_info(info->dev, "%s: Sense OFF!\n", __func__);
+		/* for speed reason (no need to check echo in this case and
+		  * interrupt can be enabled) */
+		ret = setScanMode(info, SCAN_MODE_ACTIVE, 0x00);
+		res |= ret;	/* to avoid warning unsused ret variable when a
+				  * ll the features are disabled */
+
+#ifdef GESTURE_MODE
+		if (info->gesture_enabled == 1) {
+			dev_info(info->dev, "%s: enter in gesture mode !\n",
+				 __func__);
+			res = enterGestureMode(info, isSystemResettedDown(info));
+			if (res >= OK) {
+				enable_irq_wake(info->client->irq);
+				fromIDtoMask(FEAT_SEL_GESTURE,
+					     (u8 *)&info->mode,
+					     sizeof(info->mode));
+				MODE_LOW_POWER(info->mode, 0);
+			} else
+				dev_err(info->dev, "%s: enterGestureMode failed! ERROR %08X recovery in senseOff...\n",
+					__func__, res);
+		}
+#endif
+
+		setSystemResetedDown(info, 0);
+		break;
+
+	case 1:	/* screen up */
+		dev_dbg(info->dev, "%s: Screen ON...\n", __func__);
+
+#ifdef GLOVE_MODE
+		if ((info->glove_enabled == FEAT_ENABLE) || force == 1) {
+			dev_info(info->dev, "%s: Glove Mode setting...\n", __func__);
+			settings[0] = info->glove_enabled;
+			/* required to satisfy also the disable case */
+			ret = setFeatures(info, FEAT_SEL_GLOVE, settings, 1);
+			if (ret < OK)
+				dev_err(info->dev, "%s: error during setting GLOVE_MODE! ERROR %08X\n",
+					__func__, ret);
+			res |= ret;
+
+			if (ret >= OK && info->glove_enabled == FEAT_ENABLE) {
+				fromIDtoMask(FEAT_SEL_GLOVE, (u8 *)&info->mode,
+					     sizeof(info->mode));
+				dev_info(info->dev, "%s: GLOVE_MODE Enabled!\n", __func__);
+			} else
+				dev_info(info->dev, "%s: GLOVE_MODE Disabled!\n", __func__);
+		}
+
+#endif
+
+#ifdef COVER_MODE
+		if ((info->cover_enabled == FEAT_ENABLE || force == 1) {
+			dev_info(info->dev, "%s: Cover Mode setting...\n", __func__);
+			settings[0] = info->cover_enabled;
+			ret = setFeatures(info, FEAT_SEL_COVER, settings, 1);
+			if (ret < OK)
+				dev_err(info->dev, "%s: error during setting COVER_MODE! ERROR %08X\n",
+					__func__, ret);
+			res |= ret;
+
+			if (ret >= OK && info->cover_enabled == FEAT_ENABLE) {
+				fromIDtoMask(FEAT_SEL_COVER, (u8 *)&info->mode,
+					     sizeof(info->mode));
+				dev_info(info->dev, "%s: COVER_MODE Enabled!\n", __func__);
+			} else
+				dev_info(info->dev, "%s: COVER_MODE Disabled!\n", __func__);
+		}
+#endif
+#ifdef CHARGER_MODE
+		if ((info->charger_enabled > 0) ||
+		    force == 1) {
+			dev_info(info->dev, "%s: Charger Mode setting...\n", __func__);
+
+			settings[0] = info->charger_enabled;
+			ret = setFeatures(info, FEAT_SEL_CHARGER, settings, 1);
+			if (ret < OK)
+				dev_err(info->dev, "%s: error during setting CHARGER_MODE! ERROR %08X\n",
+					__func__, ret);
+			res |= ret;
+
+			if (ret >= OK && info->charger_enabled == FEAT_ENABLE) {
+				fromIDtoMask(FEAT_SEL_CHARGER,
+					     (u8 *)&info->mode,
+					     sizeof(info->mode));
+				dev_info(info->dev, "%s: CHARGER_MODE Enabled!\n",
+					__func__);
+			} else
+				dev_info(info->dev, "%s: CHARGER_MODE Disabled!\n",
+					__func__);
+		}
+#endif
+
+
+#ifdef GRIP_MODE
+		if ((info->grip_enabled == FEAT_ENABLE || force == 1) {
+			dev_info(info->dev, "%s: Grip Mode setting...\n", __func__);
+			settings[0] = info->grip_enabled;
+			ret = setFeatures(info, FEAT_SEL_GRIP, settings, 1);
+			if (ret < OK)
+				dev_err(info->dev, "%s: error during setting GRIP_MODE! ERROR %08X\n",
+					__func__, ret);
+			res |= ret;
+
+			if (ret >= OK && info->grip_enabled == FEAT_ENABLE) {
+				fromIDtoMask(FEAT_SEL_GRIP, (u8 *)&info->mode,
+					     sizeof(info->mode));
+				dev_info(info->dev, "%s: GRIP_MODE Enabled!\n", __func__);
+			} else
+				dev_info(info->dev, "%s: GRIP_MODE Disabled!\n", __func__);
+		}
+#endif
+		/* If some selective scan want to be enabled can be done
+		  * an or of the following options
+		  */
+		/* settings[0] = ACTIVE_MULTI_TOUCH | ACTIVE_KEY | */
+		/*		ACTIVE_HOVER | ACTIVE_PROXIMITY | */
+		/*		ACTIVE_FORCE; */
+		settings[0] = 0xFF;	/* enable all the possible scans mode
+					  * supported by the config */
+		dev_info(info->dev, "%s: Sense ON!\n", __func__);
+		res |= setScanMode(info, SCAN_MODE_ACTIVE, settings[0]);
+		info->mode |= (SCAN_MODE_ACTIVE << 24);
+		MODE_ACTIVE(info->mode, settings[0]);
+
+
+		setSystemResetedUp(info, 0);
+		break;
+
+	default:
+		dev_err(info->dev, "%s: invalid resume_bit value = %d! ERROR %08X\n",
+			__func__, info->resume_bit, ERROR_OP_NOT_ALLOW);
+		res = ERROR_OP_NOT_ALLOW;
+	}
+
+
+	dev_dbg(info->dev, "%s: Mode Handler finished! res = %08X mode = %08X\n",
+		__func__, res, info->mode);
+	return res;
+}
+
+/* Report a finger down event on the long press gesture area then immediately
+ * report a cancel event(MT_TOOL_PALM).
+ */
+static void report_cancel_event(struct fts_ts_info *info)
+{
+	dev_info(info->dev, "%s\n", __func__);
+
+	mutex_lock(&info->input_report_mutex);
+
+	/* Finger down on UDFPS area. */
+	input_mt_slot(info->input_dev, 0);
+	input_report_key(info->input_dev, BTN_TOUCH, 1);
+	input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 1);
+	input_report_abs(info->input_dev, ABS_MT_POSITION_X, info->board->udfps_x);
+	input_report_abs(info->input_dev, ABS_MT_POSITION_Y, info->board->udfps_y);
+	input_report_abs(info->input_dev, ABS_MT_TOUCH_MAJOR, 200);
+	input_report_abs(info->input_dev, ABS_MT_TOUCH_MINOR, 200);
+#ifndef SKIP_PRESSURE
+	input_report_abs(info->input_dev, ABS_MT_PRESSURE, 1);
+#endif
+	input_report_abs(info->input_dev, ABS_MT_ORIENTATION, 0);
+	input_sync(info->input_dev);
+
+	/* Report MT_TOOL_PALM for canceling the touch event. */
+	input_mt_slot(info->input_dev, 0);
+	input_report_key(info->input_dev, BTN_TOUCH, 1);
+	input_mt_report_slot_state(info->input_dev, MT_TOOL_PALM, 1);
+	input_sync(info->input_dev);
+
+	/* Release touches. */
+	input_mt_slot(info->input_dev, 0);
+	input_report_abs(info->input_dev, ABS_MT_PRESSURE, 0);
+	input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);
+	input_report_abs(info->input_dev, ABS_MT_TRACKING_ID, -1);
+	input_report_key(info->input_dev, BTN_TOUCH, 0);
+	input_sync(info->input_dev);
+
+	mutex_unlock(&info->input_report_mutex);
+}
+
+/* Check the finger status on long press gesture area. */
+static void check_finger_status(struct fts_ts_info *info)
+{
+	u8 command[3] = { FTS_CMD_SYSTEM, SYS_CMD_LOAD_DATA, LOAD_DEBUG_INFO };
+	u8 data[DEBUG_INFO_SIZE] = { 0 };
+	ktime_t ktime_start = ktime_get();
+	int retry = 0;
+	int ret;
+
+	dev_info(info->dev, "%s\n", __func__);
+
+	while (ktime_ms_delta(ktime_get(), ktime_start) < 500) {
+		retry++;
+		ret = fts_write(info, command, ARRAY_SIZE(command));
+		if (ret < OK) {
+			dev_err(info->dev,
+				"%s: error while writing the sys cmd ERROR %08X\n",
+				__func__, ret);
+			msleep(10);
+			continue;
+		}
+
+		ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16,
+					ADDR_FRAMEBUFFER, data, DEBUG_INFO_SIZE,
+					DUMMY_FRAMEBUFFER);
+		if (ret < OK) {
+			dev_err(info->dev,
+				"%s: error while write/read cmd ERROR %08X\n",
+				__func__, ret);
+			msleep(10);
+			continue;
+		}
+
+		/* Check header. */
+		if (data[0] != HEADER_SIGNATURE || data[1] != LOAD_DEBUG_INFO) {
+			dev_err(info->dev,
+				"%s: Fail to get debug info, header = %#x %#x, read next frame.\n",
+				__func__, data[0], data[1]);
+			msleep(10);
+			continue;
+		}
+
+		/* Check scan mode (data[4]).
+		0x05: low power detect mode.
+		0x06: low power active mode. */
+		if (data[4] != DEBUG_INFO_LP_DETECT && data[4] != DEBUG_INFO_LP_ACTIVE)
+			return;
+
+		/* Check finger count (data[60]). */
+		if (data[60] == 0) {
+			/* Report cancel event when finger count is 0. */
+			report_cancel_event(info);
+			break;
+		} else if (data[60] > 1) {
+			/* Skip the process when the count is abnormal. */
+			break;
+		}
+		msleep(10);
+	}
+}
+
+/**
+  * Configure the switch GPIO to toggle bus master between AP and SLPI.
+  * gpio_value takes one of
+  * { FTS_SWITCH_GPIO_VALUE_SLPI_MASTER, FTS_SWITCH_GPIO_VALUE_AP_MASTER }
+  */
+static void fts_set_switch_gpio(struct fts_ts_info *info, int gpio_value)
+{
+	int retval;
+
+	dev_dbg(info->dev, "%s: toggling i2c switch to %s\n", __func__,
+		gpio_value == FTS_SWITCH_GPIO_VALUE_AP_MASTER ? "AP" : "SLPI");
+
+	retval = gpiod_direction_output(info->board->switch_gpio, gpio_value);
+	if (retval < 0)
+		dev_err(info->dev, "%s: Failed to toggle switch_gpio, err = %d\n",
+			__func__, retval);
+}
+
+/**
+  * Resume work function which perform a system reset, clean all the touches
+  * from the linux input system and prepare the ground for enabling the sensing
+  */
+static void fts_resume_work(struct work_struct *work)
+{
+	struct fts_ts_info *info;
+
+	info = container_of(work, struct fts_ts_info, resume_work);
+
+	if (!info->sensor_sleep)
+		return;
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_TBN)
+	if (info->tbn_register_mask)
+		tbn_request_bus(info->tbn_register_mask);
+#endif
+
+	fts_set_switch_gpio(info, FTS_SWITCH_GPIO_VALUE_AP_MASTER);
+
+	fts_pinctrl_setup(info, true);
+
+	__pm_wakeup_event(info->wakesrc, jiffies_to_msecs(HZ));
+
+	info->resume_bit = 1;
+
+	if (info->board->udfps_x != 0 && info->board->udfps_y != 0)
+		check_finger_status(info);
+
+	fts_system_reset(info);
+
+	release_all_touches(info);
+
+	fts_mode_handler(info, 0);
+
+	info->sensor_sleep = false;
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	/* heatmap must be enabled after every chip reset (fts_system_reset) */
+	heatmap_enable(info);
+#endif
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	/* Set touch_offload configuration */
+	if (info->offload.offload_running) {
+		dev_info(info->dev, "%s: applying touch_offload settings.\n",
+			 __func__);
+		if (info->offload.config.filter_grip) {
+			/* The grip disable command will not take effect unless
+			 * it is delayed ~100ms.
+			 */
+			queue_delayed_work(info->event_wq,
+					   &info->offload_resume_work,
+					   msecs_to_jiffies(100));
+		}
+	}
+#endif
+
+	fts_enableInterrupt(info, true);
+
+	complete_all(&info->bus_resumed);
+}
+
+/**
+  * Suspend work function which clean all the touches from Linux input system
+  * and prepare the ground to disabling the sensing or enter in gesture mode
+  */
+static void fts_suspend_work(struct work_struct *work)
+{
+	struct fts_ts_info *info;
+
+	info = container_of(work, struct fts_ts_info, suspend_work);
+
+	if (info->sensor_sleep)
+		return;
+
+	reinit_completion(&info->bus_resumed);
+
+	__pm_stay_awake(info->wakesrc);
+
+	info->resume_bit = 0;
+
+	fts_mode_handler(info, 0);
+
+	release_all_touches(info);
+
+	fts_enableInterrupt(info, false);
+
+	/* Flush any outstanding touch events */
+	fts_system_reset(info);
+	flushFIFO(info);
+
+	fts_pinctrl_setup(info, false);
+
+	fts_set_switch_gpio(info, FTS_SWITCH_GPIO_VALUE_SLPI_MASTER);
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_TBN)
+	if (info->tbn_register_mask)
+		tbn_release_bus(info->tbn_register_mask);
+#endif
+
+	info->sensor_sleep = true;
+	__pm_relax(info->wakesrc);
+}
+/** @}*/
+
+
+static void fts_aggregate_bus_state(struct fts_ts_info *info)
+{
+	dev_dbg(info->dev, "%s: bus_refmask = 0x%02X.\n", __func__,
+		 info->bus_refmask);
+
+	/* Complete or cancel any outstanding transitions */
+	cancel_work_sync(&info->suspend_work);
+	cancel_work_sync(&info->resume_work);
+
+	if ((info->bus_refmask == 0 && info->sensor_sleep) ||
+	    (info->bus_refmask != 0 && !info->sensor_sleep))
+		return;
+
+	if (info->bus_refmask == 0) {
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+		cancel_delayed_work_sync(&info->offload_resume_work);
+#endif
+		info->enable_palm_data_dump = false;
+		cancel_delayed_work_sync(&info->palm_data_dump_work);
+		queue_work(info->event_wq, &info->suspend_work);
+	} else
+		queue_work(info->event_wq, &info->resume_work);
+}
+
+int fts_set_bus_ref(struct fts_ts_info *info, u16 ref, bool enable)
+{
+	int result = OK;
+
+	mutex_lock(&info->bus_mutex);
+
+	if ((enable && (info->bus_refmask & ref)) ||
+	    (!enable && !(info->bus_refmask & ref))) {
+		dev_warn(info->dev, "%s: reference is unexpectedly set: mask=0x%04X, ref=0x%04X, enable=%d.\n",
+			__func__, info->bus_refmask, ref, enable);
+		mutex_unlock(&info->bus_mutex);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	if (enable) {
+		/* IRQs can only keep the bus active. IRQs received while the
+		 * bus is transferred to SLPI should be ignored.
+		 */
+		if (ref == FTS_BUS_REF_IRQ && info->bus_refmask == 0)
+			result = ERROR_OP_NOT_ALLOW;
+		else
+			info->bus_refmask |= ref;
+	} else
+		info->bus_refmask &= ~ref;
+	fts_aggregate_bus_state(info);
+
+	mutex_unlock(&info->bus_mutex);
+
+	/* When triggering a wake, wait up to one second to resume. SCREEN_ON
+	 * and IRQ references do not need to wait.
+	 */
+	if (enable && ref != FTS_BUS_REF_SCREEN_ON && ref != FTS_BUS_REF_IRQ) {
+		wait_for_completion_timeout(&info->bus_resumed, HZ);
+		if (info->sensor_sleep) {
+			dev_err(info->dev, "%s: Failed to wake the touch bus: mask=0x%04X, ref=0x%04X, enable=%d.\n",
+			       __func__, info->bus_refmask, ref, enable);
+			result = ERROR_TIMEOUT;
+		}
+	}
+
+	return result;
+}
+
+static void fts_set_display_state(struct fts_ts_info *info,
+	enum fts_display_state display_state)
+{
+	if (info->display_state == display_state)
+		return;
+
+	switch (display_state) {
+	case FTS_DISPLAY_STATE_OFF:
+		dev_info(info->dev, "%s: screen-off.\n", __func__);
+		fts_set_bus_ref(info, FTS_BUS_REF_SCREEN_ON, false);
+		break;
+	case FTS_DISPLAY_STATE_ON:
+		dev_info(info->dev, "%s: screen-on.\n", __func__);
+		fts_set_bus_ref(info, FTS_BUS_REF_SCREEN_ON, true);
+		break;
+	default:
+		dev_err(info->dev,
+			"%s: Unexpected value(0x%X) of display state parameter.\n",
+			__func__, display_state);
+		return;
+	}
+	info->display_state = display_state;
+}
+
+/**
+  * From the name of the power regulator get/put the actual regulator structs
+  * (copying their references into fts_ts_info variable)
+  * @param info pointer to fts_ts_info which contains info about the device and
+  * its hw setup
+  * @param get if 1, the regulators are get otherwise they are put (released)
+  * back to the system
+  * @return OK if success or an error code which specify the type of error
+  */
+static int fts_get_reg(struct fts_ts_info *info, bool get)
+{
+	int retval;
+
+	if (!get) {
+		retval = 0;
+		goto regulator_put;
+	}
+
+	if (of_property_read_bool(info->dev->of_node, "vdd-supply")) {
+		info->vdd_reg = regulator_get(info->dev, "vdd");
+		if (IS_ERR(info->vdd_reg)) {
+			dev_err(info->dev, "%s: Failed to get power regulator\n", __func__);
+			retval = -EPROBE_DEFER;
+			goto regulator_put;
+		}
+	}
+
+	if (of_property_read_bool(info->dev->of_node, "avdd-supply")) {
+		info->avdd_reg = regulator_get(info->dev, "avdd");
+		if (IS_ERR(info->avdd_reg)) {
+			dev_err(info->dev, "%s: Failed to get bus pullup regulator\n",
+			__func__);
+			retval = -EPROBE_DEFER;
+			goto regulator_put;
+		}
+	}
+
+	return OK;
+
+regulator_put:
+	if (info->vdd_reg) {
+		regulator_put(info->vdd_reg);
+		info->vdd_reg = NULL;
+	}
+
+	if (info->avdd_reg) {
+		regulator_put(info->avdd_reg);
+		info->avdd_reg = NULL;
+	}
+
+	return retval;
+}
+
+
+/**
+  * Enable or disable the power regulators
+  * @param info pointer to fts_ts_info which contains info about the device and
+  * its hw setup
+  * @param enable if 1, the power regulators are turned on otherwise they are
+  * turned off
+  * @return OK if success or an error code which specify the type of error
+  */
+static int fts_enable_reg(struct fts_ts_info *info, bool enable)
+{
+	int retval;
+
+	if (!enable) {
+		retval = 0;
+		goto disable_pwr_reg;
+	}
+
+	if (info->vdd_reg) {
+		retval = regulator_enable(info->vdd_reg);
+		if (retval < 0) {
+			dev_err(info->dev, "%s: Failed to enable bus regulator\n",
+				__func__);
+			goto exit;
+		}
+	}
+
+	if (info->avdd_reg) {
+		retval = regulator_enable(info->avdd_reg);
+		if (retval < 0) {
+			dev_err(info->dev, "%s: Failed to enable power regulator\n",
+				__func__);
+			goto disable_bus_reg;
+		}
+	}
+
+	return OK;
+
+disable_pwr_reg:
+	if (info->avdd_reg)
+		regulator_disable(info->avdd_reg);
+
+disable_bus_reg:
+	if (info->vdd_reg)
+		regulator_disable(info->vdd_reg);
+
+exit:
+	return retval;
+}
+
+/**
+  * Configure a GPIO according to the parameters
+  * @param gpio a gpio descriptor
+  * @param config if true, the gpio is set up otherwise it is free
+  * @param dir direction of the gpio, 0 = in, 1 = out
+  * @param state initial value (if the direction is in, this parameter is
+  * ignored)
+  * @param device
+  * return error code
+  */
+static int fts_gpio_setup(struct gpio_desc *gpio, bool config, int dir,
+			  int state, struct device *dev)
+{
+	int retval = 0;
+
+	if (config) {
+		unsigned char buf[16];
+
+		scnprintf(buf, sizeof(buf), "fts_gpio_%u\n", desc_to_gpio(gpio));
+		gpiod_set_consumer_name(gpio, buf);
+
+		if (dir == 0)
+			retval = gpiod_direction_input(gpio);
+		else
+			retval = gpiod_direction_output(gpio, state);
+		if (retval) {
+			pr_err("%s: Failed to set gpio %d direction: %d",
+				__func__, desc_to_gpio(gpio), retval);
+			return retval;
+		}
+	} else {
+		devm_gpiod_put(dev, gpio);
+	}
+
+	return retval;
+}
+
+/**
+  * Setup the IRQ and RESET (if present) gpios.
+  * If the Reset Gpio is present it will perform a cycle HIGH-LOW-HIGH in order
+  * to assure that the IC has been reset properly
+  */
+static int fts_set_gpio(struct fts_ts_info *info)
+{
+	int retval;
+	struct fts_hw_platform_data *bdata =
+		info->board;
+
+	retval = fts_gpio_setup(bdata->irq_gpio, true, 0, 0, info->dev);
+	if (retval < 0) {
+		dev_err(info->dev, "%s: Failed to configure irq GPIO\n", __func__);
+		goto err_gpio_irq;
+	}
+
+	if (bdata->switch_gpio) {
+		retval = fts_gpio_setup(bdata->switch_gpio, true, 1,
+					FTS_SWITCH_GPIO_VALUE_AP_MASTER, info->dev);
+		if (retval < 0)
+			dev_err(info->dev, "%s: Failed to configure I2C switch\n",
+				__func__);
+	}
+
+#ifdef DYNAMIC_REFRESH_RATE
+	if (bdata->disp_rate_gpio) {
+		retval = fts_gpio_setup(bdata->disp_rate_gpio, true, 1,
+					(info->display_refresh_rate == 90), info->dev);
+		if (retval < 0)
+			dev_err(info->dev, "%s: Failed to configure disp_rate_gpio\n",
+				__func__);
+	}
+#endif
+
+	if (bdata->reset_gpio) {
+		retval = fts_gpio_setup(bdata->reset_gpio, true, 1, 0, info->dev);
+		if (retval < 0) {
+			dev_err(info->dev, "%s: Failed to configure reset GPIO\n",
+				__func__);
+			goto err_gpio_reset;
+		}
+
+		gpiod_set_value(bdata->reset_gpio, 1);
+		mdelay(10);
+		gpiod_set_value(bdata->reset_gpio, 0);
+	}
+
+	return OK;
+
+err_gpio_reset:
+	fts_gpio_setup(bdata->irq_gpio, false, 0, 0, info->dev);
+	bdata->irq_gpio = NULL;
+err_gpio_irq:
+	return retval;
+}
+
+/** Set pin state to active or suspend
+  * @param active 1 for active while 0 for suspend
+  */
+static void fts_pinctrl_setup(struct fts_ts_info *info, bool active)
+{
+	int retval;
+
+	if (info->ts_pinctrl) {
+		/*
+		 * Pinctrl setup is optional.
+		 * If pinctrl is found, set pins to active/suspend state.
+		 * Otherwise, go on without showing error messages.
+		 */
+		retval = pinctrl_select_state(info->ts_pinctrl, active ?
+				info->pinctrl_state_active :
+				info->pinctrl_state_suspend);
+		if (retval < 0) {
+			dev_err(info->dev, "Failed to select %s pinstate %d\n", active ?
+				PINCTRL_STATE_ACTIVE : PINCTRL_STATE_SUSPEND,
+				retval);
+		}
+	} else {
+		dev_warn(info->dev, "ts_pinctrl is NULL\n");
+	}
+}
+
+/**
+  * Get/put the touch pinctrl from the specific names. If pinctrl is used, the
+  * active and suspend pin control names and states are necessary.
+  * @param info pointer to fts_ts_info which contains info about the device and
+  * its hw setup
+  * @param get if 1, the pinctrl is get otherwise it is put (released) back to
+  * the system
+  * @return OK if success or an error code which specify the type of error
+  */
+static int fts_pinctrl_get(struct fts_ts_info *info, bool get)
+{
+	int retval;
+
+	if (!get) {
+		retval = 0;
+		goto pinctrl_put;
+	}
+
+	info->ts_pinctrl = devm_pinctrl_get(info->dev);
+	if (IS_ERR_OR_NULL(info->ts_pinctrl)) {
+		retval = PTR_ERR(info->ts_pinctrl);
+		dev_info(info->dev, "Target does not use pinctrl %d\n", retval);
+		goto err_pinctrl_get;
+	}
+
+	info->pinctrl_state_active
+		= pinctrl_lookup_state(info->ts_pinctrl, PINCTRL_STATE_ACTIVE);
+	if (IS_ERR_OR_NULL(info->pinctrl_state_active)) {
+		retval = PTR_ERR(info->pinctrl_state_active);
+		dev_err(info->dev, "Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_ACTIVE, retval);
+		goto err_pinctrl_lookup;
+	}
+
+	info->pinctrl_state_suspend
+		= pinctrl_lookup_state(info->ts_pinctrl, PINCTRL_STATE_SUSPEND);
+	if (IS_ERR_OR_NULL(info->pinctrl_state_suspend)) {
+		retval = PTR_ERR(info->pinctrl_state_suspend);
+		dev_err(info->dev, "Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_SUSPEND, retval);
+		goto err_pinctrl_lookup;
+	}
+
+	info->pinctrl_state_release
+		= pinctrl_lookup_state(info->ts_pinctrl, PINCTRL_STATE_RELEASE);
+	if (IS_ERR_OR_NULL(info->pinctrl_state_release)) {
+		retval = PTR_ERR(info->pinctrl_state_release);
+		dev_warn(info->dev, "Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_RELEASE, retval);
+	}
+
+	return OK;
+
+err_pinctrl_lookup:
+	devm_pinctrl_put(info->ts_pinctrl);
+err_pinctrl_get:
+	info->ts_pinctrl = NULL;
+pinctrl_put:
+	if (info->ts_pinctrl) {
+		if (IS_ERR_OR_NULL(info->pinctrl_state_release)) {
+			devm_pinctrl_put(info->ts_pinctrl);
+			info->ts_pinctrl = NULL;
+		} else {
+			if (pinctrl_select_state(
+					info->ts_pinctrl,
+					info->pinctrl_state_release))
+				dev_warn(info->dev, "Failed to select release pinstate\n");
+		}
+	}
+	return retval;
+}
+
+/**
+  * Retrieve and parse the hw information from the device tree node defined in
+  * the system.
+  * the most important information to obtain are: IRQ and RESET gpio numbers,
+  * power regulator names
+  * In the device file node is possible to define additional optional
+  * information
+  * that can be parsed here.
+  */
+static int parse_dt(struct device *dev, struct fts_hw_platform_data *bdata)
+{
+	int retval;
+	int index;
+	struct of_phandle_args panelmap;
+	struct drm_panel *panel = NULL;
+	struct display_timing timing;
+	struct device_node *np = dev->of_node;
+	u32 coords[2];
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	u8 offload_id[4];
+
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+#endif
+
+	if (of_property_read_u8_array(np, "st,dchip_id", bdata->dchip_id, 2)) {
+		dev_err(dev, "st,dchip_id not found. Use default DCHIP_ID <0x%02X 0x%02X>.\n",
+		       DCHIP_ID_0, DCHIP_ID_1);
+		bdata->dchip_id[0] = DCHIP_ID_0;
+		bdata->dchip_id[1] = DCHIP_ID_1;
+		bdata->flash_chunk = FLASH_CHUNK;
+	} else if (bdata->dchip_id[0] == ALIX_DCHIP_ID_0 &&
+		   bdata->dchip_id[1] == ALIX_DCHIP_ID_1)
+		bdata->flash_chunk = (32 * 1024);
+	else
+		bdata->flash_chunk = (64 * 1024);
+	dev_info(dev, "Flash chunk = %d\n", bdata->flash_chunk);
+
+//	if (of_property_read_bool(np, "st,panel_map")) {
+//		for (index = 0 ;; index++) {
+//			retval = of_parse_phandle_with_fixed_args(np,
+//								  "st,panel_map",
+//								  1,
+//								  index,
+//								  &panelmap);
+//			if (retval)
+//				return -EPROBE_DEFER;
+//			panel = of_drm_find_panel(panelmap.np);
+//			of_node_put(panelmap.np);
+//			if (!IS_ERR_OR_NULL(panel)) {
+//				bdata->panel = panel;
+//				bdata->initial_panel_index = panelmap.args[0];
+//				break;
+//			}
+//		}
+//	}
+
+	bdata->switch_gpio = devm_gpiod_get_optional(dev, "st,switch", GPIOD_ASIS);
+	if (IS_ERR(bdata->switch_gpio)) {
+		dev_err(dev, "failed to get switch_gpio: %ld\n",
+			PTR_ERR(bdata->switch_gpio));
+		return PTR_ERR(bdata->switch_gpio);
+	}
+	if (bdata->switch_gpio)
+		dev_info(dev, "switch_gpio = %d\n", desc_to_gpio(bdata->switch_gpio));
+
+	bdata->irq_gpio = devm_gpiod_get(dev, "st,irq", GPIOD_ASIS);
+	if (IS_ERR(bdata->irq_gpio)) {
+		dev_err(dev, "failed to get irq_gpio: %ld\n",
+			PTR_ERR(bdata->irq_gpio));
+		return PTR_ERR(bdata->irq_gpio);
+	}
+	dev_info(dev, "irq_gpio = %d\n", desc_to_gpio(bdata->irq_gpio));
+
+	bdata->reset_gpio = devm_gpiod_get_optional(dev, "st,reset",
+						    GPIOD_ASIS);
+	if (IS_ERR(bdata->reset_gpio)) {
+		dev_err(dev, "failed to get reset_gpio: %ld\n",
+			PTR_ERR(bdata->reset_gpio));
+		return PTR_ERR(bdata->reset_gpio);
+	}
+	if (bdata->reset_gpio)
+		dev_info(dev, "reset_gpio = %d\n", desc_to_gpio(bdata->reset_gpio));
+
+	bdata->disp_rate_gpio = devm_gpiod_get_optional(dev,
+							"st,disp-rate",
+							GPIOD_ASIS);
+	if (IS_ERR(bdata->disp_rate_gpio)) {
+		dev_err(dev, "failed to get disp_rate_gpio: %ld\n",
+			PTR_ERR(bdata->disp_rate_gpio));
+		return PTR_ERR(bdata->disp_rate_gpio);
+	}
+	if (bdata->disp_rate_gpio)
+		dev_info(dev, "disp_rate_gpio = %d\n",
+			 desc_to_gpio(bdata->disp_rate_gpio));
+
+	bdata->auto_fw_update = true;
+	if (of_property_read_bool(np, "st,disable-auto-fw-update")) {
+		bdata->auto_fw_update = false;
+		dev_info(dev, "Automatic firmware update disabled\n");
+	}
+
+	bdata->separate_save_golden_ms_raw_cmd = false;
+	if (of_property_read_bool(np, "st,save-golden-ms-raw")) {
+		bdata->separate_save_golden_ms_raw_cmd = true;
+		dev_info(dev, "Separate \"Save Golden MS Raw\" command from PI command.\n");
+	}
+
+	bdata->skip_fpi_for_unset_mpflag = false;
+	if (of_property_read_bool(np, "st,skip-fpi-for-unset-mpflag")) {
+		bdata->skip_fpi_for_unset_mpflag = true;
+		dev_info(dev, "Skip boot-time FPI for unset MP flag.\n");
+	}
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	bdata->heatmap_mode_full_init = false;
+	if (of_property_read_bool(np, "st,heatmap_mode_full")) {
+		bdata->heatmap_mode_full_init = true;
+		dev_info(dev, "Full heatmap enabled\n");
+	}
+#endif
+
+	if (panel && panel->funcs && panel->funcs->get_timings &&
+	    panel->funcs->get_timings(panel, 1, &timing) > 0) {
+		coords[0] = timing.hactive.max - 1;
+		coords[1] = timing.vactive.max - 1;
+	} else if (of_property_read_u32_array(np, "st,max-coords", coords, 2)) {
+		dev_err(dev, "st,max-coords not found, using 1440x2560\n");
+		coords[0] = 1440 - 1;
+		coords[1] = 2560 - 1;
+	}
+	bdata->x_axis_max = coords[0];
+	bdata->y_axis_max = coords[1];
+
+	if (of_property_read_u32_array(np, "st,udfps-coords", coords, 2)) {
+		dev_err(dev, "st,udfps-coords not found\n");
+		coords[0] = 0;
+		coords[1] = 0;
+	}
+	bdata->udfps_x = coords[0];
+	bdata->udfps_y = coords[1];
+
+	bdata->sensor_inverted_x = 0;
+	if (of_property_read_bool(np, "st,sensor_inverted_x"))
+		bdata->sensor_inverted_x = 1;
+	dev_info(dev, "Sensor inverted x = %u\n", bdata->sensor_inverted_x);
+
+	bdata->sensor_inverted_y = 0;
+	if (of_property_read_bool(np, "st,sensor_inverted_y"))
+		bdata->sensor_inverted_y = 1;
+	dev_info(dev, "Sensor inverted y = %u\n", bdata->sensor_inverted_y);
+
+	bdata->tx_rx_dir_swap = 0;
+	if (of_property_read_bool(np, "st,tx_rx_dir_swap"))
+		bdata->tx_rx_dir_swap = 1;
+	dev_info(dev, "tx_rx_dir_swap = %u\n",
+		bdata->tx_rx_dir_swap);
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	bdata->offload_id = 0;
+	retval = of_property_read_u8_array(np, "st,touch_offload_id",
+					    offload_id, 4);
+	if (retval == -EINVAL)
+		dev_err(dev,
+			"Failed to read st,touch_offload_id with error = %d\n",
+			retval);
+	else {
+		bdata->offload_id = *(u32 *)offload_id;
+		dev_info(dev, "Offload device ID = \"%c%c%c%c\" / 0x%08X\n",
+		    offload_id[0], offload_id[1], offload_id[2], offload_id[3],
+		    bdata->offload_id);
+	}
+#endif
+
+	bdata->device_name = NULL;
+	of_property_read_string(np, "st,device_name",
+				&bdata->device_name);
+	if(!bdata->device_name) {
+		bdata->device_name = FTS_TS_DRV_NAME;
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+		scnprintf(info->offload.device_name, 32, "touch_offload");
+	} else {
+		scnprintf(info->offload.device_name, 32, "touch_offload_%s",
+			  info->board->device_name);
+		info->offload.multiple_panels = true;
+#endif
+	}
+	dev_info(dev, "device_name = %s\n", bdata->device_name);
+
+	if (of_property_read_u8(np, "st,grip_area", &bdata->fw_grip_area))
+		bdata->fw_grip_area = 0;
+	dev_info(dev, "Firmware grip area = %u\n", bdata->fw_grip_area);
+
+	return OK;
+}
+
+/**
+  * Probe function, called when the driver it is matched with a device
+  * with the same name compatible name
+  * This function allocate, initialize all the most important functions and flow
+  * those are used by the driver to operate with the IC.
+  * It allocates device variables, initialize queues and schedule works,
+  * registers the IRQ handler, suspend/resume callbacks, registers the device
+  * to the linux input subsystem etc.
+  */
+#ifdef I2C_INTERFACE
+static int fts_probe(struct i2c_client *client)
+#else
+static int fts_probe(struct spi_device *client)
+#endif
+{
+
+	struct fts_ts_info *info = NULL;
+	int error = 0;
+	struct device_node *dp = client->dev.of_node;
+	int retval;
+	int skip_5_1 = 0;
+	u16 bus_type;
+
+	dev_info(&client->dev, "%s: driver probe begin!\n", __func__);
+	dev_info(&client->dev, "driver ver. %s\n", FTS_TS_DRV_VERSION);
+
+	dev_info(&client->dev, "SET Bus Functionality :\n");
+#ifdef I2C_INTERFACE
+	dev_info(&client->dev, "I2C interface...\n");
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "Unsupported I2C functionality\n");
+		error = -EIO;
+		goto ProbeErrorExit_0;
+	}
+
+	dev_info(&client->dev, "i2c address: %x\n", client->addr);
+	bus_type = BUS_I2C;
+#else
+	if (client->controller->rt == false) {
+		client->rt = true;
+		retval = spi_setup(client);
+		if (retval < 0) {
+			dev_err(&client->dev, "%s: setup SPI rt failed(%d)\n",
+				__func__, retval);
+		}
+	}
+	dev_info(&client->dev, "SPI interface...\n");
+	bus_type = BUS_SPI;
+#endif
+	dev_info(&client->dev, "SET Device driver INFO:\n");
+
+	info = kzalloc(sizeof(struct fts_ts_info), GFP_KERNEL);
+	if (!info) {
+		dev_err(&client->dev, "Out of memory... Impossible to allocate struct info!\n");
+		error = -ENOMEM;
+		goto ProbeErrorExit_0;
+	}
+
+	info->client = client;
+	info->dev = &info->client->dev;
+
+#ifdef DYNAMIC_REFRESH_RATE
+	/* Set default display refresh rate */
+	info->display_refresh_rate = 60;
+#endif
+
+	dev_set_drvdata(info->dev, info);
+
+	if (dp) {
+		info->board = devm_kzalloc(&client->dev,
+					   sizeof(struct fts_hw_platform_data),
+					   GFP_KERNEL);
+		if (!info->board) {
+			dev_err(info->dev, "ERROR:info.board kzalloc failed\n");
+			goto ProbeErrorExit_1;
+		}
+		error = parse_dt(&client->dev, info->board);
+		if (error)
+			goto ProbeErrorExit_1;
+	}
+
+	dev_info(info->dev, "SET Regulators:\n");
+	error = fts_get_reg(info, true);
+	if (error < 0) {
+		dev_err(info->dev, "ERROR: %s: Failed to get regulators\n", __func__);
+		goto ProbeErrorExit_1;
+	}
+
+	error = fts_enable_reg(info, true);
+	if (error < 0) {
+		dev_err(info->dev, "%s: ERROR Failed to enable regulators\n", __func__);
+		goto ProbeErrorExit_2;
+	}
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_TBN)
+	if (register_tbn(&info->tbn_register_mask)) {
+		error = -ENODEV;
+		dev_err(info->dev, "Failed to register tbn context.");
+		goto ProbeErrorExit_2;
+	}
+	dev_info(info->dev, "tbn_register_mask = %#x.\n", info->tbn_register_mask);
+#endif
+
+	dev_info(info->dev, "SET GPIOS:\n");
+	error = fts_set_gpio(info);
+	if (error < 0) {
+		dev_err(info->dev, "%s: ERROR Failed to set up GPIO's\n", __func__);
+		goto ProbeErrorExit_2;
+	}
+	info->client->irq = gpiod_to_irq(info->board->irq_gpio);
+
+	dev_info(info->dev, "SET Pinctrl:\n");
+	retval = fts_pinctrl_get(info, true);
+	if (!retval)
+		fts_pinctrl_setup(info, true);
+
+	dev_info(info->dev, "SET Event Handler:\n");
+
+	info->wakesrc = wakeup_source_register(NULL, "fts_tp");
+	if (!info->wakesrc) {
+		dev_err(info->dev, "%s: failed to register wakeup source\n", __func__);
+		error = -ENODEV;
+		goto ProbeErrorExit_3;
+
+	}
+	info->event_wq = alloc_workqueue("fts-event-queue", WQ_UNBOUND |
+					 WQ_HIGHPRI | WQ_CPU_INTENSIVE, 1);
+	if (!info->event_wq) {
+		dev_err(info->dev, "ERROR: Cannot create work thread\n");
+		error = -ENOMEM;
+		goto ProbeErrorExit_4;
+	}
+
+	INIT_WORK(&info->resume_work, fts_resume_work);
+	INIT_WORK(&info->suspend_work, fts_suspend_work);
+
+	init_completion(&info->bus_resumed);
+	complete_all(&info->bus_resumed);
+
+	dev_info(info->dev, "SET Input Device Property:\n");
+	info->dev = &info->client->dev;
+	info->input_dev = input_allocate_device();
+	if (!info->input_dev) {
+		dev_err(info->dev, "ERROR: No such input device defined!\n");
+		error = -ENODEV;
+		goto ProbeErrorExit_5;
+	}
+	info->input_dev->dev.parent = &client->dev;
+	info->input_dev->name = info->board->device_name;
+	scnprintf(info->fts_ts_phys, sizeof(info->fts_ts_phys), "%s/input0",
+		 info->input_dev->name);
+	info->input_dev->phys = info->fts_ts_phys;
+	info->input_dev->uniq = info->input_dev->name;
+	info->input_dev->id.bustype = bus_type;
+	info->input_dev->id.vendor = 0x0001;
+	info->input_dev->id.product = 0x0002;
+	info->input_dev->id.version = 0x0100;
+
+	__set_bit(EV_SYN, info->input_dev->evbit);
+	__set_bit(EV_KEY, info->input_dev->evbit);
+	__set_bit(EV_ABS, info->input_dev->evbit);
+	__set_bit(BTN_TOUCH, info->input_dev->keybit);
+	/* __set_bit(BTN_TOOL_FINGER, info->input_dev->keybit); */
+	/* __set_bit(BTN_TOOL_PEN, info->input_dev->keybit); */
+
+	input_mt_init_slots(info->input_dev, TOUCH_ID_MAX, INPUT_MT_DIRECT);
+
+	/* input_mt_init_slots(info->input_dev, TOUCH_ID_MAX); */
+
+	input_set_abs_params(info->input_dev, ABS_MT_POSITION_X, X_AXIS_MIN,
+			     info->board->x_axis_max, 0, 0);
+	input_set_abs_params(info->input_dev, ABS_MT_POSITION_Y, Y_AXIS_MIN,
+			     info->board->y_axis_max, 0, 0);
+	input_set_abs_params(info->input_dev, ABS_MT_TOUCH_MAJOR, AREA_MIN,
+			     AREA_MAX, 0, 0);
+	input_set_abs_params(info->input_dev, ABS_MT_TOUCH_MINOR, AREA_MIN,
+			     AREA_MAX, 0, 0);
+	input_set_abs_params(info->input_dev, ABS_MT_TOOL_TYPE, MT_TOOL_FINGER,
+			     MT_TOOL_FINGER, 0, 0);
+#ifndef SKIP_PRESSURE
+	input_set_abs_params(info->input_dev, ABS_MT_PRESSURE, PRESSURE_MIN,
+		PRESSURE_MAX, 0, 0);
+#endif
+#ifndef SKIP_DISTANCE
+	input_set_abs_params(info->input_dev, ABS_MT_DISTANCE, DISTANCE_MIN,
+			     DISTANCE_MAX, 0, 0);
+#endif
+
+	/* Units are (-4096, 4096), representing the range between rotation
+	 * 90 degrees to left and 90 degrees to the right.
+	 */
+	input_set_abs_params(info->input_dev, ABS_MT_ORIENTATION, -4096, 4096,
+			     0, 0);
+
+#ifdef GESTURE_MODE
+	input_set_capability(info->input_dev, EV_KEY, KEY_WAKEUP);
+
+	input_set_capability(info->input_dev, EV_KEY, KEY_M);
+	input_set_capability(info->input_dev, EV_KEY, KEY_O);
+	input_set_capability(info->input_dev, EV_KEY, KEY_E);
+	input_set_capability(info->input_dev, EV_KEY, KEY_W);
+	input_set_capability(info->input_dev, EV_KEY, KEY_C);
+	input_set_capability(info->input_dev, EV_KEY, KEY_L);
+	input_set_capability(info->input_dev, EV_KEY, KEY_F);
+	input_set_capability(info->input_dev, EV_KEY, KEY_V);
+	input_set_capability(info->input_dev, EV_KEY, KEY_S);
+	input_set_capability(info->input_dev, EV_KEY, KEY_Z);
+	input_set_capability(info->input_dev, EV_KEY, KEY_WWW);
+
+	input_set_capability(info->input_dev, EV_KEY, KEY_LEFT);
+	input_set_capability(info->input_dev, EV_KEY, KEY_RIGHT);
+	input_set_capability(info->input_dev, EV_KEY, KEY_UP);
+	input_set_capability(info->input_dev, EV_KEY, KEY_DOWN);
+
+	input_set_capability(info->input_dev, EV_KEY, KEY_F1);
+	input_set_capability(info->input_dev, EV_KEY, KEY_F2);
+	input_set_capability(info->input_dev, EV_KEY, KEY_F3);
+	input_set_capability(info->input_dev, EV_KEY, KEY_F4);
+	input_set_capability(info->input_dev, EV_KEY, KEY_F5);
+
+	input_set_capability(info->input_dev, EV_KEY, KEY_LEFTBRACE);
+	input_set_capability(info->input_dev, EV_KEY, KEY_RIGHTBRACE);
+#endif
+
+#ifdef PHONE_KEY
+	/* KEY associated to the touch screen buttons */
+	input_set_capability(info->input_dev, EV_KEY, KEY_HOMEPAGE);
+	input_set_capability(info->input_dev, EV_KEY, KEY_BACK);
+	input_set_capability(info->input_dev, EV_KEY, KEY_MENU);
+#endif
+
+	mutex_init(&info->diag_cmd_lock);
+
+	mutex_init(&info->input_report_mutex);
+	mutex_init(&info->bus_mutex);
+	mutex_init(&info->io_mutex);
+
+	/* Assume screen is on throughout probe */
+	info->bus_refmask = FTS_BUS_REF_SCREEN_ON;
+	info->display_state = FTS_DISPLAY_STATE_ON;
+
+#ifdef GESTURE_MODE
+	mutex_init(&gestureMask_mutex);
+#endif
+
+	spin_lock_init(&info->fts_int);
+
+	/* register the multi-touch input device */
+	error = input_register_device(info->input_dev);
+	if (error) {
+		dev_err(info->dev, "ERROR: No such input device\n");
+		error = -ENODEV;
+		goto ProbeErrorExit_5_1;
+	}
+
+	skip_5_1 = 1;
+	/* track slots */
+	info->touch_id = 0;
+	info->palm_touch_mask = 0;
+	info->grip_touch_mask = 0;
+#ifdef STYLUS_MODE
+	info->stylus_id = 0;
+#endif
+
+
+	/* init feature switches (by default all the features are disable,
+	  * if one feature want to be enabled from the start,
+	  * set the corresponding value to 1)*/
+	info->gesture_enabled = 0;
+	info->glove_enabled = 0;
+	info->charger_enabled = 0;
+	info->cover_enabled = 0;
+	info->grip_enabled = 0;
+
+	info->resume_bit = 1;
+
+	/* Set initial heatmap mode based on the device tree configuration.
+	 * Default is partial heatmap mode.
+	 */
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	if (info->board->heatmap_mode_full_init)
+		info->heatmap_mode = FTS_HEATMAP_FULL;
+	else
+		info->heatmap_mode = FTS_HEATMAP_PARTIAL;
+	info->mutual_strength_heatmap.timestamp = 0;
+	info->mutual_strength_heatmap.size_x = 0;
+	info->mutual_strength_heatmap.size_y = 0;
+	info->mutual_strength_heatmap.data = NULL;
+	info->v4l2_mutual_strength_updated = false;
+#endif
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	info->touch_offload_active_coords = 0;
+#endif
+	/* init motion filter mode */
+	info->use_default_mf = false;
+
+	/*
+	 * This *must* be done before request_threaded_irq is called.
+	 * Otherwise, if an interrupt is received before request is added,
+	 * but after the interrupt has been subscribed to, pm_qos_req
+	 * may be accessed before initialization in the interrupt handler.
+	 */
+	cpu_latency_qos_add_request(&info->pm_qos_req, PM_QOS_DEFAULT_VALUE);
+
+	dev_info(info->dev, "Init Core Lib:\n");
+	initCore(info);
+	/* init hardware device */
+	dev_info(info->dev, "Device Initialization:\n");
+	error = fts_init(info);
+	if (error < OK) {
+		dev_err(info->dev, "Cannot initialize the device ERROR %08X\n", error);
+		error = -ENODEV;
+		goto ProbeErrorExit_6;
+	}
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	/*
+	 * Heatmap_probe must be called before irq routine is registered,
+	 * because heatmap_read is called from interrupt context.
+	 * This is done as part of fwu_work.
+	 * At the same time, heatmap_probe must be done after fts_init(..) has
+	 * completed, because getForceLen() and getSenseLen() require
+	 * the chip to be initialized.
+	 */
+	info->v4l2.parent_dev = info->dev;
+	info->v4l2.input_dev = info->input_dev;
+	info->v4l2.read_frame = read_heatmap_raw;
+	if (info->board->tx_rx_dir_swap) {
+		info->v4l2.width = getSenseLen(info);
+		info->v4l2.height = getForceLen(info);
+	} else {
+		info->v4l2.width = getForceLen(info);
+		info->v4l2.height = getSenseLen(info);
+	}
+	/* 120 Hz operation */
+	info->v4l2.timeperframe.numerator = 1;
+	info->v4l2.timeperframe.denominator = 120;
+	error = heatmap_probe(&info->v4l2);
+	if (error < OK)
+		goto ProbeErrorExit_6;
+#endif
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	info->offload.caps.touch_offload_major_version =
+			TOUCH_OFFLOAD_INTERFACE_MAJOR_VERSION;
+	info->offload.caps.touch_offload_minor_version =
+			TOUCH_OFFLOAD_INTERFACE_MINOR_VERSION;
+	info->offload.caps.device_id = info->board->offload_id;
+	info->offload.caps.display_width = info->board->x_axis_max;
+	info->offload.caps.display_height = info->board->y_axis_max;
+	if (info->board->tx_rx_dir_swap) {
+		info->offload.caps.tx_size = getSenseLen(info);
+		info->offload.caps.rx_size = getForceLen(info);
+	} else {
+		info->offload.caps.tx_size = getForceLen(info);
+		info->offload.caps.rx_size = getSenseLen(info);
+	}
+	info->offload.caps.bus_type = BUS_TYPE_SPI;
+	info->offload.caps.bus_speed_hz = 10000000;
+	info->offload.caps.heatmap_size = HEATMAP_SIZE_FULL;
+	info->offload.caps.touch_data_types =
+	    TOUCH_DATA_TYPE_COORD | TOUCH_DATA_TYPE_RAW |
+	    TOUCH_DATA_TYPE_STRENGTH | TOUCH_DATA_TYPE_FILTERED |
+	    TOUCH_DATA_TYPE_BASELINE;
+	info->offload.caps.touch_scan_types =
+	    TOUCH_SCAN_TYPE_MUTUAL | TOUCH_SCAN_TYPE_SELF;
+	info->offload.caps.context_channel_types =
+			CONTEXT_CHANNEL_TYPE_DRIVER_STATUS;
+	info->offload.caps.continuous_reporting = true;
+	info->offload.caps.noise_reporting = false;
+	info->offload.caps.cancel_reporting = false;
+	info->offload.caps.rotation_reporting = true;
+	info->offload.caps.size_reporting = true;
+	info->offload.caps.auto_reporting = false;
+	info->offload.caps.filter_grip = true;
+	info->offload.caps.filter_palm = true;
+	info->offload.caps.num_sensitivity_settings = 1;
+
+	INIT_DELAYED_WORK(&info->offload_resume_work, fts_offload_resume_work);
+
+	info->offload.hcallback = (void *)info;
+	info->offload.report_cb = fts_offload_report;
+	touch_offload_init(&info->offload);
+#endif
+
+#if defined(FW_UPDATE_ON_PROBE) && defined(FW_H_FILE)
+	dev_info(info->dev, "FW Update and Sensing Initialization:\n");
+	error = fts_fw_update(info);
+	if (error < OK) {
+		dev_err(info->dev, "Cannot execute fw upgrade the device ERROR %08X\n",
+			error);
+		error = -ENODEV;
+		goto ProbeErrorExit_7;
+	}
+
+#else
+	dev_info(info->dev, "SET Auto Fw Update:\n");
+	info->fwu_workqueue = alloc_workqueue("fts-fwu-queue",
+					      WQ_UNBOUND | WQ_HIGHPRI |
+					      WQ_CPU_INTENSIVE, 1);
+	if (!info->fwu_workqueue) {
+		dev_err(info->dev, "ERROR: Cannot create fwu work thread\n");
+		goto ProbeErrorExit_7;
+	}
+	INIT_DELAYED_WORK(&info->fwu_work, fts_fw_update_auto);
+#endif
+
+	info->enable_palm_data_dump = false;
+	INIT_DELAYED_WORK(&info->palm_data_dump_work, fts_palm_data_dump_work);
+
+	dev_info(info->dev, "SET Device File Nodes:\n");
+	/* sysfs stuff */
+	info->attrs.attrs = fts_attr_group;
+	info->attrs.bin_attrs = fts_bin_attr_group;
+	error = sysfs_create_group(&client->dev.kobj, &info->attrs);
+	if (error) {
+		dev_err(info->dev, "ERROR: Cannot create sysfs structure!\n");
+		error = -ENODEV;
+		goto ProbeErrorExit_7;
+	}
+
+	retval = fts_proc_init(info);
+	if (retval < OK)
+		dev_err(info->dev, "Error: can not create /proc file!\n");
+	info->diag_node_open = false;
+
+	if (info->fwu_workqueue)
+		queue_delayed_work(info->fwu_workqueue, &info->fwu_work,
+				   msecs_to_jiffies(EXP_FN_WORK_DELAY_MS));
+
+	info->touchsim.wq = alloc_workqueue("fts-heatmap_test-queue",
+					WQ_UNBOUND | WQ_HIGHPRI |
+					WQ_CPU_INTENSIVE, 1);
+
+	if (info->touchsim.wq)
+		INIT_WORK(&(info->touchsim.work), touchsim_work);
+	else
+		dev_err(info->dev, "ERROR: Cannot create touch sim. test work queue\n");
+
+	dev_info(info->dev, "Probe Finished!\n");
+
+	return OK;
+
+
+ProbeErrorExit_7:
+	if(info->touchsim.wq)
+		destroy_workqueue(info->touchsim.wq);
+
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	touch_offload_cleanup(&info->offload);
+#endif
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	heatmap_remove(&info->v4l2);
+#endif
+
+ProbeErrorExit_6:
+	cpu_latency_qos_remove_request(&info->pm_qos_req);
+	input_unregister_device(info->input_dev);
+
+ProbeErrorExit_5_1:
+	if (skip_5_1 != 1)
+		input_free_device(info->input_dev);
+
+ProbeErrorExit_5:
+	destroy_workqueue(info->event_wq);
+
+ProbeErrorExit_4:
+	/* destroy_workqueue(info->fwu_workqueue); */
+	wakeup_source_unregister(info->wakesrc);
+
+ProbeErrorExit_3:
+	fts_pinctrl_get(info, false);
+
+	fts_enable_reg(info, false);
+
+ProbeErrorExit_2:
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_TBN)
+	if (info->tbn_register_mask)
+		unregister_tbn(&info->tbn_register_mask);
+#endif
+	fts_get_reg(info, false);
+
+ProbeErrorExit_1:
+	kfree(info);
+
+ProbeErrorExit_0:
+	if (error != -EPROBE_DEFER)
+		dev_err(info->dev, "Probe Failed!\n");
+
+	return error;
+}
+
+
+/**
+  * Clear and free all the resources associated to the driver.
+  * This function is called when the driver need to be removed.
+  */
+#ifdef I2C_INTERFACE
+static void fts_remove(struct i2c_client *client)
+{
+#else
+static void fts_remove(struct spi_device *client)
+{
+#endif
+
+	struct fts_ts_info *info = dev_get_drvdata(&(client->dev));
+
+	/* Force the bus active throughout removal of the client */
+	fts_set_bus_ref(info, FTS_BUS_REF_FORCE_ACTIVE, true);
+
+	dev_info(info->dev, "%s\n", __func__);
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_TBN)
+	if (info->tbn_register_mask)
+		unregister_tbn(&info->tbn_register_mask);
+#endif
+
+	fts_proc_remove(info);
+
+	/* sysfs stuff */
+	sysfs_remove_group(&client->dev.kobj, &info->attrs);
+
+	/* remove interrupt and event handlers */
+	fts_interrupt_uninstall(info);
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	touch_offload_cleanup(&info->offload);
+#endif
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	heatmap_remove(&info->v4l2);
+#endif
+
+	cpu_latency_qos_remove_request(&info->pm_qos_req);
+
+
+	/* unregister the device */
+	input_unregister_device(info->input_dev);
+
+	/* input_free_device(info->input_dev ); */
+
+	/* Remove the work thread */
+	destroy_workqueue(info->event_wq);
+	wakeup_source_unregister(info->wakesrc);
+
+	if(info->touchsim.wq)
+		destroy_workqueue(info->touchsim.wq);
+
+	if (info->fwu_workqueue)
+		destroy_workqueue(info->fwu_workqueue);
+
+	fts_pinctrl_get(info, false);
+
+	fts_enable_reg(info, false);
+	fts_get_reg(info, false);
+
+	/* free any extinfo */
+	kfree(info->extinfo.data);
+
+	/* free all */
+	kfree(info);
+}
+
+#ifdef CONFIG_PM
+static int fts_pm_suspend(struct device *dev)
+{
+	struct fts_ts_info *info = dev_get_drvdata(dev);
+
+	if (info->bus_refmask)
+		dev_warn(info->dev, "%s: bus_refmask 0x%X\n", __func__, info->bus_refmask);
+
+	if (info->resume_bit == 1 || info->sensor_sleep == false) {
+		dev_warn(info->dev, "%s: can't suspend because touch bus is in use!\n",
+			__func__);
+		dev_warn(info->dev, "%s: display_state: %d, sensor_sleep: %d\n",
+			__func__, info->display_state, info->sensor_sleep);
+		if (info->bus_refmask == FTS_BUS_REF_BUGREPORT) {
+			fts_set_bus_ref(info, FTS_BUS_REF_BUGREPORT, false);
+			__pm_relax(info->wakesrc);
+		}
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int fts_pm_resume(struct device *dev)
+{
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(fts_pm_ops, fts_pm_suspend, fts_pm_resume);
+#endif
+
+/**
+  * Struct which contains the compatible names that need to match with
+  * the definition of the device in the device tree node
+  */
+static struct of_device_id fts_of_match_table[] = {
+	{
+		.compatible = "st,fts",
+	},
+	{},
+};
+
+#ifdef I2C_INTERFACE
+static const struct i2c_device_id fts_device_id[] = {
+	{ FTS_TS_DRV_NAME, 0 },
+	{}
+};
+
+static struct i2c_driver fts_i2c_driver = {
+	.driver			= {
+		.name		= FTS_TS_DRV_NAME,
+		.of_match_table = fts_of_match_table,
+#ifdef CONFIG_PM
+		.pm		= &fts_pm_ops,
+#endif
+	},
+	.probe			= fts_probe,
+	.remove			= fts_remove,
+	.id_table		= fts_device_id,
+};
+#else
+static struct spi_driver fts_spi_driver = {
+	.driver			= {
+		.name		= FTS_TS_DRV_NAME,
+		.of_match_table = fts_of_match_table,
+		.owner		= THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm		= &fts_pm_ops,
+#endif
+	},
+	.probe			= fts_probe,
+	.remove			= fts_remove,
+};
+#endif
+
+
+
+
+static int __init fts_driver_init(void)
+{
+#ifdef I2C_INTERFACE
+	return i2c_add_driver(&fts_i2c_driver);
+#else
+	return spi_register_driver(&fts_spi_driver);
+#endif
+}
+
+static void __exit fts_driver_exit(void)
+{
+	pr_info("%s\n", __func__);
+#ifdef I2C_INTERFACE
+	i2c_del_driver(&fts_i2c_driver);
+#else
+	spi_unregister_driver(&fts_spi_driver);
+#endif
+}
+
+MODULE_DESCRIPTION("STMicroelectronics MultiTouch IC Driver");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
+
+late_initcall(fts_driver_init);
+module_exit(fts_driver_exit);
diff --git a/drivers/input/touchscreen/stfts/google/fts.h b/drivers/input/touchscreen/stfts/google/fts.h
new file mode 100644
index 000000000000..cc6031a159ae
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts.h
@@ -0,0 +1,1015 @@
+/*
+  * fts.h
+  *
+  * FTS Capacitive touch screen controller (FingerTipS)
+  *
+  * Copyright (C) 2017, STMicroelectronics
+  * Authors: AMG(Analog Mems Group)
+  *
+  *		marco.cali@st.com
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+  * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+  * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+  * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+  * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM
+  * THE
+  * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+  * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * THIS SOFTWARE IS SPECIFICALLY DESIGNED FOR EXCLUSIVE USE WITH ST PARTS.
+  */
+
+/*!
+  * \file fts.h
+  * \brief Contains all the definitions and structs used generally by the driver
+  */
+
+#ifndef _LINUX_FTS_I2C_H_
+#define _LINUX_FTS_I2C_H_
+
+#include <linux/device.h>
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+#include <heatmap.h>
+#endif
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+#include <touch_offload.h>
+#endif
+#include <linux/pm_qos.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_device.h>
+#include <drm/drm_encoder.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include "fts_lib/ftsSoftware.h"
+#include "fts_lib/ftsHardware.h"
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_TBN)
+#include <touch_bus_negotiator.h>
+#endif
+
+#include <linux/proc_fs.h>
+
+#undef DYNAMIC_REFRESH_RATE
+
+/****************** CONFIGURATION SECTION ******************/
+/** @defgroup conf_section	 Driver Configuration Section
+  * Settings of the driver code in order to suit the HW set up and the
+  *application behavior
+  * @{
+  */
+/* **** CODE CONFIGURATION **** */
+#define FTS_TS_DRV_NAME		"fts"	/* driver name */
+#define FTS_TS_DRV_VERSION	"5.2.16.16"	/* driver version string */
+#define FTS_TS_DRV_VER		0x05021010	/* driver version u32 format */
+/* #define DEBUG */	/* /< define to print more logs in the kernel log
+			 * and better follow the code flow */
+#undef pr_fmt
+#define pr_fmt(fmt) "gtd: fts: " fmt
+#undef dev_fmt
+#define dev_fmt(fmt) "gtd: " fmt
+
+#define PINCTRL_STATE_ACTIVE    "pmx_ts_active"
+#define PINCTRL_STATE_SUSPEND   "pmx_ts_suspend"
+#define PINCTRL_STATE_RELEASE   "pmx_ts_release"
+
+#define DRIVER_TEST	/* /< if defined allow to use and test special functions
+			  * of the driver and fts_lib from command shell
+			  * (useful for enginering/debug operations) */
+
+/* If both COMPUTE_INIT_METHOD and PRE_SAVED_METHOD are not defined,
+ * driver will be automatically configured as GOLDEN_VALUE_METHOD
+ */
+#define COMPUTE_INIT_METHOD	/* Allow to compute init data on phone during
+				 * production
+				 */
+#define SKIP_PRODUCTION_TEST	/* Allow to skip Production test */
+
+#ifndef COMPUTE_INIT_METHOD
+#define PRE_SAVED_METHOD	/* Pre-Saved Method used during production */
+#endif
+
+/*#define FW_H_FILE*/			/* include the FW data as header file */
+#ifdef FW_H_FILE
+#define FW_SIZE_NAME	myArray_size	/* FW data array size */
+#define FW_ARRAY_NAME	myArray	/* FW data array name */
+/*#define FW_UPDATE_ON_PROBE*/		/* No delay updating FW */
+#endif
+
+#ifndef FW_UPDATE_ON_PROBE
+/* Include the Production Limit File as header file, can be commented to use a
+  * .csv file instead */
+/* #define LIMITS_H_FILE */
+#ifdef LIMITS_H_FILE
+	#define LIMITS_SIZE_NAME	myArray2_size	/* /< name of the
+							 * variable
+							  * in the limits header
+							  *file which
+							  * specified the
+							  *dimension of
+							  * the limits data
+							  *array */
+	#define LIMITS_ARRAY_NAME	myArray2	/* /< name of the
+							 * variable in
+							  * the limits header
+							  *file which
+							  * specified the limits
+							  *data array */
+#endif
+#else
+/* if execute fw update in the probe the limit file must be a .h */
+#define LIMITS_H_FILE	/* /< include the Production Limit File as header file,
+			 * DO NOT COMMENT! */
+#define LIMITS_SIZE_NAME		myArray2_size	/* /< name of the
+							 * variable
+							  * in the limits header
+							  *file
+							  * which specified the
+							  *dimension
+							  * of the limits data
+							  *array */
+#define LIMITS_ARRAY_NAME		myArray2	/* /< name of the
+							 * variable in the
+							  * limits header file
+							  *which specified
+							  * the limits data
+							  *array */
+#endif
+
+/* #define USE_ONE_FILE_NODE */	/* /< allow to enable/disable all the features
+  * just using one file node */
+
+#ifndef FW_UPDATE_ON_PROBE
+#define EXP_FN_WORK_DELAY_MS 1000	/* /< time in ms elapsed after the probe
+					  * to start the work which execute FW
+					  *update
+					  * and the Initialization of the IC */
+#endif
+
+/* **** END **** */
+
+
+/* **** FEATURES USED IN THE IC **** */
+/* Enable the support of keys */
+/* #define PHONE_KEY */
+
+#undef GESTURE_MODE	/* /< enable the support of the gestures */
+#ifdef GESTURE_MODE
+	#define USE_GESTURE_MASK	/* /< the gestures to select are
+					 * referred using
+					  * a gesture bitmask instead of their
+					  *gesture IDs */
+#endif
+
+
+#undef CHARGER_MODE	/* /< enable the support to charger mode feature
+			 * (comment to disable) */
+
+#define GLOVE_MODE	/* /< enable the support to glove mode feature (comment
+			 * to disable) */
+
+#undef COVER_MODE	/* /< enable the support to cover mode feature (comment
+			 * to disable) */
+
+#undef STYLUS_MODE	/* /< enable the support to stylus mode feature (comment
+			 * to disable) */
+
+#undef GRIP_MODE	/* /< enable the support to grip mode feature (comment
+			 * to disable) */
+
+
+/* **** END **** */
+
+
+/* **** PANEL SPECIFICATION **** */
+#define X_AXIS_MIN	0	/* /< min X coordinate of the display */
+#define Y_AXIS_MIN	0	/* /< min Y coordinate of the display */
+#define Y_AXIS_MAX	2959	/* /< Max Y coordinate of the display */
+#define X_AXIS_MAX	1440	/* /< Max X coordinate of the display */
+
+#define PRESSURE_MIN	0	/* /< min value of pressure reported */
+#define PRESSURE_MAX	127	/* /< Max value of pressure reported */
+
+#define DISTANCE_MIN	0	/* /< min distance between the tool and the
+				 * display */
+#define DISTANCE_MAX	127	/* /< Max distance between the tool and the
+				 * display */
+
+#define TOUCH_ID_MAX	10	/* /< Max number of simoultaneous touches
+				 * reported */
+
+#define AREA_SCALE	16	/* /< Scale for major/minor axis calculation */
+#define AREA_MIN	(PRESSURE_MIN * AREA_SCALE)	/* /< Min value of
+							 * major/minor axis
+							 * reported */
+#define AREA_MAX	(PRESSURE_MAX * AREA_SCALE)	/* /< Max value of
+							 * major/minor axis
+							 * reported */
+/* **** END **** */
+
+/* #define SKIP_PRESSURE */
+
+/**@}*/
+/*********************************************************/
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+/* **** LOCAL HEATMAP FEATURE *** */
+#define LOCAL_HEATMAP_WIDTH 7
+#define LOCAL_HEATMAP_HEIGHT 7
+#define LOCAL_HEATMAP_MODE 0xC1
+
+struct heatmap_report {
+	uint8_t prefix; /* always should be 0xA0 */
+	uint8_t mode; /* mode should be 0xC1 for heatmap */
+
+	uint16_t counter; /* LE order, should increment on each heatmap read */
+	int8_t offset_x;
+	uint8_t size_x;
+	int8_t offset_y;
+	uint8_t size_y;
+	/* data is in LE order; order should be enforced after data is read */
+	strength_t data[LOCAL_HEATMAP_WIDTH * LOCAL_HEATMAP_HEIGHT];
+} __attribute__((packed));
+/* **** END **** */
+
+struct heatmap_data {
+	ktime_t timestamp;
+	uint16_t size_x;
+	uint16_t size_y;
+	uint8_t *data;
+} __attribute__((packed));
+#endif
+/*
+  * Configuration mode
+  *
+  * bitmask which can assume the value defined as features in ftsSoftware.h or
+  * the following values
+  */
+
+/** @defgroup mode_section	 IC Status Mode
+  * Bitmask which keeps track of the features and working mode enabled in the
+  * IC.
+  * The meaning of the the LSB of the bitmask must be interpreted considering
+  * that the value defined in @link feat_opt Feature Selection Option @endlink
+  * correspond to the position of the corresponding bit in the mask
+  * @{
+  */
+#define MODE_NOTHING 0x00000000	/* /< nothing enabled (sense off) */
+#define MODE_ACTIVE(_mask, _sett)	\
+	(_mask |= (SCAN_MODE_ACTIVE << 24) | (_sett << 16))
+/* /< store the status of scan mode active and its setting */
+#define MODE_LOW_POWER(_mask, _sett)	\
+	(_mask |= (SCAN_MODE_LOW_POWER << 24) | (_sett << 16))
+/* /< store the status of scan mode low power and its setting */
+#define IS_POWER_MODE(_mask, _mode)	((_mask&(_mode<<24)) != 0x00)
+/* /< check the current mode of the IC */
+
+/** @}*/
+
+#define CMD_STR_LEN	32	/* /< max number of parameters that can accept
+				 * the
+				  * MP file node (stm_fts_cmd) */
+
+#define TSP_BUF_SIZE	PAGE_SIZE	/* /< max number of bytes printable on
+					  * the shell in the normal file nodes
+					  **/
+
+#define MAX_RAWDATA_STR_SIZE	PAGE_SIZE * 3
+
+/* Encapsulate display extinfo
+ *
+ * For some panels, it is insufficient to simply detect the panel ID and load
+ * one corresponding firmware. The display driver exposes extended info read
+ * from the display, but it is up to the touch driver to parse the data.
+ */
+struct fts_disp_extinfo {
+	bool is_read;
+	u8 size;
+	u8 *data;
+};
+
+/**
+  * Struct which contains information about the HW platform and set up
+  */
+struct fts_hw_platform_data {
+	u8 dchip_id[2];	/* DCHIPID_ID_0 and DCHIPID_ID_1 in ftsHardware.h */
+	int flash_chunk; /* Max number of bytes that the DMA can burn on flash
+			  * in one shot in FTI */
+	int (*power) (bool on);
+	struct gpio_desc *switch_gpio;    /* optional I2C switch */
+	struct gpio_desc *irq_gpio;       /* gpio associated to the interrupt pin* */
+	struct gpio_desc *reset_gpio;     /* optional gpio associated to the reset pin */
+	struct gpio_desc *disp_rate_gpio; /* optional disp_rate gpio: LOW=60Hz, HIGH=90Hz */
+	const char *fw_name;
+	const char *limits_name;
+	const char *device_name;
+	bool sensor_inverted;
+	int x_axis_max;
+	int y_axis_max;
+	int udfps_x;
+	int udfps_y;
+	bool auto_fw_update;
+	bool separate_save_golden_ms_raw_cmd;
+	bool skip_fpi_for_unset_mpflag;
+	bool sensor_inverted_x;
+	bool sensor_inverted_y;
+	bool tx_rx_dir_swap; /* Set as TRUE if Tx direction is same as x-axis. */
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	bool heatmap_mode_full_init;
+#endif
+	struct drm_panel *panel;
+	u32 initial_panel_index;
+	u32 *force_pi_cfg_ver;
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	u32 offload_id;
+#endif
+	u8 fw_grip_area;
+};
+
+/* Bits for the bus reference mask */
+enum {
+	FTS_BUS_REF_SCREEN_ON		= 0x01,
+	FTS_BUS_REF_IRQ			= 0x02,
+	FTS_BUS_REF_FW_UPDATE		= 0x04,
+	FTS_BUS_REF_SYSFS		= 0x08,
+	FTS_BUS_REF_FORCE_ACTIVE	= 0x10,
+	FTS_BUS_REF_BUGREPORT		= 0x20,
+};
+
+enum fts_display_state : u32 {
+	FTS_DISPLAY_STATE_OFF = 0,
+	FTS_DISPLAY_STATE_ON,
+};
+
+/* Motion filter finite state machine (FSM) states
+ * FTS_MF_FILTERED        - default coordinate filtering
+ * FTS_MF_UNFILTERED      - unfiltered single-touch coordinates
+ * FTS_MF_FILTERED_LOCKED - filtered coordinates. Locked until touch is lifted.
+ */
+typedef enum {
+	FTS_MF_FILTERED		= 0,
+	FTS_MF_UNFILTERED	= 1,
+	FTS_MF_FILTERED_LOCKED	= 2
+} motion_filter_state_t;
+
+/* Heatmap mode selection
+ * FTS_HEATMAP_OFF	- no data read
+ * FTS_HEATMAP_PARTIAL	- read partial frame
+ *			(LOCAL_HEATMAP_WIDTH * LOCAL_HEATMAP_HEIGHT)
+ * FTS_HEATMAP_FULL	- read full mutual sense strength frame
+ */
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+enum {
+	FTS_HEATMAP_OFF		= 0,
+	FTS_HEATMAP_PARTIAL	= 1,
+	FTS_HEATMAP_FULL	= 2
+};
+#endif
+/*
+  * Forward declaration
+  */
+struct fts_ts_info;
+
+/*
+  * Dispatch event handler
+  * Return true if the handler has processed a pointer event
+  */
+typedef bool (*event_dispatch_handler_t)
+	(struct fts_ts_info *info, unsigned char *data);
+
+/**
+  * Driver touch simulation details
+  */
+struct fts_touchsim{
+	/* touch simulation coordinates */
+	int x, y, x_step, y_step;
+
+	/* timer to run the touch simulation code */
+	struct hrtimer hr_timer;
+
+	struct work_struct work;
+	struct workqueue_struct *wq;
+
+	/* True if the touch simulation is currently running */
+	bool is_running;
+};
+
+/**
+  * Struct which store an ordered list of the errors events encountered during
+  *the polling of a FIFO.
+  * The max number of error events that can be stored is equal to FIFO_DEPTH
+  */
+typedef struct {
+	u8 list[FIFO_DEPTH * FIFO_EVENT_SIZE];	/* /< byte array which contains
+						 * the series of error events
+						 * encountered from the last
+						 * reset of the list. */
+	int count;	/* /< number of error events stored in the list */
+	int last_index;	/* /< index of the list where will be stored the next
+			 * error event. Subtract -1 to have the index of the
+			 * last error event! */
+} ErrorList;
+
+/**
+  * Struct used to specify which test perform during the Mass Production Test.
+  * For each test item selected in this structure, there should be one or
+  * more labels associated in the Limit file from where load the thresholds
+  */
+typedef struct {
+	int MutualRaw;	/* /< MS Raw min/Max test */
+	int MutualRawMap;	/* /< MS Raw min/Max test for each node */
+	int MutualRawGap;	/* /< MS Raw Gap(max-min) test */
+	int MutualRawAdj;	/* /< MS Raw Adjacent test */
+	int MutualRawAdjGap;	/* /< MS Raw Adjacent Gap (max-min) test */
+	int MutualRawAdjPeak;	/* /< MS Raw Adjacent Peak
+				 * max(max(adjv),max(adjh)) test
+				 */
+	int MutualRawLP;	/* /< MS Low Power Raw min/Max test */
+	int MutualRawMapLP;	/* /< MS Low Power Raw min/Max test
+				 * for each node
+				 */
+	int MutualRawGapLP;	/* /< MS Low Power Raw Gap(max-min) test */
+	int MutualRawAdjLP;	/* /< MS Low Power Raw Adjacent test */
+	int MutualRawAdjITO;	/* /< MS Raw Adjacent test during ITO test */
+	int MutualRawMapITO; 	/* /< MS Raw ITO min/Max test */
+
+	int MutualCx1;	/* /< MS Cx1 min/Max test */
+	int MutualCx2;	/* /< MS Cx2 min/Max (for each node) test */
+	int MutualCx2Adj;	/* /< MS Vertical and Horizontal Adj Cx2 min/Max
+				 *  (for each node) test */
+	int MutualCxTotal;	/* /< MS Total Cx min/Max (for each node) test
+				 * */
+	int MutualCxTotalAdj;	/* /< MS Total vertical and Horizontal Adj Cx2
+				 * min/Max (for each node) test
+				 */
+
+	int MutualCx1LP;	/* /< MS LowPower Cx1 min/Max test */
+	int MutualCx2LP;	/* /< MS LowPower Cx2 min/Max (for each node)
+				 * test
+				 */
+	int MutualCx2AdjLP;	/* /< MS LowPower Vertical and Horizontal Adj
+				 * Cx2 min/Max
+				 * (for each node) test
+				 */
+	int MutualCxTotalLP;	/* /< MS Total LowPower Cx min/Max
+				 * (for each node) test */
+	int MutualCxTotalAdjLP;	/* /< MS Total LowPower vertical and Horizontal
+				 * Adj Cx2 min/Max (for each node) test
+				 */
+
+	int MutualKeyRaw;	/* /< MS Raw Key min/Max test */
+	int MutualKeyCx1;	/* /< MS Cx1 Key min/Max test */
+	int MutualKeyCx2;	/* /< MS Cx2 Key min/Max (for each node) test */
+	int MutualKeyCxTotal;	/* /< MS Total Cx Key min/Max (for each node)
+				 * test */
+
+	int SelfForceRaw;	/* /< SS Force Raw min/Max test */
+	int SelfForceRawGap;	/* /< SS Force Raw Gap(max-min) test */
+	int SelfForceRawMap;	/* /< SS Force Raw min/Max Map test */
+	int SelfForceRawLP;	/* /< SS Low Power Force Raw min/Max test */
+	int SelfForceRawGapLP; /* /< SS Low Power Force Raw Gap(max-min) test */
+	int SelfForceRawMapLP;	/* /< SS Low Power Force Raw min/Max Map test */
+
+	int SelfForceIx1;	/* /< SS Force Ix1 min/Max test */
+	int SelfForceIx2;	/* /< SS Force Ix2 min/Max (for each node) test
+				 * */
+	int SelfForceIx2Adj;	/* /< SS Vertical Adj Force Ix2 min/Max
+				 * (for each node) test */
+	int SelfForceIxTotal;	/* /< SS Total Force Ix min/Max (for each node)
+				 * test */
+	int SelfForceIxTotalAdj;	/* /< SS Total Vertical Adj Force Ix
+					 * min/Max
+					 * (for each node) test */
+	int SelfForceCx1;	/* /< SS Force Cx1 min/Max test */
+	int SelfForceCx2; /* /< SS Force Cx2 min/Max (for each node) test */
+	int SelfForceCx2Adj;	/* /< SS Vertical Adj Force Cx2 min/Max (for
+				 * each node) test */
+	int SelfForceCxTotal;	/* /< SS Total Force Cx min/Max (for each node)
+				 * test */
+	int SelfForceCxTotalAdj;	/* /< SS Total Vertical Adj Force Cx
+					 * min/Max (for each node) test
+					 */
+
+	int SelfForceIx1LP;	/* /< SS LP Force Ix1 min/Max test */
+	int SelfForceIx2LP;	/* /< SS LP Force Ix2 min/Max (for each node)
+				 *  test
+				 */
+	int SelfForceIx2AdjLP;	/* /< SS LP Vertical Adj Force Ix2 min/Max
+					 * (for each node) test */
+	int SelfForceIxTotalLP;	/* /< SS LP Total Force Ix min/Max
+				 * (for each node) test
+				 */
+	int SelfForceIxTotalAdjLP;	/* /< SS LP Total Vertical Adj Force Ix
+					 * min/Max (for each node) test
+					 */
+	int SelfForceCx1LP;	/* /< SS LP Force Cx1 min/Max test */
+	int SelfForceCx2LP;	/* /< SS LP Force Cx2 min/Max (for each node)
+				 * test
+				 */
+	int SelfForceCx2AdjLP;	/* /< SS LP Vertical Adj Force Cx2 min/Max (for
+				 * each node) test
+				 */
+	int SelfForceCxTotalLP;	/* /< SS LP Total Force Cx min/Max
+				 * (for each node) test
+				 */
+	int SelfForceCxTotalAdjLP;	/* /< SS LP Total Vertical Adj Force Cx
+					 * min/Max (for each node) test
+					 */
+
+	int SelfSenseRaw;	/* /< SS Sense Raw min/Max test */
+	int SelfSenseRawGap;	/* /< SS Sense Raw Gap(max-min) test */
+	int SelfSenseRawMap;	/* /< SS Sense Raw min/Max test for each node */
+	int SelfSenseRawLP;	/* /< SS Low Power Sense Raw min/Max test */
+	int SelfSenseRawGapLP; /* /< SS Low Power Sense Raw Gap(max-min) test */
+	int SelfSenseRawMapLP;	/* /< SS Low Power Sense Raw min/Max test for
+				 * each node
+				 */
+
+	int SelfSenseIx1;	/* /< SS Sense Ix1 min/Max test */
+	int SelfSenseIx2; /* /< SS Sense Ix2 min/Max (for each node) test */
+	int SelfSenseIx2Adj;	/* /< SS Horizontal Adj Sense Ix2 min/Max
+				  * (for each node) test */
+	int SelfSenseIxTotal;	/* /< SS Total Horizontal Sense Ix min/Max
+				  * (for each node) test */
+	int SelfSenseIxTotalAdj;	/* /< SS Total Horizontal Adj Sense Ix
+					 * min/Max
+					 * (for each node) test */
+	int SelfSenseCx1;	/* /< SS Sense Cx1 min/Max test */
+	int SelfSenseCx2; /* /< SS Sense Cx2 min/Max (for each node) test */
+	int SelfSenseCx2Adj;	/* /< SS Horizontal Adj Sense Cx2 min/Max
+				  * (for each node) test */
+	int SelfSenseCxTotal;	/* /< SS Total Sense Cx min/Max (for each node)
+				 * test */
+	int SelfSenseCxTotalAdj;	/* /< SS Total Horizontal Adj Sense Cx
+					 * min/Max
+					 * (for each node) test */
+	int SelfSenseIx1LP;	/* /< SS LP Sense Ix1 min/Max test */
+	int SelfSenseIx2LP; /* /< SS LP Sense Ix2 min/Max (for each node)
+			     * test
+			     */
+	int SelfSenseIx2AdjLP;	/* /< SS LP Horizontal Adj Sense Ix2 min/Max
+				 * (for each node) test
+				 */
+	int SelfSenseIxTotalLP;	/* /< SS LP Total Horizontal Sense Ix min/Max
+				 * (for each node) test
+				 */
+	int SelfSenseIxTotalAdjLP; /* /< SS LP Total Horizontal Adj Sense Ix
+				    * min/Max (for each node) test
+				    */
+	int SelfSenseCx1LP;	/* /< SS LP Sense Cx1 min/Max test */
+	int SelfSenseCx2LP; /* /< SS LP Sense Cx2 min/Max (for each node)
+			     * test
+			     */
+	int SelfSenseCx2AdjLP;	/* /< SS LP Horizontal Adj Sense Cx2 min/Max
+				 * (for each node) test
+				 */
+	int SelfSenseCxTotalLP;	/* /< SS LP Total Sense Cx min/Max
+				 * (for each node) test
+				 */
+	int SelfSenseCxTotalAdjLP; /* /< SS LP Total Horizontal Adj Sense Cx
+				    * min/Max (for each node) test
+				    */
+} TestToDo;
+
+#define DIE_INFO_SIZE			16	/* Num bytes of external release
+						 * in config */
+#define EXTERNAL_RELEASE_INFO_SIZE	8	/* Num bytes of release info in
+						 * sys info
+						 *  (first bytes are external
+						 * release) */
+#define RELEASE_INFO_SIZE		(EXTERNAL_RELEASE_INFO_SIZE)
+
+/**
+  * Struct which contains fundamental information about the chip and its
+  * configuration
+  */
+typedef struct {
+	u16 u16_apiVer_rev;	/* /< API revision version */
+	u8 u8_apiVer_minor;	/* /< API minor version */
+	u8 u8_apiVer_major;	/* /< API major version */
+	u16 u16_chip0Ver;	/* /< Dev0 version */
+	u16 u16_chip0Id;	/* /< Dev0 ID */
+	u16 u16_chip1Ver;	/* /< Dev1 version */
+	u16 u16_chip1Id;	/* /< Dev1 ID */
+	u16 u16_fwVer;	/* /< Fw version */
+	u16 u16_svnRev;	/* /< SVN Revision */
+	u16 u16_cfgVer;	/* /< Config Version */
+	u16 u16_cfgProjectId;	/* /< Config Project ID */
+	u16 u16_cxVer;	/* /< Cx Version */
+	u16 u16_cxProjectId;	/* /< Cx Project ID */
+	u8 u8_cfgAfeVer;	/* /< AFE version in Config */
+	u8 u8_cxAfeVer;	/* /< AFE version in CX */
+	u8 u8_panelCfgAfeVer;	/* /< AFE version in PanelMem */
+	u8 u8_protocol;	/* /< Touch Report Protocol */
+	u8 u8_dieInfo[DIE_INFO_SIZE];	/* /< Die information */
+	u8 u8_releaseInfo[RELEASE_INFO_SIZE];	/* /< Release information */
+	u32 u32_fwCrc;	/* /< Crc of FW */
+	u32 u32_cfgCrc;	/* /< Crc of config */
+	u8 u8_mpFlag; /* /< MP Flag */
+	u8 u8_ssDetScanSet; /* /< Type of Detect Scan Selected */
+
+	u16 u16_scrResX;/* /< X resolution on main screen */
+	u16 u16_scrResY;/* /< Y resolution on main screen */
+	u8 u8_scrTxLen;	/* /< Tx length */
+	u8 u8_scrRxLen;	/* /< Rx length */
+	u8 u8_keyLen;	/* /< Key Len */
+	u8 u8_forceLen;	/* /< Force Len */
+	u32 u32_productionTimestamp;	/* /< Production Timestamp */
+
+	u16 u16_dbgInfoAddr;	/* /< Offset of debug Info structure */
+
+	u16 u16_msTchRawAddr;	/* /< Offset of MS touch raw frame */
+	u16 u16_msTchFilterAddr;/* /< Offset of MS touch filter frame */
+	u16 u16_msTchStrenAddr;	/* /< Offset of MS touch strength frame */
+	u16 u16_msTchBaselineAddr;	/* /< Offset of MS touch baseline frame
+					 * */
+
+	u16 u16_ssTchTxRawAddr;	/* /< Offset of SS touch force raw frame */
+	u16 u16_ssTchTxFilterAddr;	/* /< Offset of SS touch force filter
+					 * frame */
+	u16 u16_ssTchTxStrenAddr;/* /< Offset of SS touch force strength frame
+				 * */
+	u16 u16_ssTchTxBaselineAddr;	/* /< Offset of SS touch force baseline
+					 * frame */
+
+	u16 u16_ssTchRxRawAddr;	/* /< Offset of SS touch sense raw frame */
+	u16 u16_ssTchRxFilterAddr;	/* /< Offset of SS touch sense filter
+					 * frame */
+	u16 u16_ssTchRxStrenAddr;/* /< Offset of SS touch sense strength frame
+				 * */
+	u16 u16_ssTchRxBaselineAddr;	/* /< Offset of SS touch sense baseline
+					 * frame */
+
+	u16 u16_keyRawAddr;	/* /< Offset of key raw frame */
+	u16 u16_keyFilterAddr;	/* /< Offset of key filter frame */
+	u16 u16_keyStrenAddr;	/* /< Offset of key strength frame */
+	u16 u16_keyBaselineAddr;	/* /< Offset of key baseline frame */
+
+	u16 u16_frcRawAddr;	/* /< Offset of force touch raw frame */
+	u16 u16_frcFilterAddr;	/* /< Offset of force touch filter frame */
+	u16 u16_frcStrenAddr;	/* /< Offset of force touch strength frame */
+	u16 u16_frcBaselineAddr;/* /< Offset of force touch baseline frame */
+
+	u16 u16_ssHvrTxRawAddr;	/* /< Offset of SS hover Force raw frame */
+	u16 u16_ssHvrTxFilterAddr;	/* /< Offset of SS hover Force filter
+					 * frame */
+	u16 u16_ssHvrTxStrenAddr;/* /< Offset of SS hover Force strength frame
+				  * */
+	u16 u16_ssHvrTxBaselineAddr;	/* /< Offset of SS hover Force baseline
+					 * frame */
+
+	u16 u16_ssHvrRxRawAddr;	/* /< Offset of SS hover Sense raw frame */
+	u16 u16_ssHvrRxFilterAddr;	/* /< Offset of SS hover Sense filter
+					 * frame */
+	u16 u16_ssHvrRxStrenAddr;	/* /< Offset of SS hover Sense strength
+					 * frame */
+	u16 u16_ssHvrRxBaselineAddr;	/* /< Offset of SS hover Sense baseline
+					 * frame */
+
+	u16 u16_ssPrxTxRawAddr;	/* /< Offset of SS proximity force raw frame */
+	u16 u16_ssPrxTxFilterAddr;	/* /< Offset of SS proximity force
+					 * filter frame */
+	u16 u16_ssPrxTxStrenAddr;/* /< Offset of SS proximity force strength
+				 * frame */
+	u16 u16_ssPrxTxBaselineAddr;	/* /< Offset of SS proximity force
+					 * baseline frame */
+
+	u16 u16_ssPrxRxRawAddr;	/* /< Offset of SS proximity sense raw frame */
+	u16 u16_ssPrxRxFilterAddr;	/* /< Offset of SS proximity sense
+					 * filter frame */
+	u16 u16_ssPrxRxStrenAddr;/* /< Offset of SS proximity sense strength
+				  * frame */
+	u16 u16_ssPrxRxBaselineAddr;	/* /< Offset of SS proximity sense
+					 * baseline frame */
+
+	u16 u16_ssDetRawAddr;		/* /< Offset of SS detect raw frame */
+	u16 u16_ssDetFilterAddr;	/* /< Offset of SS detect filter
+					 * frame */
+	u16 u16_ssDetStrenAddr;		/* /< Offset of SS detect strength
+					 * frame */
+	u16 u16_ssDetBaselineAddr;	/* /< Offset of SS detect baseline
+					 * frame */
+} SysInfo;
+
+#define MAX_LIMIT_FILE_NAME 100	/* max number of chars of the limit file name
+				 */
+#define CHUNK_PROC	1024	/* Max chunk of data printed on the sequential
+				 * file in each iteration */
+
+/**
+  * Struct which store the data coming from a Production Limit File
+  */
+typedef struct {
+	char *data;	/* /< pointer to an array of char which contains
+			  * the content of the Production Limit File */
+	int size;	/* /< size of data */
+	char name[MAX_LIMIT_FILE_NAME];	/* /< identifier of the source from
+					  * where the limits data were loaded
+					  * (if loaded from a file it will be
+					  * the file name, while if loaded
+					  * from .h will be "NULL") */
+} LimitFile;
+
+/**
+  * Possible actions that can be requested by an host
+  */
+typedef enum {
+	ACTION_WRITE				= (u16) 0x0001,	/* /< Bus Write
+								 * */
+	ACTION_READ				= (u16) 0x0002,	/* /< Bus Read
+								 * */
+	ACTION_WRITE_READ			= (u16) 0x0003,	/* /< Bus Write
+								 * followed by a
+								 * Read */
+	ACTION_GET_VERSION			= (u16) 0x0004,	/* /< Get
+								 * Version of
+								 * the protocol
+								 * (equal to the
+								 * first 2 bye
+								 * of driver
+								 * version) */
+	ACTION_WRITEU8UX			= (u16) 0x0011,	/* /< Bus Write
+								 * with support
+								 * to different
+								 * address size
+								 * */
+	ACTION_WRITEREADU8UX			= (u16) 0x0012,	/* /< Bus
+								 * writeRead
+								 * with support
+								 * to different
+								 * address size
+								 * */
+	ACTION_WRITETHENWRITEREAD		= (u16) 0x0013,	/* /< Bus write
+								 * followed by a
+								 * writeRead */
+	ACTION_WRITEU8XTHENWRITEREADU8UX	= (u16) 0x0014,	/* /< Bus write
+								 * followed by a
+								 * writeRead
+								 * with support
+								 * to different
+								 * address size
+								 * */
+	ACTION_WRITEU8UXTHENWRITEU8UX		= (u16) 0x0015,	/* /< Bus write
+								 * followed by a
+								 * write with
+								 * support to
+								 * different
+								 * address size
+								 * */
+	ACTION_GET_FW				= (u16) 0x1000,	/* /< Get Fw
+								 * file content
+								 * used by the
+								 * driver */
+	ACTION_GET_LIMIT			= (u16) 0x1001	/* /< Get Limit
+								 * File content
+								 * used by the
+								 * driver */
+} Actions;
+/**
+  * Struct used to contain info of the message received by the host in
+  * Scriptless mode
+  */
+typedef struct {
+	u16 msg_size;	/* /< total size of the message in bytes */
+	u16 counter;	/* /< counter ID to identify a message */
+	Actions action;	/* /< type of operation requested by the host @see
+			 * Actions */
+	u8 dummy;	/* /< (optional)in case of any kind of read operations,
+			 * specify if the first byte is dummy */
+} Message;
+
+/**
+  * FTS capacitive touch screen device information
+  * - dev             Pointer to the structure device \n
+  * - client          client structure \n
+  * - input_dev       Input device structure \n
+  * - work            Work thread \n
+  * - event_wq        Event queue for work thread \n
+  * - event_dispatch_table  Event dispatch table handlers \n
+  * - attrs           SysFS attributes \n
+  * - mode            Device operating mode (bitmask) \n
+  * - touch_id        Bitmask for touch id (mapped to input slots) \n
+  * - stylus_id       Bitmask for tracking the stylus touches (mapped using the
+  *                   touchId) \n
+  * - timer           Timer when operating in polling mode \n
+  * - power           Power on/off routine \n
+  * - board           HW info retrieved from device tree \n
+  * - vdd_reg         DVDD power regulator \n
+  * - avdd_reg        AVDD power regulator \n
+  * - resume_bit      Indicate if screen off/on \n
+  * - fwupdate_stat   Store the result of a fw update triggered by the host \n
+  * - notifier        Used for be notified from a suspend/resume event \n
+  * - sensor_sleep    true suspend was called, false resume was called \n
+  * - wakesrc         Wakeup Source struct \n
+  * - input_report_mutex  mutex for handling the pressure of keys \n
+  * - series_of_switches  to store the enabling status of a particular feature
+  *                       from the host \n
+  * - tbn             Touch Bus Negotiator context
+  */
+struct fts_ts_info {
+	struct device           *dev;	/* Pointer to the device */
+#ifdef I2C_INTERFACE
+	struct i2c_client       *client;	/* I2C client structure */
+#else
+	struct spi_device       *client;	/* SPI client structure */
+#endif
+	struct input_dev        *input_dev;	/* Input device structure */
+
+	/* buffer which store the input device name assigned by the kernel */
+	char fts_ts_phys[64];
+
+	struct work_struct suspend_work;	/* Suspend work thread */
+	struct work_struct resume_work;	/* Resume work thread */
+	struct workqueue_struct *event_wq;	/* Used for event handler, */
+						/* suspend, resume threads */
+
+	struct completion bus_resumed;		/* resume_work complete */
+
+	struct pm_qos_request pm_qos_req;
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	struct v4l2_heatmap v4l2;
+	struct heatmap_data mutual_strength_heatmap;
+#endif
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	struct touch_offload_context offload;
+	struct delayed_work offload_resume_work;
+	int touch_offload_active_coords;
+#endif
+
+	bool enable_palm_data_dump;
+	struct delayed_work palm_data_dump_work;
+	struct delayed_work fwu_work;	/* Work for fw update */
+	struct workqueue_struct *fwu_workqueue;	/* Fw update work queue */
+	event_dispatch_handler_t *event_dispatch_table;	/* Dispatch table */
+
+	struct attribute_group attrs;	/* SysFS attributes */
+
+	unsigned int mode;	/* Device operating mode */
+				/* MSB - active or lpm */
+	unsigned long touch_id;	/* Bitmask for touch id */
+	unsigned long palm_touch_mask; /* Bitmask for palm touch */
+	unsigned long grip_touch_mask; /* Bitmask for grip touch */
+#ifdef STYLUS_MODE
+	unsigned long stylus_id;	/* Bitmask for the stylus */
+#endif
+
+	ktime_t timestamp; /* time that the event was first received from the
+		touch IC, acquired during hard interrupt, in CLOCK_MONOTONIC */
+
+	struct fts_hw_platform_data     *board;	/* HW info from device tree */
+	struct regulator        *vdd_reg;	/* DVDD power regulator */
+	struct regulator        *avdd_reg;	/* AVDD power regulator */
+
+	struct pinctrl       *ts_pinctrl;		/* touch pin control state holder */
+	struct pinctrl_state *pinctrl_state_active;	/* Active pin state*/
+	struct pinctrl_state *pinctrl_state_suspend;	/* Suspend pin state*/
+	struct pinctrl_state *pinctrl_state_release;	/* Release pin state*/
+
+	spinlock_t fts_int;	/* Spinlock to protect interrupt toggling */
+	bool irq_enabled;	/* Interrupt state */
+
+	struct mutex io_mutex;	/* Protect access to the I/O */
+	struct mutex bus_mutex;	/* Protect access to the bus */
+	unsigned int bus_refmask; /* References to the bus */
+
+	int resume_bit;	/* Indicate if screen off/on */
+	int fwupdate_stat;	/* Result of a fw update */
+	int reflash_fw;	/* Attempt to reflash fw */
+	int autotune_stat;	/* Attempt to autotune */
+
+	struct fts_disp_extinfo extinfo;	/* Display extended info */
+
+	struct drm_bridge panel_bridge;
+	struct drm_connector *connector;
+	bool is_panel_lp_mode;
+#ifdef DYNAMIC_REFRESH_RATE
+	int display_refresh_rate;	/* Display rate in Hz */
+#endif
+	enum fts_display_state display_state;	/* Display state */
+	bool sensor_sleep;		/* True if suspend called */
+	struct wakeup_source *wakesrc;	/* Wake Lock struct */
+
+	/* input lock */
+	struct mutex input_report_mutex;	/* Mutex for input report */
+
+	/* switches for features */
+	int gesture_enabled;	/* Gesture during suspend */
+	int glove_enabled;	/* Glove mode */
+	int charger_enabled;	/* Charger mode */
+	int stylus_enabled;	/* Stylus mode */
+	int cover_enabled;	/* Cover mode */
+	int grip_enabled;	/* Grip mode */
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	int heatmap_mode;	/* heatmap mode*/
+	bool v4l2_mutual_strength_updated;
+#endif
+	/* Stop changing motion filter and keep fw design */
+	bool use_default_mf;
+	/* Motion filter finite state machine (FSM) state */
+	motion_filter_state_t mf_state;
+	/* Time of initial single-finger touch down. This timestamp is used to
+	 * compute the duration a single finger is touched before it is lifted.
+	 */
+	ktime_t mf_downtime;
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_TBN)
+	u32 tbn_register_mask;
+#endif
+
+	/* Allow only one thread to execute diag command code*/
+	struct mutex diag_cmd_lock;
+	/* Allow one process to open procfs node */
+	bool diag_node_open;
+
+	/* Touch simulation details */
+	struct fts_touchsim touchsim;
+
+	struct proc_dir_entry *fts_dir;
+
+	/* Select the output type of the scriptless protocol
+	 * (binary = 1  or hex string = 0) */
+	u8 bin_output;
+
+	/*  store the amount of data to print into the shell */
+	int limit;
+	/* store the chuk of data that should be printed in this iteration */
+	int chunk;
+	/* store the amount of data already printed in the shell */
+	int printed;
+
+	/* store the information of the Scriptless message received */
+	Message mess;
+
+	SysInfo systemInfo;
+
+	/* The tests to perform during the Mass Production Test */
+	TestToDo tests;
+
+	/* Variable which contains the limit file during test */
+	LimitFile limit_file;
+
+	/* Private variable which implement the Error List */
+	ErrorList errors;
+
+	bool system_reseted_up;	/* flag checked during resume to understand
+				 * if there was a system reset
+				 * and restore the proper state */
+	bool system_reseted_down; /* flag checked during suspend to understand
+				   * if there was a system reset
+				   *  and restore the proper state */
+
+	u8 scanning_frequency;
+
+	/* buffer used to store the command sent from the
+	 * MP device file node */
+	u32 typeOfCommand[CMD_STR_LEN];
+
+	/* number of parameter passed through the MP device file node */
+	int numberParameters;
+
+#ifdef USE_ONE_FILE_NODE
+	int feature_feasibility = ERROR_OP_NOT_ALLOW;
+#endif
+
+#ifdef PHONE_KEY
+	/* store the last update of the key mask published by the IC */
+	u8 key_mask;
+#endif
+	/* pointer to an array of bytes used to store the result of the
+	 * function executed */
+	u8 *driver_test_buff;
+	u8 *stm_fts_cmd_buff;
+	loff_t stm_fts_cmd_buff_len;
+
+	/* buffer used to store the message info received */
+	char buf_chunk[CHUNK_PROC];
+
+	/* Preallocated i/o read buffer */
+	u8 io_read_buf[READ_CHUNK + DUMMY_FIFO];
+	/* Preallocated i/o write buffer */
+	u8 io_write_buf[WRITE_CHUNK + BITS_64 + DUMMY_FIFO];
+	/* Preallocated i/o extra write buffer */
+	u8 io_extra_write_buf[WRITE_CHUNK + BITS_64 + DUMMY_FIFO];
+
+};
+
+/* DSI display function used to read panel extinfo */
+int dsi_panel_read_vendor_extinfo(struct drm_panel *panel, char *buffer,
+				  size_t len);
+
+int fts_chip_powercycle(struct fts_ts_info *info);
+extern int input_register_notifier_client(struct notifier_block *nb);
+extern int input_unregister_notifier_client(struct notifier_block *nb);
+
+/* export declaration of functions in fts_proc.c */
+extern int fts_proc_init(struct fts_ts_info *info);
+extern int fts_proc_remove(struct fts_ts_info *info);
+
+/* Bus reference tracking */
+int fts_set_bus_ref(struct fts_ts_info *info, u16 ref, bool enable);
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/Makefile b/drivers/input/touchscreen/stfts/google/fts_lib/Makefile
new file mode 100644
index 000000000000..f7206571eb0a
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_TOUCHSCREEN_ST_FTS) += ftsCompensation.o ftsCore.o ftsError.o ftsFrame.o ftsIO.o ftsTest.o ftsTime.o ftsTool.o ftsFlash.o ftsGesture.o
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsCompensation.c b/drivers/input/touchscreen/stfts/google/fts_lib/ftsCompensation.c
new file mode 100644
index 000000000000..a3c29331b153
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsCompensation.c
@@ -0,0 +1,1144 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				**
+  **************************************************************************
+  **                        marco.cali@st.com				**
+  **************************************************************************
+  *                                                                        *
+  *               FTS functions for getting Initialization Data		 *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+/*!
+  * \file ftsCompensation.c
+  * \brief Contains all the function to work with Initialization Data
+  */
+
+#include "ftsCompensation.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsFrame.h"
+#include "ftsHardware.h"
+#include "ftsIO.h"
+#include "ftsSoftware.h"
+#include "ftsTime.h"
+#include "ftsTool.h"
+
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/serio.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+
+
+/**
+  * Request to the FW to load the specified Initialization Data into HDM
+  * @param type type of Initialization data to load @link load_opt Load Host
+  * Data Option @endlink
+  * @return OK if success or an error code which specify the type of error
+  */
+int requestHDMDownload(struct fts_ts_info *info, u8 type)
+{
+	int ret = ERROR_OP_NOT_ALLOW;
+	int retry = 0;
+
+	dev_info(info->dev, "%s: Requesting HDM download...\n", __func__);
+	while (retry < RETRY_FW_HDM_DOWNLOAD) {
+		ret = writeSysCmd(info, SYS_CMD_LOAD_DATA,  &type, 1);
+		/* send request to load in memory the Compensation Data */
+		if (ret < OK) {
+			dev_err(info->dev, "%s: failed at %d attemp!\n",
+				 __func__, retry + 1);
+			retry += 1;
+		} else {
+			dev_info(info->dev, "%s: Request HDM Download FINISHED!\n",
+				__func__);
+			return OK;
+		}
+	}
+
+	ret |= ERROR_REQU_HDM_DOWNLOAD;
+	dev_err(info->dev, "%s: Requesting HDM Download... ERROR %08X\n",
+		 __func__, ret);
+
+	return ret;
+}
+
+
+/**
+  * Read HDM Header and check that the type loaded match
+  * with the one previously requested
+  * @param type type of Initialization data requested @link load_opt Load Host
+  * Data Option @endlink
+  * @param header pointer to DataHeader variable which will contain the header
+  * @param address pointer to a variable which will contain the updated address
+  * to the next data
+  * @return OK if success or an error code which specify the type of error
+  */
+int readHDMHeader(struct fts_ts_info *info, u8 type, DataHeader *header,
+		  u64 *address)
+{
+	u64 offset = ADDR_FRAMEBUFFER;
+	u8 data[HDM_DATA_HEADER];
+	int ret;
+
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, offset,
+				data, HDM_DATA_HEADER, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {	/* i2c function have already a retry mechanism */
+		dev_err(info->dev, "%s: error while reading HDM data header ERROR %08X\n",
+			__func__, ret);
+		return ret;
+	}
+
+	dev_info(info->dev, "Read HDM Data Header done!\n");
+
+	if (data[0] != HEADER_SIGNATURE) {
+		dev_err(info->dev, "%s: The Header Signature was wrong! %02X != %02X ERROR %08X\n",
+			__func__, data[0], HEADER_SIGNATURE,
+			ERROR_WRONG_DATA_SIGN);
+		return ERROR_WRONG_DATA_SIGN;
+	}
+
+
+	if (data[1] != type) {
+		dev_err(info->dev, "%s: Wrong type found! %02X!=%02X ERROR %08X\n",
+			__func__, data[1], type, ERROR_DIFF_DATA_TYPE);
+		return ERROR_DIFF_DATA_TYPE;
+	}
+
+	dev_info(info->dev, "Type = %02X of Compensation data OK!\n", type);
+
+	header->type = type;
+
+	*address = offset + HDM_DATA_HEADER;
+
+	return OK;
+}
+
+
+/**
+  * Read MS Global Initialization data from the buffer such as Cx1
+  * @param address pointer to a variable which contain the address from where
+  * to read the data and will contain the updated address to the next data
+  * @param global pointer to MutualSenseData variable which will contain the MS
+  * initialization data
+  * @return OK if success or an error code which specify the type of error
+  */
+static int readMutualSenseGlobalData(struct fts_ts_info *info, u64 *address,
+				     MutualSenseData *global)
+{
+	u8 data[COMP_DATA_GLOBAL];
+	int ret;
+
+	dev_info(info->dev, "Address for Global data= %llx\n", *address);
+
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, *address,
+				data, COMP_DATA_GLOBAL, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while reading info data ERROR %08X\n",
+			__func__, ret);
+		return ret;
+	}
+	dev_info(info->dev, "Global data Read !\n");
+
+	global->header.force_node = data[0];
+	global->header.sense_node = data[1];
+	global->cx1 = data[2];
+	/* all other bytes are reserved atm */
+
+	dev_info(info->dev, "force_len = %d sense_len = %d CX1 = %d\n",
+		 global->header.force_node, global->header.sense_node,
+		 global->cx1);
+
+	*address += COMP_DATA_GLOBAL;
+	return OK;
+}
+
+
+/**
+  * Read MS Initialization data for each node from the buffer
+  * @param address a variable which contain the address from where to read the
+  * data
+  * @param node pointer to MutualSenseData variable which will contain the MS
+  * initialization data
+  * @return OK if success or an error code which specify the type of error
+  */
+static int readMutualSenseNodeData(struct fts_ts_info *info, u64 address,
+				   MutualSenseData *node)
+{
+	int ret;
+	int size = node->header.force_node * node->header.sense_node;
+
+	dev_info(info->dev, "Address for Node data = %llx\n", address);
+
+	node->node_data = (i8 *)kmalloc(size * (sizeof(i8)), GFP_KERNEL);
+
+	if (node->node_data == NULL) {
+		dev_err(info->dev, "%s: can not allocate node_data... ERROR %08X",
+			__func__, ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	dev_info(info->dev, "Node Data to read %d bytes\n", size);
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, address,
+				node->node_data, size, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while reading node data ERROR %08X\n",
+			__func__, ret);
+		kfree(node->node_data);
+		return ret;
+	}
+	node->node_data_size = size;
+
+	dev_info(info->dev, "Read node data OK!\n");
+
+	return size;
+}
+
+/**
+  * Perform all the steps to read the necessary info for MS Initialization data
+  * from the buffer and store it in a MutualSenseData variable
+  * @param type type of MS Initialization data to read @link load_opt Load Host
+  * Data Option @endlink
+  * @param data pointer to MutualSenseData variable which will contain the MS
+  * initialization data
+  * @return OK if success or an error code which specify the type of error
+  */
+int readMutualSenseCompensationData(struct fts_ts_info *info, u8 type,
+				    MutualSenseData *data)
+{
+	int ret;
+	u64 address;
+
+	data->node_data = NULL;
+
+	if (!(type == LOAD_CX_MS_TOUCH || type == LOAD_CX_MS_LOW_POWER ||
+	      type == LOAD_CX_MS_KEY || type == LOAD_CX_MS_FORCE)) {
+		dev_err(info->dev, "%s: Choose a MS type of compensation data ERROR %08X\n",
+			__func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	ret = requestHDMDownload(info, type);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ret);
+		return ret;
+	}
+
+	ret = readHDMHeader(info, type, &(data->header), &address);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_HDM_DATA_HEADER);
+		return ret | ERROR_HDM_DATA_HEADER;
+	}
+
+	ret = readMutualSenseGlobalData(info, &address, data);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_COMP_DATA_GLOBAL);
+		return ret | ERROR_COMP_DATA_GLOBAL;
+	}
+
+	ret = readMutualSenseNodeData(info, address, data);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_COMP_DATA_NODE);
+		return ret | ERROR_COMP_DATA_NODE;
+	}
+
+	return OK;
+}
+
+/**
+  * Read SS Global Initialization data from the buffer such as Ix1/Cx1 for force
+  * and sense
+  * @param address pointer to a variable which contain the address from where
+  * to read the data and will contain the updated address to the next data
+  * @param global pointer to MutualSenseData variable which will contain the SS
+  * initialization data
+  * @return OK if success or an error code which specify the type of error
+  */
+static int readSelfSenseGlobalData(struct fts_ts_info *info, u64 *address, SelfSenseData *global)
+{
+	int ret;
+	u8 data[COMP_DATA_GLOBAL];
+
+	dev_info(info->dev, "Address for Global data= %llx\n", *address);
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, *address,
+				data, COMP_DATA_GLOBAL, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while reading the data... ERROR %08X\n",
+			__func__, ret);
+		return ret;
+	}
+
+	dev_info(info->dev, "Global data Read !\n");
+
+
+	global->header.force_node = data[0];
+	global->header.sense_node = data[1];
+	global->f_ix1 = data[2];
+	global->s_ix1 = data[3];
+	global->f_cx1 = (i8)data[4];
+	global->s_cx1 = (i8)data[5];
+	global->f_max_n = data[6];
+	global->s_max_n = data[7];
+	global->f_ix0 = data[8];
+	global->s_ix0 = data[9];
+
+	dev_info(info->dev, "force_len = %d sense_len = %d  f_ix1 = %d   s_ix1 = %d   f_cx1 = %d   s_cx1 = %d\n",
+		global->header.force_node, global->header.sense_node,
+		global->f_ix1, global->s_ix1, global->f_cx1, global->s_cx1);
+	dev_info(info->dev, "max_n = %d   s_max_n = %d f_ix0 = %d  s_ix0 = %d\n",
+		global->f_max_n, global->s_max_n, global->f_ix0,
+		global->s_ix0);
+
+
+	*address += COMP_DATA_GLOBAL;
+
+	return OK;
+}
+
+/**
+  * Read SS Initialization data for each node of force and sense channels from
+  * the buffer
+  * @param address a variable which contain the address from where to read the
+  * data
+  * @param node pointer to SelfSenseData variable which will contain the SS
+  * initialization data
+  * @return OK if success or an error code which specify the type of error
+  */
+static int readSelfSenseNodeData(struct fts_ts_info *info, u64 address,
+				 SelfSenseData *node)
+{
+	int size = node->header.force_node * 2 + node->header.sense_node * 2;
+	u8 *data;
+	int ret;
+
+	if (size <= 0) {
+		dev_err(info->dev, "%s: Invalid  SS data length!\n", __func__);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	data = kzalloc(size * sizeof(u8), GFP_KERNEL);
+	if (data == NULL)
+		return ERROR_ALLOC;
+
+	node->ix2_fm = (u8 *)kmalloc(node->header.force_node * (sizeof(u8)),
+				     GFP_KERNEL);
+	if (node->ix2_fm == NULL) {
+		dev_err(info->dev, "%s: can not allocate memory for ix2_fm... ERROR %08X",
+			__func__, ERROR_ALLOC);
+		kfree(data);
+		return ERROR_ALLOC;
+	}
+
+	node->cx2_fm = (i8 *)kmalloc(node->header.force_node * (sizeof(i8)),
+				     GFP_KERNEL);
+	if (node->cx2_fm == NULL) {
+		dev_err(info->dev, "%s: can not allocate memory for cx2_fm ... ERROR %08X",
+			__func__, ERROR_ALLOC);
+		kfree(node->ix2_fm);
+		kfree(data);
+		return ERROR_ALLOC;
+	}
+	node->ix2_sn = (u8 *)kmalloc(node->header.sense_node * (sizeof(u8)),
+				     GFP_KERNEL);
+	if (node->ix2_sn == NULL) {
+		dev_err(info->dev, "%s: can not allocate memory for ix2_sn ERROR %08X",
+			__func__, ERROR_ALLOC);
+		kfree(node->ix2_fm);
+		kfree(node->cx2_fm);
+		kfree(data);
+		return ERROR_ALLOC;
+	}
+	node->cx2_sn = (i8 *)kmalloc(node->header.sense_node * (sizeof(i8)),
+				     GFP_KERNEL);
+	if (node->cx2_sn == NULL) {
+		dev_err(info->dev, "%s: can not allocate memory for cx2_sn ERROR %08X",
+			__func__, ERROR_ALLOC);
+		kfree(node->ix2_fm);
+		kfree(node->cx2_fm);
+		kfree(node->ix2_sn);
+		kfree(data);
+		return ERROR_ALLOC;
+	}
+
+
+	dev_info(info->dev, "Address for Node data = %llx\n", address);
+
+	dev_info(info->dev, "Node Data to read %d bytes\n", size);
+
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, address,
+				data, size, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while reading data... ERROR %08X\n",
+			__func__, ret);
+		kfree(node->ix2_fm);
+		kfree(node->cx2_fm);
+		kfree(node->ix2_sn);
+		kfree(node->cx2_sn);
+		kfree(data);
+		return ret;
+	}
+
+	dev_info(info->dev, "Read node data ok!\n");
+
+	memcpy(node->ix2_fm, data, node->header.force_node);
+	memcpy(node->ix2_sn, &data[node->header.force_node],
+	       node->header.sense_node);
+	memcpy(node->cx2_fm, &data[node->header.force_node +
+				   node->header.sense_node],
+	       node->header.force_node);
+	memcpy(node->cx2_sn, &data[node->header.force_node * 2 +
+				   node->header.sense_node],
+	       node->header.sense_node);
+
+	kfree(data);
+	return OK;
+}
+
+/**
+  * Perform all the steps to read the necessary info for SS Initialization data
+  * from the buffer and store it in a SelfSenseData variable
+  * @param type type of SS Initialization data to read @link load_opt Load Host
+  * Data Option @endlink
+  * @param data pointer to SelfSenseData variable which will contain the SS
+  * initialization data
+  * @return OK if success or an error code which specify the type of error
+  */
+int readSelfSenseCompensationData(struct fts_ts_info *info, u8 type,
+				  SelfSenseData *data)
+{
+	int ret;
+	u64 address;
+
+	data->ix2_fm = NULL;
+	data->cx2_fm = NULL;
+	data->ix2_sn = NULL;
+	data->cx2_sn = NULL;
+
+	if (!(type == LOAD_CX_SS_TOUCH || type == LOAD_CX_SS_TOUCH_IDLE ||
+	      type == LOAD_CX_SS_KEY || type == LOAD_CX_SS_FORCE)) {
+		dev_err(info->dev, "%s: Choose a SS type of compensation data ERROR %08X\n",
+			__func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	ret = requestHDMDownload(info, type);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: error while requesting data... ERROR %08X\n",
+			__func__, ret);
+		return ret;
+	}
+
+	ret = readHDMHeader(info, type, &(data->header), &address);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: error while reading data header... ERROR %08X\n",
+			__func__, ERROR_HDM_DATA_HEADER);
+		return ret | ERROR_HDM_DATA_HEADER;
+	}
+
+	ret = readSelfSenseGlobalData(info, &address, data);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_COMP_DATA_GLOBAL);
+		return ret | ERROR_COMP_DATA_GLOBAL;
+	}
+
+	ret = readSelfSenseNodeData(info, address, data);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_COMP_DATA_NODE);
+		return ret | ERROR_COMP_DATA_NODE;
+	}
+
+	return OK;
+}
+
+/**
+  * Read TOT MS Global Initialization data from the buffer such as number of
+  * force and sense channels
+  * @param address pointer to a variable which contain the address from where
+  * to read the data and will contain the updated address to the next data
+  * @param global pointer to a variable which will contain the TOT MS
+  * initialization data
+  * @return OK if success or an error code which specify the type of error
+  */
+static int readTotMutualSenseGlobalData(struct fts_ts_info *info, u64 *address,
+					TotMutualSenseData *global)
+{
+	int ret;
+	u8 data[COMP_DATA_GLOBAL];
+
+	dev_info(info->dev, "Address for Global data= %llx\n", *address);
+
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, *address,
+				data, COMP_DATA_GLOBAL, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while reading info data ERROR %08X\n",
+			__func__, ret);
+		return ret;
+	}
+	dev_info(info->dev, "Global data Read !\n");
+
+	global->header.force_node = data[0];
+	global->header.sense_node = data[1];
+	/* all other bytes are reserved atm */
+
+	dev_info(info->dev, "force_len = %d sense_len = %d\n",
+		global->header.force_node, global->header.sense_node);
+
+	*address += COMP_DATA_GLOBAL;
+	return OK;
+}
+
+
+/**
+  * Read TOT MS Initialization data for each node from the buffer
+  * @param address a variable which contain the address from where to read the
+  * data
+  * @param node pointer to MutualSenseData variable which will contain the TOT
+  * MS initialization data
+  * @return OK if success or an error code which specify the type of error
+  */
+static int readTotMutualSenseNodeData(struct fts_ts_info *info, u64 address,
+				      TotMutualSenseData *node)
+{
+	int ret, i;
+	int size = node->header.force_node * node->header.sense_node;
+	int toRead = size * sizeof(u16);
+	u8 *data;
+
+	if (size <= 0) {
+		dev_err(info->dev, "%s: Invalid MS data length!\n", __func__);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	data = kzalloc(toRead * sizeof(u8), GFP_KERNEL);
+	if (data == NULL)
+		return ERROR_ALLOC;
+
+	dev_info(info->dev, "Address for Node data = %llx\n", address);
+
+	node->node_data = (short *)kmalloc(size * (sizeof(short)), GFP_KERNEL);
+
+	if (node->node_data == NULL) {
+		dev_err(info->dev, "%s: can not allocate node_data... ERROR %08X",
+			__func__, ERROR_ALLOC);
+		kfree(data);
+		return ERROR_ALLOC;
+	}
+
+	dev_info(info->dev, "Node Data to read %d bytes\n", size);
+
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, address, data,
+				toRead, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while reading node data ERROR %08X\n",
+			__func__, ret);
+		kfree(node->node_data);
+		kfree(data);
+		return ret;
+	}
+	node->node_data_size = size;
+
+	for (i = 0; i < size; i++)
+		node->node_data[i] = ((short)data[i * 2 + 1]) << 8 |
+				      data[i * 2];
+
+	dev_info(info->dev, "Read node data OK!\n");
+
+	kfree(data);
+	return size;
+}
+
+/**
+  * Perform all the steps to read the necessary info for TOT MS Initialization
+  * data from the buffer and store it in a TotMutualSenseData variable
+  * @param type type of TOT MS Initialization data to read @link load_opt Load
+  * Host Data Option @endlink
+  * @param data pointer to a variable which will contain the TOT MS
+  * initialization data
+  * @return OK if success or an error code which specify the type of error
+  */
+int readTotMutualSenseCompensationData(struct fts_ts_info *info, u8 type,
+				       TotMutualSenseData *data)
+{
+	int ret;
+	u64 address;
+
+	data->node_data = NULL;
+
+	if (!(type == LOAD_PANEL_CX_TOT_MS_TOUCH || type ==
+	      LOAD_PANEL_CX_TOT_MS_LOW_POWER ||
+	      type == LOAD_PANEL_CX_TOT_MS_KEY ||
+	      type == LOAD_PANEL_CX_TOT_MS_FORCE)) {
+		dev_err(info->dev, "%s: Choose a TOT MS type of compensation data ERROR %08X\n",
+			__func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	ret = requestHDMDownload(info, type);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ret);
+		return ret;
+	}
+
+	ret = readHDMHeader(info, type, &(data->header), &address);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_HDM_DATA_HEADER);
+		return ret | ERROR_HDM_DATA_HEADER;
+	}
+
+	ret = readTotMutualSenseGlobalData(info, &address, data);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_COMP_DATA_GLOBAL);
+		return ret | ERROR_COMP_DATA_GLOBAL;
+	}
+
+	ret = readTotMutualSenseNodeData(info, address, data);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_COMP_DATA_NODE);
+		return ret | ERROR_COMP_DATA_NODE;
+	}
+
+	return OK;
+}
+
+/**
+  * Read TOT SS Global Initialization data from the buffer such as number of
+  * force and sense channels
+  * @param address pointer to a variable which contain the address from where
+  * to read the data and will contain the updated address to the next data
+  * @param global pointer to a variable which will contain the TOT SS
+  * initialization data
+  * @return OK if success or an error code which specify the type of error
+  */
+static int readTotSelfSenseGlobalData(struct fts_ts_info *info, u64 *address,
+				      TotSelfSenseData *global)
+{
+	int ret;
+	u8 data[COMP_DATA_GLOBAL];
+
+	dev_info(info->dev, "Address for Global data= %llx\n", *address);
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, *address,
+				data, COMP_DATA_GLOBAL, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while reading the data... ERROR %08X\n",
+			__func__, ret);
+		return ret;
+	}
+
+	dev_info(info->dev, "Global data Read !\n");
+
+
+	global->header.force_node = data[0];
+	global->header.sense_node = data[1];
+
+
+	dev_info(info->dev, "force_len = %d sense_len = %d\n",
+		global->header.force_node, global->header.sense_node);
+
+
+	*address += COMP_DATA_GLOBAL;
+
+	return OK;
+}
+
+/**
+  * Read TOT SS Global Initialization data from the buffer such as number of
+  * force and sense channels
+  * @param address pointer to a variable which contain the address from where
+  * to read the data and will contain the updated address to the next data
+  * @param node pointer to a variable which will contain the TOT SS
+  * initialization data
+  * @return OK if success or an error code which specify the type of error
+  */
+static int readTotSelfSenseNodeData(struct fts_ts_info *info, u64 address,
+				    TotSelfSenseData *node)
+{
+	int size = node->header.force_node * 2 + node->header.sense_node * 2;
+	int toRead = size * 2;	/* *2 2 bytes each node */
+	u8 *data;
+	int ret, i, j = 0;
+
+	if (size <= 0) {
+		dev_err(info->dev, "%s: Invalid Tot SS data length!\n", __func__);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	data = kzalloc(toRead * sizeof(u8), GFP_KERNEL);
+	if (data == NULL)
+		return ERROR_ALLOC;
+
+	node->ix_fm = (u16 *)kmalloc(node->header.force_node * (sizeof(u16)),
+				     GFP_KERNEL);
+	if (node->ix_fm == NULL) {
+		dev_err(info->dev, "%s: can not allocate memory for ix2_fm... ERROR %08X",
+			__func__, ERROR_ALLOC);
+		kfree(data);
+		return ERROR_ALLOC;
+	}
+
+	node->cx_fm = (short *)kmalloc(node->header.force_node *
+				       (sizeof(short)), GFP_KERNEL);
+	if (node->cx_fm == NULL) {
+		dev_err(info->dev, "%s: can not allocate memory for cx2_fm ... ERROR %08X",
+			__func__, ERROR_ALLOC);
+		kfree(node->ix_fm);
+		kfree(data);
+		return ERROR_ALLOC;
+	}
+	node->ix_sn = (u16 *)kmalloc(node->header.sense_node * (sizeof(u16)),
+				     GFP_KERNEL);
+	if (node->ix_sn == NULL) {
+		dev_err(info->dev, "%s: can not allocate memory for ix2_sn ERROR %08X",
+			__func__, ERROR_ALLOC);
+		kfree(node->ix_fm);
+		kfree(node->cx_fm);
+		kfree(data);
+		return ERROR_ALLOC;
+	}
+	node->cx_sn = (short *)kmalloc(node->header.sense_node *
+				       (sizeof(short)), GFP_KERNEL);
+	if (node->cx_sn == NULL) {
+		dev_err(info->dev, "%s: can not allocate memory for cx2_sn ERROR %08X",
+			__func__, ERROR_ALLOC);
+		kfree(node->ix_fm);
+		kfree(node->cx_fm);
+		kfree(node->ix_sn);
+		kfree(data);
+		return ERROR_ALLOC;
+	}
+
+
+	dev_info(info->dev, "Address for Node data = %llx\n", address);
+
+	dev_info(info->dev, "Node Data to read %d bytes\n", size);
+
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, address,
+				data, toRead, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while reading data... ERROR %08X\n",
+			__func__, ret);
+		kfree(node->ix_fm);
+		kfree(node->cx_fm);
+		kfree(node->ix_sn);
+		kfree(node->cx_sn);
+		kfree(data);
+		return ret;
+	}
+
+	dev_info(info->dev, "Read node data ok!\n");
+
+	j = 0;
+	for (i = 0; i < node->header.force_node; i++) {
+		node->ix_fm[i] = ((u16)data[j + 1]) << 8 | data[j];
+		j += 2;
+	}
+
+	for (i = 0; i < node->header.sense_node; i++) {
+		node->ix_sn[i] = ((u16)data[j + 1]) << 8 | data[j];
+		j += 2;
+	}
+
+	for (i = 0; i < node->header.force_node; i++) {
+		node->cx_fm[i] = ((short)data[j + 1]) << 8 | data[j];
+		j += 2;
+	}
+
+	for (i = 0; i < node->header.sense_node; i++) {
+		node->cx_sn[i] = ((short)data[j + 1]) << 8 | data[j];
+		j += 2;
+	}
+
+	if (j != toRead)
+		dev_err(info->dev, "%s: parsed a wrong number of bytes %d!=%d\n",
+			__func__, j, toRead);
+
+	kfree(data);
+	return OK;
+}
+
+/**
+  * Perform all the steps to read the necessary info for TOT SS Initialization
+  * data from the buffer and store it in a TotSelfSenseData variable
+  * @param type type of TOT MS Initialization data to read @link load_opt Load
+  * Host Data Option @endlink
+  * @param data pointer to a variable which will contain the TOT MS
+  * initialization data
+  * @return OK if success or an error code which specify the type of error
+  */
+int readTotSelfSenseCompensationData(struct fts_ts_info *info, u8 type,
+				     TotSelfSenseData *data)
+{
+	int ret;
+	u64 address;
+
+	data->ix_fm = NULL;
+	data->cx_fm = NULL;
+	data->ix_sn = NULL;
+	data->cx_sn = NULL;
+
+	if (!(type == LOAD_PANEL_CX_TOT_SS_TOUCH || type ==
+	      LOAD_PANEL_CX_TOT_SS_TOUCH_IDLE || type ==
+	      LOAD_PANEL_CX_TOT_SS_KEY ||
+	      type == LOAD_PANEL_CX_TOT_SS_FORCE)) {
+		dev_err(info->dev, "%s: Choose a TOT SS type of compensation data ERROR %08X\n",
+			__func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	ret = requestHDMDownload(info, type);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: error while requesting data... ERROR %08X\n",
+			__func__, ret);
+		return ret;
+	}
+
+	ret = readHDMHeader(info, type, &(data->header), &address);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: error while reading data header... ERROR %08X\n",
+			__func__, ERROR_HDM_DATA_HEADER);
+		return ret | ERROR_HDM_DATA_HEADER;
+	}
+
+	ret = readTotSelfSenseGlobalData(info, &address, data);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_COMP_DATA_GLOBAL);
+		return ret | ERROR_COMP_DATA_GLOBAL;
+	}
+
+	ret = readTotSelfSenseNodeData(info, address, data);
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_COMP_DATA_NODE);
+		return ret | ERROR_COMP_DATA_NODE;
+	}
+
+	return OK;
+}
+
+
+/**
+  * Read Initialization Data Header for the Coefficients and check that the type
+  *  loaded match with the one previously requested
+  * @param type type of Coefficients data requested @link load_opt Load Host
+  * Data Option @endlink
+  * @param msHeader pointer to DataHeader variable for the MS Coefficients
+  * @param ssHeader pointer to DataHeader variable for the SS Coefficients
+  * @param address pointer to a variable which will contain the updated address
+  * to the next data
+  * @return OK if success or an error code which specify the type of error
+  */
+static int readSensitivityCoeffHeader(struct fts_ts_info *info, u8 type,
+				      DataHeader *msHeader,
+				      DataHeader *ssHeader, u64 *address)
+{
+	u64 offset = ADDR_FRAMEBUFFER;
+	u8 data[SYNCFRAME_DATA_HEADER];
+	int ret;
+
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, offset,
+				data, SYNCFRAME_DATA_HEADER,
+				DUMMY_FRAMEBUFFER);
+	if (ret < OK) {	/* i2c function have already a retry mechanism */
+		dev_err(info->dev, "%s: error while reading data header ERROR %08X\n",
+			__func__, ret);
+		return ret;
+	}
+
+	dev_info(info->dev, "Read Data Header done!\n");
+
+	if (data[0] != HEADER_SIGNATURE) {
+		dev_err(info->dev, "%s: The Header Signature was wrong! %02X != %02X ERROR %08X\n",
+			__func__, data[0], HEADER_SIGNATURE,
+			ERROR_WRONG_DATA_SIGN);
+		return ERROR_WRONG_DATA_SIGN;
+	}
+
+
+	if (data[1] != type) {
+		dev_err(info->dev, "%s: Wrong type found! %02X!=%02X ERROR %08X\n",
+			__func__, data[1], type, ERROR_DIFF_DATA_TYPE);
+		return ERROR_DIFF_DATA_TYPE;
+	}
+
+	dev_info(info->dev, "Type = %02X of Compensation data OK!\n", type);
+
+	msHeader->type = type;
+	ssHeader->type = type;
+
+	msHeader->force_node = data[5];
+	msHeader->sense_node = data[6];
+	dev_info(info->dev, "MS Force Len = %d Sense Len = %d\n",
+		msHeader->force_node, msHeader->sense_node);
+
+	ssHeader->force_node = data[7];
+	ssHeader->sense_node = data[8];
+	dev_info(info->dev, "SS Force Len = %d Sense Len = %d\n",
+		ssHeader->force_node, ssHeader->sense_node);
+
+	*address = offset + SYNCFRAME_DATA_HEADER;
+
+	return OK;
+}
+
+
+/**
+  * Read MS and SS Sensitivity Coefficients for from the IC
+  * @param address a variable which contain the address from where to read the
+  * data
+  * @param msCoeff pointer to MutualSenseCoeff variable which will contain the
+  * MS Coefficient data
+  * @param ssCoeff pointer to SelfSenseCoeff variable which will contain the SS
+  * Coefficient data
+  * @return OK if success or an error code which specify the type of error
+  */
+static int readSensitivityCoeffNodeData(struct fts_ts_info *info, u64 address,
+					MutualSenseCoeff *msCoeff,
+					SelfSenseCoeff *ssCoeff)
+{
+	int size = msCoeff->header.force_node * msCoeff->header.sense_node +
+		   (ssCoeff->header.force_node + ssCoeff->header.sense_node);
+	u8 *data;
+	int ret;
+
+	if (size <= 0) {
+		dev_err(info->dev, "%s:Invalid SS coeff. length!\n", __func__);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	data = kzalloc(size * sizeof(u8), GFP_KERNEL);
+	if (data == NULL)
+		return ERROR_ALLOC;
+
+	msCoeff->node_data_size = msCoeff->header.force_node *
+				  msCoeff->header.sense_node;
+
+	msCoeff->ms_coeff = (u8 *)kmalloc(msCoeff->node_data_size *
+					  (sizeof(u8)), GFP_KERNEL);
+
+	ssCoeff->ss_force_coeff = (u8 *)kmalloc(ssCoeff->header.force_node *
+						(sizeof(u8)), GFP_KERNEL);
+
+	ssCoeff->ss_sense_coeff = (u8 *)kmalloc(ssCoeff->header.sense_node *
+						(sizeof(u8)), GFP_KERNEL);
+	if (msCoeff->ms_coeff == NULL ||
+	    ssCoeff->ss_force_coeff == NULL ||
+	    ssCoeff->ss_sense_coeff == NULL) {
+
+		dev_err(info->dev, "%s: can not allocate memory for coeff ERROR %08X",
+			__func__, ERROR_ALLOC);
+
+		kfree(msCoeff->ms_coeff);
+		msCoeff->ms_coeff = NULL;
+
+		kfree(ssCoeff->ss_force_coeff);
+		ssCoeff->ss_force_coeff = NULL;
+
+		kfree(ssCoeff->ss_sense_coeff);
+		ssCoeff->ss_sense_coeff = NULL;
+
+		kfree(data);
+		return ERROR_ALLOC;
+	}
+
+	dev_info(info->dev, "Address for Node data = %llx\n", address);
+
+	dev_info(info->dev, "Node Data to read %d bytes\n", size);
+
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, address, data,
+				size, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while reading data... ERROR %08X\n",
+			__func__, ret);
+		kfree(msCoeff->ms_coeff);
+		msCoeff->ms_coeff = NULL;
+		kfree(ssCoeff->ss_force_coeff);
+		ssCoeff->ss_force_coeff = NULL;
+		kfree(ssCoeff->ss_sense_coeff);
+		ssCoeff->ss_sense_coeff = NULL;
+		kfree(data);
+		return ret;
+	}
+
+	dev_info(info->dev, "Read node data ok!\n");
+
+	memcpy(msCoeff->ms_coeff, data, msCoeff->node_data_size);
+	memcpy(ssCoeff->ss_force_coeff, &data[msCoeff->node_data_size],
+	       ssCoeff->header.force_node);
+	memcpy(ssCoeff->ss_sense_coeff, &data[msCoeff->node_data_size +
+					      ssCoeff->header.force_node],
+	       ssCoeff->header.sense_node);
+
+	kfree(data);
+	return OK;
+}
+
+
+/**
+  * Perform all the steps to read Sensitivity Coefficients and store into the
+  * corresponding variables
+  * @param msCoeff pointer to a variable which will contain the MS Sensitivity
+  * Coefficients
+  * @param ssCoeff pointer to a variable which will contain the SS Sensitivity
+  * Coefficients
+  * @return OK if success or an error code which specify the type of error
+  */
+int readSensitivityCoefficientsData(struct fts_ts_info *info,
+				    MutualSenseCoeff *msCoeff,
+				    SelfSenseCoeff *ssCoeff)
+{
+	int ret;
+	u64 address;
+
+	msCoeff->ms_coeff = NULL;
+	ssCoeff->ss_force_coeff = NULL;
+	ssCoeff->ss_sense_coeff = NULL;
+
+
+	ret = requestHDMDownload(info, LOAD_SENS_CAL_COEFF);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while requesting data... ERROR %08X\n",
+			__func__, ret);
+		return ret;
+	}
+
+	ret = readSensitivityCoeffHeader(info, LOAD_SENS_CAL_COEFF,
+					 &(msCoeff->header), &(ssCoeff->header),
+					 &address);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while reading data header... ERROR %08X\n",
+			__func__, ERROR_HDM_DATA_HEADER);
+		return ret | ERROR_HDM_DATA_HEADER;
+	}
+
+	ret = readSensitivityCoeffNodeData(info, address, msCoeff, ssCoeff);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_COMP_DATA_NODE);
+		return ret | ERROR_COMP_DATA_NODE;
+	}
+
+	return OK;
+}
+
+/**
+  * Read Golden Mutual Raw data from FW Host Data Memory.
+  * @param address a variable which contain the address from where to read the
+  * data
+  * @param node pointer to GoldenMutualRawData variable.
+  * @return OK if success or an error code which specify the type of error
+  */
+static int readGoldenMutualData(struct fts_ts_info *info,
+				GoldenMutualRawData *pgmData, u64 address)
+{
+	u32 size, i;
+	int ret;
+
+	pgmData->data_size = 0;
+	pgmData->data 	   = NULL;
+
+	dev_info(info->dev, "Address for Golden Mutual hdr = %llx\n", address);
+
+	/* read 12 byte Golden Mutual header */
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16,
+				address, (u8 *)&(pgmData->hdr),
+				GM_DATA_HEADER, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "error while reading Golden Mutual hdr... ERROR %08X\n",
+			ret);
+		goto out;
+	}
+
+	dev_info(info->dev, "ms_force_len = %u ms_sense_len = %u\n",
+		 pgmData->hdr.ms_f_len, pgmData->hdr.ms_s_len);
+	dev_info(info->dev, "ss_force_len = %u ss_sense_len = %u\n",
+		 pgmData->hdr.ss_f_len, pgmData->hdr.ss_s_len);
+ 	dev_info(info->dev, "ms_key_len = %u \n", pgmData->hdr.ms_k_len);
+
+	size = pgmData->hdr.ms_f_len * pgmData->hdr.ms_s_len;
+
+	pgmData->data = kzalloc(size * sizeof(s16), GFP_KERNEL);
+	if (pgmData->data == NULL) {
+		ret = ERROR_ALLOC;
+		dev_err(info->dev, "Unable to allocate memory for GM raw data. ERR %08X",
+			ret);
+		goto out;
+	}
+
+	/* go past both HDM and GM header to read the data */
+	address += GM_DATA_HEADER;
+	dev_info(info->dev, "Address for Golden Mutual data = %llx\n", address);
+
+	//read the data buffer.
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, address,
+				(u8 *)pgmData->data, size * sizeof(s16),
+				DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "error while reading Golden Mutual data... ERROR %08X\n", ret);
+		kfree(pgmData->data);
+		pgmData->data = NULL;
+		goto out;
+	}
+
+	pgmData->data_size = size;
+
+	dev_info(info->dev, "Read data ok!\n");
+
+	for (i = 0; i < size; i++)
+		le16_to_cpus(&pgmData->data[i]);
+
+	ret = OK;
+out:
+	return ret;
+}
+
+/**
+  * Perform all the steps to read the necessary info for Golden Mutual raw
+  * data from the buffer and store it in a GoldemMutualRawData object.
+  * @param pointer to GoldemMutualRawData variable which will contain
+  * the raw data.
+  * @return OK if success or an error code which specify the type of error
+  */
+int readGoldenMutualRawData(struct fts_ts_info *info,
+			    GoldenMutualRawData *pgmData)
+{
+	int ret;
+	u64 address;
+
+	ret = requestHDMDownload(info, LOAD_GOLDEN_MUTUAL_RAW);
+	if (ret < 0) {
+		dev_err(info->dev, "error while requesting HDM Download... ERROR %08X\n",
+			ret);
+		goto out;
+	}
+
+	ret = readHDMHeader(info, LOAD_GOLDEN_MUTUAL_RAW,
+			&pgmData->hdm_hdr, &address);
+	if (ret < 0) {
+		dev_err(info->dev, "error reading HDM header... ERROR %08X\n",
+			ERROR_HDM_DATA_HEADER);
+		ret |= ERROR_HDM_DATA_HEADER;
+		goto out;
+	}
+
+	ret = readGoldenMutualData(info, pgmData, address);
+	if (ret < 0) {
+		dev_err(info->dev, "error reading Golden Mutual data... ERROR %08X\n",
+			ERROR_GOLDEN_MUTUAL_DATA);
+		ret |= ERROR_GOLDEN_MUTUAL_DATA;
+		goto out;
+	}
+
+	ret = OK;
+out:
+	return ret;
+}
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("STMicroelectronics MultiTouch IC Driver");
+MODULE_AUTHOR("STMicroelectronics");
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsCompensation.h b/drivers/input/touchscreen/stfts/google/fts_lib/ftsCompensation.h
new file mode 100644
index 000000000000..c668aac71475
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsCompensation.h
@@ -0,0 +1,188 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				  **
+  **************************************************************************
+  **                        marco.cali@st.com				**
+  **************************************************************************
+  *                                                                        *
+  *               FTS functions for getting Initialization Data		  **
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsCompensation.h
+  * \brief Contains all the definitions and structs to work with Initialization
+  * Data
+  */
+
+#ifndef FTS_COMPENSATION_H
+#define FTS_COMPENSATION_H
+
+#include "ftsCore.h"
+#include "ftsSoftware.h"
+
+
+
+#define RETRY_FW_HDM_DOWNLOAD 2	/* /< max number of attempts to
+				 * request HDM download */
+
+
+/* Bytes dimension of HDM content */
+
+#define HDM_DATA_HEADER	DATA_HEADER	/* /< size in bytes of
+						 * initialization data header */
+#define COMP_DATA_GLOBAL	(16 - HDM_DATA_HEADER)	/* /< size in bytes
+							 * of initialization
+							 * data general info */
+#define GM_DATA_HEADER		(16 - HDM_DATA_HEADER)	/* /< size in bytes of
+ 						* Golden Mutual data header */
+
+
+#define HEADER_SIGNATURE	0xA5	/* /< signature used as starting byte of
+					 * data loaded in memory */
+
+
+
+/**
+  * Struct which contains the general info about Frames and Initialization Data
+  */
+typedef struct {
+	int force_node;	/* /< Number of Force Channels in the
+			 * frame/Initialization data */
+	int sense_node;	/* /< Number of Sense Channels in the
+			 * frame/Initialization data */
+	int type;	/* /< Type of frame/Initialization data */
+} DataHeader;
+
+/**
+  * Struct which contains the MS Initialization data
+  */
+typedef struct {
+	DataHeader header;	/* /< Header */
+	i8 cx1;			/* /< Cx1 value (can be negative)) */
+	i8 *node_data;	/* /< Pointer to an array of bytes which contains the
+			 * CX2 data (can be negative) */
+	int node_data_size;	/* /< size of the data */
+} MutualSenseData;
+
+
+/**
+  * Struct which contains the SS Initialization data
+  */
+typedef struct {
+	DataHeader header;	/* /< Header */
+	u8 f_ix1;	/* /< IX1 Force */
+	u8 s_ix1;	/* /< IX1 Sense */
+	i8 f_cx1;	/* /< CX1 Force (can be negative) */
+	i8 s_cx1;	/* /< CX1 Sense (can be negative) */
+	u8 f_max_n;	/* /< Force MaxN */
+	u8 s_max_n;	/* /< Sense MaxN */
+	u8 f_ix0;	/* /< IX0 Force */
+	u8 s_ix0;	/* /< IX0 Sense */
+
+	u8 *ix2_fm;	/* /< pointer to an array of bytes which contains Force
+			 * Ix2 data node */
+	u8 *ix2_sn;	/* /< pointer to an array of bytes which contains Sense
+			 * Ix2 data node */
+	i8 *cx2_fm;	/* /< pointer to an array of bytes which contains Force
+			 * Cx2 data node
+			 * (can be negative) */
+	i8 *cx2_sn;	/* /< pointer to an array of bytes which contains Sense
+			 * Cx2 data node
+			 * (can be negative)) */
+} SelfSenseData;
+
+/**
+  * Struct which contains the TOT MS Initialization data
+  */
+typedef struct {
+	DataHeader header;	/* /< Header */
+	short *node_data;	/* /< pointer to an array of ushort which
+				 * contains TOT MS Initialization data */
+	int node_data_size;	/* /< size of data */
+} TotMutualSenseData;
+
+/**
+  * Struct which contains the TOT SS Initialization data
+  */
+typedef struct {
+	DataHeader header;	/* /< Header */
+
+	u16 *ix_fm;	/* /< pointer to an array of ushort which contains TOT
+			 * SS IX Force data */
+	u16 *ix_sn;	/* /< pointer to an array of ushort which contains TOT
+			 * SS IX Sense data */
+	short *cx_fm;	/* /< pointer to an array of ushort which contains TOT
+			 * SS CX Force data
+			 * (can be negative) */
+	short *cx_sn;	/* /< pointer to an array of ushort which contains TOT
+			 * SS CX Sense data
+			 * (can be negative) */
+} TotSelfSenseData;
+
+/**
+  * Struct which contains the Mutual Sense Sensitivity Calibration Coefficients
+  */
+typedef struct {
+	DataHeader header;	/* /< Header */
+	u8 *ms_coeff;	/* /< Pointer to an array of bytes which contains the MS
+			 * Sens coeff */
+	int node_data_size;	/* /< size of coefficients */
+} MutualSenseCoeff;
+
+/**
+  * Struct which contains the Self Sense Sensitivity Calibration Coefficients
+  */
+typedef struct {
+	DataHeader header;	/* /< Header */
+	u8 *ss_force_coeff;	/* /< Pointer to an array of bytes which
+				 * contains the SS Sens Force coeff */
+	u8 *ss_sense_coeff;	/* /< Pointer to an array of bytes which
+				 * contains the SS Sens Sense coeff */
+} SelfSenseCoeff;
+
+/**
+  * Struct which contains the Golden Mutual Header
+  */
+typedef struct {
+	u8 ms_f_len;		/* /< ms force length */
+	u8 ms_s_len;		/* /< ms sense length */
+	u8 ss_f_len;		/* /< ss force length */
+	u8 ss_s_len;		/* /< ss sense length */
+	u8 ms_k_len;		/* /< ms key length   */
+	u8 reserved_0[3];
+	u32 reserved_1;
+}GoldenMutualHdr;
+
+/**
+  * Struct which contains the Golden Mutual Raw data
+  */
+typedef struct {
+	DataHeader hdm_hdr;	/* /< HDM Header */
+	GoldenMutualHdr hdr; 	/* /< Golden Mutual Data Hdr */
+	s16 *data; 	        /* /< pointer to the raw data */
+	u32 data_size; 	        /* /< size of raw data buffer */
+} GoldenMutualRawData;
+
+int requestHDMDownload(struct fts_ts_info *info, u8 type);
+int readHDMHeader(struct fts_ts_info *info, u8 type, DataHeader *header,
+		  u64 *address);
+int readMutualSenseCompensationData(struct fts_ts_info *info, u8 type,
+				    MutualSenseData *data);
+int readSelfSenseCompensationData(struct fts_ts_info *info, u8 type,
+				  SelfSenseData *data);
+int readTotMutualSenseCompensationData(struct fts_ts_info *info, u8 type,
+				       TotMutualSenseData *data);
+int readTotSelfSenseCompensationData(struct fts_ts_info *info, u8 type,
+				     TotSelfSenseData *data);
+int readSensitivityCoefficientsData(struct fts_ts_info *info,
+				    MutualSenseCoeff *msData,
+				    SelfSenseCoeff *ssData);
+int readGoldenMutualRawData(struct fts_ts_info *info,
+			    GoldenMutualRawData *pgmData);
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsCore.c b/drivers/input/touchscreen/stfts/google/fts_lib/ftsCore.c
new file mode 100644
index 000000000000..252d252615f6
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsCore.c
@@ -0,0 +1,1224 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				**
+  **************************************************************************
+  **                        marco.cali@st.com			          **
+  **************************************************************************
+  *                                                                        *
+  *		FTS Core functions					 *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsCore.c
+  * \brief Contains the implementation of the Core functions
+  */
+
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include "ftsCompensation.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsIO.h"
+#include "ftsTest.h"
+#include "ftsTime.h"
+#include "ftsTool.h"
+#include "ftsFrame.h"
+
+
+/**
+  * Initialize core variables of the library.
+  * Must be called during the probe before any other lib function
+  * @param info pointer to fts_ts_info which contains info about the device and
+  * its hw setup
+  * @return OK if success or an error code which specify the type of error
+  */
+int initCore(struct fts_ts_info *info)
+{
+	int ret = OK;
+
+	dev_info(info->dev, "%s: Initialization of the Core...\n", __func__);
+	ret |= openChannel(info->client);
+	ret |= resetErrorList(info);
+	ret |= initTestToDo(info);
+	if (ret < OK)
+		dev_err(info->dev, "%s: Initialization Core ERROR %08X!\n",
+			 __func__, ret);
+	else
+		dev_info(info->dev, "%s: Initialization Finished!\n",
+			 __func__);
+	return ret;
+}
+
+/**
+  * Perform a system reset of the IC.
+  * If the reset pin is associated to a gpio, the function execute an hw reset
+  * (toggling of reset pin) otherwise send an hw command to the IC
+  * @return OK if success or an error code which specify the type of error
+  */
+int fts_system_reset(struct fts_ts_info *info)
+{
+	u8 readData[FIFO_EVENT_SIZE];
+	int event_to_search;
+	int res = -1;
+	int i;
+	u8 data[1] = { SYSTEM_RESET_VALUE };
+
+	event_to_search = (int)EVT_ID_CONTROLLER_READY;
+
+	dev_info(info->dev, "System resetting...\n");
+	for (i = 0; i < RETRY_SYSTEM_RESET && res < 0; i++) {
+		resetErrorList(info);
+		fts_enableInterrupt(info, false);
+		/* disable interrupt before resetting to be able to get boot
+		 * events */
+
+		if (!info->board->reset_gpio)
+			res = fts_writeU8UX(info, FTS_CMD_HW_REG_W,
+					    ADDR_SIZE_HW_REG,
+					    ADDR_SYSTEM_RESET, data, ARRAY_SIZE(
+						    data));
+		else {
+			gpiod_set_value(info->board->reset_gpio, 1);
+			msleep(10);
+			gpiod_set_value(info->board->reset_gpio, 0);
+			res = OK;
+		}
+		if (res < OK)
+			dev_err(info->dev, "fts_system_reset: ERROR %08X\n", ERROR_BUS_W);
+		else {
+			res = pollForEvent(info, &event_to_search, 1, readData,
+					   GENERAL_TIMEOUT);
+			if (res < OK)
+				dev_err(info->dev, "fts_system_reset: ERROR %08X\n", res);
+		}
+	}
+
+	if (res < OK) {
+		dev_err(info->dev, "fts_system_reset...failed after 3 attempts: ERROR %08X\n",
+			(res | ERROR_SYSTEM_RESET_FAIL));
+		return res | ERROR_SYSTEM_RESET_FAIL;
+	} else {
+		dev_dbg(info->dev, "System reset DONE!\n");
+		info->system_reseted_down = 1;
+		info->system_reseted_up = 1;
+		return OK;
+	}
+}
+
+/**
+  * Return the value of system_resetted_down.
+  * @return the flag value: 0 if not set, 1 if set
+  */
+bool isSystemResettedDown(struct fts_ts_info *info)
+{
+	return info->system_reseted_down;
+}
+
+/**
+  * Set the value of system_reseted_down flag
+  * @param val value to write in the flag
+  */
+void setSystemResetedDown(struct fts_ts_info *info, bool val)
+{
+	info->system_reseted_down = val;
+}
+
+/**
+  * Set the value of system_reseted_up flag
+  * @param val value to write in the flag
+  */
+void setSystemResetedUp(struct fts_ts_info *info, bool val)
+{
+	info->system_reseted_up = val;
+}
+
+
+/** @addtogroup events_group
+  * @{
+  */
+
+/**
+  * Poll the FIFO looking for a specified event within a timeout. Support a
+  * retry mechanism.
+  * @param event_to_search pointer to an array of int where each element
+  * correspond to a byte of the event to find.
+  * If the element of the array has value -1, the byte of the event,
+  * in the same position of the element is ignored.
+  * @param event_bytes size of event_to_search
+  * @param readData pointer to an array of byte which will contain the event
+  * found
+  * @param time_to_wait time to wait before going in timeout
+  * @return OK if success or an error code which specify the type of error
+  */
+int pollForEvent(struct fts_ts_info *info, int *event_to_search,
+		 int event_bytes, u8 *readData, int time_to_wait)
+{
+	const u8 NO_RESPONSE = 0xFF;
+	const int POLL_SLEEP_TIME_MS = 5;
+	int i, find, retry, count_err;
+	int time_to_count;
+	int err_handling = OK;
+	StopWatch clock;
+
+	u8 cmd[1] = { FIFO_CMD_READONE };
+	char temp[128] = { 0 };
+
+	find = 0;
+	retry = 0;
+	count_err = 0;
+	time_to_count = time_to_wait / POLL_SLEEP_TIME_MS;
+
+	startStopWatch(&clock);
+	while (find != 1 && retry < time_to_count &&
+		fts_writeReadU8UX(info, cmd[0], 0, 0, readData, FIFO_EVENT_SIZE,
+			DUMMY_FIFO)
+	       >= OK) {
+		if (readData[0] == NO_RESPONSE ||
+		    readData[0] == EVT_ID_NOEVENT) {
+			/* No events available, so sleep briefly */
+			msleep(POLL_SLEEP_TIME_MS);
+			retry++;
+			continue;
+		} else if (readData[0] == EVT_ID_ERROR) {
+			/* Log of errors */
+			dev_err(info->dev, "%s\n",
+				 printHex("ERROR EVENT = ",
+					  readData,
+					  FIFO_EVENT_SIZE,
+					  temp,
+					  sizeof(temp)));
+			memset(temp, 0, 128);
+			count_err++;
+			err_handling = errorHandler(info, readData, FIFO_EVENT_SIZE);
+			if ((err_handling & 0xF0FF0000) ==
+			    ERROR_HANDLER_STOP_PROC) {
+				dev_err(info->dev, "pollForEvent: forced to be stopped! ERROR %08X\n",
+					err_handling);
+				return err_handling;
+			}
+		} else {
+			dev_info(info->dev, "%s\n",
+				 printHex("READ EVENT = ", readData,
+					  FIFO_EVENT_SIZE,
+					  temp,
+					  sizeof(temp)));
+			memset(temp, 0, 128);
+
+			if (readData[0] == EVT_ID_CONTROLLER_READY &&
+			    event_to_search[0] != EVT_ID_CONTROLLER_READY) {
+				dev_err(info->dev, "pollForEvent: Unmanned Controller Ready Event! Setting reset flags...\n");
+				setSystemResetedUp(info, 1);
+				setSystemResetedDown(info, 1);
+			}
+		}
+
+		find = 1;
+
+		for (i = 0; i < event_bytes; i++) {
+			if (event_to_search[i] != -1 && (int)readData[i] !=
+			    event_to_search[i]) {
+				find = 0;
+				break;
+			}
+		}
+	}
+	stopStopWatch(&clock);
+	if ((retry >= time_to_count) && find != 1) {
+		dev_err(info->dev, "pollForEvent: ERROR %08X\n", ERROR_TIMEOUT);
+		return ERROR_TIMEOUT;
+	} else if (find == 1) {
+		dev_info(info->dev, "%s\n",
+			 printHex("FOUND EVENT = ",
+				  readData,
+				  FIFO_EVENT_SIZE,
+				  temp,
+				  sizeof(temp)));
+		memset(temp, 0, 128);
+		dev_dbg(info->dev, "Event found in %d ms (%d iterations)! Number of errors found = %d\n",
+			elapsedMillisecond(&clock), retry, count_err);
+		return count_err;
+	} else {
+		dev_err(info->dev, "pollForEvent: ERROR %08X\n", ERROR_BUS_R);
+		return ERROR_BUS_R;
+	}
+}
+
+/** @}*/
+
+/**
+  * Check that the FW sent the echo even after a command was sent
+  * @param cmd pointer to an array of byte which contain the command previously
+  * sent
+  * @param size size of cmd
+  * @return OK if success or an error code which specify the type of error
+  */
+int checkEcho(struct fts_ts_info *info, u8 *cmd, int size)
+{
+	int ret, i;
+	int event_to_search[FIFO_EVENT_SIZE];
+	u8 readData[FIFO_EVENT_SIZE];
+
+
+	if (size < 1) {
+		dev_err(info->dev, "checkEcho: Error Size = %d not valid!\n", size);
+		return ERROR_OP_NOT_ALLOW;
+	} else {
+		if ((size + 4) > FIFO_EVENT_SIZE)
+			size = FIFO_EVENT_SIZE - 4;
+		/* Echo event 0x43 0x01 xx xx xx xx xx fifo_status
+		 * therefore command with more than 4 bytes will be trunked */
+
+		event_to_search[0] = EVT_ID_STATUS_UPDATE;
+		event_to_search[1] = EVT_TYPE_STATUS_ECHO;
+		for (i = 2; i < size + 2; i++)
+			event_to_search[i] = cmd[i - 2];
+		if ((cmd[0] == FTS_CMD_SYSTEM) &&
+			(cmd[1] == SYS_CMD_SPECIAL) &&
+			((cmd[2] == SPECIAL_FULL_PANEL_INIT) ||
+			(cmd[2] == SPECIAL_PANEL_INIT)))
+			ret = pollForEvent(info, event_to_search, size + 2,
+				   readData, TIMEOUT_ECHO_FPI);
+		else if ((cmd[0] == FTS_CMD_SYSTEM) &&
+			(cmd[1] == SYS_CMD_CX_TUNING))
+			ret = pollForEvent(info, event_to_search, size + 2,
+				   readData,
+				   TIMEOUT_ECHO_SINGLE_ENDED_SPECIAL_AUTOTUNE);
+		else if (cmd[0] == FTS_CMD_SYSTEM &&
+			 cmd[1] == SYS_CMD_SPECIAL &&
+			 cmd[2] == SPECIAL_FIFO_FLUSH)
+			ret = pollForEvent(info, event_to_search, size + 2,
+				   readData, TIMEOUT_ECHO_FLUSH);
+		else
+			ret = pollForEvent(info, event_to_search, size + 2,
+				   readData, TIEMOUT_ECHO);
+		if (ret < OK) {
+			dev_err(info->dev, "checkEcho: Echo Event not found! ERROR %08X\n",
+				ret);
+			return ret | ERROR_CHECK_ECHO_FAIL;
+		} else if (ret > OK) {
+			dev_err(info->dev, "checkEcho: Echo Event found but with some error events before! num_error = %d\n",
+				ret);
+			return ERROR_CHECK_ECHO_FAIL;
+		}
+
+		dev_info(info->dev, "ECHO OK!\n");
+		return ret;
+	}
+}
+
+
+/** @addtogroup scan_mode
+  * @{
+  */
+/**
+  * Set a scan mode in the IC
+  * @param mode scan mode to set; possible values @link scan_opt Scan Mode
+  * Option @endlink
+  * @param settings option for the selected scan mode
+  * (for example @link active_bitmask Active Mode Bitmask @endlink)
+  * @return OK if success or an error code which specify the type of error
+  */
+int setScanMode(struct fts_ts_info *info, u8 mode, u8 settings)
+{
+	u8 cmd[3] = { FTS_CMD_SCAN_MODE, mode, settings };
+	u8 cmd1[7] = {0xFA, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00};
+	int ret, size = 3;
+
+	dev_dbg(info->dev, "%s: Setting scan mode: mode = %02X settings = %02X !\n",
+		__func__, mode, settings);
+	if (mode == SCAN_MODE_LOW_POWER)
+		size = 2;
+	ret = fts_write(info, cmd1, 7);
+	if(ret >= OK)
+		ret = fts_write(info, cmd, size);
+	/* use write instead of writeFw because can be called while the
+	 * interrupt are enabled */
+	if (ret < OK) {
+		dev_err(info->dev, "%s: write failed...ERROR %08X !\n",
+			 __func__, ret);
+		return ret | ERROR_SET_SCAN_MODE_FAIL;
+	}
+	dev_dbg(info->dev, "%s: Setting scan mode OK!\n", __func__);
+	return OK;
+}
+/** @}*/
+
+
+/** @addtogroup feat_sel
+  * @{
+  */
+/**
+  * Set a feature and its option in the IC
+  * @param feat feature to set; possible values @link feat_opt Feature Selection
+  * Option @endlink
+  * @param settings pointer to an array of byte which store the options for
+  * the selected feature (for example the gesture mask to activate
+  * @link gesture_opt Gesture IDs @endlink)
+  * @param size in bytes of settings
+  * @return OK if success or an error code which specify the type of error
+  */
+int setFeatures(struct fts_ts_info *info, u8 feat, u8 *settings, int size)
+{
+	u8 *cmd;
+	int i = 0;
+	int ret;
+	char *buff;
+	int buff_len = ((2 + 1) * size + 1) * sizeof(char);
+	int index = 0;
+	u8 cmd1[7] = {0xFA, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+	cmd = kzalloc((2 + size) * sizeof(u8), GFP_KERNEL);
+	buff = kzalloc(buff_len, GFP_KERNEL);
+	if ((buff == NULL) || (cmd == NULL)) {
+		kfree(buff);
+		kfree(cmd);
+		return ERROR_ALLOC;
+        }
+
+	dev_info(info->dev, "%s: Setting feature: feat = %02X !\n", __func__, feat);
+	cmd[0] = FTS_CMD_FEATURE;
+	cmd[1] = feat;
+	for (i = 0; i < size; i++) {
+		cmd[2 + i] = settings[i];
+		index += scnprintf(buff + index, buff_len - index,
+					"%02X ", settings[i]);
+	}
+	dev_info(info->dev, "%s: Settings = %s\n", __func__, buff);
+	ret = fts_write(info, cmd1, 7);
+	if(ret >= OK)
+		ret = fts_write(info, cmd, 2 + size);
+	/* use write instead of writeFw because can be called while the
+	 * interrupts are enabled */
+	if (ret < OK) {
+		dev_err(info->dev, "%s: write failed...ERROR %08X !\n", __func__, ret);
+		kfree(buff);
+		kfree(cmd);
+		return ret | ERROR_SET_FEATURE_FAIL;
+	}
+	dev_info(info->dev, "%s: Setting feature OK!\n", __func__);
+	kfree(cmd);
+	kfree(buff);
+	return OK;
+}
+/** @}*/
+
+/** @addtogroup sys_cmd
+  * @{
+  */
+/**
+  * Write a system command to the IC
+  * @param sys_cmd System Command to execute; possible values
+  * @link sys_opt System Command Option @endlink
+  * @param sett settings option for the selected system command
+  * (@link sys_special_opt Special Command Option @endlink, @link ito_opt
+  * ITO Test Option @endlink, @link load_opt Load Host Data Option @endlink)
+  * @param size in bytes of settings
+  * @return OK if success or an error code which specify the type of error
+  */
+int writeSysCmd(struct fts_ts_info *info, u8 sys_cmd, u8 *sett, int size)
+{
+	u8 *cmd;
+	int ret;
+	char *buff;
+	int buff_len = ((2 + 1) * size + 1) * sizeof(char);
+	int index = 0;
+	u8 cmd1[7] = {0xFA, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+	cmd = kzalloc((2 + size) * sizeof(u8), GFP_KERNEL);
+	buff = kzalloc(buff_len, GFP_KERNEL);
+	if ((buff == NULL) || (cmd == NULL)) {
+	        kfree(buff);
+		kfree(cmd);
+		return ERROR_ALLOC;
+        }
+
+	cmd[0] = FTS_CMD_SYSTEM;
+	cmd[1] = sys_cmd;
+
+	for (ret = 0; ret < size; ret++) {
+		cmd[2 + ret] = sett[ret];
+		index += scnprintf(buff + index, buff_len - index,
+					"%02X ", sett[ret]);
+	}
+	dev_info(info->dev, "%s: Command = %02X %02X %s\n", __func__, cmd[0],
+		 cmd[1], buff);
+	dev_info(info->dev, "%s: Writing Sys command...\n", __func__);
+	if (sys_cmd != SYS_CMD_LOAD_DATA) {
+		ret = fts_write(info, cmd1, 7);
+		if(ret >= OK)
+			ret = fts_writeFwCmd(info, cmd, 2 + size);
+	}
+	else {
+		if (size >= 1)
+			ret = requestSyncFrame(info, sett[0]);
+		else {
+			dev_err(info->dev, "%s: No setting argument! ERROR %08X\n",
+				__func__, ERROR_OP_NOT_ALLOW);
+			kfree(cmd);
+			kfree(buff);
+			return ERROR_OP_NOT_ALLOW;
+		}
+	}
+	if (ret < OK)
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ret);
+	else
+		dev_info(info->dev, "%s: FINISHED!\n", __func__);
+
+	kfree(cmd);
+	kfree(buff);
+	return ret;
+}
+/** @}*/
+
+/** @addtogroup system_info
+  * @{
+  */
+/**
+  * Initialize the System Info Struct with default values according to the error
+  * found during the reading
+  * @param i2cError 1 if there was an I2C error while reading the System Info
+  * data from memory, other value if another error occurred
+  * @return OK if success or an error code which specify the type of error
+  */
+int defaultSysInfo(struct fts_ts_info *info, int i2cError)
+{
+	int i;
+
+	dev_info(info->dev, "Setting default System Info...\n");
+
+	if (i2cError == 1) {
+		info->systemInfo.u16_fwVer = 0xFFFF;
+		info->systemInfo.u16_cfgProjectId = 0xFFFF;
+		for (i = 0; i < RELEASE_INFO_SIZE; i++)
+			info->systemInfo.u8_releaseInfo[i] = 0xFF;
+		info->systemInfo.u16_cxVer = 0xFFFF;
+	} else {
+		info->systemInfo.u16_fwVer = 0x0000;
+		info->systemInfo.u16_cfgProjectId = 0x0000;
+		for (i = 0; i < RELEASE_INFO_SIZE; i++)
+			info->systemInfo.u8_releaseInfo[i] = 0x00;
+		info->systemInfo.u16_cxVer = 0x0000;
+	}
+
+	info->systemInfo.u8_scrRxLen = 0;
+	info->systemInfo.u8_scrTxLen = 0;
+	info->systemInfo.u8_cxAfeVer = 0;
+	info->systemInfo.u8_cfgAfeVer = 0;
+
+	dev_info(info->dev, "default System Info DONE!\n");
+	return OK;
+}
+
+/**
+  * Read the System Info data from memory. System Info is loaded automatically
+  * after every system reset.
+  * @param request if 1, will be asked to the FW to reload the data, otherwise
+  * attempt to read it directly from memory
+  * @return OK if success or an error code which specify the type of error
+  */
+int readSysInfo(struct fts_ts_info *info, int request)
+{
+	int ret, i, index = 0;
+	u8 sett = LOAD_SYS_INFO;
+	u8 data[SYS_INFO_SIZE] = { 0 };
+	char temp[256] = { 0 };
+	SysInfo systemInfo;
+
+	if (request == 1) {
+		dev_info(info->dev, "%s: Requesting System Info...\n", __func__);
+
+		ret = writeSysCmd(info, SYS_CMD_LOAD_DATA, &sett, 1);
+		if (ret < OK) {
+			dev_err(info->dev, "%s: error while writing the sys cmd ERROR %08X\n",
+				__func__, ret);
+			goto FAIL;
+		}
+	}
+
+	dev_info(info->dev, "%s: Reading System Info...\n", __func__);
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16,
+				ADDR_FRAMEBUFFER, data, SYS_INFO_SIZE,
+				DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while reading the system data ERROR %08X\n",
+			__func__, ret);
+		goto FAIL;
+	}
+
+	dev_info(info->dev, "%s: Parsing System Info...\n", __func__);
+
+	if (data[0] != HEADER_SIGNATURE) {
+		dev_err(info->dev, "%s: The Header Signature is wrong!  sign: %02X != %02X ERROR %08X\n",
+			__func__, data[0], HEADER_SIGNATURE,
+			ERROR_WRONG_DATA_SIGN);
+		ret = ERROR_WRONG_DATA_SIGN;
+		goto FAIL;
+	}
+
+
+	if (data[1] != LOAD_SYS_INFO) {
+		dev_err(info->dev, "%s: The Data ID is wrong!  ids: %02X != %02X ERROR %08X\n",
+			__func__, data[3], LOAD_SYS_INFO,
+			ERROR_DIFF_DATA_TYPE);
+		ret = ERROR_DIFF_DATA_TYPE;
+		goto FAIL;
+	}
+
+	index += 4;
+	u8ToU16(&data[index], &systemInfo.u16_apiVer_rev);
+	index += 2;
+	systemInfo.u8_apiVer_minor = data[index++];
+	systemInfo.u8_apiVer_major = data[index++];
+	u8ToU16(&data[index], &systemInfo.u16_chip0Ver);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_chip0Id);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_chip1Ver);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_chip1Id);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_fwVer);
+	index += 2;
+	dev_info(info->dev, "FW VER = %04X\n", systemInfo.u16_fwVer);
+	u8ToU16(&data[index], &systemInfo.u16_svnRev);
+	index += 2;
+	dev_info(info->dev, "SVN REV = %04X\n", systemInfo.u16_svnRev);
+	u8ToU16(&data[index], &systemInfo.u16_cfgVer);
+	index += 2;
+	dev_info(info->dev, "CONFIG VER = %04X\n", systemInfo.u16_cfgVer);
+	u8ToU16(&data[index], &systemInfo.u16_cfgProjectId);
+	index += 2;
+	dev_info(info->dev, "CONFIG PROJECT ID = %04X\n", systemInfo.u16_cfgProjectId);
+	u8ToU16(&data[index], &systemInfo.u16_cxVer);
+	index += 2;
+	dev_info(info->dev, "CX VER = %04X\n", systemInfo.u16_cxVer);
+	u8ToU16(&data[index], &systemInfo.u16_cxProjectId);
+	index += 2;
+	dev_info(info->dev, "CX PROJECT ID = %04X\n", systemInfo.u16_cxProjectId);
+	systemInfo.u8_cfgAfeVer = data[index++];
+	systemInfo.u8_cxAfeVer =  data[index++];
+	systemInfo.u8_panelCfgAfeVer = data[index++];
+	dev_info(info->dev, "AFE VER: CFG = %02X - CX = %02X - PANEL = %02X\n",
+		 systemInfo.u8_cfgAfeVer, systemInfo.u8_cxAfeVer,
+		 systemInfo.u8_panelCfgAfeVer);
+	systemInfo.u8_protocol = data[index++];
+	dev_info(info->dev, "Protocol = %02X\n", systemInfo.u8_protocol);
+	/* index+= 1; */
+	/* skip reserved area */
+
+	/* dev_err(info->dev, "Die Info =  "); */
+	for (i = 0; i < DIE_INFO_SIZE; i++)
+		systemInfo.u8_dieInfo[i] = data[index++];
+
+	/* dev_err(info->dev, "\n"); */
+	dev_info(info->dev, "%s\n",
+		 printHex("Die Info =  ",
+			  systemInfo.u8_dieInfo,
+			  DIE_INFO_SIZE, temp, sizeof(temp)));
+	memset(temp, 0, 256);
+
+
+	/* dev_err(info->dev, "Release Info =  "); */
+	for (i = 0; i < RELEASE_INFO_SIZE; i++)
+		systemInfo.u8_releaseInfo[i] = data[index++];
+
+	/* dev_err(info->dev, "\n"); */
+
+	dev_info(info->dev, "%s\n",
+		 printHex("Release Info =  ",
+			  systemInfo.u8_releaseInfo,
+			  RELEASE_INFO_SIZE,
+			  temp,
+			  sizeof(temp)));
+	memset(temp, 0, 256);
+
+	u8ToU32(&data[index], &systemInfo.u32_fwCrc);
+	index += 4;
+	u8ToU32(&data[index], &systemInfo.u32_cfgCrc);
+	index += 4;
+
+	index += 4;	/* skip reserved area */
+
+	systemInfo.u8_mpFlag = data[index++];
+	dev_info(info->dev, "MP FLAG = %02X\n", systemInfo.u8_mpFlag);
+
+	index += 3 + 4; /* +3 remaining from mp flag address */
+
+	systemInfo.u8_ssDetScanSet = data[index];
+	dev_info(info->dev, "SS Detect Scan Select = %d\n",
+		 systemInfo.u8_ssDetScanSet);
+	index += 4;
+
+	u8ToU16(&data[index], &systemInfo.u16_scrResX);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_scrResY);
+	index += 2;
+	dev_info(info->dev, "Screen Resolution = %d x %d\n",
+		 systemInfo.u16_scrResX, systemInfo.u16_scrResY);
+	systemInfo.u8_scrTxLen = data[index++];
+	dev_info(info->dev, "TX Len = %d\n", systemInfo.u8_scrTxLen);
+	systemInfo.u8_scrRxLen = data[index++];
+	dev_info(info->dev, "RX Len = %d\n", systemInfo.u8_scrRxLen);
+	systemInfo.u8_keyLen = data[index++];
+	dev_info(info->dev, "Key Len = %d\n", systemInfo.u8_keyLen);
+	systemInfo.u8_forceLen = data[index++];
+	dev_info(info->dev, "Force Len = %d\n", systemInfo.u8_forceLen);
+	index += 8;
+
+	u8ToU32(&data[index], &systemInfo.u32_productionTimestamp);
+	dev_info(info->dev, "Production Timestamp = %08X\n",
+	systemInfo.u32_productionTimestamp);
+
+	index += 32;	/* skip reserved area */
+
+	u8ToU16(&data[index], &systemInfo.u16_dbgInfoAddr);
+	index += 2;
+
+	index += 6;	/* skip reserved area */
+
+	u8ToU16(&data[index], &systemInfo.u16_msTchRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_msTchFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_msTchStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_msTchBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssTchTxRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssTchTxFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssTchTxStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssTchTxBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssTchRxRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssTchRxFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssTchRxStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssTchRxBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_keyRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_keyFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_keyStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_keyBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_frcRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_frcFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_frcStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_frcBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrTxRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrTxFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrTxStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrTxBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrRxRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrRxFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrRxStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssHvrRxBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxTxRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxTxFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxTxStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxTxBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxRxRawAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxRxFilterAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxRxStrenAddr);
+	index += 2;
+	u8ToU16(&data[index], &systemInfo.u16_ssPrxRxBaselineAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssDetRawAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssDetFilterAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssDetStrenAddr);
+	index += 2;
+
+	u8ToU16(&data[index], &systemInfo.u16_ssDetBaselineAddr);
+	index += 2;
+
+	memcpy(&info->systemInfo, &systemInfo, sizeof(systemInfo));
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_HEATMAP)
+	if (info->board->tx_rx_dir_swap) {
+		info->v4l2.width = info->systemInfo.u8_scrRxLen;
+		info->v4l2.height = info->systemInfo.u8_scrTxLen;
+	} else {
+		info->v4l2.width = info->systemInfo.u8_scrTxLen;
+		info->v4l2.height = info->systemInfo.u8_scrRxLen;
+	}
+#endif
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_OFFLOAD)
+	info->offload.caps.tx_size = info->systemInfo.u8_scrTxLen;
+	info->offload.caps.rx_size = info->systemInfo.u8_scrRxLen;
+#endif
+
+	dev_info(info->dev, "Parsed %d bytes!\n", index);
+
+
+	if (index != SYS_INFO_SIZE) {
+		dev_err(info->dev, "%s: index = %d different from %d ERROR %08X\n",
+			__func__, index, SYS_INFO_SIZE,
+			ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	dev_info(info->dev, "System Info Read DONE!\n");
+	return OK;
+
+FAIL:
+	defaultSysInfo(info, isI2cError(ret));
+	return ret;
+}
+/** @}*/
+
+
+/**
+  * Read data from the Config Memory
+  * @param offset Starting address in the Config Memory of data to read
+  * @param outBuf pointer of a byte array which contain the bytes to read
+  * @param len number of bytes to read
+  * @return OK if success or an error code which specify the type of error
+  */
+int readConfig(struct fts_ts_info *info, u16 offset, u8 *outBuf, int len)
+{
+	int ret;
+	u64 final_address = offset + ADDR_CONFIG_OFFSET;
+
+	dev_info(info->dev, "%s: Starting to read config memory at %llx ...\n",
+		__func__, final_address);
+	ret = fts_writeReadU8UX(info, FTS_CMD_CONFIG_R, BITS_16, final_address,
+				outBuf, len, DUMMY_CONFIG);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: Impossible to read Config Memory... ERROR %08X!\n",
+			__func__, ret);
+		return ret;
+	}
+
+	dev_info(info->dev, "%s: Read config memory FINISHED!\n", __func__);
+	return OK;
+}
+
+/**
+  * Write data into the Config Memory
+  * @param offset Starting address in the Config Memory where write the data
+  * @param data pointer of a byte array which contain the data to write
+  * @param len number of bytes to write
+  * @return OK if success or an error code which specify the type of error
+  */
+int writeConfig(struct fts_ts_info *info, u16 offset, u8 *data, int len)
+{
+	int ret;
+	u64 final_address = offset + ADDR_CONFIG_OFFSET;
+
+	dev_info(info->dev, "%s: Starting to write config memory at %llx ...\n",
+		__func__, final_address);
+	ret = fts_writeU8UX(info, FTS_CMD_CONFIG_W, BITS_16, final_address, data,
+			    len);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: Impossible to write Config Memory... ERROR %08X!\n",
+			__func__, ret);
+		return ret;
+	}
+
+	dev_info(info->dev, "%s: Write config memory FINISHED!\n", __func__);
+	return OK;
+}
+
+/* Set the interrupt state
+ * @param enable Indicates whether interrupts should enabled.
+ * @return OK if success
+ */
+int fts_enableInterrupt(struct fts_ts_info *info, bool enable)
+{
+	unsigned long flag;
+
+	if (info->client == NULL) {
+		dev_err(info->dev, "Cannot get client irq. Error = %08X\n",
+			ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	spin_lock_irqsave(&info->fts_int, flag);
+
+	if (enable == info->irq_enabled)
+		dev_dbg(info->dev, "Interrupt is already set (enable = %d).\n", enable);
+	else {
+		info->irq_enabled = enable;
+		if (enable) {
+			enable_irq(info->client->irq);
+			dev_dbg(info->dev, "Interrupt enabled.\n");
+		} else {
+			disable_irq_nosync(info->client->irq);
+			dev_dbg(info->dev, "Interrupt disabled.\n");
+		}
+	}
+
+	spin_unlock_irqrestore(&info->fts_int, flag);
+	return OK;
+}
+
+/**
+  * Check if there is a crc error in the IC which prevent the fw to run.
+  * @return  OK if no CRC error, or a number >OK according the CRC error found
+  */
+int fts_crc_check(struct fts_ts_info *info)
+{
+	u8 val;
+	u8 crc_status;
+	int res;
+	u8 error_to_search[6] = { EVT_TYPE_ERROR_CRC_CFG_HEAD,
+				  EVT_TYPE_ERROR_CRC_CFG,
+				  EVT_TYPE_ERROR_CRC_CX,
+				  EVT_TYPE_ERROR_CRC_CX_HEAD,
+				  EVT_TYPE_ERROR_CRC_CX_SUB,
+				  EVT_TYPE_ERROR_CRC_CX_SUB_HEAD };
+
+
+	res = fts_writeReadU8UX(info, FTS_CMD_HW_REG_R, ADDR_SIZE_HW_REG, ADDR_CRC,
+				&val, 1, DUMMY_HW_REG);
+	/* read 2 bytes because the first one is a dummy byte! */
+	if (res < OK) {
+		dev_err(info->dev, "%s Cannot read crc status ERROR %08X\n", __func__, res);
+		return res;
+	}
+
+	crc_status = val & CRC_MASK;
+	if (crc_status != OK) {	/* CRC error if crc_status!=0 */
+		dev_err(info->dev, "%s CRC ERROR = %02X\n", __func__, crc_status);
+		return CRC_CODE;
+	}
+
+	dev_info(info->dev, "%s: Verifying if Config CRC Error...\n", __func__);
+	res = fts_system_reset(info);
+	if (res >= OK) {
+		res = pollForErrorType(info, error_to_search, 2);
+		if (res < OK) {
+			dev_info(info->dev, "%s: No Config CRC Error Found!\n", __func__);
+			dev_info(info->dev, "%s: Verifying if Cx CRC Error...\n", __func__);
+			res = pollForErrorType(info, &error_to_search[2], 4);
+			if (res < OK) {
+				dev_info(info->dev, "%s: No Cx CRC Error Found!\n",
+					__func__);
+				return OK;
+			} else {
+				dev_err(info->dev, "%s: Cx CRC Error found! CRC ERROR = %02X\n",
+					__func__, res);
+				return CRC_CX;
+			}
+		} else {
+			dev_err(info->dev, "%s: Config CRC Error found! CRC ERROR = %02X\n",
+				__func__, res);
+			return CRC_CONFIG;
+		}
+	} else {
+		dev_err(info->dev, "%s: Error while executing system reset! ERROR %08X\n",
+			__func__, res);
+		return res;
+	}
+
+	return OK;
+}
+
+/**
+  * Request a host data and use the sync method to understand when the FW load
+  * it
+  * @param type the type ID of host data to load (@link load_opt Load Host Data
+  * Option  @endlink)
+  * @return OK if success or an error code which specify the type of error
+  */
+int requestSyncFrame(struct fts_ts_info *info, u8 type)
+{
+	u8 request[3] = { FTS_CMD_SYSTEM, SYS_CMD_LOAD_DATA, type };
+	u8 readData[DATA_HEADER] = { 0 };
+	int ret, retry = 0, retry2 = 0, time_to_count;
+	int count, new_count;
+	u8 cmd[7] = {0xFA, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+	dev_info(info->dev, "%s: Starting to get a sync frame...\n", __func__);
+
+	while (retry2 < RETRY_MAX_REQU_DATA) {
+		dev_info(info->dev, "%s: Reading count...\n", __func__);
+
+		ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16,
+					ADDR_FRAMEBUFFER, readData, DATA_HEADER,
+					DUMMY_FRAMEBUFFER);
+		if (ret < OK) {
+			dev_err(info->dev, "%s: Error while reading count! ERROR %08X\n",
+				__func__, ret | ERROR_REQU_DATA);
+			ret |= ERROR_REQU_DATA;
+			retry2++;
+			continue;
+		}
+
+		if (readData[0] != HEADER_SIGNATURE)
+			dev_err(info->dev, "%s: Invalid Signature while reading count! ERROR %08X\n",
+				__func__, ret | ERROR_REQU_DATA);
+
+		count = (readData[3] << 8) | readData[2];
+		new_count = count;
+		dev_info(info->dev, "%s: Base count = %d\n", __func__, count);
+
+		dev_info(info->dev, "%s: Requesting frame %02X  attempt = %d\n",
+			__func__,  type, retry2 + 1);
+		ret = fts_write(info, cmd, 7);
+		if(ret >= OK)
+			ret = fts_write(info, request, ARRAY_SIZE(request));
+		if (ret >= OK) {
+			dev_info(info->dev, "%s: Polling for new count...\n", __func__);
+			time_to_count = TIMEOUT_REQU_DATA / TIMEOUT_RESOLUTION;
+			while (count == new_count && retry < time_to_count) {
+				ret = fts_writeReadU8UX(info,
+							FTS_CMD_FRAMEBUFFER_R,
+							BITS_16,
+							ADDR_FRAMEBUFFER,
+							readData,
+							DATA_HEADER,
+							DUMMY_FRAMEBUFFER);
+				if ((ret >= OK) && (readData[0] ==
+						    HEADER_SIGNATURE) &&
+				    (readData[1] == type))
+					new_count = ((readData[3] << 8) |
+						     readData[2]);
+				else
+					dev_err(info->dev, "%s: invalid Signature or can not read count... ERROR %08X\n",
+						__func__, ret);
+				retry++;
+				mdelay(TIMEOUT_RESOLUTION);
+			}
+
+			if (count == new_count) {
+				dev_err(info->dev, "%s: New count not received! ERROR %08X\n",
+					__func__,
+					ERROR_TIMEOUT | ERROR_REQU_DATA);
+				ret = ERROR_TIMEOUT | ERROR_REQU_DATA;
+			} else {
+				dev_info(info->dev, "%s: New count found! count = %d! Frame ready!\n",
+					__func__, new_count);
+				return OK;
+			}
+		}
+		retry2++;
+	}
+	dev_err(info->dev, "%s: Request Data failed! ERROR %08X\n", __func__, ret);
+	return ret;
+}
+
+/**
+  * Set the Active Scanning Frequency to a defined value
+  * @param freq scanning frequency to set in Hz
+  * @return OK if success or an error code which specify the type of error
+  * @warning The scan frequency can be set only for the MS scan!
+  */
+int setActiveScanFrequency(struct fts_ts_info *info, u32 freq)
+{
+	int res;
+	u8 temp[2] = { 0 };
+	u16 t_cycle;
+
+	dev_info(info->dev, "%s: Setting the scanning frequency to %uHz...\n",
+		__func__, freq);
+
+	/* read MRN register */
+	res = readConfig(info, ADDR_CONFIG_MRN, temp, 1);
+	if (res < OK) {
+		dev_err(info->dev, "%s: error while reading mrn count! ERROR %08X\n",
+			__func__, res);
+		return res;
+	}
+
+	/* setting r count to 0 (= 1 R cycle used) and write it back */
+	temp[0] &= (~0x03);
+	res = writeConfig(info, ADDR_CONFIG_MRN, temp, 1);
+	if (res < OK) {
+		dev_err(info->dev, "%s: error while writing mrn count! ERROR %08X\n",
+			__func__, res);
+		return res;
+	}
+
+	/* set first R cycle slot according the specified frequency */
+	/* read T cycle */
+	res = readConfig(info, ADDR_CONFIG_T_CYCLE, temp, 2);
+	if (res < OK) {
+		dev_err(info->dev, "%s: error while reading T cycle! ERROR %08X\n",
+			__func__, res);
+		return res;
+	}
+	t_cycle = ((u16)(temp[1] << 8)) | temp[0];
+
+
+	/* compute the value of R cycle according the formula
+	  * scan_freq = 30Mhz/(2*(T_cycle+R_cycle)) */
+	temp[0] = (30000000) / (freq * 2) - t_cycle;
+	/* write R cycle in Config Area */
+	dev_info(info->dev, "%s: T cycle  = %d (0x%04X) => R0 cycle = %d (0x%02X)\n",
+		__func__, t_cycle, t_cycle, temp[0], temp[0]);
+	res = writeConfig(info, ADDR_CONFIG_R0_CYCLE, temp, 1);
+	if (res < OK) {
+		dev_err(info->dev, "%s: error while writing R0 cycle! ERROR %08X\n",
+			__func__, res);
+		return res;
+	}
+
+	dev_info(info->dev, "%s: Saving Config into the flash ...\n", __func__);
+	/* save config */
+	temp[0] = SAVE_FW_CONF;
+	res = writeSysCmd(info, SYS_CMD_SAVE_FLASH, temp, 1);
+	if (res < OK) {
+		dev_err(info->dev, "%s: error while saving config into the flash! ERROR %08X\n",
+			__func__, res);
+		return res;
+	}
+
+	/* system reset */
+	res = fts_system_reset(info);
+	if (res < OK) {
+		dev_err(info->dev, "%s: error at system reset! ERROR %08X\n",
+			__func__, res);
+		return res;
+	}
+
+	dev_info(info->dev, "%s: Setting the scanning frequency FINISHED!\n", __func__);
+	return OK;
+}
+
+/**
+  * Write Host Data Memory
+  * @param type type of data to write
+  * @param data pointer to the data which are written
+  * @param msForceLen number of force (Tx) channels used with Mutual
+  * @param msSenseLen number of sense (Rx) channels used with Mutual
+  * @param ssForceLen number of force (Tx) channel used with Self
+  * @param ssSenseLen number of sense (Rx) channel used with Self
+  * @param save if =1 will save the host data written into the flash
+  * @return OK if success or an error code which specify the type of error
+  */
+int writeHostDataMemory(struct fts_ts_info *info, u8 type, u8 *data,
+			u8 msForceLen, u8 msSenseLen,
+			u8 ssForceLen, u8 ssSenseLen, int save)
+{
+	int res;
+	int size = (msForceLen * msSenseLen) + (ssForceLen + ssSenseLen);
+	u8 sett = SPECIAL_WRITE_HOST_MEM_TO_FLASH;
+	u8 *temp;
+
+	temp = kzalloc((size + SYNCFRAME_DATA_HEADER) * sizeof(u8), GFP_KERNEL);
+	if (temp == NULL)
+                return ERROR_ALLOC;
+
+	dev_info(info->dev, "%s: Starting to write Host Data Memory\n", __func__);
+
+	temp[0] = 0x5A;
+	temp[1] = type;
+	temp[5] = msForceLen;
+	temp[6] = msSenseLen;
+	temp[7] = ssForceLen;
+	temp[8] = ssSenseLen;
+
+	memcpy(&temp[16], data, size);
+
+	dev_info(info->dev, "%s: Write Host Data Memory in buffer...\n", __func__);
+	res = fts_writeU8UX(info, FTS_CMD_FRAMEBUFFER_W, BITS_16,
+			    ADDR_FRAMEBUFFER, temp, size +
+			    SYNCFRAME_DATA_HEADER);
+
+	if (res < OK) {
+		dev_err(info->dev, "%s: error while writing the buffer! ERROR %08X\n",
+			__func__, res);
+		kfree(temp);
+		return res;
+	}
+
+	/* save host data memory into the flash */
+	if (save == 1) {
+		dev_info(info->dev, "%s: Trigger writing into the flash...\n", __func__);
+		res = writeSysCmd(info, SYS_CMD_SPECIAL, &sett, 1);
+		if (res < OK) {
+			dev_err(info->dev, "%s: error while writing into the flash! ERROR %08X\n",
+				__func__, res);
+			kfree(temp);
+			return res;
+		}
+	}
+
+
+	dev_info(info->dev, "%s: write Host Data Memory FINISHED!\n", __func__);
+	kfree(temp);
+	return OK;
+}
+
+/*
+ * Save MP flag value into the flash
+ * @param mpflag Value to write in the MP Flag field
+ * @return OK if success or an error code which specify the type of error
+ */
+int saveMpFlag(struct fts_ts_info *info, u8 mpflag)
+{
+	int ret = OK;
+	u8 panelCfg = SAVE_PANEL_CONF;
+
+	dev_info(info->dev, "%s: Saving MP Flag = %02X\n", __func__, mpflag);
+	ret |= writeSysCmd(info, SYS_CMD_MP_FLAG, &mpflag, 1);
+	if (ret < OK)
+		dev_err(info->dev, "%s: Error while writing MP flag on ram... ERROR %08X\n",
+			__func__, ret);
+
+	ret |= writeSysCmd(info, SYS_CMD_SAVE_FLASH, &panelCfg, 1);
+	if (ret < OK)
+		dev_err(info->dev, "%s: Error while saving MP flag on flash... ERROR %08X\n",
+			__func__, ret);
+
+	ret |= readSysInfo(info, 1);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: Error while refreshing SysInfo... ERROR %08X\n",
+			__func__, ret);
+		return ret;
+	}
+
+	dev_info(info->dev, "%s: Saving MP Flag OK!\n", __func__);
+	return OK;
+}
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("STMicroelectronics MultiTouch IC Driver");
+MODULE_AUTHOR("STMicroelectronics");
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsCore.h b/drivers/input/touchscreen/stfts/google/fts_lib/ftsCore.h
new file mode 100644
index 000000000000..42bd3492b254
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsCore.h
@@ -0,0 +1,88 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				**
+  **************************************************************************
+  **                        marco.cali@st.com				 **
+  **************************************************************************
+  *                                                                        *
+  *			FTS Core definitions				 **
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsCore.h
+  * \brief Contains all the definitions and structs of Core functionalities
+  */
+
+#ifndef FTS_CORE_H
+#define FTS_CORE_H
+
+#include "ftsHardware.h"
+#include "ftsSoftware.h"
+#include "../fts.h"
+
+/* HW DATA */
+#define ADDR_SIZE_HW_REG	BITS_32	/* /< value of AddrSize for Hw register
+					 * in FTI @see AddrSize */
+
+#define DATA_HEADER		4	/* /< size in byte of the header loaded
+					 * with the data in the frambuffer */
+
+/**
+  * Type of CRC errors
+  */
+typedef enum {
+	CRC_CODE	= 1,	/* /< CRC in the code section */
+	CRC_CONFIG	= 2,	/* /< CRC in the config section */
+	CRC_CX		= 3,	/* /< CRC in the cx section */
+	CRC_PANEL	= 4	/* /< CRC in the panel section */
+} CRC_Error;
+
+/* CHIP INFO */
+/** @defgroup system_info	System Info
+  * System Info Data collect the most important information about hw and fw
+  * @{
+  */
+/* Size in bytes of System Info data */
+#define SYS_INFO_SIZE			216	/* Num bytes of die info */
+/** @}*/
+
+/* Size in bytes of Debug Info data */
+#define DEBUG_INFO_SIZE			64	/* Num bytes of debug info */
+
+/* RETRY MECHANISM */
+#define RETRY_MAX_REQU_DATA		2	/* /< Max number of attempts
+						 * performed
+						 * when requesting data */
+#define RETRY_SYSTEM_RESET		3	/* /< Max number of attempts
+						 * performed
+						 * to reset the IC */
+
+int initCore(struct fts_ts_info *info);
+int fts_system_reset(struct fts_ts_info *info);
+bool isSystemResettedDown(struct fts_ts_info *info);
+void setSystemResetedUp(struct fts_ts_info *info, bool val);
+void setSystemResetedDown(struct fts_ts_info *info, bool val);
+int pollForEvent(struct fts_ts_info *info, int *event_to_search,
+		 int event_bytes, u8 *readData, int time_to_wait);
+int checkEcho(struct fts_ts_info *info, u8 *cmd, int size);
+int setScanMode(struct fts_ts_info *info, u8 mode, u8 settings);
+int setFeatures(struct fts_ts_info *info, u8 feat, u8 *settings, int size);
+int defaultSysInfo(struct fts_ts_info *info, int i2cError);
+int writeSysCmd(struct fts_ts_info *info, u8 sys_cmd, u8 *sett, int size);
+int readSysInfo(struct fts_ts_info *info, int request);
+int readConfig(struct fts_ts_info *info, u16 offset, u8 *outBuf, int len);
+int writeConfig(struct fts_ts_info *info, u16 offset, u8 *data, int len);
+int fts_enableInterrupt(struct fts_ts_info *info, bool enable);
+int fts_crc_check(struct fts_ts_info *info);
+int requestSyncFrame(struct fts_ts_info *info, u8 type);
+int setActiveScanFrequency(struct fts_ts_info *info, u32 freq);
+int writeHostDataMemory(struct fts_ts_info *info, u8 type, u8 *data,
+			u8 msForceLen, u8 msSenseLen,
+			u8 ssForceLen, u8 ssSenseLen, int save);
+int saveMpFlag(struct fts_ts_info *info, u8 mpflag);
+#endif	/* FTS_CORE_H */
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsError.c b/drivers/input/touchscreen/stfts/google/fts_lib/ftsError.c
new file mode 100644
index 000000000000..63ccfd79930c
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsError.c
@@ -0,0 +1,350 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				 **
+  **************************************************************************
+  **                        marco.cali@st.com				**
+  **************************************************************************
+  *                                                                        *
+  *                  FTS error/info kernel log reporting		  *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsError.c
+  * \brief Contains all the function which handle with Error conditions
+  */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+
+#include "../fts.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsIO.h"
+#include "ftsTool.h"
+#include "ftsCompensation.h"
+
+
+/**
+  * Check if an error code is related to an I2C failure
+  * @param error error code to check
+  * @return 1 if the first level error code is I2C related otherwise 0
+  */
+int isI2cError(int error)
+{
+	if (((error & 0x000000FF) >= (ERROR_BUS_R & 0x000000FF)) &&
+	    ((error & 0x000000FF) <= (ERROR_BUS_O & 0x000000FF)))
+		return 1;
+	else
+		return 0;
+}
+
+
+/**
+  * Dump in the kernel log some debug info in case of FW hang
+  * @param outBuf (optional)pointer to bytes array where to copy the debug info,
+  * if NULL the data will just printed on the kernel log
+  * @param size dimension in bytes of outBuf,
+  * if > ERROR_DUMP_ROW_SIZE*ERROR_DUMP_COL_SIZE, only the first
+  * ERROR_DUMP_ROW_SIZE*ERROR_DUMP_COL_SIZE bytes will be copied
+  * @return OK if success or an error code which specify the type of error
+  */
+int dumpErrorInfo(struct fts_ts_info *info, u8 *outBuf, int size)
+{
+	int ret, i;
+	u8 data[ERROR_DUMP_ROW_SIZE * ERROR_DUMP_COL_SIZE] = { 0 };
+	u32 sign = 0;
+
+	dev_err(info->dev, "%s: Starting dump of error info...\n", __func__);
+
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16,
+				ADDR_ERROR_DUMP, data,
+				ERROR_DUMP_ROW_SIZE * ERROR_DUMP_COL_SIZE,
+				DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: reading data ERROR %08X\n", __func__,
+			 ret);
+		return ret;
+	} else {
+		int buff_len, index = 0;
+		char *buff;
+
+		buff_len = (2 + 1) * ERROR_DUMP_COL_SIZE + 1;
+		buff = kzalloc(buff_len, GFP_KERNEL);
+		if (buff == NULL) {
+			dev_err(info->dev, "%s: fail to allocate buffer\n", __func__);
+			return -ENOMEM;
+		}
+
+		if (outBuf != NULL) {
+			sign = size > ERROR_DUMP_ROW_SIZE *
+			       ERROR_DUMP_COL_SIZE ? ERROR_DUMP_ROW_SIZE *
+			       ERROR_DUMP_COL_SIZE : size;
+			memcpy(outBuf, data, sign);
+			dev_err(info->dev, "%s: error info copied in the buffer!\n",
+				 __func__);
+		}
+		dev_err(info->dev, "%s: Error Info =\n", __func__);
+		u8ToU32(data, &sign);
+		if (sign != ERROR_DUMP_SIGNATURE)
+			dev_err(info->dev, "%s: Wrong Error Signature! Data may be invalid!\n",
+				__func__);
+		else
+			dev_err(info->dev, "%s: Error Signature OK! Data are valid!\n",
+				__func__);
+
+		for (i = 0; i < ERROR_DUMP_ROW_SIZE * ERROR_DUMP_COL_SIZE;
+		     i++) {
+			index += scnprintf(buff + index, buff_len - index,
+					"%02X ", data[i]);
+			if (i % ERROR_DUMP_COL_SIZE ==
+				(ERROR_DUMP_COL_SIZE - 1)) {
+				dev_err(info->dev, "%s: %d) %s\n", __func__,
+					i / ERROR_DUMP_COL_SIZE,
+					buff);
+				index = 0;
+			}
+		}
+
+		kfree(buff);
+		dev_err(info->dev, "%s: dump of error info FINISHED!\n", __func__);
+		return OK;
+	}
+}
+
+
+/**
+  * Implement recovery strategies to be used when an error event is found
+  * while polling the FIFO
+  * @param event error event found during the polling
+  * @param size size of event
+  * @return OK if the error event doesn't require any action or the recovery
+  * strategy doesn't have any impact in the possible procedure that trigger the
+  * error,
+  * otherwise return an error code which specify the kind of error.
+  * If ERROR_HANDLER_STOP_PROC the calling function must stop!
+  */
+int errorHandler(struct fts_ts_info *info, u8 *event, int size)
+{
+	int res = OK;
+
+	if (info != NULL && event != NULL && size > 1 &&
+	    event[0] == EVT_ID_ERROR) {
+		dev_dbg(info->dev, "errorHandler: Starting handling...\n");
+		addErrorIntoList(info, event, size);
+		switch (event[1]) {	/* TODO: write an error log for
+					 * undefined command subtype 0xBA */
+		case EVT_TYPE_ERROR_ESD:	/* esd */
+			res = fts_chip_powercycle(info);
+			if (res < OK)
+				dev_err(info->dev, "errorHandler: Error performing powercycle ERROR %08X\n",
+					res);
+
+			res = fts_system_reset(info);
+			if (res < OK)
+				dev_err(info->dev, "errorHandler: Cannot reset the device ERROR %08X\n",
+					res);
+			res = (ERROR_HANDLER_STOP_PROC | res);
+			break;
+
+		case EVT_TYPE_ERROR_WATCHDOG:	/* watchdog */
+			dumpErrorInfo(info, NULL, 0);
+			res = fts_system_reset(info);
+			if (res < OK)
+				dev_err(info->dev, "errorHandler: Cannot reset the device ERROR %08X\n",
+					res);
+			res = (ERROR_HANDLER_STOP_PROC | res);
+			break;
+
+		case EVT_TYPE_ERROR_ITO_FORCETOGND:
+			dev_err(info->dev, "errorHandler: Force Short to GND!\n");
+			break;
+		case EVT_TYPE_ERROR_ITO_SENSETOGND:
+			dev_err(info->dev, "errorHandler: Sense short to GND!\n");
+			break;
+		case EVT_TYPE_ERROR_ITO_FORCETOVDD:
+			dev_err(info->dev, "errorHandler: Force short to VDD!\n");
+			break;
+		case EVT_TYPE_ERROR_ITO_SENSETOVDD:
+			dev_err(info->dev, "errorHandler: Sense short to VDD!\n");
+			break;
+		case EVT_TYPE_ERROR_ITO_FORCE_P2P:
+			dev_err(info->dev, "errorHandler: Force Pin to Pin Short!\n");
+			break;
+		case EVT_TYPE_ERROR_ITO_SENSE_P2P:
+			dev_err(info->dev, "errorHandler: Sense Pin to Pin Short!\n");
+			break;
+		case EVT_TYPE_ERROR_ITO_FORCEOPEN:
+			dev_err(info->dev, "errorHandler: Force Open !\n");
+			break;
+		case EVT_TYPE_ERROR_ITO_SENSEOPEN:
+			dev_err(info->dev, "errorHandler: Sense Open !\n");
+			break;
+		case EVT_TYPE_ERROR_ITO_KEYOPEN:
+			dev_err(info->dev, "errorHandler: Key Open !\n");
+			break;
+
+		case EVT_TYPE_ERROR_FLASH_FAILED:
+			dev_err(info->dev, "errorHandler: Previous flash failed!\n");
+			info->reflash_fw = 1;
+			break;
+
+		default:
+			dev_dbg(info->dev, "errorHandler: No Action taken!\n");
+			break;
+		}
+		dev_dbg(info->dev, "errorHandler: handling Finished! res = %08X\n",
+			res);
+		return res;
+	} else {
+		dev_err(info->dev, "errorHandler: event Null or not correct size! ERROR %08X\n",
+			ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+}
+
+
+/**
+  * Add an error event into the Error List
+  * @param event error event to add
+  * @param size size of event
+  * @return OK
+  */
+int addErrorIntoList(struct fts_ts_info *info, u8 *event, int size)
+{
+	int i = 0;
+
+	dev_dbg(info->dev, "Adding error in to ErrorList...\n");
+
+	memcpy(&info->errors.list[info->errors.last_index * FIFO_EVENT_SIZE],
+	       event, size);
+	i = FIFO_EVENT_SIZE - size;
+	if (i > 0) {
+		dev_info(info->dev, "Filling last %d bytes of the event with zero...\n", i);
+		memset(&info->errors.list[info->errors.last_index *
+					  FIFO_EVENT_SIZE + size], 0, i);
+	}
+	dev_dbg(info->dev, "Adding error in to ErrorList... FINISHED!\n");
+
+	info->errors.count += 1;
+	if (info->errors.count > FIFO_DEPTH)
+		dev_err(info->dev, "ErrorList is going in overflow... the first %d event(s) were override!\n",
+			info->errors.count - FIFO_DEPTH);
+	info->errors.last_index = (info->errors.last_index + 1) % FIFO_DEPTH;
+
+	return OK;
+}
+
+/**
+  * Reset the Error List setting the count and last_index to 0.
+  * @return OK
+  */
+int resetErrorList(struct fts_ts_info *info)
+{
+	info->errors.count = 0;
+	info->errors.last_index = 0;
+	memset(info->errors.list, 0, FIFO_DEPTH * FIFO_EVENT_SIZE);
+	/* if count is not considered is better reset also the list in order to
+	 * avoid to read data previously copied into the list */
+	return OK;
+}
+
+/**
+  * Get the number of error events copied into the Error List
+  * @return the number of error events into the Error List
+  */
+int getErrorListCount(struct fts_ts_info *info)
+{
+	if (info->errors.count > FIFO_DEPTH)
+		return FIFO_DEPTH;
+	else
+		return info->errors.count;
+}
+
+/* in case of success return the index of the event found */
+/**
+  * Scroll the Error List looking for the event specified
+  * @param event_to_search event_to_search pointer to an array of int where
+  * each element correspond to a byte of the event to find. If the element
+  * of the array has value -1, the byte of the event, in the same position
+  * of the element is ignored.
+  * @param event_bytes size of event_to_search
+  * @return a value >=0 if the event is found which represent the index of
+  * the Error List where the event is located otherwise an error code
+  */
+int pollErrorList(struct fts_ts_info *info, int *event_to_search,
+		  int event_bytes)
+{
+	int i = 0, j = 0, find = 0;
+	int count = getErrorListCount(info);
+
+	dev_dbg(info->dev, "Starting to poll ErrorList...\n");
+	while (find != 1 && i < count) {
+		find = 1;
+		for (j = 0; j < event_bytes; j++) {
+			if ((event_to_search[i] != -1) &&
+			    ((int)info->errors.list[i * FIFO_EVENT_SIZE + j] !=
+			     event_to_search[i])) {
+				find = 0;
+				break;
+			}
+		}
+		i++;
+	}
+	if (find == 1) {
+		dev_dbg(info->dev, "Error Found into ErrorList!\n");
+		return i - 1;	/* there is i++ at the end of the while */
+	} else {
+		dev_err(info->dev, "Error Not Found into ErrorList! ERROR %08X\n",
+			ERROR_TIMEOUT);
+		return ERROR_TIMEOUT;
+	}
+}
+
+
+
+/**
+  * Poll the Error List looking for any error types passed in the arguments.
+  * Return at the first match!
+  * @param list pointer to a list of error types to look for
+  * @param size size of list
+  * @return error type found if success or ERROR_TIMEOUT
+  */
+int pollForErrorType(struct fts_ts_info *info, u8 *list, int size)
+{
+	int i = 0, j = 0, find = 0;
+	int count = getErrorListCount(info);
+
+	dev_info(info->dev, "%s: Starting to poll ErrorList... count = %d\n",
+		__func__, count);
+	while (find != 1 && i < count) {
+		for (j = 0; j < size; j++) {
+			if (list[j] == info->errors.list[i * FIFO_EVENT_SIZE
+							 + 1]) {
+				find = 1;
+				break;
+			}
+		}
+		i++;
+	}
+	if (find == 1) {
+		dev_info(info->dev, "%s: Error Type %02X into ErrorList!\n",
+			__func__, list[j]);
+		return list[j];
+	} else {
+		dev_err(info->dev, "%s: Error Type Not Found into ErrorList! ERROR %08X\n",
+			__func__, ERROR_TIMEOUT);
+		return ERROR_TIMEOUT;
+	}
+}
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("STMicroelectronics MultiTouch IC Driver");
+MODULE_AUTHOR("STMicroelectronics");
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsError.h b/drivers/input/touchscreen/stfts/google/fts_lib/ftsError.h
new file mode 100644
index 000000000000..24c6510a2768
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsError.h
@@ -0,0 +1,222 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				**
+  **************************************************************************
+  **                        marco.cali@st.com				 **
+  **************************************************************************
+  *                                                                        *
+  *                  FTS error/info kernel log reporting		  *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsError.h
+  * \brief Contains all the definitions and structs which refer to Error
+  * conditions
+  */
+
+#ifndef FTS_ERROR_H
+#define FTS_ERROR_H
+
+#include "ftsHardware.h"
+#include "ftsSoftware.h"
+
+
+/** @defgroup error_codes Error Codes
+  * Error codes that can be reported by the driver functions.
+  * An error code is made up by 4 bytes, each byte indicate a logic error
+  * level.\n
+  * From the LSB to the MSB, the logic level increase going from a low level
+  * error (I2C,TIMEOUT) to an high level error (flashing procedure fail,
+  * production test fail etc)
+  * @{
+  */
+
+/* FIRST LEVEL ERROR CODE */
+/** @defgroup first_level	First Level Error Code
+  * @ingroup error_codes
+  * Errors related to low level operation which are not under control of driver,
+  * such as: communication protocol (I2C/SPI), timeout, file operations ...
+  * @{
+  */
+#define OK			(0x00000000)	/* /< No ERROR */
+#define ERROR_ALLOC		(0x80000001)	/* /< allocation of memory
+						 * failed */
+#define ERROR_BUS_R		(0x80000002)	/* /< i2c/spi read failed */
+#define ERROR_BUS_W		(0x80000003)	/* /< i2c/spi write failed */
+#define ERROR_BUS_WR		(0x80000004)	/* /< i2c/spi write/read
+						 * failed */
+#define ERROR_BUS_O		(0x80000005)	/* /< error during
+						 * opening an i2c device */
+#define ERROR_OP_NOT_ALLOW	(0x80000006)	/* /< operation not allowed */
+#define ERROR_TIMEOUT		(0x80000007)	/* /< timeout expired!
+						 * exceed the max number
+						 * of retries or the max
+						 * waiting time */
+#define ERROR_FILE_NOT_FOUND	(0x80000008)	/* /< the file that i
+						 * want to open is not found */
+#define ERROR_FILE_PARSE	(0x80000009)	/* /< error during parsing
+						 * the file */
+#define ERROR_FILE_READ		(0x8000000A)	/* /< error during
+						 * reading the file */
+#define ERROR_LABEL_NOT_FOUND	(0x8000000B)	/* /< label not found */
+#define ERROR_FW_NO_UPDATE	(0x8000000C)	/* /< fw in the chip
+						 * newer than the one in
+						 * the memmh */
+#define ERROR_FLASH_UNKNOWN	(0x8000000D)	/* /< flash status busy
+						 * or unknown */
+/** @}*/
+
+/* SECOND LEVEL ERROR CODE */
+/** @defgroup second_level Second Level Error Code
+  * @ingroup error_codes
+  * Errors related to simple logic operations in the IC which require one
+  * command or which are part of a more complex procedure
+  * @{
+  */
+#define ERROR_DISABLE_INTER		(0x80000200)	/* /< unable to
+							 * disable the
+							 * interrupt */
+#define ERROR_ENABLE_INTER		(0x80000300)	/* /< unable to activate
+							 * the interrupt */
+#define ERROR_READ_CONFIG		(0x80000400)	/* /< failed to read
+							 * config memory */
+#define ERROR_GET_OFFSET		(0x80000500)	/* /< unable to
+							 * read an offset from
+							 * memory */
+#define ERROR_GET_FRAME_DATA		(0x80000600)	/* /< unable to
+							 * retrieve the data of
+							 * a required frame */
+#define ERROR_DIFF_DATA_TYPE		(0x80000700)	/* /< FW answers
+							 * with an event that
+							 * has a different
+							 * address respect the
+							 * request done */
+#define ERROR_WRONG_DATA_SIGN		(0x80000800)	/* /< the signature of
+							 * the host data is not
+							 * HEADER_SIGNATURE */
+#define ERROR_SET_SCAN_MODE_FAIL	(0x80000900)	/* /< setting
+							 * the scanning mode
+							 * failed
+							 * (sense on/off
+							 * etc...) */
+#define ERROR_SET_FEATURE_FAIL		(0x80000A00)	/* /< setting a specific
+							 * feature failed */
+#define ERROR_SYSTEM_RESET_FAIL		(0x80000B00)	/* /< the command
+							 * SYSTEM RESET
+							 * failed */
+#define ERROR_FLASH_NOT_READY		(0x80000C00)	/* /< flash status not
+							 * ready within a
+							 * timeout */
+#define ERROR_FW_VER_READ		(0x80000D00)	/* /< unable to retrieve
+							 * fw_vers or the
+							 * config_id */
+#define ERROR_GESTURE_ENABLE_FAIL	(0x80000E00)	/* /< unable to
+							 * enable/disable
+							 * the gesture */
+#define ERROR_GESTURE_START_ADD		(0x80000F00)	/* /< unable to start to
+							 * add custom gesture */
+#define ERROR_GESTURE_FINISH_ADD	(0x80001000)	/* /< unable to finish
+							 * to add custom gesture
+							 */
+#define ERROR_GESTURE_DATA_ADD		(0x80001100)	/* /< unable to add
+							 * custom gesture data
+							 * */
+#define ERROR_GESTURE_REMOVE		(0x80001200)	/* /< unable to remove
+							 * custom gesture data
+							 * */
+#define ERROR_FEATURE_ENABLE_DISABLE	(0x80001300)	/* /< unable to
+							 * enable/disable a
+							 * feature mode in
+							 * the IC */
+#define ERROR_NOISE_PARAMETERS		(0x80001400)	/* /< unable to set/read
+							 * noise parameter in
+							 * the IC */
+#define ERROR_CH_LEN			(0x80001500)	/* /< unable to retrieve
+							 * the force and/or
+							 * sense length */
+#define ERROR_INFO_BLOCK		(0x80001600)	/* /< info
+							 * block
+							 * corruption */
+/** @}*/
+
+/* THIRD LEVEL ERROR CODE */
+/** @defgroup third_level	Third Level Error Code
+  * @ingroup error_codes
+  * Errors related to logic operations in the IC which require more
+  * commands/steps or which are part of a more complex procedure
+  * @{
+  */
+#define ERROR_REQU_HDM_DOWNLOAD	(0x80010000)	/* /< HDM download
+						 * request failed */
+#define ERROR_REQU_DATA		(0x80020000)	/* /< data request
+						 * failed */
+#define ERROR_HDM_DATA_HEADER	(0x80030000)	/* /< unable to retrieve
+						 * the HDM data
+						 * header */
+#define ERROR_COMP_DATA_GLOBAL	(0x80040000)	/* /< unable to retrieve
+						 * the global
+						 * compensation data */
+#define ERROR_COMP_DATA_NODE	(0x80050000)	/* /< unable to retrieve
+						 * the compensation data
+						 * for each node */
+#define ERROR_TEST_CHECK_FAIL	(0x80060000) /* /< check of
+					      * production limits or
+					      * of fw answers failed */
+#define ERROR_MEMH_READ		(0x80070000)	/* /< memh reading
+						 * failed */
+#define ERROR_FLASH_BURN_FAILED (0x80080000) /* /< flash burn failed */
+#define ERROR_MS_TUNING		(0x80090000) /* /< ms tuning failed */
+#define ERROR_SS_TUNING		(0x800A0000)	/* /< ss tuning failed */
+#define ERROR_LP_TIMER_TUNING	(0x800B0000)	/* /< lp timer
+						 * calibration failed */
+#define ERROR_SAVE_CX_TUNING	(0x800C0000)	/* /< save cx data to
+						 * flash failed */
+#define ERROR_HANDLER_STOP_PROC (0x800D0000)	/* /< stop the poll of the FIFO
+						 * if particular errors are
+						 * found */
+#define ERROR_CHECK_ECHO_FAIL	(0x800E0000)	/* /< unable to retrieve
+						 * echo event */
+#define ERROR_GET_FRAME		(0x800F0000)	/* /< unable to get frame */
+#define ERROR_GOLDEN_MUTUAL_DATA (0x80100000)	/* /< unable to read Golden
+ 						 * Mutual Data */
+/** @}*/
+
+/* FOURTH LEVEL ERROR CODE */
+/** @defgroup fourth_level	Fourth Level Error Code
+  * @ingroup error_codes
+  * Errors related to the highest logic operations in the IC which have an
+  * important impact on the driver flow or which require several commands and
+  * steps to be executed
+  * @{
+  */
+#define ERROR_PROD_TEST_DATA		(0x81000000)	/* /< production data
+							 * test failed */
+#define ERROR_FLASH_PROCEDURE		(0x82000000)	/* /< fw update
+							 * procedure failed */
+#define ERROR_PROD_TEST_ITO		(0x83000000)	/* /< production
+							 * ito test failed */
+#define ERROR_PROD_TEST_INITIALIZATION	(0x84000000) /* /< production
+						      * initialization
+						      * test failed */
+#define ERROR_GET_INIT_STATUS		(0x85000000) /* /< mismatch of the MS or
+						      * SS tuning_version */
+/** @}*/
+
+/** @}*/	/* end of error_commands section */
+
+
+int isI2cError(int error);
+int dumpErrorInfo(struct fts_ts_info *info, u8 *outBuf, int size);
+int errorHandler(struct fts_ts_info *info, u8 *event, int size);
+int addErrorIntoList(struct fts_ts_info *info, u8 *event, int size);
+int getErrorListCount(struct fts_ts_info *info);
+int resetErrorList(struct fts_ts_info *info);
+int pollErrorList(struct fts_ts_info *info, int *event_to_search,
+		  int event_bytes);
+int pollForErrorType(struct fts_ts_info *info, u8 *list, int size);
+#endif
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsFlash.c b/drivers/input/touchscreen/stfts/google/fts_lib/ftsFlash.c
new file mode 100644
index 000000000000..76e294580b1c
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsFlash.c
@@ -0,0 +1,1181 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics                            **
+  **************************************************************************
+  **                        marco.cali@st.com                             **
+  **************************************************************************
+  *                                                                        *
+  *                      FTS API for Flashing the IC                       *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+
+/*!
+  * \file ftsFlash.c
+  * \brief Contains all the functions to handle the FW update process
+  */
+
+#include "ftsCore.h"
+#include "ftsCompensation.h"
+#include "ftsError.h"
+#include "ftsFlash.h"
+#include "ftsFrame.h"
+#include "ftsIO.h"
+#include "ftsSoftware.h"
+#include "ftsTest.h"
+#include "ftsTime.h"
+#include "ftsTool.h"
+#include "../fts.h"	/* needed for including the define FW_H_FILE */
+
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/serio.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/firmware.h>
+
+
+#ifdef FW_H_FILE
+#include "../fts_fw.h"
+#endif
+
+
+/**
+  * Retrieve the actual FW data from the system (bin file or header file)
+  * @param pathToFile name of FW file to load or "NULL" if the FW data should be
+  * loaded by a .h file
+  * @param data pointer to the pointer which will contains the FW data
+  * @param size pointer to a variable which will contain the size of the loaded
+  * data
+  * @return OK if success or an error code which specify the type of error
+  */
+int getFWdata(struct fts_ts_info *info, const char *pathToFile, u8 **data,
+	      int *size)
+{
+	const struct firmware *fw = NULL;
+	int res, from = 0;
+	char *path = (char *)pathToFile;
+
+	dev_info(info->dev, "getFWdata starting ...\n");
+	if (strncmp(pathToFile, "NULL", 4) == 0) {
+		from = 1;
+		if (info != NULL && info->board)
+			path = (char *)info->board->fw_name;
+		else
+			path = PATH_FILE_FW;
+	}
+	/* keep the switch case because if the argument passed is null but
+	 * the option from .h is not set we still try to load from bin */
+	switch (from) {
+#ifdef FW_H_FILE
+	case 1:
+		dev_info(info->dev, "Read FW from .h file!\n");
+		*size = FW_SIZE_NAME;
+		*data = (u8 *)kmalloc((*size) * sizeof(u8), GFP_KERNEL);
+		if (*data == NULL) {
+			dev_err(info->dev, "getFWdata: Impossible to allocate memory! ERROR %08X\n",
+				ERROR_ALLOC);
+			return ERROR_ALLOC;
+		}
+		memcpy(*data, (u8 *)FW_ARRAY_NAME, (*size));
+
+		break;
+#endif
+	default:
+		dev_info(info->dev, "Read FW from BIN file %s !\n", path);
+
+		if (info->dev != NULL) {
+			res = request_firmware(&fw, path, info->dev);
+			if (res == 0) {
+				*size = fw->size;
+				*data = (u8 *)kmalloc((*size) * sizeof(u8),
+						      GFP_KERNEL);
+				if (*data == NULL) {
+					dev_err(info->dev, "getFWdata: Impossible to allocate memory! ERROR %08X\n",
+						ERROR_ALLOC);
+					release_firmware(fw);
+					return ERROR_ALLOC;
+				}
+				memcpy(*data, (u8 *)fw->data, (*size));
+				release_firmware(fw);
+			} else {
+				dev_err(info->dev, "getFWdata: No File found! ERROR %08X\n",
+					ERROR_FILE_NOT_FOUND);
+				return ERROR_FILE_NOT_FOUND;
+			}
+		} else {
+			dev_err(info->dev, "getFWdata: No device found! ERROR %08X\n",
+				ERROR_OP_NOT_ALLOW);
+			return ERROR_OP_NOT_ALLOW;
+		}
+	}
+
+	dev_info(info->dev, "getFWdata Finished!\n");
+	return OK;
+}
+
+
+/**
+  * Perform all the steps to read the FW that should be burnt in the IC from
+  * the system and parse it in order to fill a Firmware struct with the relevant
+  * info
+  * @param path name of FW file to load or "NULL" if the FW data should be
+  * loaded by a .h file
+  * @param fw pointer to a Firmware variable which will contains the FW data and
+  * info
+  * @param keep_cx if 1, the CX area will be loaded otherwise will be skipped
+  * @return OK if success or an error code which specify the type of error
+  */
+int readFwFile(struct fts_ts_info *info, const char *path, Firmware *fw,
+	       int keep_cx)
+{
+	int res;
+	int orig_size;
+	u8 *orig_data = NULL;
+
+
+	res = getFWdata(info, path, &orig_data, &orig_size);
+	if (res < OK) {
+		dev_err(info->dev, "readFwFile: impossible retrieve FW... ERROR %08X\n",
+			ERROR_MEMH_READ);
+		return res | ERROR_MEMH_READ;
+	}
+	res = parseBinFile(info, orig_data, orig_size, fw, keep_cx);
+	if (res < OK) {
+		dev_err(info->dev, "readFwFile: impossible parse ERROR %08X\n",
+			 ERROR_MEMH_READ);
+		return res | ERROR_MEMH_READ;
+	}
+
+	return OK;
+}
+
+/**
+  * Perform all the steps necessary to burn the FW into the IC
+  * @param path name of FW file to load or "NULL" if the FW data should be
+  * loaded by a .h file
+  * @param force if 1, the flashing procedure will be forced and executed
+  * regardless the additional info, otherwise the FW in the file will be burnt
+  * only if it is newer than the one running in the IC
+  * @param keep_cx if 2, load and burn the CX area if the chip and firmware bin
+  * file CX AFE version are different, otherwise untouch this area.
+  * if 1, the CX area will be loaded and burnt otherwise will be skipped and the
+  * area will be untouched.
+  * @return OK if success or an error code which specify the type of error
+  */
+int flashProcedure(struct fts_ts_info *info, const char *path, int force,
+		   int keep_cx)
+{
+	Firmware fw;
+	int res;
+
+	fw.data = NULL;
+	dev_info(info->dev, "Reading Fw file...\n");
+	res = readFwFile(info, path, &fw, keep_cx);
+	if (res < OK) {
+		dev_err(info->dev, "flashProcedure: ERROR %08X\n",
+			 (res | ERROR_FLASH_PROCEDURE));
+		kfree(fw.data);
+		return res | ERROR_FLASH_PROCEDURE;
+	}
+	dev_info(info->dev, "Fw file read COMPLETED!\n");
+
+#ifdef COMPUTE_INIT_METHOD
+	if (keep_cx == CX_CHECK_AFE_VER) {
+		if (fw.cx_afe_ver != (uint32_t)info->systemInfo.u8_cxAfeVer) {
+			keep_cx = CX_ERASE;
+			saveMpFlag(info, MP_FLAG_CX_AFE_CHG);
+		} else {
+			keep_cx = CX_KEEP;
+		}
+		dev_info(info->dev, "Update keep_cx to %d\n", keep_cx);
+	}
+#endif
+
+	dev_info(info->dev, "Starting flashing procedure...\n");
+	res = flash_burn(info, fw, force, keep_cx);
+	if (res < OK && res != (ERROR_FW_NO_UPDATE | ERROR_FLASH_BURN_FAILED)) {
+		dev_err(info->dev, "flashProcedure: ERROR %08X\n",
+			 ERROR_FLASH_PROCEDURE);
+		kfree(fw.data);
+		return res | ERROR_FLASH_PROCEDURE;
+	}
+	dev_info(info->dev, "flashing procedure Finished!\n");
+	kfree(fw.data);
+
+	return res;
+}
+
+/**
+  * Poll the Flash Status Registers after the execution of a command to check
+  * if the Flash becomes ready within a timeout
+  * @param type register to check according to the previous command sent
+  * @return OK if success or an error code which specify the type of error
+  */
+int wait_for_flash_ready(struct fts_ts_info *info, u8 type)
+{
+	u8 cmd[5] = { FTS_CMD_HW_REG_R, 0x20, 0x00, 0x00, type };
+
+	u8 readData[2] = { 0 };
+	int i, res = -1;
+
+	dev_info(info->dev, "Waiting for flash ready ...\n");
+	for (i = 0; i < FLASH_RETRY_COUNT && res != 0; i++) {
+		res = fts_writeRead(info, cmd, ARRAY_SIZE(cmd), readData, 2);
+		if (res < OK)
+			dev_err(info->dev, "wait_for_flash_ready: ERROR %08X\n",
+				ERROR_BUS_W);
+		else {
+#ifdef I2C_INTERFACE	/* in case of spi there is a dummy byte */
+			res = readData[0] & 0x80;
+#else
+			res = readData[1] & 0x80;
+#endif
+
+			dev_info(info->dev, "flash status = %d\n", res);
+		}
+		mdelay(FLASH_WAIT_BEFORE_RETRY);
+	}
+
+	if (i == FLASH_RETRY_COUNT && res != 0) {
+		dev_err(info->dev, "Wait for flash TIMEOUT! ERROR %08X\n",
+			 ERROR_TIMEOUT);
+		return ERROR_TIMEOUT;
+	}
+
+	dev_info(info->dev, "Flash READY!\n");
+	return OK;
+}
+
+
+/**
+  * Put the M3 in hold
+  * @return OK if success or an error code which specify the type of error
+  */
+int hold_m3(struct fts_ts_info *info)
+{
+	int ret;
+	u8 cmd[1] = { 0x01 };
+	u64 address = 0x0;
+
+	dev_info(info->dev, "Command m3 hold...\n");
+	ret = fts_writeU8UX(info, FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG,
+			    ADDR_SYSTEM_RESET, cmd, 1);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ret);
+		return ret;
+	}
+	dev_info(info->dev, "Hold M3 DONE!\n");
+
+#if !defined(I2C_INTERFACE)
+	if (info->client &&
+		(info->client->mode & SPI_3WIRE) == 0) {
+		/* configure manually SPI4 because when no fw is running the
+		 * chip use SPI3 by default */
+		dev_info(info->dev, "Setting SPI4 mode...\n");
+		cmd[0] = 0x10;
+		ret = fts_writeU8UX(info, FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG,
+				    ADDR_GPIO_DIRECTION, cmd, 1);
+		if (ret < OK) {
+			dev_err(info->dev, "%s: can not set gpio dir ERROR %08X\n",
+				__func__, ret);
+			return ret;
+		}
+
+		cmd[0] = 0x02;
+		ret = fts_writeU8UX(info, FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG,
+				    ADDR_GPIO_PULLUP, cmd, 1);
+		if (ret < OK) {
+			dev_err(info->dev, "%s: can not set gpio pull-up ERROR %08X\n",
+				__func__, ret);
+			return ret;
+		}
+
+		if (info->board->dchip_id[0] == ALIX_DCHIP_ID_0 &&
+		    info->board->dchip_id[1] == ALIX_DCHIP_ID_1) {
+			cmd[0] = 0x70;
+			address = ADDR_GPIO_CONFIG_REG3;
+		} else if (info->board->dchip_id[0] == SALIXP_DCHIP_ID_0 &&
+			   info->board->dchip_id[1] == SALIXP_DCHIP_ID_1){
+			cmd[0] = 0x07;
+			address = ADDR_GPIO_CONFIG_REG3;
+		} else {
+			cmd[0] = 0x07;
+			address = ADDR_GPIO_CONFIG_REG2;
+		}
+		ret = fts_writeU8UX(info, FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG,
+				    address, cmd, 1);
+		if (ret < OK) {
+			dev_err(info->dev, "%s: can not set gpio config ERROR %08X\n",
+				__func__, ret);
+			return ret;
+		}
+
+		cmd[0] = 0x30;
+		ret = fts_writeU8UX(info, FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG,
+				    ADDR_GPIO_CONFIG_REG0, cmd, 1);
+		if (ret < OK) {
+			dev_err(info->dev, "%s: can not set gpio config ERROR %08X\n",
+				__func__, ret);
+			return ret;
+		}
+
+		cmd[0] = SPI4_MASK;
+		ret = fts_writeU8UX(info, FTS_CMD_HW_REG_W, ADDR_SIZE_HW_REG,
+			ADDR_ICR, cmd, 1);
+		if (ret < OK) {
+			dev_err(info->dev, "%s: can not set spi4 mode ERROR %08X\n",
+				__func__, ret);
+			return ret;
+		}
+		mdelay(1);	/* wait for the GPIO to stabilize */
+	}
+#endif
+
+	return OK;
+}
+
+
+
+
+/**
+  * Parse the raw data read from a FW file in order to fill properly the fields
+  * of a Firmware variable
+  * @param fw_data raw FW data loaded from system
+  * @param fw_size size of fw_data
+  * @param fwData pointer to a Firmware variable which will contain the
+  * processed data
+  * @param keep_cx if 1, the CX area will be loaded and burnt otherwise will be
+  * skipped and the area will be untouched
+  * @return OK if success or an error code which specify the type of error
+  */
+int parseBinFile(struct fts_ts_info *info, u8 *fw_data, int fw_size,
+		 Firmware *fwData, int keep_cx)
+{
+	int dimension, index = 0;
+	u32 temp;
+	int res, i;
+	char buff[(2 + 1) * EXTERNAL_RELEASE_INFO_SIZE + 1];
+	int buff_len = sizeof(buff);
+	int buff_index = 0;
+
+	/* the file should contain at least the header plus the content_crc */
+	if (fw_size < FW_HEADER_SIZE + FW_BYTES_ALIGN || fw_data == NULL) {
+		dev_err(info->dev, "parseBinFile: Read only %d instead of %d... ERROR %08X\n",
+			fw_size, FW_HEADER_SIZE + FW_BYTES_ALIGN,
+			ERROR_FILE_PARSE);
+		res = ERROR_FILE_PARSE;
+		goto END;
+	} else {
+		/* start parsing of bytes */
+		u8ToU32(&fw_data[index], &temp);
+		if (temp != FW_HEADER_SIGNATURE) {
+			dev_err(info->dev, "parseBinFile: Wrong Signature %08X ... ERROR %08X\n",
+				temp, ERROR_FILE_PARSE);
+			res = ERROR_FILE_PARSE;
+			goto END;
+		}
+		dev_info(info->dev, "parseBinFile: Fw Signature OK!\n");
+		index += FW_BYTES_ALIGN;
+		u8ToU32(&fw_data[index], &temp);
+		if (temp != FW_FTB_VER) {
+			dev_err(info->dev, "parseBinFile: Wrong ftb_version %08X ... ERROR %08X\n",
+				temp, ERROR_FILE_PARSE);
+			res = ERROR_FILE_PARSE;
+			goto END;
+		}
+		dev_info(info->dev, "parseBinFile: ftb_version OK!\n");
+		index += FW_BYTES_ALIGN;
+		if (fw_data[index] != info->board->dchip_id[0] ||
+		    fw_data[index + 1] != info->board->dchip_id[1]) {
+			dev_err(info->dev, "parseBinFile: Wrong target %02X != %02X  %02X != %02X ... ERROR %08X\n",
+				fw_data[index], info->board->dchip_id[0],
+				fw_data[index + 1],
+				info->board->dchip_id[1], ERROR_FILE_PARSE);
+			res = ERROR_FILE_PARSE;
+			goto END;
+		}
+		index += FW_BYTES_ALIGN;
+		u8ToU32(&fw_data[index], &temp);
+		dev_info(info->dev, "parseBinFile: FILE SVN REV = %08X\n", temp);
+
+		index += FW_BYTES_ALIGN;
+		u8ToU32(&fw_data[index], &temp);
+		fwData->fw_ver = temp;
+		dev_info(info->dev, "parseBinFile: FILE Fw Version = %04X\n",
+			fwData->fw_ver);
+
+		index += FW_BYTES_ALIGN;
+		u8ToU32(&fw_data[index], &temp);
+		dev_info(info->dev, "parseBinFile: FILE Config Project ID = %08X\n", temp);
+
+		index += FW_BYTES_ALIGN;
+		u8ToU32(&fw_data[index], &temp);
+		fwData->config_ver = temp;
+		dev_info(info->dev, "parseBinFile: FILE Config Version = %08X\n",
+			fwData->config_ver);
+
+		index += FW_BYTES_ALIGN * 2;	/* skip reserved data */
+
+		index += FW_BYTES_ALIGN;
+		for (i = 0; i < EXTERNAL_RELEASE_INFO_SIZE; i++) {
+			fwData->externalRelease[i] = fw_data[index++];
+			buff_index += scnprintf(buff + buff_index,
+						buff_len - buff_index,
+						"%02X ",
+						fwData->externalRelease[i]);
+		}
+		dev_info(info->dev, "parseBinFile: File External Release = %s\n", buff);
+
+		/* index+=FW_BYTES_ALIGN; */
+		u8ToU32(&fw_data[index], &temp);
+		fwData->sec0_size = temp;
+		dev_info(info->dev, "parseBinFile:  sec0_size = %08X (%d bytes)\n",
+			fwData->sec0_size, fwData->sec0_size);
+
+		index += FW_BYTES_ALIGN;
+		u8ToU32(&fw_data[index], &temp);
+		fwData->sec1_size = temp;
+		dev_info(info->dev, "parseBinFile:  sec1_size = %08X (%d bytes)\n",
+			fwData->sec1_size, fwData->sec1_size);
+
+		index += FW_BYTES_ALIGN;
+		u8ToU32(&fw_data[index], &temp);
+		fwData->sec2_size = temp;
+		dev_info(info->dev, "parseBinFile:  sec2_size = %08X (%d bytes)\n",
+			fwData->sec2_size, fwData->sec2_size);
+
+		index += FW_BYTES_ALIGN;
+		u8ToU32(&fw_data[index], &temp);
+		fwData->sec3_size = temp;
+		dev_info(info->dev, "parseBinFile:  sec3_size = %08X (%d bytes)\n",
+			fwData->sec3_size, fwData->sec3_size);
+
+		index += FW_BYTES_ALIGN;/* skip header crc */
+
+		/* if (!keep_cx) */
+		/* { */
+		dimension = fwData->sec0_size + fwData->sec1_size +
+			    fwData->sec2_size + fwData->sec3_size;
+		temp = fw_size;
+		/*} else
+		 * {
+		 *      dimension = fwData->sec0_size + fwData->sec1_size;
+		 *      temp = fw_size - fwData->sec2_size - fwData->sec3_size;
+		 *      fwData->sec2_size = 0;
+		 *      fwData->sec3_size = 0;
+		 * }*/
+
+		if (dimension + FW_HEADER_SIZE + FW_BYTES_ALIGN != temp) {
+			dev_err(info->dev, "parseBinFile: Read only %d instead of %d... ERROR %08X\n",
+				fw_size, dimension + FW_HEADER_SIZE +
+				FW_BYTES_ALIGN, ERROR_FILE_PARSE);
+			res = ERROR_FILE_PARSE;
+			goto END;
+		}
+
+		fwData->data = (u8 *)kmalloc(dimension * sizeof(u8),
+					     GFP_KERNEL);
+		if (fwData->data == NULL) {
+			dev_err(info->dev, "parseBinFile: ERROR %08X\n", ERROR_ALLOC);
+			res = ERROR_ALLOC;
+			goto END;
+		}
+
+		index += FW_BYTES_ALIGN;
+		memcpy(fwData->data, &fw_data[index], dimension);
+		if (fwData->sec2_size != 0) {
+			u8ToU16(&fwData->data[fwData->sec0_size +
+					     fwData->sec1_size +
+					FW_CX_VERSION], &fwData->cx_ver);
+			fwData->cx_afe_ver = fwData->data[fwData->sec0_size +
+						fwData->sec1_size +
+						FW_CX_AFE_VERSION];
+		} else {
+			dev_info(info->dev, "parseBinFile: Initialize cx_ver "
+				 "and cx_afe_ver to default value!\n");
+			fwData->cx_ver = info->systemInfo.u16_cxVer;
+			fwData->cx_afe_ver = info->systemInfo.u8_cxAfeVer;
+		}
+		if (fwData->sec1_size != 0)
+			fwData->cfg_afe_ver = fwData->data[fwData->sec0_size +
+						FW_CFG_AFE_VERSION];
+		else {
+			dev_info(info->dev, "parseBinFile: Initialize cfg_ver to "
+				 "default value from sysinfo!\n");
+			fwData->cfg_afe_ver = info->systemInfo.u8_cfgAfeVer;
+		}
+		dev_info(info->dev, "parseBinFile: CX Version = %04X\n",
+			 fwData->cx_ver);
+		dev_info(info->dev, "parseBinFile: CX AFE Version = %02X\n",
+			fwData->cx_afe_ver);
+		dev_info(info->dev, "parseBinFile: CFG AFE Version = %02X\n",
+			 fwData->cfg_afe_ver);
+
+		fwData->data_size = dimension;
+		index = FLASH_ORG_INFO_INDEX;
+		fwData->fw_code_size = fw_data[index++];
+		fwData->panel_config_size = fw_data[index++];
+		fwData->cx_area_size = fw_data[index++];
+		fwData->fw_config_size = fw_data[index];
+
+		dev_info(info->dev, "parseBinFile: Code Pages: %d panel area Pages: %d"
+			" cx area Pages: %d fw config Pages: %d !\n",
+			fwData->fw_code_size, fwData->panel_config_size,
+			fwData->cx_area_size, fwData->fw_config_size);
+
+		if ((fwData->fw_code_size == 0) ||
+			(fwData->panel_config_size == 0) ||
+			(fwData->cx_area_size == 0) ||
+			(fwData->fw_config_size == 0)) {
+			dev_info(info->dev, "parseBinFile: Using default flash Address\n");
+			fwData->code_start_addr = FLASH_ADDR_CODE;
+			fwData->cx_start_addr = FLASH_ADDR_CX;
+			fwData->config_start_addr = FLASH_ADDR_CONFIG;
+		} else {
+			fwData->code_start_addr = FLASH_ADDR_CODE;
+			fwData->cx_start_addr = (FLASH_ADDR_CODE +
+						(((fwData->fw_code_size +
+						fwData->panel_config_size) *
+						FLASH_PAGE_SIZE) / 4));
+			fwData->config_start_addr = (FLASH_ADDR_CODE +
+						(((fwData->fw_code_size +
+						fwData->panel_config_size +
+						fwData->cx_area_size) *
+						FLASH_PAGE_SIZE) / 4));
+		}
+
+		dev_info(info->dev, "parseBinFile: Code start addr: 0x%08X"
+			" cx start addr: 0x%08X"
+			" fw start addr: 0x%08X !\n",
+			fwData->code_start_addr, fwData->cx_start_addr,
+			fwData->config_start_addr);
+
+		dev_info(info->dev, "READ FW DONE %d bytes!\n", fwData->data_size);
+		res = OK;
+		goto END;
+	}
+
+END:
+	kfree(fw_data);
+	return res;
+}
+
+/*
+ * Enable UVLO and Auto Power Down Mode
+ * @return OK if success or an error code which specify the type of error
+ */
+int flash_enable_uvlo_autopowerdown(struct fts_ts_info *info)
+{
+	u8 cmd[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00,
+			FLASH_UVLO_ENABLE_CODE0,
+			FLASH_UVLO_ENABLE_CODE1 };
+	u8 cmd1[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00,
+			FLASH_AUTOPOWERDOWN_ENABLE_CODE0,
+			FLASH_AUTOPOWERDOWN_ENABLE_CODE1 };
+
+	dev_info(info->dev, "Command enable uvlo ...\n");
+	if (fts_write(info, cmd, ARRAY_SIZE(cmd)) < OK) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+	if (fts_write(info, cmd1, ARRAY_SIZE(cmd1)) < OK) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	dev_info(info->dev, "Enable uvlo and flash auto power down  DONE!\n");
+
+	return OK;
+}
+
+/**
+  * Unlock the flash to be programmed
+  * @return OK if success or an error code which specify the type of error
+  */
+int flash_unlock(struct fts_ts_info *info)
+{
+	u8 cmd[6] = { FTS_CMD_HW_REG_W,	  0x20,	  0x00,	  0x00,
+		      FLASH_UNLOCK_CODE0, FLASH_UNLOCK_CODE1 };
+
+	u8 cmd1[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00,
+		       FLASH_UNLOCK_CODE2, FLASH_UNLOCK_CODE3 };
+
+	dev_info(info->dev, "Command unlock ...\n");
+	if (fts_write(info, cmd, ARRAY_SIZE(cmd)) < OK) {
+		dev_err(info->dev, "flash_unlock: ERROR %08X\n", ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	if (fts_write(info, cmd1, ARRAY_SIZE(cmd1)) < OK) {
+		dev_err(info->dev, "Command unlock: ERROR %08X\n", ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	dev_info(info->dev, "Unlock flash DONE!\n");
+
+	return OK;
+}
+
+/**
+  * Unlock the flash to be erased
+  * @return OK if success or an error code which specify the type of error
+  */
+int flash_erase_unlock(struct fts_ts_info *info)
+{
+	u8 cmd[6] = { FTS_CMD_HW_REG_W,		0x20,	      0x00,
+		      0x00,
+		      FLASH_ERASE_UNLOCK_CODE0, FLASH_ERASE_UNLOCK_CODE1 };
+
+	dev_info(info->dev, "Try to erase unlock flash...\n");
+
+	dev_info(info->dev, "Command erase unlock ...\n");
+	if (fts_write(info, cmd, ARRAY_SIZE(cmd)) < 0) {
+		dev_err(info->dev, "flash_erase_unlock: ERROR %08X\n", ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	dev_info(info->dev, "Erase Unlock flash DONE!\n");
+
+	return OK;
+}
+
+/**
+  * Erase the full flash
+  * @return OK if success or an error code which specify the type of error
+  */
+int flash_full_erase(struct fts_ts_info *info)
+{
+	int status;
+
+	u8 cmd1[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00,
+		       FLASH_ERASE_CODE0 + 1, 0x00 };
+	u8 cmd[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00,
+		      FLASH_ERASE_CODE0, FLASH_ERASE_CODE1 };
+
+	if (fts_write(info, cmd1, ARRAY_SIZE(cmd1)) < OK) {
+		dev_err(info->dev, "flash_erase_page_by_page: ERROR %08X\n", ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	dev_info(info->dev, "Command full erase sent ...\n");
+	if (fts_write(info, cmd, ARRAY_SIZE(cmd)) < OK) {
+		dev_err(info->dev, "flash_full_erase: ERROR %08X\n", ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	status = wait_for_flash_ready(info, FLASH_ERASE_CODE0);
+
+	if (status != OK) {
+		dev_err(info->dev, "flash_full_erase: ERROR %08X\n", ERROR_FLASH_NOT_READY);
+		return status | ERROR_FLASH_NOT_READY;
+		/* Flash not ready within the chosen time, better exit! */
+	}
+
+	dev_info(info->dev, "Full Erase flash DONE!\n");
+
+	return OK;
+}
+
+/**
+  * Erase the flash page by page, giving the possibility to skip the CX area and
+  * maintain therefore its value
+  * @param keep_cx if SKIP_PANEL_INIT the Panel Init pages will be skipped,
+  * if > SKIP_PANEL_CX_INIT Cx and Panel Init pages otherwise all the pages will
+  * be deleted
+  * @return OK if success or an error code which specify the type of error
+  */
+int flash_erase_page_by_page(struct fts_ts_info *info, ErasePage keep_cx,
+			     Firmware *fw)
+{
+	u8 status, i = 0;
+
+	u8 flash_cx_start_page = FLASH_CX_PAGE_START;
+	u8 flash_cx_end_page = FLASH_CX_PAGE_END;
+	u8 flash_panel_start_page = FLASH_PANEL_PAGE_START;
+	u8 flash_panel_end_page = FLASH_PANEL_PAGE_END;
+
+	u8 cmd1[9] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00,
+		       FLASH_ERASE_CODE0 + 1, 0x00, 0xFF, 0x1C, 0x90};
+
+	u8 cmd[6] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x00, FLASH_ERASE_CODE0, 0xA0 };
+
+	u8 cmd2[11] = { FTS_CMD_HW_REG_W, 0x20, 0x00, 0x01, 0x28, 0xFF,
+			0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+
+	u8 mask[6] = { 0 };
+
+	u8 cmd1_length;
+	u8 cmd2_length;
+	u8 mask_cnt;
+	char buff[(2 + 1) * 4 + 1];
+	int buff_len = sizeof(buff);
+	int index = 0;
+
+	if (info->board->dchip_id[0] == SALIXP_DCHIP_ID_0 &&
+	    info->board->dchip_id[1] == SALIXP_DCHIP_ID_1) {
+		cmd[5] = 0x80;
+		cmd1_length = 9;
+		cmd2_length = 11;
+		mask_cnt = 6;
+	} else {
+		cmd1_length = 6;
+		cmd2_length = 9;
+		mask_cnt = 4;
+	}
+
+	if ((fw->fw_code_size == 0) ||
+	(fw->panel_config_size == 0) ||
+	(fw->cx_area_size == 0) || (fw->fw_config_size == 0)) {
+		dev_info(info->dev, " using default page address!\n");
+	} else {
+		flash_panel_start_page = fw->fw_code_size;
+		if (fw->panel_config_size > 1)
+			flash_panel_end_page = flash_panel_start_page +
+				(fw->panel_config_size - 1);
+		else
+			flash_panel_end_page = flash_panel_start_page;
+
+		flash_cx_start_page = flash_panel_end_page + 1;
+		if (fw->cx_area_size > 1)
+			flash_cx_end_page = flash_cx_start_page +
+				(fw->cx_area_size - 1);
+		else
+			flash_cx_end_page = flash_cx_start_page;
+	}
+
+	dev_info(info->dev, " CX Start page: %d CX end page: %d Panel Start Page: %d"
+		"Panel End page: %d!\n", flash_cx_start_page,
+		flash_cx_end_page, flash_panel_start_page,
+		flash_panel_end_page);
+
+	for (i = flash_cx_start_page; i <= flash_cx_end_page && keep_cx >=
+	     SKIP_PANEL_CX_INIT; i++) {
+		dev_info(info->dev, "Skipping erase CX page %d!\n", i);
+		fromIDtoMask(i, mask, mask_cnt);
+	}
+
+
+	for (i = flash_panel_start_page; i <= flash_panel_end_page && keep_cx >=
+	     SKIP_PANEL_INIT; i++) {
+		dev_info(info->dev, "Skipping erase Panel Init page %d!\n", i);
+		fromIDtoMask(i, mask, mask_cnt);
+	}
+
+	for (i = 0; i < mask_cnt; i++) {
+		cmd2[5 + i] = cmd2[5 + i] & (~mask[i]);
+		index += scnprintf(buff + index, buff_len - index,
+					"%02X ", cmd2[5 + i]);
+	}
+	dev_info(info->dev, "Setting the page mask = %s\n", buff);
+
+	dev_info(info->dev, "Writing page mask...\n");
+	if (fts_write(info, cmd2, cmd2_length) < OK) {
+		dev_err(info->dev, "flash_erase_page_by_page: Page mask ERROR %08X\n",
+			ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	if (fts_write(info, cmd1, cmd1_length) < OK) {
+		dev_err(info->dev, "flash_erase_page_by_page: Disable info ERROR %08X\n",
+			ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	dev_info(info->dev, "Command erase pages sent ...\n");
+	if (fts_write(info, cmd, ARRAY_SIZE(cmd)) < OK) {
+		dev_err(info->dev, "flash_erase_page_by_page: Erase ERROR %08X\n",
+			ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	status = wait_for_flash_ready(info, FLASH_ERASE_CODE0);
+
+	if (status != OK) {
+		dev_err(info->dev, "flash_erase_page_by_page: ERROR %08X\n",
+			 ERROR_FLASH_NOT_READY);
+		return status | ERROR_FLASH_NOT_READY;
+		/* Flash not ready within the chosen time, better exit! */
+	}
+
+	dev_info(info->dev, "Erase flash page by page DONE!\n");
+
+	return OK;
+}
+
+/**
+  * Start the DMA procedure which actually transfer and burn the data loaded
+  * from memory into the Flash
+  * @return OK if success or an error code which specify the type of error
+  */
+int start_flash_dma(struct fts_ts_info *info)
+{
+	int status;
+	u8 cmd[12] = { FLASH_CMD_WRITE_REGISTER, 0x20, 0x00, 0x00,
+		      0x6B, 0x00, 0x40, 0x42, 0x0F, 0x00, 0x00,
+			FLASH_DMA_CODE1 };
+
+	if (info->board->dchip_id[0] == SALIXP_DCHIP_ID_0 &&
+	    info->board->dchip_id[1] == SALIXP_DCHIP_ID_1) {
+		cmd[6] = 0xFF;
+		cmd[7] = 0x1C;
+		cmd[8] = 0x10;
+	}
+
+	/* write the command to erase the flash */
+
+	dev_info(info->dev, "Command flash DMA ...\n");
+	if (fts_write(info, cmd, ARRAY_SIZE(cmd)) < OK) {
+		dev_err(info->dev, "start_flash_dma: ERROR %08X\n", ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+
+	status = wait_for_flash_ready(info, FLASH_DMA_CODE0);
+
+	if (status != OK) {
+		dev_err(info->dev, "start_flash_dma: ERROR %08X\n", ERROR_FLASH_NOT_READY);
+		return status | ERROR_FLASH_NOT_READY;
+		/* Flash not ready within the chosen time, better exit! */
+	}
+
+	dev_info(info->dev, "flash DMA DONE!\n");
+
+	return OK;
+}
+
+/**
+  * Copy the FW data that should be burnt in the Flash into the memory and then
+  * the DMA will take care about burning it into the Flash
+  * @param address address in memory where to copy the data, possible values
+  * are FLASH_ADDR_CODE, FLASH_ADDR_CONFIG, FLASH_ADDR_CX
+  * @param data pointer to an array of byte which contain the data that should
+  * be copied into the memory
+  * @param size size of data
+  * @return OK if success or an error code which specify the type of error
+  */
+int fillFlash(struct fts_ts_info *info, u32 address, u8 *data, int size)
+{
+	int remaining = size, index = 0;
+	int toWrite = 0;
+	int byteBlock = 0;
+	int wheel = 0;
+	u32 addr = 0;
+	int res;
+	int delta;
+	u8 *buff = NULL;
+
+	buff = kmalloc(max(DMA_CHUNK + 5, 12), GFP_KERNEL);
+	if (buff == NULL) {
+		dev_err(info->dev, "fillFlash: ERROR %08X\n", ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	while (remaining > 0) {
+		byteBlock = 0;
+		addr = 0x00100000;
+
+		while (byteBlock < info->board->flash_chunk && remaining > 0) {
+			index = 0;
+			if (remaining >= DMA_CHUNK) {
+				if ((byteBlock + DMA_CHUNK) <= info->board->flash_chunk) {
+					/* dev_err(info->dev, "fillFlash: 1\n"); */
+					toWrite = DMA_CHUNK;
+					remaining -= DMA_CHUNK;
+					byteBlock += DMA_CHUNK;
+				} else {
+					/* dev_err(info->dev, "fillFlash: 2\n); */
+					delta = info->board->flash_chunk - byteBlock;
+					toWrite = delta;
+					remaining -= delta;
+					byteBlock += delta;
+				}
+			} else {
+				if ((byteBlock + remaining) <= info->board->flash_chunk) {
+					/* dev_err(info->dev, "fillFlash: 3\n"); */
+					toWrite = remaining;
+					byteBlock += remaining;
+					remaining = 0;
+				} else {
+					/* dev_err(info->dev, "fillFlash: 4\n"); */
+					delta = info->board->flash_chunk - byteBlock;
+					toWrite = delta;
+					remaining -= delta;
+					byteBlock += delta;
+				}
+			}
+
+			buff[index++] = FTS_CMD_HW_REG_W;
+			buff[index++] = (u8)((addr & 0xFF000000) >> 24);
+			buff[index++] = (u8)((addr & 0x00FF0000) >> 16);
+			buff[index++] = (u8)((addr & 0x0000FF00) >> 8);
+			buff[index++] = (u8)(addr & 0x000000FF);
+
+			memcpy(&buff[index], data, toWrite);
+			/* dev_err(info->dev, "Command = %02X , address = %02X %02X
+			 * , bytes = %d, data =  %02X %02X, %02X %02X\n",
+			 * buff[0], buff[1], buff[2], toWrite, buff[3],
+			 * buff[4], buff[3 + toWrite-2],
+			 * buff[3 + toWrite-1]); */
+			if (fts_write_heap(info, buff, index + toWrite) < OK) {
+				dev_err(info->dev, "fillFlash: ERROR %08X\n", ERROR_BUS_W);
+				kfree(buff);
+				return ERROR_BUS_W;
+			}
+
+			/* mdelay(5); */
+			addr += toWrite;
+			data += toWrite;
+		}
+
+
+		/* configuring the DMA */
+		byteBlock = byteBlock / 4 - 1;
+		index = 0;
+
+		buff[index++] = FLASH_CMD_WRITE_REGISTER;
+		buff[index++] = 0x20;
+		buff[index++] = 0x00;
+		buff[index++] = 0x00;
+		buff[index++] = FLASH_DMA_CONFIG;
+		buff[index++] = 0x00;
+		buff[index++] = 0x00;
+
+		addr = address + ((wheel * info->board->flash_chunk) / 4);
+		buff[index++] = (u8)((addr & 0x000000FF));
+		buff[index++] = (u8)((addr & 0x0000FF00) >> 8);
+		buff[index++] = (u8)(byteBlock & 0x000000FF);
+		buff[index++] = (u8)((byteBlock & 0x0000FF00) >> 8);
+		buff[index++] = 0x00;
+
+		dev_info(info->dev, "DMA Command = %02X , address = %02X %02X, words =  %02X %02X\n",
+			buff[0], buff[8], buff[7], buff[10], buff[9]);
+
+		if (fts_write_heap(info, buff, index) < OK) {
+			dev_err(info->dev, "Error during filling Flash! ERROR %08X\n",
+				ERROR_BUS_W);
+			kfree(buff);
+			return ERROR_BUS_W;
+		}
+
+		res = start_flash_dma(info);
+		if (res < OK) {
+			dev_err(info->dev, "Error during flashing DMA! ERROR %08X\n", res);
+			kfree(buff);
+			return res;
+		}
+		wheel++;
+	}
+	kfree(buff);
+	return OK;
+}
+
+
+/*
+  * Execute the procedure to burn a FW on FTM5/FTI IC
+  *
+  * @param fw - structure which contain the FW to be burnt
+  * @param force_burn - if >0, the flashing procedure will be forced and
+  * executed
+  *	regardless the additional info, otherwise the FW in the file will be
+  *	burned only if it is different from the one running in the IC
+  * @param keep_cx - if 1, the function preserves the CX/Panel Init area.
+  *	Otherwise, it will be cleared.
+  *
+  * @return OK if success or an error code which specifies the type of error
+  *	encountered
+  */
+int flash_burn(struct fts_ts_info *info, Firmware fw, int force_burn,
+	       int keep_cx)
+{
+	int res;
+	SysInfo systemInfo;
+	memcpy(&systemInfo, &info->systemInfo, sizeof(systemInfo));
+
+	if (!force_burn) {
+		/* Compare firmware, config, and CX versions */
+		if (fw.fw_ver != (uint32_t)systemInfo.u16_fwVer ||
+		    fw.config_ver != (uint32_t)systemInfo.u16_cfgVer ||
+		    fw.cx_afe_ver != (uint32_t)systemInfo.u8_cxAfeVer)
+			goto start;
+
+		for (res = EXTERNAL_RELEASE_INFO_SIZE - 1; res >= 0; res--) {
+			if (fw.externalRelease[res] !=
+			    systemInfo.u8_releaseInfo[res])
+				goto start;
+		}
+
+		dev_info(info->dev, "flash_burn: Firmware in the chip matches the firmware to flash! NO UPDATE ERROR %08X\n",
+			ERROR_FW_NO_UPDATE);
+		return ERROR_FW_NO_UPDATE | ERROR_FLASH_BURN_FAILED;
+	} else if (force_burn == CRC_CX && fw.sec2_size == 0) {
+		/* burn procedure to update the CX memory, if not present just
+		 * skip it!
+		 */
+		for (res = EXTERNAL_RELEASE_INFO_SIZE - 1; res >= 0; res--) {
+			if (fw.externalRelease[res] !=
+			    systemInfo.u8_releaseInfo[res]) {
+				/* Avoid loading the CX because it is missing
+				 * in the bin file, it just need to update
+				 * to last fw+cfg because a new release */
+				force_burn = 0;
+				goto start;
+			}
+		}
+		dev_info(info->dev, "flash_burn: CRC in CX but fw does not contain CX data! NO UPDATE ERROR %08X\n",
+			ERROR_FW_NO_UPDATE);
+		return ERROR_FW_NO_UPDATE | ERROR_FLASH_BURN_FAILED;
+	}
+
+	/* Programming procedure start */
+start:
+	dev_info(info->dev, "Programming Procedure for flashing started:\n\n");
+
+	dev_info(info->dev, " 1) SYSTEM RESET:\n");
+	res = fts_system_reset(info);
+	if (res < 0) {
+		dev_err(info->dev, "    system reset FAILED!\n");
+		/* If there is no firmware, there is no controller ready event
+		 * and there will be a timeout, we can keep going. But if
+		 * there is an I2C error, we must exit.
+		 */
+		if (res != (ERROR_SYSTEM_RESET_FAIL | ERROR_TIMEOUT))
+			return res | ERROR_FLASH_BURN_FAILED;
+	} else
+		dev_info(info->dev, "   system reset COMPLETED!\n\n");
+
+	msleep(100); /* required by HW for safe flash procedure */
+
+	dev_info(info->dev, " 2) HOLD M3 :\n");
+
+	res = hold_m3(info);
+	if (res < OK) {
+		dev_err(info->dev, "    hold_m3 FAILED!\n");
+		return res | ERROR_FLASH_BURN_FAILED;
+	}
+	dev_info(info->dev, "    hold_m3 COMPLETED!\n\n");
+
+	dev_info(info->dev, "3) ENABLE UVLO AND AUTO POWER DOWN MODE :\n");
+	res = flash_enable_uvlo_autopowerdown(info);
+	if (res < OK) {
+		dev_err(info->dev, "    flash_enable_uvlo_autopowerdown FAILED!\n");
+		return res | ERROR_FLASH_BURN_FAILED;
+	}
+	dev_err(info->dev, "    flash_enable_uvlo_autopowerdown COMPLETED!\n\n");
+
+	dev_info(info->dev, " 4) FLASH UNLOCK:\n");
+	res = flash_unlock(info);
+	if (res < OK) {
+		dev_err(info->dev, "   flash unlock FAILED! ERROR %08X\n",
+			 ERROR_FLASH_BURN_FAILED);
+		return res | ERROR_FLASH_BURN_FAILED;
+	}
+	dev_info(info->dev, "   flash unlock COMPLETED!\n\n");
+
+	dev_info(info->dev, " 5) FLASH ERASE UNLOCK:\n");
+	res = flash_erase_unlock(info);
+	if (res < 0) {
+		dev_err(info->dev, "   flash unlock FAILED! ERROR %08X\n",
+			 ERROR_FLASH_BURN_FAILED);
+		return res | ERROR_FLASH_BURN_FAILED;
+	}
+	dev_info(info->dev, "   flash unlock COMPLETED!\n\n");
+
+	dev_info(info->dev, " 6) FLASH ERASE:\n");
+	if (keep_cx > 0) {
+		if (fw.sec2_size != 0 && force_burn == CRC_CX)
+			res = flash_erase_page_by_page(info, SKIP_PANEL_INIT,
+						       &fw);
+		else
+			res = flash_erase_page_by_page(info, SKIP_PANEL_CX_INIT,
+						       &fw);
+	} else {
+		res = flash_erase_page_by_page(info, SKIP_PANEL_INIT, &fw);
+		if (fw.sec2_size == 0)
+			dev_err(info->dev, "WARNING!!! Erasing CX memory but no CX in fw file! touch will not work right after fw update!\n");
+	}
+
+	if (res < OK) {
+		dev_err(info->dev, "   flash erase FAILED! ERROR %08X\n",
+			 ERROR_FLASH_BURN_FAILED);
+		return res | ERROR_FLASH_BURN_FAILED;
+	}
+	dev_info(info->dev, "   flash erase COMPLETED!\n\n");
+
+	dev_info(info->dev, " 7) LOAD PROGRAM:\n");
+	res = fillFlash(info, fw.code_start_addr, &fw.data[0], fw.sec0_size);
+	if (res < OK) {
+		dev_err(info->dev, "   load program ERROR %08X\n",
+			 ERROR_FLASH_BURN_FAILED);
+		return res | ERROR_FLASH_BURN_FAILED;
+	}
+	dev_info(info->dev, "   load program DONE!\n");
+
+	dev_info(info->dev, " 8) LOAD CONFIG:\n");
+	res = fillFlash(info, fw.config_start_addr, &(fw.data[fw.sec0_size]),
+			fw.sec1_size);
+	if (res < OK) {
+		dev_err(info->dev, "   load config ERROR %08X\n",
+			 ERROR_FLASH_BURN_FAILED);
+		return res | ERROR_FLASH_BURN_FAILED;
+	}
+	dev_info(info->dev, "   load config DONE!\n");
+
+	if (fw.sec2_size != 0 && (force_burn == CRC_CX || keep_cx <= 0)) {
+		dev_info(info->dev, " 8.1) LOAD CX:\n");
+		res = fillFlash(info, fw.cx_start_addr,
+				&(fw.data[fw.sec0_size + fw.sec1_size]),
+				fw.sec2_size);
+		if (res < OK) {
+			dev_err(info->dev, "   load cx ERROR %08X\n",
+				 ERROR_FLASH_BURN_FAILED);
+			return res | ERROR_FLASH_BURN_FAILED;
+		}
+		dev_info(info->dev, "   load cx DONE!\n");
+	}
+
+	dev_info(info->dev, "   Flash burn COMPLETED!\n\n");
+
+	dev_info(info->dev, " 9) SYSTEM RESET:\n");
+	res = fts_system_reset(info);
+	if (res < 0) {
+		dev_err(info->dev, "    system reset FAILED! ERROR %08X\n",
+			 ERROR_FLASH_BURN_FAILED);
+		return res | ERROR_FLASH_BURN_FAILED;
+	}
+	dev_info(info->dev, "   system reset COMPLETED!\n\n");
+
+	dev_info(info->dev, " 10) FINAL CHECK:\n");
+	res = readSysInfo(info, 0);
+	if (res < 0) {
+		dev_err(info->dev, "flash_burn: Unable to retrieve Chip INFO! ERROR %08X\n",
+			ERROR_FLASH_BURN_FAILED);
+		return res | ERROR_FLASH_BURN_FAILED;
+	}
+
+	for (res = 0; res < EXTERNAL_RELEASE_INFO_SIZE; res++) {
+		if (fw.externalRelease[res] != info->systemInfo.u8_releaseInfo[res]) {
+			/* External release is printed during readSysInfo */
+			dev_info(info->dev, "  Firmware in the chip different from the one that was burn!\n");
+			return ERROR_FLASH_BURN_FAILED;
+		}
+	}
+
+	dev_info(info->dev, "   Final check OK!\n");
+
+	return OK;
+}
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("STMicroelectronics MultiTouch IC Driver");
+MODULE_AUTHOR("STMicroelectronics");
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsFlash.h b/drivers/input/touchscreen/stfts/google/fts_lib/ftsFlash.h
new file mode 100644
index 000000000000..50a75aea2d12
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsFlash.h
@@ -0,0 +1,148 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics                            **
+  **************************************************************************
+  **                        marco.cali@st.com                             **
+  **************************************************************************
+  *                                                                        *
+  *                       FTS API for Flashing the IC                      *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsFlash.h
+  * \brief Contains all the definitions and structs to handle the FW update
+  *process
+  */
+
+#ifndef FTS_FLASH_H
+#define FTS_FLASH_H
+
+#include "ftsSoftware.h"
+
+/* Flash possible status */
+#define FLASH_READY		0	/* /< value to indicate that the flash
+					 * is ready */
+#define FLASH_BUSY		1	/* /< value to indicate that the flash
+					 * is busy */
+#define FLASH_UNKNOWN		-1	/* /< value to indicate an unknown
+					 * status of the flash */
+
+#define FLASH_STATUS_BYTES	1	/* /< number of bytes to check for read
+					 * the flash status */
+
+
+
+/* Flash timing parameters */
+#define FLASH_RETRY_COUNT	200	/* /< number of attempts to read the
+					 * flash status */
+#define FLASH_WAIT_BEFORE_RETRY 50	/* /< time to wait in ms between status
+					 * readings */
+
+
+#ifdef FW_H_FILE
+#define PATH_FILE_FW		"NULL"
+#else
+#define PATH_FILE_FW		"ftm5_fw.ftb"	/* new FW bin file name */
+#endif
+
+#ifdef ALIX
+#define FLASH_CHUNK		(32 * 1024)	/* /< Max number of bytes that
+						 * the
+						  * DMA can burn on flash in
+						  *one shot in FTI */
+#else
+#define FLASH_CHUNK		(64 * 1024)	/* /< Max number of bytes that
+						 * the
+						  * DMA can burn on flash in
+						  *one shot in FTI */
+#endif
+
+#define DMA_CHUNK		32	/* /< Max number of bytes that can be
+					 * written in I2C to the DMA */
+
+#define FLASH_ORG_INFO_INDEX	280
+
+#define FLASH_PAGE_SIZE		(4 * 1024) //page size of 4KB
+
+/**
+  * Define which kind of erase page by page should be performed
+  */
+typedef enum {
+	ERASE_ALL		= 0,	/* /< erase all the pages */
+	SKIP_PANEL_INIT		= 1,	/* /< skip erase Panel Init Pages */
+	SKIP_PANEL_CX_INIT	= 2 /* /< skip erase Panel Init and CX Pages */
+} ErasePage;
+
+/** @addtogroup fw_file
+  * @{
+  */
+
+/**
+  * Struct which contains information and data of the FW that should be burnt
+  *into the IC
+  */
+typedef struct {
+	u8 *data;	/* /< pointer to an array of bytes which represent the
+			 * FW data */
+	u16 fw_ver;	/* /< FW version of the FW file */
+	u16 config_ver;	/* Config version of the FW file */
+	u16 cx_ver;	/* /< Cx version of the FW file */
+	u8 cfg_afe_ver;	/* /< Cx afe version of the FW file */
+	u8 cx_afe_ver;	/* /< Cfg afe version of the FW file */
+	u8 externalRelease[EXTERNAL_RELEASE_INFO_SIZE];	/* /< External Release
+							 * Info of the FW file
+							 * */
+	int data_size;	/* /< dimension of data (the actual data to be burnt) */
+	u32 sec0_size;	/* /< dimension of section 0 (FW) in .ftb file */
+	u32 sec1_size;	/* /< dimension of section 1 (Config) in .ftb file */
+	u32 sec2_size;	/* /< dimension of section 2 (Cx) in .ftb file */
+	u32 sec3_size;	/* /< dimension of section 3 (TBD) in .ftb file */
+	u8 fw_code_size; /* /< size of fw code in pages in
+			.ftb file */
+	u8 panel_config_size;/* /< size of panel area in pages in
+			.ftb file */
+	u8 cx_area_size;/* /< size of cx area in pages in
+			 .ftb file */
+	u8 fw_config_size;/* /< size of fw config in pages in
+			.ftb file */
+	u32 code_start_addr;  /* start addr for fw code */
+	u32 cx_start_addr; /* start addr for cx area */
+	u32 config_start_addr; /* start addr for config area */
+} Firmware;
+
+/** @}*/
+
+/** @addtogroup flash_command
+  * @{
+  */
+
+int wait_for_flash_ready(struct fts_ts_info *info, u8 type);
+int hold_m3(struct fts_ts_info *info);
+int flash_erase_unlock(struct fts_ts_info *info);
+int flash_full_erase(struct fts_ts_info *info);
+int flash_erase_page_by_page(struct fts_ts_info *info, ErasePage keep_cx,
+			     Firmware *fw);
+int start_flash_dma(struct fts_ts_info *info);
+int fillFlash(struct fts_ts_info *info, u32 address, u8 *data, int size);
+
+int flash_unlock(struct fts_ts_info *info);
+int getFWdata(struct fts_ts_info *info, const char *pathToFile, u8 **data,
+	      int *size);
+int parseBinFile(struct fts_ts_info *info, u8 *fw_data, int fw_size,
+		 Firmware *fw, int keep_cx);
+int readFwFile(struct fts_ts_info *info, const char *path, Firmware *fw,
+	       int keep_cx);
+int flash_burn(struct fts_ts_info *info, Firmware fw, int force_burn,
+	       int keep_cx);
+int flashProcedure(struct fts_ts_info *info, const char *path, int force,
+		   int keep_cx);
+int flash_enable_uvlo_autopowerdown(struct fts_ts_info *info);
+
+#endif
+
+/** @}*/
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsFrame.c b/drivers/input/touchscreen/stfts/google/fts_lib/ftsFrame.c
new file mode 100644
index 000000000000..147f1ff2c830
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsFrame.c
@@ -0,0 +1,666 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				**
+  **************************************************************************
+  **                        marco.cali@st.com				 **
+  **************************************************************************
+  *                                                                        *
+  *                  FTS functions for getting frames			  *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsFrame.c
+  * \brief Contains all the functions to work with frames
+  */
+
+#include "ftsCompensation.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsFrame.h"
+#include "ftsHardware.h"
+#include "ftsIO.h"
+#include "ftsSoftware.h"
+#include "ftsTool.h"
+#include "ftsTime.h"
+
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/serio.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+
+
+/**
+  * Read the channels lengths from the config memory
+  * @return OK if success or an error code which specify the type of error
+  */
+int getChannelsLength(struct fts_ts_info *info)
+{
+	int ret;
+	u8 data[2];
+
+	ret = readConfig(info, ADDR_CONFIG_SENSE_LEN, data, 2);
+	if (ret < OK) {
+		dev_err(info->dev, "getChannelsLength: ERROR %08X\n", ret);
+
+		return ret;
+	}
+
+	info->systemInfo.u8_scrRxLen = (int)data[0];
+	info->systemInfo.u8_scrTxLen = (int)data[1];
+
+	dev_info(info->dev, "Force_len = %d   Sense_Len = %d\n",
+		 info->systemInfo.u8_scrTxLen, info->systemInfo.u8_scrRxLen);
+
+	return OK;
+}
+
+
+
+/**
+  * Read and pack the frame data related to the nodes
+  * @param address address in memory when the frame data node start
+  * @param size amount of data to read
+  * @param frame pointer to an array of bytes which will contain the frame node
+  * data
+  * @return OK if success or an error code which specify the type of error
+  */
+int getFrameData(struct fts_ts_info *info, u16 address, int size, short *frame)
+{
+	int i, j, ret;
+	u8 *data = (u8 *)kmalloc(size * sizeof(u8), GFP_KERNEL);
+
+	if (data == NULL) {
+		dev_err(info->dev, "getFrameData: ERROR %08X\n", ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, address,
+				data, size, DUMMY_FRAMEBUFFER);
+	if (ret < OK) {
+		dev_err(info->dev, "getFrameData: ERROR %08X\n", ERROR_BUS_R);
+		kfree(data);
+		return ERROR_BUS_R;
+	}
+	j = 0;
+	for (i = 0; i < size; i += 2) {
+		frame[j] = (short)((data[i + 1] << 8) + data[i]);
+		j++;
+	}
+	kfree(data);
+	return OK;
+}
+
+
+/**
+  * Return the number of Sense Channels (Rx)
+  * @return number of Rx channels
+  */
+int getSenseLen(struct fts_ts_info *info)
+{
+	if (info->systemInfo.u8_scrRxLen == 0)
+		getChannelsLength(info);
+	return info->systemInfo.u8_scrRxLen;
+}
+
+/**
+  * Return the number of Force Channels (Tx)
+  * @return number of Tx channels
+  */
+int getForceLen(struct fts_ts_info *info)
+{
+	if (info->systemInfo.u8_scrTxLen == 0)
+		getChannelsLength(info);
+	return info->systemInfo.u8_scrTxLen;
+}
+
+
+/********************    New API     **************************/
+
+/**
+  * Read a MS Frame from frame buffer memory
+  * @param type type of MS frame to read
+  * @param frame pointer to MutualSenseFrame variable which will contain the
+  * data
+  * @return > 0 if success specifying the number of node into the frame or
+  * an error code which specify the type of error
+  */
+int getMSFrame3(struct fts_ts_info *info, MSFrameType type,
+		MutualSenseFrame *frame)
+{
+	u16 offset;
+	int ret, force_len, sense_len;
+	SysInfo systemInfo;
+	memcpy(&systemInfo, &info->systemInfo, sizeof(systemInfo));
+
+	force_len = getForceLen(info);
+	sense_len = getSenseLen(info);
+
+	frame->node_data = NULL;
+
+	dev_dbg(info->dev, "%s: Starting to get frame %02X\n", __func__,
+		 type);
+	switch (type) {
+	case MS_RAW:
+		offset = systemInfo.u16_msTchRawAddr;
+		goto LOAD_NORM;
+	case MS_FILTER:
+		offset = systemInfo.u16_msTchFilterAddr;
+
+		goto LOAD_NORM;
+	case MS_STRENGTH:
+		offset = systemInfo.u16_msTchStrenAddr;
+		goto LOAD_NORM;
+	case MS_BASELINE:
+		offset = systemInfo.u16_msTchBaselineAddr;
+LOAD_NORM:
+		if (force_len == 0 || sense_len == 0) {
+			dev_err(info->dev, "%s: number of channels not initialized ERROR %08X\n",
+				__func__, ERROR_CH_LEN);
+			return ERROR_CH_LEN | ERROR_GET_FRAME;
+		}
+
+		break;
+
+	case MS_KEY_RAW:
+		offset = systemInfo.u16_keyRawAddr;
+		goto LOAD_KEY;
+	case MS_KEY_FILTER:
+		offset = systemInfo.u16_keyFilterAddr;
+		goto LOAD_KEY;
+	case MS_KEY_STRENGTH:
+		offset = systemInfo.u16_keyStrenAddr;
+		goto LOAD_KEY;
+	case MS_KEY_BASELINE:
+		offset = systemInfo.u16_keyBaselineAddr;
+LOAD_KEY:
+		if (systemInfo.u8_keyLen == 0) {
+			dev_err(info->dev, "%s: number of channels not initialized ERROR %08X\n",
+				__func__, ERROR_CH_LEN);
+			return ERROR_CH_LEN | ERROR_GET_FRAME;
+		}
+		force_len = 1;
+		sense_len = systemInfo.u8_keyLen;
+		break;
+
+	case FRC_RAW:
+		offset = systemInfo.u16_frcRawAddr;
+		goto LOAD_FRC;
+	case FRC_FILTER:
+		offset = systemInfo.u16_frcFilterAddr;
+		goto LOAD_FRC;
+	case FRC_STRENGTH:
+		offset = systemInfo.u16_frcStrenAddr;
+		goto LOAD_FRC;
+	case FRC_BASELINE:
+		offset = systemInfo.u16_frcBaselineAddr;
+LOAD_FRC:
+		if (force_len == 0) {
+			dev_err(info->dev, "%s: number of channels not initialized ERROR %08X\n",
+				__func__, ERROR_CH_LEN);
+			return ERROR_CH_LEN | ERROR_GET_FRAME;
+		}
+		sense_len = 1;
+		break;
+	default:
+		dev_err(info->dev, "%s: Invalid type ERROR %08X\n", __func__,
+			 ERROR_OP_NOT_ALLOW | ERROR_GET_FRAME);
+		return ERROR_OP_NOT_ALLOW | ERROR_GET_FRAME;
+	}
+
+	frame->node_data_size = ((force_len) * sense_len);
+	frame->header.force_node = force_len;
+	frame->header.sense_node = sense_len;
+	frame->header.type = type;
+
+	dev_dbg(info->dev, "%s: Force_len = %d Sense_len = %d Offset = %04X\n",
+		__func__, force_len, sense_len, offset);
+
+	frame->node_data = (short *)kmalloc(frame->node_data_size *
+					    sizeof(short), GFP_KERNEL);
+	if (frame->node_data == NULL) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__,
+			ERROR_ALLOC | ERROR_GET_FRAME);
+		return ERROR_ALLOC | ERROR_GET_FRAME;
+	}
+
+	ret = getFrameData(info, offset,
+			   frame->node_data_size * BYTES_PER_NODE,
+			   (frame->node_data));
+	if (ret < OK) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_GET_FRAME_DATA);
+		kfree(frame->node_data);
+		frame->node_data = NULL;
+		return ret | ERROR_GET_FRAME_DATA | ERROR_GET_FRAME;
+	}
+	/* if you want to access one node i,j,
+	  * compute the offset like: offset = i*columns + j = > frame[i, j] */
+
+	dev_dbg(info->dev, "Frame acquired!\n");
+	return frame->node_data_size;
+	/* return the number of data put inside frame */
+}
+
+/**
+  * Read a SS Frame from frame buffer
+  * @param type type of SS frame to read
+  * @param frame pointer to SelfSenseFrame variable which will contain the data
+  * @return > 0 if success specifying the number of node into frame or an
+  * error code which specify the type of error
+  */
+int getSSFrame3(struct fts_ts_info *info, SSFrameType type, SelfSenseFrame *frame)
+{
+	u16 offset_force, offset_sense;
+	int ret;
+	SysInfo systemInfo;
+	memcpy(&systemInfo, &info->systemInfo, sizeof(systemInfo));
+
+	frame->force_data = NULL;
+	frame->sense_data = NULL;
+
+	frame->header.force_node = getForceLen(info);	/* use getForce/SenseLen
+							 * because introduce
+							 * a recover mechanism
+							 * in case of len =0 */
+	frame->header.sense_node = getSenseLen(info);
+
+	if (frame->header.force_node == 0 || frame->header.sense_node == 0) {
+		dev_err(info->dev, "%s: number of channels not initialized ERROR %08X\n",
+			__func__, ERROR_CH_LEN);
+		return ERROR_CH_LEN | ERROR_GET_FRAME;
+	}
+
+	dev_dbg(info->dev, "%s: Starting to get frame %02X\n", __func__, type);
+	switch (type) {
+	case SS_RAW:
+		offset_force = systemInfo.u16_ssTchTxRawAddr;
+		offset_sense = systemInfo.u16_ssTchRxRawAddr;
+		break;
+	case SS_FILTER:
+		offset_force = systemInfo.u16_ssTchTxFilterAddr;
+		offset_sense = systemInfo.u16_ssTchRxFilterAddr;
+		break;
+	case SS_STRENGTH:
+		offset_force = systemInfo.u16_ssTchTxStrenAddr;
+		offset_sense = systemInfo.u16_ssTchRxStrenAddr;
+		break;
+	case SS_BASELINE:
+		offset_force = systemInfo.u16_ssTchTxBaselineAddr;
+		offset_sense = systemInfo.u16_ssTchRxBaselineAddr;
+		break;
+
+	case SS_HVR_RAW:
+		offset_force = systemInfo.u16_ssHvrTxRawAddr;
+		offset_sense = systemInfo.u16_ssHvrRxRawAddr;
+		break;
+	case SS_HVR_FILTER:
+		offset_force = systemInfo.u16_ssHvrTxFilterAddr;
+		offset_sense = systemInfo.u16_ssHvrRxFilterAddr;
+		break;
+	case SS_HVR_STRENGTH:
+		offset_force = systemInfo.u16_ssHvrTxStrenAddr;
+		offset_sense = systemInfo.u16_ssHvrRxStrenAddr;
+		break;
+	case SS_HVR_BASELINE:
+		offset_force = systemInfo.u16_ssHvrTxBaselineAddr;
+		offset_sense = systemInfo.u16_ssHvrRxBaselineAddr;
+		break;
+
+	case SS_PRX_RAW:
+		offset_force = systemInfo.u16_ssPrxTxRawAddr;
+		offset_sense = systemInfo.u16_ssPrxRxRawAddr;
+		break;
+	case SS_PRX_FILTER:
+		offset_force = systemInfo.u16_ssPrxTxFilterAddr;
+		offset_sense = systemInfo.u16_ssPrxRxFilterAddr;
+		break;
+	case SS_PRX_STRENGTH:
+		offset_force = systemInfo.u16_ssPrxTxStrenAddr;
+		offset_sense = systemInfo.u16_ssPrxRxStrenAddr;
+		break;
+	case SS_PRX_BASELINE:
+		offset_force = systemInfo.u16_ssPrxTxBaselineAddr;
+		offset_sense = systemInfo.u16_ssPrxRxBaselineAddr;
+		break;
+	case SS_DETECT_RAW:
+		if (systemInfo.u8_ssDetScanSet == 0) {
+			offset_force = systemInfo.u16_ssDetRawAddr;
+			offset_sense = 0;
+			frame->header.sense_node = 0;
+		} else {
+			offset_sense = systemInfo.u16_ssDetRawAddr;
+			offset_force = 0;
+			frame->header.force_node = 0;
+		}
+		break;
+
+	case SS_DETECT_FILTER:
+		if (systemInfo.u8_ssDetScanSet == 0) {
+			offset_force = systemInfo.u16_ssDetFilterAddr;
+			offset_sense = 0;
+			frame->header.sense_node = 0;
+		} else {
+			offset_sense = systemInfo.u16_ssDetFilterAddr;
+			offset_force = 0;
+			frame->header.force_node = 0;
+		}
+		break;
+
+	case SS_DETECT_BASELINE:
+		if (systemInfo.u8_ssDetScanSet == 0) {
+			offset_force = systemInfo.u16_ssDetBaselineAddr;
+			offset_sense = 0;
+			frame->header.sense_node = 0;
+		} else {
+			offset_sense = systemInfo.u16_ssDetBaselineAddr;
+			offset_force = 0;
+			frame->header.force_node = 0;
+		}
+		break;
+
+	case SS_DETECT_STRENGTH:
+		if (systemInfo.u8_ssDetScanSet == 0) {
+			offset_force = systemInfo.u16_ssDetStrenAddr;
+			offset_sense = 0;
+			frame->header.sense_node = 0;
+		} else {
+			offset_sense = systemInfo.u16_ssDetStrenAddr;
+			offset_force = 0;
+			frame->header.force_node = 0;
+		}
+		break;
+
+	default:
+		dev_err(info->dev, "%s: Invalid type ERROR %08X\n", __func__,
+			 ERROR_OP_NOT_ALLOW | ERROR_GET_FRAME);
+		return ERROR_OP_NOT_ALLOW | ERROR_GET_FRAME;
+	}
+
+	frame->header.type = type;
+
+	dev_dbg(info->dev, "%s: Force_len = %d Sense_len = %d Offset_force = %04X Offset_sense = %04X\n",
+		__func__, frame->header.force_node,
+		frame->header.sense_node,
+		offset_force, offset_sense);
+
+	frame->force_data = (short *)kmalloc(frame->header.force_node *
+					     sizeof(short), GFP_KERNEL);
+	if (frame->force_data == NULL) {
+		dev_err(info->dev, "%s: can not allocate force_data ERROR %08X\n",
+			__func__, ERROR_ALLOC | ERROR_GET_FRAME);
+		return ERROR_ALLOC | ERROR_GET_FRAME;
+	}
+
+	frame->sense_data = (short *)kmalloc(frame->header.sense_node *
+					     sizeof(short), GFP_KERNEL);
+	if (frame->sense_data == NULL) {
+		kfree(frame->force_data);
+		frame->force_data = NULL;
+		dev_err(info->dev, "%s: can not allocate sense_data ERROR %08X\n",
+			__func__, ERROR_ALLOC | ERROR_GET_FRAME);
+		return ERROR_ALLOC | ERROR_GET_FRAME;
+	}
+
+	ret = getFrameData(info, offset_force, frame->header.force_node *
+			   BYTES_PER_NODE, (frame->force_data));
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while reading force data ERROR %08X\n",
+			__func__, ERROR_GET_FRAME_DATA);
+		kfree(frame->force_data);
+		frame->force_data = NULL;
+		kfree(frame->sense_data);
+		frame->sense_data = NULL;
+		return ret | ERROR_GET_FRAME_DATA | ERROR_GET_FRAME;
+	}
+
+	ret = getFrameData(info, offset_sense, frame->header.sense_node *
+			   BYTES_PER_NODE, (frame->sense_data));
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while reading sense data ERROR %08X\n",
+			__func__, ERROR_GET_FRAME_DATA);
+		kfree(frame->force_data);
+		frame->force_data = NULL;
+		kfree(frame->sense_data);
+		frame->sense_data = NULL;
+		return ret | ERROR_GET_FRAME_DATA | ERROR_GET_FRAME;
+	}
+	/* if you want to access one node i,j,
+	  * the offset like: offset = i*columns + j = > frame[i, j] */
+
+	dev_dbg(info->dev, "Frame acquired!\n");
+	return frame->header.force_node + frame->header.sense_node;
+	/* return the number of data put inside frame */
+}
+
+
+/**
+  * Read Initialization Data Header and check that the type loaded match with
+  * the one previously requested
+  * @param type type of Initialization data requested @link load_opt Load Host
+  * Data Option @endlink
+  * @param msHeader pointer to DataHeader variable which will contain the header
+  * info for the MS frame
+  * @param ssHeader pointer to DataHeader variable which will contain the header
+  * info for the SS frame
+  * @param address pointer to a variable which will contain the updated address
+  * to the next data
+  * @return OK if success or an error code which specify the type of error
+  */
+int readSyncDataHeader(struct fts_ts_info *info, u8 type, DataHeader *msHeader,
+		       DataHeader *ssHeader, u64 *address)
+{
+	u64 offset = ADDR_FRAMEBUFFER;
+	u8 data[SYNCFRAME_DATA_HEADER];
+	int ret;
+
+	ret = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16, offset,
+				data, SYNCFRAME_DATA_HEADER,
+				DUMMY_FRAMEBUFFER);
+	if (ret < OK) {	/* i2c function have already a retry mechanism */
+		dev_err(info->dev, "%s: error while reading data header ERROR %08X\n",
+			__func__, ret);
+		return ret;
+	}
+
+	dev_info(info->dev, "Read Data Header done!\n");
+
+	if (data[0] != HEADER_SIGNATURE) {
+		dev_err(info->dev, "%s: The Header Signature was wrong! %02X != %02X ERROR %08X\n",
+			__func__, data[0], HEADER_SIGNATURE,
+			ERROR_WRONG_DATA_SIGN);
+		return ERROR_WRONG_DATA_SIGN;
+	}
+
+
+	if (data[1] != type) {
+		dev_err(info->dev, "%s: Wrong type found! %02X!=%02X ERROR %08X\n",
+			__func__, data[1], type, ERROR_DIFF_DATA_TYPE);
+		return ERROR_DIFF_DATA_TYPE;
+	}
+
+	dev_info(info->dev, "Type = %02X of SyncFrame data OK!\n", type);
+
+	msHeader->force_node = data[5];
+	msHeader->sense_node = data[6];
+	dev_info(info->dev, "MS Frame force_node = %d, sense_node = %d\n",
+		 msHeader->force_node, msHeader->sense_node);
+
+	ssHeader->force_node = data[7];
+	ssHeader->sense_node = data[8];
+	dev_info(info->dev, "SS Frame force_node = %d, sense_node = %d\n",
+		 ssHeader->force_node, ssHeader->sense_node);
+
+	*address = offset + SYNCFRAME_DATA_HEADER + data[4];
+
+	return OK;
+}
+
+/**
+  * Read a Sync Frame from frame buffer which contain MS and SS data collected
+  * for the same scan
+  * @param type type of Sync frame to read, possible values:
+  * LOAD_SYNC_FRAME_RAW, LOAD_SYNC_FRAME_FILTER, LOAD_SYNC_FRAME_BASELINE,
+  * LOAD_SYNC_FRAME_STRENGTH
+  * @param msFrame pointer to MutualSenseFrame variable which will contain the
+  * MS data
+  * @param ssFrame pointer to SelfSenseFrame variable which will contain the SS
+  * data
+  * @return >0 if success specifying the total number of nodes copied into
+  * msFrame and ssFrame or an error code which specify the type of error
+  */
+int getSyncFrame(struct fts_ts_info *info, u8 type, MutualSenseFrame *msFrame,
+		 SelfSenseFrame *ssFrame)
+{
+	int res;
+	u64 address;
+
+	msFrame->node_data = NULL;
+	ssFrame->force_data = NULL;
+	ssFrame->sense_data = NULL;
+
+	dev_info(info->dev, "%s: Starting to get Sync Frame %02X...\n", __func__, type);
+	switch (type) {
+	case LOAD_SYNC_FRAME_RAW:
+		msFrame->header.type = MS_RAW;
+		ssFrame->header.type = SS_RAW;
+		break;
+
+	case LOAD_SYNC_FRAME_FILTER:
+		msFrame->header.type = MS_FILTER;
+		ssFrame->header.type = SS_FILTER;
+		break;
+
+	case LOAD_SYNC_FRAME_BASELINE:
+		msFrame->header.type = MS_BASELINE;
+		ssFrame->header.type = SS_BASELINE;
+		break;
+
+	case LOAD_SYNC_FRAME_STRENGTH:
+		msFrame->header.type = MS_STRENGTH;
+		ssFrame->header.type = SS_STRENGTH;
+		break;
+
+	default:
+		return ERROR_OP_NOT_ALLOW | ERROR_GET_FRAME;
+	}
+
+	dev_info(info->dev, "%s: Requesting Sync Frame %02X...\n", __func__, type);
+	res = requestSyncFrame(info, type);
+	if (res < OK) {
+		dev_err(info->dev, "%s: error while requesting Sync Frame ERROR %08X\n",
+			__func__, res | ERROR_GET_FRAME_DATA);
+		return res | ERROR_GET_FRAME_DATA;
+	}
+
+	res = readSyncDataHeader(info, type, &(msFrame->header),
+				 &(ssFrame->header), &address);
+	if (res < OK) {
+		dev_err(info->dev, "%s: error while reading Sync Frame header... ERROR %08X\n",
+			__func__, res | ERROR_GET_FRAME_DATA);
+		return res | ERROR_GET_FRAME_DATA;
+	}
+
+	msFrame->node_data_size = msFrame->header.force_node *
+				  msFrame->header.sense_node;
+
+	msFrame->node_data = (short *)kmalloc(msFrame->node_data_size *
+					      sizeof(short), GFP_KERNEL);
+	if (msFrame->node_data == NULL) {
+		dev_err(info->dev, "%s: impossible allocate memory for MS frame... ERROR %08X\n",
+			__func__, ERROR_ALLOC | ERROR_GET_FRAME);
+		return ERROR_ALLOC | ERROR_GET_FRAME;
+	}
+
+	dev_info(info->dev, "%s: Getting MS frame at %llx...\n", __func__, address);
+	res = getFrameData(info, address,
+			   (msFrame->node_data_size) * BYTES_PER_NODE,
+			   (msFrame->node_data));
+	if (res < OK) {
+		dev_err(info->dev, "%s: error while getting MS data...ERROR %08X\n",
+			__func__, res);
+		res |= ERROR_GET_FRAME_DATA | ERROR_GET_FRAME;
+		goto ERROR;
+	}
+
+	/* move the offset */
+	address += (msFrame->node_data_size) * BYTES_PER_NODE;
+
+	ssFrame->force_data = (short *)kmalloc(ssFrame->header.force_node *
+					       sizeof(short), GFP_KERNEL);
+	if (ssFrame->force_data == NULL) {
+		dev_err(info->dev, "%s: impossible allocate memory for SS force frame...ERROR %08X\n",
+			__func__, ERROR_ALLOC | ERROR_GET_FRAME);
+		res = ERROR_ALLOC | ERROR_GET_FRAME;
+		goto ERROR;
+	}
+
+	dev_info(info->dev, "%s: Getting SS force frame at %llx...\n", __func__, address);
+	res = getFrameData(info, address, (ssFrame->header.force_node) *
+			   BYTES_PER_NODE, (ssFrame->force_data));
+	if (res < OK) {
+		dev_err(info->dev, "%s: error while getting SS force data...ERROR %08X\n",
+			__func__, res);
+		res |= ERROR_GET_FRAME_DATA | ERROR_GET_FRAME;
+		goto ERROR;
+	}
+
+	/* move the offset */
+	address += (ssFrame->header.force_node) * BYTES_PER_NODE;
+
+	ssFrame->sense_data = (short *)kmalloc(ssFrame->header.sense_node *
+					       sizeof(short), GFP_KERNEL);
+	if (ssFrame->sense_data == NULL) {
+		dev_err(info->dev, "%s: impossible allocate memory for SS sense frame...ERROR %08X\n",
+			__func__, ERROR_ALLOC | ERROR_GET_FRAME);
+		res = ERROR_ALLOC | ERROR_GET_FRAME;
+		goto ERROR;
+	}
+
+	dev_info(info->dev, "%s: Getting SS sense frame at %llx...\n", __func__, address);
+	res = getFrameData(info, address, (ssFrame->header.sense_node) *
+			   BYTES_PER_NODE, (ssFrame->sense_data));
+	if (res < OK) {
+		dev_err(info->dev, "%s: error while getting SS sense data...ERROR %08X\n",
+			__func__, res);
+		res |= ERROR_GET_FRAME_DATA | ERROR_GET_FRAME;
+		goto ERROR;
+	}
+
+ERROR:
+	if (res < OK) {
+		if (msFrame->node_data != NULL) {
+			kfree(msFrame->node_data);
+			msFrame->node_data = NULL;
+		}
+
+		if (ssFrame->force_data != NULL) {
+			kfree(ssFrame->force_data);
+			ssFrame->force_data = NULL;
+		}
+
+		if (ssFrame->sense_data != NULL) {
+			kfree(ssFrame->sense_data);
+			ssFrame->sense_data = NULL;
+		}
+		dev_err(info->dev, "Getting Sync Frame FAILED! ERROR %08X!\n", res);
+	} else {
+		dev_info(info->dev, "Getting Sync Frame FINISHED!\n");
+		res = msFrame->node_data_size + ssFrame->header.force_node +
+		      ssFrame->header.sense_node;
+	}
+	return res;
+}
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("STMicroelectronics MultiTouch IC Driver");
+MODULE_AUTHOR("STMicroelectronics");
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsFrame.h b/drivers/input/touchscreen/stfts/google/fts_lib/ftsFrame.h
new file mode 100644
index 000000000000..70fe490637e3
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsFrame.h
@@ -0,0 +1,122 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				 **
+  **************************************************************************
+  **                        marco.cali@st.com				 **
+  **************************************************************************
+  *                                                                        *
+  *                  FTS functions for getting frames			  *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsFrame.h
+  * \brief Contains all the definitions and structs to work with frames
+  */
+
+
+#ifndef FTS_FRAME_H
+#define FTS_FRAME_H
+
+#include "ftsSoftware.h"
+#include "ftsCore.h"
+
+
+
+/* Number of data bytes for each node */
+#define BYTES_PER_NODE		2	/* /< number of data bytes for each node
+					 * */
+
+
+#define RETRY_FRAME_DATA_READ	2	/* /< max number of attempts to read a
+					 * frame */
+#define SYNCFRAME_DATA_HEADER	(DATA_HEADER + 12)	/* /< number of bytes of
+							 * Sync Frame Header */
+
+/**
+  * Possible types of MS frames
+  */
+typedef enum {
+	MS_RAW		= 0,	/* /< Mutual Sense Raw Frame */
+	MS_FILTER	= 1,	/* /< Mutual Sense Filtered Frame */
+	MS_STRENGTH	= 2,	/* /< Mutual Sense Strength Frame (Baseline-Raw)
+				 * */
+	MS_BASELINE	= 3,	/* /< Mutual Sense Baseline Frame */
+	MS_KEY_RAW	= 4,	/* /< Mutual Sense Key Raw Frame */
+	MS_KEY_FILTER	= 5,	/* /< Mutual Sense Key Filter Frame */
+	MS_KEY_STRENGTH = 6,	/* /< Mutual Sense Key Strength Frame
+				 * (Baseline-Raw) */
+	MS_KEY_BASELINE = 7,	/* /< Mutual Sense Key Baseline Frame */
+	FRC_RAW		= 8,	/* /< Force Raw Frame */
+	FRC_FILTER	= 9,	/* /< Force Filtered Frame */
+	FRC_STRENGTH	= 10,	/* /< Force Strength Frame (Baseline-Raw) */
+	FRC_BASELINE	= 11	/* /< Force Baseline Frame */
+} MSFrameType;
+
+
+/**
+  * Possible types of SS frames
+  */
+typedef enum {
+	SS_RAW		= 0,	/* /< Self Sense Raw Frame */
+	SS_FILTER	= 1,	/* /< Self Sense Filtered Frame */
+	SS_STRENGTH	= 2,	/* /< Self Sense Strength Frame (Baseline-Raw)
+				 * */
+	SS_BASELINE	= 3,	/* /< Self Sense Baseline Frame */
+	SS_HVR_RAW	= 4,	/* /< Self Sense Hover Raw Frame */
+	SS_HVR_FILTER	= 5,	/* /< Self Sense Hover Filter Frame */
+	SS_HVR_STRENGTH = 6,	/* /< Self Sense Hover Strength Frame
+				 * (Baseline-Raw) */
+	SS_HVR_BASELINE = 7,	/* /< Self Sense Hover Baseline Frame */
+	SS_PRX_RAW	= 8,	/* /< Self Sense Proximity Raw Frame */
+	SS_PRX_FILTER	= 9,	/* /< Self Sense Proximity Filtered Frame */
+	SS_PRX_STRENGTH = 10,	/* /< Self Sense Proximity Strength Frame
+				 * (Baseline-Raw) */
+	SS_PRX_BASELINE = 11,	/* /< Self Sense Proximity Baseline Frame */
+
+	SS_DETECT_RAW = 12,  /* /< Self Sense Detect Raw Frame */
+	SS_DETECT_FILTER = 13,  /* /< Self Sense Detect Filter Frame */
+	SS_DETECT_STRENGTH = 14,  /* /< Self Sense Detect Strength Frame */
+	SS_DETECT_BASELINE = 15  /* /< Self Sense Detect Baseline Frame */
+} SSFrameType;
+
+
+/**
+  * Struct which contains the data of a MS Frame
+  */
+typedef struct {
+	DataHeader header;	/* /< Header which contain basic info of the
+				 * frame */
+	short *node_data;	/* /< Data of the frame */
+	int node_data_size;	/* /< Dimension of the data of the frame */
+} MutualSenseFrame;
+
+/**
+  * Struct which contains the data of a SS Frame
+  */
+typedef struct {
+	DataHeader header;	/* /< Header which contain basic info of the
+				 * frame */
+	short *force_data;	/* /< Force Channels Data */
+	short *sense_data;	/* /< Sense Channels Data */
+} SelfSenseFrame;
+
+
+int getChannelsLength(struct fts_ts_info *info);
+int getFrameData(struct fts_ts_info *info, u16 address, int size,
+		 short *frame);
+int getSenseLen(struct fts_ts_info *info);
+int getForceLen(struct fts_ts_info *info);
+int getMSFrame3(struct fts_ts_info *info, MSFrameType type,
+		MutualSenseFrame *frame);
+int getSSFrame3(struct fts_ts_info *info, SSFrameType type,
+		SelfSenseFrame *frame);
+int readSyncDataHeader(struct fts_ts_info *info, u8 type, DataHeader *msHeader, DataHeader *ssHeader,
+		       u64 *address);
+int getSyncFrame(struct fts_ts_info *info, u8 type, MutualSenseFrame *msFrame,
+		 SelfSenseFrame *ssFrame);
+#endif
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsGesture.c b/drivers/input/touchscreen/stfts/google/fts_lib/ftsGesture.c
new file mode 100644
index 000000000000..2c32a26eda50
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsGesture.c
@@ -0,0 +1,381 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				 **
+  **************************************************************************
+  **                        marco.cali@st.com				**
+  **************************************************************************
+  *                                                                        *
+  *                     FTS Gesture Utilities				**
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsGesture.c
+  * \brief Contains all the functions and variable to handle the Gesture
+  * Detection features
+  */
+
+#include "ftsSoftware.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsGesture.h"
+#include "ftsIO.h"
+#include "ftsTime.h"
+#include "ftsTool.h"
+
+/* /< store the gesture bitmask which the host want to enable.
+ * If bit set 1 the corresponding gesture will be detected in Gesture Mode */
+static u8 gesture_mask[GESTURE_MASK_SIZE] = { 0 };
+/* /< store the x coordinates of the points draw by the user
+ * when a gesture is detected */
+u16 gesture_coordinates_x[GESTURE_MAX_COORDS_PAIRS_REPORT] = { 0 };
+/* /< store the y coordinates of the points draw by the user
+ * when a gesture is detected */
+u16 gesture_coordinates_y[GESTURE_MAX_COORDS_PAIRS_REPORT] = { 0 };
+/* /< number of coordinates pairs (points) reported with the detected gesture */
+int gesture_coords_reported = ERROR_OP_NOT_ALLOW;
+static u8 refreshGestureMask;	/* /< flag which indicate if there is
+				 * the need to set the gesture mask in the FW */
+struct mutex gestureMask_mutex;	/* /< mutex used to control access on gesture
+				 * shared variables */
+
+/**
+  * Update the gesture mask stored in the driver and have to be used in gesture
+  * mode
+  * @param mask pointer to a byte array which store the gesture mask update
+  * that want to be performed.
+  * @param size dimension in byte of mask. This size can be <=
+  * GESTURE_MASK_SIZE.
+  * If size < GESTURE_MASK_SIZE the bytes of mask are considering continuos
+  * and starting from the less significant byte.
+  * @param en 0 = enable the gestures set in mask, 1 = disable the gestures set
+  * in mask
+  * @return OK if success or an error code which specify the type of error
+  */
+int updateGestureMask(u8 *mask, int size, int en)
+{
+	u8 temp;
+	int i;
+
+	if (mask != NULL) {
+		if (size <= GESTURE_MASK_SIZE) {
+			if (en == FEAT_ENABLE) {
+				mutex_lock(&gestureMask_mutex);
+				pr_info("updateGestureMask: setting gesture mask to enable...\n");
+				if (mask != NULL)
+					for (i = 0; i < size; i++)
+						gesture_mask[i] =
+							gesture_mask[i] |
+							mask[i];
+				/* back up of the gesture enabled */
+				refreshGestureMask = 1;
+				pr_info("updateGestureMask: gesture mask to enable SET!\n");
+				mutex_unlock(&gestureMask_mutex);
+				return OK;
+			} else if (en == FEAT_DISABLE) {
+				mutex_lock(&gestureMask_mutex);
+				pr_info("updateGestureMask: setting gesture mask to disable...\n");
+				for (i = 0; i < size; i++) {
+					temp = gesture_mask[i] ^ mask[i];
+					/* enabled XOR disabled */
+					gesture_mask[i] = temp &
+							  gesture_mask[i];
+					/* temp AND enabled
+					 * disable the gestures that were
+					 * enabled */
+				}
+				pr_info("updateGestureMask: gesture mask to disable SET!\n");
+				refreshGestureMask = 1;
+				mutex_unlock(&gestureMask_mutex);
+				return OK;
+			} else {
+				pr_err("%s: Enable parameter Invalid! %d != %d or %d ERROR %08X\n",
+					__func__,
+					en,
+					FEAT_DISABLE, FEAT_ENABLE,
+					ERROR_OP_NOT_ALLOW);
+				return ERROR_OP_NOT_ALLOW;
+			}
+		} else {
+			pr_err("updateGestureMask: Size not valid! %d > %d ERROR %08X\n",
+				size, GESTURE_MASK_SIZE, ERROR_OP_NOT_ALLOW);
+			return ERROR_OP_NOT_ALLOW;
+		}
+	} else {
+		pr_err("updateGestureMask: Mask NULL! ERROR %08X\n",
+			ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+}
+
+/**
+  * Enable in the FW the gesture mask to be used in gesture mode
+  * @param mask pointer to a byte array which store the gesture mask update
+  * that want to be sent to the FW, if NULL, will be used gesture_mask
+  * set previously without any changes.
+  * @param size dimension in byte of mask. This size can be <=
+  * GESTURE_MASK_SIZE.
+  * If size < GESTURE_MASK_SIZE the bytes of mask are considering continuos and
+  * starting from the less significant byte.
+  * @return OK if success or an error code which specify the type of error
+  */
+int enableGesture(struct fts_ts_info *info, u8 *mask, int size)
+{
+	int i, res;
+
+	pr_info("Trying to enable gesture...\n");
+
+	if (size <= GESTURE_MASK_SIZE) {
+		mutex_lock(&gestureMask_mutex);
+		if (mask != NULL)
+			for (i = 0; i < size; i++)
+				gesture_mask[i] = gesture_mask[i] | mask[i];
+		/* back up of the gesture enabled */
+
+		res = setFeatures(info, FEAT_SEL_GESTURE, gesture_mask,
+				  GESTURE_MASK_SIZE);
+		if (res < OK) {
+			pr_err("enableGesture: ERROR %08X\n", res);
+			goto END;
+		}
+
+		pr_info("enableGesture DONE!\n");
+		res = OK;
+
+END:
+		mutex_unlock(&gestureMask_mutex);
+		return res;
+	} else {
+		pr_err("enableGesture: Size not valid! %d > %d ERROR %08X\n",
+			size, GESTURE_MASK_SIZE, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+}
+
+/**
+  * Disable in the FW the gesture mask to be used in gesture mode
+  * @param mask pointer to a byte array which store the gesture mask update that
+  * want to be sent to the FW, if NULL, all the gestures will be disabled.
+  * @param size dimension in byte of mask. This size can be <=
+  * GESTURE_MASK_SIZE.
+  * If size < GESTURE_MASK_SIZE the bytes of mask are considering continuos and
+  * starting from the less significant byte.
+  * @return OK if success or an error code which specify the type of error
+  */
+int disableGesture(struct fts_ts_info *info, u8 *mask, int size)
+{
+	u8 temp;
+	int i, res;
+	u8 *pointer;
+
+
+	pr_info("Trying to disable gesture...\n");
+
+
+	if (size <= GESTURE_MASK_SIZE) {
+		mutex_lock(&gestureMask_mutex);
+		if (mask != NULL) {
+			for (i = 0; i < size; i++) {
+				temp = gesture_mask[i] ^ mask[i];
+				/* enabled mask XOR disabled mask */
+				gesture_mask[i] = temp & gesture_mask[i];
+				/* temp AND enabled
+				 * disable the gestures that are specified and
+				 * previously enabled */
+			}
+
+			pointer = gesture_mask;
+		} else {
+			i = 0;	/* if NULL is passed disable all the possible
+				 * gestures */
+			pointer = (u8 *)&i;
+		}
+
+		res = setFeatures(info, FEAT_SEL_GESTURE, pointer, GESTURE_MASK_SIZE);
+		if (res < OK) {
+			pr_err("disableGesture: ERROR %08X\n", res);
+			goto END;
+		}
+
+		pr_info("disableGesture DONE!\n");
+
+		res = OK;
+
+END:
+		mutex_unlock(&gestureMask_mutex);
+		return res;
+	} else {
+		pr_err("disableGesture: Size not valid! %d > %d ERROR %08X\n",
+			size, GESTURE_MASK_SIZE, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+}
+
+/**
+  * Perform all the steps required to put the chip in gesture mode
+  * @param reload if set to 1, before entering in gesture mode it will re-enable
+  * in the FW the last defined gesture mask
+  * @return OK if success or an error code which specify the type of error
+  */
+int enterGestureMode(struct fts_ts_info *info, int reload)
+{
+	int res, ret;
+
+	res = fts_enableInterrupt(info, false);
+	if (res < OK) {
+		pr_err("enterGestureMode: ERROR %08X\n",
+			res | ERROR_DISABLE_INTER);
+		return res | ERROR_DISABLE_INTER;
+	}
+
+	if (reload == 1 || refreshGestureMask == 1) {
+		res = enableGesture(info, NULL, 0);
+		if (res < OK) {
+			pr_err("enterGestureMode: enableGesture ERROR %08X\n",
+				res);
+			goto END;
+		}
+
+		refreshGestureMask = 0;
+	}
+
+	res = setScanMode(info, SCAN_MODE_LOW_POWER, 0);
+	if (res < OK) {
+		pr_err("enterGestureMode: enter gesture mode ERROR %08X\n",
+			res);
+		goto END;
+	}
+
+	res = OK;
+END:
+	ret = fts_enableInterrupt(info, true);
+	if (ret < OK) {
+		pr_err("enterGestureMode: fts_enableInterrupt ERROR %08X\n",
+			res | ERROR_ENABLE_INTER);
+		res |= ret | ERROR_ENABLE_INTER;
+	}
+
+
+	return res;
+}
+
+/**
+  * Check if one or more Gesture IDs are currently enabled in gesture_mask
+  * @return FEAT_ENABLE if one or more gesture ids are enabled, FEAT_DISABLE if
+  * all the gesture ids are currently disabled
+  */
+int isAnyGestureActive(void)
+{
+	int res = 0;
+
+	while (res < (GESTURE_MASK_SIZE - 1) && gesture_mask[res] == 0)
+		/* -1 because in any case the last gesture mask byte will
+		 * be evaluated with the following if */
+		res++;
+
+	if (gesture_mask[res] != 0) {
+		pr_info("%s: Active Gestures Found! gesture_mask[%d] = %02X !\n",
+			__func__, res, gesture_mask[res]);
+		return FEAT_ENABLE;
+	} else {
+		pr_info("%s: All Gestures Disabled!\n", __func__);
+		return FEAT_DISABLE;
+	}
+}
+
+
+/**
+  * Read from the frame buffer the gesture coordinates pairs of the points draw
+  * by an user when a gesture is detected
+  * @param event pointer to a byte array which contains the gesture event
+  * reported
+  * by the fw when a gesture is detected
+  * @return OK if success or an error code which specify the type of error
+  */
+int readGestureCoords(struct fts_ts_info *info, u8 *event)
+{
+	int i = 0;
+	u64 address = 0;
+	int res;
+
+	u8 val[GESTURE_MAX_COORDS_PAIRS_REPORT * 4];
+
+	/* the max coordinates to read are GESTURE_COORDS_REPORT_MAX*4
+	 * (because each coordinate is a short(*2) and we have x and y) */
+
+
+	if (event[0] == EVT_ID_USER_REPORT &&
+	    event[1] == EVT_TYPE_USER_GESTURE) {
+		address = (event[4] << 8) | event[3]; /* Offset in framebuff */
+		gesture_coords_reported = event[5];	/* number of pairs
+							 * coords reported */
+		if (gesture_coords_reported > GESTURE_MAX_COORDS_PAIRS_REPORT) {
+			pr_err("%s:  FW reported more than %d points for the gestures! Decreasing to %d\n",
+				__func__, gesture_coords_reported,
+				GESTURE_MAX_COORDS_PAIRS_REPORT);
+			gesture_coords_reported =
+				GESTURE_MAX_COORDS_PAIRS_REPORT;
+		}
+
+		pr_info("%s: Offset: %llx , coords pairs = %d\n",
+			 __func__, address, gesture_coords_reported);
+
+		res = fts_writeReadU8UX(info, FTS_CMD_FRAMEBUFFER_R, BITS_16,
+					address, val,
+					(gesture_coords_reported * 2 * 2),
+					DUMMY_FRAMEBUFFER);
+		/* *2 because each coord is made by 2 bytes,
+		 * *2 because there are x and y */
+		if (res < OK) {
+			pr_err("%s: Cannot read the coordinates! ERROR %08X\n",
+				__func__, res);
+			gesture_coords_reported = ERROR_OP_NOT_ALLOW;
+			return res;
+		}
+
+		/* all the points of the gesture are stored in val */
+		for (i = 0; i < gesture_coords_reported; i++) {
+			gesture_coordinates_x[i] =
+				(((u16)val[i * 2 + 1]) & 0x0F) << 8 |
+				(((u16)val[i * 2]) & 0xFF);
+			gesture_coordinates_y[i] =
+				(((u16)val[gesture_coords_reported *
+					2 + i * 2 + 1]) & 0x0F) << 8 |
+				(((u16)val[gesture_coords_reported *
+					2 + i * 2]) & 0xFF);
+		}
+
+
+		pr_info("%s: Reading Gesture Coordinates DONE!\n", __func__);
+		return OK;
+	} else {
+		pr_err("%s: The event passsed as argument is invalid! ERROR %08X\n",
+			__func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+}
+
+/**
+  * Return the coordinates of the points stored during the last detected gesture
+  * @param x output parameter which will store the address of the array
+  * containing the x coordinates
+  * @param y output parameter which will store the address of the array
+  * containing the y coordinates
+  * @return the number of points (x,y) stored and therefore the size of the x
+  * and y array returned.
+  */
+int getGestureCoords(u16 **x, u16 **y)
+{
+	*x = gesture_coordinates_x;
+	*y = gesture_coordinates_y;
+	pr_info("%s: Number of gesture coordinates pairs returned = %d\n",
+		__func__, gesture_coords_reported);
+	return gesture_coords_reported;
+}
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("STMicroelectronics MultiTouch IC Driver");
+MODULE_AUTHOR("STMicroelectronics");
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsGesture.h b/drivers/input/touchscreen/stfts/google/fts_lib/ftsGesture.h
new file mode 100644
index 000000000000..9b070ffc3197
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsGesture.h
@@ -0,0 +1,47 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				**
+  **************************************************************************
+  **                        marco.cali@st.com				**
+  **************************************************************************
+  *                                                                        *
+  *                     FTS Gesture Utilities				   *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsGesture.h
+  * \brief Contains all the macro and prototypes to handle the Gesture Detection
+  * features
+  */
+
+
+#ifndef FTS_GESTURE_H_
+#define FTS_GESTURE_H_
+
+
+
+
+#include "ftsHardware.h"
+
+#define GESTURE_MASK_SIZE		4	/* /< number of bytes of the
+						 * gesture mask */
+
+#define GESTURE_MAX_COORDS_PAIRS_REPORT 100	/* /< max number of gestures
+						 * coordinates pairs reported */
+
+
+
+int updateGestureMask(u8 *mask, int size, int en);
+int disableGesture(struct fts_ts_info *info, u8 *mask, int size);
+int enableGesture(struct fts_ts_info *info, u8 *mask, int size);
+int enterGestureMode(struct fts_ts_info *info, int reload);
+int isAnyGestureActive(void);
+int readGestureCoords(struct fts_ts_info *info, u8 *event);
+int getGestureCoords(u16 **x, u16 **y);
+
+#endif	/* ! _GESTURE_H_ */
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsHardware.h b/drivers/input/touchscreen/stfts/google/fts_lib/ftsHardware.h
new file mode 100644
index 000000000000..418c75cc751f
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsHardware.h
@@ -0,0 +1,331 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				**
+  **************************************************************************
+  **                        marco.cali@st.com				 **
+  **************************************************************************
+  *                                                                        *
+  *		HW related data						   *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsHardware.h
+  * \brief Contains all the definitions and information related to the IC
+  * from an hardware point of view
+  */
+
+#ifndef FTS_HARDWARE_H
+#define FTS_HARDWARE_H
+
+/* DIGITAL CHIP INFO */
+#undef ALIX
+
+#define ALIX_DCHIP_ID_0			0x36	/* /< LSB chip ID for FTM5 */
+#define ALIX_DCHIP_ID_1			0x48	/* /< MSB chip ID for FTM5 */
+#define SALIXP_DCHIP_ID_0		0x36
+#define SALIXP_DCHIP_ID_1		0x40
+
+#ifdef ALIX
+#define DCHIP_ID_0		ALIX_DCHIP_ID_0	/* /< LSB chip ID for FTM5 */
+#define DCHIP_ID_1		ALIX_DCHIP_ID_1	/* /< MSB chip ID for FTM5 */
+#else
+#define DCHIP_ID_0			0x36	/* /< LSB chip ID for FTM5 */
+#define DCHIP_ID_1			0x39	/* /< MSB chip ID for FTM5 */
+#endif
+
+#define DCHIP_FW_VER_BYTE		2	/* /< number of bytes of the fw
+						 * versions */
+
+/* CHUNKS */
+#define READ_CHUNK			1024	/* /< chunk dimension of
+						 * a single i2c read,
+						 * max allowed value is 2kB */
+#define WRITE_CHUNK			1024	/* /< chunk dimension of
+						 * a single i2c write,
+						 * max allowed value is 2kB */
+#define MEMORY_CHUNK			1024	/* /< chunk dimenasion of
+						 * a single i2c write on mem,
+						 * max allowed value is 2kB */
+
+#define READ_FILTERED_RAW	/* /< To understand
+				* which type of RAW data to read
+				* OCTA panel needs to read Filtered RAW */
+
+/* PROTOCOL INFO */
+#define SPI_INETERFACE
+#ifdef I2C_INTERFACE
+#define I2C_SAD				0x49	/* /< slave address of the IC */
+#else
+#define SPI_DELAY_CS			10	/* /< time in usec to wait
+						 * before rising the CS */
+#endif
+
+#define IER_ENABLE			0x41	/* /< value to write in IER_ADDR
+						 *  to enable the interrupts */
+#define IER_DISABLE			0x00	/* /< value to write in IER_ADDR
+						 *  to disable the interrupts
+						 **/
+
+/* FLASH COMMAND */
+/** @defgroup flash_command Flash Commands
+  *	All the commands that works with the flash of the IC
+  *	@{
+  */
+#define FLASH_CMD_UNLOCK		0xF7
+
+#define FLASH_CMD_READ_REGISTER		0xFA
+#define FLASH_CMD_WRITE_REGISTER	0xFA
+
+/* FLASH UNLOCK PARAMETER */
+#define FLASH_UNLOCK_CODE0		0x25
+#define FLASH_UNLOCK_CODE1		0x20
+#define FLASH_UNLOCK_CODE2		0x6B
+#define FLASH_UNLOCK_CODE3		0x00
+
+/* FLASH UVLO ENABLE PARAMETER */
+#define FLASH_UVLO_ENABLE_CODE0		0x1B
+#define FLASH_UVLO_ENABLE_CODE1		0x66
+
+/* FLASH AUTOPOWERDOWN ENABLE PARAMETER */
+#define FLASH_AUTOPOWERDOWN_ENABLE_CODE0 0x68
+#define FLASH_AUTOPOWERDOWN_ENABLE_CODE1 0x13
+
+#define INFO_BLOCK_SIZE			16384
+#define INFO_BLOCK_LOCKDOWN		0x1800
+#define INFO_BLOCK_IOFF			0x19E8
+#define INFO_BLOCK_OSC			0x1EAC
+#define INFO_BLOCK_AOFFSET		0x1D48
+#define INFO_BLOCK_CG			0x1E08
+
+/* FLASH ERASE and DMA PARAMETER */
+#define FLASH_ERASE_START		0x80
+#define FLASH_ERASE_CODE1		0xC0
+#define FLASH_DMA_CODE1			0xC0
+#define FLASH_ERASE_UNLOCK_CODE0	0xDE
+#define FLASH_ERASE_UNLOCK_CODE1	0x03
+#define FLASH_ERASE_CODE0		0x6A
+#define FLASH_DMA_CODE0			0x71
+#define FLASH_DMA_CONFIG		0x72
+#define FLASH_NUM_PAGE			32	/* /< number of pages in main
+						 * flash */
+#define FLASH_CX_PAGE_START		28	/* /< starting page which
+						 * contain Cx data */
+#define FLASH_CX_PAGE_END		30	/* /< last page which contain Cx
+						 * data */
+#define FLASH_PANEL_PAGE_START		26	/* /< starting page which
+						 * contain Panel Init data */
+#define FLASH_PANEL_PAGE_END		27	/* /< last page which contain
+						 * Panel Init data */
+/** @} */
+
+/* FLASH ADDRESS */
+#define FLASH_ADDR_CODE			0x00000000	/* /< address of code in
+							 * FTI */
+#define FLASH_ADDR_CONFIG		0x00007C00	/* /< address of config
+							 * in FTI */
+#define FLASH_ADDR_CX			0x00007000	/* /< address of Init
+							 * data in FTI */
+
+/* SIZES FW, CODE, CONFIG, MEMH */
+/** @defgroup fw_file FW file info
+ *	All the info related to the fw file
+ *	@{
+ */
+#define FW_HEADER_SIZE			64	/* /< dimension of the header in
+						 * .fts file */
+#define FW_HEADER_SIGNATURE		0xAA55AA55	/* /< header signature
+							 * */
+#define FW_FTB_VER			0x00000001	/* /< .ftb version */
+#define FW_BYTES_ALIGN			4	/* /< allignment of the info */
+#define FW_BIN_VER_OFFSET		16	/* /< offset of the fw version
+						 * in the .ftb file */
+#define FW_BIN_CONFIG_ID_OFFSET		20	/* /< offset of the config id in
+						 * the .ftb file */
+#define FW_CX_VERSION			(16 + 4)	/* CX version offset in
+							 * sec2 of FW */
+#define FW_CX_AFE_VERSION		(FW_CX_VERSION + 4)	/* CX afe
+								 * version
+								 * offset
+								 * in sec2 of
+								 * FW */
+#define FW_CFG_AFE_VERSION		21	/* cfg afe version offset
+						 * in sec1 of FW */
+/** @} */
+
+/* FIFO */
+#define FIFO_EVENT_SIZE			8	/* /< number of bytes of one
+						 * event */
+#define FIFO_DEPTH			32	/* /< max number of events that
+						  * the FIFO can collect before
+						  * going in overflow in FTM5 */
+
+#ifdef I2C_INTERFACE
+#define FIFO_CMD_READALL		0x86	/* /< command to read all
+						  * the events in the FIFO */
+#else
+#define FIFO_CMD_READALL		0x87	/* /< command to read all
+						  * the events in the FIFO */
+#endif
+#define FIFO_CMD_READONE		FIFO_CMD_READALL/* /< commad to read
+							  * one event from FIFO
+							  **/
+
+
+/* OP CODES FOR MEMORY (based on protocol) */
+#ifdef I2C_INTERFACE
+#define FTS_CMD_HW_REG_R	0xFA	/* /< command to read an hw register if
+					 * FTI */
+#define FTS_CMD_HW_REG_W	0xFA	/* /< command to write an hw register if
+					 * FTI */
+#define FTS_CMD_FRAMEBUFFER_W	0xA6	/* /< command to write the framebuffer
+					 * if FTI
+					 */
+#define FTS_CMD_FRAMEBUFFER_R	0xA6	/* /< command to read the framebuffer if
+					 * FTI */
+#define FTS_CMD_CONFIG_R	0xA8	/* /< command to read the config memory
+					 * if FTI */
+#define FTS_CMD_CONFIG_W	0xA8	/* /< command to write the config memory
+					 * if FTI */
+#else
+#define FTS_CMD_HW_REG_R	0xFB	/* /< command to read an hw register if
+					 * FTI */
+#define FTS_CMD_HW_REG_W	0xFA	/* /< command to write an hw register if
+					 * FTI */
+#define FTS_CMD_FRAMEBUFFER_W	0xA6	/* /< command to write the framebuffer
+					 * if FTI
+					 */
+#define FTS_CMD_FRAMEBUFFER_R	0xA7	/* /< command to read the framebuffer if
+					 * FTI */
+#define FTS_CMD_CONFIG_R	0xA9	/* /< command to read the config memory
+					 * if FTI */
+#define FTS_CMD_CONFIG_W	0xA8	/* /< command to write the config memory
+					 * if FTI */
+#endif
+
+/* DUMMY BYTES DATA */
+#ifndef I2C_INTERFACE
+#define DUMMY_HW_REG		1	/* /< 1 if the first byte read from HW
+					 * register is dummy */
+#define DUMMY_FRAMEBUFFER	1	/* /< 1 if the first byte read from
+					 * Frame buffer is dummy */
+#define DUMMY_CONFIG		1	/* /< 1 if the first byte read from
+					 * Config Memory is dummy */
+#define DUMMY_FIFO		1	/* /< 1 if the first byte read from FIFO
+					 * is dummy */
+#else
+#define DUMMY_HW_REG		0	/* /< 1 if the first byte read from HW
+					 * register is dummy */
+#define DUMMY_FRAMEBUFFER	0	/* /< 1 if the first byte read from
+					 * Frame buffer is dummy */
+#define DUMMY_CONFIG		0	/* /< 1 if the first byte read from
+					 * Config Memory is dummy */
+#define DUMMY_FIFO		0	/* /< 1 if the first byte read from FIFO
+					 * is dummy */
+#endif
+
+/** @defgroup hw_adr HW Address
+  * @ingroup address
+  * Important addresses of hardware registers (and sometimes their important
+  * values)
+  * @{
+  */
+
+/* IMPORTANT HW ADDRESSES (u64) */
+#define ADDR_FRAMEBUFFER	((u64)0x0000000000000000)	/* /< frame
+								 * buffer
+								 * address in
+								 * memory */
+#define ADDR_ERROR_DUMP		((u64)0x000000000000EF80)	/* /< start
+								 * address dump
+								 * error log */
+
+/* SYSTEM RESET INFO */
+#define ADDR_SYSTEM_RESET	((u64)0x0000000020000024)	/* /< address of
+								 * System
+								 * control
+								 * register in
+								 * FTI */
+/* value to write in SYSTEM_RESET_ADDRESS to perform a system reset in FTM5 */
+#define SYSTEM_RESET_VALUE	0x81
+
+
+/* REMAP REGISTER */
+#define ADDR_BOOT_OPTION	((u64)0x0000000020000025)	/* /< address of
+								 * Boot option
+								 * register */
+
+/* INTERRUPT INFO */
+#define ADDR_IER		((u64)0x0000000020000029)	/* /< address of
+								 * the Interrupt
+								 * enable
+								 * register in
+								 * FTMI */
+
+/* Chip ID/Fw Version */
+#define ADDR_DCHIP_ID		((u64)0x0000000020000000)	/* /< chip id
+								 * address for
+								 * FTI */
+#define ADDR_DCHIP_FW_VER	((u64)0x0000000020000004)	/* /< fw version
+								 * address for
+								 * FTI */
+
+/* INTERFACE REGISTER */
+#define ADDR_ICR		((u64)0x000000002000002D)	/* /< address of
+								 * Device
+								 * control
+								 * register
+								 * to set the
+								 * communication
+								 * protocol
+								 * (SPI/I2C) */
+
+#define SPI4_MASK		0x02	/* /< bit to set spi4 */
+
+#define ADDR_FLASH_STATUS       ((u64)0x0000000020000068)
+#define ADDR_INFOBLOCK          ((u64)0x0000000000040000)
+
+
+/* CRC ADDR */
+#define ADDR_CRC		((u64)0x0000000020000078)	/* /< address of
+								 * the CRC
+								 * control
+								 * register in
+								 * FTI */
+#define CRC_MASK		0x03	/* /< bitmask which reveal if
+					 * there is a CRC error in the flash */
+
+#define ADDR_CONFIG_OFFSET	((u64)0x0000000000000000)	/* /< config
+								 * address in
+								 * memory if FTI
+								 * */
+
+#define ADDR_GPIO_INPUT		((u64)0x0000000020000030)	/* /< address of
+								 * GPIO input
+								 * register */
+#define ADDR_GPIO_DIRECTION	((u64)0x0000000020000032)	/* /< address of
+								 * GPIO
+								 * direction
+								 * register */
+#define ADDR_GPIO_PULLUP	((u64)0x0000000020000034)	/* /< address of
+								 * GPIO pullup
+								 * register */
+#define ADDR_GPIO_CONFIG_REG0	((u64)0x000000002000003D)	/* /< address of
+								 * GPIO config
+								 * register */
+#define ADDR_GPIO_CONFIG_REG2	((u64)0x000000002000003F)	/* /< address of
+								 * GPIO config
+								 * register */
+
+#define ADDR_GPIO_CONFIG_REG3	((u64)0x000000002000003E)	/* /< address of
+								 * GPIO config
+								 * register */
+
+/**@}*/
+
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsIO.c b/drivers/input/touchscreen/stfts/google/fts_lib/ftsIO.c
new file mode 100644
index 000000000000..ff9147ee9e4c
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsIO.c
@@ -0,0 +1,847 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				**
+  **************************************************************************
+  **                        marco.cali@st.com				**
+  **************************************************************************
+  *                                                                        *
+  *                     I2C/SPI Communication				  *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsIO.c
+  * \brief Contains all the functions which handle with the I2C/SPI
+  *communication
+  */
+
+
+#include "ftsSoftware.h"
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/of_gpio.h>
+
+#ifdef I2C_INTERFACE
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+static u16 I2CSAD;	/* /< slave address of the IC in the i2c bus */
+#else
+#include <linux/spi/spidev.h>
+#endif
+
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsHardware.h"
+#include "ftsIO.h"
+
+
+/**
+  * Initialize the static client variable of the fts_lib library in order
+  * to allow any i2c/spi transaction in the driver (Must be called in the probe)
+  * @param clt pointer to i2c_client or spi_device struct which identify the bus
+  * slave device
+  * @return OK
+  */
+int openChannel(void *clt)
+{
+#ifdef I2C_INTERFACE
+	I2CSAD = ((struct i2c_client *)clt)->addr;
+	dev_info(&((struct i2c_client *)clt)->dev, "openChannel: SAD: %02X\n",
+		I2CSAD);
+#else
+	dev_info(&((struct spi_device *)clt)->dev,
+		"%s: spi_controller: flags = %04X !\n", __func__,
+		 ((struct spi_device *)clt)->controller->flags);
+	dev_info(&((struct spi_device *)clt)->dev,
+		"%s: spi_device: max_speed = %d chip select = %02X bits_per_words = %d mode = %04X !\n",
+		__func__, ((struct spi_device *)clt)->max_speed_hz,
+		spi_get_chipselect(((struct spi_device *)clt), 0),
+		((struct spi_device *)clt)->bits_per_word,
+		((struct spi_device *)clt)->mode);
+	dev_info(&((struct spi_device *)clt)->dev, "openChannel: completed!\n");
+#endif
+	return OK;
+}
+
+#ifdef I2C_INTERFACE
+/**
+  * Change the I2C slave address which will be used during the transaction
+  * (For Debug Only)
+  * @param sad new slave address id
+  * @return OK
+  */
+int changeSAD(u8 sad)
+{
+	I2CSAD = sad;
+	return OK;
+}
+#endif
+
+
+/****************** New I2C API *********************/
+
+/**
+  * Perform a direct bus read
+  * @param outBuf pointer of a byte array which should contain the byte read
+  * from the IC
+  * @param byteToRead number of bytes to read
+  * @return OK if success or an error code which specify the type of error
+  */
+static int fts_read_internal(struct fts_ts_info *info, u8 *outBuf,
+			     int byteToRead, bool dma_safe)
+{
+	int ret = -1;
+	int retry = 0;
+#ifdef I2C_INTERFACE
+	struct i2c_msg I2CMsg[1];
+#else
+	struct spi_message msg;
+	struct spi_transfer transfer[1] = { { 0 } };
+#endif
+
+	if (dma_safe == false && byteToRead > sizeof(info->io_read_buf)) {
+		dev_err(info->dev, "%s: preallocated buffers are too small!\n", __func__);
+		return ERROR_ALLOC;
+	}
+
+#ifdef I2C_INTERFACE
+	I2CMsg[0].addr = (__u16)I2CSAD;
+	I2CMsg[0].flags = (__u16)I2C_M_RD;
+	I2CMsg[0].len = (__u16)byteToRead;
+	if (dma_safe == false)
+		I2CMsg[0].buf = (__u8 *)info->io_read_buf;
+	else
+		I2CMsg[0].buf = (__u8 *)outBuf;
+#else
+	spi_message_init(&msg);
+
+	transfer[0].len = byteToRead;
+	transfer[0].delay.value = SPI_DELAY_CS;
+	transfer[0].delay.unit = SPI_DELAY_UNIT_USECS;
+	transfer[0].tx_buf = NULL;
+	if (dma_safe == false)
+		transfer[0].rx_buf = info->io_read_buf;
+	else
+		transfer[0].rx_buf = outBuf;
+	spi_message_add_tail(&transfer[0], &msg);
+#endif
+
+	if (info->client == NULL)
+		return ERROR_BUS_O;
+	while (retry < I2C_RETRY && ret < OK) {
+#ifdef I2C_INTERFACE
+		ret = i2c_transfer(info->client->adapter, I2CMsg, 1);
+#else
+		ret = spi_sync(info->client, &msg);
+#endif
+
+		retry++;
+		if (ret < OK)
+			mdelay(I2C_WAIT_BEFORE_RETRY);
+		/* dev_err(info->dev, "fts_writeCmd: attempt %d\n", retry); */
+	}
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_BUS_R);
+		return ERROR_BUS_R;
+	}
+
+	if (dma_safe == false)
+		memcpy(outBuf, info->io_read_buf, byteToRead);
+
+	return OK;
+}
+
+
+/**
+  * Perform a bus write followed by a bus read without a stop condition
+  * @param cmd byte array containing the command to write
+  * @param cmdLength size of cmd
+  * @param outBuf pointer of a byte array which should contain the bytes read
+  * from the IC
+  * @param byteToRead number of bytes to read
+  * @return OK if success or an error code which specify the type of error
+  */
+static int fts_writeRead_internal(struct fts_ts_info *info, u8 *cmd,
+				  int cmdLength, u8 *outBuf, int byteToRead,
+				  bool dma_safe)
+{
+	int ret = -1;
+	int retry = 0;
+#ifdef I2C_INTERFACE
+	struct i2c_msg I2CMsg[2];
+#else
+	struct spi_message msg;
+	struct spi_transfer transfer[2] = { { 0 }, { 0 } };
+#endif
+
+	if (dma_safe == false && (cmdLength > sizeof(info->io_write_buf) ||
+	    byteToRead > sizeof(info->io_read_buf))) {
+		dev_err(info->dev, "%s: preallocated buffers are too small!\n", __func__);
+		return ERROR_ALLOC;
+	}
+
+	if (dma_safe == false) {
+		memcpy(info->io_write_buf, cmd, cmdLength);
+		cmd = info->io_write_buf;
+	}
+
+#ifdef I2C_INTERFACE
+	/* write msg */
+	I2CMsg[0].addr = (__u16)I2CSAD;
+	I2CMsg[0].flags = (__u16)0;
+	I2CMsg[0].len = (__u16)cmdLength;
+	I2CMsg[0].buf = (__u8 *)cmd;
+
+	/* read msg */
+	I2CMsg[1].addr = (__u16)I2CSAD;
+	I2CMsg[1].flags = I2C_M_RD;
+	I2CMsg[1].len = byteToRead;
+	if (dma_safe == false)
+		I2CMsg[1].buf = (__u8 *)info->io_read_buf;
+	else
+		I2CMsg[1].buf = (__u8 *)outBuf;
+#else
+	spi_message_init(&msg);
+
+	transfer[0].len = cmdLength;
+	transfer[0].tx_buf = cmd;
+	transfer[0].rx_buf = NULL;
+	spi_message_add_tail(&transfer[0], &msg);
+
+	transfer[1].len = byteToRead;
+	transfer[1].delay.value = SPI_DELAY_CS;
+	transfer[1].delay.unit = SPI_DELAY_UNIT_USECS;
+	transfer[1].tx_buf = NULL;
+	if (dma_safe == false)
+		transfer[1].rx_buf = info->io_read_buf;
+	else
+		transfer[1].rx_buf = outBuf;
+	spi_message_add_tail(&transfer[1], &msg);
+
+#endif
+
+	if (info->client == NULL)
+		return ERROR_BUS_O;
+
+	while (retry < I2C_RETRY && ret < OK) {
+#ifdef I2C_INTERFACE
+		ret = i2c_transfer(info->client->adapter, I2CMsg, 2);
+#else
+		ret = spi_sync(info->client, &msg);
+#endif
+
+		retry++;
+		if (ret < OK)
+			mdelay(I2C_WAIT_BEFORE_RETRY);
+	}
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_BUS_WR);
+		return ERROR_BUS_WR;
+	}
+
+	if (dma_safe == false)
+		memcpy(outBuf, info->io_read_buf, byteToRead);
+
+	return OK;
+}
+
+
+/**
+  * Perform a bus write
+  * @param cmd byte array containing the command to write
+  * @param cmdLength size of cmd
+  * @return OK if success or an error code which specify the type of error
+  */
+static int fts_write_internal(struct fts_ts_info *info, u8 *cmd, int cmdLength,
+			      bool dma_safe)
+{
+	int ret = -1;
+	int retry = 0;
+#ifdef I2C_INTERFACE
+	struct i2c_msg I2CMsg[1];
+#else
+	struct spi_message msg;
+	struct spi_transfer transfer[1] = { { 0 } };
+#endif
+
+	if (dma_safe == false && cmdLength > sizeof(info->io_write_buf)) {
+		dev_err(info->dev, "%s: preallocated buffers are too small!\n", __func__);
+		return ERROR_ALLOC;
+	}
+
+	if (dma_safe == false) {
+		memcpy(info->io_write_buf, cmd, cmdLength);
+		cmd = info->io_write_buf;
+	}
+
+#ifdef I2C_INTERFACE
+	I2CMsg[0].addr = (__u16)I2CSAD;
+	I2CMsg[0].flags = (__u16)0;
+	I2CMsg[0].len = (__u16)cmdLength;
+	I2CMsg[0].buf = (__u8 *)cmd;
+#else
+	spi_message_init(&msg);
+
+	transfer[0].len = cmdLength;
+	transfer[0].delay.value = SPI_DELAY_CS;
+	transfer[0].delay.unit = SPI_DELAY_UNIT_USECS;
+	transfer[0].tx_buf = cmd;
+	transfer[0].rx_buf = NULL;
+	spi_message_add_tail(&transfer[0], &msg);
+#endif
+
+
+	if (info->client == NULL)
+		return ERROR_BUS_O;
+	while (retry < I2C_RETRY && ret < OK) {
+#ifdef I2C_INTERFACE
+		ret = i2c_transfer(info->client->adapter, I2CMsg, 1);
+#else
+		ret = spi_sync(info->client, &msg);
+#endif
+
+		retry++;
+		if (ret < OK)
+			mdelay(I2C_WAIT_BEFORE_RETRY);
+		/* dev_err(info->dev, "fts_writeCmd: attempt %d\n", retry); */
+	}
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_BUS_W);
+		return ERROR_BUS_W;
+	}
+	return OK;
+}
+
+/**
+  * Perform two bus write and one bus read without any stop condition
+  * In case of FTI this function is not supported and the same sequence
+  * can be achieved calling fts_write followed by an fts_writeRead.
+  * @param writeCmd1 byte array containing the first command to write
+  * @param writeCmdLength size of writeCmd1
+  * @param readCmd1 byte array containing the second command to write
+  * @param readCmdLength size of readCmd1
+  * @param outBuf pointer of a byte array which should contain the bytes read
+  * from the IC
+  * @param byteToRead number of bytes to read
+  * @return OK if success or an error code which specify the type of error
+  */
+static int fts_writeThenWriteRead_internal(struct fts_ts_info *info,
+					   u8 *writeCmd1, int writeCmdLength,
+					   u8 *readCmd1, int readCmdLength,
+					   u8 *outBuf, int byteToRead,
+					   bool dma_safe)
+{
+	int ret = -1;
+	int retry = 0;
+#ifdef I2C_INTERFACE
+	struct i2c_msg I2CMsg[3];
+#else
+	struct spi_message msg;
+	struct spi_transfer transfer[3] = { { 0 }, { 0 }, { 0 } };
+#endif
+
+	if (dma_safe == false && (writeCmdLength > sizeof(info->io_write_buf) ||
+	    readCmdLength > sizeof(info->io_extra_write_buf) ||
+	    byteToRead > sizeof(info->io_read_buf))) {
+		dev_err(info->dev, "%s: preallocated buffers are too small!\n", __func__);
+		return ERROR_ALLOC;
+	}
+
+	if (dma_safe == false) {
+		memcpy(info->io_write_buf, writeCmd1, writeCmdLength);
+		writeCmd1 = info->io_write_buf;
+		memcpy(info->io_extra_write_buf, readCmd1, readCmdLength);
+		readCmd1 = info->io_extra_write_buf;
+	}
+
+#ifdef I2C_INTERFACE
+	/* write msg */
+	I2CMsg[0].addr = (__u16)I2CSAD;
+	I2CMsg[0].flags = (__u16)0;
+	I2CMsg[0].len = (__u16)writeCmdLength;
+	I2CMsg[0].buf = (__u8 *)writeCmd1;
+
+	/* write msg */
+	I2CMsg[1].addr = (__u16)I2CSAD;
+	I2CMsg[1].flags = (__u16)0;
+	I2CMsg[1].len = (__u16)readCmdLength;
+	I2CMsg[1].buf = (__u8 *)readCmd1;
+
+	/* read msg */
+	I2CMsg[2].addr = (__u16)I2CSAD;
+	I2CMsg[2].flags = I2C_M_RD;
+	I2CMsg[2].len = byteToRead;
+	if (dma_safe == false)
+		I2CMsg[2].buf = (__u8 *)info->io_read_buf;
+	else
+		I2CMsg[2].buf = (__u8 *)outBuf;
+#else
+	spi_message_init(&msg);
+
+	transfer[0].len = writeCmdLength;
+	transfer[0].tx_buf = writeCmd1;
+	transfer[0].rx_buf = NULL;
+	spi_message_add_tail(&transfer[0], &msg);
+
+	transfer[1].len = readCmdLength;
+	transfer[1].tx_buf = readCmd1;
+	transfer[1].rx_buf = NULL;
+	spi_message_add_tail(&transfer[1], &msg);
+
+	transfer[2].len = byteToRead;
+	transfer[2].delay.value = SPI_DELAY_CS;
+	transfer[2].delay.unit = SPI_DELAY_UNIT_USECS;
+	transfer[2].tx_buf = NULL;
+	if (dma_safe == false)
+		transfer[2].rx_buf = info->io_read_buf;
+	else
+		transfer[2].rx_buf = outBuf;
+	spi_message_add_tail(&transfer[2], &msg);
+#endif
+
+	if (info->client == NULL)
+		return ERROR_BUS_O;
+	while (retry < I2C_RETRY && ret < OK) {
+#ifdef I2C_INTERFACE
+		ret = i2c_transfer(info->client->adapter, I2CMsg, 3);
+#else
+		ret = spi_sync(info->client, &msg);
+#endif
+		retry++;
+		if (ret < OK)
+			mdelay(I2C_WAIT_BEFORE_RETRY);
+	}
+
+	if (ret < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_BUS_WR);
+		return ERROR_BUS_WR;
+	}
+
+	if (dma_safe == false)
+		memcpy(outBuf, info->io_read_buf, byteToRead);
+
+	return OK;
+}
+
+/* Wrapper API for i2c read and write */
+int fts_read(struct fts_ts_info *info, u8 *outBuf, int byteToRead)
+{
+	int ret;
+	mutex_lock(&info->io_mutex);
+	ret = fts_read_internal(info, outBuf, byteToRead, false);
+	mutex_unlock(&info->io_mutex);
+	return ret;
+}
+
+int fts_read_heap(struct fts_ts_info *info, u8 *outBuf, int byteToRead)
+{
+	return fts_read_internal(info, outBuf, byteToRead, true);
+}
+
+int fts_writeRead(struct fts_ts_info *info, u8 *cmd, int cmdLength, u8 *outBuf,
+		  int byteToRead)
+{
+	int ret;
+	mutex_lock(&info->io_mutex);
+	ret = fts_writeRead_internal(info, cmd, cmdLength, outBuf, byteToRead,
+					false);
+	mutex_unlock(&info->io_mutex);
+	return ret;
+}
+
+int fts_writeRead_heap(struct fts_ts_info *info, u8 *cmd, int cmdLength,
+		       u8 *outBuf, int byteToRead)
+{
+	return fts_writeRead_internal(info, cmd, cmdLength, outBuf, byteToRead,
+				      true);
+}
+
+int fts_write(struct fts_ts_info *info, u8 *cmd, int cmdLength)
+{
+	int ret;
+	mutex_lock(&info->io_mutex);
+	ret = fts_write_internal(info, cmd, cmdLength, false);
+	mutex_unlock(&info->io_mutex);
+	return ret;
+}
+
+int fts_write_heap(struct fts_ts_info *info, u8 *cmd, int cmdLength)
+{
+	return fts_write_internal(info, cmd, cmdLength, true);
+}
+
+int fts_writeFwCmd(struct fts_ts_info *info, u8 *cmd, int cmdLength)
+{
+	int ret_write = 0;
+	int ret_echo = 0;
+	int retry = 0;
+
+	while (retry < I2C_RETRY) {
+		mutex_lock(&info->io_mutex);
+		ret_write = fts_write_internal(info, cmd, cmdLength, false);
+		mutex_unlock(&info->io_mutex);
+		retry++;
+		if (ret_write >= OK) {
+			ret_echo = checkEcho(info, cmd, cmdLength);
+			if (ret_echo >= OK)
+				break;
+		}
+		mdelay(I2C_WAIT_BEFORE_RETRY);
+	}
+	if (ret_write < OK) {
+		dev_err(info->dev, "fts_writeFwCmd: ERROR %08X\n", ERROR_BUS_W);
+		return ERROR_BUS_W;
+	} else if (ret_echo < OK) {
+		dev_err(info->dev, "fts_writeFwCmd: check echo ERROR %08X\n", ret_echo);
+		return ret_echo;
+	}
+
+	return OK;
+}
+
+int fts_writeFwCmd_heap(struct fts_ts_info *info, u8 *cmd, int cmdLength)
+{
+	int ret_write = 0;
+	int ret_echo = 0;
+	int retry = 0;
+
+	while (retry < I2C_RETRY) {
+		ret_write = fts_write_internal(info, cmd, cmdLength, true);
+		retry++;
+		if (ret_write >= OK) {
+			ret_echo = checkEcho(info, cmd, cmdLength);
+			if (ret_echo >= OK)
+				break;
+		}
+		mdelay(I2C_WAIT_BEFORE_RETRY);
+	}
+	if (ret_write < OK) {
+		dev_err(info->dev, "fts_writeFwCmd: ERROR %08X\n", ERROR_BUS_W);
+		return ERROR_BUS_W;
+	} else if (ret_echo < OK) {
+		dev_err(info->dev, "fts_writeFwCmd: check echo ERROR %08X\n", ret_echo);
+		return ret_echo;
+	}
+
+	return OK;
+}
+
+int fts_writeThenWriteRead(struct fts_ts_info *info, u8 *writeCmd1,
+			   int writeCmdLength, u8 *readCmd1, int readCmdLength,
+			   u8 *outBuf, int byteToRead)
+{
+	int ret;
+	mutex_lock(&info->io_mutex);
+	ret = fts_writeThenWriteRead_internal(info, writeCmd1, writeCmdLength,
+						readCmd1, readCmdLength,
+						outBuf, byteToRead, false);
+	mutex_unlock(&info->io_mutex);
+	return ret;
+}
+
+int fts_writeThenWriteRead_heap(struct fts_ts_info *info, u8 *writeCmd1,
+				int writeCmdLength, u8 *readCmd1,
+				int readCmdLength, u8 *outBuf, int byteToRead)
+{
+	return fts_writeThenWriteRead_internal(info, writeCmd1, writeCmdLength,
+						readCmd1, readCmdLength,
+						outBuf, byteToRead, true);
+}
+
+/**
+  * Perform a chunked write with one byte op code and 1 to 8 bytes address
+  * @param cmd byte containing the op code to write
+  * @param addrSize address size in byte
+  * @param address the starting address
+  * @param data pointer of a byte array which contain the bytes to write
+  * @param dataSize size of data
+  * @return OK if success or an error code which specify the type of error
+  */
+/* this function works only if the address is max 8 bytes */
+int fts_writeU8UX(struct fts_ts_info *info, u8 cmd, AddrSize addrSize,
+		  u64 address, u8 *data, int dataSize)
+{
+	u8 *finalCmd;
+	u8 *p;
+	int remaining = dataSize;
+	int toWrite = 0, i = 0;
+	int ret = 0;
+
+	if(addrSize > sizeof(u64)) {
+		dev_err(info->dev, "%s: address size bigger than max allowed %lu. ERROR %08X\n",
+			__func__, sizeof(u64), ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	mutex_lock(&info->io_mutex);
+
+	finalCmd = info->io_write_buf;
+
+	while (remaining > 0) {
+		if (remaining > WRITE_CHUNK)
+			toWrite = WRITE_CHUNK;
+		else
+			toWrite = remaining;
+
+		finalCmd[0] = cmd;
+		dev_dbg(info->dev, "%s: addrSize = %d, address = %llX\n",
+			__func__, addrSize, address);
+
+		p = (u8 *)&address + addrSize - 1;
+		for (i = 0; i < addrSize; i++)
+			finalCmd[i + 1] = *p--;
+		memcpy(&finalCmd[addrSize + 1], data, toWrite);
+
+		ret = fts_write_heap(info, finalCmd, 1 + addrSize + toWrite);
+		if (ret < OK) {
+			ret = ERROR_BUS_W;
+			break;
+		}
+
+		address += toWrite;
+		data += toWrite;
+		remaining -= toWrite;
+	}
+
+	mutex_unlock(&info->io_mutex);
+	if (ret < OK)
+		dev_err(info->dev, " %s: ERROR %08X\n", __func__, ret);
+
+	return ret;
+}
+
+/**
+  * Perform a chunked write read with one byte op code and 1 to 8 bytes address
+  * and dummy byte support.
+  * @param cmd byte containing the op code to write
+  * @param addrSize address size in byte
+  * @param address the starting address
+  * @param outBuf pointer of a byte array which contain the bytes to read
+  * @param byteToRead number of bytes to read
+  * @param bytes_to_skip if need to skip the first byte of each reading,
+  * set to 1,
+  *  otherwise if the first byte is valid set to 0.
+  * @return OK if success or an error code which specify the type of error
+  */
+int fts_writeReadU8UX(struct fts_ts_info *info, u8 cmd, AddrSize addrSize,
+		      u64 address, u8 *outBuf, int byteToRead,
+		      int bytes_to_skip)
+{
+	u8 *finalCmd;
+	u8 *buff;
+	u8 *p;
+	int remaining = byteToRead;
+	int toRead = 0, i = 0;
+	int ret = 0;
+
+	if(addrSize > sizeof(u64)) {
+		dev_err(info->dev, "%s: address size bigger than max allowed %lu. ERROR %08X\n",
+			__func__, sizeof(u64), ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	mutex_lock(&info->io_mutex);
+
+	finalCmd = info->io_write_buf;
+	buff = info->io_read_buf;
+
+	while (remaining > 0) {
+		if (remaining > READ_CHUNK)
+			toRead = READ_CHUNK;
+		else
+			toRead = remaining;
+
+		finalCmd[0] = cmd;
+		dev_dbg(info->dev, "%s: addrSize = %d, address = %llX\n",
+			__func__, addrSize, address);
+
+		p = (u8 *)&address + addrSize - 1;
+		for (i = 0; i < addrSize; i++)
+			finalCmd[i + 1] = *p--;
+
+		ret = fts_writeRead_heap(info, finalCmd, 1 + addrSize,
+					 buff, toRead + bytes_to_skip);
+		if (ret < OK) {
+			ret = ERROR_BUS_WR;
+			break;
+		}
+		memcpy(outBuf, buff + bytes_to_skip, toRead);
+
+		address += toRead;
+		outBuf += toRead;
+		remaining -= toRead;
+	}
+
+	mutex_unlock(&info->io_mutex);
+	if (ret < OK)
+		dev_err(info->dev, "%s: read error... ERROR %08X\n",
+			__func__, ret);
+
+	return ret;
+}
+
+/**
+  * Perform a chunked write followed by a second write with one byte op code
+  * for each write and 1 to 8 bytes address (the sum of the 2 address size of
+  * the two writes can not exceed 8 bytes)
+  * @param cmd1 byte containing the op code of first write
+  * @param addrSize1 address size in byte of first write
+  * @param cmd2 byte containing the op code of second write
+  * @param addrSize2 address size in byte of second write
+  * @param address the starting address
+  * @param data pointer of a byte array which contain the bytes to write
+  * @param dataSize size of data
+  * @return OK if success or an error code which specify the type of error
+  */
+/* this function works only if the sum of two addresses in the two commands is
+ * max 8 bytes */
+int fts_writeU8UXthenWriteU8UX(struct fts_ts_info *info, u8 cmd1,
+			       AddrSize addrSize1, u8 cmd2, AddrSize addrSize2,
+			       u64 address, u8 *data, int dataSize)
+{
+	u8 *finalCmd1;
+	u8 *finalCmd2;
+	u8 *p;
+	int remaining = dataSize;
+	int toWrite = 0, i = 0;
+	int ret = 0;
+
+	mutex_lock(&info->io_mutex);
+
+	finalCmd1 = info->io_write_buf;
+	finalCmd2 = info->io_extra_write_buf;
+
+	while (remaining > 0) {
+		if (remaining > WRITE_CHUNK)
+			toWrite = WRITE_CHUNK;
+		else
+			toWrite = remaining;
+
+		finalCmd1[0] = cmd1;
+		p = (u8 *)&address + addrSize1 + addrSize2 - 1;
+		for (i = 0; i < addrSize1; i++)
+			finalCmd1[i + 1] = *p--;
+
+		finalCmd2[0] = cmd2;
+		for (i = 0; i < addrSize2; i++)
+			finalCmd2[i + 1] = *p--;
+
+		memcpy(&finalCmd2[addrSize2 + 1], data, toWrite);
+
+		ret = fts_write_heap(info, finalCmd1, 1 + addrSize1);
+		if (ret < OK) {
+			ret = ERROR_BUS_W;
+			dev_err(info->dev, "%s: first write error. ERROR %08X\n",
+				__func__, ret);
+			break;
+		}
+
+		ret = fts_write_heap(info, finalCmd2, 1 + addrSize2 + toWrite);
+		if (ret < OK) {
+			ret = ERROR_BUS_W;
+			dev_err(info->dev, "%s: second write error. ERROR %08X\n",
+				__func__, ret);
+			break;
+		}
+
+		address += toWrite;
+		data += toWrite;
+		remaining -= toWrite;
+	}
+
+	mutex_unlock(&info->io_mutex);
+
+	return ret;
+}
+
+/**
+  * Perform a chunked write  followed by a write read with one byte op code
+  * and 1 to 8 bytes address for each write and dummy byte support.
+  * @param cmd1 byte containing the op code of first write
+  * @param addrSize1 address size in byte of first write
+  * @param cmd2 byte containing the op code of second write read
+  * @param addrSize2 address size in byte of second write read
+  * @param address the starting address
+  * @param outBuf pointer of a byte array which contain the bytes to read
+  * @param byteToRead number of bytes to read
+  * @param bytes_to_skip if need to skip the first byte of each reading,
+  * set to 1,
+  *  otherwise if the first byte is valid set to 0.
+  * @return OK if success or an error code which specify the type of error
+  */
+/* this function works only if the sum of two addresses in the two commands is
+ * max 8 bytes */
+int fts_writeU8UXthenWriteReadU8UX(struct fts_ts_info *info, u8 cmd1,
+				   AddrSize addrSize1, u8 cmd2,
+				   AddrSize addrSize2, u64 address, u8 *outBuf,
+				   int byteToRead, int bytes_to_skip)
+{
+	u8 *finalCmd1;
+	u8 *finalCmd2;
+	u8 *buff;
+	u8 *p;
+	int remaining = byteToRead;
+	int toRead = 0, i = 0;
+	int ret = 0;
+
+	mutex_lock(&info->io_mutex);
+	finalCmd1 = info->io_write_buf;
+	finalCmd2 = info->io_extra_write_buf;
+	buff = info->io_read_buf;
+
+	while (remaining > 0) {
+		if (remaining > READ_CHUNK)
+			toRead = READ_CHUNK;
+		else
+			toRead = remaining;
+
+		finalCmd1[0] = cmd1;
+		p = (u8 *)&address + addrSize1 + addrSize2 - 1;
+		for (i = 0; i < addrSize1; i++)
+			finalCmd1[i + 1] = *p--;
+
+		finalCmd2[0] = cmd2;
+		for (i = 0; i < addrSize2; i++)
+			finalCmd2[i + 1] = *p--;
+
+		ret = fts_write_heap(info, finalCmd1, 1 + addrSize1);
+		if (ret < OK) {
+			ret = ERROR_BUS_W;
+			dev_err(info->dev, "%s: first write error. ERROR %08X\n",
+				__func__, ret);
+			break;
+		}
+
+		ret = fts_writeRead_heap(info, finalCmd2, 1 + addrSize2,
+					      buff, toRead + bytes_to_skip);
+		if (ret < OK) {
+			ret = ERROR_BUS_WR;
+			dev_err(info->dev, "%s: read error. ERROR %08X\n",
+					__func__, ret);
+			break;
+		}
+		memcpy(outBuf, buff + bytes_to_skip, toRead);
+
+		address += toRead;
+		outBuf += toRead;
+		remaining -= toRead;
+	}
+
+	mutex_unlock(&info->io_mutex);
+
+	return ret;
+}
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("STMicroelectronics MultiTouch IC Driver");
+MODULE_AUTHOR("STMicroelectronics");
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsIO.h b/drivers/input/touchscreen/stfts/google/fts_lib/ftsIO.h
new file mode 100644
index 000000000000..f9f08a02afbd
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsIO.h
@@ -0,0 +1,78 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				**
+  **************************************************************************
+  **                        marco.cali@st.com				**
+  **************************************************************************
+  *                                                                        *
+  *                     I2C/SPI Communication				*
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+/*!
+  * \file ftsIO.h
+  * \brief Contains all the definitions and prototypes used and implemented in
+  * ftsIO.c
+  */
+
+#ifndef FTS_IO_H
+#define FTS_IO_H
+
+#include "ftsSoftware.h"
+
+#define I2C_RETRY		3	/* /< number of retry in case of i2c
+					 * failure */
+#define I2C_WAIT_BEFORE_RETRY	2	/* /< wait in ms before retry an i2c
+					 * transaction */
+
+#ifdef I2C_INTERFACE
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#else
+#include <linux/spi/spi.h>
+#endif
+
+
+int openChannel(void *clt);
+
+
+/*************** NEW I2C API ****************/
+#ifdef I2C_INTERFACE
+int changeSAD(u8 sad);
+#endif
+int fts_read(struct fts_ts_info *info, u8 *outBuf, int byteToRead);
+int fts_read_heap(struct fts_ts_info *info, u8 *outBuf, int byteToRead);
+int fts_writeRead(struct fts_ts_info *info, u8 *cmd, int cmdLength, u8 *outBuf,
+		  int byteToRead);
+int fts_writeRead_heap(struct fts_ts_info *info, u8 *cmd, int cmdLength,
+		       u8 *outBuf, int byteToRead);
+int fts_write(struct fts_ts_info *info, u8 *cmd, int cmdLength);
+int fts_write_heap(struct fts_ts_info *info, u8 *cmd, int cmdLength);
+int fts_writeFwCmd(struct fts_ts_info *info, u8 *cmd, int cmdLength);
+int fts_writeFwCmd_heap(struct fts_ts_info *info, u8 *cmd, int cmdLength);
+int fts_writeThenWriteRead(struct fts_ts_info *info, u8 *writeCmd1,
+			   int writeCmdLength, u8 *readCmd1, int readCmdLength,
+			   u8 *outBuf, int byteToRead);
+int fts_writeThenWriteRead_heap(struct fts_ts_info *info, u8 *writeCmd1,
+				int writeCmdLength, u8 *readCmd1,
+				int readCmdLength, u8 *outBuf, int byteToRead);
+
+/* chunked version of fts_write */
+int fts_writeU8UX(struct fts_ts_info *info, u8 cmd, AddrSize addrSize,
+		  u64 address, u8 *data, int dataSize);
+/* chunked version of fts_writeRead */
+int fts_writeReadU8UX(struct fts_ts_info *info, u8 cmd, AddrSize addrSize, u64 address, u8 *outBuf,
+			int byteToRead, int bytes_to_skip);
+/* chunked, write followed by another write */
+int fts_writeU8UXthenWriteU8UX(struct fts_ts_info *info, u8 cmd1, AddrSize addrSize1, u8 cmd2,
+			       AddrSize addrSize2, u64 address, u8 *data,
+			       int dataSize);
+/* chunked, write followed by a writeRead */
+int fts_writeU8UXthenWriteReadU8UX(struct fts_ts_info *info, u8 cmd1,
+				   AddrSize addrSize1, u8 cmd2,
+				   AddrSize addrSize2, u64 address, u8 *outBuf,
+				   int count, int bytes_to_skip);
+#endif
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsSoftware.h b/drivers/input/touchscreen/stfts/google/fts_lib/ftsSoftware.h
new file mode 100644
index 000000000000..09883759cd02
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsSoftware.h
@@ -0,0 +1,568 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				 **
+  **************************************************************************
+  **                        marco.cali@st.com				 **
+  **************************************************************************
+  *                                                                        *
+  *	FW related data							*
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsSoftware.h
+  * \brief Contains all the definitions and information related to the IC
+  * from a fw/driver point of view
+  */
+
+
+#ifndef FTS_SOFTWARE_H
+#define FTS_SOFTWARE_H
+#include <linux/types.h>
+#include "ftsHardware.h"
+#define I2C_INTERFACE       1
+/* signed type */
+typedef signed char i8;	/* /< basic type that represent one signed byte (or 8
+			 * bits) */
+
+/**
+  *	Enumerator which contains all the possible address length expressed in
+  *bytes.
+  */
+typedef enum {
+	NO_ADDR = 0,
+	BITS_8	= 1,
+	BITS_16 = 2,
+	BITS_24 = 3,
+	BITS_32 = 4,
+	BITS_40 = 5,
+	BITS_48 = 6,
+	BITS_56 = 7,
+	BITS_64 = 8
+} AddrSize;
+
+/**
+ * Enumerator which define the keep_cx meaning
+ */
+enum {
+	CX_ERASE,
+	CX_KEEP,
+	CX_CHECK_AFE_VER
+};
+
+/********************  NEW API  *********************/
+
+/* HOST COMMAND */
+/** @defgroup host_command Fw Host op codes
+  * Valid op codes for fw commands
+  * @{
+  */
+
+/** @defgroup scan_mode	Scan Mode
+  * @ingroup host_command
+  * Set the scanning mode required according to the parameters
+  * @{
+  */
+#define FTS_CMD_SCAN_MODE	0xA0	/* /< OP Code to set scan mode */
+/** @} */
+
+/** @defgroup feat_sel	 Feature Select
+  * @ingroup host_command
+  * Set the system defined features to enable/disable according the parameters
+  * @{
+  */
+#define FTS_CMD_FEATURE		0xA2	/* /< OP code to set features */
+/** @} */
+
+/** @defgroup sys_cmd  System Command
+  * @ingroup host_command
+  * Execute a system command to perform core tasks
+  * @{
+  */
+#define FTS_CMD_SYSTEM		0xA4	/* /< OP code to write s system command
+					 * */
+/** @} */
+
+/** @} */	/* end host_command group */
+
+/* SCAN MODE OPTION (0xA0) */
+/* Scan mode selection */
+/** @defgroup scan_opt	 Scan Mode Option
+  * @ingroup scan_mode
+  * Valid scanning modes and their options
+  * @{
+  */
+#define SCAN_MODE_ACTIVE	0x00	/* /< Select the Active scanning mode */
+#define SCAN_MODE_LOW_POWER	0x01	/* /< Select the low power scanning mode
+					 * */
+#define SCAN_MODE_JIG_1		0x02	/* /< Select the Jig test 1 */
+#define SCAN_MODE_LOCKED	0x03	/* /< Select the Scan mode which will be
+					 * locked */
+/** @}*/
+
+/* Active mode option (bitmask) */
+/** @defgroup active_bitmask Active Mode Bitmask
+  * @ingroup scan_opt
+  * Bitmask to use to enables the specific scanning with the SCAN_MODE_ACTIVE
+  * option
+  * @{
+  */
+#define ACTIVE_MULTI_TOUCH	0x01	/* /< Bit 0 MS/SS scan */
+#define ACTIVE_KEY		0x02	/* /< Bit 1 Key scan */
+#define ACTIVE_HOVER		0x04	/* /< Bit 2 Hover scan */
+#define ACTIVE_PROXIMITY	0x08	/* /< Bit 3 Proximity scan */
+#define ACTIVE_FORCE		0x10	/* /< Bit 4 Force scan */
+/** @}*/
+
+/* Locked mode option (locked mode) */
+/** @defgroup locked_opt Locked Mode Option
+  * @ingroup scan_opt
+  * Options to enable and lock specific scanning with the SCAN_MODE_LOCKED
+  * option
+  * @{
+  */
+#define LOCKED_ACTIVE		0x00	/* /< Active Scan Mode */
+#define LOCKED_HOVER		0x01	/* /< Hover Scan Mode */
+#define LOCKED_IDLE		0x02	/* /< Idle Scan Mode */
+#define LOCKED_ONLY_SELF	0x03	/* /< Only Self Sense scan mode */
+#define LOCKED_ONLY_MUTUAL_0	0x04	/* /< Only Mutual Sense scan mode at
+					 * lowest freq */
+#define LOCKED_ONLY_MUTUAL_1	0x05	/* /< Only Mutual Sense scan mode */
+#define LOCKED_ONLY_MUTUAL_2	0x06	/* /< Only Mutual Sense scan mode */
+#define LOCKED_ONLY_MUTUAL_3	0x07	/* /< Only Mutual Sense scan mode at
+					 * highest freq */
+#define LOCKED_SINGLE_ENDED_ONLY_MUTUAL_0	0x20	/* /< Only Mutual Sense
+							 * scan mode at lowest
+							 * freq in single ended
+							 * mode
+							 */
+#define LOCKED_LP_DETECT	0x10	/* /< Low Power SS */
+#define LOCKED_LP_ACTIVE	0x11	/* /< Low Power MS */
+/** @}*/
+
+/* FEATURE SELECT OPTION (0xA2) */
+/* Feature Selection */
+/** @defgroup feat_opt	 Feature Selection Option
+  * @ingroup feat_sel
+  * System defined features that can be enable/disable
+  * @{
+  */
+#define FEAT_SEL_GLOVE		0x00	/* /< Glove Mode */
+#define FEAT_SEL_COVER		0x01	/* /< Cover Mode */
+#define FEAT_SEL_CHARGER	0x02	/* /< Charger Mode */
+#define FEAT_SEL_GESTURE	0x03	/* /< Gesture Mode */
+#define FEAT_SEL_GRIP		0x04	/* /< Grip Detection */
+#define FEAT_SEL_STYLUS		0x07	/* /< Stylus Mode
+					 * (this is a driver define, not
+					 * available in FW) */
+/** @}*/
+
+/* Feature Settings */
+#define FEAT_ENABLE		1	/* /< General value to enable a feature
+					 * */
+#define FEAT_DISABLE		0	/* /< General value to disable a feature
+					 * */
+
+
+/* Charger */
+/** @defgroup charger_opt	 Charger Mode Option
+  * @ingroup feat_sel
+  * Option for Charger Mode, it is a bitmask where the each bit indicate a
+  * different kind of chager
+  * @{
+  */
+#define CHARGER_CABLE	0x01	/* /< normal usb charger */
+#define CHARGER_WIRLESS 0x02	/* /< wireless charger */
+/** @}*/
+
+/* Gestures */
+/** @defgroup gesture_opt	 Gesture Mode Option
+  * @ingroup feat_sel
+  * Gesture IDs of the predefined gesture recognized by the fw.
+  * The ID represent also the position of the corresponding bit in the gesture
+  * mask
+  * @{
+  */
+#define GEST_ID_UP_1F		0x01	/* /< Bottom to Top line */
+#define GEST_ID_DOWN_1F		0x02	/* /< Top to bottom line */
+#define GEST_ID_LEFT_1F		0x03	/* /< Right to left line */
+#define GEST_ID_RIGHT_1F	0x04	/* /< Left to right line */
+#define GEST_ID_DBLTAP		0x05	/* /< Double Tap */
+#define GEST_ID_O		0x06	/* /< 'O' */
+#define GEST_ID_C		0x07	/* /< 'C' */
+#define GEST_ID_M		0x08	/* /< 'M' */
+#define GEST_ID_W		0x09	/* /< 'W' */
+#define GEST_ID_E		0x0A	/* /< 'e' */
+#define GEST_ID_L		0x0B	/* /< 'L' */
+#define GEST_ID_F		0x0C	/* /< 'F' */
+#define GEST_ID_V		0x0D	/* /< 'V' */
+#define GEST_ID_AT		0x0E	/* /< '@' */
+#define GEST_ID_S		0x0F	/* /< 'S' */
+#define GEST_ID_Z		0x10	/* /< 'Z' */
+#define GEST_ID_LEFTBRACE	0x11	/* /< '<' */
+#define GEST_ID_RIGHTBRACE	0x12	/* /< '>' */
+#define GEST_ID_CARET		0x13	/* /< '^' */
+/** @}*/
+
+/* WRYTE SYSTEM COMMAND (0xA4) */
+/* System command */
+/** @defgroup sys_opt	 System Command Option
+  * @ingroup sys_cmd
+  * Valid System Command Parameters
+  * @{
+  */
+#define SYS_CMD_SPECIAL		0x00	/* /< Special Commands */
+#define SYS_CMD_INT		0x01	/* /< FW Interrupt Control */
+#define SYS_CMD_FORCE_CAL	0x02	/* /< Force Calibration */
+#define SYS_CMD_CX_TUNING	0x03	/* /< CX initialization */
+#define SYS_CMD_ITO		0x04	/* /< ITO test */
+#define SYS_CMD_SAVE_FLASH	0x05	/* /< Saving to flash */
+#define SYS_CMD_LOAD_DATA	0x06	/* /< Load Host data memory */
+#define SYS_CMD_SPECIAL_TUNING	0x08	/* /< Perform some special tuning */
+#define SYS_CMD_MP_FLAG		0x0C	/* /< Update value of MP flag in RAM */
+/** @} */
+
+/* System command settings */
+/* Special commands */
+/** @defgroup sys_special_opt	 Special Command Option
+  * @ingroup sys_cmd
+  * Valid special command
+  * @{
+  */
+#define SPECIAL_SYS_RESET		0x00	/* /< System Reset triggered by
+						 * the FW */
+#define SPECIAL_FIFO_FLUSH		0x01	/* /< Flush of the FIFO */
+#define SPECIAL_PANEL_INIT		0x02	/* /< Panel Initialization */
+#define SPECIAL_FULL_PANEL_INIT		0x03	/* /< Full panel initialization
+						 * */
+#define SPECIAL_WRITE_HOST_MEM_TO_FLASH 0x04	/* /< Write */
+/** @} */
+
+
+/* Force Cal and Cx auto tuning */
+/** @defgroup forcecal_cx_opt	 Force Cal and Tuning Option
+  * @ingroup sys_cmd
+  * Valid bitmask for triggering forcecal or performing manual autotune
+  * @{
+  */
+#define CAL_MS_TOUCH		0x01	/* /< Mutual Sense Touch */
+#define CAL_MS_LOW_POWER	0x02	/* /< Mutual Sense Touch in low power
+					 * mode */
+#define CAL_SS_TOUCH		0x04	/* /< Self Sense Touch */
+#define CAL_SS_IDLE		0x08	/* /< Self Sense Touch in idle mode */
+#define CAL_MS_KEY		0x10	/* /< Mutual Sense Key */
+#define CAL_SS_KEY		0x20	/* /< Self Sense Key */
+#define CAL_MS_FORCE		0x40	/* /< Mutual Sense Force */
+#define CAL_SS_FORCE		0x80	/* /< Self Sense Force */
+/** @} */
+
+/* ITO checks (position of the bit in the mask) */
+/** @defgroup ito_opt	 ITO Test Option
+  * @ingroup sys_cmd
+  * Valid option for the ITO test
+  * @{
+  */
+#define ITO_FORCE_OPEN		0x00	/* /< Check if some force channels is
+					 * open */
+#define ITO_SENSE_OPEN		0x01	/* /< Check if some sense channels is
+					 * open */
+#define ITO_FORCE_GROUND	0x02	/* /< Check if some force channels is
+					 * short to ground */
+#define ITO_SENSE_GROUND	0x03	/* /< Check if some sense channels is
+					 * short to ground */
+#define ITO_FORCE_VDD		0x04	/* /< Check if some force channels is
+					 * short to VDD */
+#define ITO_SENSE_VDD		0x05	/* /< Check if some sense channels is
+					 * short to VDD */
+#define ITO_FORCE_FORCE		0x06	/* /< Check force to force channels */
+#define ITO_FORCE_SENSE		0x07	/* /< Check force to sense channels */
+#define ITO_SENSE_SENSE		0x08	/* /< Check sense to sense channels */
+#define ITO_KEY_FORCE_OPEN	0x09	/* /< Check if some force channels used
+					 * for the key is open */
+#define ITO_KEY_SENSE_OPEN	0x0A	/* /< Check if some sense channels used
+					 * for the key is open */
+/** @}*/
+
+/* Save flash */
+/** @defgroup save_opt	 Save to Flash Option
+  * @ingroup sys_cmd
+  * Valid option for saving data to the Flash
+  * @{
+  */
+#define SAVE_FW_CONF	0x01	/* /< Save the confing to the flash */
+#define SAVE_CX		0x02	/* /< Save the CX to the flash */
+#define SAVE_PANEL_CONF 0x04	/* /< Save the Panel configuration to the flash
+				 * */
+/** @}*/
+
+/* Load Data */
+/** @defgroup load_opt	 Load Host Data Option
+  * @ingroup sys_cmd
+  * Valid option to ask to the FW to load host data into the memory
+  * @{
+  */
+#define LOAD_SYS_INFO			0x01	/* /< Load System Info */
+#define LOAD_CX_MS_TOUCH		0x10	/* /< Load MS Init Data for
+						 * Active Mode */
+#define LOAD_CX_MS_LOW_POWER		0x11	/* /< Load MS Init Data for Low
+						 * Power Mode */
+#define LOAD_CX_SS_TOUCH		0x12	/* /< Load SS Init Data for
+						 * Active Mode */
+#define LOAD_CX_SS_TOUCH_IDLE		0x13	/* /< Load SS Init Data for Low
+						 * Power Mode */
+#define LOAD_CX_MS_KEY			0x14	/* /< Load MS Init Data for Key
+						 * */
+#define LOAD_CX_SS_KEY			0x15	/* /< Load SS Init Data for Key
+						 * */
+#define LOAD_CX_MS_FORCE		0x16	/* /< Load MS Init Data for
+						 * Force */
+#define LOAD_CX_SS_FORCE		0x17	/* /< Load SS Init Data for
+						 * Force */
+#define LOAD_SYNC_FRAME_RAW		0x30	/* /< Load a Synchronized Raw
+						 * Frame */
+#define LOAD_SYNC_FRAME_FILTER		0x31	/* /< Load a Synchronized Filter
+						 * Frame */
+#define LOAD_SYNC_FRAME_STRENGTH	0x33	/* /< Load a Synchronized
+						 * Strength Frame */
+#define LOAD_SYNC_FRAME_BASELINE	0x32	/* /< Load a Synchronized
+						 * Baseline Frame */
+#define LOAD_PANEL_CX_TOT_MS_TOUCH	0x50	/* /< Load TOT MS Init Data for
+						 * Active Mode */
+#define LOAD_PANEL_CX_TOT_MS_LOW_POWER	0x51	/* /< Load TOT MS Init Data for
+						 * Low Power Mode */
+#define LOAD_PANEL_CX_TOT_SS_TOUCH	0x52	/* /< Load TOT SS Init Data for
+						 * Active Mode */
+#define LOAD_PANEL_CX_TOT_SS_TOUCH_IDLE 0x53	/* /< Load TOT SS Init Data for
+						 * Low Power Mode */
+#define LOAD_PANEL_CX_TOT_MS_KEY	0x54	/* /< Load TOT MS Init Data for
+						 * Key */
+#define LOAD_PANEL_CX_TOT_SS_KEY	0x55	/* /< Load TOT SS Init Data for
+						 * Key */
+#define LOAD_PANEL_CX_TOT_MS_FORCE	0x56	/* /< Load TOT MS Init Data for
+						 * Force */
+#define LOAD_PANEL_CX_TOT_SS_FORCE	0x57	/* /< Load TOT SS Init Data for
+						 * Force */
+#define LOAD_SENS_CAL_COEFF		0xC0	/* /< Load Sesitivity
+						 * Calibration Coefficients */
+#define LOAD_DEBUG_INFO 		0xC3	/* /< Load Sesitivity
+						 * Calibration Coefficients */
+#define LOAD_GOLDEN_MUTUAL_RAW  	0x80	/* /< Load Goden Mutual Raw Data */
+
+/* Debug information. */
+#define DEBUG_INFO_LP_DETECT		0x05	/* Low power detect scan mode. */
+#define DEBUG_INFO_LP_ACTIVE		0x06	/* Low power active scan mode. */
+
+/** @}*/
+
+/* Special Tuning */
+/** @defgroup spcl_tun_opt	 Special Tuning Option
+  * @ingroup sys_cmd
+  * Valid special tuning operations which the fw can perform (bitmask)
+  * @{
+  */
+#define SPECIAL_TUNING_LP_TIMER 0x01	/* /< Perform LP Timer calibration */
+#define SPECIAL_TUNING_IOFF	0x02	/* /< Perform Ioff calibration */
+
+/** @}*/
+
+/* EVENT ID */
+/** @defgroup events_group	 FW Event IDs and Types
+  * Event IDs and Types pushed by the FW into the FIFO
+  * @{
+  */
+#define EVT_ID_NOEVENT		0x00	/* /< No Events */
+#define EVT_ID_CONTROLLER_READY 0x03	/* /< Controller ready, issued after a
+					 * system reset. */
+#define EVT_ID_ENTER_POINT	0x13	/* /< Touch enter in the sensing area */
+#define EVT_ID_MOTION_POINT	0x23	/* /< Touch motion (a specific touch
+					 * changed position) */
+#define EVT_ID_LEAVE_POINT	0x33	/* /< Touch leave the sensing area */
+#define EVT_ID_STATUS_UPDATE	0x43	/* /< FW report a system condition
+					 * change */
+#define EVT_ID_USER_REPORT	0x53	/* /< User related events triggered
+					 * (keys, gestures, proximity etc) */
+#define EVT_ID_DEBUG		0xE3	/* /< Debug Info */
+#define EVT_ID_ERROR		0xF3	/* /< Error Event */
+
+/* /< Max number of unique event IDs supported */
+#define NUM_EVT_ID		(((EVT_ID_ERROR & 0xF0) >> 4) + 1)
+
+/** @}*/
+
+/* STATUS TYPE */
+/** @defgroup status_type	 Status Event Types
+  * @ingroup events_group
+  * Types of EVT_ID_STATUS_UPDATE events
+  * @{
+  */
+#define EVT_TYPE_STATUS_ECHO		0x01	/* /< Echo event,
+						 * contain the first 5 bytes of
+						 * the FW command sent */
+#define EVT_TYPE_STATUS_GPIO_CHAR_DET	0x02	/*/< Gpio Charger detected */
+#define EVT_TYPE_STATUS_FRAME_DROP	0x03	/* /< Some frame was skipped
+						 * during the elaboration */
+#define EVT_TYPE_STATUS_FORCE_CAL	0x05	/* /< Force Calibration has
+						 * triggered */
+#define EVT_TYPE_STATUS_WATER		0x06	/* /< Water Mode */
+#define EVT_TYPE_STATUS_SS_RAW_SAT	0x07	/* /< Self Sense data saturated */
+#define EVT_TYPE_STATUS_PRE_WAT_DET	0x08	/* /< Previous Water Detect* */
+#define EVT_TYPE_STATUS_NOISE		0x09	/* /< Noise Status* */
+#define EVT_TYPE_STATUS_STIMPAD		0x0A	/* /< Stimpad Status* */
+#define EVT_TYPE_STATUS_NO_TOUCH	0x0B	/* /< No Touch Status* */
+#define EVT_TYPE_STATUS_IDLE		0x0C	/* /< Idle Status* */
+#define EVT_TYPE_STATUS_PALM_TOUCH	0x0D	/* /< Palm Touch Status* */
+#define EVT_TYPE_STATUS_GRIP_TOUCH	0x0E	/* /< Grip Touch Status* */
+#define EVT_TYPE_STATUS_GOLDEN_RAW_VAL	0x0F	/* /< Golden Raw
+						 * Validation Status */
+#define EVT_TYPE_STATUS_GOLDEN_RAW_ERR	0x16	/* /< Golden Raw
+						 * Data Abnormal */
+
+/** @} */
+
+/* USER TYPE */
+/** @defgroup user_type	 User Event Types
+  * @ingroup events_group
+  * Types of EVT_ID_USER_REPORT events generated by thw FW
+  * @{
+  */
+#define EVT_TYPE_USER_KEY	0x00	/* /< Keys pressed/relesed event report
+					 * */
+#define EVT_TYPE_USER_PROXIMITY 0x01	/* /< Proximity detection event report
+					 * */
+#define EVT_TYPE_USER_GESTURE	0x02	/* /< Gesture detection event report */
+/** @}*/
+
+/* ERROR TYPE */
+/** @defgroup error_type  Error Event Types
+  * @ingroup events_group
+  * Types of EVT_ID_ERROR events reported by the FW
+  * @{
+  */
+#define EVT_TYPE_ERROR_HARD_FAULT	0x02	/* /< Hard Fault */
+#define EVT_TYPE_ERROR_WATCHDOG		0x06	/* /< Watchdog timer expired */
+
+#define EVT_TYPE_ERROR_CRC_CFG_HEAD	0x20	/* /< CRC error in the Config
+						 * Area Header */
+#define EVT_TYPE_ERROR_CRC_CFG		0x21	/* /< CRC error in the Config
+						 * Area */
+#define EVT_TYPE_ERROR_CRC_PANEL_HEAD	0x22	/* /< CRC error in the Panel
+						 * Area Header */
+#define EVT_TYPE_ERROR_CRC_PANEL	0x23	/* /< CRC error in the Panel
+						 * Area */
+
+#define EVT_TYPE_ERROR_ITO_FORCETOGND	0x60	/* /< Force channel/s short to
+						 * ground */
+#define EVT_TYPE_ERROR_ITO_SENSETOGND	0x61	/* /< Sense channel/s short to
+						 * ground */
+#define EVT_TYPE_ERROR_ITO_FORCETOVDD	0x62	/* /< Force channel/s short to
+						 * VDD */
+#define EVT_TYPE_ERROR_ITO_SENSETOVDD	0x63	/* /< Sense channel/s short to
+						 * VDD */
+#define EVT_TYPE_ERROR_ITO_FORCE_P2P	0x64	/* /< Pin to Pin short Force
+						 * channel/s */
+#define EVT_TYPE_ERROR_ITO_SENSE_P2P	0x65	/* /< Pin to Pin short Sense
+						 * channel/s */
+#define EVT_TYPE_ERROR_ITO_FORCEOPEN	0x66	/* /< Force Panel open */
+#define EVT_TYPE_ERROR_ITO_SENSEOPEN	0x67	/* /< Sense Panel open */
+#define EVT_TYPE_ERROR_ITO_KEYOPEN	0x68	/* /< Key open */
+
+#define EVT_TYPE_ERROR_CRC_CX_HEAD	0xA0	/* /< CRC error in the CX Area
+						 * Header */
+#define EVT_TYPE_ERROR_CRC_CX		0xA1	/* /< CRC error in the CX Area
+						 * */
+#define EVT_TYPE_ERROR_FLASH_FAILED	0xA4	/* Flash error, cause unknown */
+#define EVT_TYPE_ERROR_CRC_CX_SUB_HEAD	0xA5	/* /< CRC error in the CX
+						 * Subsection Area Header */
+#define EVT_TYPE_ERROR_CRC_CX_SUB	0xA6	/* /< CRC error in the CX
+						 * Subsection Area */
+
+#define EVT_TYPE_ERROR_ESD		0xF0	/* /< ESD error */
+
+#define EVT_TYPE_ERROR_OSC_TRIM		0x24	/* /< OSC Trim error */
+#define EVT_TYPE_ERROR_AOFFSET_TRIM	0x29	/* /< Aoffset Trim error */
+/** @}*/
+
+
+/** @defgroup address Chip Address
+  * Collection of HW and SW Addresses useful to collect different kind of data
+  * @{
+  */
+
+/** @defgroup config_adr SW Address
+  * @ingroup address
+  * Important addresses of data stored into Config memory (and sometimes their
+  * dimensions)
+  * @{
+  */
+#define ADDR_CONFIG_ID		0x0010	/* /< Starting Address of the config ID
+					 * */
+#define CONFIG_ID_BYTE		2	/* /< Number of bytes of config ID */
+#define ADDR_CONFIG_SENSE_LEN	0x0030	/* /< Address where is stored the number
+					 * of sense channels */
+#define ADDR_CONFIG_FORCE_LEN	0x0031	/* /< Address where is stored the number
+					 * of force channels */
+#define ADDR_CONFIG_AUTOCAL	0x0040	/* /< Address where is stored the Auto
+					 * Calibration register */
+#define ADDR_CONFIG_T_CYCLE	0x00ED	/* /< Address where is stored the MS T
+					 * cycle */
+#define ADDR_CONFIG_MNM		0x01F0	/* /< Address where is stored the MNM
+					 * register */
+#define ADDR_CONFIG_MRN		0x01F1	/* /< Address where is stored the MRN
+					 * register */
+#define ADDR_CONFIG_R0_CYCLE	0x01F2	/* /< Address where is stored the first
+					 * R cycle */
+/** @}*/
+
+/** @}*/
+
+/* @defgroup mp_flags MP Flags value
+ * @ingroup mp_test
+ * Specify the MP flags value which are written into the flash after performing
+ * a full panel initialization which pass all the tests.
+ * @{
+ */
+#define MP_FLAG_UNSET		0x00	/* /< Original value when a panel module
+					 * just got built. */
+#define MP_FLAG_FACTORY		0xA5	/* /< Full Panel Init done in factory */
+#define MP_FLAG_BOOT		0x5A	/* /< Full Panel Init done at boot */
+#define MP_FLAG_OTHERS		0xFF	/* /< Full Panel Init done somewhere else */
+#define MP_FLAG_NEED_FPI	0xDF	/* /< Manual firmware update with keep_cx=0
+					 * and Full Panel Init is not executed yet */
+#define MP_FLAG_CX_AFE_CHG	0xCF	/* /< Need to do Full Panel Init when cx_afe
+					 * version change during auto firmware update. */
+/** @}*/
+
+/** @}*/
+
+/* ERROR INFO */
+#define ERROR_DUMP_ROW_SIZE	32	/* /< number of rows of the error memory
+					 * */
+#define ERROR_DUMP_COL_SIZE	4	/* /< number of bytes for each row of
+					 * the error memory */
+#define ERROR_DUMP_SIGNATURE	0xFA5005AF	/* /< first row signature of a
+						 * proper dump */
+
+/* Touch Types */
+#define TOUCH_TYPE_INVALID	0x00	/* /< Invalid touch type */
+#define TOUCH_TYPE_FINGER	0x01	/* /< Finger touch */
+#define TOUCH_TYPE_GLOVE	0x02	/* /< Glove touch */
+#define TOUCH_TYPE_STYLUS	0x03	/* /< Stylus touch */
+#define TOUCH_TYPE_PALM		0x04	/* /< Palm touch */
+#define TOUCH_TYPE_HOVER	0x00	/* /< Hovering touch */
+#define TOUCH_TYPE_GRIP		0x07	/* /< Hovering touch */
+
+/* Keys code */
+#define FTS_KEY_0		0x01	/* /< Key 0 bit */
+#define FTS_KEY_1		0x02	/* /< Key 1 bit */
+#define FTS_KEY_2		0x04	/* /< Key 2 bit */
+#define FTS_KEY_3		0x08	/* /< Key 3 bit */
+#define FTS_KEY_4		0x10	/* /< Key 4 bit */
+#define FTS_KEY_5		0x20	/* /< Key 5 bit */
+#define FTS_KEY_6		0x40	/* /< Key 6 bit */
+#define FTS_KEY_7		0x80	/* /< Key 7 bit */
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsTest.c b/drivers/input/touchscreen/stfts/google/fts_lib/ftsTest.c
new file mode 100644
index 000000000000..c887f47d923e
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsTest.c
@@ -0,0 +1,7858 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				 **
+  **************************************************************************
+  **                        marco.cali@st.com				  **
+  **************************************************************************
+  *                                                                        *
+  *			FTS API for MP test				*
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsTest.c
+  * \brief Contains all the functions related to the Mass Production Test
+  */
+
+#include "ftsCompensation.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsFrame.h"
+#include "ftsHardware.h"
+#include "ftsIO.h"
+#include "ftsSoftware.h"
+#include "ftsTest.h"
+#include "ftsTime.h"
+#include "ftsTool.h"
+#include "../fts.h"
+
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/serio.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/firmware.h>
+
+
+#ifdef LIMITS_H_FILE
+#include "../fts_limits.h"
+#endif
+
+
+/**
+  * Initialize the testToDo variable with the default tests to perform during
+  * the Mass Production Test
+  * @return OK
+  */
+int initTestToDo(struct fts_ts_info *info)
+{
+	TestToDo tests;
+	/*** Initialize Limit File ***/
+	info->limit_file.size = 0;
+	info->limit_file.data = NULL;
+	strscpy(info->limit_file.name, " ", sizeof(info->limit_file.name));
+
+#ifndef COMPUTE_INIT_METHOD
+	tests.MutualRawAdjITO = 1;
+	tests.MutualRawMapITO = 1;
+
+	tests.MutualRaw = 0;
+	tests.MutualRawMap = 1;
+	tests.MutualRawGap = 0;
+	tests.MutualRawAdj = 0;
+	tests.MutualRawAdjGap = 0;
+	tests.MutualRawAdjPeak = 0;
+
+	tests.MutualRawLP = 0;
+	tests.MutualRawGapLP = 0;
+	tests.MutualRawMapLP = 1;
+	tests.MutualRawAdjLP = 0;
+
+	tests.MutualCx1 = 0;
+	tests.MutualCx2 = 0;
+	tests.MutualCx2Adj = 0;
+	tests.MutualCxTotal = 0;
+	tests.MutualCxTotalAdj = 0;
+
+	tests.MutualCx1LP = 0;
+	tests.MutualCx2LP = 0;
+	tests.MutualCx2AdjLP = 0;
+	tests.MutualCxTotalLP = 0;
+	tests.MutualCxTotalAdjLP = 0;
+
+#ifdef PHONE_KEY
+	tests.MutualKeyRaw = 0;
+#else
+	tests.MutualKeyRaw = 0;
+#endif
+	tests.MutualKeyCx1 = 0;
+	tests.MutualKeyCx2 = 0;
+#ifdef PHONE_KEY
+	tests.MutualKeyCxTotal = 0;
+#else
+	tests.MutualKeyCxTotal = 0;
+#endif
+
+	tests.SelfForceRaw = 0;
+	tests.SelfForceRawGap = 0;
+	tests.SelfForceRawMap = 1;
+
+	tests.SelfForceRawLP = 0;
+	tests.SelfForceRawGapLP = 0;
+	tests.SelfForceRawMapLP = 1;
+
+	tests.SelfForceIx1 = 0;
+	tests.SelfForceIx2 = 0;
+	tests.SelfForceIx2Adj = 0;
+	tests.SelfForceIxTotal = 0;
+	tests.SelfForceIxTotalAdj = 0;
+	tests.SelfForceCx1 = 0;
+	tests.SelfForceCx2 = 0;
+	tests.SelfForceCx2Adj = 0;
+	tests.SelfForceCxTotal = 0;
+	tests.SelfForceCxTotalAdj = 0;
+	tests.SelfForceIx1LP = 0;
+	tests.SelfForceIx2LP = 0;
+	tests.SelfForceIx2AdjLP = 0;
+	tests.SelfForceIxTotalLP = 0;
+	tests.SelfForceIxTotalAdjLP = 0;
+	tests.SelfForceCx1LP = 0;
+	tests.SelfForceCx2LP = 0;
+	tests.SelfForceCx2AdjLP = 0;
+	tests.SelfForceCxTotalLP = 0;
+	tests.SelfForceCxTotalAdjLP = 0;
+
+	tests.SelfSenseRaw = 0;
+	tests.SelfSenseRawGap = 0;
+	tests.SelfSenseRawMap = 1;
+
+	tests.SelfSenseRawLP = 0;
+	tests.SelfSenseRawGapLP = 0;
+	tests.SelfSenseRawMapLP = 1;
+
+	tests.SelfSenseIx1 = 0;
+	tests.SelfSenseIx2 = 0;
+	tests.SelfSenseIx2Adj = 0;
+	tests.SelfSenseIxTotal = 0;
+	tests.SelfSenseIxTotalAdj = 0;
+	tests.SelfSenseCx1 = 0;
+	tests.SelfSenseCx2 = 0;
+	tests.SelfSenseCx2Adj = 0;
+	tests.SelfSenseCxTotal = 0;
+	tests.SelfSenseCxTotalAdj = 0;
+	tests.SelfSenseIx1LP = 0;
+	tests.SelfSenseIx2LP = 0;
+	tests.SelfSenseIx2AdjLP = 0;
+	tests.SelfSenseIxTotalLP = 0;
+	tests.SelfSenseIxTotalAdjLP = 0;
+	tests.SelfSenseCx1LP = 0;
+	tests.SelfSenseCx2LP = 0;
+	tests.SelfSenseCx2AdjLP = 0;
+	tests.SelfSenseCxTotalLP = 0;
+	tests.SelfSenseCxTotalAdjLP = 0;
+#else
+	tests.MutualRawAdjITO = 1;
+	tests.MutualRawMapITO = 1;
+
+	tests.MutualRaw = 1;  /* in case of YOCTA please use Map */
+	tests.MutualRawMap = 0;
+	tests.MutualRawGap = 0;
+	tests.MutualRawAdj = 0;
+	tests.MutualRawAdjGap = 0;
+	tests.MutualRawAdjPeak = 0;
+
+	tests.MutualRawLP = 0; /* in case of YOCTA please use Map */
+	tests.MutualRawGapLP = 0;
+	tests.MutualRawMapLP = 0;
+	tests.MutualRawAdjLP = 0;
+
+	tests.MutualCx1 = 0;
+	tests.MutualCx2 = 0;
+	tests.MutualCx2Adj = 0;
+	tests.MutualCxTotal = 0;
+	tests.MutualCxTotalAdj = 0;
+
+	tests.MutualCx1LP = 0;
+	tests.MutualCx2LP = 1;
+	tests.MutualCx2AdjLP = 1;
+	tests.MutualCxTotalLP = 0;
+	tests.MutualCxTotalAdjLP = 0;
+
+#ifdef PHONE_KEY
+	tests.MutualKeyRaw = 0;
+#else
+	tests.MutualKeyRaw = 0;
+#endif
+	tests.MutualKeyCx1 = 0;
+	tests.MutualKeyCx2 = 0;
+#ifdef PHONE_KEY
+	tests.MutualKeyCxTotal = 0;
+#else
+	tests.MutualKeyCxTotal = 0;
+#endif
+
+	tests.SelfForceRaw = 1; /* in case of YOCTA please use Map */
+	tests.SelfForceRawGap = 0;
+	tests.SelfForceRawMap = 0;
+
+	tests.SelfForceRawLP = 1; /* in case of YOCTA please use Map */
+	tests.SelfForceRawGapLP = 0;
+	tests.SelfForceRawMapLP = 0;
+
+	tests.SelfForceIx1 = 0;
+	tests.SelfForceIx2 = 0;
+	tests.SelfForceIx2Adj = 0;
+	tests.SelfForceIxTotal = 1;
+	tests.SelfForceIxTotalAdj = 0;
+	tests.SelfForceCx1 = 0;
+	tests.SelfForceCx2 = 0;
+	tests.SelfForceCx2Adj = 0;
+	tests.SelfForceCxTotal = 0;
+	tests.SelfForceCxTotalAdj = 0;
+	tests.SelfForceIx1LP = 0;
+	tests.SelfForceIx2LP = 0;
+	tests.SelfForceIx2AdjLP = 0;
+	tests.SelfForceIxTotalLP = 1;
+	tests.SelfForceIxTotalAdjLP = 0;
+	tests.SelfForceCx1LP = 0;
+	tests.SelfForceCx2LP = 0;
+	tests.SelfForceCx2AdjLP = 0;
+	tests.SelfForceCxTotalLP = 0;
+	tests.SelfForceCxTotalAdjLP = 0;
+
+	tests.SelfSenseRaw = 1;
+	tests.SelfSenseRawGap = 0;
+	tests.SelfSenseRawMap = 0;
+
+	tests.SelfSenseRawLP = 0;
+	tests.SelfSenseRawGapLP = 0;
+	tests.SelfSenseRawMapLP = 0;
+
+	tests.SelfSenseIx1 = 0;
+	tests.SelfSenseIx2 = 0;
+	tests.SelfSenseIx2Adj = 0;
+	tests.SelfSenseIxTotal = 1;
+	tests.SelfSenseIxTotalAdj = 0;
+	tests.SelfSenseCx1 = 0;
+	tests.SelfSenseCx2 = 0;
+	tests.SelfSenseCx2Adj = 0;
+	tests.SelfSenseCxTotal = 0;
+	tests.SelfSenseCxTotalAdj = 0;
+	tests.SelfSenseIx1LP = 0;
+	tests.SelfSenseIx2LP = 0;
+	tests.SelfSenseIx2AdjLP = 0;
+	tests.SelfSenseIxTotalLP = 0;
+	tests.SelfSenseIxTotalAdjLP = 0;
+	tests.SelfSenseCx1LP = 0;
+	tests.SelfSenseCx2LP = 0;
+	tests.SelfSenseCx2AdjLP = 0;
+	tests.SelfSenseCxTotalLP = 0;
+	tests.SelfSenseCxTotalAdjLP = 0;
+#endif
+	memcpy(&info->tests, &tests, sizeof(info->tests));
+	return OK;
+}
+
+/**
+  * Compute the Horizontal adjacent matrix doing the abs of the difference
+  * between the column i with the i-1 one. \n
+  * Both the original data matrix and the adj matrix are disposed as 1 dimension
+  * array one row after the other \n
+  * The resulting matrix has one column less than the starting original one \n
+  * @param data pointer to the array of signed bytes containing the original
+  * data
+  * @param row number of rows of the original data
+  * @param column number of columns of the original data
+  * @param result pointer of a pointer to an array of unsigned bytes which will
+  * contain the adj matrix
+  * @return OK if success or an error code which specify the type of error
+  */
+int computeAdjHoriz(i8 *data, int row, int column, u8 **result)
+{
+	int i, j;
+	int size = row * (column - 1);
+
+	if (column < 2) {
+		pr_err("computeAdjHoriz: ERROR %08X\n", ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u8 *)kmalloc(size * sizeof(u8), GFP_KERNEL);
+	if (*result == NULL) {
+		pr_err("computeAdjHoriz: ERROR %08X\n", ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 0; i < row; i++)
+		for (j = 1; j < column; j++)
+			*(*result + (i * (column - 1) + (j - 1))) =
+				abs(data[i * column + j] - data[i * column +
+								(j - 1)]);
+
+	return OK;
+}
+
+/**
+  * Compute the Horizontal adjacent matrix of short values doing the abs of
+  * the difference between the column i with the i-1 one.
+  * Both the original data matrix and the adj matrix are disposed as 1 dimension
+  *  array one row after the other \n
+  * The resulting matrix has one column less than the starting original one \n
+  * @param data pointer to the array of signed bytes containing the original
+  * data
+  * @param row number of rows of the original data
+  * @param column number of columns of the original data
+  * @param result pointer of a pointer to an array of unsigned bytes which
+  * will contain the adj matrix
+  * @return OK if success or an error code which specify the type of error
+  */
+int computeAdjHorizTotal(short *data, int row, int column, u16 **result)
+{
+	int i, j;
+	int size = row * (column - 1);
+
+	if (column < 2) {
+		pr_err("computeAdjHorizTotal: ERROR %08X\n",
+			ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u16 *)kmalloc(size * sizeof(u16), GFP_KERNEL);
+	if (*result == NULL) {
+		pr_err("computeAdjHorizTotal: ERROR %08X\n", ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 0; i < row; i++)
+		for (j = 1; j < column; j++)
+			*(*result + (i * (column - 1) + (j - 1))) =
+				abs(data[i * column + j] - data[i * column +
+								(j - 1)]);
+
+	return OK;
+}
+
+/**
+  * Compute the Vertical adjacent matrix doing the abs of the difference between
+  * the row i with the i-1 one.
+  * Both the original data matrix and the adj matrix are disposed as 1 dimension
+  * array one row after the other. \n
+  * The resulting matrix has one column less than the starting original one \n
+  * @param data pointer to the array of signed bytes containing the original
+  * data
+  * @param row number of rows of the original data
+  * @param column number of columns of the original data
+  * @param result pointer of a pointer to an array of unsigned bytes which will
+  * contain the adj matrix
+  * @return OK if success or an error code which specify the type of error
+  */
+int computeAdjVert(i8 *data, int row, int column, u8 **result)
+{
+	int i, j;
+	int size = (row - 1) * (column);
+
+	if (row < 2) {
+		pr_err("computeAdjVert: ERROR %08X\n", ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u8 *)kmalloc(size * sizeof(u8), GFP_KERNEL);
+	if (*result == NULL) {
+		pr_err("computeAdjVert: ERROR %08X\n", ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 1; i < row; i++)
+		for (j = 0; j < column; j++)
+			*(*result + ((i - 1) * column + j)) =
+				abs(data[i * column + j] - data[(i - 1) *
+								column + j]);
+
+	return OK;
+}
+
+/**
+  * Compute the Vertical adjacent matrix of short values doing the abs of
+  * the difference between the row i with the i-1 one.
+  * Both the original data matrix and the adj matrix are disposed as 1 dimension
+  * array one row after the other. \n
+  * The resulting matrix has one column less than the starting original one \n
+  * @param data pointer to the array of signed bytes containing the original
+  * data
+  * @param row number of rows of the original data
+  * @param column number of columns of the original data
+  * @param result pointer of a pointer to an array of unsigned bytes which will
+  * contain the adj matrix
+  * @return OK if success or an error code which specify the type of error
+  */
+int computeAdjVertTotal(short *data, int row, int column, u16 **result)
+{
+	int i, j;
+	int size = (row - 1) * (column);
+
+	if (row < 2) {
+		pr_err("computeAdjVertTotal: ERROR %08X\n", ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u16 *)kmalloc(size * sizeof(u16), GFP_KERNEL);
+	if (*result == NULL) {
+		pr_err("computeAdjVertTotal: ERROR %08X\n", ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 1; i < row; i++)
+		for (j = 0; j < column; j++)
+			*(*result + ((i - 1) * column + j)) =
+				abs(data[i * column + j] - data[(i - 1) *
+								column + j]);
+
+	return OK;
+}
+
+/**
+  * Compute the Horizontal adjacent matrix doing the abs of the difference
+  * between the column i with the i-1 one. \n
+  * Both the original data matrix and the adj matrix are disposed as 1 dimension
+  * array one row after the other \n
+  * The resulting matrix has one column less than the starting original one \n
+  * @param data pointer to the array of unsigned bytes containing the original
+  * data
+  * @param row number of rows of the original data
+  * @param column number of columns of the original data
+  * @param result pointer of a pointer to an array of unsigned bytes which will
+  *  contain the adj matrix
+  * @return OK if success or an error code which specify the type of error
+  */
+int computeAdjHorizFromU(u8 *data, int row, int column, u8 **result)
+{
+	int i, j;
+	int size = row * (column - 1);
+
+	if (column < 2) {
+		pr_err("computeAdjHoriz: ERROR %08X\n", ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u8 *)kmalloc(size * sizeof(u8), GFP_KERNEL);
+	if (*result == NULL) {
+		pr_err("computeAdjHoriz: ERROR %08X\n", ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 0; i < row; i++)
+		for (j = 1; j < column; j++)
+			*(*result + (i * (column - 1) + (j - 1))) =
+				abs(data[i * column + j] - data[i * column +
+								(j - 1)]);
+
+	return OK;
+}
+
+/**
+  * Compute the Horizontal adjacent matrix of u16 values doing the abs of
+  * the difference between the column i with the i-1 one.
+  * Both the original data matrix and the adj matrix are disposed as 1 dimension
+  * array one row after the other \n
+  * The resulting matrix has one column less than the starting original one \n
+  * @param data pointer to the array of unsigned bytes containing the original
+  * data
+  * @param row number of rows of the original data
+  * @param column number of columns of the original data
+  * @param result pointer of a pointer to an array of unsigned bytes which will
+  * contain the adj matrix
+  * @return OK if success or an error code which specify the type of error
+  */
+int computeAdjHorizTotalFromU(u16 *data, int row, int column, u16 **result)
+{
+	int i, j;
+	int size = row * (column - 1);
+
+	if (column < 2) {
+		pr_err("computeAdjHorizTotal: ERROR %08X\n",
+			ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u16 *)kmalloc(size * sizeof(u16), GFP_KERNEL);
+	if (*result == NULL) {
+		pr_err("computeAdjHorizTotal: ERROR %08X\n", ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 0; i < row; i++)
+		for (j = 1; j < column; j++)
+			*(*result + (i * (column - 1) + (j - 1))) =
+				abs(data[i * column + j] - data[i * column +
+								(j - 1)]);
+
+	return OK;
+}
+
+/**
+  * Compute the Vertical adjacent matrix doing the abs of the difference between
+  * the row i with the i-1 one.
+  * Both the original data matrix and the adj matrix are disposed as 1 dimension
+  * array one row after the other. \n
+  * The resulting matrix has one column less than the starting original one \n
+  * @param data pointer to the array of unsigned bytes containing the original
+  * data
+  * @param row number of rows of the original data
+  * @param column number of columns of the original data
+  * @param result pointer of a pointer to an array of unsigned bytes which will
+  * contain the adj matrix
+  * @return OK if success or an error code which specify the type of error
+  */
+int computeAdjVertFromU(u8 *data, int row, int column, u8 **result)
+{
+	int i, j;
+	int size = (row - 1) * (column);
+
+	if (row < 2) {
+		pr_err("computeAdjVert: ERROR %08X\n", ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u8 *)kmalloc(size * sizeof(u8), GFP_KERNEL);
+	if (*result == NULL) {
+		pr_err("computeAdjVert: ERROR %08X\n", ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 1; i < row; i++)
+		for (j = 0; j < column; j++)
+			*(*result + ((i - 1) * column + j)) =
+				abs(data[i * column + j] - data[(i - 1) *
+								column + j]);
+
+	return OK;
+}
+
+/**
+  * Compute the Vertical adjacent matrix of u16 values doing the abs of
+  * the difference between the row i with the i-1 one.
+  * Both the original data matrix and the adj matrix are disposed as 1 dimension
+  * array one row after the other. \n
+  * The resulting matrix has one column less than the starting original one \n
+  * @param data pointer to the array of unsigned bytes containing the original
+  * data
+  * @param row number of rows of the original data
+  * @param column number of columns of the original data
+  * @param result pointer of a pointer to an array of unsigned bytes which will
+  * contain the adj matrix
+  * @return OK if success or an error code which specify the type of error
+  */
+int computeAdjVertTotalFromU(u16 *data, int row, int column, u16 **result)
+{
+	int i, j;
+	int size = (row - 1) * (column);
+
+	if (row < 2) {
+		pr_err("computeAdjVertTotal: ERROR %08X\n", ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*result = (u16 *)kmalloc(size * sizeof(u16), GFP_KERNEL);
+	if (*result == NULL) {
+		pr_err("computeAdjVertTotal: ERROR %08X\n", ERROR_ALLOC);
+		return ERROR_ALLOC;
+	}
+
+	for (i = 1; i < row; i++)
+		for (j = 0; j < column; j++)
+			*(*result + ((i - 1) * column + j)) =
+				abs(data[i * column + j] - data[(i - 1) *
+								column + j]);
+
+	return OK;
+}
+
+
+
+/**
+  * Check that each value of a matrix of short doesn't exceed a min and a Max
+  * value
+  * (these values are included in the interval). \n
+  * The matrix is stored as 1 dimension array one row after the other. \n
+  * @param data pointer to the array of short containing the data to check
+  * @param row number of rows of data
+  * @param column number of columns of data
+  * @param min minimum value allowed
+  * @param max Maximum value allowed
+  * @return the number of elements that overcome the specified interval (0 = OK)
+  */
+int checkLimitsMinMax(short *data, int row, int column, int min, int max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] < min || data[i * column + j] >
+			    max) {
+				pr_info("%s: Node[%d,%d] = %d exceed limit [%d, %d]\n",
+					__func__, i, j, data[i * column + j], min, max);
+				count++;
+			}
+		}
+	}
+
+	return count;	/* if count is 0 = OK, test completed successfully */
+}
+
+/**
+  * Check that the difference between the max and min of a matrix of short
+  * is less or equal to a threshold.\n
+  * The matrix is stored as 1 dimension array one row after the other.
+  * @param data pointer to the array of short containing the data to check
+  * @param row number of rows of data
+  * @param column number of columns of data
+  * @param threshold threshold value allowed
+  * @return OK if the difference is <= to threshold otherwise
+  * ERROR_TEST_CHECK_FAIL
+  */
+int checkLimitsGap(short *data, int row, int column, int threshold)
+{
+	int i, j;
+	int min_node;
+	int max_node;
+
+	if (row == 0 || column == 0) {
+		pr_err("checkLimitsGap: invalid number of rows = %d or columns = %d  ERROR %08X\n",
+			row, column, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	min_node = data[0];
+	max_node = data[0];
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] < min_node)
+				min_node = data[i * column + j];
+			else if (data[i * column + j] > max_node)
+				max_node = data[i * column + j];
+		}
+	}
+
+	if (max_node - min_node > threshold) {
+		pr_err("checkLimitsGap: GAP = %d exceed limit  %d\n",
+			max_node - min_node, threshold);
+		return ERROR_TEST_CHECK_FAIL;
+	} else
+		return OK;
+}
+
+/*
+ * Check that the difference between the max and min of a matrix of short is
+ * less or equal to a threshold.\n
+ * The matrix is stored as 1 dimension array one row after the other.
+ * @param data pointer to the array of short containing the data to check
+ * @param row number of rows of data
+ * @param column number of columns of data
+ * @param threshold threshold value allowed
+ * @param row_start index of the starting column which should be considered
+ * @param column_start index of the starting column which should be considered
+ * @param row_end number of index to subtract to row to identify last
+ *		valid row to check
+ * @param column_end number of index to subtract to column to identify last
+ *		valid column to check
+ * @return OK if the difference is <= to threshold otherwise
+ * ERROR_TEST_CHECK_FAIL
+ */
+int checkLimitsGapOffsets(short *data, int row, int column, int threshold,
+	int row_start, int column_start, int row_end, int column_end)
+{
+	int i, j;
+	int min_node;
+	int max_node;
+
+	if (row == 0 || column == 0) {
+		pr_err("checkLimitsGap: invalid number of rows = %d or columns = %d  ERROR %08X\n",
+			row, column, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	min_node = data[row_start*column+column_start];
+	max_node = data[row_start*column+column_start];
+
+	for (i = row_start; i < row-row_end; i++) {
+		for (j = column_start; j < column-column_end; j++) {
+			if (data[i * column + j] < min_node)
+				min_node = data[i * column + j];
+			else if (data[i * column + j] > max_node)
+				max_node = data[i * column + j];
+		}
+	}
+
+	if (max_node - min_node > threshold) {
+		pr_err("checkLimitsGap: GAP = %d exceed limit  %d\n",
+			max_node - min_node, threshold);
+		return ERROR_TEST_CHECK_FAIL;
+	} else
+		return OK;
+}
+
+/**
+  * Check that each value of a matrix of i8 doesn't exceed a specific min and
+  * Max value  set for each node (these values are included in the interval). \n
+  * The matrixes of data, min and max values are stored as 1 dimension arrays
+  * one row after the other.
+  * @param data pointer to the array of short containing the data to check
+  * @param row number of rows of data
+  * @param column number of columns of data
+  * @param min pointer to a matrix which specify the minimum value allowed for
+  * each node
+  * @param max pointer to a matrix which specify the Maximum value allowed for
+  * each node
+  * @return the number of elements that overcome the specified interval (0 = OK)
+  */
+int checkLimitsMap(i8 *data, int row, int column, int *min, int *max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] < min[i * column + j] ||
+			    data[i * column + j] > max[i * column + j]) {
+				pr_info("%s: Node[%d,%d] = %d exceed limit [%d, %d]\n",
+					__func__, i, j, data[i * column + j],
+					min[i * column + j],
+					max[i * column + j]);
+				count++;
+			}
+		}
+	}
+
+	return count;	/* if count is 0 = OK, test completed successfully */
+}
+
+/**
+  * Check that each value of a matrix of short doesn't exceed a specific min and
+  * Max value  set for each node (these values are included in the interval).
+  * The matrixes of data, min and max values are stored as 1 dimension arrays
+  * one row after the other.
+  * @param data pointer to the array of short containing the data to check
+  * @param row number of rows of data
+  * @param column number of columns of data
+  * @param min pointer to a matrix which specify the minimum value allowed for
+  * each node
+  * @param max pointer to a matrix which specify the Maximum value allowed for
+  * each node
+  * @return the number of elements that overcome the specified interval (0 = OK)
+  */
+int checkLimitsMapTotal(short *data, int row, int column, int *min, int *max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] < min[i * column + j] ||
+			    data[i * column + j] > max[i * column + j]) {
+				pr_info("%s: Node[%d,%d] = %d exceed limit [%d, %d]\n",
+					__func__, i, j, data[i * column + j],
+					min[i * column + j],
+					max[i * column + j]);
+				count++;
+			}
+		}
+	}
+
+	return count;	/* if count is 0 = OK, test completed successfully */
+}
+
+/**
+  * Check that each value of a matrix of u8 doesn't exceed a specific min and
+  * Max value  set for each node (these values are included in the interval). \n
+  * The matrixes of data, min and max values are stored as 1 dimension arrays
+  * one row after the other.
+  * @param data pointer to the array of short containing the data to check
+  * @param row number of rows of data
+  * @param column number of columns of data
+  * @param min pointer to a matrix which specify the minimum value allowed for
+  * each node
+  * @param max pointer to a matrix which specify the Maximum value allowed for
+  * each node
+  * @return the number of elements that overcome the specified interval (0 = OK)
+  */
+int checkLimitsMapFromU(u8 *data, int row, int column, int *min, int *max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] < min[i * column + j] ||
+			    data[i * column + j] > max[i * column + j]) {
+				pr_info("%s: Node[%d,%d] = %d exceed limit [%d, %d]\n",
+					__func__, i, j, data[i * column + j],
+					min[i * column + j],
+					max[i * column + j]);
+				count++;
+			}
+		}
+	}
+
+	return count;	/* if count is 0 = OK, test completed successfully */
+}
+
+/**
+  * Check that each value of a matrix of u16 doesn't exceed a specific min and
+  * Max value  set for each node (these values are included in the interval).
+  * The matrixes of data, min and max values are stored as 1 dimension arrays
+  * one row after the other.
+  * @param data pointer to the array of short containing the data to check
+  * @param row number of rows of data
+  * @param column number of columns of data
+  * @param min pointer to a matrix which specify the minimum value allowed for
+  * each node
+  * @param max pointer to a matrix which specify the Maximum value allowed for
+  * each node
+  * @return the number of elements that overcome the specified interval (0 = OK)
+  */
+int checkLimitsMapTotalFromU(u16 *data, int row, int column, int *min, int *max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] < min[i * column + j] ||
+			    data[i * column + j] > max[i * column + j]) {
+				pr_info("%s: Node[%d,%d] = %d exceed limit [%d, %d]\n",
+					__func__, i, j, data[i * column + j],
+					min[i * column + j],
+					max[i * column + j]);
+				count++;
+			}
+		}
+	}
+
+	return count;	/* if count is 0 = OK, test completed successfully */
+}
+
+/**
+  * Check that each value of a matrix of u8 doesn't exceed a specific Max value
+  * set for each node (max value is included in the interval).
+  * The matrixes of data and max values are stored as 1 dimension arrays one row
+  * after the other.
+  * @param data pointer to the array of short containing the data to check
+  * @param row number of rows of data
+  * @param column number of columns of data
+  * @param max pointer to a matrix which specify the Maximum value allowed for
+  * each node
+  * @return the number of elements that overcome the specified interval (0 = OK)
+  */
+int checkLimitsMapAdj(u8 *data, int row, int column, int *max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] > max[i * column + j]) {
+				pr_info("%s: Node[%d,%d] = %d exceed limit > %d\n",
+					__func__, i, j,
+					data[i * column + j],
+					max[i * column + j]);
+				count++;
+			}
+		}
+	}
+
+	return count;	/* if count is 0 = OK, test completed successfully */
+}
+
+/**
+  * Check that each value of a matrix of u16 doesn't exceed a specific Max value
+  * set for each node (max value is included in the interval).
+  * The matrixes of data and max values are stored as 1 dimension arrays one row
+  * after the other.
+  * @param data pointer to the array of short containing the data to check
+  * @param row number of rows of data
+  * @param column number of columns of data
+  * @param max pointer to a matrix which specify the Maximum value allowed for
+  * each node
+  * @return the number of elements that overcome the specified interval (0 = OK)
+  */
+int checkLimitsMapAdjTotal(u16 *data, int row, int column, int *max)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < row; i++) {
+		for (j = 0; j < column; j++) {
+			if (data[i * column + j] > max[i * column + j]) {
+				pr_info("%s: Node[%d,%d] = %d exceed limit > %d\n",
+					__func__, i, j,
+					data[i * column + j],
+					max[i * column + j]);
+				count++;
+			}
+		}
+	}
+
+	return count;	/* if count is 0 = OK, test completed successfully */
+}
+
+/**
+  * Perform an ITO test setting all the possible options
+  * (see @link ito_opt ITO Options @endlink) and checking MS Raw ADJ if enabled
+  * @param path_limits name of Production Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @param todo pointer to a TestToDo variable which select the test to do
+  * @param frame pointer to a MutualSenseframe variable which will store the ITO
+  *  MS RAW data. If NULL, no data will be returned while if MutualRawAdjITO
+  *  item in todo is disabled the variable will be untouched
+  * @param max_val pointer to store the adjacent frame max node value
+  * @return OK if success or an error code which specify the type of error
+  */
+int production_test_ito(struct fts_ts_info *info, const char *path_limits,
+			MutualSenseFrame *frame, u16 *max_val)
+{
+	int res = OK;
+	u8 sett[2] = { 0x00, 0x00 };
+	MutualSenseFrame msRawFrame;
+	MutualSenseFrame *ptr_frame = NULL;
+	int *thresholds = NULL;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	u16 *adj = NULL;
+	int trows, tcolumns;
+	int size;
+	int i;
+	int max_value;
+	TestToDo *todo = &info->tests;
+
+	msRawFrame.node_data = NULL;
+
+	dev_info(info->dev, "ITO Production test is starting...\n");
+
+	res = fts_system_reset(info);
+	if (res < 0) {
+		dev_err(info->dev, "%s: ERROR %08X\n", __func__, ERROR_PROD_TEST_ITO);
+		return res | ERROR_PROD_TEST_ITO;
+	}
+
+	sett[0] = SPECIAL_TUNING_IOFF;
+	dev_info(info->dev, "Trimming Ioff...\n");
+	res = writeSysCmd(info, SYS_CMD_SPECIAL_TUNING, sett, 2);
+	if (res < OK) {
+		dev_err(info->dev, "production_test_ito: Trimm Ioff ERROR %08X\n",
+			(res | ERROR_PROD_TEST_ITO));
+		return res | ERROR_PROD_TEST_ITO;
+	}
+
+	sett[0] = 0xFF;
+	sett[1] = 0x01;
+	dev_info(info->dev, "ITO Check command sent...\n");
+	res = writeSysCmd(info, SYS_CMD_ITO, sett, 2);
+	if (res < OK) {
+		dev_err(info->dev, "production_test_ito: ERROR %08X\n",
+			 (res | ERROR_PROD_TEST_ITO));
+		return res | ERROR_PROD_TEST_ITO;
+	}
+
+	dev_info(info->dev, "ITO Command = OK!\n");
+
+	dev_info(info->dev, "MS RAW ITO ADJ TEST:\n");
+	if (todo->MutualRawAdjITO == 1 || todo->MutualRawMapITO == 1) {
+		dev_info(info->dev, "Collecting MS Raw data...\n");
+
+		if (frame != NULL) {
+			dev_info(info->dev, "%s: Copying MS Raw data to caller!\n",
+				__func__);
+			ptr_frame  = frame;
+		} else
+			ptr_frame = &msRawFrame;
+
+		res |= getMSFrame3(info, MS_RAW, ptr_frame);
+		if (res < OK) {
+			dev_err(info->dev, "%s: getMSFrame failed... ERROR %08X\n",
+				__func__, ERROR_PROD_TEST_ITO);
+			goto ERROR;
+		}
+
+		print_frame_short(info, "MS Raw ITO frame =",
+				  array1dTo2d_short(
+					  (*ptr_frame).node_data,
+					  (*ptr_frame).node_data_size,
+					  (*ptr_frame).header.sense_node),
+				  (*ptr_frame).header.force_node,
+				  (*ptr_frame).header.sense_node);
+
+		dev_info(info->dev, "MS RAW ITO ADJ HORIZONTAL TEST:\n");
+		res = computeAdjHorizTotal((*ptr_frame).node_data,
+					   (*ptr_frame).header.force_node,
+					   (*ptr_frame).header.sense_node,
+					   &adj);
+		if (res < OK) {
+			dev_err(info->dev, "%s: computeAdjHoriz failed... ERROR %08X\n",
+				__func__, ERROR_PROD_TEST_ITO);
+			goto ERROR;
+		}
+		size = (*ptr_frame).header.force_node *
+			((*ptr_frame).header.sense_node - 1);
+		max_value = adj[0];
+		for (i = 1; i < size; i++)
+			max_value = (adj[i] > max_value) ? adj[i] : max_value;
+		dev_info(info->dev, "%s: MSRAW ITO ADJH Max Value: %d\n",
+			__func__, max_value);
+		if (max_val != NULL)
+			*max_val = max_value;
+
+		res = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_RAW_ITO_ADJH, &thresholds,
+						&trows, &tcolumns);
+		if (res < OK || (trows != (*ptr_frame).header.force_node ||
+				 tcolumns != (*ptr_frame).header.sense_node -
+				 1)) {
+			dev_err(info->dev, "%s: parseProductionTestLimits MS_RAW_ITO_ADJH failed... ERROR %08X\n",
+				__func__, ERROR_PROD_TEST_DATA);
+			goto ERROR;
+		}
+
+
+		res = checkLimitsMapAdjTotal(adj,
+					     (*ptr_frame).header.force_node,
+					     (*ptr_frame).header.sense_node - 1,
+					     thresholds);
+		if (res != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsAdj MS RAW ITO ADJH failed... ERROR COUNT = %d\n",
+				res);
+			dev_err(info->dev, "MS RAW ITO ADJ HORIZONTAL TEST:.................FAIL\n\n");
+			res = ERROR_PROD_TEST_ITO;
+			goto ERROR;
+		} else
+			dev_info(info->dev, "MS RAW ITO ADJ HORIZONTAL TEST:.................OK\n");
+
+		kfree(thresholds);
+		thresholds = NULL;
+
+		kfree(adj);
+		adj = NULL;
+
+		dev_info(info->dev, "MS RAW ITO ADJ VERTICAL TEST:\n");
+		res = computeAdjVertTotal((*ptr_frame).node_data,
+					  (*ptr_frame).header.force_node,
+					  (*ptr_frame).header.sense_node,
+					  &adj);
+		if (res < OK) {
+			dev_err(info->dev, "%s: computeAdjVert failed... ERROR %08X\n",
+				__func__, ERROR_PROD_TEST_ITO);
+			goto ERROR;
+		}
+
+		size = ((*ptr_frame).header.force_node - 1) *
+			(*ptr_frame).header.sense_node;
+		max_value = adj[0];
+		for (i = 1; i < size; i++)
+			max_value = (adj[i] > max_value) ? adj[i] : max_value;
+		dev_info(info->dev, "%s: MSRAW ITO ADJV Max Value: %d\n",
+			__func__, max_value);
+		if (max_val != NULL)
+			*(max_val + 1) = max_value;
+
+		res = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_RAW_ITO_ADJV, &thresholds,
+						&trows, &tcolumns);
+		if (res < OK || (trows != (*ptr_frame).header.force_node - 1 ||
+				 tcolumns != (*ptr_frame).header.sense_node)) {
+			dev_err(info->dev, "%s: parseProductionTestLimits MS_RAW_ITO_ADJV failed... ERROR %08X\n",
+				__func__, ERROR_PROD_TEST_ITO);
+			goto ERROR;
+		}
+
+
+		res = checkLimitsMapAdjTotal(adj, (*ptr_frame).header.force_node
+					- 1, (*ptr_frame).header.sense_node,
+					     thresholds);
+		if (res != OK) {
+			dev_err(info->dev, "%s: checkLimitsAdj MS RAW ITO ADJV failed... ERROR COUNT = %d\n",
+				__func__, res);
+			dev_err(info->dev, "MS RAW ITO ADJ VERTICAL TEST:.................FAIL\n\n");
+			res = ERROR_PROD_TEST_ITO;
+			goto ERROR;
+		} else
+			dev_info(info->dev, "MS RAW ITO ADJ VERTICAL TEST:.................OK\n");
+
+		kfree(thresholds);
+		thresholds = NULL;
+
+		kfree(adj);
+		adj = NULL;
+
+		dev_info(info->dev, "MS RAW ITO MIN MAX TEST:\n");
+		if (todo->MutualRawMapITO == 1) {
+			res = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, MS_RAW_ITO_EACH_NODE_MIN,
+				&thresholds_min, &trows, &tcolumns);
+			if (res < OK || (trows !=
+				(*ptr_frame).header.force_node ||
+				tcolumns != (*ptr_frame).header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionMS_RAW_ITO_EACH_NODE_MIN failed..."
+					"ERROR %08X\n", ERROR_PROD_TEST_DATA);
+				res |= ERROR_PROD_TEST_DATA;
+				goto ERROR;
+			}
+
+			res = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, MS_RAW_ITO_EACH_NODE_MAX,
+				&thresholds_max, &trows, &tcolumns);
+			if (res < OK || (trows !=
+				(*ptr_frame).header.force_node ||
+				tcolumns != (*ptr_frame).header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionMS_RAW_ITO_EACH_NODE_MAX failed..."
+					"ERROR %08X\n", ERROR_PROD_TEST_DATA);
+				res |= ERROR_PROD_TEST_DATA;
+				goto ERROR;
+			}
+
+			res = checkLimitsMapTotal((*ptr_frame).node_data,
+				(*ptr_frame).header.force_node,
+				(*ptr_frame).header.sense_node, thresholds_min,
+				thresholds_max);
+			if (res != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMinMax"
+					" MS RAW ITO failed... ERROR COUNT = %d\n",
+					res);
+				dev_err(info->dev, "MS RAW ITO MIN MAX TEST:.................FAIL\n\n");
+				res |= ERROR_PROD_TEST_DATA;
+				goto ERROR;
+			} else {
+				dev_info(info->dev, "MS RAW ITO MIN MAX TEST:................OK\n");
+			}
+		} else {
+			dev_info(info->dev, "MS RAW ITO MIN MAX TEST:.................SKIPPED\n");
+		}
+	} else {
+		dev_info(info->dev, "MS RAW ITO TEST:.................SKIPPED\n");
+	}
+
+ERROR:
+	kfree(thresholds);
+	kfree(adj);
+	kfree(msRawFrame.node_data);
+	kfree(thresholds_min);
+	kfree(thresholds_max);
+	freeLimitsFile(&info->limit_file);
+	res |= fts_system_reset(info);
+	if (res < OK) {
+		dev_err(info->dev, "production_test_ito: ERROR %08X\n",
+			ERROR_PROD_TEST_ITO);
+		res = (res | ERROR_PROD_TEST_ITO);
+	}
+	return res;
+}
+
+/**
+  * Perform the Initialization of the IC
+  * @param type type of initialization to do
+  * (see @link sys_special_opt Initialization Options (Full or Panel) @endlink)
+  * @return OK if success or an error code which specify the type of error
+  */
+int production_test_initialization(struct fts_ts_info *info, u8 type)
+{
+	int res;
+
+	dev_info(info->dev, "INITIALIZATION Production test is starting...\n");
+	if (type != SPECIAL_PANEL_INIT && type != SPECIAL_FULL_PANEL_INIT) {
+		dev_err(info->dev, "production_test_initialization: Type incompatible! Type = %02X ERROR %08X\n",
+			type, ERROR_OP_NOT_ALLOW |
+			ERROR_PROD_TEST_INITIALIZATION);
+		return ERROR_OP_NOT_ALLOW | ERROR_PROD_TEST_INITIALIZATION;
+	}
+
+	res = fts_system_reset(info);
+	if (res < 0) {
+		dev_err(info->dev, "production_test_initialization: ERROR %08X\n",
+			ERROR_PROD_TEST_INITIALIZATION);
+		return res | ERROR_PROD_TEST_INITIALIZATION;
+	}
+
+	dev_info(info->dev, "INITIALIZATION command sent... %02X\n", type);
+	res = writeSysCmd(info, SYS_CMD_SPECIAL, &type, 1);
+	if (res < OK) {
+		dev_err(info->dev, "production_test_initialization: ERROR %08X\n",
+			(res | ERROR_PROD_TEST_INITIALIZATION));
+		return res | ERROR_PROD_TEST_INITIALIZATION;
+	}
+
+
+	dev_info(info->dev, "Refresh Sys Info...\n");
+	res |= readSysInfo(info, 1);	/* need to update the chipInfo in order
+				  * to refresh several versions */
+
+	if (res < 0) {
+		dev_err(info->dev, "production_test_initialization: read sys info ERROR %08X\n",
+			ERROR_PROD_TEST_INITIALIZATION);
+		res = (res | ERROR_PROD_TEST_INITIALIZATION);
+	}
+
+	return res;
+}
+
+
+//  @param signature value of the MP flag to save if the Mass Production Test succeed
+/**
+  * Perform a FULL (ITO + INIT + DATA CHECK) Mass Production Test of the IC
+  * @param pathThresholds name of Production Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @param stop_on_fail if 1, the test flow stops at the first data check
+  * failure
+  * otherwise it keeps going performing all the selected test
+  * @param saveInit if >0 (possible values: NO_INIT, SPECIAL_PANEL_INIT or
+  * SPECIAL_FULL_PANEL_INIT),
+  * the Initialization of the IC is executed otherwise it is skipped
+  * @param todo pointer to a TestToDo variable which select the test to do
+  * @param mpflag MP flag value to write in case of successful test
+  * @return OK if success or an error code which specify the type of error
+  */
+int production_test_main(struct fts_ts_info *info, const char *pathThresholds,
+			 int stop_on_fail, int saveInit, u8 mpflag)
+{
+	int res = 0;
+	int ret = 0;
+
+	dev_info(info->dev, "MAIN Production test is starting...\n");
+
+#ifndef SKIP_PRODUCTION_TEST
+	dev_info(info->dev, "ITO TEST:\n");
+	res = production_test_ito(info, pathThresholds, NULL, NULL);
+	if (res < 0) {
+		dev_err(info->dev, "Error during ITO TEST! ERROR %08X\n", res);
+		/* in case of ITO TEST failure is no sense keep going */
+		goto END;
+	} else
+		dev_info(info->dev, "ITO TEST OK!\n");
+#endif
+
+	dev_info(info->dev, "INITIALIZATION TEST :\n");
+	if (saveInit != NO_INIT) {
+		res = production_test_initialization(info, (u8)saveInit);
+		if (res < 0) {
+			dev_err(info->dev, "Error during  INITIALIZATION TEST! ERROR %08X\n",
+				res);
+			if (stop_on_fail)
+				goto END;
+		} else
+			dev_info(info->dev, "INITIALIZATION TEST OK!\n");
+	} else
+		dev_info(info->dev, "INITIALIZATION TEST :................. SKIPPED\n");
+
+	if (saveInit != NO_INIT) {
+		dev_info(info->dev, "Cleaning up...\n");
+		ret = fts_system_reset(info);
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_main: system reset ERROR %08X\n",
+				ret);
+			res |= ret;
+			if (stop_on_fail)
+				goto END;
+		}
+	}
+
+#ifndef SKIP_PRODUCTION_TEST
+	dev_info(info->dev, "PRODUCTION DATA TEST:\n");
+	ret = production_test_data(info, pathThresholds, stop_on_fail);
+	if (ret < OK)
+		dev_err(info->dev, "Error during PRODUCTION DATA TEST! ERROR %08X\n", ret);
+	else
+		dev_info(info->dev, "PRODUCTION DATA TEST OK!\n");
+#endif
+
+#ifdef COMPUTE_INIT_METHOD
+	if (saveInit != NO_INIT) {
+		dev_info(info->dev, "%s: Clearing the FIFO events!!!\n", __func__);
+		ret = flushFIFO(info);
+		if (ret < OK)
+			dev_err(info->dev, "%s: Error while Flushing the FIFO! ERROR %8X\n",
+				__func__, ret);
+		/* save the mp flag to desired value
+		 * because data check OK
+		 */
+		ret = saveMpFlag(info, mpflag);
+		if (ret < OK)
+			dev_err(info->dev, "Error while saving MP FLAG! ERROR %08X\n",
+				ret);
+		else
+			dev_info(info->dev, "MP FLAG saving OK!\n");
+	}
+#endif
+
+	res |= ret;
+	/* the OR is important because if the data test is OK but
+	 * the init test fail, the main production test result should = FAIL */
+
+END:
+	if (res < OK) {
+		dev_err(info->dev, "MAIN Production test finished.................FAILED\n");
+		return res;
+	} else {
+		dev_info(info->dev, "MAIN Production test finished.................OK\n");
+		return OK;
+	}
+}
+
+/**
+  * Perform all the test selected in a TestTodo variable related to MS raw data
+  * (touch, keys etc..)
+  * @param path_limits name of Production Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @param stop_on_fail if 1, the test flow stops at the first data check
+  * failure
+  * otherwise it keeps going performing all the selected test
+  * @param todo pointer to a TestToDo variable which select the test to do
+  * @return OK if success or an error code which specify the type of error
+  */
+int production_test_ms_raw(struct fts_ts_info *info, const char *path_limits,
+			   int stop_on_fail)
+{
+	int ret, count_fail = 0;
+	MutualSenseFrame msRawFrame;
+	TestToDo *todo = &info->tests;
+
+	int *thresholds = NULL;
+	int trows, tcolumns;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	u16 *adj = NULL;
+
+	int maxAdjH, maxAdjV;
+	int i, z;
+
+	msRawFrame.node_data = NULL;
+
+	/************** Mutual Sense Test *************/
+	dev_info(info->dev, "MS RAW DATA TEST is starting...\n");
+	if (todo->MutualRaw == 1 || todo->MutualRawGap == 1 ||
+	    todo->MutualRawAdj == 1 || todo->MutualRawMap == 1 ||
+	    todo->MutualRawAdjGap == 1 || todo->MutualRawAdjPeak == 1) {
+		ret = setScanMode(info, SCAN_MODE_LOCKED, LOCKED_ACTIVE);
+		msleep(WAIT_FOR_FRESH_FRAMES);
+		ret |= setScanMode(info, SCAN_MODE_ACTIVE, 0x00);
+		msleep(WAIT_AFTER_SENSEOFF);
+#ifdef READ_FILTERED_RAW
+		ret |= getMSFrame3(info, MS_FILTER, &msRawFrame);
+#else
+		ret |= getMSFrame3(info, MS_RAW, &msRawFrame);
+#endif
+		if (ret < OK) {
+			dev_err(info->dev, "production_test_data: getMSFrame failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			return ret | ERROR_PROD_TEST_DATA;
+		}
+
+		print_frame_short(info, "MS Raw frame =",
+				  array1dTo2d_short(
+					  msRawFrame.node_data,
+					  msRawFrame.node_data_size,
+					  msRawFrame.header.sense_node),
+				  msRawFrame.header.force_node,
+				  msRawFrame.header.sense_node);
+
+		dev_info(info->dev, "MS RAW MIN MAX TEST:\n");
+		if (todo->MutualRaw == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							MS_RAW_MIN_MAX,
+							&thresholds, &trows,
+							&tcolumns);
+			if (ret < OK || (trows != 1 || tcolumns != 2)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_MIN_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+
+			ret = checkLimitsMinMax(msRawFrame.node_data,
+						msRawFrame.header.force_node,
+						msRawFrame.header.sense_node,
+						thresholds[0],
+						thresholds[1]);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMinMax MS RAW failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "MS RAW MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "MS RAW MIN MAX TEST:.................OK\n");
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			dev_info(info->dev, "MS RAW MIN MAX TEST:.................SKIPPED\n");
+
+		dev_info(info->dev, "MS RAW MAP MIN MAX TEST:\n");
+		if (todo->MutualRawMap == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, MS_RAW_EACH_NODE_MIN,
+				&thresholds_min, &trows, &tcolumns);
+			if (ret < OK || (trows !=
+						msRawFrame.header.force_node ||
+					 tcolumns !=
+						msRawFrame.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_EACH_NODE_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			ret = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, MS_RAW_EACH_NODE_MAX,
+				&thresholds_max, &trows, &tcolumns);
+			if (ret < OK || (trows !=
+						msRawFrame.header.force_node ||
+					 tcolumns !=
+						msRawFrame.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_EACH_NODE_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			ret = checkLimitsMapTotal(msRawFrame.node_data,
+				msRawFrame.header.force_node,
+				msRawFrame.header.sense_node, thresholds_min,
+				thresholds_max);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMinMaxEachNodeData failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "MS RAW MAP MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else{
+				dev_info(info->dev, "MS RAW MAP MIN MAX TEST:.................OK\n");
+			}
+			if (thresholds_min != NULL) {
+				kfree(thresholds_min);
+				thresholds_min = NULL;
+			}
+			if (thresholds_max != NULL) {
+				kfree(thresholds_max);
+				thresholds_max = NULL;
+			}
+		} else
+			dev_info(info->dev, "MS RAW MAP MIN MAX TEST:.................SKIPPED\n");
+
+
+		dev_info(info->dev, "MS RAW GAP TEST:\n");
+		if (todo->MutualRawGap == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file, MS_RAW_GAP,
+							&thresholds, &trows,
+							&tcolumns);
+			if (ret < OK || (trows != 1 || tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_GAP failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsGap(msRawFrame.node_data,
+					     msRawFrame.header.force_node,
+					     msRawFrame.header.sense_node,
+					     thresholds[0]);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsGap MS RAW failed... ERROR = %08X\n",
+					ret);
+				count_fail += 1;
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "MS RAW GAP TEST:.................OK\n\n");
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			dev_info(info->dev, "MS RAW GAP TEST:.................SKIPPED\n");
+
+		dev_info(info->dev, "MS RAW ADJ TEST:\n");
+		if ((todo->MutualRawAdj == 1) || (todo->MutualRawAdjGap == 1) ||
+			(todo->MutualRawAdjPeak == 1)) {
+			dev_info(info->dev, "MS RAW ADJ HORIZONTAL TEST:\n");
+			ret = computeAdjHorizTotal(msRawFrame.node_data,
+						   msRawFrame.header.force_node,
+						   msRawFrame.header.sense_node,
+						   &adj);
+			if (ret < OK) {
+				dev_err(info->dev, "production_test_data: computeAdjHoriz failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			if (todo->MutualRawAdj) {
+				dev_err(info->dev, "MS RAW ADJ HORIZONTAL MIN/MAX:\n");
+
+				ret = parseProductionTestLimits(info,
+							path_limits,
+							&info->limit_file,
+							MS_RAW_ADJH,
+							&thresholds,
+							&trows,
+							&tcolumns);
+				if (ret < OK ||
+				    (trows != msRawFrame.header.force_node ||
+				     tcolumns !=
+					msRawFrame.header.sense_node - 1)) {
+					dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_ADJH failed... ERROR %08X\n",
+						ERROR_PROD_TEST_DATA);
+					ret |= ERROR_PROD_TEST_DATA;
+					goto ERROR_LIMITS;
+				}
+
+
+				ret = checkLimitsMapAdjTotal(adj,
+					msRawFrame.header.force_node,
+					msRawFrame.header.sense_node - 1,
+					thresholds);
+				if (ret != OK) {
+					dev_err(info->dev, "production_test_data: checkLimitsAdj MS RAW ADJH failed... ERROR COUNT = %d\n",
+						ret);
+					dev_err(info->dev, "MS RAW ADJ HORIZONTAL MIN/MAX:.................FAIL\n\n");
+					count_fail += 1;
+					if (stop_on_fail == 1)
+						goto ERROR;
+				} else
+					dev_info(info->dev, "MS RAW ADJ HORIZONTAL MIN/MAX:.................OK\n");
+
+				if (thresholds != NULL) {
+					kfree(thresholds);
+					thresholds = NULL;
+				}
+			}
+
+			if (todo->MutualRawAdjGap) {
+				dev_info(info->dev, "MS RAW ADJ HORIZONTAL GAP:\n");
+
+				ret = parseProductionTestLimits(info,
+							path_limits,
+							&info->limit_file,
+							MS_RAW_ADJH_GAP,
+							&thresholds, &trows,
+							&tcolumns);
+				if (ret < OK || (trows != 1 ||
+					 tcolumns != 1)) {
+					dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_ADJH failed... ERROR %08X\n",
+						ERROR_PROD_TEST_DATA);
+					ret |= ERROR_PROD_TEST_DATA;
+					goto ERROR_LIMITS;
+				}
+
+
+				ret = checkLimitsGapOffsets(adj,
+						     msRawFrame.header.
+						     force_node,
+						     msRawFrame.header.
+						     sense_node - 1,
+						     thresholds[0],
+						     1, 1, 1, 1);
+				if (ret != OK) {
+					dev_err(info->dev, "production_test_data: checkLimitsAdj MS RAW ADJH GAP failed...\n");
+					dev_err(info->dev, "MS RAW ADJ HORIZONTAL GAP:.................FAIL\n\n");
+					count_fail += 1;
+					if (stop_on_fail == 1)
+						goto ERROR;
+				} else
+					dev_info(info->dev, "MS RAW ADJ HORIZONTAL GAP:.................OK\n");
+
+				if (thresholds != NULL) {
+					kfree(thresholds);
+					thresholds = NULL;
+				}
+			}
+
+
+			if (todo->MutualRawAdjPeak) {
+				int force_node = msRawFrame.header.force_node;
+				int sense_node = msRawFrame.header.sense_node;
+
+				dev_info(info->dev, "MS RAW ADJ Peak: Getting max ADJH\n");
+				maxAdjH = abs(adj[force_node + 1]);
+				/* skip nodes on the edges */
+				for (i = 1; i < force_node - 1; i++) {
+					for (z = 1; z < sense_node - 2; z++) {
+						maxAdjH =
+						max(maxAdjH,
+						abs(adj[(i * force_node) + z]));
+					}
+				}
+			}
+
+			kfree(adj);
+			adj = NULL;
+
+			dev_info(info->dev, "MS RAW ADJ VERTICAL TESTs:\n");
+			ret = computeAdjVertTotal(msRawFrame.node_data,
+						  msRawFrame.header.force_node,
+						  msRawFrame.header.sense_node,
+						  &adj);
+			if (ret < OK) {
+				dev_err(info->dev, "production_test_data: computeAdjVert failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			if (todo->MutualRawAdj) {
+				dev_info(info->dev, "MS RAW ADJ VERTICAL MIN/MAX:\n");
+				ret = parseProductionTestLimits(info,
+							path_limits,
+							&info->limit_file,
+							MS_RAW_ADJV,
+							&thresholds,
+							&trows,
+							&tcolumns);
+				if (ret < OK ||
+				    (trows !=
+					msRawFrame.header.force_node - 1 ||
+				     tcolumns !=
+					msRawFrame.header.sense_node)) {
+					dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_ADJV failed... ERROR %08X\n",
+						ERROR_PROD_TEST_DATA);
+					ret |= ERROR_PROD_TEST_DATA;
+					goto ERROR_LIMITS;
+				}
+
+
+				ret = checkLimitsMapAdjTotal(adj,
+					msRawFrame.header.force_node - 1,
+					msRawFrame.header.sense_node,
+					thresholds);
+				if (ret != OK) {
+					dev_err(info->dev, "production_test_data: checkLimitsAdj MS RAW ADJV failed... ERROR COUNT = %d\n",
+						ret);
+					dev_err(info->dev, "MS RAW ADJ VERTICAL MIN/MAX:.................FAIL\n\n");
+					count_fail += 1;
+					if (stop_on_fail == 1)
+						goto ERROR;
+				} else
+					dev_info(info->dev, "MS RAW ADJ VERTICAL MIN/MAX:.................OK\n");
+
+				if (thresholds != NULL) {
+					kfree(thresholds);
+					thresholds = NULL;
+				}
+			}
+
+			if (todo->MutualRawAdjGap) {
+				dev_err(info->dev, "MS RAW ADJ VERTICAL GAP:\n");
+				ret = parseProductionTestLimits(info,
+							path_limits,
+							&info->limit_file,
+							MS_RAW_ADJV_GAP,
+							&thresholds, &trows,
+							&tcolumns);
+				if (ret < OK || (trows != 1 ||
+					tcolumns != 1)) {
+					dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_ADJV_GAP failed... ERROR %08X\n",
+						ERROR_PROD_TEST_DATA);
+					ret |= ERROR_PROD_TEST_DATA;
+					goto ERROR_LIMITS;
+				}
+
+
+				ret = checkLimitsGapOffsets(adj,
+					msRawFrame.header.force_node - 1,
+					msRawFrame.header.sense_node,
+					thresholds[0], 1, 1, 1, 1);
+				if (ret != OK) {
+					dev_err(info->dev, "production_test_data: checkLimitsAdj MS RAW ADJV GAP failed... ERROR COUNT = %d\n",
+						ret);
+					dev_err(info->dev, "MS RAW ADJ VERTICAL GAP:.................FAIL\n\n");
+					count_fail += 1;
+					if (stop_on_fail == 1)
+						goto ERROR;
+				} else
+					dev_info(info->dev, "MS RAW ADJ VERTICAL GAP:.................OK\n");
+
+				if (thresholds != NULL) {
+					kfree(thresholds);
+					thresholds = NULL;
+				}
+			}
+
+			if (todo->MutualRawAdjPeak) {
+				int force_node = msRawFrame.header.force_node;
+				int sense_node = msRawFrame.header.sense_node;
+
+				dev_info(info->dev, "MS RAW ADJ Peak: Getting max ADJV\n");
+				maxAdjV = abs(adj[force_node + 1]);
+
+				/* skip nodes on the edges */
+				for (i = 1; i < (force_node - 2); i++) {
+					for (z = 1; z < sense_node - 1; z++) {
+						maxAdjV = (maxAdjV <
+							abs(adj[(i *
+							force_node) + z])) ?
+							abs(adj[(i *
+							force_node) + z]) :
+							maxAdjV;
+					}
+				}
+
+				ret = parseProductionTestLimits(info,
+							path_limits,
+							&info->limit_file,
+							MS_RAW_ADJ_PEAK,
+							&thresholds, &trows,
+							&tcolumns);
+				if (ret < OK || (trows != 1 ||
+					tcolumns != 1)) {
+					dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_ADJV_PEAK failed... ERROR %08X\n",
+						ERROR_PROD_TEST_DATA);
+					ret |= ERROR_PROD_TEST_DATA;
+					goto ERROR_LIMITS;
+				}
+
+				dev_info(info->dev, "maxAdjH = %d  maxAdjV = %d  threshold = %d\n",
+					maxAdjH, maxAdjV, thresholds[0]);
+
+				ret = OK;
+				if (maxAdjH > maxAdjV) {
+					if (maxAdjH > thresholds[0])
+						ret = ERROR_PROD_TEST_DATA;
+				} else {
+					if (maxAdjV > thresholds[0])
+						ret = ERROR_PROD_TEST_DATA;
+				}
+
+				if (ret != OK) {
+					dev_err(info->dev, "production_test_data: checkLimitsAdj MS RAW ADJV GAP failed... ERROR COUNT = %d\n",
+						ret);
+					dev_err(info->dev, "MS RAW ADJ PEAK:.................FAIL\n\n");
+					count_fail += 1;
+					if (stop_on_fail == 1)
+						goto ERROR;
+				} else
+					dev_info(info->dev, "MS RAW ADJ PEAK:.................OK\n");
+
+				if (thresholds != NULL) {
+					kfree(thresholds);
+					thresholds = NULL;
+				}
+
+			}
+
+			kfree(adj);
+			adj = NULL;
+		} else
+			dev_info(info->dev, "MS RAW ADJ TEST:.................SKIPPED\n");
+	} else
+		dev_info(info->dev, "MS RAW FRAME TEST:.................SKIPPED\n");
+
+	dev_info(info->dev, "MS KEY RAW TEST:\n");
+	if (todo->MutualKeyRaw == 1) {
+		ret = production_test_ms_key_raw(info, path_limits);
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: production_test_ms_key_raw failed... ERROR = %08X\n",
+				ret);
+			count_fail += 1;
+			if (count_fail == 1) {
+				dev_err(info->dev, "MS RAW DATA TEST:.................FAIL fails_count = %d\n\n",
+					count_fail);
+				goto ERROR_LIMITS;
+			}
+		}
+	} else
+		dev_info(info->dev, "MS KEY RAW TEST:.................SKIPPED\n");
+
+	ret = production_test_ms_raw_lp(info, path_limits, stop_on_fail);
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: production_test_ms_raw_lp failed... ERROR = %08X\n",
+			ret);
+		count_fail += 1;
+		if (count_fail == 1) {
+			dev_err(info->dev, "MS RAW DATA TEST:.................FAIL fails_count = %d\n\n",
+				count_fail);
+			goto ERROR_LIMITS;
+		}
+	}
+
+ERROR:
+
+	if (count_fail == 0) {
+		if (msRawFrame.node_data != NULL) {
+			kfree(msRawFrame.node_data);
+			msRawFrame.node_data = NULL;
+		}
+		dev_info(info->dev, "MS RAW DATA TEST finished!.................OK\n");
+		return OK;
+	} else {
+		if (msRawFrame.node_data != NULL)
+			kfree(msRawFrame.node_data);
+		if (thresholds != NULL)
+			kfree(thresholds);
+		if (adj != NULL)
+			kfree(adj);
+		if (thresholds_min != NULL) {
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+		}
+		if (thresholds_max != NULL) {
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		}
+		dev_err(info->dev, "MS RAW DATA TEST:.................FAIL fails_count = %d\n\n",
+			count_fail);
+		return ERROR_PROD_TEST_DATA | ERROR_TEST_CHECK_FAIL;
+	}
+
+
+ERROR_LIMITS:
+	if (msRawFrame.node_data != NULL)
+		kfree(msRawFrame.node_data);
+	if (thresholds != NULL)
+		kfree(thresholds);
+	return ret;
+}
+
+
+/**
+  * Perform all the test selected in a TestTodo variable related to MS low power
+  * raw data
+  * @param path_limits name of Production Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @param stop_on_fail if 1, the test flow stops at the first data check
+  * failure
+  * otherwise it keeps going performing all the selected test
+  * @param todo pointer to a TestToDo variable which select the test to do
+  * @return OK if success or an error code which specify the type of error
+  */
+int production_test_ms_raw_lp(struct fts_ts_info *info,
+			      const char *path_limits, int stop_on_fail)
+{
+	int ret, count_fail = 0;
+	MutualSenseFrame msRawFrame;
+	TestToDo *todo = &info->tests;
+
+	int *thresholds = NULL;
+	int trows, tcolumns;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	u16 *adj = NULL;
+
+	msRawFrame.node_data = NULL;
+
+	/************** Mutual Sense Test **************/
+	dev_info(info->dev, "MS RAW LP DATA TEST:\n");
+	if (todo->MutualRawLP == 1 || todo->MutualRawGapLP == 1 ||
+	    todo->MutualRawAdjLP == 1 || todo->MutualRawMapLP) {
+		ret = setScanMode(info, SCAN_MODE_LOCKED, LOCKED_LP_ACTIVE);
+		msleep(WAIT_FOR_FRESH_FRAMES);
+		ret |= setScanMode(info, SCAN_MODE_ACTIVE, 0x00);
+		msleep(WAIT_AFTER_SENSEOFF);
+#ifdef READ_FILTERED_RAW
+		ret |= getMSFrame3(info, MS_FILTER, &msRawFrame);
+#else
+		ret |= getMSFrame3(info, MS_RAW, &msRawFrame);
+#endif
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: getMSFrame failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			return ret | ERROR_PROD_TEST_DATA;
+		}
+
+		print_frame_short(info, "MS Raw LP frame =",
+				  array1dTo2d_short(
+					  msRawFrame.node_data,
+					  msRawFrame.node_data_size,
+					  msRawFrame.header.sense_node),
+				  msRawFrame.header.force_node,
+				  msRawFrame.header.sense_node);
+
+		dev_info(info->dev, "MS RAW LP MIN MAX TEST:\n");
+		if (todo->MutualRawLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							MS_RAW_LP_MIN_MAX,
+							&thresholds, &trows,
+							&tcolumns);
+			if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_LP_MIN_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+
+			ret = checkLimitsMinMax(msRawFrame.node_data,
+						msRawFrame.header.force_node,
+						msRawFrame.header.sense_node,
+						thresholds[0],
+						thresholds[1]);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMinMax MS RAW LP failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "MS RAW LP MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "MS RAW LP MIN MAX TEST:.................OK\n");
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			dev_info(info->dev, "MS RAW LP MIN MAX TEST:.................SKIPPED\n");
+
+		dev_info(info->dev, "MS RAW LP MAP MIN MAX TEST:\n");
+		if (todo->MutualRawMapLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, MS_RAW_LP_EACH_NODE_MIN,
+				&thresholds_min, &trows, &tcolumns);
+			if (ret < OK ||
+			    (trows != msRawFrame.header.force_node ||
+			     tcolumns != msRawFrame.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_LP_EACH_NODE_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			ret = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, MS_RAW_LP_EACH_NODE_MAX,
+				&thresholds_max, &trows, &tcolumns);
+			if (ret < OK ||
+			    (trows != msRawFrame.header.force_node ||
+			     tcolumns != msRawFrame.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_LP_EACH_NODE_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			ret = checkLimitsMapTotal(msRawFrame.node_data,
+				msRawFrame.header.force_node,
+				msRawFrame.header.sense_node, thresholds_min,
+				thresholds_max);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMinMaxEachNodeData failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "MS RAW LP MAP MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else{
+				dev_info(info->dev, "MS RAW LP MAP MIN MAX TEST:.................OK\n");
+			}
+			if (thresholds_min != NULL) {
+				kfree(thresholds_min);
+				thresholds_min = NULL;
+			}
+			if (thresholds_max != NULL) {
+				kfree(thresholds_max);
+				thresholds_max = NULL;
+			}
+		} else
+			dev_info(info->dev, "MS RAW LP MAP MIN MAX TEST:.................SKIPPED\n");
+
+
+		dev_info(info->dev, "MS RAW LP GAP TEST:\n");
+		if (todo->MutualRawGapLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							MS_RAW_LP_GAP,
+							&thresholds, &trows,
+							&tcolumns);
+			if (ret < 0 || (trows != 1 || tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_LP_GAP failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsGap(msRawFrame.node_data,
+					     msRawFrame.header.force_node,
+					     msRawFrame.header.sense_node,
+					     thresholds[0]);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsGap MS RAW LP failed... ERROR = %08X\n",
+					ret);
+				count_fail += 1;
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "MS RAW LP GAP TEST:.................OK\n\n");
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			dev_info(info->dev, "MS RAW LP GAP TEST:.................SKIPPED\n");
+
+		dev_info(info->dev, "MS RAW LP ADJ TEST:\n");
+		if (todo->MutualRawAdjLP == 1) {
+			dev_info(info->dev, "MS RAW LP ADJ HORIZONTAL TEST:\n");
+			ret = computeAdjHorizTotal(msRawFrame.node_data,
+						   msRawFrame.header.force_node,
+						   msRawFrame.header.sense_node,
+						   &adj);
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjHoriz failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							MS_RAW_LP_ADJH,
+							&thresholds, &trows,
+							&tcolumns);
+			if (ret < 0 || (trows != msRawFrame.header.force_node ||
+					tcolumns !=
+					msRawFrame.header.sense_node - 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_LP_ADJH failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+
+			ret = checkLimitsMapAdjTotal(adj,
+						     msRawFrame.header.
+						     force_node,
+						     msRawFrame.header.
+						     sense_node - 1,
+						     thresholds);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsAdj MS RAW LP ADJH failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "MS RAW LP ADJ HORIZONTAL TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "MS RAW LP ADJ HORIZONTAL TEST:.................OK\n");
+
+			kfree(thresholds);
+			thresholds = NULL;
+
+			kfree(adj);
+			adj = NULL;
+
+			dev_info(info->dev, "MS RAW LP ADJ VERTICAL TEST:\n");
+			ret = computeAdjVertTotal(msRawFrame.node_data,
+						  msRawFrame.header.force_node,
+						  msRawFrame.header.sense_node,
+						  &adj);
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjVert failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							MS_RAW_LP_ADJV,
+							&thresholds, &trows,
+							&tcolumns);
+			if (ret < 0 || (trows != msRawFrame.header.force_node -
+					1 || tcolumns !=
+					msRawFrame.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_RAW_ADJV failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+
+			ret = checkLimitsMapAdjTotal(adj,
+						     msRawFrame.header.
+						     force_node - 1,
+						     msRawFrame.header.
+						     sense_node, thresholds);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsAdj MS RAW ADJV failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "MS RAW LP ADJ VERTICAL TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail == 1)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "MS RAW LP ADJ VERTICAL TEST:.................OK\n");
+			kfree(thresholds);
+			thresholds = NULL;
+
+			kfree(adj);
+			adj = NULL;
+		} else
+			dev_info(info->dev, "MS RAW LP ADJ TEST:.................SKIPPED\n");
+	} else
+		dev_info(info->dev, "MS RAW LP FRAME TEST:.................SKIPPED\n");
+
+ERROR:
+	if (count_fail == 0) {
+		if (msRawFrame.node_data != NULL) {
+			kfree(msRawFrame.node_data);
+			msRawFrame.node_data = NULL;
+		}
+		dev_info(info->dev, "MS RAW DATA TEST finished!.................OK\n");
+		return OK;
+	} else {
+		if (msRawFrame.node_data != NULL)
+			kfree(msRawFrame.node_data);
+		if (thresholds != NULL)
+			kfree(thresholds);
+		if (adj != NULL)
+			kfree(adj);
+		if (thresholds_min != NULL) {
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+		}
+		if (thresholds_max != NULL) {
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		}
+		dev_err(info->dev, "MS RAW LP DATA TEST:.................FAIL fails_count = %d\n\n",
+			count_fail);
+		return ERROR_PROD_TEST_DATA | ERROR_TEST_CHECK_FAIL;
+	}
+
+
+ERROR_LIMITS:
+	if (msRawFrame.node_data != NULL)
+		kfree(msRawFrame.node_data);
+	if (thresholds != NULL)
+		kfree(thresholds);
+	return ret;
+}
+
+/**
+  * Perform MS raw test for keys data
+  * @param path_limits name of Production Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @return OK if success or an error code which specify the type of error
+  */
+int production_test_ms_key_raw(struct fts_ts_info *info,
+			       const char *path_limits)
+{
+	int ret;
+	MutualSenseFrame msRawFrame;
+
+	int *thresholds = NULL;
+	int trows, tcolumns;
+
+	/************** Mutual Sense Test **************/
+	dev_info(info->dev, "MS KEY RAW DATA TEST is starting...\n");
+	ret = setScanMode(info, SCAN_MODE_ACTIVE, 0xFF);
+	msleep(WAIT_FOR_FRESH_FRAMES);
+	ret |= setScanMode(info, SCAN_MODE_ACTIVE, 0x00);
+	msleep(WAIT_AFTER_SENSEOFF);
+	ret |= getMSFrame3(info, MS_KEY_RAW, &msRawFrame);
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: getMSKeyFrame failed... ERROR %08X\n",
+			ERROR_PROD_TEST_DATA);
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	ret = parseProductionTestLimits(info, path_limits, &info->limit_file,
+					MS_KEY_RAW_MIN_MAX, &thresholds, &trows,
+					&tcolumns);
+	if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+		dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_KEY_RAW_MIN_MAX failed... ERROR %08X\n",
+			ERROR_PROD_TEST_DATA);
+		ret |= ERROR_PROD_TEST_DATA;
+		goto ERROR_LIMITS;
+	}
+
+	ret = checkLimitsMinMax(msRawFrame.node_data,
+				msRawFrame.header.force_node,
+				msRawFrame.header.sense_node,
+				thresholds[0], thresholds[1]);
+	if (ret != OK) {
+		dev_err(info->dev, "production_test_data: checkLimitsMinMax MS KEY RAW failed... ERROR COUNT = %d\n",
+			ret);
+		goto ERROR;
+	} else
+		dev_info(info->dev, "MS KEY RAW TEST:.................OK\n\n");
+
+	kfree(thresholds);
+	thresholds = NULL;
+
+	kfree(msRawFrame.node_data);
+	msRawFrame.node_data = NULL;
+	return OK;
+
+ERROR:
+	print_frame_short(info, "MS Key Raw frame =", array1dTo2d_short(
+				  msRawFrame.node_data,
+				  msRawFrame.node_data_size,
+				  msRawFrame.header.sense_node),
+			  msRawFrame.header.force_node,
+			  msRawFrame.header.sense_node);
+	if (msRawFrame.node_data != NULL)
+		kfree(msRawFrame.node_data);
+	if (thresholds != NULL)
+		kfree(thresholds);
+	dev_err(info->dev, "MS KEY RAW TEST:.................FAIL\n\n");
+	return ERROR_PROD_TEST_DATA | ERROR_TEST_CHECK_FAIL;
+
+ERROR_LIMITS:
+	if (msRawFrame.node_data != NULL)
+		kfree(msRawFrame.node_data);
+	if (thresholds != NULL)
+		kfree(thresholds);
+	return ret;
+}
+
+/**
+  * Perform all the tests selected in a TestTodo variable related to MS Init
+  * data (touch, keys etc..)
+  * @param path_limits name of Production Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @param stop_on_fail if 1, the test flow stops at the first data check
+  * failure
+  * otherwise it keeps going performing all the selected test
+  * @param todo pointer to a TestToDo variable which select the test to do
+  * @return OK if success or an error code which specify the type of error
+  */
+int production_test_ms_cx(struct fts_ts_info *info, const char *path_limits,
+			  int stop_on_fail)
+{
+	int ret;
+	int count_fail = 0;
+
+	int *thresholds = NULL;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	int trows, tcolumns;
+
+	MutualSenseData msCompData;
+	TotMutualSenseData totCompData;
+
+	u8 *adjhor = NULL;
+
+	u8 *adjvert = NULL;
+
+	u16 container;
+	/* u16 *total_cx = NULL; */
+	u16 *total_adjhor = NULL;
+	u16 *total_adjvert = NULL;
+	TestToDo *todo = &info->tests;
+
+	/* MS CX TEST */
+	dev_info(info->dev, "MS CX Testes are starting...\n");
+
+	ret = readMutualSenseCompensationData(info, LOAD_CX_MS_TOUCH, &msCompData);
+	/* read MS compensation data */
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: readMutualSenseCompensationData failed... ERROR %08X\n",
+			ERROR_PROD_TEST_DATA);
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	ret = readTotMutualSenseCompensationData(info, LOAD_PANEL_CX_TOT_MS_TOUCH,
+						 &totCompData);
+	/* read  TOT MS compensation data */
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: readTotMutualSenseCompensationData failed... ERROR %08X\n",
+			ERROR_PROD_TEST_DATA);
+		kfree(msCompData.node_data);
+		msCompData.node_data = NULL;
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	dev_info(info->dev, "MS CX1 TEST:\n");
+	if (todo->MutualCx1 == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_CX1_MIN_MAX, &thresholds,
+						&trows, &tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_CX1_MIN_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (u16)msCompData.cx1;
+		ret = checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					thresholds[1]);
+		/* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMinMax MS CX1 failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "MS CX1 TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "MS CX1 TEST:.................OK\n\n");
+	} else
+		dev_info(info->dev, "MS CX1 TEST:.................SKIPPED\n\n");
+
+	kfree(thresholds);
+	thresholds = NULL;
+
+	dev_info(info->dev, "MS CX2 MIN MAX TEST:\n");
+	if (todo->MutualCx2 == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_CX2_MAP_MIN, &thresholds_min,
+						&trows, &tcolumns);
+						/* load min thresholds */
+		if (ret < 0 || (trows != msCompData.header.force_node ||
+				tcolumns != msCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_CX2_MAP_MIN failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_CX2_MAP_MAX, &thresholds_max,
+						&trows, &tcolumns);
+						/* load max thresholds */
+		if (ret < 0 || (trows != msCompData.header.force_node ||
+				tcolumns != msCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_CX2_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMap(msCompData.node_data,
+				     msCompData.header.force_node,
+				     msCompData.header.sense_node,
+				     thresholds_min, thresholds_max);
+					 /* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap MS CX2 MIN MAX failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "MS CX2 MIN MAX TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "MS CX2 MIN MAX TEST:.................OK\n\n");
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		dev_info(info->dev, "MS CX2 MIN MAX TEST:.................SKIPPED\n\n");
+
+	dev_info(info->dev, "MS CX2 ADJ TEST:\n");
+	if (todo->MutualCx2Adj == 1) {
+		/* MS CX2 ADJ HORIZ */
+		dev_info(info->dev, "MS CX2 ADJ HORIZ TEST:\n");
+
+		ret = computeAdjHoriz(msCompData.node_data,
+				      msCompData.header.force_node,
+				      msCompData.header.sense_node,
+				      &adjhor);
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: computeAdjHoriz failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		dev_info(info->dev, "MS CX2 ADJ HORIZ computed!\n");
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_CX2_ADJH_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		if (ret < 0 || (trows != msCompData.header.force_node ||
+				tcolumns != msCompData.header.sense_node - 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_CX2_ADJH_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjhor, msCompData.header.force_node,
+					msCompData.header.sense_node - 1,
+					thresholds_max);
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMapAdj CX2 ADJH failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "MS CX2 ADJ HORIZ TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "MS CX2 ADJ HORIZ TEST:.................OK\n\n");
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjhor);
+		adjhor = NULL;
+
+		/* MS CX2 ADJ VERT */
+		dev_info(info->dev, "MS CX2 ADJ VERT TEST:\n");
+
+		ret = computeAdjVert(msCompData.node_data,
+				     msCompData.header.force_node,
+				     msCompData.header.sense_node,
+				     &adjvert);
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: computeAdjVert failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		dev_info(info->dev, "MS CX2 ADJ VERT computed!\n");
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_CX2_ADJV_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		if (ret < 0 || (trows != msCompData.header.force_node - 1 ||
+				tcolumns != msCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_CX2_ADJV_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjvert, msCompData.header.force_node -
+					1, msCompData.header.sense_node - 1,
+					thresholds_max);
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMapAdj CX2 ADJV failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "MS CX2 ADJ HORIZ TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "MS CX2 ADJ VERT TEST:.................OK\n\n");
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjvert);
+		adjvert = NULL;
+	} else
+		dev_info(info->dev, "MS CX2 ADJ TEST:.................SKIPPED\n\n");
+
+	/* START OF TOTAL CHECK */
+	dev_info(info->dev, "MS TOTAL CX TEST:\n");
+
+	if (todo->MutualCxTotal == 1 || todo->MutualCxTotalAdj == 1) {
+		dev_info(info->dev, "MS TOTAL CX MIN MAX TEST:\n");
+		if (todo->MutualCxTotal == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							MS_TOTAL_CX_MAP_MIN,
+							&thresholds_min,
+							&trows, &tcolumns);
+			/* load min thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_TOTAL_CX_MAP_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							MS_TOTAL_CX_MAP_MAX,
+							&thresholds_max,
+							&trows, &tcolumns);
+			/* load max thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_TOTAL_CX_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(totCompData.node_data,
+						  totCompData.header.force_node,
+						  totCompData.header.sense_node,
+						  thresholds_min,
+						  thresholds_max);
+			/* check the limits */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap  MS TOTAL CX TEST failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "MS TOTAL CX MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "MS TOTAL CX MIN MAX TEST:.................OK\n\n");
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			dev_info(info->dev, "MS TOTAL CX MIN MAX TEST:.................SKIPPED\n\n");
+
+
+		dev_info(info->dev, "MS TOTAL CX ADJ TEST:\n");
+		if (todo->MutualCxTotalAdj == 1) {
+			/* MS TOTAL CX ADJ HORIZ */
+			dev_info(info->dev, "MS TOTAL CX ADJ HORIZ TEST:\n");
+
+			ret = computeAdjHorizTotal(totCompData.node_data,
+					   totCompData.header.force_node,
+					   totCompData.header.sense_node,
+					   &total_adjhor);
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjHoriz failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			dev_info(info->dev, "MS TOTAL CX ADJ HORIZ computed!\n");
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_TOTAL_CX_ADJH_MAP_MAX,
+						&thresholds_max,
+						&trows, &tcolumns);
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns !=
+					totCompData.header.sense_node - 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_TOTAL_CX_ADJH_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjhor,
+						     totCompData.header.
+						     force_node,
+						     totCompData.header.
+						     sense_node - 1,
+						     thresholds_max);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMapAdj MS TOTAL CX ADJH failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "MS TOTAL CX ADJ HORIZ TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "MS TOTAL CX ADJ HORIZ TEST:.................OK\n\n");
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjhor);
+			total_adjhor = NULL;
+
+			/* MS TOTAL CX ADJ VERT */
+			dev_info(info->dev, "MS TOTAL CX ADJ VERT TEST:\n");
+
+			ret = computeAdjVertTotal(totCompData.node_data,
+						  totCompData.header.force_node,
+						  totCompData.header.sense_node,
+						  &total_adjvert);
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjVert failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			dev_info(info->dev, "MS TOTAL CX ADJ VERT computed!\n");
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_TOTAL_CX_ADJV_MAP_MAX,
+						&thresholds_max,
+						&trows, &tcolumns);
+			if (ret < 0 || (trows != totCompData.header.force_node -
+					1 || tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_TOTAL_CX_ADJV_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjvert,
+						     totCompData.header.
+						     force_node - 1,
+						     totCompData.header.
+						     sense_node - 1,
+						     thresholds_max);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMapAdj MS TOTAL CX ADJV failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "MS TOTAL CX ADJ HORIZ TEST:.................FAIL\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "MS TOTAL CX ADJ VERT TEST:.................OK\n");
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjvert);
+			total_adjvert = NULL;
+		} else
+			dev_info(info->dev, "MS TOTAL CX ADJ TEST:.................SKIPPED\n");
+
+		kfree(totCompData.node_data);
+		totCompData.node_data = NULL;
+	} else
+		dev_info(info->dev, "MS TOTAL CX TEST:.................SKIPPED\n");
+
+	if ((todo->MutualCx1LP | todo->MutualCx2LP | todo->MutualCx2AdjLP |
+	     todo->MutualCxTotalLP | todo->MutualCxTotalAdjLP) == 1) {
+		ret = production_test_ms_cx_lp(info, path_limits,
+					       stop_on_fail);
+		if (ret < OK) {
+			count_fail += 1;
+			dev_err(info->dev, "production_test_data: production_test_cx_lp failed... ERROR = %08X\n",
+				ret);
+			dev_err(info->dev, "MS CX testes finished!.................FAILED  fails_count = %d\n\n",
+				count_fail);
+			return ret;
+		}
+	} else
+		dev_info(info->dev, "MS CX LP TEST:.................SKIPPED\n");
+
+	if ((todo->MutualKeyCx1 | todo->MutualKeyCx2 |
+	     todo->MutualKeyCxTotal) == 1) {
+		ret = production_test_ms_key_cx(info, path_limits,
+						stop_on_fail);
+		if (ret < 0) {
+			count_fail += 1;
+			dev_err(info->dev, "production_test_data: production_test_ms_key_cx failed... ERROR = %08X\n",
+				ret);
+			dev_err(info->dev, "MS CX testes finished!.................FAILED  fails_count = %d\n\n",
+				count_fail);
+			return ret;
+		}
+	} else
+		dev_info(info->dev, "MS KEY CX TEST:.................SKIPPED\n");
+
+ERROR:
+
+	if (count_fail == 0) {
+		dev_info(info->dev, "MS CX testes finished!.................OK\n");
+		kfree(msCompData.node_data);
+		msCompData.node_data = NULL;
+		return OK;
+	} else {
+		print_frame_i8(info, "MS Init Data (Cx2) =", array1dTo2d_i8(
+				       msCompData.node_data,
+				       msCompData.node_data_size,
+				       msCompData.header.sense_node),
+			       msCompData.header.force_node,
+			       msCompData.header.sense_node);
+		print_frame_short(info, "TOT MS Init Data (Cx) =", array1dTo2d_short(
+					  totCompData.node_data,
+					  totCompData.node_data_size,
+					  totCompData.header.sense_node),
+				  totCompData.header.force_node,
+				  totCompData.header.sense_node);
+		dev_err(info->dev, "MS CX testes finished!.................FAILED  fails_count = %d\n\n",
+			count_fail);
+		if (thresholds != NULL)
+			kfree(thresholds);
+		if (thresholds_min != NULL)
+			kfree(thresholds_min);
+		if (thresholds_max != NULL)
+			kfree(thresholds_max);
+		if (adjhor != NULL)
+			kfree(adjhor);
+		if (adjvert != NULL)
+			kfree(adjvert);
+		if (totCompData.node_data != NULL)
+			kfree(totCompData.node_data);
+		if (total_adjhor != NULL)
+			kfree(total_adjhor);
+		if (total_adjvert != NULL)
+			kfree(total_adjvert);
+		if (msCompData.node_data != NULL)
+			kfree(msCompData.node_data);
+		return ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA;
+	}
+
+ERROR_LIMITS:
+	if (thresholds != NULL)
+		kfree(thresholds);
+	if (thresholds_min != NULL)
+		kfree(thresholds_min);
+	if (thresholds_max != NULL)
+		kfree(thresholds_max);
+	if (adjhor != NULL)
+		kfree(adjhor);
+	if (adjvert != NULL)
+		kfree(adjvert);
+	if (totCompData.node_data != NULL)
+		kfree(totCompData.node_data);
+	if (total_adjhor != NULL)
+		kfree(total_adjhor);
+	if (total_adjvert != NULL)
+		kfree(total_adjvert);
+	if (msCompData.node_data != NULL)
+		kfree(msCompData.node_data);
+	return ret;
+}
+
+/**
+  * Perform all the tests selected in a TestTodo variable related to MS Init
+  * data of the keys
+  * @param path_limits name of Production Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @param stop_on_fail if 1, the test flow stops at the first data check
+  * failure
+  * otherwise it keeps going performing all the selected test
+  * @param todo pointer to a TestToDo variable which select the test to do
+  * @return OK if success or an error code which specify the type of error
+  */
+int production_test_ms_key_cx(struct fts_ts_info *info,
+			      const char *path_limits, int stop_on_fail)
+{
+	int ret;
+	int count_fail = 0;
+	int num_keys = 0;
+
+	int *thresholds = NULL;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	int trows, tcolumns;
+
+	MutualSenseData msCompData;
+	TotMutualSenseData totCompData;
+	TestToDo *todo = &info->tests;
+
+	short container;
+
+
+	/* MS CX TEST */
+	dev_info(info->dev, "MS KEY CX Testes are starting...\n");
+
+	ret = readMutualSenseCompensationData(info, LOAD_CX_MS_KEY, &msCompData);
+	/* read MS compensation data */
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: readMutualSenseCompensationData failed... ERROR %08X\n",
+			ERROR_PROD_TEST_DATA);
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	if (msCompData.header.force_node > msCompData.header.sense_node)
+		/* the meaningful data are only in the first row,
+		  * the other rows are only a copy of the first one */
+		num_keys = msCompData.header.force_node;
+	else
+		num_keys = msCompData.header.sense_node;
+
+	dev_info(info->dev, "MS KEY CX1 TEST:\n");
+	if (todo->MutualKeyCx1 == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_KEY_CX1_MIN_MAX, &thresholds,
+						&trows, &tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_KEY_CX1_MIN_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (short)msCompData.cx1;
+		ret = checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					thresholds[1]);
+		/* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMinMax MS CX1 failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "MS KEY CX1 TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "MS KEY CX1 TEST:.................OK\n\n");
+	} else
+		dev_info(info->dev, "MS KEY CX1 TEST:.................SKIPPED\n\n");
+
+	kfree(thresholds);
+	thresholds = NULL;
+
+	dev_info(info->dev, "MS KEY CX2 TEST:\n");
+	if (todo->MutualKeyCx2 == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_KEY_CX2_MAP_MIN,
+						&thresholds_min, &trows,
+						&tcolumns);
+		/* load min thresholds */
+		if (ret < 0 || (trows != msCompData.header.force_node  ||
+				tcolumns != msCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_KEY_CX2_MAP_MIN failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_KEY_CX2_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load max thresholds */
+		if (ret < 0 || (trows != msCompData.header.force_node  ||
+				tcolumns != msCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_KEY_CX2_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMap(msCompData.node_data,
+				     msCompData.header.force_node,
+				     msCompData.header.sense_node,
+				     thresholds_min, thresholds_max);
+		/* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap MS KEY CX2 failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "MS KEY CX2 TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "MS KEY CX2 TEST:.................OK\n\n");
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		dev_info(info->dev, "MS CX2 TEST:.................SKIPPED\n\n");
+
+	/* START OF TOTAL CHECK */
+	dev_info(info->dev, "MS KEY TOTAL CX TEST:\n");
+
+	if (todo->MutualKeyCxTotal == 1) {
+		ret = readTotMutualSenseCompensationData(info,
+			LOAD_PANEL_CX_TOT_MS_KEY, &totCompData);
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: computeTotalCx failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_KEY_TOTAL_CX_MAP_MIN,
+						&thresholds_min, &trows,
+						&tcolumns);
+		/* load min thresholds */
+		if (ret < 0 || (trows != totCompData.header.force_node ||
+				tcolumns != totCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_KEY_TOTAL_CX_MAP_MIN failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_KEY_TOTAL_CX_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load max thresholds */
+		if (ret < 0 || (trows != totCompData.header.force_node  ||
+				tcolumns != totCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_KEY_TOTAL_CX_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapTotal(totCompData.node_data,
+					  totCompData.header.force_node,
+					  totCompData.header.sense_node,
+					  thresholds_min, thresholds_max);
+		/* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap  MS TOTAL KEY CX TEST failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "MS KEY TOTAL CX TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "MS KEY TOTAL CX TEST:.................OK\n\n");
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+
+		kfree(totCompData.node_data);
+		totCompData.node_data = NULL;
+	} else
+		dev_info(info->dev, "MS KEY TOTAL CX TEST:.................SKIPPED\n");
+
+
+ERROR:
+	if (count_fail == 0) {
+		dev_info(info->dev, "MS KEY CX testes finished!.................OK\n");
+		kfree(msCompData.node_data);
+		msCompData.node_data = NULL;
+		return OK;
+	} else {
+		print_frame_i8(info, "MS Key Init Data (Cx2) =", array1dTo2d_i8(
+				       msCompData.node_data,
+				       msCompData.node_data_size,
+				       msCompData.header.sense_node),
+			       msCompData.header.force_node,
+			       msCompData.header.sense_node);
+		dev_err(info->dev, "MS Key CX testes finished!.................FAILED  fails_count = %d\n\n",
+			count_fail);
+		if (thresholds != NULL)
+			kfree(thresholds);
+		if (thresholds_min != NULL)
+			kfree(thresholds_min);
+		if (thresholds_max != NULL)
+			kfree(thresholds_max);
+		if (msCompData.node_data != NULL)
+			kfree(msCompData.node_data);
+		if (totCompData.node_data != NULL)
+			kfree(totCompData.node_data);
+		return ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA;
+	}
+
+ERROR_LIMITS:
+	if (thresholds != NULL)
+		kfree(thresholds);
+	if (thresholds_min != NULL)
+		kfree(thresholds_min);
+	if (thresholds_max != NULL)
+		kfree(thresholds_max);
+	if (msCompData.node_data != NULL)
+		kfree(msCompData.node_data);
+	if (totCompData.node_data != NULL)
+		kfree(totCompData.node_data);
+	return ret;
+}
+
+/**
+  * Perform all the tests selected in a TestTodo variable related to MS LowPower
+  * Init data (touch, keys etc..)
+  * @param path_limits name of Production Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @param stop_on_fail if 1, the test flow stops at the first data check
+  * failure otherwise it keeps going performing all the selected test
+  * @param todo pointer to a TestToDo variable which select the test to do
+  * @return OK if success or an error code which specify the type of error
+  */
+int production_test_ms_cx_lp(struct fts_ts_info *info, const char *path_limits,
+			     int stop_on_fail)
+{
+	int ret;
+	int count_fail = 0;
+
+	int *thresholds = NULL;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	int trows, tcolumns;
+
+	MutualSenseData msCompData;
+	TotMutualSenseData totCompData;
+
+	u8 *adjhor = NULL;
+
+	u8 *adjvert = NULL;
+
+	u16 container;
+	/* u16 *total_cx = NULL; */
+	u16 *total_adjhor = NULL;
+	u16 *total_adjvert = NULL;
+	TestToDo *todo = &info->tests;
+
+	/* MS CX TEST */
+	dev_info(info->dev, "MS LP CX Testes are starting...\n");
+
+	ret = readMutualSenseCompensationData(info, LOAD_CX_MS_LOW_POWER,
+						&msCompData);
+	/* read MS compensation data */
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: readMutualSenseCompensationData failed... ERROR %08X\n",
+			ERROR_PROD_TEST_DATA);
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	ret = readTotMutualSenseCompensationData(info, LOAD_PANEL_CX_TOT_MS_LOW_POWER,
+						 &totCompData);
+	/* read  TOT MS compensation data */
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: readTotMutualSenseCompensationData failed... ERROR %08X\n",
+			ERROR_PROD_TEST_DATA);
+		kfree(msCompData.node_data);
+		msCompData.node_data = NULL;
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	dev_info(info->dev, "MS LP CX1 TEST:\n");
+	if (todo->MutualCx1LP == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_CX1_LP_MIN_MAX, &thresholds,
+						&trows, &tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_CX1_LP_MIN_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (u16)msCompData.cx1;
+		ret = checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					thresholds[1]);
+		/* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMinMax MS LP CX1 failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "MS LP CX1 TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "MS LP CX1 TEST:.................OK\n\n");
+	} else
+		dev_info(info->dev, "MS LP CX1 TEST:.................SKIPPED\n\n");
+
+	kfree(thresholds);
+	thresholds = NULL;
+
+	dev_info(info->dev, "MS LP CX2 MIN MAX TEST:\n");
+	if (todo->MutualCx2LP == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_CX2_LP_MAP_MIN,
+						&thresholds_min,
+						&trows, &tcolumns);
+						/* load min thresholds */
+		if (ret < 0 || (trows != msCompData.header.force_node ||
+				tcolumns != msCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_CX2_LP_MAP_MIN failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_CX2_LP_MAP_MAX,
+						&thresholds_max,
+						&trows, &tcolumns);
+						/* load max thresholds */
+		if (ret < 0 || (trows != msCompData.header.force_node ||
+				tcolumns != msCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_CX2_LP_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMap(msCompData.node_data,
+				     msCompData.header.force_node,
+				     msCompData.header.sense_node,
+				     thresholds_min, thresholds_max);
+					 /* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap MS LP CX2 MIN MAX failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "MS LP CX2 MIN MAX TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "MS LP CX2 MIN MAX TEST:.................OK\n\n");
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		dev_err(info->dev, "MS LP CX2 MIN MAX TEST:.................SKIPPED\n\n");
+
+	dev_info(info->dev, "MS LP CX2 ADJ TEST:\n");
+	if (todo->MutualCx2AdjLP == 1) {
+		/* MS CX2 ADJ HORIZ */
+		dev_info(info->dev, "MS LP CX2 ADJ HORIZ TEST:\n");
+
+		ret = computeAdjHoriz(msCompData.node_data,
+				      msCompData.header.force_node,
+				      msCompData.header.sense_node,
+				      &adjhor);
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: computeAdjHoriz failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		dev_info(info->dev, "MS LP CX2 ADJ HORIZ computed!\n");
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_CX2_ADJH_LP_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		if (ret < 0 || (trows != msCompData.header.force_node ||
+				tcolumns != msCompData.header.sense_node - 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_CX2_ADJH_LP_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjhor, msCompData.header.force_node,
+					msCompData.header.sense_node - 1,
+					thresholds_max);
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMapAdj CX2 ADJH LP failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "MS LP CX2 ADJ HORIZ TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "MS LP CX2 ADJ HORIZ TEST:.................OK\n\n");
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjhor);
+		adjhor = NULL;
+
+		/* MS CX2 ADJ VERT */
+		dev_info(info->dev, "MS LP CX2 ADJ VERT TEST:\n");
+
+		ret = computeAdjVert(msCompData.node_data,
+				     msCompData.header.force_node,
+				     msCompData.header.sense_node,
+				     &adjvert);
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: computeAdjVert failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		dev_info(info->dev, "MS LP CX2 ADJ VERT computed!\n");
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_CX2_ADJV_LP_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		if (ret < 0 || (trows != msCompData.header.force_node - 1 ||
+				tcolumns != msCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_CX2_ADJV_LP_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjvert, msCompData.header.force_node -
+					1, msCompData.header.sense_node - 1,
+					thresholds_max);
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMapAdj CX2 ADJV LP failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "MS LP CX2 ADJ HORIZ TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "MS LP CX2 ADJ VERT TEST:.................OK\n\n");
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjvert);
+		adjvert = NULL;
+	} else
+		dev_info(info->dev, "MS LP CX2 ADJ TEST:.................SKIPPED\n\n");
+
+	/* START OF TOTAL CHECK */
+	dev_info(info->dev, "MS TOTAL LP CX TEST:\n");
+
+	if (todo->MutualCxTotalLP == 1 || todo->MutualCxTotalAdjLP == 1) {
+		dev_info(info->dev, "MS TOTAL LP CX MIN MAX TEST:\n");
+		if (todo->MutualCxTotalLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							MS_TOTAL_CX_LP_MAP_MIN,
+							&thresholds_min,
+							&trows, &tcolumns);
+			/* load min thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_TOTAL_CX_LP_MAP_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							MS_TOTAL_CX_LP_MAP_MAX,
+							&thresholds_max,
+							&trows, &tcolumns);
+			/* load max thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_TOTAL_CX_LP_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(totCompData.node_data,
+						  totCompData.header.force_node,
+						  totCompData.header.sense_node,
+						  thresholds_min,
+						  thresholds_max);
+			/* check the limits */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap  MS TOTAL CX LP TEST failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "MS TOTAL CX LP MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "MS TOTAL CX LP MIN MAX TEST:.................OK\n\n");
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			dev_info(info->dev, "MS TOTAL CX LP MIN MAX TEST:.................SKIPPED\n\n");
+
+
+		dev_info(info->dev, "MS TOTAL CX ADJ LP TEST:\n");
+		if (todo->MutualCxTotalAdjLP == 1) {
+			/* MS TOTAL CX ADJ HORIZ */
+			dev_info(info->dev, "MS TOTAL CX ADJ HORIZ LP TEST:\n");
+
+			ret = computeAdjHorizTotal(totCompData.node_data,
+						totCompData.header.force_node,
+						totCompData.header.sense_node,
+						&total_adjhor);
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjHoriz failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			dev_info(info->dev, "MS TOTAL CX ADJ HORIZ LP computed!\n");
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_TOTAL_CX_ADJH_LP_MAP_MAX,
+						&thresholds_max,
+						&trows, &tcolumns);
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns !=
+					totCompData.header.sense_node - 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_TOTAL_CX_ADJH_LP_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjhor,
+					totCompData.header.force_node,
+					totCompData.header.sense_node - 1,
+					thresholds_max);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMapAdj MS TOTAL CX ADJH LP failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "MS TOTAL CX ADJ HORIZ LP TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "MS TOTAL CX ADJ HORIZ LP TEST:.................OK\n\n");
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjhor);
+			total_adjhor = NULL;
+
+			/* MS TOTAL CX ADJ VERT */
+			dev_info(info->dev, "MS TOTAL CX ADJ VERT LP TEST:\n");
+
+			ret = computeAdjVertTotal(totCompData.node_data,
+						  totCompData.header.force_node,
+						  totCompData.header.sense_node,
+						  &total_adjvert);
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjVert failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			dev_info(info->dev, "MS TOTAL CX ADJ VERT LP computed!\n");
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						MS_TOTAL_CX_ADJV_LP_MAP_MAX,
+						&thresholds_max,
+						&trows, &tcolumns);
+			if (ret < 0 || (trows != totCompData.header.force_node -
+					1 || tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits MS_TOTAL_CX_ADJV_LP_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjvert,
+					totCompData.header.force_node - 1,
+					totCompData.header.sense_node - 1,
+					thresholds_max);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMapAdj MS TOTAL CX ADJV failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "MS TOTAL CX ADJ HORIZ LP TEST:.................FAIL\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "MS TOTAL CX ADJ VERT LP TEST:.................OK\n");
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjvert);
+			total_adjvert = NULL;
+		} else
+			dev_info(info->dev, "MS TOTAL CX ADJ LP TEST:.................SKIPPED\n");
+
+		kfree(totCompData.node_data);
+		totCompData.node_data = NULL;
+	} else
+		dev_info(info->dev, "MS TOTAL CX LP TEST:.................SKIPPED\n");
+
+
+
+ERROR:
+
+	if (count_fail == 0) {
+		dev_info(info->dev, "MS LP CX testes finished!.................OK\n");
+		kfree(msCompData.node_data);
+		msCompData.node_data = NULL;
+		return OK;
+	}
+
+	print_frame_i8(info, "MS LP Init Data (Cx2) =", array1dTo2d_i8(
+			       msCompData.node_data,
+			       msCompData.node_data_size,
+			       msCompData.header.sense_node),
+		       msCompData.header.force_node,
+		       msCompData.header.sense_node);
+	print_frame_short(info, " TOT MS LP Init Data (Cx) =",
+			array1dTo2d_short(
+				  totCompData.node_data,
+				  totCompData.node_data_size,
+				  totCompData.header.sense_node),
+			totCompData.header.force_node,
+			totCompData.header.sense_node);
+	dev_err(info->dev, "MS LP CX testes finished!.................FAILED  fails_count = %d\n\n",
+		count_fail);
+	if (thresholds != NULL)
+		kfree(thresholds);
+	if (thresholds_min != NULL)
+		kfree(thresholds_min);
+	if (thresholds_max != NULL)
+		kfree(thresholds_max);
+	if (adjhor != NULL)
+		kfree(adjhor);
+	if (adjvert != NULL)
+		kfree(adjvert);
+	if (totCompData.node_data != NULL)
+		kfree(totCompData.node_data);
+	if (total_adjhor != NULL)
+		kfree(total_adjhor);
+	if (total_adjvert != NULL)
+		kfree(total_adjvert);
+	if (msCompData.node_data != NULL)
+		kfree(msCompData.node_data);
+	return ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA;
+
+ERROR_LIMITS:
+	if (thresholds != NULL)
+		kfree(thresholds);
+	if (thresholds_min != NULL)
+		kfree(thresholds_min);
+	if (thresholds_max != NULL)
+		kfree(thresholds_max);
+	if (adjhor != NULL)
+		kfree(adjhor);
+	if (adjvert != NULL)
+		kfree(adjvert);
+	if (totCompData.node_data != NULL)
+		kfree(totCompData.node_data);
+	if (total_adjhor != NULL)
+		kfree(total_adjhor);
+	if (total_adjvert != NULL)
+		kfree(total_adjvert);
+	if (msCompData.node_data != NULL)
+		kfree(msCompData.node_data);
+	return ret;
+}
+
+/**
+  * Perform all the test selected in a TestTodo variable related to SS raw data
+  *(touch, keys etc..)
+  * @param path_limits name of Production Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @param stop_on_fail if 1, the test flow stops at the first data check
+  * failure
+  * otherwise it keeps going performing all the selected test
+  * @param todo pointer to a TestToDo variable which select the test to do
+  * @return OK if success or an error code which specify the type of error
+  */
+int production_test_ss_raw(struct fts_ts_info *info, const char *path_limits,
+			   int stop_on_fail)
+{
+	int ret;
+	int count_fail = 0;
+	int rows, columns;
+
+	SelfSenseFrame ssRawFrame;
+
+	int *thresholds = NULL;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	int trows, tcolumns;
+	TestToDo *todo = &info->tests;
+
+	/* SS TEST */
+	dev_info(info->dev, "SS RAW Testes are starting...\n");
+
+	/************** Self Sense Test **************/
+
+	dev_info(info->dev, "Getting SS Frame...\n");
+	ret = setScanMode(info, SCAN_MODE_LOCKED, LOCKED_ACTIVE);
+	msleep(WAIT_FOR_FRESH_FRAMES);
+	ret |= setScanMode(info, SCAN_MODE_ACTIVE, 0x00);
+	msleep(WAIT_AFTER_SENSEOFF);
+#ifdef READ_FILTERED_RAW
+	ret |= getSSFrame3(info, SS_FILTER, &ssRawFrame);
+#else
+	ret |= getSSFrame3(info, SS_RAW, &ssRawFrame);
+#endif
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: getSSFrame failed... ERROR %08X\n",
+			ERROR_PROD_TEST_DATA);
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	print_frame_short(info, "SS Raw force frame =",
+			  array1dTo2d_short(
+				  ssRawFrame.force_data,
+				  ssRawFrame.header.force_node,
+				  1),
+			  ssRawFrame.header.force_node, 1);
+	print_frame_short(info, "SS Raw sense frame =",
+			  array1dTo2d_short(
+				  ssRawFrame.sense_data,
+				  ssRawFrame.header.sense_node,
+				  ssRawFrame.header.sense_node),
+			  1, ssRawFrame.header.sense_node);
+
+	/* SS RAW (PROXIMITY) FORCE TEST */
+	dev_info(info->dev, "SS RAW FORCE TEST:\n");
+
+
+
+	if (todo->SelfForceRaw == 1 || todo->SelfForceRawGap == 1
+		|| todo->SelfForceRawMap == 1) {
+		columns = 1;	/* there are no data for the sense channels
+				  * because is a force frame
+				  */
+		rows = ssRawFrame.header.force_node;
+
+		dev_info(info->dev, "SS RAW FORCE MIN MAX TEST:\n");
+		if (todo->SelfForceRaw == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							SS_RAW_FORCE_MIN_MAX,
+							&thresholds, &trows,
+							&tcolumns);
+			if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_FORCE_MIN_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMinMax(ssRawFrame.force_data, rows,
+						columns, thresholds[0],
+						thresholds[1]);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMinMax SS RAW FORCE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS RAW (PROXIMITY) FORCE MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail) {
+					ret = ERROR_PROD_TEST_DATA |
+					      ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				dev_info(info->dev, "SS RAW FORCE MIN MAX TEST:.................OK\n\n");
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			dev_info(info->dev, "SS RAW FORCE MIN MAX TEST:.................SKIPPED\n\n");
+
+		dev_info(info->dev, "SS RAW FORCE MAP MIN MAX TEST:\n");
+		if (todo->SelfForceRawMap == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, SS_RAW_FORCE_EACH_NODE_MIN,
+				&thresholds_min, &trows, &tcolumns);
+			if (ret < OK || (trows != rows ||
+					 tcolumns != columns)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_FORCE_EACH_NODE_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			ret = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, SS_RAW_FORCE_EACH_NODE_MAX,
+				&thresholds_max, &trows, &tcolumns);
+			if (ret < OK || (trows != rows ||
+					 tcolumns != columns)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_FORCE_EACH_NODE_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(ssRawFrame.force_data, rows,
+						columns, thresholds_min,
+						thresholds_max);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMinMax SS RAW FORCE MAP failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS RAW FORCE MAP MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				print_frame_short(info, "SS Raw force frame =",
+						  array1dTo2d_short(
+							  ssRawFrame.force_data,
+							  rows *
+							  columns,
+							  columns), rows,
+						  columns);
+				if (stop_on_fail) {
+					ret = ERROR_PROD_TEST_DATA |
+					      ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				dev_info(info->dev, "SS RAW FORCE MAP MIN MAX TEST:.................OK\n\n");
+
+			if (thresholds_min != NULL) {
+				kfree(thresholds_min);
+				thresholds_min = NULL;
+			}
+			if (thresholds_max != NULL) {
+				kfree(thresholds_max);
+				thresholds_max = NULL;
+			}
+		} else
+			dev_info(info->dev, "SS RAW FORCE MAP MIN MAX TEST:.................SKIPPED\n\n");
+
+		dev_info(info->dev, "SS RAW FORCE GAP TEST:\n");
+		if (todo->SelfForceRawGap == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							SS_RAW_FORCE_GAP,
+							&thresholds, &trows,
+							&tcolumns);
+			if (ret < 0 || (trows != 1 || tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_FORCE_GAP failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsGap(ssRawFrame.force_data, rows,
+					     columns, thresholds[0]);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsGap SS RAW FORCE GAP failed... ERROR = %08X\n",
+					ret);
+				dev_err(info->dev, "SS RAW FORCE GAP TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail) {
+					ret = ERROR_PROD_TEST_DATA |
+					      ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				dev_info(info->dev, "SS RAW FORCE GAP TEST:.................OK\n\n");
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			dev_info(info->dev, "SS RAW FORCE GAP TEST:.................SKIPPED\n\n");
+
+		kfree(ssRawFrame.force_data);
+		ssRawFrame.force_data = NULL;
+	} else
+		dev_info(info->dev, "SS RAW FORCE TEST:.................SKIPPED\n\n");
+
+	/* SS RAW (PROXIMITY) SENSE TEST */
+	dev_info(info->dev, "SS RAW SENSE TEST:\n");
+
+	if (todo->SelfSenseRaw == 1 || todo->SelfSenseRawGap == 1 ||
+		todo->SelfSenseRawMap == 1) {
+		columns = ssRawFrame.header.sense_node;
+		rows = 1;	/* there are no data for the force channels
+				 * because is a sense frame
+				 */
+
+		dev_info(info->dev, "SS RAW SENSE MIN MAX TEST:\n");
+		if (todo->SelfSenseRaw == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							SS_RAW_SENSE_MIN_MAX,
+							&thresholds, &trows,
+							&tcolumns);
+			if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_SENSE_MIN_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMinMax(ssRawFrame.sense_data, rows,
+						columns, thresholds[0],
+						thresholds[1]);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMinMax SS RAW SENSE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS RAW SENSE MIN MAX TEST:.................FAIL\n");
+				count_fail += 1;
+				if (stop_on_fail) {
+					ret = ERROR_PROD_TEST_DATA |
+					      ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				dev_info(info->dev, "SS RAW SENSE MIN MAX TEST:.................OK\n");
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			dev_info(info->dev, "SS RAW SENSE MIN MAX TEST:.................SKIPPED\n");
+
+		dev_info(info->dev, "SS RAW SENSE MAP MIN MAX TEST:\n");
+		if (todo->SelfSenseRawMap == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, SS_RAW_SENSE_EACH_NODE_MIN,
+				&thresholds_min, &trows, &tcolumns);
+			if (ret < OK || (trows != rows ||
+					 tcolumns != columns)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_SENSE_EACH_NODE_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			ret = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, SS_RAW_SENSE_EACH_NODE_MAX,
+				&thresholds_max, &trows, &tcolumns);
+			if (ret < OK || (trows != rows ||
+					 tcolumns != columns)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_SENSE_EACH_NODE_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(ssRawFrame.sense_data, rows,
+						columns, thresholds_min,
+						thresholds_max);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMinMax SS RAW SENSE MAP failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS RAW SENSE MAP MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				print_frame_short(info, "SS Raw sense frame =",
+						  array1dTo2d_short(
+							  ssRawFrame.sense_data,
+							  rows *
+							  columns,
+							  columns), rows,
+						  columns);
+				if (stop_on_fail) {
+					ret = ERROR_PROD_TEST_DATA |
+					      ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				dev_info(info->dev, "SS RAW SENSE MAP MIN MAX TEST:.................OK\n\n");
+
+			if (thresholds_min != NULL) {
+				kfree(thresholds_min);
+				thresholds_min = NULL;
+			}
+			if (thresholds_max != NULL) {
+				kfree(thresholds_max);
+				thresholds_max = NULL;
+			}
+		} else
+			dev_info(info->dev, "SS RAW SENSE MAP MIN MAX TEST:.................SKIPPED\n\n");
+
+		dev_info(info->dev, "SS RAW SENSE GAP TEST:\n");
+		if (todo->SelfSenseRawGap == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							SS_RAW_SENSE_GAP,
+							&thresholds, &trows,
+							&tcolumns);
+			if (ret < 0 || (trows != 1 || tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_SENSE_GAP failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsGap(ssRawFrame.sense_data, rows,
+					     columns, thresholds[0]);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsGap SS RAW SENSE GAP failed... ERROR = %08X\n",
+					ret);
+				dev_err(info->dev, "SS RAW SENSE GAP TEST:.................FAIL\n");
+				count_fail += 1;
+				if (stop_on_fail) {
+					ret = ERROR_PROD_TEST_DATA |
+					      ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				dev_info(info->dev, "SS RAW SENSE GAP TEST:.................OK\n");
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			dev_info(info->dev, "SS RAW SENSE GAP TEST:.................SKIPPED\n");
+
+		kfree(ssRawFrame.sense_data);
+		ssRawFrame.sense_data = NULL;
+	} else
+		dev_info(info->dev, "SS RAW SENSE TEST:.................SKIPPED\n\n");
+
+	ret = production_test_ss_raw_lp(info, path_limits, stop_on_fail);
+	if (ret < OK) {
+		dev_err(info->dev, "production_test_data: ss_raw_lp failed... ERROR = %08X\n",
+			ret);
+		count_fail += 1;
+	}
+
+	if (count_fail == 0) {
+		dev_info(info->dev, "SS RAW testes finished!.................OK\n\n");
+		return OK;
+	}
+
+	dev_err(info->dev, "SS RAW testes finished!.................FAILED  fails_count = %d\n\n",
+		count_fail);
+	return ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA;
+
+
+ERROR_LIMITS:
+	if (ssRawFrame.force_data != NULL)
+		kfree(ssRawFrame.force_data);
+	if (ssRawFrame.sense_data != NULL)
+		kfree(ssRawFrame.sense_data);
+	if (thresholds != NULL)
+		kfree(thresholds);
+	if (thresholds_min != NULL)
+		kfree(thresholds_min);
+	if (thresholds_max != NULL)
+		kfree(thresholds_max);
+
+	return ret;
+}
+
+
+/*
+ * Perform all the test selected in a TestTodo variable related to SS raw data
+ * low power
+ * @param path_limits name of Production Limit file to load or
+ * "NULL" if the limits data should be loaded by a .h file
+ * @param stop_on_fail if 1, the test flow stops at the first data check
+ * failure
+ * otherwise it keeps going performing all the selected test
+ * @param todo pointer to a TestToDo variable which select the test to do
+ * @return OK if success or an error code which specify the type of error
+ */
+int production_test_ss_raw_lp(struct fts_ts_info *info,
+			      const char *path_limits, int stop_on_fail)
+{
+	int ret;
+	int count_fail = 0;
+	int rows, columns;
+
+	SelfSenseFrame ssRawFrame;
+
+	int *thresholds = NULL;
+	int trows, tcolumns;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+	TestToDo *todo = &info->tests;
+
+	/* SS TEST */
+	dev_info(info->dev, "SS RAW LP Testes are starting...\n");
+
+	/************** Self Sense Test **************/
+
+	dev_info(info->dev, "Getting SS LP Frame...\n");
+	ret = setScanMode(info, SCAN_MODE_LOCKED, LOCKED_LP_DETECT);
+	msleep(WAIT_FOR_FRESH_FRAMES);
+	ret |= setScanMode(info, SCAN_MODE_ACTIVE, 0x00);
+	msleep(WAIT_AFTER_SENSEOFF);
+#ifdef READ_FILTERED_RAW
+	ret |= getSSFrame3(info, SS_DETECT_FILTER, &ssRawFrame);
+#else
+	ret |= getSSFrame3(info, SS_DETECT_RAW, &ssRawFrame);
+#endif
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: getSSFrame failed... ERROR %08X\n",
+			ERROR_PROD_TEST_DATA);
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	print_frame_short(info, "SS Raw LP force frame =",
+			  array1dTo2d_short(
+				  ssRawFrame.force_data,
+				  ssRawFrame.header.force_node, 1),
+			  ssRawFrame.header.force_node, 1);
+	print_frame_short(info, "SS Raw LP sense frame =",
+			  array1dTo2d_short(
+				  ssRawFrame.sense_data,
+				  ssRawFrame.header.sense_node,
+				  ssRawFrame.header.sense_node),
+			  1, ssRawFrame.header.sense_node);
+
+	/* SS RAW (PROXIMITY) FORCE TEST */
+	dev_info(info->dev, "SS RAW LP FORCE TEST:\n");
+
+	if ((todo->SelfForceRawLP == 1 || todo->SelfForceRawGapLP == 1 ||
+		todo->SelfForceRawMapLP == 1) &&
+		ssRawFrame.header.force_node != 0) {
+		columns = 1;	/* there are no data for the sense channels
+				 *  because is a force frame
+				 */
+		rows = ssRawFrame.header.force_node;
+
+		dev_info(info->dev, "SS RAW LP FORCE MIN MAX TEST:\n");
+		if (todo->SelfForceRawLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							SS_RAW_LP_FORCE_MIN_MAX,
+							&thresholds,
+							&trows, &tcolumns);
+			if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_FORCE_MIN_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMinMax(ssRawFrame.force_data, rows,
+						columns, thresholds[0],
+						thresholds[1]);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMinMax SS RAW FORCE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS RAW LP FORCE MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail) {
+					ret = ERROR_PROD_TEST_DATA |
+					      ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				dev_info(info->dev, "SS RAW LP FORCE MIN MAX TEST:.................OK\n\n");
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			dev_info(info->dev, "SS RAW LP FORCE MIN MAX TEST:.................SKIPPED\n\n");
+
+		dev_info(info->dev, "SS RAW LP FORCE MAP MIN MAX TEST:\n");
+		if (todo->SelfForceRawMapLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, SS_RAW_LP_FORCE_EACH_NODE_MIN,
+				&thresholds_min, &trows, &tcolumns);
+			if (ret < OK || (trows != rows ||
+					 tcolumns != columns)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_LP_FORCE_EACH_NODE_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			ret = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, SS_RAW_LP_FORCE_EACH_NODE_MAX,
+				&thresholds_max, &trows, &tcolumns);
+			if (ret < OK || (trows != rows ||
+					 tcolumns != columns)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_LP_FORCE_EACH_NODE_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(ssRawFrame.force_data, rows,
+						columns, thresholds_min,
+						thresholds_max);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMinMax SS RAW LP FORCE MAP failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS RAW LP FORCE MAP MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				print_frame_short(info, "SS Raw LP force frame =",
+						  array1dTo2d_short(
+							  ssRawFrame.force_data,
+							  rows *
+							  columns,
+							  columns), rows,
+						  columns);
+				if (stop_on_fail) {
+					ret = ERROR_PROD_TEST_DATA |
+					      ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				dev_info(info->dev, "SS RAW FORCE LP MAP MIN MAX TEST:.................OK\n\n");
+
+			if (thresholds_min != NULL) {
+				kfree(thresholds_min);
+				thresholds_min = NULL;
+			}
+			if (thresholds_max != NULL) {
+				kfree(thresholds_max);
+				thresholds_max = NULL;
+			}
+		} else
+			dev_info(info->dev, "SS RAW FORCE LP MAP MIN MAX TEST:.................SKIPPED\n\n");
+
+		dev_info(info->dev, "SS RAW LP FORCE GAP TEST:\n");
+		if (todo->SelfForceRawGapLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							SS_RAW_LP_FORCE_GAP,
+							&thresholds, &trows,
+							&tcolumns);
+			if (ret < OK || (trows != 1 || tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_FORCE_GAP failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsGap(ssRawFrame.force_data, rows,
+					     columns, thresholds[0]);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsGap SS RAW FORCE GAP failed... ERROR = %08X\n",
+					ret);
+				dev_err(info->dev, "SS RAW LP FORCE GAP TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail) {
+					ret = ERROR_PROD_TEST_DATA |
+					      ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				dev_info(info->dev, "SS RAW LP FORCE GAP TEST:.................OK\n\n");
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			dev_info(info->dev, "SS RAW LP FORCE GAP TEST:.................SKIPPED\n\n");
+
+		kfree(ssRawFrame.force_data);
+		ssRawFrame.force_data = NULL;
+	} else
+		dev_info(info->dev, "SS RAW LP FORCE TEST:.................SKIPPED\n\n");
+
+	/* SS RAW (PROXIMITY) SENSE TEST */
+	dev_info(info->dev, "SS RAW LP SENSE TEST:\n");
+
+	if ((todo->SelfSenseRawLP == 1 || todo->SelfSenseRawGapLP == 1 ||
+		todo->SelfSenseRawMapLP == 1) &&
+		ssRawFrame.header.sense_node != 0){
+		columns = ssRawFrame.header.sense_node;
+		rows = 1;	/* there are no data for the force channels
+				 * because is a sense frame
+				 */
+
+		dev_info(info->dev, "SS RAW LP SENSE MIN MAX TEST:\n");
+		if (todo->SelfSenseRawLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							SS_RAW_LP_SENSE_MIN_MAX,
+							&thresholds,
+							&trows, &tcolumns);
+			if (ret < OK || (trows != 1 || tcolumns != 2)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_LP_SENSE_MIN_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMinMax(ssRawFrame.sense_data, rows,
+						columns, thresholds[0],
+						thresholds[1]);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMinMax SS RAW LP SENSE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS RAW LP SENSE MIN MAX TEST:.................FAIL\n");
+				count_fail += 1;
+				if (stop_on_fail) {
+					ret = ERROR_PROD_TEST_DATA |
+					      ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				dev_info(info->dev, "SS RAW SENSE MIN MAX TEST:.................OK\n");
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			dev_info(info->dev, "SS RAW LP SENSE MIN MAX TEST:.................SKIPPED\n");
+
+		dev_info(info->dev, "SS RAW LP SENSE MAP MIN MAX TEST:\n");
+		if (todo->SelfSenseRawMapLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, SS_RAW_LP_SENSE_EACH_NODE_MIN,
+				&thresholds_min, &trows, &tcolumns);
+			if (ret < OK || (trows != rows ||
+					 tcolumns != columns)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_LP_SENSE_EACH_NODE_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			ret = parseProductionTestLimits(info, path_limits,
+				&info->limit_file, SS_RAW_LP_SENSE_EACH_NODE_MAX,
+				&thresholds_max, &trows, &tcolumns);
+			if (ret < OK || (trows != rows ||
+					 tcolumns != columns)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_LP_SENSE_EACH_NODE_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(ssRawFrame.sense_data, rows,
+						columns, thresholds_min,
+						thresholds_max);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMinMax SS RAW LP SENSE MAP failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS RAW LP SENSE MAP MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				print_frame_short(info, "SS Raw LP sense frame =",
+						  array1dTo2d_short(
+							  ssRawFrame.sense_data,
+							  rows *
+							  columns,
+							  columns), rows,
+						  columns);
+				if (stop_on_fail) {
+					ret = ERROR_PROD_TEST_DATA |
+					      ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				dev_info(info->dev, "SS RAW LP SENSE MAP MIN MAX TEST:.................OK\n\n");
+
+			if (thresholds_min != NULL) {
+				kfree(thresholds_min);
+				thresholds_min = NULL;
+			}
+			if (thresholds_max != NULL) {
+				kfree(thresholds_max);
+				thresholds_max = NULL;
+			}
+		} else
+			dev_info(info->dev, "SS RAW LP SENSE MAP MIN MAX TEST:.................SKIPPED\n\n");
+
+		dev_info(info->dev, "SS RAW LP SENSE GAP TEST:\n");
+		if (todo->SelfSenseRawGapLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+							&info->limit_file,
+							SS_RAW_LP_SENSE_GAP,
+							&thresholds, &trows,
+							&tcolumns);
+			if (ret < OK || (trows != 1 || tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_RAW_LP_SENSE_GAP failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsGap(ssRawFrame.sense_data, rows,
+					     columns, thresholds[0]);
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsGap SS RAW LP SENSE GAP failed... ERROR = %08X\n",
+					ret);
+				dev_err(info->dev, "SS RAW LP SENSE GAP TEST:.................FAIL\n");
+				count_fail += 1;
+				if (stop_on_fail) {
+					ret = ERROR_PROD_TEST_DATA |
+					      ERROR_TEST_CHECK_FAIL;
+					goto ERROR_LIMITS;
+				}
+			} else
+				dev_info(info->dev, "SS RAW LP SENSE GAP TEST:.................OK\n");
+
+			kfree(thresholds);
+			thresholds = NULL;
+		} else
+			dev_info(info->dev, "SS RAW LP SENSE GAP TEST:.................SKIPPED\n");
+
+		kfree(ssRawFrame.sense_data);
+		ssRawFrame.sense_data = NULL;
+	} else
+		dev_info(info->dev, "SS RAW LP SENSE TEST:.................SKIPPED\n\n");
+
+	if (count_fail == 0) {
+		dev_info(info->dev, "SS RAW LP testes finished!.................OK\n\n");
+		return OK;
+	}
+
+	dev_err(info->dev, "SS RAW LP testes finished!.................FAILED  fails_count = %d\n\n",
+		count_fail);
+	return ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA;
+
+ERROR_LIMITS:
+	if (ssRawFrame.force_data != NULL)
+		kfree(ssRawFrame.force_data);
+	if (ssRawFrame.sense_data != NULL)
+		kfree(ssRawFrame.sense_data);
+	if (thresholds != NULL)
+		kfree(thresholds);
+	if (thresholds_min != NULL)
+		kfree(thresholds_min);
+	if (thresholds_max != NULL)
+		kfree(thresholds_max);
+
+	return ret;
+}
+
+/*
+ * Perform all the tests selected in a TestTodo variable related to SS Init
+ * data (touch, keys etc..)
+ * @param path_limits name of Production Limit file to load or
+ * "NULL" if the limits data should be loaded by a .h file
+ * @param stop_on_fail if 1, the test flow stops at the first data check
+ * failure
+ * otherwise it keeps going performing all the selected test
+ * @param todo pointer to a TestToDo variable which select the test to do
+ * @return OK if success or an error code which specify the type of error
+ */
+int production_test_ss_ix_cx(struct fts_ts_info *info, const char *path_limits,
+			     int stop_on_fail)
+{
+	int ret;
+	int count_fail = 0;
+
+	int *thresholds = NULL;
+	int trows, tcolumns;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+
+	SelfSenseData ssCompData;
+	TotSelfSenseData totCompData;
+
+	u8 *adjhor = NULL;
+	u8 *adjvert = NULL;
+
+	short container;
+
+	u16 *total_adjhor = NULL;
+	u16 *total_adjvert = NULL;
+	TestToDo *todo = &info->tests;
+
+	dev_info(info->dev, "SS IX CX testes are starting...\n");
+	ret = readSelfSenseCompensationData(info, LOAD_CX_SS_TOUCH, &ssCompData);
+	/* read the SS compensation data */
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: readSelfSenseCompensationData failed... ERROR %08X\n",
+			ERROR_PROD_TEST_DATA);
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	ret = readTotSelfSenseCompensationData(info, LOAD_PANEL_CX_TOT_SS_TOUCH,
+					       &totCompData);
+	/* read the TOT SS compensation data */
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: readTotSelfSenseCompensationData failed... ERROR %08X\n",
+			ERROR_PROD_TEST_DATA);
+		kfree(ssCompData.ix2_fm);
+		kfree(ssCompData.ix2_sn);
+		kfree(ssCompData.cx2_fm);
+		kfree(ssCompData.cx2_sn);
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	/************* SS FORCE IX **************/
+	/* SS IX1 FORCE TEST */
+	dev_info(info->dev, "SS IX1 FORCE TEST:\n");
+	if (todo->SelfForceIx1 == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX1_FORCE_MIN_MAX,
+						&thresholds, &trows, &tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX1_FORCE_MIN_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		container = (short)ssCompData.f_ix1;
+		ret = checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					thresholds[1]);
+		/* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMinMax SS IX1 FORCE TEST failed... ERROR COUNT = %d\n",
+				ret);
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS IX1 FORCE TEST:.................OK\n\n");
+	} else
+		dev_info(info->dev, "SS IX1 FORCE TEST:.................SKIPPED\n\n");
+
+	kfree(thresholds);
+	thresholds = NULL;
+	/* SS IX2 FORCE TEST */
+	dev_info(info->dev, "SS IX2 FORCE MIN MAX TEST:\n");
+	if (todo->SelfForceIx2 == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX2_FORCE_MAP_MIN,
+						&thresholds_min, &trows,
+						&tcolumns);
+		/* load the min thresholds */
+		if (ret < 0 || (trows != ssCompData.header.force_node ||
+				tcolumns != 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_FORCE_MAP_MIN failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX2_FORCE_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != ssCompData.header.force_node ||
+				tcolumns != 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_FORCE_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapFromU(ssCompData.ix2_fm,
+					  ssCompData.header.force_node, 1,
+					  thresholds_min,
+					  thresholds_max);	/* check the
+								 * values with
+								 * thresholds
+								 */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap SS IX2 FORCE failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS IX2 FORCE MIN MAX TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS IX2 FORCE MIN MAX TEST:.................OK\n\n");
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		dev_info(info->dev, "SS IX2 FORCE MIN MAX TEST:.................SKIPPED\n\n");
+
+	dev_info(info->dev, "SS IX2 FORCE ADJ TEST:\n");
+	if (todo->SelfForceIx2Adj == 1) {
+		/* SS IX2 FORCE ADJV TEST */
+		dev_info(info->dev, "SS IX2 FORCE ADJVERT TEST:\n");
+		ret = computeAdjVertFromU(ssCompData.ix2_fm,
+					  ssCompData.header.force_node, 1,
+					  &adjvert);
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: computeAdjVert SS IX2 FORCE ADJV failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		dev_info(info->dev, "SS IX2 FORCE ADJV computed!\n");
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX2_FORCE_ADJV_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);	/* load the max
+								 * thresholds
+								 */
+		if (ret < 0 || (trows != ssCompData.header.force_node - 1 ||
+				tcolumns != 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_FORCE_ADJV_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjvert, ssCompData.header.force_node -
+					1, 1, thresholds_max);	/* check the
+								 * values with
+								 * thresholds
+								 */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap SS IX2 FORCE failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS IX2 FORCE ADJV TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS IX2 FORCE ADJV TEST:.................OK\n\n");
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjvert);
+		adjvert = NULL;
+	} else
+		dev_info(info->dev, "SS IX2 FORCE ADJ TEST:.................SKIPPED\n\n");
+
+	/* SS TOTAL FORCE IX */
+	dev_info(info->dev, "SS TOTAL IX FORCE TEST:\n");
+	if (todo->SelfForceIxTotal == 1 || todo->SelfForceIxTotalAdj == 1) {
+		dev_info(info->dev, "SS TOTAL IX FORCE MIN MAX TEST:\n");
+		if (todo->SelfForceIxTotal == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_IX_FORCE_MAP_MIN,
+						&thresholds_min,
+						&trows, &tcolumns);
+						/* load the min thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_IX_FORCE_MAP_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_IX_FORCE_MAP_MAX,
+						&thresholds_max,
+						&trows, &tcolumns);
+						/* load the max thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_IX_FORCE_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotalFromU(totCompData.ix_fm,
+						totCompData.header.force_node,
+						1,
+						thresholds_min,
+						thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap  SS TOTAL IX FORCE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL IX FORCE MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL IX FORCE MIN MAX TEST:.................OK\n\n");
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL IX FORCE MIN MAX TEST:.................SKIPPED\n");
+
+		dev_info(info->dev, "SS TOTAL IX FORCE ADJ TEST:\n");
+		if (todo->SelfForceIxTotalAdj == 1) {
+			/* SS TOTAL IX FORCE ADJV TEST */
+			dev_info(info->dev, "SS TOTAL IX FORCE ADJVERT TEST:\n");
+			ret = computeAdjVertTotalFromU(totCompData.ix_fm,
+					totCompData.header.force_node, 1,
+					&total_adjvert);
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjVert SS TOTAL IX FORCE ADJV failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			dev_info(info->dev, "SS TOTAL IX FORCE ADJV computed!\n");
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_IX_FORCE_ADJV_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows != totCompData.header.force_node -
+					1 || tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_IX_FORCE_ADJV_MAP_MAX... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjvert,
+					totCompData.header.force_node - 1, 1,
+					thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap SS TOTAL IX FORCE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL IX FORCE ADJV TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL IX FORCE ADJV TEST:.................OK\n\n");
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjvert);
+			total_adjvert = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL IX FORCE ADJ TEST:.................SKIPPED\n");
+	} else
+		dev_info(info->dev, "SS TOTAL IX FORCE TEST:.................SKIPPED\n\n");
+
+
+	/************** SS SENSE IX **************/
+	/* SS IX1 SENSE TEST */
+	dev_info(info->dev, "SS IX1 SENSE TEST:\n");
+	if (todo->SelfSenseIx1 == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX1_SENSE_MIN_MAX,
+						&thresholds, &trows, &tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX1_SENSE_MIN_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (short)ssCompData.s_ix1;
+		ret = checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					thresholds[1]);
+		/* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMinMax SS IX1 SENSE TEST failed... ERROR COUNT = %d\n",
+				ret);
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS IX1 SENSE TEST:.................OK\n\n");
+	} else
+		dev_info(info->dev, "SS IX1 SENSE TEST:.................SKIPPED\n\n");
+
+	kfree(thresholds);
+	thresholds = NULL;
+	/* SS IX2 SENSE TEST */
+	dev_info(info->dev, "SS IX2 SENSE MIN MAX TEST:\n");
+	if (todo->SelfSenseIx2 == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX2_SENSE_MAP_MIN,
+						&thresholds_min, &trows,
+						&tcolumns);
+		/* load the min thresholds */
+		if (ret < 0 || (trows != 1 || tcolumns !=
+				ssCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_SENSE_MAP_MIN failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX2_SENSE_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != 1 || tcolumns !=
+				ssCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_SENSE_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapFromU(ssCompData.ix2_sn, 1,
+					  ssCompData.header.sense_node,
+					  thresholds_min, thresholds_max);
+		/* check the values with thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap SS IX2 SENSE failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS IX2 SENSE MIN MAX TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS IX2 SENSE MIN MAX TEST:.................OK\n\n");
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		dev_info(info->dev, "SS IX2 SENSE MIN MAX TEST:.................SKIPPED\n\n");
+
+	dev_info(info->dev, "SS IX2 SENSE ADJ TEST:\n");
+	if (todo->SelfSenseIx2Adj == 1) {
+		/* SS IX2 SENSE ADJH TEST */
+		dev_info(info->dev, "SS IX2 SENSE ADJHORIZ TEST:\n");
+		ret = computeAdjHorizFromU(ssCompData.ix2_sn, 1,
+					   ssCompData.header.sense_node,
+					   &adjhor);
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: computeAdjHoriz SS IX2 SENSE ADJH failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		dev_info(info->dev, "SS IX2 SENSE ADJ HORIZ computed!\n");
+
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX2_SENSE_ADJH_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != 1 || tcolumns !=
+				ssCompData.header.sense_node - 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_SENSE_ADJH_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjhor, 1,
+					ssCompData.header.sense_node - 1,
+					thresholds_max);
+		/* check the values with thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMapAdj SS IX2 SENSE ADJH failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS IX2 SENSE ADJH TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS IX2 SENSE ADJH TEST:.................OK\n\n");
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjhor);
+		adjhor = NULL;
+	} else
+		dev_info(info->dev, "SS IX2 SENSE ADJ TEST:.................SKIPPED\n");
+
+	/* SS TOTAL IX SENSE */
+	dev_info(info->dev, "SS TOTAL IX SENSE TEST:\n");
+	if (todo->SelfSenseIxTotal == 1 || todo->SelfSenseIxTotalAdj == 1) {
+		dev_info(info->dev, "SS TOTAL IX SENSE MIN MAX TEST:\n");
+		if (todo->SelfSenseIxTotal == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_IX_SENSE_MAP_MIN,
+						&thresholds_min,
+						&trows, &tcolumns);
+			/* load the min thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_IX_SENSE_MAP_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_IX_SENSE_MAP_MAX,
+						&thresholds_max,
+						&trows, &tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_IX_SENSE_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotalFromU(totCompData.ix_sn, 1,
+						totCompData.header.sense_node,
+						thresholds_min,
+						thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap SS TOTAL IX SENSE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL IX SENSE MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL IX SENSE MIN MAX TEST:.................OK\n\n");
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL IX SENSE MIN MAX TEST:.................SKIPPED\n");
+
+
+		dev_info(info->dev, "SS TOTAL IX SENSE ADJ TEST:\n");
+		if (todo->SelfSenseIxTotalAdj == 1) {
+			/* SS TOTAL IX SENSE ADJH TEST */
+			dev_info(info->dev, "SS TOTAL IX SENSE ADJHORIZ TEST:\n");
+			ret = computeAdjHorizTotalFromU(totCompData.ix_sn, 1,
+						totCompData.header.sense_node,
+						&total_adjhor);
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjHoriz SS TOTAL IX SENSE ADJH failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			dev_info(info->dev, "SS TOTAL IX SENSE ADJ HORIZ computed!\n");
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_IX_SENSE_ADJH_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					totCompData.header.sense_node - 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_IX_SENSE_ADJH_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjhor, 1,
+					totCompData.header.sense_node - 1,
+					thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMapAdj SS TOTAL IX SENSE ADJH failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL IX SENSE ADJH TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL IX SENSE ADJH TEST:.................OK\n\n");
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjhor);
+			total_adjhor = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL IX SENSE ADJ TEST:.................SKIPPED\n");
+	} else
+		dev_info(info->dev, "SS TOTAL IX SENSE TEST:.................SKIPPED\n");
+
+	/************* SS SENSE CX **************/
+	/* SS CX1 FORCE TEST */
+	dev_info(info->dev, "SS CX1 FORCE TEST:\n");
+	if (todo->SelfForceCx1 == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX1_FORCE_MIN_MAX,
+						&thresholds, &trows, &tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX1_FORCE_MIN_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (short)ssCompData.f_cx1;
+		ret = checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					thresholds[1]);
+		/* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMinMax SS CX1 FORCE TEST failed... ERROR COUNT = %d\n",
+				ret);
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS CX1 FORCE TEST:.................OK\n\n");
+		kfree(thresholds);
+		thresholds = NULL;
+	} else
+		dev_info(info->dev, "SS CX1 FORCE TEST:.................SKIPPED\n\n");
+
+	/* SS CX2 FORCE TEST */
+	dev_info(info->dev, "SS CX2 FORCE MIN MAX TEST:\n");
+	if (todo->SelfForceCx2 == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX2_FORCE_MAP_MIN,
+						&thresholds_min, &trows,
+						&tcolumns);
+		/* load the min thresholds */
+		if (ret < 0 || (trows != ssCompData.header.force_node ||
+				tcolumns != 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX2_FORCE_MAP_MIN failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX2_FORCE_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != ssCompData.header.force_node ||
+				tcolumns != 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX2_FORCE_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMap(ssCompData.cx2_fm,
+				     ssCompData.header.force_node, 1,
+				     thresholds_min,
+				     thresholds_max);
+		/* check the values with thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap SS CX2 FORCE failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS CX2 FORCE MIN MAX TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS CX2 FORCE MIN MAX TEST:.................OK\n\n");
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		dev_info(info->dev, "SS CX2 FORCE MIN MAX TEST:.................SKIPPED\n");
+
+	dev_info(info->dev, "SS CX2 FORCE ADJ TEST:\n");
+	if (todo->SelfForceCx2Adj == 1) {
+		/* SS CX2 FORCE ADJV TEST */
+		dev_info(info->dev, "SS CX2 FORCE ADJVERT TEST:\n");
+		ret = computeAdjVert(ssCompData.cx2_fm,
+				     ssCompData.header.force_node, 1, &adjvert);
+		/* compute the ADJV for CX2  FORCE */
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: computeAdjVert SS CX2 FORCE ADJV failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		dev_info(info->dev, "SS CX2 FORCE ADJV computed!\n");
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX2_FORCE_ADJV_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != ssCompData.header.force_node - 1 ||
+				tcolumns != 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX2_FORCE_ADJV_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjvert, ssCompData.header.force_node -
+					1, 1, thresholds_max);
+		/* check the values with thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap SS IX2 FORCE failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS CX2 FORCE ADJV TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS CX2 FORCE ADJV TEST:.................OK\n\n");
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjvert);
+		adjvert = NULL;
+	} else
+		dev_info(info->dev, "SS CX2 FORCE ADJ TEST:.................SKIPPED\n\n");
+
+	/* SS TOTAL CX FORCE */
+	dev_info(info->dev, "SS TOTAL CX FORCE TEST:\n");
+	if (todo->SelfForceCxTotal == 1 || todo->SelfForceCxTotalAdj == 1) {
+		dev_info(info->dev, "SS TOTAL CX FORCE MIN MAX TEST:\n");
+		if (todo->SelfForceCxTotal == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_CX_FORCE_MAP_MIN,
+						&thresholds_min,
+						&trows, &tcolumns);
+			/* load the min thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_CX_FORCE_MAP_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_CX_FORCE_MAP_MAX,
+						&thresholds_max,
+						&trows, &tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_CX_FORCE_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(totCompData.cx_fm,
+						  totCompData.header.force_node,
+						  1, thresholds_min,
+						  thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap SS TOTAL FORCE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL FORCE MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL FORCE MIN MAX TEST:.................OK\n\n");
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL CX FORCE MIN MAX TEST:.................SKIPPED\n");
+
+		/* SS TOTAL CX FORCE ADJV TEST */
+		dev_info(info->dev, "SS TOTAL CX FORCE ADJ TEST:\n");
+		if (todo->SelfForceCxTotalAdj == 1) {
+			dev_info(info->dev, "SS TOTAL CX FORCE ADJVERT TEST:\n");
+			ret = computeAdjVertTotal(totCompData.cx_fm,
+						  totCompData.header.force_node,
+						  1, &total_adjvert);
+			/* compute the ADJV for CX2  FORCE */
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjVert SS TOTAL CX FORCE ADJV failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			dev_info(info->dev, "SS TOTAL CX FORCE ADJV computed!\n");
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_CX_FORCE_ADJV_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows != totCompData.header.force_node -
+					1 || tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_CX_FORCE_ADJV_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjvert,
+					totCompData.header.force_node - 1, 1,
+					thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap SS TOTAL CX FORCE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL CX FORCE ADJV TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL CX FORCE ADJV TEST:.................OK\n\n");
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjvert);
+			total_adjvert = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL CX FORCE ADJ TEST:.................SKIPPED\n");
+	} else
+		dev_info(info->dev, "SS TOTAL CX FORCE TEST:.................SKIPPED\n\n");
+
+
+
+	/************* SS SENSE CX *************/
+	/* SS CX1 SENSE TEST */
+	dev_info(info->dev, "SS CX1 SENSE TEST:\n");
+	if (todo->SelfSenseCx1 == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX1_SENSE_MIN_MAX,
+						&thresholds, &trows, &tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX1_SENSE_MIN_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (short)ssCompData.s_cx1;
+		ret = checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					thresholds[1]);
+		/* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMinMax SS CX1 SENSE TEST failed... ERROR COUNT = %d\n",
+				ret);
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS CX1 SENSE TEST:.................OK\n\n");
+
+		kfree(thresholds);
+		thresholds = NULL;
+	} else
+		dev_info(info->dev, "SS CX1 SENSE TEST:.................SKIPPED\n\n");
+
+
+	/* SS CX2 SENSE TEST */
+	dev_info(info->dev, "SS CX2 SENSE MIN MAX TEST:\n");
+	if (todo->SelfSenseCx2 == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX2_SENSE_MAP_MIN,
+						&thresholds_min, &trows,
+						&tcolumns);
+		/* load the min thresholds */
+		if (ret < 0 || (trows != 1 || tcolumns !=
+				ssCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX2_SENSE_MAP_MIN failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX2_SENSE_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != 1 || tcolumns !=
+				ssCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX2_SENSE_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMap(ssCompData.cx2_sn, 1,
+				     ssCompData.header.sense_node,
+				     thresholds_min, thresholds_max);
+		/* check the values with thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap SS CX2 SENSE failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS CX2 SENSE MIN MAX TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS CX2 SENSE MIN MAX TEST:.................OK\n\n");
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		dev_info(info->dev, "SS CX2 SENSE MIN MAX TEST:.................SKIPPED\n");
+
+	dev_info(info->dev, "SS CX2 SENSE ADJ TEST:\n");
+	if (todo->SelfSenseCx2Adj == 1) {
+		/* SS CX2 SENSE ADJH TEST */
+		dev_info(info->dev, "SS CX2 SENSE ADJHORIZ TEST:\n");
+		ret = computeAdjHoriz(ssCompData.cx2_sn, 1,
+				      ssCompData.header.sense_node, &adjhor);
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: computeAdjHoriz SS CX2 SENSE ADJH failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		dev_info(info->dev, "SS CX2 SENSE ADJH computed!\n");
+
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX2_SENSE_ADJH_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != 1 || tcolumns !=
+				ssCompData.header.sense_node - 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_SENSE_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjhor, 1,
+					ssCompData.header.sense_node - 1,
+					thresholds_max);
+		/* check the values with thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMapAdj SS CX2 SENSE ADJH failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS CX2 SENSE ADJH TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS CX2 SENSE ADJH TEST:.................OK\n");
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjhor);
+		adjhor = NULL;
+	} else
+		dev_info(info->dev, "SS CX2 SENSE ADJ TEST:.................SKIPPED\n\n");
+
+	/* SS TOTAL CX SENSE */
+	dev_info(info->dev, "SS TOTAL CX SENSE TEST:\n");
+	if (todo->SelfSenseCxTotal == 1 || todo->SelfSenseCxTotalAdj == 1) {
+		dev_info(info->dev, "SS TOTAL CX SENSE MIN MAX TEST:\n");
+		if (todo->SelfSenseCxTotal == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_CX_SENSE_MAP_MIN,
+						&thresholds_min,
+						&trows, &tcolumns);
+			/* load the min thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_CX_SENSE_MAP_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_CX_SENSE_MAP_MAX,
+						&thresholds_max,
+						&trows, &tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_CX_SENSE_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(totCompData.cx_sn, 1,
+						  totCompData.header.sense_node,
+						  thresholds_min,
+						  thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap SS TOTAL CX SENSE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL CX SENSE MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL CX SENSE MIN MAX TEST:.................OK\n\n");
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL CX SENSE MIN MAX TEST:.................SKIPPED\n");
+
+
+		/* SS TOTAL IX SENSE ADJH TEST */
+		dev_info(info->dev, "SS TOTAL CX SENSE ADJ TEST:\n");
+		if (todo->SelfSenseCxTotalAdj == 1) {
+			dev_info(info->dev, "SS TOTAL CX SENSE ADJHORIZ TEST:\n");
+			ret = computeAdjHorizTotal(totCompData.cx_sn, 1,
+					   totCompData.header.sense_node,
+					   &total_adjhor);
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjHoriz SS TOTAL CX SENSE ADJH failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			dev_info(info->dev, "SS TOTAL CX SENSE ADJ HORIZ computed!\n");
+
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_CX_SENSE_ADJH_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					totCompData.header.sense_node - 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_CX_SENSE_ADJH_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjhor, 1,
+					totCompData.header.sense_node - 1,
+					thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMapAdj SS TOTAL CX SENSE ADJH failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL CX SENSE ADJH TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL CX SENSE ADJH TEST:.................OK\n\n");
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjhor);
+			total_adjhor = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL CX SENSE ADJ TEST:.................SKIPPED\n");
+	} else
+		dev_info(info->dev, "SS TOTAL CX SENSE TEST:.................SKIPPED\n");
+
+	if ((todo->SelfSenseCx1LP | todo->SelfSenseCx2LP |
+		todo->SelfSenseCx2AdjLP | todo->SelfSenseCxTotalLP |
+		todo->SelfSenseCxTotalAdjLP | todo->SelfSenseIx1LP |
+		todo->SelfSenseIx2LP | todo->SelfSenseIx2AdjLP |
+		todo->SelfSenseIxTotalLP | todo->SelfSenseIxTotalAdjLP) == 1) {
+		ret = production_test_ss_ix_cx_lp(info, path_limits,
+			stop_on_fail);
+		if (ret < OK) {
+			count_fail += 1;
+			dev_err(info->dev, "production_test_data: production_test_ss_ix_cx_lp failed... ERROR = %08X\n",
+				ret);
+			goto ERROR;
+		}
+	} else
+		dev_info(info->dev, "SS IX CX LP TEST:.................SKIPPED\n");
+
+ERROR:
+	if (count_fail == 0) {
+		kfree(ssCompData.ix2_fm);
+		ssCompData.ix2_fm = NULL;
+		kfree(ssCompData.ix2_sn);
+		ssCompData.ix2_sn = NULL;
+		kfree(ssCompData.cx2_fm);
+		ssCompData.cx2_fm = NULL;
+		kfree(ssCompData.cx2_sn);
+		ssCompData.cx2_sn = NULL;
+		kfree(totCompData.ix_fm);
+		totCompData.ix_fm = NULL;
+		kfree(totCompData.ix_sn);
+		totCompData.ix_sn = NULL;
+		kfree(totCompData.cx_fm);
+		totCompData.cx_fm = NULL;
+		kfree(totCompData.cx_sn);
+		totCompData.cx_sn = NULL;
+		dev_info(info->dev, "SS IX CX testes finished!.................OK\n\n");
+		return OK;
+	}
+
+	/* print all kind of data in just one row for readability reason */
+	print_frame_u8(info, "SS Init Data Ix2_fm = ", array1dTo2d_u8(
+			       ssCompData.ix2_fm,
+			       ssCompData.header.force_node, 1),
+		       ssCompData.header.force_node, 1);
+	print_frame_i8(info, "SS Init Data Cx2_fm = ", array1dTo2d_i8(
+			       ssCompData.cx2_fm,
+			       ssCompData.header.force_node, 1),
+		       ssCompData.header.force_node, 1);
+	print_frame_u8(info, "SS Init Data Ix2_sn = ", array1dTo2d_u8(
+			       ssCompData.ix2_sn,
+			       ssCompData.header.sense_node,
+			       ssCompData.header.sense_node), 1,
+		       ssCompData.header.sense_node);
+	print_frame_i8(info, "SS Init Data Cx2_sn = ", array1dTo2d_i8(
+			       ssCompData.cx2_sn,
+			       ssCompData.header.sense_node,
+			       ssCompData.header.sense_node), 1,
+		       ssCompData.header.sense_node);
+	print_frame_u16(info, "TOT SS Init Data Ix_fm = ", array1dTo2d_u16(
+				totCompData.ix_fm,
+				totCompData.header.force_node, 1),
+			totCompData.header.force_node, 1);
+	print_frame_short(info, "TOT SS Init Data Cx_fm = ",
+			  array1dTo2d_short(totCompData.cx_fm,
+					    totCompData.header.force_node,
+					    1),
+			  totCompData.header.force_node, 1);
+	print_frame_u16(info, "TOT SS Init Data Ix_sn = ", array1dTo2d_u16(
+				totCompData.ix_sn,
+				totCompData.header.sense_node,
+				totCompData.header.sense_node), 1,
+			totCompData.header.sense_node);
+	print_frame_short(info, "TOT SS Init Data Cx_sn = ",
+			  array1dTo2d_short(totCompData.cx_sn,
+					    totCompData.header.sense_node,
+					    totCompData.header.sense_node),
+			  1, totCompData.header.sense_node);
+	dev_err(info->dev, "SS IX CX testes finished!.................FAILED  fails_count = %d\n\n",
+		count_fail);
+	if (thresholds != NULL)
+		kfree(thresholds);
+	if (thresholds_min != NULL)
+		kfree(thresholds_min);
+	if (thresholds_max != NULL)
+		kfree(thresholds_max);
+	if (adjhor != NULL)
+		kfree(adjhor);
+	if (adjvert != NULL)
+		kfree(adjvert);
+	if (total_adjhor != NULL)
+		kfree(total_adjhor);
+	if (total_adjvert != NULL)
+		kfree(total_adjvert);
+	if (ssCompData.ix2_fm != NULL)
+		kfree(ssCompData.ix2_fm);
+	if (ssCompData.ix2_sn != NULL)
+		kfree(ssCompData.ix2_sn);
+	if (ssCompData.cx2_fm != NULL)
+		kfree(ssCompData.cx2_fm);
+	if (ssCompData.cx2_sn != NULL)
+		kfree(ssCompData.cx2_sn);
+	if (totCompData.ix_fm != NULL)
+		kfree(totCompData.ix_fm);
+	if (totCompData.ix_sn != NULL)
+		kfree(totCompData.ix_sn);
+	if (totCompData.cx_fm != NULL)
+		kfree(totCompData.cx_fm);
+	if (totCompData.cx_sn != NULL)
+		kfree(totCompData.cx_sn);
+	return ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA;
+
+
+ERROR_LIMITS:
+	if (thresholds != NULL)
+		kfree(thresholds);
+	if (thresholds_min != NULL)
+		kfree(thresholds_min);
+	if (thresholds_max != NULL)
+		kfree(thresholds_max);
+	if (adjhor != NULL)
+		kfree(adjhor);
+	if (adjvert != NULL)
+		kfree(adjvert);
+	if (total_adjhor != NULL)
+		kfree(total_adjhor);
+	if (total_adjvert != NULL)
+		kfree(total_adjvert);
+	if (ssCompData.ix2_fm != NULL)
+		kfree(ssCompData.ix2_fm);
+	if (ssCompData.ix2_sn != NULL)
+		kfree(ssCompData.ix2_sn);
+	if (ssCompData.cx2_fm != NULL)
+		kfree(ssCompData.cx2_fm);
+	if (ssCompData.cx2_sn != NULL)
+		kfree(ssCompData.cx2_sn);
+	if (totCompData.ix_fm != NULL)
+		kfree(totCompData.ix_fm);
+	if (totCompData.ix_sn != NULL)
+		kfree(totCompData.ix_sn);
+	if (totCompData.cx_fm != NULL)
+		kfree(totCompData.cx_fm);
+	if (totCompData.cx_sn != NULL)
+		kfree(totCompData.cx_sn);
+	return ret;
+}
+
+/**
+  * Perform all the tests selected in a TestTodo variable related to SS Init
+  * data for LP mode (touch, keys etc..)
+  * @param path_limits name of Production Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @param stop_on_fail if 1, the test flow stops at the first data check
+  * failure
+  * otherwise it keeps going performing all the selected test
+  * @param todo pointer to a TestToDo variable which select the test to do
+  * @return OK if success or an error code which specify the type of error
+  */
+int production_test_ss_ix_cx_lp(struct fts_ts_info *info,
+			     const char *path_limits, int stop_on_fail)
+{
+	int ret;
+	int count_fail = 0;
+
+	int *thresholds = NULL;
+	int trows, tcolumns;
+	int *thresholds_min = NULL;
+	int *thresholds_max = NULL;
+
+	SelfSenseData ssCompData;
+	TotSelfSenseData totCompData;
+
+	u8 *adjhor = NULL;
+	u8 *adjvert = NULL;
+
+	short container;
+
+	u16 *total_adjhor = NULL;
+	u16 *total_adjvert = NULL;
+	TestToDo *todo = &info->tests;
+
+	dev_info(info->dev, "SS LP IX CX testes are starting...\n");
+	ret = readSelfSenseCompensationData(info, LOAD_CX_SS_TOUCH_IDLE, &ssCompData);
+	/* read the SS LP compensation data */
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: readSelfSenseCompensationData failed... ERROR %08X\n",
+			ERROR_PROD_TEST_DATA);
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	ret = readTotSelfSenseCompensationData(info, LOAD_PANEL_CX_TOT_SS_TOUCH_IDLE,
+					       &totCompData);
+	/* read the TOT SS LP compensation data */
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: readTotSelfSenseCompensationData failed... ERROR %08X\n",
+			ERROR_PROD_TEST_DATA);
+		kfree(ssCompData.ix2_fm);
+		kfree(ssCompData.ix2_sn);
+		kfree(ssCompData.cx2_fm);
+		kfree(ssCompData.cx2_sn);
+		return ret | ERROR_PROD_TEST_DATA;
+	}
+
+	/************* SS FORCE IX LP **************/
+	/* SS IX1 LP FORCE TEST */
+	dev_info(info->dev, "SS IX1 LP FORCE TEST:\n");
+	if (todo->SelfForceIx1LP == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX1_LP_FORCE_MIN_MAX,
+						&thresholds, &trows, &tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX1_LP_FORCE_MIN_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		container = (short)ssCompData.f_ix1;
+		ret = checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					thresholds[1]);
+		/* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMinMax SS IX1 LP FORCE TEST failed... ERROR COUNT = %d\n",
+				ret);
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS IX1 LP FORCE TEST:.................OK\n\n");
+	} else
+		dev_info(info->dev, "SS IX1 LP FORCE TEST:.................SKIPPED\n\n");
+
+	kfree(thresholds);
+	thresholds = NULL;
+	/* SS IX2 LP FORCE TEST */
+	dev_info(info->dev, "SS IX2 LP FORCE MIN MAX TEST:\n");
+	if (todo->SelfForceIx2LP == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX2_LP_FORCE_MAP_MIN,
+						&thresholds_min, &trows,
+						&tcolumns);
+		/* load the min thresholds */
+		if (ret < 0 || (trows != ssCompData.header.force_node ||
+				tcolumns != 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_LP_FORCE_MAP_MIN failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX2_LP_FORCE_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != ssCompData.header.force_node ||
+				tcolumns != 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_LP_FORCE_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapFromU(ssCompData.ix2_fm,
+					  ssCompData.header.force_node, 1,
+					  thresholds_min,
+					  thresholds_max);	/* check the
+								 * values with
+								 * thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap SS IX2 LP FORCE failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS IX2 LP FORCE MIN MAX TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS IX2 LP FORCE MIN MAX TEST:.................OK\n\n");
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		dev_info(info->dev, "SS IX2 LP FORCE MIN MAX TEST:.................SKIPPED\n\n");
+
+	dev_info(info->dev, "SS IX2 LP FORCE ADJ TEST:\n");
+	if (todo->SelfForceIx2AdjLP == 1) {
+		/* SS IX2 FORCE ADJV TEST */
+		dev_info(info->dev, "SS IX2 LP FORCE ADJVERT TEST:\n");
+		ret = computeAdjVertFromU(ssCompData.ix2_fm,
+					  ssCompData.header.force_node, 1,
+					  &adjvert);
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: computeAdjVert SS IX2 LP FORCE ADJV failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		dev_info(info->dev, "SS IX2 LP FORCE ADJV computed!\n");
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX2_LP_FORCE_ADJV_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);	/* load the max
+								 * thresholds */
+		if (ret < 0 || (trows != ssCompData.header.force_node - 1 ||
+				tcolumns != 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_LP_FORCE_ADJV_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjvert, ssCompData.header.force_node -
+					1, 1, thresholds_max);	/* check the
+								 * values with
+								 * thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap SS IX2 LP FORCE failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS IX2 LP FORCE ADJV TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS IX2 LP FORCE ADJV TEST:.................OK\n\n");
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjvert);
+		adjvert = NULL;
+	} else
+		dev_info(info->dev, "SS IX2 LP FORCE ADJ TEST:.................SKIPPED\n\n");
+
+	/* SS TOTAL FORCE IX */
+	dev_info(info->dev, "SS TOTAL IX LP FORCE TEST:\n");
+	if (todo->SelfForceIxTotalLP == 1 || todo->SelfForceIxTotalAdjLP == 1) {
+		dev_info(info->dev, "SS TOTAL IX LP FORCE MIN MAX TEST:\n");
+		if (todo->SelfForceIxTotalLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_IX_LP_FORCE_MAP_MIN,
+						&thresholds_min,
+						&trows, &tcolumns);
+						/* load the min thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_IX_LP_FORCE_MAP_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_IX_LP_FORCE_MAP_MAX,
+						&thresholds_max,
+						&trows, &tcolumns);
+						/* load the max thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_IX_LP_FORCE_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotalFromU(totCompData.ix_fm,
+						       totCompData.header.
+						       force_node, 1,
+						       thresholds_min,
+						       thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap  SS TOTAL IX LP FORCE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL IX LP FORCE MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL IX LP FORCE MIN MAX TEST:.................OK\n\n");
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL IX LP FORCE MIN MAX TEST:.................SKIPPED\n");
+
+		dev_info(info->dev, "SS TOTAL IX LP FORCE ADJ TEST:\n");
+		if (todo->SelfForceIxTotalAdjLP == 1) {
+			/* SS TOTAL IX FORCE ADJV TEST */
+			dev_info(info->dev, "SS TOTAL IX LP FORCE ADJVERT TEST:\n");
+			ret = computeAdjVertTotalFromU(totCompData.ix_fm,
+						       totCompData.header.
+						       force_node, 1,
+						       &total_adjvert);
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjVert SS TOTAL IX LP FORCE ADJV failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			dev_info(info->dev, "SS TOTAL IX LP FORCE ADJV computed!\n");
+
+			ret = parseProductionTestLimits(info, path_limits,
+					&info->limit_file,
+					SS_TOTAL_IX_LP_FORCE_ADJV_MAP_MAX,
+					&thresholds_max, &trows,
+					&tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows != totCompData.header.force_node -
+					1 || tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_IX_LP_FORCE_ADJV_MAP_MAX... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjvert,
+						     totCompData.header.
+						     force_node - 1, 1,
+						     thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap SS TOTAL IX LP FORCE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL IX LP FORCE ADJV TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL IX LP FORCE ADJV TEST:.................OK\n\n");
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjvert);
+			total_adjvert = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL IX LP FORCE ADJ TEST:.................SKIPPED\n");
+	} else
+		dev_info(info->dev, "SS TOTAL IX LP FORCE TEST:.................SKIPPED\n\n");
+
+
+	/************** SS SENSE IX LP **************/
+	/* SS IX1 LP SENSE TEST */
+	dev_info(info->dev, "SS IX1 LP SENSE TEST:\n");
+	if (todo->SelfSenseIx1LP == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX1_LP_SENSE_MIN_MAX,
+						&thresholds, &trows, &tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX1_LP_SENSE_MIN_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (short)ssCompData.s_ix1;
+		ret = checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					thresholds[1]);
+		/* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMinMax SS IX1 SENSE LP TEST failed... ERROR COUNT = %d\n",
+				ret);
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS IX1 LP SENSE TEST:.................OK\n\n");
+	} else
+		dev_info(info->dev, "SS IX1 LP SENSE TEST:.................SKIPPED\n\n");
+
+	kfree(thresholds);
+	thresholds = NULL;
+	/* SS IX2 SENSE TEST */
+	dev_info(info->dev, "SS IX2 LP SENSE MIN MAX TEST:\n");
+	if (todo->SelfSenseIx2LP == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX2_LP_SENSE_MAP_MIN,
+						&thresholds_min, &trows,
+						&tcolumns);
+		/* load the min thresholds */
+		if (ret < 0 || (trows != 1 || tcolumns !=
+				ssCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_LP_SENSE_MAP_MIN failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX2_LP_SENSE_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != 1 || tcolumns !=
+				ssCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_LP_SENSE_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapFromU(ssCompData.ix2_sn, 1,
+					  ssCompData.header.sense_node,
+					  thresholds_min, thresholds_max);
+		/* check the values with thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap SS IX2 LP SENSE failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS IX2 LP SENSE MIN MAX TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS IX2 LP SENSE MIN MAX TEST:.................OK\n\n");
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		dev_info(info->dev, "SS IX2 LP SENSE MIN MAX TEST:.................SKIPPED\n\n");
+
+	dev_info(info->dev, "SS IX2 LP SENSE ADJ TEST:\n");
+	if (todo->SelfSenseIx2AdjLP == 1) {
+		/* SS IX2 SENSE ADJH TEST */
+		dev_info(info->dev, "SS IX2 SENSE ADJHORIZ TEST:\n");
+		ret = computeAdjHorizFromU(ssCompData.ix2_sn, 1,
+					   ssCompData.header.sense_node,
+					   &adjhor);
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: computeAdjHoriz SS IX2 SENSE ADJH failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		dev_info(info->dev, "SS IX2 SENSE ADJ HORIZ computed!\n");
+
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_IX2_SENSE_ADJH_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != 1 || tcolumns !=
+				ssCompData.header.sense_node - 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_LP_SENSE_ADJH_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjhor, 1,
+					ssCompData.header.sense_node - 1,
+					thresholds_max);
+		/* check the values with thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMapAdj SS IX2 LP SENSE ADJH failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS IX2 LP SENSE ADJH TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS IX2 LP SENSE ADJH TEST:.................OK\n\n");
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjhor);
+		adjhor = NULL;
+	} else
+		dev_info(info->dev, "SS IX2 LP SENSE ADJ TEST:.................SKIPPED\n");
+
+	/* SS TOTAL IX SENSE */
+	dev_info(info->dev, "SS TOTAL IX LP SENSE TEST:\n");
+	if (todo->SelfSenseIxTotalLP == 1 || todo->SelfSenseIxTotalAdjLP == 1) {
+		dev_info(info->dev, "SS TOTAL IX LP SENSE MIN MAX TEST:\n");
+		if (todo->SelfSenseIxTotalLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_IX_LP_SENSE_MAP_MIN,
+						&thresholds_min,
+						&trows, &tcolumns);
+			/* load the min thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_IX_LP_SENSE_MAP_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_IX_LP_SENSE_MAP_MAX,
+						&thresholds_max,
+						&trows, &tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_IX_LP_SENSE_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotalFromU(totCompData.ix_sn, 1,
+						       totCompData.header.
+						       sense_node,
+						       thresholds_min,
+						       thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap SS TOTAL IX LP SENSE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL IX LP SENSE MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL IX LP SENSE MIN MAX TEST:.................OK\n\n");
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL IX LP SENSE MIN MAX TEST:.................SKIPPED\n");
+
+
+		dev_info(info->dev, "SS TOTAL IX LP SENSE ADJ TEST:\n");
+		if (todo->SelfSenseIxTotalAdjLP == 1) {
+			/* SS TOTAL IX SENSE ADJH TEST */
+			dev_info(info->dev, "SS TOTAL IX LP SENSE ADJHORIZ TEST:\n");
+			ret = computeAdjHorizTotalFromU(totCompData.ix_sn, 1,
+							totCompData.header.
+							sense_node,
+							&total_adjhor);
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjHoriz SS TOTAL IX LP SENSE ADJH failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			dev_info(info->dev, "SS TOTAL IX LP SENSE ADJ HORIZ computed!\n");
+
+
+			ret = parseProductionTestLimits(info, path_limits,
+					&info->limit_file,
+					SS_TOTAL_IX_LP_SENSE_ADJH_MAP_MAX,
+					&thresholds_max, &trows,
+					&tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					totCompData.header.sense_node - 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_IX_LP_SENSE_ADJH_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjhor, 1,
+						     totCompData.header.
+						     sense_node - 1,
+						     thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMapAdj SS TOTAL IX LP SENSE ADJH failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL IX LP SENSE ADJH TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL IX LP SENSE ADJH TEST:.................OK\n\n");
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjhor);
+			total_adjhor = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL IX LP SENSE ADJ TEST:.................SKIPPED\n");
+	} else
+		dev_info(info->dev, "SS TOTAL IX LP SENSE TEST:.................SKIPPED\n");
+
+	/************* SS SENSE CX LP **************/
+	/* SS CX1 LP FORCE TEST */
+	dev_info(info->dev, "SS CX1 LP FORCE TEST:\n");
+	if (todo->SelfForceCx1LP == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX1_LP_FORCE_MIN_MAX,
+						&thresholds, &trows, &tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX1_LP_FORCE_MIN_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (short)ssCompData.f_cx1;
+		ret = checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					thresholds[1]);
+		/* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMinMax SS CX1 LP FORCE TEST failed... ERROR COUNT = %d\n",
+				ret);
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS CX1 LP FORCE TEST:.................OK\n\n");
+		kfree(thresholds);
+		thresholds = NULL;
+	} else
+		dev_info(info->dev, "SS CX1 LP FORCE TEST:.................SKIPPED\n\n");
+
+
+
+	/* SS CX2 LP FORCE TEST */
+	dev_info(info->dev, "SS CX2 LP FORCE MIN MAX TEST:\n");
+	if (todo->SelfForceCx2LP == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX2_LP_FORCE_MAP_MIN,
+						&thresholds_min, &trows,
+						&tcolumns);
+		/* load the min thresholds */
+		if (ret < 0 || (trows != ssCompData.header.force_node ||
+				tcolumns != 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX2_LP_FORCE_MAP_MIN failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX2_LP_FORCE_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != ssCompData.header.force_node ||
+				tcolumns != 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX2_LP_FORCE_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMap(ssCompData.cx2_fm,
+				     ssCompData.header.force_node, 1,
+				     thresholds_min,
+				     thresholds_max);
+		/* check the values with thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap SS CX2 LP FORCE failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS CX2 LP FORCE MIN MAX TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS CX2 LP FORCE MIN MAX TEST:.................OK\n\n");
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		dev_info(info->dev, "SS CX2 LP FORCE MIN MAX TEST:.................SKIPPED\n");
+
+	dev_info(info->dev, "SS CX2 LP FORCE ADJ TEST:\n");
+	if (todo->SelfForceCx2AdjLP == 1) {
+		/* SS CX2 FORCE ADJV TEST */
+		dev_info(info->dev, "SS CX2 LP FORCE ADJVERT TEST:\n");
+		ret = computeAdjVert(ssCompData.cx2_fm,
+				     ssCompData.header.force_node, 1, &adjvert);
+		/* compute the ADJV for CX2  FORCE */
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: computeAdjVert SS CX2 LP FORCE ADJV failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		dev_info(info->dev, "SS CX2 LP FORCE ADJV computed!\n");
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX2_LP_FORCE_ADJV_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != ssCompData.header.force_node - 1 ||
+				tcolumns != 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX2_LP_FORCE_ADJV_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjvert, ssCompData.header.force_node -
+					1, 1, thresholds_max);
+		/* check the values with thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap SS IX2 LP FORCE failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS CX2 LP FORCE ADJV TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS CX2 LP FORCE ADJV TEST:.................OK\n\n");
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjvert);
+		adjvert = NULL;
+	} else
+		dev_info(info->dev, "SS CX2 LP FORCE ADJ TEST:.................SKIPPED\n\n");
+
+	/* SS TOTAL CX LP FORCE */
+	dev_info(info->dev, "SS TOTAL CX LP FORCE TEST:\n");
+	if (todo->SelfForceCxTotalLP == 1 || todo->SelfForceCxTotalAdjLP == 1) {
+		dev_info(info->dev, "SS TOTAL CX LP FORCE MIN MAX TEST:\n");
+		if (todo->SelfForceCxTotalLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_CX_LP_FORCE_MAP_MIN,
+						&thresholds_min,
+						&trows, &tcolumns);
+			/* load the min thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_CX_LP_FORCE_MAP_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_CX_LP_FORCE_MAP_MAX,
+						&thresholds_max,
+						&trows, &tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows !=
+					totCompData.header.force_node ||
+					tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_CX_LP_FORCE_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(totCompData.cx_fm,
+						  totCompData.header.force_node,
+						  1, thresholds_min,
+						  thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap SS TOTAL LP FORCE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL FORCE LP MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL FORCE LP MIN MAX TEST:.................OK\n\n");
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL CX LP FORCE MIN MAX TEST:.................SKIPPED\n");
+
+		/* SS TOTAL CX LP FORCE ADJV TEST */
+		dev_info(info->dev, "SS TOTAL CX LP FORCE ADJ TEST:\n");
+		if (todo->SelfForceCxTotalAdjLP == 1) {
+			dev_info(info->dev, "SS TOTAL CX LP FORCE ADJVERT TEST:\n");
+			ret = computeAdjVertTotal(totCompData.cx_fm,
+						  totCompData.header.force_node,
+						  1, &total_adjvert);
+			/* compute the ADJV for CX2  FORCE */
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjVert SS TOTAL CX LP FORCE ADJV failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			dev_info(info->dev, "SS TOTAL CX LP FORCE ADJV computed!\n");
+
+			ret = parseProductionTestLimits(info, path_limits,
+					&info->limit_file,
+					SS_TOTAL_CX_LP_FORCE_ADJV_MAP_MAX,
+					&thresholds_max, &trows,
+					&tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows != totCompData.header.force_node -
+					1 || tcolumns != 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_CX_LP_FORCE_ADJV_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjvert,
+						     totCompData.header.
+						     force_node - 1, 1,
+						     thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap SS TOTAL CX LP FORCE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL CX LP FORCE ADJV TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL CX LP FORCE ADJV TEST:.................OK\n\n");
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjvert);
+			total_adjvert = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL CX LP FORCE ADJ TEST:.................SKIPPED\n");
+	} else
+		dev_info(info->dev, "SS TOTAL CX LP FORCE TEST:.................SKIPPED\n\n");
+
+
+
+	/************* SS SENSE CX *************/
+	/* SS CX1 SENSE TEST */
+	dev_info(info->dev, "SS CX1 LP SENSE TEST:\n");
+	if (todo->SelfSenseCx1LP == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX1_LP_SENSE_MIN_MAX,
+						&thresholds, &trows, &tcolumns);
+		if (ret < 0 || (trows != 1 || tcolumns != 2)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX1_LP_SENSE_MIN_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		container = (short)ssCompData.s_cx1;
+		ret = checkLimitsMinMax(&container, 1, 1, thresholds[0],
+					thresholds[1]);
+		/* check the limits */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMinMax SS CX1 LP SENSE TEST failed... ERROR COUNT = %d\n",
+				ret);
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS CX1 LP SENSE TEST:.................OK\n\n");
+		kfree(thresholds);
+		thresholds = NULL;
+	} else
+		dev_info(info->dev, "SS CX1 LP SENSE TEST:.................SKIPPED\n\n");
+
+
+	/* SS CX2 LP SENSE TEST */
+	dev_info(info->dev, "SS CX2 LP SENSE MIN MAX TEST:\n");
+	if (todo->SelfSenseCx2LP == 1) {
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX2_LP_SENSE_MAP_MIN,
+						&thresholds_min, &trows,
+						&tcolumns);
+		/* load the min thresholds */
+		if (ret < 0 || (trows != 1 || tcolumns !=
+				ssCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX2_LP_SENSE_MAP_MIN failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX2_LP_SENSE_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != 1 || tcolumns !=
+				ssCompData.header.sense_node)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_CX2_LP_SENSE_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMap(ssCompData.cx2_sn, 1,
+				     ssCompData.header.sense_node,
+				     thresholds_min, thresholds_max);
+		/* check the values with thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMap SS CX2 LP SENSE failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS CX2 LP SENSE MIN MAX TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS CX2 LP SENSE MIN MAX TEST:.................OK\n\n");
+
+		kfree(thresholds_min);
+		thresholds_min = NULL;
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+	} else
+		dev_info(info->dev, "SS CX2 LP SENSE MIN MAX TEST:.................SKIPPED\n");
+
+	dev_info(info->dev, "SS CX2 LP SENSE ADJ TEST:\n");
+	if (todo->SelfSenseCx2AdjLP == 1) {
+		/* SS CX2 SENSE ADJH TEST */
+		dev_info(info->dev, "SS CX2 LP SENSE ADJHORIZ TEST:\n");
+		ret = computeAdjHoriz(ssCompData.cx2_sn, 1,
+				      ssCompData.header.sense_node, &adjhor);
+		if (ret < 0) {
+			dev_err(info->dev, "production_test_data: computeAdjHoriz SS CX2 LP SENSE ADJH failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+		dev_info(info->dev, "SS CX2 LP SENSE ADJH computed!\n");
+
+
+		ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_CX2_LP_SENSE_ADJH_MAP_MAX,
+						&thresholds_max, &trows,
+						&tcolumns);
+		/* load the max thresholds */
+		if (ret < 0 || (trows != 1 || tcolumns !=
+				ssCompData.header.sense_node - 1)) {
+			dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_IX2_SENSE_MAP_MAX failed... ERROR %08X\n",
+				ERROR_PROD_TEST_DATA);
+			ret |= ERROR_PROD_TEST_DATA;
+			goto ERROR_LIMITS;
+		}
+
+		ret = checkLimitsMapAdj(adjhor, 1,
+					ssCompData.header.sense_node - 1,
+					thresholds_max);
+		/* check the values with thresholds */
+		if (ret != OK) {
+			dev_err(info->dev, "production_test_data: checkLimitsMapAdj SS CX2 LP SENSE ADJH failed... ERROR COUNT = %d\n",
+				ret);
+			dev_err(info->dev, "SS CX2 LP SENSE ADJH TEST:.................FAIL\n\n");
+			count_fail += 1;
+			if (stop_on_fail)
+				goto ERROR;
+		} else
+			dev_info(info->dev, "SS CX2 LP SENSE ADJH TEST:.................OK\n");
+
+		kfree(thresholds_max);
+		thresholds_max = NULL;
+		kfree(adjhor);
+		adjhor = NULL;
+	} else
+		dev_info(info->dev, "SS CX2 LP SENSE ADJ TEST:.................SKIPPED\n\n");
+
+	/* SS TOTAL CX SENSE */
+	dev_info(info->dev, "SS TOTAL CX LP SENSE TEST:\n");
+	if (todo->SelfSenseCxTotalLP == 1 || todo->SelfSenseCxTotalAdjLP == 1) {
+		dev_info(info->dev, "SS TOTAL CX LP SENSE MIN MAX TEST:\n");
+		if (todo->SelfSenseCxTotalLP == 1) {
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_CX_LP_SENSE_MAP_MIN,
+						&thresholds_min,
+						&trows, &tcolumns);
+			/* load the min thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_CX_LP_SENSE_MAP_MIN failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = parseProductionTestLimits(info, path_limits,
+						&info->limit_file,
+						SS_TOTAL_CX_LP_SENSE_MAP_MAX,
+						&thresholds_max,
+						&trows, &tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					totCompData.header.sense_node)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_CX_LP_SENSE_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapTotal(totCompData.cx_sn, 1,
+						  totCompData.header.sense_node,
+						  thresholds_min,
+						  thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMap SS TOTAL CX LP SENSE failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL CX LP SENSE MIN MAX TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL CX LP SENSE MIN MAX TEST:.................OK\n\n");
+
+			kfree(thresholds_min);
+			thresholds_min = NULL;
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL CX LP SENSE MIN MAX TEST:.................SKIPPED\n");
+
+
+		/* SS TOTAL IX SENSE ADJH TEST */
+		dev_info(info->dev, "SS TOTAL CX LP SENSE ADJ TEST:\n");
+		if (todo->SelfSenseCxTotalAdjLP == 1) {
+			dev_info(info->dev, "SS TOTAL CX LP SENSE ADJHORIZ TEST:\n");
+			ret = computeAdjHorizTotal(totCompData.cx_sn, 1,
+					   totCompData.header.sense_node,
+					   &total_adjhor);
+			if (ret < 0) {
+				dev_err(info->dev, "production_test_data: computeAdjHoriz SS TOTAL CX LP SENSE ADJH failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+			dev_info(info->dev, "SS TOTAL CX LP SENSE ADJ HORIZ computed!\n");
+
+
+			ret = parseProductionTestLimits(info, path_limits,
+					&info->limit_file,
+					SS_TOTAL_CX_LP_SENSE_ADJH_MAP_MAX,
+					&thresholds_max, &trows,
+					&tcolumns);
+			/* load the max thresholds */
+			if (ret < 0 || (trows != 1 || tcolumns !=
+					totCompData.header.sense_node - 1)) {
+				dev_err(info->dev, "production_test_data: parseProductionTestLimits SS_TOTAL_CX_LP_SENSE_ADJH_MAP_MAX failed... ERROR %08X\n",
+					ERROR_PROD_TEST_DATA);
+				ret |= ERROR_PROD_TEST_DATA;
+				goto ERROR_LIMITS;
+			}
+
+			ret = checkLimitsMapAdjTotal(total_adjhor, 1,
+						     totCompData.header.
+						     sense_node - 1,
+						     thresholds_max);
+			/* check the values with thresholds */
+			if (ret != OK) {
+				dev_err(info->dev, "production_test_data: checkLimitsMapAdj SS TOTAL CX LP SENSE ADJH failed... ERROR COUNT = %d\n",
+					ret);
+				dev_err(info->dev, "SS TOTAL CX LP SENSE ADJH TEST:.................FAIL\n\n");
+				count_fail += 1;
+				if (stop_on_fail)
+					goto ERROR;
+			} else
+				dev_info(info->dev, "SS TOTAL CX LP SENSE ADJH TEST:.................OK\n\n");
+
+			kfree(thresholds_max);
+			thresholds_max = NULL;
+			kfree(total_adjhor);
+			total_adjhor = NULL;
+		} else
+			dev_info(info->dev, "SS TOTAL CX LP SENSE ADJ TEST:.................SKIPPED\n");
+	} else
+		dev_info(info->dev, "SS TOTAL CX LP SENSE TEST:.................SKIPPED\n");
+
+
+
+ERROR:
+
+	if (count_fail == 0) {
+		kfree(ssCompData.ix2_fm);
+		ssCompData.ix2_fm = NULL;
+		kfree(ssCompData.ix2_sn);
+		ssCompData.ix2_sn = NULL;
+		kfree(ssCompData.cx2_fm);
+		ssCompData.cx2_fm = NULL;
+		kfree(ssCompData.cx2_sn);
+		ssCompData.cx2_sn = NULL;
+		kfree(totCompData.ix_fm);
+		totCompData.ix_fm = NULL;
+		kfree(totCompData.ix_sn);
+		totCompData.ix_sn = NULL;
+		kfree(totCompData.cx_fm);
+		totCompData.cx_fm = NULL;
+		kfree(totCompData.cx_sn);
+		totCompData.cx_sn = NULL;
+		dev_info(info->dev, "SS LP IX CX  testes finished!.................OK\n\n");
+		return OK;
+	} else {
+	/* print all kind of data in just one row for readability reason */
+		print_frame_u8(info, "SS LP Init Data Ix2_fm = ", array1dTo2d_u8(
+				       ssCompData.ix2_fm,
+				       ssCompData.header.force_node, 1),
+			       ssCompData.header.force_node, 1);
+		print_frame_i8(info, "SS LP Init Data Cx2_fm = ", array1dTo2d_i8(
+				       ssCompData.cx2_fm,
+				       ssCompData.header.force_node, 1),
+			       ssCompData.header.force_node, 1);
+		print_frame_u8(info, "SS LP Init Data Ix2_sn = ", array1dTo2d_u8(
+				       ssCompData.ix2_sn,
+				       ssCompData.header.sense_node,
+				       ssCompData.header.sense_node), 1,
+			       ssCompData.header.sense_node);
+		print_frame_i8(info, "SS LP Init Data Cx2_sn = ", array1dTo2d_i8(
+				       ssCompData.cx2_sn,
+				       ssCompData.header.sense_node,
+				       ssCompData.header.sense_node), 1,
+			       ssCompData.header.sense_node);
+		print_frame_u16(info, "TOT SS LP Init Data Ix_fm = ", array1dTo2d_u16(
+					totCompData.ix_fm,
+					totCompData.header.force_node, 1),
+				totCompData.header.force_node, 1);
+		print_frame_short(info, "TOT SS LP Init Data Cx_fm = ",
+				  array1dTo2d_short(totCompData.cx_fm,
+						    totCompData.header.
+						    force_node, 1),
+				  totCompData.header.force_node, 1);
+		print_frame_u16(info, "TOT SS LP Init Data Ix_sn = ", array1dTo2d_u16(
+					totCompData.ix_sn,
+					totCompData.header.sense_node,
+					totCompData.header.sense_node), 1,
+				totCompData.header.sense_node);
+		print_frame_short(info, "TOT SS LP Init Data Cx_sn = ",
+				  array1dTo2d_short(totCompData.cx_sn,
+						    totCompData.header.
+						    sense_node,
+						    totCompData.header.
+						    sense_node),
+				  1, totCompData.header.sense_node);
+		dev_err(info->dev, "SS LP IX CX testes finished!.................FAILED  fails_count = %d\n\n",
+			count_fail);
+		if (thresholds != NULL)
+			kfree(thresholds);
+		if (thresholds_min != NULL)
+			kfree(thresholds_min);
+		if (thresholds_max != NULL)
+			kfree(thresholds_max);
+		if (adjhor != NULL)
+			kfree(adjhor);
+		if (adjvert != NULL)
+			kfree(adjvert);
+		if (total_adjhor != NULL)
+			kfree(total_adjhor);
+		if (total_adjvert != NULL)
+			kfree(total_adjvert);
+		if (ssCompData.ix2_fm != NULL)
+			kfree(ssCompData.ix2_fm);
+		if (ssCompData.ix2_sn != NULL)
+			kfree(ssCompData.ix2_sn);
+		if (ssCompData.cx2_fm != NULL)
+			kfree(ssCompData.cx2_fm);
+		if (ssCompData.cx2_sn != NULL)
+			kfree(ssCompData.cx2_sn);
+		if (totCompData.ix_fm != NULL)
+			kfree(totCompData.ix_fm);
+		if (totCompData.ix_sn != NULL)
+			kfree(totCompData.ix_sn);
+		if (totCompData.cx_fm != NULL)
+			kfree(totCompData.cx_fm);
+		if (totCompData.cx_sn != NULL)
+			kfree(totCompData.cx_sn);
+		return ERROR_TEST_CHECK_FAIL | ERROR_PROD_TEST_DATA;
+	}
+
+ERROR_LIMITS:
+	if (thresholds != NULL)
+		kfree(thresholds);
+	if (thresholds_min != NULL)
+		kfree(thresholds_min);
+	if (thresholds_max != NULL)
+		kfree(thresholds_max);
+	if (adjhor != NULL)
+		kfree(adjhor);
+	if (adjvert != NULL)
+		kfree(adjvert);
+	if (total_adjhor != NULL)
+		kfree(total_adjhor);
+	if (total_adjvert != NULL)
+		kfree(total_adjvert);
+	if (ssCompData.ix2_fm != NULL)
+		kfree(ssCompData.ix2_fm);
+	if (ssCompData.ix2_sn != NULL)
+		kfree(ssCompData.ix2_sn);
+	if (ssCompData.cx2_fm != NULL)
+		kfree(ssCompData.cx2_fm);
+	if (ssCompData.cx2_sn != NULL)
+		kfree(ssCompData.cx2_sn);
+	if (totCompData.ix_fm != NULL)
+		kfree(totCompData.ix_fm);
+	if (totCompData.ix_sn != NULL)
+		kfree(totCompData.ix_sn);
+	if (totCompData.cx_fm != NULL)
+		kfree(totCompData.cx_fm);
+	if (totCompData.cx_sn != NULL)
+		kfree(totCompData.cx_sn);
+	return ret;
+}
+
+/**
+  * Perform a complete Data Test check of the IC
+  * @param path_limits name of Production Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @param stop_on_fail if 1, the test flow stops at the first data check
+  * failure
+  * otherwise it keeps going performing all the selected test
+  * @param todo pointer to a TestToDo variable which select the test to do
+  * @return OK if success or an error code which specify the type of error
+  */
+int production_test_data(struct fts_ts_info *info, const char *path_limits,
+			 int stop_on_fail)
+{
+	int res = OK, ret;
+	TestToDo *todo = &info->tests;
+
+	if (todo == NULL) {
+		dev_err(info->dev, "production_test_data: No TestToDo specified!! ERROR = %08X\n",
+			(ERROR_OP_NOT_ALLOW | ERROR_PROD_TEST_DATA));
+		return ERROR_OP_NOT_ALLOW | ERROR_PROD_TEST_DATA;
+	}
+
+
+	dev_info(info->dev, "DATA Production test is starting...\n");
+
+
+	ret = production_test_ms_raw(info, path_limits, stop_on_fail);
+	res |= ret;
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: production_test_ms_raw failed... ERROR = %08X\n",
+			ret);
+		if (stop_on_fail == 1)
+			goto END;
+	}
+
+
+
+	ret = production_test_ms_cx(info, path_limits, stop_on_fail);
+	res |= ret;
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: production_test_ms_cx failed... ERROR = %08X\n",
+			ret);
+		if (stop_on_fail == 1)
+			goto END;
+	}
+
+
+	ret = production_test_ss_raw(info, path_limits, stop_on_fail);
+	res |= ret;
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: production_test_ss_raw failed... ERROR = %08X\n",
+			ret);
+		if (stop_on_fail == 1)
+			goto END;
+	}
+
+	ret = production_test_ss_ix_cx(info, path_limits, stop_on_fail);
+	res |= ret;
+	if (ret < 0) {
+		dev_err(info->dev, "production_test_data: production_test_ss_ix_cx failed... ERROR = %08X\n",
+			ret);
+		if (stop_on_fail == 1)
+			goto END;
+	}
+
+END:
+	freeLimitsFile(&info->limit_file);	/* /< release the limit file loaded
+					 * during the test */
+	if (res < OK)
+		dev_err(info->dev, "DATA Production test failed!\n");
+	else
+		dev_info(info->dev, "DATA Production test finished!\n");
+	return res;
+}
+
+
+/*************** TP Sensitivity calibration API ********************/
+
+/**
+  * Perform the Pre Calibration MS Test when the stimpad is down
+  * @param[out] frame pointer to the frame which will contain
+  * the average frame resulting from the test
+  * @param target reference value for the frame, each node should be
+  * around +-percentage% this value
+  * @param percentage percentage of the target value which define
+  * the valid interval for the frame, if <0 the test will be skipped
+  * @return OK if success or an error code which specify the type of error
+  */
+int tp_sensitivity_test_pre_cal_ms(struct fts_ts_info *info, MutualSenseFrame *finalFrame, short target,
+				   int percentage)
+{
+	int ret = OK;
+	int count = 0, i = 0, j = 0;
+	short min, max;
+	MutualSenseFrame frame;
+
+	finalFrame->node_data = NULL;
+
+
+	dev_info(info->dev, "%s: Start TP sensitivity MS Pre Cal...\n", __func__);
+	dev_info(info->dev, "%s: IMPORTANT!!! Stimpad should be on the display of the device!\n",
+		__func__);
+	ret = getMSFrame3(info, MS_STRENGTH, &frame);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: can not read MS Frame... ERROR %08X\n",
+			__func__, ret);
+		goto ERROR;
+	}
+
+	finalFrame->header = frame.header;
+	finalFrame->node_data_size = frame.node_data_size;
+
+	finalFrame->node_data = (short *)kzalloc(frame.node_data_size *
+						 sizeof(short), GFP_KERNEL);
+	if (finalFrame->node_data == NULL) {
+		dev_err(info->dev, "%s: can not allocate node_data ERROR %08X\n",
+			__func__, ERROR_ALLOC | ERROR_GET_FRAME);
+		ret = ERROR_ALLOC | ERROR_GET_FRAME;
+		goto ERROR;
+	}
+
+	/* collecting frames */
+	do {
+		for (i = 0; i < finalFrame->node_data_size; i++) {
+			finalFrame->node_data[i] += (frame.node_data[i] * 10) /
+						    SENS_TEST_NUM_FRAMES;
+		}
+
+		if (frame.node_data != NULL) {
+			kfree(frame.node_data);
+			frame.node_data = NULL;
+		}
+
+		count++;
+
+		/* exclude one more reading at the end*/
+		if (count < SENS_TEST_NUM_FRAMES)
+			ret = getMSFrame3(info, MS_STRENGTH, &frame);
+	} while ((count < SENS_TEST_NUM_FRAMES) && (ret >= OK));
+
+	if (ret < OK) {
+		dev_err(info->dev, "%s: Error while capturing the frame %d! ERROR %08X\n",
+			__func__, count, ret);
+		goto ERROR;
+	}
+
+	ret = OK;
+	/* check against +-percentage% target */
+	dev_info(info->dev, "%s: Computing average frame...\n", __func__);
+
+	min = target - (target * percentage / 100);
+	max = target + (target * percentage / 100);
+
+	for (i = 0; i < finalFrame->header.force_node; i++) {
+		for (j = 0; j < finalFrame->header.sense_node; j++) {
+			finalFrame->node_data[i *
+					      finalFrame->header.sense_node +
+					      j] /= 10;
+		/*if percentage is <0 skip this test, just collect data */
+			if ((percentage > 0) &&
+			    ((finalFrame->node_data[i * finalFrame->header.
+						    sense_node
+						    + j] >
+			      max) ||
+			     (finalFrame->node_data[i *
+						    finalFrame->header.
+						    sense_node
+						    + j] <
+			      min))) {
+				dev_err(info->dev, "%s: MS Force Node[%d, %d] = %d exceed limit [%d, %d]\n",
+					__func__, i, j,
+					finalFrame->node_data[i *
+							       finalFrame
+							       ->header.
+							       sense_node + j],
+					 min, max);
+				ret = ERROR_TEST_CHECK_FAIL;
+			}
+		}
+	}
+
+
+	/* print average frame in the log */
+	print_frame_short(info, "MS FS Mean =",
+			  array1dTo2d_short(
+				  finalFrame->node_data,
+				  finalFrame->node_data_size,
+				  finalFrame->header.sense_node),
+			  finalFrame->header.force_node,
+			  finalFrame->header.sense_node);
+
+	if (ret != OK)
+		dev_err(info->dev, "%s: TP sensitivity MS Pre Cal test FAILED... ERROR %08X\n",
+			__func__, ret);
+	else
+		dev_info(info->dev, "%s: TP sensitivity MS Pre Cal FINISHED!\n",
+			__func__);
+
+	return ret;
+
+
+ERROR:
+	if (frame.node_data != NULL) {
+		kfree(frame.node_data);
+		frame.node_data = NULL;
+	}
+
+
+	if (finalFrame->node_data != NULL) {
+		kfree(finalFrame->node_data);
+		finalFrame->node_data = NULL;
+	}
+
+	return ret;
+}
+
+
+
+/**
+  * Perform the Pre Calibration SS Test when the stimpad is down
+  * @param[out] frame pointer to the frame which will contain the average frame
+  * resulting from the test
+  * @param target reference value for the frame, each node should be around
+  * +-percentage% this value
+  * @param percentage percentage of the target value which define the valid
+  * interval for the frame
+  * @return OK if success or an error code which specify the type of error
+  */
+int tp_sensitivity_test_pre_cal_ss(struct fts_ts_info *info, SelfSenseFrame *finalFrame, short target,
+				int percentage)
+{
+	int ret = OK;
+	int count = 0, i = 0;
+	short min, max;
+	SelfSenseFrame frame;
+	int *temp_force = NULL;
+	int *temp_sense = NULL;
+
+	finalFrame->force_data = NULL;
+	finalFrame->sense_data = NULL;
+
+	dev_info(info->dev, "%s: Start TP sensitivity SS Pre Cal...\n", __func__);
+	dev_info(info->dev, "%s: IMPORTANT!!! Stimpad should be on the display of the device!\n",
+		__func__);
+	ret = getSSFrame3(info, SS_STRENGTH, &frame);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: can not read SS Frame... ERROR %08X\n",
+			__func__, ret);
+		goto ERROR;
+	}
+
+	finalFrame->header = frame.header;
+
+	finalFrame->force_data = (short *)kzalloc(frame.header.force_node *
+						  sizeof(short), GFP_KERNEL);
+	temp_force = (int *)kzalloc(frame.header.force_node *
+						  sizeof(int), GFP_KERNEL);
+	finalFrame->sense_data = (short *)kzalloc(frame.header.sense_node *
+						  sizeof(short), GFP_KERNEL);
+	temp_sense = (int *)kzalloc(frame.header.sense_node *
+						  sizeof(int), GFP_KERNEL);
+	if (finalFrame->force_data == NULL ||
+	    temp_force == NULL ||
+	    finalFrame->sense_data == NULL ||
+	    temp_sense == NULL) {
+
+		dev_err(info->dev, "%s: can not allocate memory ERROR %08X\n",
+			__func__, ERROR_ALLOC | ERROR_GET_FRAME);
+		ret = ERROR_ALLOC | ERROR_GET_FRAME;
+		goto ERROR;
+	}
+
+	/* collecting frames */
+	do {
+		for (i = 0; i < finalFrame->header.force_node; i++)
+			temp_force[i] += frame.force_data[i];
+
+		for (i = 0; i < finalFrame->header.sense_node; i++)
+			temp_sense[i] += frame.sense_data[i];
+
+		count++;
+
+		if (frame.force_data != NULL) {
+			kfree(frame.force_data);
+			frame.force_data = NULL;
+		}
+		if (frame.sense_data != NULL) {
+			kfree(frame.sense_data);
+			frame.sense_data = NULL;
+		}
+
+		/* exclude one more reading at the end*/
+		if (count < SENS_TEST_NUM_FRAMES)
+			ret = getSSFrame3(info, SS_STRENGTH, &frame);
+	} while ((count < SENS_TEST_NUM_FRAMES) && (ret >= OK));
+
+	if (ret < OK) {
+		dev_err(info->dev, "%s: Error while capturing the frame %d! ERROR %08X\n",
+			__func__, count, ret);
+		goto ERROR;
+	}
+
+	ret = OK;
+
+	/* compute the average and check against +-percentage% target */
+	min = target - (target * percentage / 100);
+	max = target + (target * percentage / 100);
+
+	for (i = 0; i < finalFrame->header.force_node; i++) {
+		finalFrame->force_data[i] = temp_force[i] /
+						SENS_TEST_NUM_FRAMES;
+		if ((percentage > 0) && ((finalFrame->force_data[i] > max) ||
+					 (finalFrame->force_data[i] < min))) {
+			dev_err(info->dev, "%s: SS Force Node[%d] = %d exceed limit [%d, %d]\n",
+				__func__, i, finalFrame->force_data[i],
+				min, max);
+			ret = ERROR_TEST_CHECK_FAIL;
+		}
+	}
+
+	for (i = 0; i < finalFrame->header.sense_node; i++) {
+		finalFrame->sense_data[i] = temp_sense[i] /
+						SENS_TEST_NUM_FRAMES;
+		if ((finalFrame->sense_data[i] > max) ||
+		    (finalFrame->sense_data[i] < min)) {
+			dev_err(info->dev, "%s: SS Sense Node[%d] = %d exceed limit [%d, %d]\n",
+				__func__, i, finalFrame->sense_data[i],
+				min, max);
+			ret = ERROR_TEST_CHECK_FAIL;
+		}
+	}
+
+	/* print average frame in the log */
+	print_frame_short(info, "SS FS force Mean =",
+			  array1dTo2d_short(
+				  finalFrame->force_data,
+				  finalFrame->header.force_node,
+				  1),
+			  finalFrame->header.force_node, 1);
+	print_frame_short(info, "SS FS sense Mean =",
+			  array1dTo2d_short(
+				  finalFrame->sense_data,
+				  finalFrame->header.sense_node,
+				  finalFrame->header.sense_node),
+			  1, finalFrame->header.sense_node);
+
+
+	kfree(temp_force);
+	temp_force = NULL;
+
+	kfree(temp_sense);
+	temp_sense = NULL;
+
+	if (ret < OK)
+		dev_err(info->dev, "%s: TP sensitivity SS Pre Cal test FAILED... ERROR %08X\n",
+			__func__, ret);
+	else {
+		dev_info(info->dev, "%s: TP sensitivity SS Pre Cal FINISHED!\n",
+			__func__);
+		ret = OK;
+	}
+
+	return ret;
+
+
+ERROR:
+
+	kfree(temp_force);
+	temp_force = NULL;
+
+	kfree(temp_sense);
+	temp_sense = NULL;
+
+	kfree(frame.force_data);
+	frame.force_data = NULL;
+
+	kfree(frame.sense_data);
+	frame.sense_data = NULL;
+
+	kfree(finalFrame->force_data);
+	finalFrame->force_data = NULL;
+
+	kfree(finalFrame->sense_data);
+	finalFrame->sense_data = NULL;
+
+	return ret;
+}
+
+/**
+  * Compute Digital gains for calibration
+  * @param frame pointer to the frame used as reference to compute the gains
+  * @param target reference target value for computing the gains
+  * @param saveGain if 1, will save the gain table into the chip otherwise will
+  * not save it
+  * @return OK if success or an error code which specify the type of error
+  */
+int tp_sensitivity_compute_gains(struct fts_ts_info *info,
+				 MutualSenseFrame *frame, short target,
+				 int saveGain)
+{
+	int ret = OK;
+	int i = 0;
+	u8 *gains;
+
+	if ((frame->node_data == NULL) || (frame->node_data_size == 0)) {
+		dev_err(info->dev, "%s: Invalid frame data passed as argument! ERROR %08X\n",
+			__func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	gains = kzalloc(frame->node_data_size * sizeof(u8), GFP_KERNEL);
+	if (gains == NULL)
+		return ERROR_ALLOC;
+
+	dev_info(info->dev, "%s: Start to compute Digital Gains...\n", __func__);
+	for (i = 0; i < frame->node_data_size; i++)
+		gains[i] = ((target * 100) / frame->node_data[i]) > 255 ?
+			   (u8)(255) : (u8)(((target * 100) /
+					     frame->node_data[i]));
+	/* clamp the max value to 255 because gain is only one byte */
+
+
+	/* print average frame in the log */
+	print_frame_u8(info, "MS Digital Gain =",
+		       array1dTo2d_u8(
+			       gains,
+			       frame->node_data_size,
+			       frame->header.sense_node),
+		       frame->header.force_node,
+		       frame->header.sense_node);
+
+
+	/* if(saveGain==1){ */
+	/* write gains into the IC */
+	ret = writeHostDataMemory(info, LOAD_SENS_CAL_COEFF, gains,
+				  frame->header.force_node,
+				  frame->header.sense_node, 0, 0, saveGain);
+	if (ret != OK)
+		dev_err(info->dev, "%s: impossible to write digital gains! ERROR %08X\n",
+			__func__, ret);
+	/* } */
+
+	if (ret < OK)
+		dev_err(info->dev, "%s: compute Digital Gains FAILED! ERROR %08X\n",
+			__func__, ret);
+	else {
+		dev_info(info->dev, "%s: compute Digital Gains FINISHED!\n", __func__);
+		ret = OK;
+	}
+
+	kfree(gains);
+	return ret;
+}
+
+/**
+  * Perform the Post Calibration MS Test when the stimpad is down
+  * @param[out] finalFrame pointer to the frame which will contain
+  * the average frame resulting from the test
+  * @param[out] deltas pointer to the frame which will contain
+  * the FS Uniform frame (worst_neighborhood/mean)
+  * @param target reference value for the frame, each node should be
+  * around +-percentage% this value
+  * @param percentage percentage of the target value which define
+  * the valid interval for the frame, if <0 the test will be skipped
+  * @param[out] mean_normal pointer to the variable which will contain the mean
+  * of the normal area
+  * @param[out] mean_edge pointer to the variable which will contain the mean of
+  * the edge area
+  * @return OK if success or an error code which specify the type of error
+  */
+int tp_sensitivity_test_post_cal_ms(struct fts_ts_info *info,
+				    MutualSenseFrame *finalFrame,
+				    MutualSenseFrame *deltas, short target,
+				    int percentage, int *mean_normal,
+				    int *mean_edge)
+{
+	short currentNode;
+	int final_force_num;
+	int final_sense_num;
+	short *final_node;
+	int delta_sense_num;
+	short *delta_node;
+	short *delta;
+	short adjNode;
+	int ret = OK;
+	int i = 0, j = 0, min, max;
+
+
+	if ((finalFrame == NULL) || (deltas == NULL) || (mean_normal == NULL) ||
+	    (mean_edge == NULL)) {
+		dev_err(info->dev, "%s: Invalid arguments Passed! ERROR %08X\n",
+			__func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	*mean_normal = 0;
+	*mean_edge = 0;
+
+	finalFrame->node_data = NULL;
+	deltas->node_data = NULL;
+
+	dev_info(info->dev, "%s: Start TP sensitivity MS Post Cal...\n", __func__);
+	dev_info(info->dev, "%s: IMPORTANT!!! Stimpad should be on the display of the device!\n",
+		__func__);
+
+	/* collect frames skipping the tests + print on the log */
+	ret = tp_sensitivity_test_pre_cal_ms(info, finalFrame, target, -1);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: can not collect MS Frame... ERROR %08X\n",
+			__func__, ret);
+		goto ERROR;
+	}
+
+
+	deltas->header = finalFrame->header;
+	deltas->node_data_size = finalFrame->node_data_size;
+
+	deltas->node_data = (short *)kzalloc(deltas->node_data_size *
+					     sizeof(short), GFP_KERNEL);
+	if (deltas->node_data == NULL) {
+		dev_err(info->dev, "%s: can not allocate deltas node_data ERROR %08X\n",
+			__func__, ERROR_ALLOC | ERROR_GET_FRAME);
+		ret = ERROR_ALLOC | ERROR_GET_FRAME;
+		goto ERROR;
+	}
+
+	/* compute the average of the whole panel and check against
+	  * +-percentage% target */
+	dev_info(info->dev, "%s: Computing average of whole panel and delta for each node...\n",
+		__func__);
+
+	final_force_num = finalFrame->header.force_node;
+	final_sense_num = finalFrame->header.sense_node;
+	final_node = finalFrame->node_data;
+	delta_sense_num = deltas->header.sense_node;
+	delta_node = deltas->node_data;
+
+
+	for (i = 0; i < final_force_num; i++) {
+		for (j = 0; j < final_sense_num; j++) {
+			currentNode = finalFrame->node_data[i *
+							    finalFrame->header.
+							    sense_node + j];
+			delta = &delta_node[i * delta_sense_num + j];
+
+			if ((i == 0) ||
+			    (i == (final_force_num - 1)) ||
+			    (j == 0) ||
+			    (j == (final_sense_num - 1))) {
+				/* edge nodes */
+				*mean_edge += currentNode;
+				if ((i == 0) ||
+				    (i == final_force_num - 1)) {
+					/* need to check adj node up or down for
+					  *  nodes in the corners */
+					if ((i == 0) &&
+					    ((j == 0) ||
+					     (j == final_sense_num - 1))) {
+						adjNode = currentNode -
+							  final_node[(i + 1) *
+							   final_sense_num + j];
+						if (abs(adjNode) > *delta)
+							*delta = abs(adjNode);
+					}
+
+					if ((i == (final_force_num - 1)) &&
+					    ((j == 0) ||
+					     (j == final_sense_num - 1))) {
+						adjNode = currentNode -
+							  final_node[(i - 1) *
+							   final_sense_num + j];
+						if (abs(adjNode) > *delta)
+							*delta = abs(adjNode);
+					}
+
+					/* scan the row */
+					if ((j - 1) >= 0) {
+						adjNode = currentNode -
+							  final_node[i *
+							    final_sense_num +
+							    (j - 1)];
+						if (abs(adjNode) > *delta)
+							*delta = abs(adjNode);
+					}
+
+					if ((j + 1) < final_sense_num) {
+						adjNode = currentNode -
+							  final_node[i *
+							    final_sense_num +
+							    (j + 1)];
+						if (abs(adjNode) > *delta)
+						    *delta = abs(adjNode);
+					}
+				}
+
+				if ((j == 0) ||
+				    (j == final_sense_num - 1)) {
+					/* scan the column */
+					if ((i - 1) >= 0) {
+						adjNode = currentNode -
+							  final_node[(i - 1) *
+							   final_sense_num + j];
+						if (abs(adjNode) > *delta)
+							*delta = abs(adjNode);
+					}
+
+					if ((i + 1) < final_force_num) {
+						adjNode = currentNode -
+							  final_node[(i + 1) *
+							   final_sense_num + j];
+						if (abs(adjNode) > *delta)
+							*delta = abs(adjNode);
+					}
+				}
+			} else {
+				/*normal nodes */
+				*mean_normal += currentNode;
+
+				/* picking up the worst difference between
+				  * one pixel and its neighbors */
+				if ((i - 1) >= 1) {
+					adjNode = currentNode -
+						  final_node[(i - 1) *
+							final_sense_num + j];
+					if (abs(adjNode) > *delta)
+						*delta = abs(adjNode);
+				}
+
+				if ((i + 1) < (final_force_num - 1)) {
+					adjNode = currentNode -
+						  final_node[(i + 1) *
+							final_sense_num + j];
+					if (abs(adjNode) > *delta)
+						*delta = abs(adjNode);
+				}
+				if ((j - 1) >= 1) {
+					adjNode = currentNode -
+						  final_node[i *
+						    final_sense_num + (j - 1)];
+					if (abs(adjNode) > *delta)
+						*delta = abs(adjNode);
+				}
+
+				if ((j + 1) < (final_sense_num - 1)) {
+					adjNode = currentNode -
+						  final_node[i *
+						    final_sense_num + (j + 1)];
+					if (abs(adjNode) > *delta)
+						*delta = abs(adjNode);
+				}
+			}
+		}
+	}
+
+	*mean_normal /= (finalFrame->header.force_node - 2) *
+			(finalFrame->header.sense_node - 2);
+	*mean_edge /= (finalFrame->header.force_node * 2) +
+		      (finalFrame->header.sense_node - 2) * 2;
+
+	dev_info(info->dev, "%s: Normal Frame average = %d\n", __func__, *mean_normal);
+	dev_info(info->dev, "%s: Edge Frame average = %d\n", __func__, *mean_edge);
+	/* compute the average and check against +-% target */
+	min = target - (target * percentage / 100);
+	max = target + (target * percentage / 100);
+
+	if ((percentage > 0) && ((*mean_normal < min) || (*mean_normal >
+							  max))) {
+		dev_err(info->dev, "%s: Normal Frame average = %d exceed limit [%d, %d]\n",
+			__func__, *mean_normal, min, max);
+		ret = ERROR_TEST_CHECK_FAIL;
+	}
+
+	if ((percentage > 0) && ((*mean_edge < min) || (*mean_edge > max))) {
+		dev_err(info->dev, "%s: Edge Frame average = %d exceed limit [%d, %d]\n",
+			__func__, *mean_edge, min, max);
+		ret = ERROR_TEST_CHECK_FAIL;
+	}
+
+	for (i = 0; i < deltas->header.force_node; i++) {
+		for (j = 0; j < deltas->header.sense_node; j++) {
+			if ((i == 0) || (i == deltas->header.force_node) ||
+			    (j == 0) || (j == deltas->header.sense_node))
+				deltas->node_data[i *
+						  deltas->header.sense_node +
+						  j] =
+					deltas->node_data[i *
+							  deltas->header.
+							  sense_node + j] *
+					100 /
+					(*mean_edge);
+			else
+				deltas->node_data[i *
+						  deltas->header.sense_node +
+						  j] =
+					deltas->node_data[i *
+							  deltas->header.
+							  sense_node + j] *
+					100 /
+					(*mean_normal);
+
+			if ((percentage > 0) && (deltas->node_data[i *
+								   deltas->
+								   header.
+								   sense_node +
+								   j] >
+						 percentage)) {
+				dev_err(info->dev, "%s: Delta Node[%d, %d] = %d exceed limit [%d]\n",
+					__func__, i, j,
+					deltas->node_data[i *
+							   deltas
+							   ->header.sense_node +
+							   j], percentage);
+				ret = ERROR_TEST_CHECK_FAIL;
+			}
+		}
+	}
+
+
+	/* print average frame in the log */
+	print_frame_short(info, "FS Uniform (%) =",
+			  array1dTo2d_short(
+				  deltas->node_data,
+				  deltas->node_data_size,
+				  deltas->header.sense_node),
+			  deltas->header.force_node,
+			  deltas->header.sense_node);
+
+
+	if (ret < OK)
+		dev_err(info->dev, "%s: TP sensitivity MS Post Cal test FAILED... ERROR %08X\n",
+			__func__, ret);
+	else {
+		dev_info(info->dev, "%s: TP sensitivity MS Post Cal FINISHED!\n",
+			__func__);
+		ret = OK;
+	}
+
+	return ret;
+
+
+ERROR:
+	if (deltas->node_data != NULL) {
+		kfree(deltas->node_data);
+		deltas->node_data = NULL;
+	}
+
+
+	if (finalFrame->node_data != NULL) {
+		kfree(finalFrame->node_data);
+		finalFrame->node_data = NULL;
+	}
+
+	return ret;
+}
+
+
+/**
+  * Compute Digital gains for calibration
+  * @param enter if =1 turn on TP Sensitivity mode, otherwise will turn it off
+  * @param saveGain if 1, will save the gain table into the chip otherwise will
+  * not save it
+  * @return OK if success or an error code which specify the type of error
+  */
+int tp_sensitivity_mode(struct fts_ts_info *info, u8 enter, int saveGain)
+{
+	int res, ret = OK;
+	u8 cmd[4] = { 0xC0, 0x00, 0x00, 0x00 };
+	u8 sett = SPECIAL_WRITE_HOST_MEM_TO_FLASH;
+	u8 parameter[2] = { 0x00, 0x01 };
+
+	dev_info(info->dev, "%s: Start TP Sensitivity Mode... enter = %02X\n",
+		 __func__, enter);
+	if (enter == 1) {
+		/* enter TP Sensitivity mode*/
+		ret = fts_enableInterrupt(info, false);
+		dev_info(info->dev, "%s: Entering TP Sensitivity Mode disabling algos...\n",
+			__func__);
+		cmd[3] = 0x01;
+		res = fts_writeFwCmd(info, cmd, 4);
+		if (res < OK)
+			dev_err(info->dev, "%s: Error while turning on TP Sens Mode! ERROR %08X\n",
+				__func__, res);
+		else {
+			ret = writeSysCmd(info, SYS_CMD_CX_TUNING, parameter, 2);
+			if (ret < OK)
+				dev_err(info->dev, "%s: error while performing Single Ended Special Autotune! ERROR %08X\n",
+					__func__, ret);
+		}
+	} else {
+		/* exit TP Sensitivity mode*/
+		dev_info(info->dev, "%s: Exiting TP Sensitivity Mode enabling algos...\n",
+			__func__);
+		res = fts_writeFwCmd(info, cmd, 4);
+		if (res < OK)
+			dev_err(info->dev, "%s: Error while turning off TP Sens Mode! ERROR %08X\n",
+				__func__, res);
+
+		if (saveGain == 1) {
+			dev_info(info->dev, "%s: Trigger writing gains into the flash...\n",
+				__func__);
+			ret = writeSysCmd(info, SYS_CMD_SPECIAL, &sett, 1);
+			if (ret < OK)
+				dev_err(info->dev, "%s: error while writing gains into the flash! ERROR %08X\n",
+					__func__, res);
+		}
+
+		res |= senseOn(info);
+		res |= fts_enableInterrupt(info, true);
+	}
+
+	res |= ret;
+
+	if (res < OK)
+		dev_err(info->dev, "%s: TP Sensitivity Mode... ERROR %08X!\n",
+			__func__, res);
+	else
+		dev_info(info->dev, "%s: TP Sensitivity Mode FINISHED!\n", __func__);
+
+	return res;
+}
+
+
+/**
+  * Compute Digital gains for calibration
+  * @param scan select the scan mode which should be enabled
+  * @param enableGains =1 apply gains when computing the strength otherwise
+  * the gains will be ignored
+  * @return OK if success or an error code which specify the type of error
+  */
+int tp_sensitivity_set_scan_mode(struct fts_ts_info *info, u8 scan,
+				 int enableGains)
+{
+	int res, ret = OK;
+	u8 cmd[4] = { 0xC0, 0x00, 0x01, 0x00 };
+
+	dev_info(info->dev, "%s: Set TP Sensitivity Scan Mode... scan = %02X, enableGains = %d\n",
+		__func__, scan, enableGains);
+
+	if (enableGains == 1) {
+		/* Consider Sensitivity Gains when computing Strength */
+		cmd[3] = 0x01;
+		ret = fts_writeFwCmd(info, cmd, 4);
+		if (ret < OK)
+			dev_err(info->dev, "%s: Error while enabling Gains in TP Sens Mode! ERROR %08X\n",
+				__func__, ret);
+	} else {
+		/* Exclude Sensitivity Gains when computing Strength */
+		ret = fts_writeFwCmd(info, cmd, 4);
+		if (ret < OK)
+			dev_err(info->dev, "%s: Error while disabling Gain in TP Sens Mode! ERROR %08X\n",
+				__func__, ret);
+	}
+
+	res = setScanMode(info, SCAN_MODE_LOCKED, scan);
+	if (res < OK)
+		dev_err(info->dev, "Error while setting the scan frequency... ERROR %08X\n",
+			res);
+
+	res |= ret;
+
+	if (res < OK)
+		dev_err(info->dev, "%s: Set TP Sensitivity Scan Mode... ERROR %08X!\n",
+			__func__, res);
+	else
+		dev_info(info->dev, "%s: Set TP Sensitivity Scan FINISHED!\n", __func__);
+
+	return res;
+}
+
+
+
+
+/**
+  * Compute the standard deviation for each node form a series of frames
+  * @param numFrames number of frames to collect to compute the standard
+  * deviation
+  * @param[out] std pointer to the frame which will contain the standard
+  * deviation for each node
+  * @return OK if success or an error code which specify the type of error
+  */
+int tp_sensitivity_test_std_ms(struct fts_ts_info *info,
+			       int numFrames, MutualSenseFrame *std)
+{
+	int ret = OK;
+	int i = 0, count = 0;
+	MutualSenseFrame frame;
+	int *mean = NULL;/* store the mean value for each node */
+	unsigned long *stdTemp = NULL;
+
+
+	if (std == NULL) {
+		dev_err(info->dev, "%s: Invalid arguments Passed! ERROR %08X\n",
+			__func__, ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+
+	std->node_data = NULL;
+
+	dev_info(info->dev, "%s: Start TP sensitivity STD... collecting %d frames!\n",
+		__func__, numFrames);
+
+	/* collect frames skipping the tests + print on the log */
+	ret = getMSFrame3(info, MS_STRENGTH, &frame);
+	if (ret < OK) {
+		dev_err(info->dev, "%s: can not read MS Frame... ERROR %08X\n",
+			__func__, ret);
+		goto ERROR;
+	}
+
+	std->header = frame.header;
+	std->node_data_size = frame.node_data_size;
+
+	std->node_data = (short *)kzalloc(std->node_data_size * sizeof(short),
+					  GFP_KERNEL);
+	mean = (int *)kzalloc(std->node_data_size * sizeof(int), GFP_KERNEL);
+	stdTemp = (unsigned long *)kzalloc(std->node_data_size *
+					   sizeof(unsigned long),
+					   GFP_KERNEL);
+	if (std->node_data == NULL ||
+	    mean == NULL ||
+	    stdTemp == NULL) {
+		dev_err(info->dev, "%s: can not allocate memory ERROR %08X\n",
+			__func__, ERROR_ALLOC | ERROR_GET_FRAME);
+		ret = ERROR_ALLOC | ERROR_GET_FRAME;
+		goto ERROR;
+	}
+
+	/* collecting frames */
+	do {
+		for (i = 0; i < frame.node_data_size; i++) {
+			mean[i] += frame.node_data[i];
+			stdTemp[i] += frame.node_data[i] * frame.node_data[i];
+		}
+		count++;
+
+		if (frame.node_data != NULL) {
+			kfree(frame.node_data);
+			frame.node_data = NULL;
+		}
+
+		/* exclude one more reading at the end*/
+		if (count < numFrames)
+			ret = getMSFrame3(info, MS_STRENGTH, &frame);
+	} while ((count < numFrames) && (ret >= OK));
+
+	if (ret < OK) {
+		dev_err(info->dev, "%s: error while collecting the frames! ERROR%08X\n",
+			__func__, ret);
+		goto ERROR;
+	}
+
+	/* compute the average for each node */
+	dev_info(info->dev, "%s: Computing std for each node...\n", __func__);
+
+	for (i = 0; i < std->node_data_size; i++) {
+		mean[i] /= numFrames;
+		stdTemp[i] = stdTemp[i] / numFrames - (mean[i] * mean[i]);
+		std->node_data[i] = (short)int_sqrt(stdTemp[i]);
+	}
+
+	kfree(stdTemp);
+	stdTemp = NULL;
+	kfree(mean);
+	mean = NULL;
+
+	/* print average frame in the log */
+	print_frame_short(info, "STD =",
+			  array1dTo2d_short(
+				  std->node_data,
+				  std->node_data_size,
+				  std->header.sense_node),
+			  std->header.force_node,
+			  std->header.sense_node);
+
+	if (ret < OK)
+		dev_err(info->dev, "%s: TP sensitivity STD test FAILED... ERROR %08X\n",
+			__func__, ret);
+	else {
+		dev_info(info->dev, "%s: TP sensitivity STD FINISHED!\n",
+			__func__);
+		ret = OK;
+	}
+
+	return ret;
+
+ERROR:
+
+	kfree(frame.node_data);
+	frame.node_data = NULL;
+
+	kfree(std->node_data);
+	std->node_data = NULL;
+
+	kfree(stdTemp);
+	stdTemp = NULL;
+
+	kfree(mean);
+	mean = NULL;
+
+	return ret;
+}
+
+
+/**
+  * Retrieve the actual Test Limit data from the system (bin file or header
+  * file)
+  * @param path name of Production Test Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @param file pointer to the LimitFile struct which will contains the limits
+  * data
+  * @return OK if success or an error code which specify the type of error
+  */
+int getLimitsFile(struct fts_ts_info *info, const char *path, LimitFile *file)
+{
+	const struct firmware *fw = NULL;
+	struct device *dev = NULL;
+	int fd = -1;
+
+	dev_info(info->dev, "Get Limits File starting... %s\n", path);
+
+	if (file->data != NULL) {
+		/* to avoid memory leak on consecutive call of
+		 * the function with the same pointer */
+		dev_err(info->dev, "Pointer to Limits Data already contains something... freeing its content!\n");
+		kfree(file->data);
+		file->data = NULL;
+		file->size = 0;
+	}
+
+	strscpy(file->name, path, sizeof(file->name));
+	if (strncmp(path, "NULL", 4) == 0) {
+#ifdef LIMITS_H_FILE
+		dev_info(info->dev, "Loading Limits File from .h!\n");
+		file->size = LIMITS_SIZE_NAME;
+		file->data = (char *)kmalloc((file->size) * sizeof(char),
+					     GFP_KERNEL);
+		if (file->data != NULL) {
+			memcpy(file->data, (char *)(LIMITS_ARRAY_NAME),
+			       file->size);
+			return OK;
+		} else {
+			dev_err(info->dev, "Error while allocating data... ERROR %08X\n",
+				path, ERROR_ALLOC);
+			return ERROR_ALLOC;
+		}
+#else
+		dev_err(info->dev, "limit file path NULL... ERROR %08X\n",
+			 ERROR_FILE_NOT_FOUND);
+		return ERROR_FILE_NOT_FOUND;
+#endif
+	} else {
+		dev = info->dev;
+		if (dev != NULL) {
+			dev_info(info->dev, "Loading Limits File from .csv!\n");
+			fd = request_firmware(&fw, path, dev);
+			if (fd == 0) {
+				dev_info(info->dev, "Start to copy %s...\n", path);
+				file->size = fw->size;
+				file->data = (char *)kmalloc((file->size) *
+							     sizeof(char),
+							     GFP_KERNEL);
+				if (file->data != NULL) {
+					memcpy(file->data, (char *)fw->data,
+					       file->size);
+					dev_info(info->dev, "Limit file Size = %d\n",
+						file->size);
+					release_firmware(fw);
+					return OK;
+				} else {
+					dev_err(info->dev, "Error while allocating data... ERROR %08X\n",
+						ERROR_ALLOC);
+					release_firmware(fw);
+					return ERROR_ALLOC;
+				}
+			} else {
+				dev_err(info->dev, "Request the file %s failed... ERROR %08X\n",
+					path, ERROR_FILE_NOT_FOUND);
+				return ERROR_FILE_NOT_FOUND;
+			}
+		} else {
+			dev_err(info->dev, "Error while getting the device ERROR %08X\n",
+				ERROR_FILE_READ);
+			return ERROR_FILE_READ;
+		}
+	}
+}
+
+/**
+  * Reset and release the memory which store a Production Limit File previously
+  * loaded
+  * @param file pointer to the LimitFile struct to free
+  * @return OK if success or an error code which specify the type of error
+  */
+
+int freeLimitsFile(LimitFile *file)
+{
+	pr_info("Freeing Limit File ...\n");
+	if (file != NULL) {
+		if (file->data != NULL) {
+			kfree(file->data);
+			file->data = NULL;
+		} else
+			pr_err("Limit File was already freed!\n");
+		file->size = 0;
+		strscpy(file->name, " ", sizeof(file->name));
+		return OK;
+	} else {
+		pr_err("Passed a NULL argument! ERROR %08X\n",
+			 ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+}
+
+/**
+  * Reset and release the memory which store the current Limit File
+  * previously loaded
+  * @return OK if success or an error code which specify the type of error
+  */
+int freeCurrentLimitsFile(struct fts_ts_info *info)
+{
+	return freeLimitsFile(&info->limit_file);
+}
+
+/**
+  * Parse the raw data read from a Production test limit file in order
+  * to find the specified information
+  * If no limits file data are passed, the function loads and stores the limit
+  * file from the system
+  * @param path name of Production Test Limit file to load or
+  * "NULL" if the limits data should be loaded by a .h file
+  * @param file pointer to LimitFile struct that should be parsed or
+  * NULL if the limit file in the system should be loaded and then parsed
+  * @param label string which identify a particular set of data in the file that
+  * want to be loaded
+  * @param data pointer to the pointer which will contains the specified limits
+  * data
+  * as 1 dimension matrix with data arranged row after row
+  * @param row pointer to a int variable which will contain the number of row of
+  * data
+  * @param column pointer to a int variable which will contain the number of
+  * column of data
+  * @return OK if success or an error code which specify the type of error
+  */
+int parseProductionTestLimits(struct fts_ts_info *info, const char *path,
+			      LimitFile *file, char *label, int **data,
+			      int *row, int *column)
+{
+	int find = 0;
+	char *token = NULL;
+	int i = 0;
+	int j = 0;
+	int z = 0;
+
+	char *line2 = NULL;
+	char line[800];
+	char *buf = NULL;
+	int n, size, pointer = 0, ret = OK;
+	char *data_file = NULL;
+
+	if (file == NULL || strcmp(path, file->name) != 0 || file->size == 0) {
+		const char *limits_file = info->board->limits_name;
+
+		dev_info(info->dev, "No limit File data passed... try to get them from the system!\n");
+		ret = getLimitsFile(info, limits_file, &info->limit_file);
+		if (ret < OK) {
+			dev_err(info->dev, "parseProductionTestLimits: ERROR %08X\n",
+				ERROR_FILE_NOT_FOUND);
+			return ERROR_FILE_NOT_FOUND;
+		}
+		size = info->limit_file.size;
+		data_file = info->limit_file.data;
+	} else {
+		dev_info(info->dev, "Limit File data passed as arguments!\n");
+		size = file->size;
+		data_file = file->data;
+	}
+
+
+
+	dev_info(info->dev, "The size of the limits file is %d bytes...\n", size);
+
+
+
+	while (find == 0) {
+		/* start to look for the wanted label */
+		if (readLine(&data_file[pointer], line, size - pointer, &n) <
+		    0) {
+			find = -1;
+			break;
+		}
+		pointer += n;
+		if (line[0] == '*') {
+		/* each header row start with * ex. *label,n_row,n_colum */
+			line2 = kstrdup(line, GFP_KERNEL);
+			if (line2 == NULL) {
+				dev_err(info->dev, "parseProductionTestLimits: kstrdup ERROR %08X\n",
+					ERROR_ALLOC);
+				ret = ERROR_ALLOC;
+				goto END;
+			}
+			buf = line2;
+			line2 += 1;
+			token = strsep(&line2, ",");
+			if (strcmp(token, label) == 0) {
+				/* if the row is the wanted one, r
+				 * retrieve rows and columns info */
+				find = 1;
+				token = strsep(&line2, ",");
+				if (token != NULL) {
+					sscanf(token, "%d", row);
+					dev_info(info->dev, "Row = %d\n", *row);
+				} else {
+					dev_err(info->dev, "parseProductionTestLimits 1: ERROR %08X\n",
+						ERROR_FILE_PARSE);
+					ret = ERROR_FILE_PARSE;
+					goto END;
+				}
+				token = strsep(&line2, ",");
+				if (token != NULL) {
+					sscanf(token, "%d", column);
+					dev_info(info->dev, "Column = %d\n", *column);
+				} else {
+					dev_err(info->dev, "parseProductionTestLimits 2: ERROR %08X\n",
+						ERROR_FILE_PARSE);
+					ret = ERROR_FILE_PARSE;
+					goto END;
+				}
+
+				kfree(buf);
+				buf = NULL;
+				*data = (int *)kmalloc(((*row) * (*column)) *
+						       sizeof(int), GFP_KERNEL);
+			/* allocate the memory for containing the data */
+				j = 0;
+				if (*data == NULL) {
+					dev_err(info->dev, "parseProductionTestLimits: ERROR %08X\n",
+						ERROR_ALLOC);
+					ret = ERROR_ALLOC;
+					goto END;
+				}
+
+
+				/* start to read the data */
+				for (i = 0; i < *row; i++) {
+					if (readLine(&data_file[pointer], line,
+						     size - pointer, &n) < 0) {
+						dev_err(info->dev, "parseProductionTestLimits : ERROR %08X\n",
+							ERROR_FILE_READ);
+						ret = ERROR_FILE_READ;
+						goto END;
+					}
+					pointer += n;
+					line2 = kstrdup(line, GFP_KERNEL);
+					if (line2 == NULL) {
+						dev_err(info->dev, "parseProductionTestLimits: kstrdup ERROR %08X\n",
+							ERROR_ALLOC);
+						ret = ERROR_ALLOC;
+						goto END;
+					}
+					buf = line2;
+					token = strsep(&line2, ",");
+					for (z = 0; (z < *column) && (token !=
+								      NULL);
+					     z++) {
+						sscanf(token, "%d", ((*data) +
+								     j));
+						j++;
+						token = strsep(&line2, ",");
+					}
+					kfree(buf);
+					buf = NULL;
+				}
+				if (j == ((*row) * (*column))) {
+					/* check that all the data are read */
+					dev_info(info->dev, "READ DONE!\n");
+					ret = OK;
+					goto END;
+				}
+				dev_err(info->dev, "parseProductionTestLimits 3: ERROR %08X\n",
+					ERROR_FILE_PARSE);
+				ret = ERROR_FILE_PARSE;
+				goto END;
+			}
+			kfree(buf);
+			buf = NULL;
+		}
+	}
+	dev_err(info->dev, "parseProductionTestLimits: ERROR %08X\n",
+		 ERROR_LABEL_NOT_FOUND);
+	ret = ERROR_LABEL_NOT_FOUND;
+END:
+	if (buf != NULL)
+		kfree(buf);
+	return ret;
+}
+
+
+/**
+  * Read one line of a text file passed as array of byte and terminate it with
+  * a termination character '\0'
+  * @param data text file as array of bytes
+  * @param line pointer to an array of char that will contain the line read
+  * @param size size of data
+  * @param n pointer to a int variable which will contain the number of
+  * characters of the line
+  * @return OK if success or an error code which specify the type of error
+  */
+int readLine(char *data, char *line, int size, int *n)
+{
+	int i = 0;
+
+	if (size < 1)
+		return ERROR_OP_NOT_ALLOW;
+
+	while (data[i] != '\n' && i < size) {
+		line[i] = data[i];
+		i++;
+	}
+	*n = i + 1;
+	line[i] = '\0';
+
+	return OK;
+}
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("STMicroelectronics MultiTouch IC Driver");
+MODULE_AUTHOR("STMicroelectronics");
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsTest.h b/drivers/input/touchscreen/stfts/google/fts_lib/ftsTest.h
new file mode 100644
index 000000000000..e98fec4f1aa3
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsTest.h
@@ -0,0 +1,320 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				**
+  **************************************************************************
+  **                        marco.cali@st.com				**
+  **************************************************************************
+  *                                                                        *
+  *			FTS API for MP test				 **
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsTest.h
+  * \brief Contains all the definitions and structs related to the Mass
+  *Production Test
+  */
+
+#ifndef FTS_TEST_H
+#define FTS_TEST_H
+
+#include "ftsSoftware.h"
+#include "ftsFrame.h"
+
+#ifndef LIMITS_H_FILE
+/* /< Name of the Production Test Limit File */
+#define LIMITS_FILE			"stm_fts_production_limits.csv"
+#else
+#define LIMITS_FILE			"NULL"
+#endif
+
+#define WAIT_FOR_FRESH_FRAMES		200	/* /< Time in ms to wait after
+						 * start to sensing before
+						 * reading a frame */
+#define WAIT_AFTER_SENSEOFF		50	/* /< Time in ms to wait after
+						 * stop sensing and before
+						 * reading a frame from
+						 * memory */
+
+#define NO_INIT				0	/* /< No Initialization required
+						 *  during the MP */
+
+#define RETRY_INIT_BOOT			3	/* /< number of retry of the
+						 * init process at boot */
+
+#define SENS_TEST_NUM_FRAMES		100 /* /< number of frames to read */
+#define SENS_TEST_PERC_TARGET_PRECAL	20	/* /< +-% of target value within
+						 * all the node of the frames
+						 * should be contained */
+#define SENS_TEST_PERC_TARGET_POSTCAL	4	/* /< +-% of target value within
+						 * should be contained the
+						 * avarege of the nodes and the
+						 * deltas for each node */
+
+/** @defgroup mp_test Mass Production Test
+  * Mass production test API.
+  * Mass Production Test (MP) should be executed at least one time in the life
+  * of every device \n
+  * It used to verify that tit is not present any hardware damage and
+  * initialize some value of the chip in order to guarantee the working
+  * performance \n
+  * The MP test is made up by 3 steps:
+  * - ITO test = production_test_ito() \n
+  * - Initialization = production_test_initialization() \n
+  * - Data Test = production_test_data(),
+  * it is possible to select which items test thanks to the TestToDo struct\n
+  * To execute the Data Test it is mandatory load some thresholds that
+  * are stored in the Limit File.
+  * @{
+  */
+
+/** @defgroup limit_file Limit File
+  * @ingroup mp_test
+  * Production Test Limit File is a csv which contains thresholds of the data to
+  * test.
+  * This file can be loaded from the file system or stored as a header file
+  * according to the LIMITS_H_FILE define \n
+  * For each selectable test item there can be one or more associated labels
+  * which store the corresponding thresholds \n
+  * @{
+  */
+/* LABELS PRODUCTION TEST LIMITS FILE */
+/** @defgroup test_labels Test Items Labels
+  * @ingroup limit_file
+  * Labels present in the Limit File and associated to the test items of
+  * TestToDo
+  * @{
+  */
+#define MS_RAW_MIN_MAX			"MS_RAW_DATA_MIN_MAX"
+#define MS_RAW_EACH_NODE_MIN		"MS_RAW_DATA_EACH_MIN"
+#define MS_RAW_EACH_NODE_MAX		"MS_RAW_DATA_EACH_MAX"
+#define MS_RAW_GAP			"MS_RAW_DATA_GAP"
+#define MS_RAW_ADJH			"MS_RAW_DATA_ADJ_HORIZONTAL"
+#define MS_RAW_ADJV			"MS_RAW_DATA_ADJ_VERTICAL"
+#define MS_RAW_ITO_ADJH			"MS_RAW_ITO_DATA_ADJ_HORIZONTAL"
+#define MS_RAW_ITO_ADJV			"MS_RAW_ITO_DATA_ADJ_VERTICAL"
+#define MS_RAW_ITO_MIN_MAX		"MS_RAW_ITO_MIN_MAX"
+#define MS_RAW_ITO_EACH_NODE_MIN	"MS_RAW_ITO_DATA_MIN"
+#define MS_RAW_ITO_EACH_NODE_MAX	"MS_RAW_ITO_DATA_MAX"
+#define MS_RAW_LP_MIN_MAX		"MS_RAW_LOWPOWER_DATA_MIN_MAX"
+#define MS_RAW_LP_EACH_NODE_MIN		"MS_RAW_LOWPOWER_DATA_EACH_MIN"
+#define MS_RAW_LP_EACH_NODE_MAX		"MS_RAW_LOWPOWER_DATA_EACH_MAX"
+#define MS_RAW_LP_GAP			"MS_RAW_LOWPOWER_DATA_GAP"
+#define MS_RAW_LP_ADJH			"MS_RAW_LOWPOWER_DATA_ADJ_HORIZONTAL"
+#define MS_RAW_LP_ADJV			"MS_RAW_LOWPOWER_DATA_ADJ_VERTICAL"
+#define MS_RAW_ADJH_GAP			"MS_RAW_DATA_ADJ_HORIZONTAL_P2P"
+#define MS_RAW_ADJV_GAP			"MS_RAW_DATA_ADJ_VERTICAL_P2P"
+#define MS_RAW_ADJ_PEAK			"MS_RAW_DATA_ADJ_PEAK"
+#define MS_CX1_MIN_MAX			"MS_TOUCH_ACTIVE_CX1_MIN_MAX"
+#define MS_CX2_MAP_MIN			"MS_TOUCH_ACTIVE_CX2_MIN"
+#define MS_CX2_MAP_MAX			"MS_TOUCH_ACTIVE_CX2_MAX"
+#define MS_CX2_ADJH_MAP_MAX		"MS_TOUCH_ACTIVE_CX2_ADJ_HORIZONTAL"
+#define MS_CX2_ADJV_MAP_MAX		"MS_TOUCH_ACTIVE_CX2_ADJ_VERTICAL"
+#define MS_TOTAL_CX_MAP_MIN		"MS_TOUCH_ACTIVE_TOTAL_CX_MIN"
+#define MS_TOTAL_CX_MAP_MAX		"MS_TOUCH_ACTIVE_TOTAL_CX_MAX"
+#define MS_TOTAL_CX_ADJH_MAP_MAX	"MS_TOUCH_ACTIVE_TOTAL_CX_ADJ_HORIZONTAL"
+#define MS_TOTAL_CX_ADJV_MAP_MAX	"MS_TOUCH_ACTIVE_TOTAL_CX_ADJ_VERTICAL"
+#define MS_CX1_LP_MIN_MAX		"MS_TOUCH_LOWPOWER_CX1_MIN_MAX"
+#define MS_CX2_LP_MAP_MIN		"MS_TOUCH_LOWPOWER_CX2_MIN"
+#define MS_CX2_LP_MAP_MAX		"MS_TOUCH_LOWPOWER_CX2_MAX"
+#define MS_CX2_ADJH_LP_MAP_MAX		"MS_TOUCH_LOWPOWER_CX2_ADJ_HORIZONTAL"
+#define MS_CX2_ADJV_LP_MAP_MAX		"MS_TOUCH_LOWPOWER_CX2_ADJ_VERTICAL"
+#define MS_TOTAL_CX_LP_MAP_MIN		"MS_TOUCH_LOWPOWER_TOTAL_CX_MIN"
+#define MS_TOTAL_CX_LP_MAP_MAX		"MS_TOUCH_LOWPOWER_TOTAL_CX_MAX"
+#define MS_TOTAL_CX_ADJH_LP_MAP_MAX "MS_TOUCH_LOWPOWER_TOTAL_CX_ADJ_HORIZONTAL"
+#define MS_TOTAL_CX_ADJV_LP_MAP_MAX "MS_TOUCH_LOWPOWER_TOTAL_CX_ADJ_VERTICAL"
+#define SS_RAW_FORCE_MIN_MAX		"SS_RAW_DATA_FORCE_MIN_MAX"
+#define SS_RAW_FORCE_EACH_NODE_MIN	"SS_RAW_DATA_FORCE_EACH_MIN"
+#define SS_RAW_FORCE_EACH_NODE_MAX	"SS_RAW_DATA_FORCE_EACH_MAX"
+#define SS_RAW_SENSE_MIN_MAX		"SS_RAW_DATA_SENSE_MIN_MAX"
+#define SS_RAW_SENSE_EACH_NODE_MIN	"SS_RAW_DATA_SENSE_EACH_MIN"
+#define SS_RAW_SENSE_EACH_NODE_MAX	"SS_RAW_DATA_SENSE_EACH_MAX"
+#define SS_RAW_FORCE_GAP		"SS_RAW_DATA_FORCE_GAP"
+#define SS_RAW_SENSE_GAP		"SS_RAW_DATA_SENSE_GAP"
+#define SS_RAW_LP_FORCE_MIN_MAX		"SS_RAW_LOWPOWER_DATA_FORCE_MIN_MAX"
+#define SS_RAW_LP_SENSE_MIN_MAX		"SS_RAW_LOWPOWER_DATA_SENSE_MIN_MAX"
+#define SS_RAW_LP_FORCE_EACH_NODE_MIN	"SS_RAW_LOWPOWER_DATA_FORCE_EACH_MIN"
+#define SS_RAW_LP_FORCE_EACH_NODE_MAX	"SS_RAW_LOWPOWER_DATA_FORCE_EACH_MAX"
+#define SS_RAW_LP_SENSE_MIN_MAX		"SS_RAW_LOWPOWER_DATA_SENSE_MIN_MAX"
+#define SS_RAW_LP_SENSE_EACH_NODE_MIN	"SS_RAW_LOWPOWER_DATA_SENSE_EACH_MIN"
+#define SS_RAW_LP_SENSE_EACH_NODE_MAX	"SS_RAW_LOWPOWER_DATA_SENSE_EACH_MAX"
+#define SS_RAW_LP_FORCE_GAP		"SS_RAW_LOWPOWER_DATA_FORCE_GAP"
+#define SS_RAW_LP_SENSE_GAP		"SS_RAW_LOWPOWER_DATA_SENSE_GAP"
+#define SS_IX1_FORCE_MIN_MAX		"SS_TOUCH_ACTIVE_IX1_FORCE_MIN_MAX"
+#define SS_IX1_SENSE_MIN_MAX		"SS_TOUCH_ACTIVE_IX1_SENSE_MIN_MAX"
+#define SS_CX1_FORCE_MIN_MAX		"SS_TOUCH_ACTIVE_CX1_FORCE_MIN_MAX"
+#define SS_CX1_SENSE_MIN_MAX		"SS_TOUCH_ACTIVE_CX1_SENSE_MIN_MAX"
+#define SS_IX2_FORCE_MAP_MIN		"SS_TOUCH_ACTIVE_IX2_FORCE_MIN"
+#define SS_IX2_FORCE_MAP_MAX		"SS_TOUCH_ACTIVE_IX2_FORCE_MAX"
+#define SS_IX2_SENSE_MAP_MIN		"SS_TOUCH_ACTIVE_IX2_SENSE_MIN"
+#define SS_IX2_SENSE_MAP_MAX		"SS_TOUCH_ACTIVE_IX2_SENSE_MAX"
+#define SS_IX2_FORCE_ADJV_MAP_MAX	"SS_TOUCH_ACTIVE_IX2_ADJ_VERTICAL"
+#define SS_IX2_SENSE_ADJH_MAP_MAX	"SS_TOUCH_ACTIVE_IX2_ADJ_HORIZONTAL"
+#define SS_CX2_FORCE_MAP_MIN		"SS_TOUCH_ACTIVE_CX2_FORCE_MIN"
+#define SS_CX2_FORCE_MAP_MAX		"SS_TOUCH_ACTIVE_CX2_FORCE_MAX"
+#define SS_CX2_SENSE_MAP_MIN		"SS_TOUCH_ACTIVE_CX2_SENSE_MIN"
+#define SS_CX2_SENSE_MAP_MAX		"SS_TOUCH_ACTIVE_CX2_SENSE_MAX"
+#define SS_CX2_FORCE_ADJV_MAP_MAX	"SS_TOUCH_ACTIVE_CX2_ADJ_VERTICAL"
+#define SS_CX2_SENSE_ADJH_MAP_MAX	"SS_TOUCH_ACTIVE_CX2_ADJ_HORIZONTAL"
+
+/* TOTAL SS */
+#define SS_TOTAL_IX_FORCE_MAP_MIN	"SS_TOUCH_ACTIVE_TOTAL_IX_FORCE_MIN"
+#define SS_TOTAL_IX_FORCE_MAP_MAX	"SS_TOUCH_ACTIVE_TOTAL_IX_FORCE_MAX"
+#define SS_TOTAL_IX_SENSE_MAP_MIN	"SS_TOUCH_ACTIVE_TOTAL_IX_SENSE_MIN"
+#define SS_TOTAL_IX_SENSE_MAP_MAX	"SS_TOUCH_ACTIVE_TOTAL_IX_SENSE_MAX"
+#define SS_TOTAL_IX_FORCE_ADJV_MAP_MAX	"SS_TOUCH_ACTIVE_TOTAL_IX_ADJ_VERTICAL"
+#define SS_TOTAL_IX_SENSE_ADJH_MAP_MAX \
+	"SS_TOUCH_ACTIVE_TOTAL_IX_ADJ_HORIZONTAL"
+#define SS_TOTAL_CX_FORCE_MAP_MIN	"SS_TOUCH_ACTIVE_TOTAL_CX_FORCE_MIN"
+#define SS_TOTAL_CX_FORCE_MAP_MAX	"SS_TOUCH_ACTIVE_TOTAL_CX_FORCE_MAX"
+#define SS_TOTAL_CX_SENSE_MAP_MIN	"SS_TOUCH_ACTIVE_TOTAL_CX_SENSE_MIN"
+#define SS_TOTAL_CX_SENSE_MAP_MAX	"SS_TOUCH_ACTIVE_TOTAL_CX_SENSE_MAX"
+#define SS_TOTAL_CX_FORCE_ADJV_MAP_MAX	"SS_TOUCH_ACTIVE_TOTAL_CX_ADJ_VERTICAL"
+#define SS_TOTAL_CX_SENSE_ADJH_MAP_MAX \
+	"SS_TOUCH_ACTIVE_TOTAL_CX_ADJ_HORIZONTAL"
+
+/* Idle (LP)  version*/
+#define SS_IX1_LP_FORCE_MIN_MAX		"SS_TOUCH_IDLE_IX1_FORCE_MIN_MAX"
+#define SS_IX1_LP_SENSE_MIN_MAX		"SS_TOUCH_IDLE_IX1_SENSE_MIN_MAX"
+#define SS_CX1_LP_FORCE_MIN_MAX		"SS_TOUCH_IDLE_CX1_FORCE_MIN_MAX"
+#define SS_CX1_LP_SENSE_MIN_MAX		"SS_TOUCH_IDLE_CX1_SENSE_MIN_MAX"
+#define SS_IX2_LP_FORCE_MAP_MIN		"SS_TOUCH_IDLE_IX2_FORCE_MIN"
+#define SS_IX2_LP_FORCE_MAP_MAX		"SS_TOUCH_IDLE_IX2_FORCE_MAX"
+#define SS_IX2_LP_SENSE_MAP_MIN		"SS_TOUCH_IDLE_IX2_SENSE_MIN"
+#define SS_IX2_LP_SENSE_MAP_MAX		"SS_TOUCH_IDLE_IX2_SENSE_MAX"
+#define SS_IX2_LP_FORCE_ADJV_MAP_MAX	"SS_TOUCH_IDLE_IX2_ADJ_VERTICAL"
+#define SS_IX2_LP_SENSE_ADJH_MAP_MAX	"SS_TOUCH_IDLE_IX2_ADJ_HORIZONTAL"
+#define SS_CX2_LP_FORCE_MAP_MIN		"SS_TOUCH_IDLE_CX2_FORCE_MIN"
+#define SS_CX2_LP_FORCE_MAP_MAX		"SS_TOUCH_IDLE_CX2_FORCE_MAX"
+#define SS_CX2_LP_SENSE_MAP_MIN		"SS_TOUCH_IDLE_CX2_SENSE_MIN"
+#define SS_CX2_LP_SENSE_MAP_MAX		"SS_TOUCH_IDLE_CX2_SENSE_MAX"
+#define SS_CX2_LP_FORCE_ADJV_MAP_MAX	"SS_TOUCH_IDLE_CX2_ADJ_VERTICAL"
+#define SS_CX2_LP_SENSE_ADJH_MAP_MAX	"SS_TOUCH_IDLE_CX2_ADJ_HORIZONTAL"
+
+
+/* TOTAL SS */
+#define SS_TOTAL_IX_LP_FORCE_MAP_MIN	"SS_TOUCH_IDLE_TOTAL_IX_FORCE_MIN"
+#define SS_TOTAL_IX_LP_FORCE_MAP_MAX	"SS_TOUCH_IDLE_TOTAL_IX_FORCE_MAX"
+#define SS_TOTAL_IX_LP_SENSE_MAP_MIN	"SS_TOUCH_IDLE_TOTAL_IX_SENSE_MIN"
+#define SS_TOTAL_IX_LP_SENSE_MAP_MAX	"SS_TOUCH_IDLE_TOTAL_IX_SENSE_MAX"
+#define SS_TOTAL_IX_LP_FORCE_ADJV_MAP_MAX \
+	"SS_TOUCH_IDLE_TOTAL_IX_ADJ_VERTICAL"
+#define SS_TOTAL_IX_LP_SENSE_ADJH_MAP_MAX \
+	"SS_TOUCH_IDLE_TOTAL_IX_ADJ_HORIZONTAL"
+#define SS_TOTAL_CX_LP_FORCE_MAP_MIN	"SS_TOUCH_IDLE_TOTAL_CX_FORCE_MIN"
+#define SS_TOTAL_CX_LP_FORCE_MAP_MAX	"SS_TOUCH_IDLE_TOTAL_CX_FORCE_MAX"
+#define SS_TOTAL_CX_LP_SENSE_MAP_MIN	"SS_TOUCH_IDLE_TOTAL_CX_SENSE_MIN"
+#define SS_TOTAL_CX_LP_SENSE_MAP_MAX	"SS_TOUCH_IDLE_TOTAL_CX_SENSE_MAX"
+#define SS_TOTAL_CX_LP_FORCE_ADJV_MAP_MAX \
+	"SS_TOUCH_IDLE_TOTAL_CX_ADJ_VERTICAL"
+#define SS_TOTAL_CX_LP_SENSE_ADJH_MAP_MAX \
+	"SS_TOUCH_IDLE_TOTAL_CX_ADJ_HORIZONTAL"
+
+/* KEYS */
+#define MS_KEY_RAW_MIN_MAX		"MS_KEY_RAW_DATA_MIN_MAX"
+#define MS_KEY_CX1_MIN_MAX		"MS_KEY_CX1_MIN_MAX"
+#define MS_KEY_CX2_MAP_MIN		"MS_KEY_CX2_MIN"
+#define MS_KEY_CX2_MAP_MAX		"MS_KEY_CX2_MAX"
+#define MS_KEY_TOTAL_CX_MAP_MIN		"MS_KEY_TOTAL_CX_MIN"
+#define MS_KEY_TOTAL_CX_MAP_MAX		"MS_KEY_TOTAL_CX_MAX"
+
+/* CONSTANT TOTAL IX */
+#define SS_IX1_FORCE_W			"IX1_FORCE_W"
+#define SS_IX2_FORCE_W			"IX2_FORCE_W"
+#define SS_IX1_SENSE_W			"IX1_SENSE_W"
+#define SS_IX2_SENSE_W			"IX2_SENSE_W"
+
+
+int initTestToDo(struct fts_ts_info *info);
+int computeAdjHoriz(i8 *data, int row, int column, u8 **result);
+int computeAdjHorizTotal(short *data, int row, int column, u16 **result);
+int computeAdjVert(i8 *data, int row, int column, u8 **result);
+int computeAdjVertTotal(short *data, int row, int column, u16 **result);
+int computeAdjHorizFromU(u8 *data, int row, int column, u8 **result);
+int computeAdjHorizTotalFromU(u16 *data, int row, int column, u16 **result);
+int computeAdjVertFromU(u8 *data, int row, int column, u8 **result);
+int computeAdjVertTotalFromU(u16 *data, int row, int column, u16 **result);
+int checkLimitsMinMax(short *data, int row, int column, int min, int max);
+int checkLimitsMap(i8 *data, int row, int column, int *min, int *max);
+int checkLimitsMapTotal(short *data, int row, int column, int *min, int *max);
+int checkLimitsMapFromU(u8 *data, int row, int column, int *min, int *max);
+int checkLimitsMapTotalFromU(u16 *data, int row, int column, int *min,
+			     int *max);
+int checkLimitsMapAdj(u8 *data, int row, int column, int *max);
+int checkLimitsMapAdjTotal(u16 *data, int row, int column, int *max);
+int checkLimitsGap(short *data, int row, int column, int threshold);
+int checkLimitsGapOffsets(short *data, int row, int column, int threshold,
+		int row_start, int column_start, int row_end, int column_end);
+
+/**  @defgroup mp_api MP API
+  * @ingroup mp_test
+  * Functions to execute the MP test.
+  * The parameters of these functions allow to customize their behavior
+  * in order to satisfy different scenarios
+  * @{
+  */
+int production_test_ito(struct fts_ts_info *info, const char *path_limits,
+			MutualSenseFrame *frame, u16 *max_val);
+int production_test_initialization(struct fts_ts_info *info, u8 type);
+int production_test_main(struct fts_ts_info *info, const char *pathThresholds,
+			 int stop_on_fail, int saveInit, u8 mpflag);
+int production_test_ms_raw(struct fts_ts_info *info, const char *path_limits,
+			   int stop_on_fail);
+int production_test_ms_raw_lp(struct fts_ts_info *info,
+			      const char *path_limits, int stop_on_fail);
+int production_test_ms_cx(struct fts_ts_info *info, const char *path_limits,
+			  int stop_on_fail);
+int production_test_ms_cx_lp(struct fts_ts_info *info, const char *path_limits,
+			     int stop_on_fail);
+int production_test_ss_raw(struct fts_ts_info *info, const char *path_limits,
+			   int stop_on_fail);
+int production_test_ss_raw_lp(struct fts_ts_info *info,
+			      const char *path_limits, int stop_on_fail);
+int production_test_ss_ix_cx(struct fts_ts_info *info, const char *path_limits,
+			     int stop_on_fail);
+int production_test_ss_ix_cx_lp(struct fts_ts_info *info,
+				const char *path_limits, int stop_on_fail);
+int production_test_data(struct fts_ts_info *info, const char *path_limits,
+			 int stop_on_fail);
+int production_test_ms_key_cx(struct fts_ts_info *info,
+			      const char *path_limits, int stop_on_fail);
+int production_test_ms_key_raw(struct fts_ts_info *info,
+			       const char *path_limits);
+/** @}*/
+
+/**
+  * @addtogroup limit_file
+  * @{
+  */
+int parseProductionTestLimits(struct fts_ts_info *info, const char *path,
+			      LimitFile *file, char *label, int **data,
+			      int *row, int *column);
+int readLine(char *data, char *line, int size, int *n);
+int getLimitsFile(struct fts_ts_info *info, const char *path, LimitFile *file);
+int freeLimitsFile(LimitFile *file);
+int freeCurrentLimitsFile(struct fts_ts_info *info);
+/**@}*/
+
+int tp_sensitivity_test_pre_cal_ms(struct fts_ts_info *info,
+				   MutualSenseFrame *finalFrame, short target,
+				   int percentage);
+int tp_sensitivity_test_pre_cal_ss(struct fts_ts_info *info,
+				   SelfSenseFrame *finalFrame, short target,
+				   int percentage);
+int tp_sensitivity_compute_gains(struct fts_ts_info *info,
+				  MutualSenseFrame *frame, short target,
+				 int saveGain);
+int tp_sensitivity_test_post_cal_ms(struct fts_ts_info *info,
+				    MutualSenseFrame *finalFrame,
+				    MutualSenseFrame *deltas, short target,
+				    int percentage, int *mean_normal,
+				    int *mean_edge);
+int tp_sensitivity_set_scan_mode(struct fts_ts_info *info, u8 scan, int enableGains);
+int tp_sensitivity_mode(struct fts_ts_info *info, u8 enter, int saveGain);
+int tp_sensitivity_test_std_ms(struct fts_ts_info *info, int numFrames,
+			       MutualSenseFrame *std);
+#endif
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsTime.c b/drivers/input/touchscreen/stfts/google/fts_lib/ftsTime.c
new file mode 100644
index 000000000000..3ddfb74a8ac4
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsTime.c
@@ -0,0 +1,87 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				**
+  **************************************************************************
+  **                        marco.cali@st.com				**
+  **************************************************************************
+  *                                                                        *
+  *                  FTS Utility for mesuring/handling the time		  *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsTime.c
+  * \brief Contains all functions to handle and measure the time in the driver
+  */
+
+#include "ftsTime.h"
+
+
+#include <linux/errno.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+
+
+/**
+  * Take the starting time and save it in a StopWatch variable
+  * @param w pointer of a StopWatch struct
+  */
+void startStopWatch(StopWatch *w)
+{
+	ktime_get_ts64(&w->start);
+}
+
+/**
+  * Take the stop time and save it in a StopWatch variable
+  * @param w pointer of a StopWatch struct
+  */
+void stopStopWatch(StopWatch *w)
+{
+	ktime_get_ts64(&w->end);
+}
+
+/**
+  * Compute the amount of time spent from when the startStopWatch and then
+  * the stopStopWatch were called on the StopWatch variable
+  * @param w pointer of a StopWatch struct
+  * @return amount of time in ms (the return value is meaningless
+  * if the startStopWatch and stopStopWatch were not called before)
+  */
+int elapsedMillisecond(StopWatch *w)
+{
+	int result;
+
+	result = ((w->end.tv_sec - w->start.tv_sec) * 1000) +
+		 (w->end.tv_nsec - w->start.tv_nsec) / 1000000;
+	return result;
+}
+
+/**
+  * Compute the amount of time spent from when the startStopWatch and
+  * then the stopStopWatch were called on the StopWatch variable
+  * @param w pointer of a StopWatch struct
+  * @return amount of time in ns (the return value is meaningless
+  * if the startStopWatch and stopStopWatch were not called before)
+  */
+int elapsedNanosecond(StopWatch *w)
+{
+	int result;
+
+	result = ((w->end.tv_sec - w->start.tv_sec) * 1000000000) +
+		 (w->end.tv_nsec - w->start.tv_nsec);
+	return result;
+}
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("STMicroelectronics MultiTouch IC Driver");
+MODULE_AUTHOR("STMicroelectronics");
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsTime.h b/drivers/input/touchscreen/stfts/google/fts_lib/ftsTime.h
new file mode 100644
index 000000000000..9aa5945e17c7
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsTime.h
@@ -0,0 +1,74 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				 **
+  **************************************************************************
+  **                        marco.cali@st.com				 **
+  **************************************************************************
+  *                                                                        *
+  *                  FTS Utility for measuring/handling the time	   *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsTime.h
+  * \brief Contains all the definitions and structs to handle and measure the
+  * time in the driver
+  */
+
+#ifndef FTS_TIME_H
+#define FTS_TIME_H
+
+
+#include <linux/time.h>
+
+/* TIMEOUT */
+/** @defgroup timeouts	 Timeouts
+  * Definitions of all the Timeout used in several operations
+  * @{
+  */
+#define TIMEOUT_RESOLUTION			50
+/* /< timeout resolution in ms (all timeout should be multiples of this unit) */
+#define GENERAL_TIMEOUT				(15 * TIMEOUT_RESOLUTION)
+/* /< general timeout in ms */
+#define RELEASE_INFO_TIMEOUT			(2 * TIMEOUT_RESOLUTION)
+/* /< timeout to request release info in ms */
+
+
+#define TIMEOUT_REQU_COMP_DATA			(4 * TIMEOUT_RESOLUTION)
+/* /< timeout to request compensation data in ms */
+#define TIMEOUT_REQU_DATA			(8 * TIMEOUT_RESOLUTION)
+/* /< timeout to request data in ms */
+#define TIMEOUT_ITO_TEST_RESULT			(4 * TIMEOUT_RESOLUTION)
+/* /< timeout to perform ito test in ms */
+#define TIMEOUT_INITIALIZATION_TEST_RESULT	(5000 * TIMEOUT_RESOLUTION)
+/* /< timeout to perform initialization test in ms */
+#define TIEMOUT_ECHO 				(50 * TIMEOUT_RESOLUTION)
+/* /< timeout of the echo command,*/
+#define TIMEOUT_ECHO_FLUSH			(TIMEOUT_RESOLUTION)
+/* /< timeout of the flush echo command,*/
+#define TIMEOUT_ECHO_FPI			(200  * TIMEOUT_RESOLUTION)
+/* /< timeout of the Full panel Init echo command */
+#define TIMEOUT_ECHO_SINGLE_ENDED_SPECIAL_AUTOTUNE \
+	(100  * TIMEOUT_RESOLUTION)
+/** @}*/
+
+
+/**
+  * Struct used to measure the time elapsed between a starting and ending point.
+  */
+typedef struct {
+	struct timespec64 start;	/* /< store the starting time */
+	struct timespec64 end;		/* /< store the finishing time */
+} StopWatch;
+
+
+void startStopWatch(StopWatch *w);
+void stopStopWatch(StopWatch *w);
+int elapsedMillisecond(StopWatch *w);
+int elapsedNanosecond(StopWatch *w);
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsTool.c b/drivers/input/touchscreen/stfts/google/fts_lib/ftsTool.c
new file mode 100644
index 000000000000..8e534d6a1947
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsTool.c
@@ -0,0 +1,805 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				 **
+  **************************************************************************
+  **                        marco.cali@st.com				 **
+  **************************************************************************
+  *                                                                        *
+  *                     FTS Utility Functions				   *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsTool.c
+  * \brief Contains all the functions to support common operation inside the
+  * driver
+  */
+
+#include "ftsCompensation.h"
+#include "ftsCore.h"
+#include "ftsError.h"
+#include "ftsHardware.h"
+#include "ftsIO.h"
+#include "ftsSoftware.h"
+#include "ftsTime.h"
+#include "ftsTool.h"
+#include "../fts.h"	/* needed for the tag define */
+
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stdarg.h>
+#include <linux/serio.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+
+
+/**
+  * Print an array of byte in a HEX string and attach at the beginning a label.
+  * The function allocate memory that should be free outside the function itself
+  * @param label string to attach at the beginning
+  * @param buff pointer to the byte array that should be printed as HEX string
+  * @param count size of buff
+  * @param result pointer to the array of characters that compose the HEX final
+  * string
+  * @param size size of result
+  * @return pointer to the array of characters that compose the HEX string,
+  * (same address of result)
+  * @warning result MUST be allocated outside the function and should be
+  * big enough to contain the data converted as HEX!
+  */
+char *printHex(char *label, u8 *buff, int count, u8 *result, int size)
+{
+	int i, offset = 0;
+
+	offset = scnprintf(result + offset, size - offset, "%s", label);
+	for (i = 0; i < count; i++) {
+		offset +=
+			scnprintf(result + offset,
+				 size - offset, "%02X ", buff[i]);
+			/* this append automatically a null terminator char */
+	}
+	return result;
+}
+
+/**
+  * Clear the FIFO from any event
+  * @return OK if success or an error code which specify the type of error
+  */
+int flushFIFO(struct fts_ts_info *info)
+{
+	int ret;
+	u8 sett = SPECIAL_FIFO_FLUSH;
+
+	ret = writeSysCmd(info, SYS_CMD_SPECIAL, &sett, 1);	/* flush the FIFO */
+	if (ret < OK) {
+		dev_err(info->dev, "flushFIFO: ERROR %08X\n", ret);
+		return ret;
+	}
+
+	dev_info(info->dev, "FIFO flushed!\n");
+	return OK;
+}
+
+
+
+/**
+  * Convert an array of bytes to an array of u16 taking two bytes at time,
+  * src has LSB first.
+  * @param src pointer to the source byte array
+  * @param src_length size of src
+  * @param dst pointer to the destination array.
+  * @return the final size of dst (half of the source) or ERROR_OP_NOT_ALLOW
+  * if the size of src is not multiple of 2.
+  */
+int u8ToU16n(u8 *src, int src_length, u16 *dst)
+{
+	int i, j;
+
+	if (src_length % 2 != 0)
+		return ERROR_OP_NOT_ALLOW;
+	else {
+		j = 0;
+		for (i = 0; i < src_length; i += 2) {
+			dst[j] = ((src[i + 1] & 0x00FF) << 8) +
+				 (src[i] & 0x00FF);
+			j++;
+		}
+	}
+
+	return src_length / 2;
+}
+
+/**
+  * Convert an array of 2 bytes to a u16, src has LSB first (little endian).
+  * @param src pointer to the source byte array
+  * @param dst pointer to the destination u16.
+  * @return OK
+  */
+int u8ToU16(u8 *src, u16 *dst)
+{
+	*dst = (u16)(((src[1] & 0x00FF) << 8) + (src[0] & 0x00FF));
+	return OK;
+}
+
+/**
+  * Convert an array of 2 bytes to a u16, src has MSB first (big endian).
+  * @param src pointer to the source byte array
+  * @param dst pointer to the destination u16.
+  * @return OK
+  */
+int u8ToU16_be(u8 *src, u16 *dst)
+{
+	*dst = (u16)(((src[0] & 0x00FF) << 8) + (src[1] & 0x00FF));
+	return OK;
+}
+
+/**
+  * Convert an array of u16 to an array of u8, dst has MSB first (big endian).
+  * @param src pointer to the source array of u16
+  * @param src_length size of src
+  * @param dst pointer to the destination array of u8.
+  * @return size of dst (src size multiply by 2)
+  */
+int u16ToU8n_be(u16 *src, int src_length, u8 *dst)
+{
+	int i, j = 0;
+
+	for (i = 0; i < src_length; i++) {
+		dst[j] 	   = (u8)(src[i] & 0xFF00) >> 8;
+		dst[j + 1] = (u8)(src[i] & 0x00FF);
+		j += 2;
+	}
+
+	return src_length * 2;
+}
+
+/**
+  * Convert a u16 to an array of 2 u8, dst has MSB first (big endian).
+  * @param src u16 to convert
+  * @param dst pointer to the destination array of 2 u8.
+  * @return OK
+  */
+int u16ToU8_be(u16 src, u8 *dst)
+{
+	dst[0] = (u8)((src & 0xFF00) >> 8);
+	dst[1] = (u8)(src & 0x00FF);
+	return OK;
+}
+
+
+/**
+  * Convert a u16 to an array of 2 u8, dst has LSB first (little endian).
+  * @param src u16 to convert
+  * @param dst pointer to the destination array of 2 u8.
+  * @return OK
+  */
+int u16ToU8(u16 src, u8 *dst)
+{
+	dst[1] = (u8)((src & 0xFF00) >> 8);
+	dst[0] = (u8)(src & 0x00FF);
+	return OK;
+}
+
+/**
+  * Convert an array of bytes to a u32, src has LSB first (little endian).
+  * @param src array of bytes to convert
+  * @param dst pointer to the destination u32 variable.
+  * @return OK
+  */
+int u8ToU32(u8 *src, u32 *dst)
+{
+	*dst = (u32)(((src[3] & 0xFF) << 24) + ((src[2] & 0xFF) << 16) +
+		     ((src[1] & 0xFF) << 8) + (src[0] & 0xFF));
+	return OK;
+}
+
+/**
+  * Convert an array of bytes to a u32, src has MSB first (big endian).
+  * @param src array of bytes to convert
+  * @param dst pointer to the destination u32 variable.
+  * @return OK
+  */
+int u8ToU32_be(u8 *src, u32 *dst)
+{
+	*dst = (u32)(((src[0] & 0xFF) << 24) + ((src[1] & 0xFF) << 16) +
+		     ((src[2] & 0xFF) << 8) + (src[3] & 0xFF));
+	return OK;
+}
+
+
+/**
+  * Convert a u32 to an array of 4 bytes, dst has LSB first (little endian).
+  * @param src u32 value to convert
+  * @param dst pointer to the destination array of 4 bytes.
+  * @return OK
+  */
+int u32ToU8(u32 src, u8 *dst)
+{
+	dst[3] = (u8)((src & 0xFF000000) >> 24);
+	dst[2] = (u8)((src & 0x00FF0000) >> 16);
+	dst[1] = (u8)((src & 0x0000FF00) >> 8);
+	dst[0] = (u8)(src & 0x000000FF);
+	return OK;
+}
+
+/**
+  * Convert a u32 to an array of 4 bytes, dst has MSB first (big endian).
+  * @param src u32 value to convert
+  * @param dst pointer to the destination array of 4 bytes.
+  * @return OK
+  */
+int u32ToU8_be(u32 src, u8 *dst)
+{
+	dst[0] = (u8)((src & 0xFF000000) >> 24);
+	dst[1] = (u8)((src & 0x00FF0000) >> 16);
+	dst[2] = (u8)((src & 0x0000FF00) >> 8);
+	dst[3] = (u8)(src & 0x000000FF);
+	return OK;
+}
+
+/**
+  * Execute a function passed as argment and retry it defined number of times if
+  * not successful
+  * @param code pointer to a function which return an int and doesn't have any
+  * parameters
+  * @param wait_before_retry interval of time in ms to wait between one trial
+  * and another one
+  * @param retry_count max number of retry to attemp
+  * @return last return value obtained from the last execution of the code
+  *function
+  */
+int attempt_function(int (*code)(void), unsigned long wait_before_retry, int
+		     retry_count)
+{
+	int result;
+	int count = 0;
+
+	do {
+		result = code();
+		count++;
+		mdelay(wait_before_retry);
+	} while (count < retry_count && result < 0);
+
+
+	if (count == retry_count)
+		return result | ERROR_TIMEOUT;
+	else
+		return result;
+}
+
+/**
+  * Enable all the possible sensing mode supported by the FW
+  * @return OK if success or an error code which specify the type of error
+  */
+int senseOn(struct fts_ts_info *info)
+{
+	int ret;
+
+	ret = setScanMode(info, SCAN_MODE_ACTIVE, 0xFF);	/* enable all */
+	if (ret < OK) {
+		dev_err(info->dev, "senseOn: ERROR %08X\n", ret);
+		return ret;
+	}
+
+	dev_info(info->dev, "senseOn: SENSE ON\n");
+	return OK;
+}
+
+/**
+  * Disable  all the sensing mode
+  * @return  OK if success or an error code which specify the type of error
+  */
+int senseOff(struct fts_ts_info *info)
+{
+	int ret;
+
+	ret = setScanMode(info, SCAN_MODE_ACTIVE, 0x00);
+	if (ret < OK) {
+		dev_err(info->dev, "senseOff: ERROR %08X\n", ret);
+		return ret;
+	}
+
+	dev_info(info->dev, "senseOff: SENSE OFF\n");
+	return OK;
+}
+
+/**
+  * Clean up the IC status executing a system reset and giving
+  * the possibility to re-enabling the sensing
+  * @param enableTouch if 1, re-enable the sensing and the interrupt of the IC
+  * @return OK if success or an error code which specify the type of error
+  */
+int cleanUp(struct fts_ts_info *info, int enableTouch)
+{
+	int res;
+
+	dev_info(info->dev, "cleanUp: system reset...\n");
+	res = fts_system_reset(info);
+	if (res < OK)
+		return res;
+	if (enableTouch) {
+		dev_info(info->dev, "cleanUp: enabling touches...\n");
+		res = senseOn(info);	/* already enable everything */
+		if (res < OK)
+			return res;
+		dev_info(info->dev, "cleanUp: enabling interrupts...\n");
+		res = fts_enableInterrupt(info, true);
+		if (res < OK)
+			return res;
+	}
+	return OK;
+}
+
+/**
+  * Transform an array of short in a matrix of short with a defined number of
+  * columns and the resulting number of rows
+  * @param data array of bytes to convert
+  * @param size size of data
+  * @param columns number of columns that the resulting matrix should have.
+  * @return a reference to a matrix of short where for each row there are
+  * columns elements
+  */
+short **array1dTo2d_short(short *data, int size, int columns)
+{
+	int i;
+	short **matrix = NULL;
+
+	if (size != 0)
+		matrix = (short **)kmalloc_array(((int)(size / columns)),
+				sizeof(short *), GFP_KERNEL);
+
+	if (matrix != NULL) {
+		for (i = 0; i < (int)(size / columns); i++) {
+			matrix[i] = (short *)kmalloc_array(columns,
+					sizeof(short), GFP_KERNEL);
+			if (!matrix[i])
+				break;
+		}
+
+		for (i = 0; i < size; i++) {
+			if (!matrix[i / columns])
+				break;
+			matrix[i / columns][i % columns] = data[i];
+		}
+	}
+
+	return matrix;
+}
+
+/**
+  * Transform an array of u16 in a matrix of u16 with a defined number of
+  * columns and the resulting number of rows
+  * @param data array of bytes to convert
+  * @param size size of data
+  * @param columns number of columns that the resulting matrix should have.
+  * @return a reference to a matrix of u16 where for each row there are columns
+  * elements
+  */
+u16 **array1dTo2d_u16(u16 *data, int size, int columns)
+{
+	int i;
+	u16 **matrix = NULL;
+
+	if (size != 0)
+		matrix = (u16 **)kmalloc_array(((int)(size / columns)),
+				sizeof(u16 *), GFP_KERNEL);
+
+	if (matrix != NULL) {
+		for (i = 0; i < (int)(size / columns); i++) {
+			matrix[i] = (u16 *)kmalloc_array(columns,
+					sizeof(u16), GFP_KERNEL);
+			if (!matrix[i])
+				break;
+		}
+
+		for (i = 0; i < size; i++) {
+			if (!matrix[i / columns])
+				break;
+			matrix[i / columns][i % columns] = data[i];
+		}
+	}
+
+	return matrix;
+}
+
+/**
+  * Transform an array of u8 in a matrix of u8 with a defined number of
+  * columns and the resulting number of rows
+  * @param data array of bytes to convert
+  * @param size size of data
+  * @param columns number of columns that the resulting matrix should have.
+  * @return a reference to a matrix of short where for each row there are
+  * columns elements
+  */
+u8 **array1dTo2d_u8(u8 *data, int size, int columns)
+{
+	int i;
+	u8 **matrix = NULL;
+
+	if (size != 0) {
+		matrix = (u8 **)kmalloc_array(((int)(size / columns)),
+				sizeof(u8 *), GFP_KERNEL);
+	}
+
+	if (matrix != NULL) {
+		for (i = 0; i < (int)(size / columns); i++) {
+			matrix[i] = (u8 *)kmalloc_array(columns,
+					sizeof(u8), GFP_KERNEL);
+			if (!matrix[i])
+				break;
+		}
+
+		for (i = 0; i < size; i++) {
+			if (!matrix[i / columns])
+				break;
+			matrix[i / columns][i % columns] = data[i];
+		}
+	}
+
+	return matrix;
+}
+
+/**
+  * Transform an array of i8 in a matrix of i8 with a defined number of
+  * columns and the resulting number of rows
+  * @param data array of bytes to convert
+  * @param size size of data
+  * @param columns number of columns that the resulting matrix should have.
+  * @return a reference to a matrix of short where for each row there are
+  * columns elements
+  */
+i8 **array1dTo2d_i8(i8 *data, int size, int columns)
+{
+	int i;
+	i8 **matrix = NULL;
+
+	if (size != 0)
+		matrix = (i8 **)kmalloc_array(((int)(size / columns)),
+				sizeof(i8 *), GFP_KERNEL);
+
+	if (matrix != NULL) {
+		for (i = 0; i < (int)(size / columns); i++) {
+			matrix[i] = (i8 *)kmalloc_array(columns,
+					sizeof(i8), GFP_KERNEL);
+			if (!matrix[i])
+				break;
+		}
+
+		for (i = 0; i < size; i++) {
+			if (!matrix[i / columns])
+				break;
+			matrix[i / columns][i % columns] = data[i];
+		}
+	}
+
+	return matrix;
+}
+
+/**
+  * Print in the kernel log a label followed by a matrix of short row x columns
+  * and free its memory
+  * @param label pointer to the string to print before the actual matrix
+  * @param matrix reference to the matrix of short which contain the actual data
+  * @param row number of rows on which the matrix should be print
+  * @param column number of columns for each row
+  */
+void print_frame_short(struct fts_ts_info *info, char *label, short **matrix,
+		       int row, int column)
+{
+	int i, j;
+	int buff_len, index;
+	char *buff;
+
+	dev_info(info->dev, "%s\n", label);
+
+	if (matrix == NULL)
+		return;
+
+	buff_len = (6 + 1) * column + 1; /* -32768 str len: 6 */
+	buff = kzalloc(buff_len, GFP_KERNEL);
+	if (buff == NULL) {
+		dev_err(info->dev, "%s: fail to allocate buffer\n", __func__);
+		return;
+	}
+
+	for (i = 0; i < row; i++) {
+		if (!matrix[i])
+			break;
+		index = 0;
+		for (j = 0; j < column; j++)
+			index += scnprintf(buff + index, buff_len - index,
+					"%d ", matrix[i][j]);
+		dev_info(info->dev, "%s\n", buff);
+		kfree(matrix[i]);
+	}
+	kfree(matrix);
+	kfree(buff);
+}
+
+/**
+  * Print in the kernel log a label followed by a matrix of u16 row x columns
+  * and free its memory
+  * @param label pointer to the string to print before the actual matrix
+  * @param matrix reference to the matrix of u16 which contain the actual data
+  * @param row number of rows on which the matrix should be print
+  * @param column number of columns for each row
+  */
+void print_frame_u16(struct fts_ts_info *info, char *label, u16 **matrix,
+		     int row, int column)
+{
+	int i, j;
+	int buff_len, index;
+	char *buff;
+
+	dev_info(info->dev, "%s\n", label);
+
+	if (matrix == NULL)
+		return;
+
+	buff_len = (5 + 1) * column + 1; /* 65535 str len: 5 */
+	buff = kzalloc(buff_len, GFP_KERNEL);
+	if (buff == NULL) {
+		dev_err(info->dev, "%s: fail to allocate buffer\n", __func__);
+		return;
+	}
+
+	for (i = 0; i < row; i++) {
+		if (!matrix[i])
+			break;
+		index = 0;
+		for (j = 0; j < column; j++)
+			index += scnprintf(buff + index, buff_len - index,
+					"%d ", matrix[i][j]);
+		dev_info(info->dev, "%s\n", buff);
+		kfree(matrix[i]);
+	}
+	kfree(matrix);
+	kfree(buff);
+}
+
+/**
+  * Print in the kernel log a label followed by a matrix of u8 row x columns and
+  * free its memory
+  * @param label pointer to the string to print before the actual matrix
+  * @param matrix reference to the matrix of u8 which contain the actual data
+  * @param row number of rows on which the matrix should be print
+  * @param column number of columns for each row
+  */
+void print_frame_u8(struct fts_ts_info *info, char *label, u8 **matrix,
+		    int row, int column)
+{
+	int i, j;
+	int buff_len, index;
+	char *buff;
+
+	dev_info(info->dev, "%s\n", label);
+
+	if (matrix == NULL)
+		return;
+
+	buff_len = (3 + 1) * column + 1; /* 255 str len: 3 */
+	buff = kzalloc(buff_len, GFP_KERNEL);
+	if (buff == NULL) {
+		dev_err(info->dev, "%s: fail to allocate buffer\n", __func__);
+		return;
+	}
+
+	for (i = 0; i < row; i++) {
+		if (!matrix[i])
+			break;
+		index = 0;
+		for (j = 0; j < column; j++)
+			index += scnprintf(buff + index, buff_len - index,
+					"%d ", matrix[i][j]);
+		dev_info(info->dev, "%s\n", buff);
+		kfree(matrix[i]);
+	}
+	kfree(matrix);
+	kfree(buff);
+}
+
+/**
+  * Print in the kernel log a label followed by a matrix of i8 row x columns and
+  * free its memory
+  * @param label pointer to the string to print before the actual matrix
+  * @param matrix reference to the matrix of u8 which contain the actual data
+  * @param row number of rows on which the matrix should be print
+  * @param column number of columns for each row
+  */
+void print_frame_i8(struct fts_ts_info *info, char *label, i8 **matrix,
+		    int row, int column)
+{
+	int i, j;
+	int buff_len, index;
+	char *buff;
+
+	dev_info(info->dev, "%s\n", label);
+
+	if (matrix == NULL)
+		return;
+
+	buff_len = (4 + 1) * column + 1; /* -128 str len: 4 */
+	buff = kzalloc(buff_len, GFP_KERNEL);
+	if (buff == NULL) {
+		dev_err(info->dev, "%s: fail to allocate buffer\n", __func__);
+		return;
+	}
+
+	for (i = 0; i < row; i++) {
+		if (!matrix[i])
+			break;
+		index = 0;
+		for (j = 0; j < column; j++)
+			index += scnprintf(buff + index, buff_len - index,
+					"%d ", matrix[i][j]);
+		dev_info(info->dev, "%s\n", buff);
+		kfree(matrix[i]);
+	}
+	kfree(matrix);
+	kfree(buff);
+}
+
+/**
+  * Print in the kernel log a label followed by a matrix of u32 row x columns
+  * and free its memory
+  * @param label pointer to the string to print before the actual matrix
+  * @param matrix reference to the matrix of u32 which contain the actual data
+  * @param row number of rows on which the matrix should be print
+  * @param column number of columns for each row
+  */
+void print_frame_u32(struct fts_ts_info *info, char *label, u32 **matrix,
+		     int row, int column)
+{
+	int i, j;
+	int buff_len, index;
+	char *buff;
+
+	dev_info(info->dev, "%s\n", label);
+
+	if (matrix == NULL)
+		return;
+
+	buff_len = (10 + 1) * column + 1; /* 4294967295 str len: 10 */
+	buff = kzalloc(buff_len, GFP_KERNEL);
+	if (buff == NULL) {
+		dev_err(info->dev, "%s: fail to allocate buffer\n", __func__);
+		return;
+	}
+
+	for (i = 0; i < row; i++) {
+		if (!matrix[i])
+			break;
+		index = 0;
+		for (j = 0; j < column; j++)
+			index += scnprintf(buff + index, buff_len - index,
+					"%d ", matrix[i][j]);
+		dev_info(info->dev, "%s\n", buff);
+		kfree(matrix[i]);
+	}
+	kfree(matrix);
+	kfree(buff);
+}
+
+/**
+  * Print in the kernel log a label followed by a matrix of int row x columns
+  * and free its memory
+  * @param label pointer to the string to print before the actual matrix
+  * @param matrix reference to the matrix of int which contain the actual data
+  * @param row number of rows on which the matrix should be print
+  * @param column number of columns for each row
+  */
+void print_frame_int(struct fts_ts_info *info, char *label, int **matrix,
+		     int row, int column)
+{
+	int i, j;
+	int buff_len, index;
+	char *buff;
+
+	dev_info(info->dev, "%s\n", label);
+
+	if (matrix == NULL)
+		return;
+
+	buff_len = (11 + 1) * column + 1; /* -2147483648 str len: 11 */
+	buff = kzalloc(buff_len, GFP_KERNEL);
+	if (buff == NULL) {
+		dev_err(info->dev, "%s: fail to allocate buffer\n", __func__);
+		return;
+	}
+
+	for (i = 0; i < row; i++) {
+		if (!matrix[i])
+			break;
+		index = 0;
+		for (j = 0; j < column; j++)
+			index += scnprintf(buff + index, buff_len - index,
+					"%d ", matrix[i][j]);
+		dev_info(info->dev, "%s\n", buff);
+		kfree(matrix[i]);
+	}
+	kfree(matrix);
+	kfree(buff);
+}
+
+
+/**
+  * Convert an array of bytes to an u64, src has MSB first (big endian).
+  * @param src array of bytes
+  * @param dest pointer to the destination u64.
+  * @param size size of src (can be <= 8)
+  * @return OK if success or ERROR_OP_NOT_ALLOW if size exceed 8
+  */
+int u8ToU64_be(u8 *src, u64 *dest, int size)
+{
+	int i = 0;
+
+	/* u64 temp =0; */
+	if (size > sizeof(u64))
+		return ERROR_OP_NOT_ALLOW;
+
+	*dest = 0;
+	for (i = 0; i < size; i++)
+		*dest |= (u64)(src[i]) << ((size - 1 - i) * 8);
+
+	return OK;
+}
+
+/**
+  * Convert an u64 to an array of bytes, dest has MSB first (big endian).
+  * @param src value of u64
+  * @param dest pointer to the destination array of bytes.
+  * @param size size of src (can be <= 8)
+  * @return OK if success or ERROR_OP_NOT_ALLOW if size exceed 8
+  */
+int u64ToU8_be(u64 src, u8 *dest, int size)
+{
+	int i = 0;
+
+	if (size > sizeof(u64))
+		return ERROR_OP_NOT_ALLOW;
+	else
+		for (i = 0; i < size; i++)
+			dest[i] = (u8)((src >> ((size - 1 - i) * 8)) & 0xFF);
+
+	return OK;
+}
+
+
+
+/*********** NEW API *************/
+
+/**
+  * Convert a value of an id in a bitmask with a 1 in the position of the value
+  * of the id
+  * @param id Value of the ID to convert
+  * @param mask pointer to the bitmask that will be updated with the value of id
+  * @param size dimension in bytes of mask
+  * @return OK if success or ERROR_OP_NOT_ALLOW if size of mask is not enough to
+  * contain ID
+  */
+int fromIDtoMask(u8 id, u8 *mask, int size)
+{
+	if (((int)((id) / 8)) < size) {
+		pr_info("%s: ID = %d Index = %d Position = %d !\n",
+			 __func__, id, ((int)((id) / 8)), (id % 8));
+		mask[((int)((id) / 8))] |= 0x01 << (id % 8);
+		return OK;
+	} else {
+		pr_err("%s: Bitmask too small! Impossible contain ID = %d %d>=%d! ERROR %08X\n",
+			__func__, id, ((int)((id) / 8)), size,
+			ERROR_OP_NOT_ALLOW);
+		return ERROR_OP_NOT_ALLOW;
+	}
+}
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("STMicroelectronics MultiTouch IC Driver");
+MODULE_AUTHOR("STMicroelectronics");
diff --git a/drivers/input/touchscreen/stfts/google/fts_lib/ftsTool.h b/drivers/input/touchscreen/stfts/google/fts_lib/ftsTool.h
new file mode 100644
index 000000000000..3fe0003c2e27
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_lib/ftsTool.h
@@ -0,0 +1,64 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				**
+  **************************************************************************
+  **                        marco.cali@st.com				**
+  **************************************************************************
+  *                                                                        *
+  *                     FTS Utility Functions				   *
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file ftsTool.h
+  * \brief Contains all the definitions to support common operations inside the
+  * driver
+  */
+
+#ifndef FTS_TOOL_H
+#define FTS_TOOL_H
+
+char *printHex(char *label, u8 *buff, int count, u8 *result, int size);
+int u8ToU16(u8 *src, u16 *dst);
+int u8ToU16_be(u8 *src, u16 *dst);
+int u8ToU16n(u8 *src, int src_length, u16 *dst);
+int u16ToU8(u16 src, u8 *dst);
+int u16ToU8_be(u16 src, u8 *dst);
+int u16ToU8n_be(u16 *src, int src_length, u8 *dst);
+int u8ToU32(u8 *src, u32 *dst);
+int u8ToU32_be(u8 *src, u32 *dst);
+int u32ToU8(u32 src, u8 *dst);
+int u32ToU8_be(u32 src, u8 *dst);
+int u8ToU64_be(u8 *src, u64 *dest, int size);
+int u64ToU8_be(u64 src, u8 *dest, int size);
+int attempt_function(int (*code)(void), unsigned long wait_before_retry, int
+		     retry_count);
+int senseOn(struct fts_ts_info *info);
+int senseOff(struct fts_ts_info *info);
+short **array1dTo2d_short(short *data, int size, int columns);
+u16 **array1dTo2d_u16(u16 *data, int size, int columns);
+u8 **array1dTo2d_u8(u8 *data, int size, int columns);
+i8 **array1dTo2d_i8(i8 *data, int size, int columns);
+void print_frame_short(struct fts_ts_info *info, char *label, short **matrix,
+		       int row, int column);
+void print_frame_u16(struct fts_ts_info *info, char *label, u16 **matrix,
+		     int row, int column);
+void print_frame_u8(struct fts_ts_info *info, char *label, u8 **matrix,
+		    int row, int column);
+void print_frame_i8(struct fts_ts_info *info, char *label, i8 **matrix,
+		    int row, int column);
+void print_frame_u32(struct fts_ts_info *info, char *label, u32 **matrix,
+		     int row, int column);
+void print_frame_int(struct fts_ts_info *info, char *label, int **matrix,
+		     int row, int column);
+int cleanUp(struct fts_ts_info *info, int enableTouch);
+int flushFIFO(struct fts_ts_info *info);
+
+/* New API */
+int fromIDtoMask(u8 id, u8 *mask, int size);
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/google/fts_limits.h b/drivers/input/touchscreen/stfts/google/fts_limits.h
new file mode 100644
index 000000000000..35eed0259dab
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_limits.h
@@ -0,0 +1,2045 @@
+#ifndef FTS_LIMITS_H
+#define FTS_LIMITS_H
+// This is an auto generated header file
+//--->Remember to change the name of the two variables!<---
+const uint32_t myArray2_size = 24418;
+
+const uint8_t myArray2[] = {
+	0x2A, 0x46, 0x4F, 0x52, 0x43, 0x45, 0x5F, 0x4C, 0x45, 0x4E, 0x47, 0x54,
+	0x48, 0x2C, 0x31, 0x2C, 0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x31, 0x37, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x53, 0x45, 0x4E, 0x53,
+	0x45, 0x5F, 0x4C, 0x45, 0x4E, 0x47, 0x54, 0x48, 0x2C, 0x31, 0x2C, 0x31,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x33,
+	0x36, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x0D, 0x0A, 0x2A, 0x4B, 0x45, 0x59, 0x5F, 0x4C, 0x45, 0x4E, 0x47, 0x54,
+	0x48, 0x2C, 0x31, 0x2C, 0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x53, 0x53, 0x4B, 0x45, 0x59,
+	0x5F, 0x4C, 0x45, 0x4E, 0x47, 0x54, 0x48, 0x2C, 0x31, 0x2C, 0x31, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A,
+	0x2A, 0x45, 0x4E, 0x5F, 0x4C, 0x50, 0x5F, 0x54, 0x49, 0x4D, 0x45, 0x52,
+	0x5F, 0x43, 0x41, 0x4C, 0x49, 0x42, 0x52, 0x41, 0x54, 0x49, 0x4F, 0x4E,
+	0x2C, 0x31, 0x2C, 0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x45, 0x4E, 0x5F, 0x4D, 0x55, 0x54,
+	0x55, 0x41, 0x4C, 0x5F, 0x41, 0x55, 0x54, 0x4F, 0x54, 0x55, 0x4E, 0x45,
+	0x2C, 0x31, 0x2C, 0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x45, 0x4E, 0x5F, 0x53, 0x45, 0x4C,
+	0x46, 0x5F, 0x41, 0x55, 0x54, 0x4F, 0x54, 0x55, 0x4E, 0x45, 0x2C, 0x31,
+	0x2C, 0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D,
+	0x0A, 0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x2A, 0x45, 0x4E, 0x5F, 0x53, 0x41, 0x56, 0x45, 0x5F,
+	0x43, 0x58, 0x2C, 0x31, 0x2C, 0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x43, 0x58, 0x31, 0x5F,
+	0x57, 0x2C, 0x31, 0x2C, 0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x33, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x43, 0x58, 0x32, 0x5F,
+	0x57, 0x2C, 0x31, 0x2C, 0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x34, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x49, 0x58, 0x31, 0x5F, 0x46,
+	0x4F, 0x52, 0x43, 0x45, 0x5F, 0x57, 0x2C, 0x31, 0x2C, 0x31, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A,
+	0x49, 0x58, 0x32, 0x5F, 0x46, 0x4F, 0x52, 0x43, 0x45, 0x5F, 0x57, 0x2C,
+	0x31, 0x2C, 0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x0D, 0x0A, 0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x49, 0x58, 0x31, 0x5F, 0x53, 0x45, 0x4E,
+	0x53, 0x45, 0x5F, 0x57, 0x2C, 0x31, 0x2C, 0x31, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x49, 0x58,
+	0x32, 0x5F, 0x53, 0x45, 0x4E, 0x53, 0x45, 0x5F, 0x57, 0x2C, 0x31, 0x2C,
+	0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A,
+	0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x0D, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x52, 0x41, 0x57, 0x5F, 0x44, 0x41,
+	0x54, 0x41, 0x5F, 0x4D, 0x49, 0x4E, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31,
+	0x2C, 0x32, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D,
+	0x0A, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A,
+	0x4D, 0x53, 0x5F, 0x52, 0x41, 0x57, 0x5F, 0x44, 0x41, 0x54, 0x41, 0x5F,
+	0x45, 0x41, 0x43, 0x48, 0x5F, 0x4D, 0x49, 0x4E, 0x2C, 0x31, 0x37, 0x2C,
+	0x33, 0x36, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D,
+	0x0A, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x0D, 0x0A, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x0D, 0x0A, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x0D, 0x0A, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x0D, 0x0A, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x0D,
+	0x0A, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30,
+	0x0D, 0x0A, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30,
+	0x30, 0x0D, 0x0A, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30,
+	0x30, 0x30, 0x0D, 0x0A, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32,
+	0x30, 0x30, 0x30, 0x0D, 0x0A, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x2D,
+	0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x52, 0x41,
+	0x57, 0x5F, 0x44, 0x41, 0x54, 0x41, 0x5F, 0x45, 0x41, 0x43, 0x48, 0x5F,
+	0x4D, 0x41, 0x58, 0x2C, 0x31, 0x37, 0x2C, 0x33, 0x36, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x0D,
+	0x0A, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x0D, 0x0A, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x0D, 0x0A, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x0D, 0x0A, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x0D, 0x0A, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x0D, 0x0A,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C,
+	0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30,
+	0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30,
+	0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32,
+	0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x2C, 0x32, 0x30, 0x30, 0x30, 0x0D,
+	0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x52, 0x41, 0x57, 0x5F, 0x49, 0x54, 0x4F,
+	0x5F, 0x44, 0x41, 0x54, 0x41, 0x5F, 0x41, 0x44, 0x4A, 0x5F, 0x48, 0x4F,
+	0x52, 0x49, 0x5A, 0x4F, 0x4E, 0x54, 0x41, 0x4C, 0x2C, 0x31, 0x37, 0x2C,
+	0x33, 0x35, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D,
+	0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x0D, 0x0A, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x0D, 0x0A, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x0D,
+	0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x0D, 0x0A, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x0D, 0x0A, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x0D,
+	0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x0D, 0x0A, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x0D, 0x0A, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x0D, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x52, 0x41, 0x57, 0x5F, 0x49,
+	0x54, 0x4F, 0x5F, 0x44, 0x41, 0x54, 0x41, 0x5F, 0x41, 0x44, 0x4A, 0x5F,
+	0x56, 0x45, 0x52, 0x54, 0x49, 0x43, 0x41, 0x4C, 0x2C, 0x31, 0x36, 0x2C,
+	0x33, 0x36, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D,
+	0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x0D, 0x0A, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x0D, 0x0A, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x0D, 0x0A, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x0D, 0x0A,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x0D,
+	0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30,
+	0x30, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33,
+	0x30, 0x30, 0x0D, 0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C,
+	0x33, 0x30, 0x30, 0x0D, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x53, 0x54, 0x52,
+	0x45, 0x4E, 0x47, 0x54, 0x48, 0x5F, 0x44, 0x41, 0x54, 0x41, 0x5F, 0x4D,
+	0x49, 0x4E, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C, 0x32, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2D, 0x32, 0x30,
+	0x30, 0x2C, 0x32, 0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x54, 0x4F, 0x55,
+	0x43, 0x48, 0x5F, 0x4C, 0x4F, 0x57, 0x50, 0x4F, 0x57, 0x45, 0x52, 0x5F,
+	0x43, 0x58, 0x32, 0x5F, 0x4D, 0x49, 0x4E, 0x2C, 0x31, 0x37, 0x2C, 0x33,
+	0x36, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x0D,
+	0x0A, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x0D, 0x0A, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x0D, 0x0A, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x0D, 0x0A, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x0D, 0x0A, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x0D, 0x0A, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x0D, 0x0A, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x0D, 0x0A, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x0D, 0x0A, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x0D, 0x0A, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x0D, 0x0A, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x0D, 0x0A,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x0D,
+	0x0A, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x0D, 0x0A, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x0D, 0x0A, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35,
+	0x2C, 0x35, 0x0D, 0x0A, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C, 0x35, 0x2C,
+	0x35, 0x2C, 0x35, 0x0D, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x54, 0x4F, 0x55,
+	0x43, 0x48, 0x5F, 0x4C, 0x4F, 0x57, 0x50, 0x4F, 0x57, 0x45, 0x52, 0x5F,
+	0x43, 0x58, 0x32, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x37, 0x2C, 0x33,
+	0x36, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x0D,
+	0x0A, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x0D, 0x0A, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x0D, 0x0A, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x0D, 0x0A, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x0D, 0x0A, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x0D, 0x0A, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x0D, 0x0A, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x0D, 0x0A, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x0D, 0x0A, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x0D, 0x0A, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x0D, 0x0A, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x0D, 0x0A,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x0D,
+	0x0A, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x0D, 0x0A, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34,
+	0x30, 0x0D, 0x0A, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C,
+	0x34, 0x30, 0x0D, 0x0A, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30, 0x2C, 0x34, 0x30,
+	0x2C, 0x34, 0x30, 0x0D, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x54, 0x4F, 0x55,
+	0x43, 0x48, 0x5F, 0x4C, 0x4F, 0x57, 0x50, 0x4F, 0x57, 0x45, 0x52, 0x5F,
+	0x43, 0x58, 0x32, 0x5F, 0x41, 0x44, 0x4A, 0x5F, 0x48, 0x4F, 0x52, 0x49,
+	0x5A, 0x4F, 0x4E, 0x54, 0x41, 0x4C, 0x2C, 0x31, 0x37, 0x2C, 0x33, 0x35,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x0D,
+	0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x0D, 0x0A,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x2A, 0x4D, 0x53, 0x5F, 0x54, 0x4F,
+	0x55, 0x43, 0x48, 0x5F, 0x4C, 0x4F, 0x57, 0x50, 0x4F, 0x57, 0x45, 0x52,
+	0x5F, 0x43, 0x58, 0x32, 0x5F, 0x41, 0x44, 0x4A, 0x5F, 0x56, 0x45, 0x52,
+	0x54, 0x49, 0x43, 0x41, 0x4C, 0x2C, 0x31, 0x36, 0x2C, 0x33, 0x36, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x0D, 0x0A, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x0D, 0x0A,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x0D,
+	0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x0D, 0x0A, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x0D, 0x0A, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x0D, 0x0A, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x0D, 0x0A, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31,
+	0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x0D, 0x0A,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C,
+	0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x0D,
+	0x0A, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30, 0x2C, 0x31, 0x30,
+	0x0D, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x52, 0x41, 0x57, 0x5F, 0x44, 0x41,
+	0x54, 0x41, 0x5F, 0x46, 0x4F, 0x52, 0x43, 0x45, 0x5F, 0x4D, 0x49, 0x4E,
+	0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C, 0x32, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2D, 0x33, 0x30, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x52, 0x41, 0x57,
+	0x5F, 0x4C, 0x4F, 0x57, 0x50, 0x4F, 0x57, 0x45, 0x52, 0x5F, 0x44, 0x41,
+	0x54, 0x41, 0x5F, 0x46, 0x4F, 0x52, 0x43, 0x45, 0x5F, 0x4D, 0x49, 0x4E,
+	0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C, 0x32, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2D, 0x33, 0x30, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55,
+	0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x54, 0x4F,
+	0x54, 0x41, 0x4C, 0x5F, 0x49, 0x58, 0x5F, 0x46, 0x4F, 0x52, 0x43, 0x45,
+	0x5F, 0x4D, 0x49, 0x4E, 0x2C, 0x31, 0x37, 0x2C, 0x31, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x35, 0x30, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A,
+	0x32, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x35, 0x30, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A,
+	0x32, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x35, 0x30, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A,
+	0x32, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x35, 0x30, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A,
+	0x32, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x35, 0x30, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A,
+	0x32, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x35, 0x30, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A,
+	0x32, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43,
+	0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x54, 0x4F, 0x54,
+	0x41, 0x4C, 0x5F, 0x49, 0x58, 0x5F, 0x46, 0x4F, 0x52, 0x43, 0x45, 0x5F,
+	0x4D, 0x41, 0x58, 0x2C, 0x31, 0x37, 0x2C, 0x31, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x34, 0x35, 0x30, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x34,
+	0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x34, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x34, 0x35, 0x30, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x34,
+	0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x34, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x34, 0x35, 0x30, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x34,
+	0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x34, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x34, 0x35, 0x30, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x34,
+	0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x34, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x34, 0x35, 0x30, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x34,
+	0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x34, 0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x34, 0x35, 0x30, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x34,
+	0x35, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x44, 0x45, 0x54, 0x45, 0x43,
+	0x54, 0x5F, 0x54, 0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x49, 0x58, 0x5F, 0x46,
+	0x4F, 0x52, 0x43, 0x45, 0x5F, 0x4D, 0x49, 0x4E, 0x2C, 0x31, 0x37, 0x2C,
+	0x31, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A,
+	0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A,
+	0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A,
+	0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x30, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x53,
+	0x53, 0x5F, 0x44, 0x45, 0x54, 0x45, 0x43, 0x54, 0x5F, 0x54, 0x4F, 0x54,
+	0x41, 0x4C, 0x5F, 0x49, 0x58, 0x5F, 0x46, 0x4F, 0x52, 0x43, 0x45, 0x5F,
+	0x4D, 0x41, 0x58, 0x2C, 0x31, 0x37, 0x2C, 0x31, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x35, 0x30, 0x30, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x35,
+	0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x35, 0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x35, 0x30, 0x30, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x35,
+	0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x35, 0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x35, 0x30, 0x30, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x35,
+	0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x35, 0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x35, 0x30, 0x30, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x35,
+	0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x35, 0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x35, 0x30, 0x30, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x35,
+	0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x35, 0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x35, 0x30, 0x30, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x35,
+	0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x0D, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x52, 0x41, 0x57, 0x5F, 0x44,
+	0x41, 0x54, 0x41, 0x5F, 0x53, 0x45, 0x4E, 0x53, 0x45, 0x5F, 0x4D, 0x49,
+	0x4E, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C, 0x32, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2D, 0x33, 0x30, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x52, 0x41,
+	0x57, 0x5F, 0x4C, 0x4F, 0x57, 0x50, 0x4F, 0x57, 0x45, 0x52, 0x5F, 0x44,
+	0x41, 0x54, 0x41, 0x5F, 0x53, 0x45, 0x4E, 0x53, 0x45, 0x5F, 0x4D, 0x49,
+	0x4E, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C, 0x32, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2D, 0x33, 0x30, 0x30,
+	0x30, 0x2C, 0x33, 0x30, 0x30, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x54, 0x4F,
+	0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x5F, 0x54,
+	0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x49, 0x58, 0x5F, 0x53, 0x45, 0x4E, 0x53,
+	0x45, 0x5F, 0x4D, 0x49, 0x4E, 0x2C, 0x31, 0x2C, 0x33, 0x36, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x31, 0x33, 0x30,
+	0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30,
+	0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30,
+	0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30,
+	0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30,
+	0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30,
+	0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30,
+	0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30,
+	0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30,
+	0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30,
+	0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30,
+	0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30,
+	0x2C, 0x31, 0x33, 0x30, 0x2C, 0x31, 0x33, 0x30, 0x0D, 0x0A, 0x2A, 0x53,
+	0x53, 0x5F, 0x54, 0x4F, 0x55, 0x43, 0x48, 0x5F, 0x41, 0x43, 0x54, 0x49,
+	0x56, 0x45, 0x5F, 0x54, 0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x49, 0x58, 0x5F,
+	0x53, 0x45, 0x4E, 0x53, 0x45, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C,
+	0x33, 0x36, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D,
+	0x0A, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30, 0x2C, 0x33, 0x30, 0x30,
+	0x0D, 0x0A, 0x2A, 0x53, 0x53, 0x5F, 0x44, 0x45, 0x54, 0x45, 0x43, 0x54,
+	0x5F, 0x54, 0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x49, 0x58, 0x5F, 0x53, 0x45,
+	0x4E, 0x53, 0x45, 0x5F, 0x4D, 0x49, 0x4E, 0x2C, 0x31, 0x2C, 0x33, 0x36,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30,
+	0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x0D, 0x0A,
+	0x2A, 0x53, 0x53, 0x5F, 0x44, 0x45, 0x54, 0x45, 0x43, 0x54, 0x5F, 0x54,
+	0x4F, 0x54, 0x41, 0x4C, 0x5F, 0x49, 0x58, 0x5F, 0x53, 0x45, 0x4E, 0x53,
+	0x45, 0x5F, 0x4D, 0x41, 0x58, 0x2C, 0x31, 0x2C, 0x33, 0x36, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x0D, 0x0A, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35,
+	0x2C, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x35, 0x35, 0x0D, 0x0A,
+};
+
+#endif
diff --git a/drivers/input/touchscreen/stfts/google/fts_proc.c b/drivers/input/touchscreen/stfts/google/fts_proc.c
new file mode 100644
index 000000000000..6c4e4e9bc916
--- /dev/null
+++ b/drivers/input/touchscreen/stfts/google/fts_proc.c
@@ -0,0 +1,3773 @@
+/*
+  *
+  **************************************************************************
+  **                        STMicroelectronics				 **
+  **************************************************************************
+  **                        marco.cali@st.com				*
+  **************************************************************************
+  *                                                                        *
+  *                     Utilities published in /proc/fts		*
+  *                                                                        *
+  **************************************************************************
+  **************************************************************************
+  *
+  */
+
+/*!
+  * \file fts_proc.c
+  * \brief contains the function and variables needed to publish a file node in
+  * the file system which allow to communicate with the IC from userspace
+  */
+
+#include <linux/ctype.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include "fts.h"
+#include "fts_lib/ftsCompensation.h"
+#include "fts_lib/ftsCore.h"
+#include "fts_lib/ftsIO.h"
+#include "fts_lib/ftsError.h"
+#include "fts_lib/ftsFrame.h"
+#include "fts_lib/ftsFlash.h"
+#include "fts_lib/ftsTest.h"
+#include "fts_lib/ftsTime.h"
+#include "fts_lib/ftsTool.h"
+
+
+#define DRIVER_TEST_FILE_NODE	"driver_test"	/* /< name of file node
+						 * published */
+#define DIAGNOSTIC_NUM_FRAME	10	/* /< number of frames reading
+					 * iterations during the diagnostic
+					 * test */
+
+
+
+/** @defgroup proc_file_code	 Proc File Node
+  * @ingroup file_nodes
+  * The /proc/fts/driver_test file node provide expose the most important API
+  * implemented into the driver to execute any possible operation into the IC \n
+  * Thanks to a series of Operation Codes, each of them, with a different set of
+  * parameter, it is possible to select a function to execute\n
+  * The result of the function is usually returned into the shell as an ASCII
+  * hex string where each byte is encoded in two chars.\n
+  * @{
+  */
+
+/* Bus operations */
+#define CMD_READ				0x00	/* /< I2C/SPI read: need
+							 * to pass: byteToRead1
+							 * byteToRead0
+							 * (optional) dummyByte
+							 * */
+#define CMD_WRITE				0x01	/* /< I2C/SPI write:
+							 * need to pass: cmd[0]
+							 *  cmd[1] …
+							 * cmd[cmdLength-1] */
+#define CMD_WRITEREAD				0x02	/* /< I2C/SPI writeRead:
+							 * need to pass: cmd[0]
+							 *  cmd[1] …
+							 * cmd[cmdLength-1]
+							 * byteToRead1
+							 * byteToRead0 dummyByte
+							 * */
+#define CMD_WRITETHENWRITEREAD			0x03	/* /< I2C/SPI write then
+							 * writeRead: need to
+							 * pass: cmdSize1
+							 * cmdSize2 cmd1[0]
+							 * cmd1[1] …
+							 * cmd1[cmdSize1-1]
+							 * cmd2[0] cmd2[1] …
+							 * cmd2[cmdSize2-1]
+							 *  byteToRead1
+							 * byteToRead0 */
+#define CMD_WRITEU8UX				0x04
+						/* /< I2C/SPI
+						 * writeU8UX:
+						 * need to pass: cmd
+						 * addrSize addr[0] …
+						 * addr[addrSize-1]
+						 * data[0] data[1] … */
+#define CMD_WRITEREADU8UX			0x05	/* /< I2C/SPI
+							 * writeReadU8UX: need
+							 * to pass: cmd addrSize
+							 * addr[0] …
+							 * addr[addrSize-1]
+							 * byteToRead1
+							 * byteToRead0
+							 * hasDummyByte */
+#define CMD_WRITEU8UXTHENWRITEU8UX		0x06
+						/* /< I2C/SPI writeU8UX
+						 * then writeU8UX: need
+						 * to pass: cmd1
+						 * addrSize1 cmd2
+						 * addrSize2 addr[0] …
+						 * addr[addrSize1+
+						 *      addrSize2-1]
+						 * data[0] data[1] … */
+#define CMD_WRITEU8UXTHENWRITEREADU8UX		0x07	/* /< I2C/SPI writeU8UX
+							 *  then writeReadU8UX:
+							 * need to pass: cmd1
+							 * addrSize1 cmd2
+							 * addrSize2 addr[0] …
+							 * addr[addrSize1+
+							 *      addrSize2-1]
+							 *  byteToRead1
+							 * byteToRead0
+							 * hasDummybyte */
+#define CMD_GETLIMITSFILE			0x08	/* /< Get the Production
+							 * Limits File and print
+							 * its content into the
+							 * shell: need to pass:
+							 * path(optional)
+							 * otherwise select the
+							 * approach chosen at
+							 * compile time */
+#define CMD_GETFWFILE				0x09	/* /< Get the FW file
+							 * and print its content
+							 * into the shell: need
+							 * to pass: path
+							 * (optional) otherwise
+							 * select the approach
+							 * chosen at compile
+							 * time */
+#define CMD_VERSION				0x0A	/* /< Get the driver
+							 * version and other
+							 * driver setting info
+							 * */
+#define CMD_READCONFIG				0x0B	/* /< Read The config
+							 * memory, need to pass:
+							 * addr[0] addr[1]
+							 * byteToRead0
+							 * byteToRead1 */
+
+
+/* GUI utils byte ver */
+#define CMD_READ_BYTE				0xF0	/* /< Byte output
+							 * version of I2C/SPI
+							 * read @see CMD_READ */
+#define CMD_WRITE_BYTE				0xF1	/* /< Byte output
+							 * version of I2C/SPI
+							 * write @see CMD_WRITE
+							 * */
+#define CMD_WRITEREAD_BYTE			0xF2	/* /< Byte output
+							 * version of I2C/SPI
+							 * writeRead @see
+							 * CMD_WRITEREAD */
+#define CMD_WRITETHENWRITEREAD_BYTE		0xF3
+						/* /< Byte output
+						 * version of I2C/SPI
+						 * write then writeRead
+						 * @see
+						 * CMD_WRITETHENWRITEREAD
+						 * */
+#define CMD_WRITEU8UX_BYTE			0xF4	/* /< Byte output
+							 * version of I2C/SPI
+							 * writeU8UX @see
+							 * CMD_WRITEU8UX */
+#define CMD_WRITEREADU8UX_BYTE			0xF5	/* /< Byte output
+							 * version of I2C/SPI
+							 * writeReadU8UX @see
+							 * CMD_WRITEREADU8UX */
+#define CMD_WRITEU8UXTHENWRITEU8UX_BYTE		0xF6
+						/* /< Byte output
+						 * version of I2C/SPI
+						 * writeU8UX then
+						 * writeU8UX @see
+						 * CMD_WRITEU8UXTHENWRITEU8UX
+						 * */
+#define CMD_WRITEU8UXTHENWRITEREADU8UX_BYTE	0xF7
+						/* /< Byte output
+						* version of I2C/SPI
+						* writeU8UX  then
+						* writeReadU8UX @see
+						* CMD_WRITEU8UXTHENWRITEREADU8UX
+						* */
+#define CMD_GETLIMITSFILE_BYTE			0xF8	/* /< Byte output
+							 * version of Production
+							 * Limits File @see
+							 * CMD_GETLIMITSFILE */
+#define CMD_GETFWFILE_BYTE			0xF9	/* /< Byte output
+							 * version of FW file
+							 * need to pass: @see
+							 * CMD_GETFWFILE */
+#define CMD_VERSION_BYTE			0xFA	/* /< Byte output
+							 * version of driver
+							 * version and setting
+							 * @see CMD_VERSION */
+#define CMD_CHANGE_OUTPUT_MODE			0xFF	/* /< Select the output
+							 * mode of the
+							 * scriptless protocol,
+							 * need to pass:
+							 * bin_output = 1 data
+							 * returned as binary,
+							 * bin_output =0 data
+							 * returned as hex
+							 * string */
+
+/* Core/Tools */
+#define CMD_POLLFOREVENT			0x11	/* /< Poll the FIFO for
+							 * an event: need to
+							 * pass: eventLength
+							 * event[0] event[1] …
+							 * event[eventLength-1]
+							 * timeToWait1
+							 * timeToWait0 */
+#define CMD_SYSTEMRESET				0x12	/* /< System Reset */
+#define CMD_CLEANUP				0x13	/* /< Perform a system
+							 * reset and optionally
+							 * re-enable the
+							 * scanning, need to
+							 * pass: enableTouch */
+#define CMD_POWERCYCLE				0x14	/* /< Execute a power
+							 * cycle toggling the
+							 * regulators */
+#define CMD_READSYSINFO				0x15	/* /< Read the System
+							 * Info information from
+							 * the framebuffer, need
+							 * to pass: doRequest */
+#define CMD_FWWRITE				0x16
+						/* /< Write a FW
+						 * command: need to
+						 * pass: cmd[0]  cmd[1]
+						 * … cmd[cmdLength-1] */
+#define CMD_INTERRUPT				0x17	/* /< Allow to enable or
+							 * disable the
+							 * interrupts, need to
+							 * pass: enable (if 1
+							 * will enable the
+							 * interrupt) */
+#define CMD_SETSCANMODE				0x18	/* /< set Scan Mode
+							 * need to pass:
+							 * scanType option
+							 */
+#define CMD_SAVEMPFLAG				0x19	/* /< save manually a
+							 * value in the MP flag
+							 * need to pass: mpflag
+							 */
+
+/* Frame */
+#define CMD_GETFORCELEN				0x20	/* /< Get the number of
+							 * Force channels */
+#define CMD_GETSENSELEN				0x21	/* /< Get the number of
+							 * Sense channels */
+#define CMD_GETMSFRAME				0x23	/* /< Get a MS frame:
+							 * need to pass:
+							 * MSFrameType */
+#define CMD_GETSSFRAME				0x24	/* /< Get a SS frame:
+							 * need to pass:
+							 * SSFrameType */
+#define CMD_GETSYNCFRAME			0x25	/* /< Get a SS frame:
+							 * need to pass:
+							 * SSFrameType
+							 */
+
+/* Compensation */
+#define CMD_REQCOMPDATA				0x30	/* /< Request Init data:
+							 * need to pass: type */
+#define CMD_READCOMPDATAHEAD			0x31	/* /< Read Init data
+							 * header: need to pass:
+							 * type */
+#define CMD_READMSCOMPDATA			0x32	/* /< Read MS Init data:
+							 * need to pass: type */
+#define CMD_READSSCOMPDATA			0x33	/* /< Read SS Init data:
+							 * need to pass: type */
+#define CMD_READGOLDENMUTUAL			0x34	/* /< Read GoldenMutual
+							   raw data */
+#define CMD_READTOTMSCOMPDATA			0x35	/* /< Read Tot MS Init
+							 * data: need to pass:
+							 * type */
+#define CMD_READTOTSSCOMPDATA			0x36	/* /< Read Tot SS Init
+							 * data: need to pass:
+							 * type */
+#define CMD_READSENSCOEFF			0x37	/* /< Read MS and SS
+							 * Sensitivity
+							 * Calibration
+							 * Coefficients */
+
+/* FW Update */
+#define CMD_GETFWVER				0x40	/* /< Get the FW version
+							 * of the IC */
+#define CMD_FLASHUNLOCK				0x42	/* /< Unlock the flash
+							 * */
+#define CMD_READFWFILE				0x43	/* /< Try to read the FW
+							 * file, need to pass:
+							 * keep_cx */
+#define CMD_FLASHPROCEDURE			0x44	/* /< Perform a full
+							 * flashing procedure:
+							 * need to pass: force
+							 * keep_cx */
+#define CMD_FLASHERASEUNLOCK			0x45	/* /< Unlock the erase
+							 * of the flash */
+#define CMD_FLASHERASEPAGE			0x46
+						/* /< Erase page by page
+						 * the flash, need to
+						 * pass: keep_cx, if
+						 * keep_cx>SKIP_PANEL_INIT
+						 * Panel Init Page will
+						 * be skipped, if
+						 * >SKIP_PANEL_CX_INIT
+						 * Cx and Panel Init
+						 * Pages will be skipped
+						 * otherwise if
+						 * =ERASE_ALL all the
+						 * pages will be deleted
+						 * */
+
+/* MP test */
+#define CMD_ITOTEST				0x50	/* /< Perform an ITO
+							 * test */
+#define CMD_INITTEST				0x51	/* /< Perform an
+							 * Initialization test:
+							 * need to pass: type */
+#define CMD_MSRAWTEST				0x52	/* /< Perform MS raw
+							 * test: need to pass
+							 * stop_on_fail */
+#define CMD_MSINITDATATEST			0x53	/* /< Perform MS Init
+							 * data test: need to
+							 * pass stop_on_fail */
+#define CMD_SSRAWTEST				0x54	/* /< Perform SS raw
+							 * test: need to pass
+							 * stop_on_fail */
+#define CMD_SSINITDATATEST			0x55	/* /< Perform SS Init
+							 * data test: need to
+							 * pass stop_on_fail */
+#define CMD_MAINTEST				0x56	/* /< Perform a full
+							 * Mass production test:
+							 * need to pass
+							 * stop_on_fail saveInit
+							 * */
+#define CMD_FREELIMIT				0x57	/* /< Free (if any)
+							 * limit file which was
+							 * loaded during any
+							 * test procedure */
+
+/* Diagnostic */
+#define CMD_DIAGNOSTIC				0x60	/* /< Perform a series
+							 * of commands and
+							 * collect severals data
+							 * to detect any
+							 * malfunction */
+
+#define CMD_CHANGE_SAD				0x70	/* /< Allow to change
+							 * the SAD address (for
+							 * debugging) */
+#define CMD_INFOBLOCK_STATUS			0x61	/* /< Check for Info
+							 * block error */
+
+/* Debug functionalities requested by Google for B1 Project */
+#define CMD_TRIGGER_FORCECAL			0x80	/* /< Trigger manually
+							 * forcecal for MS and
+							 * SS */
+#define CMD_BASELINE_ADAPTATION			0x81	/* /< Enable/Disable
+							 * Baseline adaptation,
+							 * need to pass: enable
+							 * */
+#define CMD_FREQ_HOP				0x82	/* /< Enable/Disable
+							 * Frequency hopping,
+							 * need to pass: enable
+							 * */
+#define CMD_SET_OPERATING_FREQ			0x83	/* /< Set a defined
+							 * scanning frequency in
+							 * Hz passed as 4 bytes
+							 * in big endian, need
+							 * to pass: freq3 freq2
+							 * freq1 freq0 */
+#define CMD_READ_SYNC_FRAME			0x84
+						/* /< Read Sync Frame
+						 * which contain MS and
+						 * SS data, need to
+						 * pass: frameType (this
+						 * parameter can be
+						 * LOAD_SYNC_FRAME_STRENGTH
+						 * or LOAD_SYNC_FRAME_BASELINE)
+						 * */
+
+
+#define CMD_TP_SENS_MODE			0x90	/* /< Enter/Exit in the
+							 * TP Sensitivity
+							 * Calibration mode,
+							 * need to pass: enter
+							 * (optional)saveGain */
+#define CMD_TP_SENS_SET_SCAN_MODE		0x91	/* /< Set scan mode type
+							 * which should be used
+							 * for the test before
+							 * the stimpad is down,
+							 * need to pass: type */
+#define CMD_TP_SENS_PRECAL_SS			0x92	/* /< Perform Pre
+							 * Calibration for SS
+							 * steps when stimpad is
+							 * down */
+#define CMD_TP_SENS_PRECAL_MS			0x93	/* /< Perform Pre
+							 * Calibration for MS
+							 * steps when stimpad is
+							 * down */
+#define CMD_TP_SENS_POSTCAL_MS			0x94	/* /< Perform Post
+							 * Calibration for MS
+							 * steps when stimpad is
+							 * down */
+#define CMD_TP_SENS_STD				0x95	/* /< Compute the
+							 * Standard deviation of
+							 * a certain number of
+							 * frames, need to pass:
+							 * numFrames */
+
+#define CMD_FORCE_TOUCH_ACTIVE			0xA0	/* /< Prevent the driver
+							 * from transitioning
+							 * the ownership of the
+							 * bus to SLPI
+							 */
+
+/** @}*/
+
+/** @defgroup scriptless Scriptless Protocol
+  * @ingroup proc_file_code
+  * Scriptless Protocol allows ST Software (such as FingerTip Studio etc) to
+  * communicate with the IC from an user space.
+  * This mode gives access to common bus operations (write, read etc) and
+  * support additional functionalities. \n
+  * The protocol is based on exchange of binary messages included between a
+  * start and an end byte
+  * @{
+  */
+
+#define MESSAGE_START_BYTE	0x7B	/* /< start byte of each message
+					 * transferred in Scriptless Mode */
+#define MESSAGE_END_BYTE	0x7D	/* /< end byte of each message
+					 * transferred in Scriptless Mode */
+#define MESSAGE_MIN_HEADER_SIZE 8	/* /< minimun number of bytes of the
+					 * structure of a messages exchanged
+					 * with host (include start/end byte,
+					 * counter, actions, msg_size) */
+
+
+/************************ SEQUENTIAL FILE UTILITIES **************************/
+/**
+  * This function is called at the beginning of the stream to a sequential file
+  * or every time into the sequential were already written PAGE_SIZE bytes and
+  * the stream need to restart
+  * @param s pointer to the sequential file on which print the data
+  * @param pos pointer to the offset where write the data
+  * @return NULL if there is no data to print or the pointer to the beginning of
+  * the data that need to be printed
+  */
+static void *fts_seq_start(struct seq_file *s, loff_t *pos)
+{
+	struct fts_ts_info *info = pde_data(file_inode(s->file));
+
+	dev_info(info->dev, "%s: Entering start(), pos = %lld limit = %d printed = %d\n",
+		__func__, *pos, info->limit, info->printed);
+
+	if (info->driver_test_buff == NULL && *pos == 0) {
+		int size = 13 * sizeof(u8);
+
+		dev_info(info->dev, "%s: No data to print!\n", __func__);
+		info->driver_test_buff = (u8 *)kmalloc(size, GFP_KERNEL);
+		info->limit = scnprintf(info->driver_test_buff,
+				  size,
+				  "{ %08X }\n", ERROR_OP_NOT_ALLOW);
+		/* dev_err(info->dev, "%s: len = %d driver_test_buff = %s\n",
+		 * __func__, info->limit, info->driver_test_buff); */
+	} else {
+		if (*pos != 0)
+			*pos = info->printed;
+
+		if (*pos >= info->limit)
+			/* dev_err(info->dev, "%s: Apparently, we're done.\n", __func__); */
+			return NULL;
+	}
+
+	info->chunk = CHUNK_PROC;
+	if (info->limit - *pos < CHUNK_PROC)
+		info->chunk = info->limit - *pos;
+	/* dev_err(info->dev, "%s: In start(),
+	 *	updated pos = %Ld limit = %d printed = %d chunk = %d\n",
+	 *	__func__, *pos, info->limit, info->printed, info->chunk); */
+	memset(info->buf_chunk, 0, CHUNK_PROC);
+	memcpy(info->buf_chunk, &info->driver_test_buff[(int)*pos], info->chunk);
+
+	return info->buf_chunk;
+}
+
+/**
+  * This function actually print a chunk amount of data in the sequential file
+  * @param s pointer to the sequential file where to print the data
+  * @param v pointer to the data to print
+  * @return 0
+  */
+static int fts_seq_show(struct seq_file *s, void *v)
+{
+	struct fts_ts_info *info = pde_data(file_inode(s->file));
+
+	/* dev_err(info->dev, "%s: In show()\n", __func__); */
+	if (seq_write(s, (u8 *)v, info->chunk) == 0)
+		info->printed += info->chunk;
+	return 0;
+}
+
+/**
+  * This function update the pointer and the counters to the next data to be
+  * printed
+  * @param s pointer to the sequential file where to print the data
+  * @param v pointer to the data to print
+  * @param pos pointer to the offset where write the next data
+  * @return NULL if there is no data to print or the pointer to the beginning of
+  * the next data that need to be printed
+  */
+static void *fts_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	struct fts_ts_info *info = pde_data(file_inode(s->file));
+
+	/* int* val_ptr; */
+	/* dev_err(info->dev, "%s: In next(), v = %X, pos = %Ld.\n", __func__,
+	 * v, *pos); */
+	(*pos) += info->chunk;/* increase my position counter */
+	info->chunk = CHUNK_PROC;
+
+	/* dev_err(info->dev, "%s: In next(),
+	 *	updated pos = %Ld limit = %d printed = %d\n",
+	 *	__func__, *pos, info->limit, info->printed); */
+	if (*pos >= info->limit)	/* are we done? */
+		return NULL;
+	else if (info->limit - *pos < CHUNK_PROC)
+		info->chunk = info->limit - *pos;
+
+
+	memset(info->buf_chunk, 0, CHUNK_PROC);
+	memcpy(info->buf_chunk, &info->driver_test_buff[(int)*pos], info->chunk);
+	return info->buf_chunk;
+}
+
+
+/**
+  * This function is called when there are no more data to print  the stream
+  *need to be terminated or when PAGE_SIZE data were already written into the
+  *sequential file
+  * @param s pointer to the sequential file where to print the data
+  * @param v pointer returned by fts_seq_next
+  */
+static void fts_seq_stop(struct seq_file *s, void *v)
+{
+	struct fts_ts_info *info = pde_data(file_inode(s->file));
+
+	/* dev_err(info->dev, "%s: Entering stop().\n", __func__); */
+
+	if (v) {
+		/* dev_err(info->dev, "%s: v is %X.\n", __func__, v); */
+	} else {
+		/* dev_err(info->dev, "%s: v is null.\n", __func__); */
+		info->limit = 0;
+		info->chunk = 0;
+		info->printed = 0;
+		if (info->driver_test_buff != NULL) {
+		/* dev_err(info->dev, "%s: Freeing and clearing driver_test_buff.\n",
+		 *   __func__); */
+			kfree(info->driver_test_buff);
+			info->driver_test_buff = NULL;
+		} else {
+		/* dev_err(info->dev, "%s: driver_test_buff is already null.\n",
+		 *   __func__); */
+		}
+	}
+}
+
+/**
+  * Struct where define and specify the functions which implements the flow for
+  * writing on a sequential file
+  */
+static const struct seq_operations fts_seq_ops = {
+	.start	= fts_seq_start,
+	.next	= fts_seq_next,
+	.stop	= fts_seq_stop,
+	.show	= fts_seq_show
+};
+
+/**
+  * This function open a sequential file
+  * @param inode Inode in the file system that was called and triggered this
+  * function
+  * @param file file associated to the file node
+  * @return error code, 0 if success
+  */
+static int fts_driver_test_open(struct inode *inode, struct file *file)
+{
+	int retval;
+	struct fts_ts_info *info = pde_data(inode);
+
+	if (!info) {
+		dev_err(info->dev, "%s: Unable to access driver data\n", __func__);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	if (!mutex_trylock(&info->diag_cmd_lock)) {
+		dev_err(info->dev, "%s: Blocking concurrent access\n", __func__);
+		retval = -EBUSY;
+		goto exit;
+	}
+
+	/* Allowing only a single process to open diag procfs node */
+	if (info->diag_node_open == true) {
+		dev_err(info->dev, "%s: Blocking multiple open\n", __func__);
+		retval = -EBUSY;
+		goto unlock;
+	}
+
+	retval = seq_open(file, &fts_seq_ops);
+	if(!retval) {
+		info->diag_node_open = true;
+	}
+
+unlock:
+	mutex_unlock(&info->diag_cmd_lock);
+exit:
+	return retval;
+};
+
+/**
+  * This function closes a sequential file
+  * @param inode Inode in the file system that was called and triggered this
+  * function
+  * @param file file associated to the file node
+  * @return error code, 0 if success
+  */
+static int fts_driver_test_release(struct inode *inode, struct file *file)
+{
+	int retval;
+	struct fts_ts_info *info = pde_data(inode);
+
+	if (info)
+		mutex_lock(&info->diag_cmd_lock);
+	else
+		dev_err(info->dev, "%s: Unable to access driver data\n", __func__);
+
+	retval = seq_release(inode, file);
+
+	if (info) {
+		info->diag_node_open = false;
+		mutex_unlock(&info->diag_cmd_lock);
+	}
+
+	return retval;
+}
+
+/*****************************************************************************/
+
+/**************************** DRIVER TEST ************************************/
+
+/** @addtogroup proc_file_code
+  * @{
+  */
+
+/**
+  * Receive the OP code and the inputs from shell when the file node is called,
+  * parse it and then execute the corresponding function
+  * echo cmd+parameters > /proc/fts/driver_test to execute the select command
+  * cat /proc/fts/driver_test			to obtain the result into the
+  * shell \n
+  * the string returned in the shell is made up as follow: \n
+  * { = start byte \n
+  * the answer content and format strictly depend on the cmd executed. In
+  * general can be: an HEX string or a byte array (e.g in case of 0xF- commands)
+  * \n
+  * } = end byte \n
+  */
+static ssize_t fts_driver_test_write(struct file *file, const char __user *buf,
+				     size_t count, loff_t *pos)
+{
+	int numberParam = 0;
+	struct fts_ts_info *info = pde_data(file_inode(file));
+	char *p = NULL;
+	char *pbuf = NULL;
+	char path[100] = { 0 };
+	int res = -1, j, index = 0;
+	u8 report = 0;
+	int size = 6;
+	int temp, byte_call = 0;
+	u16 byteToRead = 0;
+	u32 fileSize = 0;
+	u8 *readData = NULL;
+	u8 *cmd = NULL;	/* worst case needs count bytes */
+	u32 maxNum_cmd = 0;
+	u32 *funcToTest = NULL;
+	u32 maxNum_funcToTest = 0;
+	u64 addr = 0;
+	MutualSenseFrame frameMS;
+	MutualSenseFrame deltas;
+	SelfSenseFrame frameSS;
+	u8 error_to_search[2] = { EVT_TYPE_ERROR_OSC_TRIM,
+				  EVT_TYPE_ERROR_AOFFSET_TRIM };
+
+	DataHeader dataHead;
+	MutualSenseData compData;
+	SelfSenseData comData;
+	TotMutualSenseData totCompData;
+	TotSelfSenseData totComData;
+	MutualSenseCoeff msCoeff;
+	SelfSenseCoeff ssCoeff;
+	GoldenMutualRawData gmRawData;
+	int meanNorm = 0, meanEdge = 0;
+
+	u64 address;
+	u16 ito_max_val[2] = {0x00};
+	char *label[4];
+
+	Firmware fw;
+	LimitFile lim;
+	const char *limits_file = info->board->limits_name;
+
+	if (!info) {
+		dev_err(info->dev, "%s: Unable to access driver data\n", __func__);
+		count =  -ENODEV;
+		goto exit;
+	}
+
+	info->mess.dummy = 0;
+	info->mess.action = 0;
+	info->mess.msg_size = 0;
+
+	if (fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, true) < 0) {
+		res = ERROR_BUS_WR;
+		dev_err(info->dev, "%s: bus is not accessible.\n", __func__);
+		if (info->driver_test_buff)
+			info->limit = scnprintf(info->driver_test_buff, size,
+						"{ %08X }\n", res);
+		fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+		goto ERROR;
+	}
+
+	if (count < 2) {
+		res = ERROR_OP_NOT_ALLOW;
+		goto ERROR;
+	}
+
+	/* alloc one more space to store '\0' at the end
+	 * for "echo -n CMDs" case
+	 */
+	pbuf = kmalloc((count + 1) * sizeof(*pbuf), GFP_KERNEL);
+	if (!pbuf) {
+		res = ERROR_ALLOC;
+		goto ERROR;
+	}
+	pbuf[count] = '\0';
+
+
+	maxNum_funcToTest = (count + 1) / 3;
+	funcToTest = kmalloc_array(maxNum_funcToTest, sizeof(*funcToTest),
+			     GFP_KERNEL);
+	if (!funcToTest) {
+		res = ERROR_ALLOC;
+		goto ERROR;
+	}
+
+	/*for(temp = 0; temp<count; temp++){
+	  *      dev_err(info->dev, "p[%d] = %02X\n", temp, p[temp]);
+	  * }*/
+	if (access_ok(buf, count) < OK ||
+	    copy_from_user(pbuf, buf, count) != 0) {
+		res = ERROR_ALLOC;
+		goto END;
+	}
+
+	maxNum_cmd = count;
+	cmd = (u8 *)kmalloc_array(maxNum_cmd, sizeof(u8), GFP_KERNEL);
+	if (cmd == NULL) {
+		res = ERROR_ALLOC;
+		dev_err(info->dev, "%s: Impossible allocate memory... ERROR %08X!\n",
+			__func__, res);
+		goto ERROR;
+	}
+
+	p = pbuf;
+	if (count > MESSAGE_MIN_HEADER_SIZE - 1 && p[0] == MESSAGE_START_BYTE) {
+		dev_info(info->dev, "Enter in Byte Mode!\n");
+		byte_call = 1;
+		info->mess.msg_size = (p[1] << 8) | p[2];
+		info->mess.counter = (p[3] << 8) | p[4];
+		info->mess.action = (p[5] << 8) | p[6];
+		dev_info(info->dev, "Message received: size = %d, counter_id = %d, action = %04X\n",
+			info->mess.msg_size, info->mess.counter,
+			info->mess.action);
+		size = MESSAGE_MIN_HEADER_SIZE + 2;	/* +2 error code */
+		if (count < info->mess.msg_size || p[count - 2] !=
+						   MESSAGE_END_BYTE) {
+			dev_err(info->dev, "number of byte received or end byte wrong! msg_size = %d != %zu, last_byte = %02X != %02X ... ERROR %08X\n",
+				info->mess.msg_size, count, p[count - 1],
+				MESSAGE_END_BYTE, ERROR_OP_NOT_ALLOW);
+			res = ERROR_OP_NOT_ALLOW;
+			goto END;
+		} else {
+			numberParam = info->mess.msg_size - MESSAGE_MIN_HEADER_SIZE +
+				      1;	/* +1 because put the internal
+						 * op code */
+			size = MESSAGE_MIN_HEADER_SIZE + 2;	/* +2 send also
+								 * the first 2
+								 * lsb of the
+								 * error code */
+			switch (info->mess.action) {
+			case ACTION_READ:
+				/* numberParam =
+				 * info->mess.msg_size-MESSAGE_MIN_HEADER_SIZE+1; */
+				cmd[0] = funcToTest[0] = CMD_READ_BYTE;
+				break;
+
+			case ACTION_WRITE:
+				cmd[0] = funcToTest[0] = CMD_WRITE_BYTE;
+				break;
+
+			case ACTION_WRITE_READ:
+				cmd[0] = funcToTest[0] = CMD_WRITEREAD_BYTE;
+				break;
+
+			case ACTION_GET_VERSION:
+				cmd[0] = funcToTest[0] = CMD_VERSION_BYTE;
+				break;
+
+			case ACTION_WRITETHENWRITEREAD:
+				cmd[0] = funcToTest[0] =
+						 CMD_WRITETHENWRITEREAD_BYTE;
+				break;
+
+			case ACTION_WRITEU8UX:
+				cmd[0] = funcToTest[0] = CMD_WRITEU8UX_BYTE;
+				break;
+
+			case ACTION_WRITEREADU8UX:
+				cmd[0] = funcToTest[0] = CMD_WRITEREADU8UX_BYTE;
+				break;
+
+			case ACTION_WRITEU8UXTHENWRITEU8UX:
+				cmd[0] = funcToTest[0] =
+					 CMD_WRITEU8UXTHENWRITEU8UX_BYTE;
+				break;
+
+			case ACTION_WRITEU8XTHENWRITEREADU8UX:
+				cmd[0] = funcToTest[0] =
+					 CMD_WRITEU8UXTHENWRITEREADU8UX_BYTE;
+				break;
+
+			case ACTION_GET_FW:
+				cmd[0] = funcToTest[0] = CMD_GETFWFILE_BYTE;
+				break;
+
+			case ACTION_GET_LIMIT:
+				cmd[0] = funcToTest[0] = CMD_GETLIMITSFILE_BYTE;
+				break;
+
+			default:
+				dev_err(info->dev, "Invalid Action = %d ... ERROR %08X\n",
+					info->mess.action, ERROR_OP_NOT_ALLOW);
+				res = ERROR_OP_NOT_ALLOW;
+				goto END;
+			}
+
+			if (numberParam - 1 != 0)
+				memcpy(&cmd[1], &p[7], numberParam - 1);
+			/* -1 because i need to exclude the cmd[0] */
+		}
+	} else {
+		u8 result;
+		char *token;
+		char *path_token = NULL;
+		size_t token_len;
+
+		/* newline case at last char */
+		if (p[count - 1] == '\n')
+			p[count - 1] = '\0';
+
+		/* Parse the input string to retrieve 2 hex-digit width
+		 * cmds/args separated by one or more spaces, except for
+		 * the fw/limits file name.
+		 */
+		while (p &&
+			numberParam < min(maxNum_cmd, maxNum_funcToTest)) {
+
+			while (isspace(*p))
+				p++;
+
+			token = strsep(&p, " ");
+
+			if (!token || *token == '\0')
+				break;
+
+			token_len = strlen(token);
+
+			/* break the loop to handle FW/LIMITS path */
+			if (numberParam == 1 &&
+				(funcToTest[0] == CMD_GETFWFILE ||
+				funcToTest[0] == CMD_GETLIMITSFILE)) {
+				path_token = token;
+				break;
+			}
+
+			if (token_len != 2) {
+				dev_err(info->dev, "bad len. len=%zu\n", token_len);
+				res = ERROR_OP_NOT_ALLOW;
+				goto ERROR;
+			}
+
+			if (kstrtou8(token, 16, &result)) {
+				/* Conversion failed due to bad input.
+				 * Discard the entire buffer.
+				 */
+				dev_err(info->dev, "bad input\n");
+				res = ERROR_OP_NOT_ALLOW;
+				goto ERROR;
+			}
+
+			/* found a valid cmd/args */
+			cmd[numberParam] = funcToTest[numberParam] = result;
+			dev_info(info->dev, "functionToTest[%d] = %02X cmd[%d] = %02X\n",
+				numberParam, funcToTest[numberParam],
+				numberParam, cmd[numberParam]);
+			numberParam++;
+		}
+
+		/* FW/LIMITS path */
+		if (path_token && strlen(path_token)) {
+			strscpy(path, path_token, sizeof(path));
+			numberParam++;
+		}
+
+		if (numberParam == 0) {
+			dev_err(info->dev, "Found invalid cmd/arg\n");
+			res = ERROR_OP_NOT_ALLOW;
+			goto END;
+		}
+	}
+
+	fw.data = NULL;
+	lim.data = NULL;
+
+	dev_info(info->dev, "Number of Parameters = %d\n", numberParam);
+
+	/* elaborate input */
+	if (numberParam >= 1) {
+		switch (funcToTest[0]) {
+		case CMD_VERSION_BYTE:
+			dev_info(info->dev, "%s: Get Version Byte\n", __func__);
+			byteToRead = 2;
+			info->mess.dummy = 0;
+			readData = (u8 *)kmalloc(byteToRead * sizeof(u8),
+						 GFP_KERNEL);
+			size += byteToRead;
+			if (readData != NULL) {
+				readData[0] = (u8)(FTS_TS_DRV_VER >> 24);
+				readData[1] = (u8)(FTS_TS_DRV_VER >> 16);
+				dev_info(info->dev, "%s: Version = %02X%02X\n",
+					 __func__, readData[0], readData[1]);
+				res = OK;
+			} else {
+				res = ERROR_ALLOC;
+				dev_err(info->dev, "%s: Impossible allocate memory... ERROR %08X\n",
+					__func__, res);
+			}
+			break;
+
+
+		case CMD_VERSION:
+			byteToRead = 2 * sizeof(u32);
+			info->mess.dummy = 0;
+			readData = (u8 *)kmalloc(byteToRead * sizeof(u8),
+						 GFP_KERNEL);
+			u32ToU8_be(FTS_TS_DRV_VER, readData);
+			fileSize = 0;
+			/* first two bytes bitmask of features enabled in the
+			 * IC, second two bytes bitmask of features enabled in
+			 * the driver */
+
+#ifdef FW_H_FILE
+			fileSize |= 0x00010000;
+#endif
+
+#ifdef LIMITS_H_FILE
+			fileSize |= 0x00020000;
+#endif
+
+#ifdef USE_ONE_FILE_NODE
+			fileSize |= 0x00040000;
+#endif
+
+#ifdef FW_UPDATE_ON_PROBE
+			fileSize |= 0x00080000;
+#endif
+
+#ifdef PRE_SAVED_METHOD
+			fileSize |= 0x00100000;
+#endif
+
+#ifdef COMPUTE_INIT_METHOD
+			fileSize |= 0x00200000;
+#endif
+
+#ifdef USE_GESTURE_MASK
+			fileSize |= 0x00100000;
+#endif
+
+#ifdef I2C_INTERFACE
+			fileSize |= 0x00200000;
+#else
+			if (info->client &&
+			    (info->client->mode & SPI_3WIRE) == 0)
+				fileSize |= 0x00400000;
+#endif
+
+#ifdef PHONE_KEY	/* it is a feature enabled in the config of the chip */
+			fileSize |= 0x00000100;
+#endif
+
+#ifdef GESTURE_MODE
+			fromIDtoMask(FEAT_SEL_GESTURE, (u8 *)&fileSize, 4);
+#endif
+
+
+#ifdef GRIP_MODE
+			fromIDtoMask(FEAT_SEL_GRIP, (u8 *)&fileSize, 4);
+#endif
+
+#ifdef CHARGER_MODE
+			fromIDtoMask(FEAT_SEL_CHARGER, (u8 *)&fileSize, 4);
+#endif
+
+#ifdef GLOVE_MODE
+			fromIDtoMask(FEAT_SEL_GLOVE, (u8 *)&fileSize, 4);
+#endif
+
+
+#ifdef COVER_MODE
+			fromIDtoMask(FEAT_SEL_COVER, (u8 *)&fileSize, 4);
+#endif
+
+#ifdef STYLUS_MODE
+			fromIDtoMask(FEAT_SEL_STYLUS, (u8 *)&fileSize, 4);
+#endif
+
+			u32ToU8_be(fileSize, &readData[4]);
+			res = OK;
+			size += (byteToRead * sizeof(u8));
+			break;
+
+		case CMD_WRITEREAD:
+		case CMD_WRITEREAD_BYTE:
+			if (numberParam >= 5) {	/* need to pass: cmd[0]  cmd[1]
+						 * … cmd[cmdLength-1]
+						 * byteToRead1 byteToRead0
+						 * dummyByte */
+				temp = numberParam - 4;
+				if (cmd[numberParam - 1] == 0)
+					info->mess.dummy = 0;
+				else
+					info->mess.dummy = 1;
+
+				u8ToU16_be(&cmd[numberParam - 3], &byteToRead);
+				dev_info(info->dev, "bytesToRead = %d\n",
+					byteToRead + info->mess.dummy);
+
+				readData = (u8 *)kmalloc((byteToRead +
+							  info->mess.dummy) *
+							 sizeof(u8),
+							 GFP_KERNEL);
+				res = fts_writeRead_heap(info, &cmd[1], temp,
+					readData, byteToRead + info->mess.dummy);
+				size += (byteToRead * sizeof(u8));
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_WRITE:
+		case CMD_WRITE_BYTE:
+			if (numberParam >= 2) {	/* need to pass: cmd[0]  cmd[1]
+						 * … cmd[cmdLength-1] */
+				temp = numberParam - 1;
+
+				res = fts_write_heap(info, &cmd[1], temp);
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READ:
+		case CMD_READ_BYTE:
+			if (numberParam >= 3) {	/* need to pass: byteToRead1
+						 * byteToRead0 (optional)
+						 * dummyByte */
+				if (numberParam == 3 ||
+				     (numberParam == 4 &&
+				      cmd[numberParam - 1] == 0))
+					info->mess.dummy = 0;
+				else
+					info->mess.dummy = 1;
+				u8ToU16_be(&cmd[1], &byteToRead);
+				readData = (u8 *)kmalloc((byteToRead +
+							  info->mess.dummy) *
+							 sizeof(u8),
+							 GFP_KERNEL);
+				res = fts_read_heap(info, readData,
+						    byteToRead + info->mess.dummy);
+				size += (byteToRead * sizeof(u8));
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_WRITETHENWRITEREAD:
+		case CMD_WRITETHENWRITEREAD_BYTE:
+			/* need to pass: cmdSize1 cmdSize2 cmd1[0] cmd1[1] …
+			 * cmd1[cmdSize1-1] cmd2[0] cmd2[1] … cmd2[cmdSize2-1]
+			 *  byteToRead1 byteToRead0 */
+			if (numberParam >= 6) {
+				u8ToU16_be(&cmd[numberParam - 2], &byteToRead);
+				readData = (u8 *)kmalloc(byteToRead *
+							 sizeof(u8),
+							 GFP_KERNEL);
+				res = fts_writeThenWriteRead_heap(info,
+						&cmd[3], cmd[1],
+						&cmd[3 + (int)cmd[1]], cmd[2],
+						readData, byteToRead);
+				size += (byteToRead * sizeof(u8));
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_WRITEU8UX:
+		case CMD_WRITEU8UX_BYTE:
+			/* need to pass:
+			 *    cmd addrSize addr[0] … addr[addrSize-1]
+			 *    data[0] data[1] … */
+			if (numberParam >= 4) {
+				if (cmd[2] <= sizeof(u64)) {
+					u8ToU64_be(&cmd[3], &addr, cmd[2]);
+					dev_info(info->dev, "addr = %llx\n", addr);
+					res = fts_writeU8UX(info, cmd[1],
+						cmd[2], addr,
+						&cmd[3 + cmd[2]],
+						(numberParam - cmd[2] - 3));
+				} else {
+					dev_err(info->dev, "Wrong address size!\n");
+					res = ERROR_OP_NOT_ALLOW;
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+
+		case CMD_WRITEREADU8UX:
+		case CMD_WRITEREADU8UX_BYTE:
+			/* need to pass:
+			 *    cmd addrSize addr[0] … addr[addrSize-1]
+			 *    byteToRead1 byteToRead0 hasDummyByte */
+			if (numberParam >= 6) {
+				if (cmd[2] <= sizeof(u64)) {
+					u8ToU64_be(&cmd[3], &addr, cmd[2]);
+					u8ToU16_be(&cmd[numberParam - 3],
+						   &byteToRead);
+					readData = (u8 *)kmalloc(byteToRead *
+								 sizeof(u8),
+								 GFP_KERNEL);
+					dev_info(info->dev, "addr = %llx byteToRead = %d\n",
+						addr, byteToRead);
+					res = fts_writeReadU8UX(info, cmd[1],
+							cmd[2], addr, readData,
+							byteToRead,
+							cmd[numberParam - 1]);
+					size += (byteToRead * sizeof(u8));
+				} else {
+					dev_err(info->dev, "Wrong address size!\n");
+					res = ERROR_OP_NOT_ALLOW;
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_WRITEU8UXTHENWRITEU8UX:
+		case CMD_WRITEU8UXTHENWRITEU8UX_BYTE:
+			/* need to pass:
+			 *    cmd1 addrSize1 cmd2 addrSize2 addr[0] …
+			 *    addr[addrSize1+addrSize2-1] data[0] data[1] … */
+			if (numberParam >= 6) {
+				if ((cmd[2] + cmd[4]) <= sizeof(u64)) {
+					u8ToU64_be(&cmd[5], &addr, cmd[2] +
+						   cmd[4]);
+
+					dev_info(info->dev, "addr = %llx\n", addr);
+					res = fts_writeU8UXthenWriteU8UX(info,
+						cmd[1], cmd[2], cmd[3],
+						cmd[4], addr,
+						&cmd[5 + cmd[2] + cmd[4]],
+						(numberParam - cmd[2]
+							- cmd[4] - 5));
+				} else {
+					dev_err(info->dev, "Wrong address size!\n");
+					res = ERROR_OP_NOT_ALLOW;
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_WRITEU8UXTHENWRITEREADU8UX:
+		case CMD_WRITEU8UXTHENWRITEREADU8UX_BYTE:
+			/* need to pass:
+			 * cmd1 addrSize1 cmd2 addrSize2 addr[0] …
+			 * addr[addrSize1+addrSize2-1]  byteToRead1 byteToRead0
+			 * hasDummybyte */
+			if (numberParam >= 8) {
+				if ((cmd[2] + cmd[4]) <= sizeof(u64)) {
+					u8ToU64_be(&cmd[5], &addr, cmd[2] +
+						   cmd[4]);
+					dev_info(info->dev, "%s: cmd[5] = %02X, addr =  %llx\n",
+						__func__, cmd[5], addr);
+					u8ToU16_be(&cmd[numberParam - 3],
+						   &byteToRead);
+					readData = (u8 *)kmalloc(byteToRead *
+								 sizeof(u8),
+								 GFP_KERNEL);
+					res = fts_writeU8UXthenWriteReadU8UX(
+						info,
+						cmd[1], cmd[2], cmd[3], cmd[4],
+						addr,
+						readData, byteToRead,
+						cmd[numberParam - 1]);
+					size += (byteToRead * sizeof(u8));
+				} else {
+					dev_err(info->dev, "Wrong total address size!\n");
+					res = ERROR_OP_NOT_ALLOW;
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+
+			break;
+
+		case CMD_CHANGE_OUTPUT_MODE:
+			/* need to pass: bin_output */
+			if (numberParam >= 2) {
+				info->bin_output = cmd[1];
+				dev_info(info->dev, "Setting Scriptless output mode: %d\n",
+					info->bin_output);
+				res = OK;
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_FWWRITE:
+			if (numberParam >= 3) {	/* need to pass: cmd[0]  cmd[1]
+						 * … cmd[cmdLength-1] */
+				if (numberParam >= 2) {
+					temp = numberParam - 1;
+					res = fts_writeFwCmd_heap(info,
+								&cmd[1],
+								temp);
+				} else {
+					dev_err(info->dev, "Wrong parameters!\n");
+					res = ERROR_OP_NOT_ALLOW;
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_INTERRUPT:
+			/* need to pass: enable */
+			if (numberParam >= 2) {
+				if (cmd[1] == 1)
+					res = fts_enableInterrupt(info, true);
+				else
+					res = fts_enableInterrupt(info, false);
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_SETSCANMODE:
+			/* need to pass: scanMode option */
+			if (numberParam >= 3)
+				res = setScanMode(info, cmd[1], cmd[2]);
+			else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_SAVEMPFLAG:
+			/* need to pass: mpflag */
+			if (numberParam == 2)
+				res = saveMpFlag(info, cmd[1]);
+			else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READCONFIG:
+			if (numberParam == 5) {	/* need to pass: addr[0]
+						 *  addr[1] byteToRead1
+						 * byteToRead0 */
+				byteToRead = ((funcToTest[3] << 8) |
+					      funcToTest[4]);
+				readData = (u8 *)kmalloc(byteToRead *
+							 sizeof(u8),
+							 GFP_KERNEL);
+				res = readConfig(info,
+						(u16)((((u8)funcToTest[1] &
+								0x00FF) << 8) +
+						       ((u8)funcToTest[2] &
+								0x00FF)),
+						 readData, byteToRead);
+				size += (byteToRead * sizeof(u8));
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_POLLFOREVENT:
+			if (numberParam >= 5) {	/* need to pass: eventLength
+						 * event[0] event[1] …
+						 * event[eventLength-1]
+						 * timeTowait1 timeTowait0 */
+				temp = (int)funcToTest[1];
+				if (numberParam == 5 + (temp - 1) &&
+					temp != 0) {
+					readData = (u8 *)kmalloc(
+						FIFO_EVENT_SIZE * sizeof(u8),
+						GFP_KERNEL);
+					res = pollForEvent(info,
+						(int *)&funcToTest[2], temp,
+						readData,
+						((funcToTest[temp + 2] &
+							0x00FF) << 8) +
+						(funcToTest[temp + 3] &
+							0x00FF));
+					if (res >= OK)
+						res = OK;	/* pollForEvent
+								 * return the
+								 * number of
+								 * error found
+								 * */
+					size += (FIFO_EVENT_SIZE * sizeof(u8));
+					byteToRead = FIFO_EVENT_SIZE;
+				} else {
+					dev_err(info->dev, "Wrong parameters!\n");
+					res = ERROR_OP_NOT_ALLOW;
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_SYSTEMRESET:
+			res = fts_system_reset(info);
+
+			break;
+
+		case CMD_READSYSINFO:
+			if (numberParam == 2)	/* need to pass: doRequest */
+				res = readSysInfo(info, funcToTest[1]);
+			else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+
+			break;
+
+		case CMD_CLEANUP:/* TOUCH ENABLE/DISABLE */
+			if (numberParam == 2)	/* need to pass: enableTouch */
+				res = cleanUp(info, funcToTest[1]);
+			else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+
+			break;
+
+		case CMD_GETFORCELEN:	/* read number Tx channels */
+			temp = getForceLen(info);
+			if (temp < OK)
+				res = temp;
+			else {
+				size += (1 * sizeof(u8));
+				res = OK;
+			}
+			break;
+
+		case CMD_GETSENSELEN:	/* read number Rx channels */
+			temp = getSenseLen(info);
+			if (temp < OK)
+				res = temp;
+			else {
+				size += (1 * sizeof(u8));
+				res = OK;
+			}
+			break;
+
+
+		case CMD_GETMSFRAME:
+			if (numberParam == 2) {
+				dev_info(info->dev, "Get 1 MS Frame\n");
+				/* setScanMode(SCAN_MODE_ACTIVE, 0xFF);
+				 * mdelay(WAIT_FOR_FRESH_FRAMES);
+				 * setScanMode(SCAN_MODE_ACTIVE, 0x00);
+				 * mdelay(WAIT_AFTER_SENSEOFF);
+				 */
+				/* flushFIFO(); //delete the events related to
+				 * some touch (allow to call this function while
+				 * touching the screen without having a flooding
+				 * of the FIFO) */
+				res = getMSFrame3(info, (MSFrameType)cmd[1],
+						  &frameMS);
+				if (res < 0)
+					dev_err(info->dev, "Error while taking the MS frame... ERROR %08X\n",
+						res);
+
+				else {
+					dev_info(info->dev, "The frame size is %d words\n",
+						res);
+					size += (res * sizeof(short) + 2);
+					/* +2 to add force and sense channels
+					 * set res to OK because if getMSFrame
+					 * is successful
+					 *	res = number of words read
+					 */
+					res = OK;
+					print_frame_short(info, "MS frame =",
+						array1dTo2d_short(
+						    frameMS.node_data,
+						    frameMS.node_data_size,
+						    frameMS.header.sense_node),
+						frameMS.header.force_node,
+						frameMS.header.sense_node);
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+
+		/*read self raw*/
+		case CMD_GETSSFRAME:
+			if (numberParam == 2) {
+				/* dev_info(info->dev, "Get 1 SS Frame\n"); */
+				/* flushFIFO(); //delete the events related to
+				 * some touch (allow to call this function while
+				 * touching the screen without having a flooding
+				 * of the FIFO) */
+				/* setScanMode(SCAN_MODE_ACTIVE, 0xFF);
+				 * mdelay(WAIT_FOR_FRESH_FRAMES);
+				 * setScanMode(SCAN_MODE_ACTIVE, 0x00);
+				 * mdelay(WAIT_AFTER_SENSEOFF);
+				 */
+				res = getSSFrame3(info, (SSFrameType)cmd[1],
+						  &frameSS);
+
+				if (res < OK)
+					dev_err(info->dev, "Error while taking the SS frame... ERROR %08X\n",
+						res);
+
+				else {
+					dev_info(info->dev, "The frame size is %d words\n",
+						res);
+					size += (res * sizeof(short) + 2);
+					/* +2 to add force and sense channels
+					 * set res to OK because if getMSFrame
+					 * is successful
+					 *	res = number of words read
+					 */
+					res = OK;
+					print_frame_short(info,
+						  "SS force frame =",
+						  array1dTo2d_short(
+						    frameSS.force_data,
+						    frameSS.header.force_node,
+						    1),
+						  frameSS.header.force_node, 1);
+					print_frame_short(info,
+						"SS sense frame =",
+						array1dTo2d_short(
+						  frameSS.sense_data,
+						  frameSS.header.sense_node,
+						  frameSS.header.sense_node),
+						  1,
+						frameSS.header.sense_node);
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_GETSYNCFRAME:
+			/* need to pass: frameType (this parameter can be
+			 * one of LOAD_SYNC_FRAME_X)
+			 */
+			if (numberParam == 2) {
+				dev_info(info->dev, "Reading Sync Frame...\n");
+				res = getSyncFrame(info, cmd[1], &frameMS,
+						   &frameSS);
+				if (res < OK)
+					dev_err(info->dev, "Error while taking the Sync Frame frame... ERROR %08X\n",
+						res);
+
+				else {
+					dev_info(info->dev, "The total frames size is %d words\n",
+						 res);
+					size += (res * sizeof(short) + 4);
+					/* +4 to add force and sense channels
+					 * for MS and SS.
+					 * Set res to OK because if getSyncFrame
+					 * is successful res = number of words
+					 * read
+					 */
+					res = OK;
+
+					print_frame_short(info, "MS frame =",
+						array1dTo2d_short(
+						    frameMS.node_data,
+						    frameMS.node_data_size,
+						    frameMS.header.sense_node),
+						frameMS.header.force_node,
+						frameMS.header.sense_node);
+					print_frame_short(info,
+						"SS force frame =",
+						array1dTo2d_short(
+						    frameSS.force_data,
+						    frameSS.header.force_node,
+						    1),
+						frameSS.header.force_node,
+						1);
+					print_frame_short(info,
+						"SS sense frame =",
+						array1dTo2d_short(
+						    frameSS.sense_data,
+						    frameSS.header.sense_node,
+						    frameSS.header.sense_node),
+						1,
+						frameSS.header.sense_node);
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_REQCOMPDATA:	/* request comp data */
+			if (numberParam == 2) {
+				dev_info(info->dev, "Requesting Compensation Data\n");
+				res = requestHDMDownload(info, cmd[1]);
+
+				if (res < OK)
+					dev_err(info->dev, "Error requesting compensation data ERROR %08X\n",
+						res);
+				else
+					dev_info(info->dev, "Requesting Compensation Data Finished!\n");
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READCOMPDATAHEAD:	/* read comp data header */
+			if (numberParam == 2) {
+				dev_info(info->dev, "Requesting Compensation Data\n");
+				res = requestHDMDownload(info, cmd[1]);
+				if (res < OK)
+					dev_err(info->dev, "Error requesting compensation data ERROR %08X\n",
+						res);
+				else {
+					dev_info(info->dev, "Requesting Compensation Data Finished!\n");
+					res = readHDMHeader(info,
+						(u8)funcToTest[1],
+						&dataHead, &address);
+					if (res < OK)
+						dev_err(info->dev, "Read Compensation Data Header ERROR %08X\n",
+							res);
+					else {
+						dev_info(info->dev, "Read Compensation Data Header OK!\n");
+						size += (1 * sizeof(u8));
+					}
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+
+		case CMD_READMSCOMPDATA:/* read mutual comp data */
+			if (numberParam == 2) {
+				dev_info(info->dev, "Get MS Compensation Data\n");
+				res = readMutualSenseCompensationData(info,
+							      cmd[1],
+							      &compData);
+
+				if (res < OK)
+					dev_err(info->dev, "Error reading MS compensation data ERROR %08X\n",
+						res);
+				else {
+					dev_info(info->dev, "MS Compensation Data Reading Finished!\n");
+					size = ((compData.node_data_size + 10) *
+						sizeof(i8));
+					if (cmd[1] == LOAD_CX_MS_TOUCH)
+						label[0] = "CX2 =";
+					else if(cmd[1] == LOAD_CX_MS_LOW_POWER)
+						label[0] = "CX2_LP =";
+					else
+						label[0] = "MS Data (Cx2) =";
+					print_frame_i8(info,
+						label[0],
+						array1dTo2d_i8(
+						compData.node_data,
+						compData.node_data_size,
+						compData.header.sense_node),
+						compData.header.force_node,
+						compData.header.sense_node);
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READSSCOMPDATA:
+			if (numberParam == 2) {	/* read self comp data */
+				dev_info(info->dev, "Get SS Compensation Data...\n");
+				res = readSelfSenseCompensationData(info,
+								    cmd[1],
+								    &comData);
+				if (res < OK)
+					dev_err(info->dev, "Error reading SS compensation data ERROR %08X\n",
+						res);
+				else {
+					dev_info(info->dev, "SS Compensation Data Reading Finished!\n");
+					size = ((comData.header.force_node +
+						 comData.header.sense_node) *
+						2 + 15) *
+					       sizeof(i8);
+					print_frame_i8(info,
+						"SS Data Ix2_fm = ",
+						array1dTo2d_i8(
+						  comData.ix2_fm,
+						  comData.header.force_node,
+						  comData.header.force_node),
+						1,
+						comData.header.force_node);
+					print_frame_i8(info,
+						"SS Data Cx2_fm = ",
+						array1dTo2d_i8(
+						  comData.cx2_fm,
+						  comData.header.force_node,
+						  comData.header.force_node),
+						1,
+						comData.header.force_node);
+					print_frame_i8(info,
+						"SS Data Ix2_sn = ",
+						array1dTo2d_i8(
+						  comData.ix2_sn,
+						  comData.header.sense_node,
+						  comData.header.sense_node),
+						1,
+						comData.header.sense_node);
+					print_frame_i8(info,
+						"SS Data Cx2_sn = ",
+						array1dTo2d_i8(
+						  comData.cx2_sn,
+						  comData.header.sense_node,
+						  comData.header.sense_node),
+						1,
+						comData.header.sense_node);
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READGOLDENMUTUAL:
+			if (numberParam != 1) {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+				break;
+			}
+
+			dev_info(info->dev, "Get Golden Mutual Raw data\n");
+
+			res = readGoldenMutualRawData(info, &gmRawData);
+			if (res < OK) {
+				dev_err(info->dev, "Err reading GM data %08X\n", res);
+				break;
+			}
+
+			dev_info(info->dev, "GM data reading Finished!\n");
+
+			size = (6 + gmRawData.data_size) * sizeof(u16);
+
+			print_frame_short(info, "Golden Mutual Data =",
+					array1dTo2d_short(
+						gmRawData.data,
+						gmRawData.data_size,
+						gmRawData.hdr.ms_s_len),
+					gmRawData.hdr.ms_f_len,
+					gmRawData.hdr.ms_s_len);
+			break;
+
+		case CMD_READTOTMSCOMPDATA:	/* read mutual comp data */
+			if (numberParam == 2) {
+				dev_info(info->dev, "Get TOT MS Compensation Data\n");
+				res = readTotMutualSenseCompensationData(info,
+								cmd[1],
+								&totCompData);
+
+				if (res < OK)
+					dev_err(info->dev, "Error reading TOT MS compensation data ERROR %08X\n",
+						res);
+				else {
+					dev_info(info->dev, "TOT MS Compensation Data Reading Finished!\n");
+					size = (totCompData.node_data_size *
+						sizeof(short) + 9);
+					print_frame_short(info,
+					  "MS Data (TOT Cx) =",
+					  array1dTo2d_short(
+					      totCompData.node_data,
+					      totCompData.node_data_size,
+					      totCompData.header.sense_node),
+					  totCompData.header.force_node,
+					  totCompData.header.sense_node);
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READTOTSSCOMPDATA:
+			if (numberParam == 2) {	/* read self comp data */
+				dev_info(info->dev, "Get TOT SS Compensation Data...\n");
+				res = readTotSelfSenseCompensationData(info,
+								cmd[1],
+								&totComData);
+				if (res < OK)
+					dev_err(info->dev, "Error reading TOT SS compensation data ERROR %08X\n",
+						res);
+				else {
+					dev_info(info->dev, "TOT SS Compensation Data Reading Finished!\n");
+					size = ((totComData.header.force_node +
+						 totComData.header.sense_node) *
+						2 *
+						sizeof(short) + 9);
+					if (cmd[1] ==
+					    LOAD_PANEL_CX_TOT_SS_TOUCH) {
+					    label[0] = "SS_TOT_IX_TX = ";
+					    label[1] = "SS_TOT_Cx_Tx = ";
+					    label[2] = "SS_TOT_Ix_Rx = ";
+					    label[3] = "SS_TOT_Cx_Rx = ";
+					} else if (cmd[1] ==
+					    LOAD_PANEL_CX_TOT_SS_TOUCH_IDLE) {
+					    label[0] = "SS_TOT_Ix_Tx_LP = ";
+					    label[1] = "SS_TOT_Cx_Tx_LP = ";
+					    label[2] = "SS_TOT_Ix_Rx_LP = ";
+					    label[3] = "SS_TOT_Cx_Rx_LP = ";
+					} else {
+					    label[0] = "SS Data TOT Ix_fm = ";
+					    label[1] = "SS Data TOT Cx_fm = ";
+					    label[2] = "SS Data TOT Ix_sn = ";
+					    label[3] = "SS Data TOT Cx_sn = ";
+					}
+					print_frame_u16(info,
+						label[0],
+						array1dTo2d_u16(
+						totComData.ix_fm,
+						totComData.header.force_node,
+						totComData.header.force_node),
+						1,
+						totComData.header.force_node);
+					print_frame_short(info,
+						label[1],
+						array1dTo2d_short(
+						totComData.cx_fm,
+						totComData.header.force_node,
+						totComData.header.force_node),
+						1,
+						totComData.header.force_node);
+					print_frame_u16(info,
+						label[2],
+						array1dTo2d_u16(
+						totComData.ix_sn,
+						totComData.header.sense_node,
+						totComData.header.sense_node),
+						1,
+						totComData.header.sense_node);
+					print_frame_short(info,
+						label[3],
+						array1dTo2d_short(
+						totComData.cx_sn,
+						totComData.header.sense_node,
+						totComData.header.sense_node),
+						1,
+						totComData.header.sense_node);
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READSENSCOEFF:
+			/* read MS and SS Sensitivity Coefficients */
+			dev_info(info->dev, "Get Sensitivity Calibration Coefficients...\n");
+			res = readSensitivityCoefficientsData(info, &msCoeff,
+							      &ssCoeff);
+			if (res < OK)
+				dev_err(info->dev, "Error reading Sensitivity Calibration Coefficients ERROR %08X\n",
+					res);
+			else {
+				dev_info(info->dev, "Sensitivity Calibration Coefficients Reading Finished!\n");
+				size += (((msCoeff.node_data_size) +
+					  ssCoeff.header.force_node +
+					  ssCoeff.header.sense_node) *
+					 sizeof(u8) + 4);
+				print_frame_u8(info,
+					       "MS Sensitivity Coeff = ",
+					       array1dTo2d_u8(msCoeff.ms_coeff,
+							      msCoeff.
+							      node_data_size,
+							      msCoeff.header.
+							      sense_node),
+					       msCoeff.header.force_node,
+					       msCoeff.header.sense_node);
+				print_frame_u8(info,
+					       "SS Sensitivity Coeff force = ",
+					       array1dTo2d_u8(
+						       ssCoeff.ss_force_coeff,
+						       ssCoeff.header.
+						       force_node, 1),
+					       ssCoeff.header.force_node, 1);
+				print_frame_u8(info,
+					       "SS Sensitivity Coeff sense = ",
+					       array1dTo2d_u8(
+						       ssCoeff.ss_sense_coeff,
+						       ssCoeff.header.
+						       sense_node,
+						       ssCoeff.header.
+						       sense_node), 1,
+					       ssCoeff.header.sense_node);
+			}
+			break;
+
+		case CMD_GETFWVER:
+			size += (EXTERNAL_RELEASE_INFO_SIZE)*sizeof(u8);
+			break;
+
+		case CMD_FLASHUNLOCK:
+			res = flash_unlock(info);
+			if (res < OK)
+				dev_err(info->dev, "Impossible Unlock Flash ERROR %08X\n",
+					res);
+			else
+				dev_info(info->dev, "Flash Unlock OK!\n");
+			break;
+
+		case CMD_READFWFILE:
+			if (numberParam == 2) {	/* read fw file */
+				dev_info(info->dev, "Reading FW File...\n");
+				res = readFwFile(info, info->board->fw_name,
+						 &fw, funcToTest[1]);
+				if (res < OK)
+					dev_err(info->dev, "Error reading FW File ERROR %08X\n",
+						res);
+				else
+					dev_info(info->dev, "Read FW File Finished!\n");
+				kfree(fw.data);
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_FLASHPROCEDURE:
+			if (numberParam == 3) {	/* flashing procedure */
+				dev_info(info->dev, "Starting Flashing Procedure...\n");
+				res = flashProcedure(info,
+						     info->board->fw_name,
+						     cmd[1],
+						     cmd[2]);
+				if (res < OK)
+					dev_err(info->dev, "Error during flash procedure ERROR %08X\n",
+						res);
+				else
+					dev_info(info->dev, "Flash Procedure Finished!\n");
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_FLASHERASEUNLOCK:
+			res = flash_erase_unlock(info);
+			if (res < OK)
+				dev_err(info->dev, "Error during flash erase unlock... ERROR %08X\n",
+					res);
+			else
+				dev_info(info->dev, "Flash Erase Unlock Finished!\n");
+			break;
+
+		case CMD_FLASHERASEPAGE:
+			if (numberParam == 2) {	/* need to pass: keep_cx */
+				dev_info(info->dev, "Reading FW File...\n");
+				res = readFwFile(info, info->board->fw_name,
+						 &fw, funcToTest[1]);
+				if (res < OK)
+					dev_err(info->dev, "Error reading FW File ERROR"
+						"%08X\n", res);
+				else
+					dev_info(info->dev, "Read FW File Finished!\n");
+				dev_info(info->dev, "Starting Flashing Page Erase...\n");
+				res = flash_erase_page_by_page(info, cmd[1],
+							       &fw);
+				if (res < OK)
+					dev_err(info->dev, "Error during flash page erase... ERROR %08X\n",
+						res);
+				else
+					dev_info(info->dev, "Flash Page Erase Finished!\n");
+				kfree(fw.data);
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		/*ITO TEST*/
+		case CMD_ITOTEST:
+			frameMS.node_data = NULL;
+			res = production_test_ito(info, limits_file, &frameMS,
+						  ito_max_val);
+
+			if (frameMS.node_data != NULL) {
+				size += (frameMS.node_data_size *
+						sizeof(short) + 2);
+				report = 1;
+			}
+			break;
+
+		/*Initialization*/
+		case CMD_INITTEST:
+			if (numberParam == 2)
+				res = production_test_initialization(info,
+								     cmd[1]);
+
+			else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+
+		case CMD_MSRAWTEST:	/* MS Raw DATA TEST */
+			if (numberParam == 2)	/* need to specify if stopOnFail
+						 * */
+				res = production_test_ms_raw(info, limits_file,
+							     cmd[1]);
+			else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_MSINITDATATEST:/* MS CX DATA TEST */
+			if (numberParam == 2)	/* need stopOnFail */
+				res = production_test_ms_cx(info, limits_file,
+							    cmd[1]);
+			else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_SSRAWTEST:	/* SS RAW DATA TEST */
+			if (numberParam == 2) /* need stopOnFail */
+				res = production_test_ss_raw(info, limits_file,
+							     cmd[1]);
+			else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_SSINITDATATEST:/* SS IX CX DATA TEST */
+			if (numberParam == 2)	/* need stopOnFail */
+				res = production_test_ss_ix_cx(info,
+							       limits_file,
+							       cmd[1]);
+			else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		/*PRODUCTION TEST*/
+		case CMD_MAINTEST:
+			if (numberParam >= 3)	/* need to specify if stopOnFail
+						 * saveInit and
+						 * mpflag(optional)
+						 */
+				if (numberParam == 3)
+					res = production_test_main(info,
+							   limits_file,
+							   cmd[1],
+							   cmd[2],
+							   MP_FLAG_OTHERS);
+				else
+					res = production_test_main(info,
+							   limits_file,
+							   cmd[1],
+							   cmd[2],
+							   cmd[3]);
+			else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_FREELIMIT:
+			res = freeCurrentLimitsFile(info);
+			break;
+
+		case CMD_POWERCYCLE:
+			res = fts_chip_powercycle(info);
+			break;
+
+		case CMD_GETLIMITSFILE:
+			/* need to pass: path(optional) return error code +
+			 * number of byte read otherwise GUI could not now how
+			 * many byte read */
+			if (numberParam >= 1) {
+				lim.data = NULL;
+				lim.size = 0;
+				if (numberParam == 1)
+					res = getLimitsFile(info, limits_file,
+							    &lim);
+				else
+					res = getLimitsFile(info, path, &lim);
+				readData = lim.data;
+				fileSize = lim.size;
+				size += (fileSize * sizeof(u8));
+				if (byte_call == 1)
+					size += sizeof(u32);	/* transmit as
+								 * first 4 bytes
+								 * the size */
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_GETLIMITSFILE_BYTE:
+			/* need to pass: byteToRead1 byteToRead0 */
+			if (numberParam >= 3) {
+				lim.data = NULL;
+				lim.size = 0;
+
+				u8ToU16_be(&cmd[1], &byteToRead);
+				addr = ((u64)byteToRead) * 4;	/* number of
+								 * words */
+
+				res = getLimitsFile(info, limits_file, &lim);
+
+				readData = lim.data;
+				fileSize = lim.size;
+
+				if (fileSize > addr) {
+					dev_err(info->dev, "Limits dimension expected by Host is less than actual size: expected = %d, real = %d\n",
+						byteToRead, fileSize);
+					res = ERROR_OP_NOT_ALLOW;
+				}
+
+				size += (addr * sizeof(u8));
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_GETFWFILE:
+			/* need to pass: from (optional) otherwise select the
+			 * approach chosen at compile time */
+			if (numberParam >= 1) {
+				if (numberParam == 1)
+					res = getFWdata(info,
+							info->board->fw_name,
+							&readData, &fileSize);
+				else
+					res = getFWdata(info, path, &readData,
+							&fileSize);
+
+				size += (fileSize * sizeof(u8));
+				if (byte_call == 1)
+					size += sizeof(u32);	/* transmit as
+								 * first 4 bytes
+								 * the size */
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_GETFWFILE_BYTE:
+			/* need to pass: byteToRead1 byteToRead0 */
+			if (numberParam == 3) {
+				u8ToU16_be(&cmd[1], &byteToRead);
+				addr = ((u64)byteToRead) * 4;	/* number of
+								 * words */
+				res = getFWdata(info, info->board->fw_name,
+						&readData, &fileSize);
+				if (fileSize > addr) {
+					dev_err(info->dev, "FW dimension expected by Host is less than actual size: expected = %d, real = %d\n",
+						byteToRead, fileSize);
+					res = ERROR_OP_NOT_ALLOW;
+				}
+
+				size += (addr * sizeof(u8));	/* return always
+								 * the amount
+								 * requested by
+								 * host, if real
+								 * size is
+								 * smaller, the
+								 * data are
+								 * padded to
+								 * zero */
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		/* finish all the diagnostic command with a goto ERROR in order
+		 * to skip the modification on driver_test_buff
+		 * remember to set properly the limit and printed variables in
+		 * order to make the seq_file logic to work */
+		case CMD_DIAGNOSTIC:
+			index = 0;
+			size = 0;
+			fileSize = 256 * 1024 * sizeof(char);
+			info->driver_test_buff = (u8 *)kzalloc(fileSize, GFP_KERNEL);
+			readData = (u8 *)kmalloc((ERROR_DUMP_ROW_SIZE *
+						  ERROR_DUMP_COL_SIZE) *
+						 sizeof(u8), GFP_KERNEL);
+			if (info->driver_test_buff == NULL || readData == NULL) {
+				res = ERROR_ALLOC;
+				dev_err(info->dev, "Impossible allocate memory for buffers! ERROR %08X!\n",
+					res);
+				goto END;
+			}
+			j = scnprintf(&info->driver_test_buff[index],
+				      fileSize - index,
+				      "DIAGNOSTIC TEST:\n1) I2C Test: ");
+			index += j;
+
+			res = fts_writeReadU8UX(info, FTS_CMD_HW_REG_R,
+						ADDR_SIZE_HW_REG, ADDR_DCHIP_ID,
+						(u8 *)&temp, 2,
+						DUMMY_HW_REG);
+			if (res < OK) {
+				dev_err(info->dev, "Error during I2C test: ERROR %08X!\n",
+					res);
+				j = scnprintf(&info->driver_test_buff[index],
+					      fileSize - index, "ERROR %08X\n",
+					      res);
+				index += j;
+				res = ERROR_OP_NOT_ALLOW;
+				goto END_DIAGNOSTIC;
+			}
+
+			temp &= 0xFFFF;
+			dev_info(info->dev, "Chip ID = %04X!\n", temp);
+			j = scnprintf(&info->driver_test_buff[index],
+				      fileSize - index,
+				      "DATA = %04X, expected = %02X%02X\n",
+				      temp, info->board->dchip_id[1],
+				      info->board->dchip_id[0]);
+			index += j;
+			if (temp != ((info->board->dchip_id[1] << 8) |
+				     info->board->dchip_id[0])) {
+				dev_err(info->dev, "Wrong CHIP ID, Diagnostic failed!\n");
+				res = ERROR_OP_NOT_ALLOW;
+				goto END_DIAGNOSTIC;
+			}
+
+			j = scnprintf(&info->driver_test_buff[index],
+				      fileSize - index,
+				      "Present Driver Mode: %08X\n",
+				      info->mode);
+			index += j;
+
+			j = scnprintf(&info->driver_test_buff[index],
+				      fileSize - index,
+				      "2) FW running: Sensing On...");
+			index += j;
+			dev_info(info->dev, "Sensing On!\n");
+			readData[0] = FTS_CMD_SCAN_MODE;
+			readData[1] = SCAN_MODE_ACTIVE;
+			readData[2] = 0x1;
+			fts_write_heap(info, readData, 3);
+			res = checkEcho(info, readData, 3);
+			if (res < OK) {
+				dev_err(info->dev, "No Echo received.. ERROR %08X !\n",
+					res);
+				j = scnprintf(&info->driver_test_buff[index],
+					      fileSize - index,
+					      "No echo found... ERROR %08X!\n",
+					      res);
+				index += j;
+				goto END_DIAGNOSTIC;
+			} else {
+				dev_info(info->dev, "Echo FOUND... OK!\n");
+				j = scnprintf(&info->driver_test_buff[index],
+					      fileSize - index,
+					      "Echo FOUND... OK!\n");
+				index += j;
+			}
+
+			dev_info(info->dev, "Reading Frames...!\n");
+			j = scnprintf(&info->driver_test_buff[index],
+				      fileSize - index,
+				      "3) Read Frames:\n");
+			index += j;
+			for (temp = 0; temp < DIAGNOSTIC_NUM_FRAME; temp++) {
+				dev_info(info->dev, "Iteration n. %d...\n", temp + 1);
+				j = scnprintf(&info->driver_test_buff[index],
+					      fileSize - index,
+					      "Iteration n. %d...\n",
+					      temp + 1);
+				index += j;
+				for (addr = 0; addr < 3; addr++) {
+					switch (addr) {
+					case 0:
+						j = scnprintf(
+						    &info->driver_test_buff[index],
+						    fileSize - index,
+						    "MS RAW FRAME =");
+						index += j;
+						res |= getMSFrame3(info,
+								   MS_RAW,
+								   &frameMS);
+						break;
+					case 2:
+						j = scnprintf(
+						    &info->driver_test_buff[index],
+						    fileSize - index,
+						    "MS STRENGTH FRAME =");
+						index += j;
+						res |= getMSFrame3(info,
+								   MS_STRENGTH,
+								   &frameMS);
+						break;
+					case 1:
+						j = scnprintf(
+						    &info->driver_test_buff[index],
+						    fileSize - index,
+						    "MS BASELINE FRAME =");
+						index += j;
+						res |= getMSFrame3(info,
+								   MS_BASELINE,
+								   &frameMS);
+						break;
+					}
+					if (res < OK) {
+						j = scnprintf(
+						    &info->driver_test_buff[index],
+						    fileSize - index,
+						    "No data! ERROR %08X\n",
+						    res);
+						index += j;
+					} else {
+						for (address = 0; address <
+						    frameMS.node_data_size;
+						  address++) {
+							if (address %
+							    frameMS.header.
+							      sense_node == 0) {
+								j = scnprintf(
+							       &info->driver_test_buff
+									[index],
+							       fileSize	-
+									  index,
+							       "\n");
+								index += j;
+							}
+							j = scnprintf(
+							    &info->driver_test_buff
+								[index],
+							    fileSize - index,
+							    "%5d, ",
+							    frameMS.
+							    node_data[address]);
+							index += j;
+						}
+						j = scnprintf(
+						    &info->driver_test_buff[index],
+						    fileSize - index, "\n");
+						index += j;
+					}
+					if (frameMS.node_data != NULL)
+						kfree(frameMS.node_data);
+				}
+				for (addr = 0; addr < 3; addr++) {
+					switch (addr) {
+					case 0:
+						j = scnprintf(
+						    &info->driver_test_buff[index],
+						    fileSize - index,
+						    "SS RAW FRAME =\n");
+						index += j;
+						res |= getSSFrame3(info,
+								   SS_RAW,
+								   &frameSS);
+						break;
+					case 2:
+						j = scnprintf(
+						    &info->driver_test_buff[index],
+						    fileSize - index,
+						    "SS STRENGTH FRAME =\n");
+						index += j;
+						res |= getSSFrame3(info,
+								   SS_STRENGTH,
+								   &frameSS);
+						break;
+					case 1:
+						j = scnprintf(
+						    &info->driver_test_buff[index],
+						    fileSize - index,
+						    "SS BASELINE FRAME =\n");
+						index += j;
+						res |= getSSFrame3(info,
+								   SS_BASELINE,
+								   &frameSS);
+						break;
+					}
+					if (res < OK) {
+						j = scnprintf(
+						    &info->driver_test_buff[index],
+						    fileSize - index,
+						    "No data! ERROR %08X\n",
+						    res);
+						index += j;
+					} else {
+						int num;
+						short *data;
+
+						num = frameSS.header.force_node;
+						data = frameSS.force_data;
+						for (address = 0;
+							address < num;
+							address++) {
+						    j = scnprintf(
+						       &info->driver_test_buff[index],
+						       fileSize - index,
+						       "%d\n",
+						       data[address]);
+						    index += j;
+						}
+
+						num = frameSS.header.sense_node;
+						data = frameSS.sense_data;
+						for (address = 0;
+							address < num;
+							address++) {
+						    j = scnprintf(
+						       &info->driver_test_buff[index],
+						       fileSize - index,
+						       "%d, ",
+						       data[address]);
+						    index += j;
+						}
+						j = scnprintf(
+						    &info->driver_test_buff[index],
+						    fileSize - index, "\n");
+						index += j;
+					}
+					if (frameSS.force_data != NULL)
+						kfree(frameSS.force_data);
+					if (frameSS.sense_data != NULL)
+						kfree(frameSS.sense_data);
+				}
+			}
+
+
+			dev_info(info->dev, "Reading error info...\n");
+			j = scnprintf(&info->driver_test_buff[index],
+				      fileSize - index,
+				      "4) FW INFO DUMP: ");
+			index += j;
+			temp = dumpErrorInfo(info, readData,
+					     ERROR_DUMP_ROW_SIZE *
+					     ERROR_DUMP_COL_SIZE);
+			/* OR to detect if there are failures also in the
+			 * previous reading of frames and write the correct
+			 * result */
+			if (temp < OK) {
+				dev_err(info->dev, "Error during dump: ERROR %08X!\n",
+					res);
+				j = scnprintf(&info->driver_test_buff[index],
+					      fileSize - index, "ERROR %08X\n",
+					      temp);
+				index += j;
+			} else {
+				dev_info(info->dev, "DUMP OK!\n");
+				for (temp = 0; temp < ERROR_DUMP_ROW_SIZE *
+				     ERROR_DUMP_COL_SIZE; temp++) {
+					if (temp % ERROR_DUMP_COL_SIZE == 0) {
+						j = scnprintf(
+						    &info->driver_test_buff[index],
+						    fileSize - index,
+						    "\n%2d - ",
+						    temp / ERROR_DUMP_COL_SIZE);
+						index += j;
+					}
+					j = scnprintf(&info->driver_test_buff[index],
+						      fileSize - index, "%02X ",
+						      readData[temp]);
+					index += j;
+				}
+			}
+			res |= temp;
+
+END_DIAGNOSTIC:
+			if (res < OK) {
+				j = scnprintf(&info->driver_test_buff[index],
+					      fileSize - index,
+					      "\nRESULT = FAIL\n");
+				index += j;
+			} else {
+				j = scnprintf(&info->driver_test_buff[index],
+					      fileSize - index,
+					      "\nRESULT = FINISHED\n");
+				index += j;
+			}
+			/* the sting is already terminated with the null char by
+			 * scnprintf */
+			info->limit = index;
+			info->printed = 0;
+			goto ERROR;
+			break;
+
+#ifdef I2C_INTERFACE
+		case CMD_CHANGE_SAD:
+			res = changeSAD(cmd[1]);
+			break;
+#endif
+
+		case CMD_TRIGGER_FORCECAL:
+			cmd[0] = CAL_MS_TOUCH | CAL_SS_TOUCH;
+			cmd[1] = 0x00;
+			fts_enableInterrupt(info, false);
+			res = writeSysCmd(info, SYS_CMD_FORCE_CAL, cmd, 2);
+			res |= fts_enableInterrupt(info, true);
+			if (res < OK)
+				dev_err(info->dev, "can not trigger Force Cal! ERROR %08X\n",
+					res);
+			else
+				dev_info(info->dev, "MS and SS force cal triggered!\n");
+			break;
+
+		case CMD_BASELINE_ADAPTATION:
+			/* need to pass: enable */
+			if (numberParam == 2) {
+				if (cmd[1] == 0x01)
+					dev_info(info->dev, "Enabling Baseline adaptation...\n");
+				else {
+					dev_info(info->dev, "Disabling Baseline adaptation...\n");
+					cmd[1] = 0x00;	/* set to zero to
+							 * disable baseline
+							 * adaptation */
+				}
+
+				res = writeConfig(info, ADDR_CONFIG_AUTOCAL, &cmd[1],
+						  1);
+				if (res < OK)
+					dev_err(info->dev, "Baseline adaptation operation FAILED! ERROR %08X\n",
+						res);
+				else
+					dev_info(info->dev, "Baseline adaptation operation OK!\n");
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_FREQ_HOP:
+			/* need to pass: enable */
+			if (numberParam == 2) {
+				dev_info(info->dev, "Reading MNM register...\n");
+				res = readConfig(info, ADDR_CONFIG_MNM,
+						 &cmd[2], 1);
+				if (res < OK) {
+					dev_err(info->dev, "Reading MNM register... ERROR %08X!\n",
+						res);
+					break;
+				}
+
+				if (cmd[1] == 0x01) {
+					dev_info(info->dev, "Enabling Frequency Hopping... %02X => %02X\n",
+						cmd[2], cmd[2] | 0x01);
+					cmd[2] |= 0x01;	/* set bit 0 to enable
+							 * Frequency Hopping */
+				} else {
+					dev_info(info->dev, "Disabling Frequency Hopping... %02X => %02X\n",
+						cmd[2], cmd[2] & (~0x01));
+					cmd[2] &= (~0x01);	/* reset bit 0
+								 * to disable
+								 * Frequency
+								 * Hopping */
+				}
+
+				res = writeConfig(info, ADDR_CONFIG_MNM, &cmd[2], 1);
+				if (res < OK)
+					dev_err(info->dev, "Frequency Hopping operation FAILED! ERROR %08X\n",
+						res);
+				else
+					dev_info(info->dev, "Frequency Hopping operation OK!\n");
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_READ_SYNC_FRAME:
+			/* need to pass: frameType (this parameter can be
+			 * LOAD_SYNC_FRAME_STRENGTH or LOAD_SYNC_FRAME_BASELINE)
+			 * */
+			if (numberParam == 2) {
+				dev_info(info->dev, "Reading Sync Frame...\n");
+				res = getSyncFrame(info, cmd[1], &frameMS,
+						   &frameSS);
+				if (res < OK)
+					dev_err(info->dev, "Error while taking the Sync Frame frame... ERROR %08X\n",
+						res);
+
+				else {
+					dev_info(info->dev, "The total frames size is %d words\n",
+						res);
+					size += (res * sizeof(short) + 4);
+					/* +4 to add force and sense channels
+					 * for MS and SS
+					 * set res to OK because if getSyncFrame
+					 * is successful
+					 *	res = number of words read
+					 */
+					res = OK;
+
+					print_frame_short(info,
+						"MS frame =",
+						array1dTo2d_short(
+						    frameMS.node_data,
+						    frameMS.node_data_size,
+						    frameMS.header.sense_node),
+						frameMS.header.force_node,
+						frameMS.header.sense_node);
+					print_frame_short(info,
+						"SS force frame =",
+						array1dTo2d_short(
+						    frameSS.force_data,
+						    frameSS.header.force_node,
+						    1),
+						frameSS.header.force_node, 1);
+					print_frame_short(info,
+						"SS sense frame =",
+						array1dTo2d_short(
+						    frameSS.sense_data,
+						    frameSS.header.sense_node,
+						    frameSS.header.sense_node),
+						1,
+						frameSS.header.sense_node);
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_SET_OPERATING_FREQ:
+			/* need to pass: freq3 freq2 freq1 freq0 */
+			if (numberParam == 5) {
+				res = fts_enableInterrupt(info, false);
+				if (res >= OK) {
+					dev_info(info->dev, "Setting Scan Freq...\n");
+					u8ToU32_be(&cmd[1], &fileSize);
+					/* fileSize is used just as container
+					 * variable, sorry for the name! */
+
+					res = setActiveScanFrequency(info, fileSize);
+					if (res < OK)
+						dev_err(info->dev, "Error while setting the scan frequency... ERROR %08X\n",
+							res);
+					else {
+						/* setActiveScan Frequency leave
+						 * the chip in reset state but
+						 * with the new scan freq set */
+						/* need to enable the scan mode
+						 * and re-enable the interrupts
+						 * */
+						res |= setScanMode(info,
+							SCAN_MODE_LOCKED,
+							LOCKED_ACTIVE);
+						/* this is a choice to force
+						 * the IC to use the freq set */
+						res |= fts_enableInterrupt(
+								info,
+								true);
+						dev_info(info->dev, "Setting Scan Freq... res = %08X\n",
+							res);
+					}
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+
+			break;
+
+		case CMD_TP_SENS_MODE:
+			/* need to pass: enter (optional)saveGain */
+			if (numberParam >= 2) {
+				if (numberParam == 2)
+					cmd[2] = 0;	/* by default never save
+							 * the gain (used only
+							 * when exit) */
+
+				res = tp_sensitivity_mode(info, cmd[1], cmd[2]);
+				if (res < OK)
+					dev_err(info->dev, "Error while setting TP Sens mode... ERROR %08X\n",
+						res);
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+
+		case CMD_TP_SENS_SET_SCAN_MODE:
+			/* need to pass: scan_type, enableGains */
+			if (numberParam == 3) {
+				if (cmd[1] == 0x07) { /* To match the api for
+						       * C2/F2
+						       */
+					res = tp_sensitivity_set_scan_mode(
+					    info,
+					    LOCKED_SINGLE_ENDED_ONLY_MUTUAL_0,
+					    cmd[2]);
+					/* this force the IC to lock in a scan
+					 * mode
+					 */
+					if (res < OK)
+						dev_err(info->dev, "Error while setting TP Sens scan mode... ERROR %08X\n",
+						res);
+				} else {
+					dev_err(info->dev, "Wrong parameter!\n");
+					 res = ERROR_OP_NOT_ALLOW;
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+
+			break;
+
+		case CMD_TP_SENS_PRECAL_SS:
+			/* need to pass: target1 target0 percentage(optional) */
+			if (numberParam >= 3) {
+				if (numberParam > 3)
+					temp = cmd[3];
+				else
+					temp = SENS_TEST_PERC_TARGET_PRECAL;
+
+				dev_info(info->dev, "Setting target = %d and percentage = %d\n",
+					(cmd[1] << 8 | cmd[2]), temp);
+
+				res = tp_sensitivity_test_pre_cal_ss(info,
+							     &frameSS,
+							     (cmd[1] << 8 |
+									cmd[2]),
+							      temp);
+				if (res < OK)
+					dev_err(info->dev, "Error while setting the scan frequency... ERROR %08X\n",
+						res);
+
+				if ((frameSS.force_data != NULL) &&
+				    (frameSS.sense_data != NULL)) {
+					size += ((frameSS.header.force_node +
+						  frameSS.header.sense_node) *
+						 sizeof(short) + 2);
+					/*make error code positive to print the
+					 * frame*/
+					res &= (~0x80000000);
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_TP_SENS_PRECAL_MS:
+			/* need to pass: target1 target0 calibrate
+			 * percentage(optional) */
+			if (numberParam >= 4) {
+				if (numberParam > 4)
+					temp = cmd[4];
+				else
+					temp = SENS_TEST_PERC_TARGET_PRECAL;
+
+				dev_info(info->dev, "Setting target = %d and percentage = %d\n",
+					(cmd[1] << 8 | cmd[2]), temp);
+
+				res = tp_sensitivity_test_pre_cal_ms(info,
+							     &frameMS,
+							     (cmd[1] << 8 |
+									cmd[2]),
+							      temp);
+				if (res < OK)
+					dev_err(info->dev, "Error during TP Sensitivity Precal ... ERROR %08X\n",
+						res);
+
+				if (cmd[3] != 0) {
+					dev_info(info->dev, "Computing gains with target = %d and saveGain = %d\n",
+						(cmd[1] << 8 | cmd[2]), 0);
+					temp = tp_sensitivity_compute_gains(
+						info,
+						&frameMS, (cmd[1] << 8 |
+							   cmd[2]),
+						0);
+					if (temp < OK)
+						dev_err(info->dev, "Error during TP Sensitivity Calibration... ERROR %08X\n",
+							temp);
+					res |= temp;
+				}
+
+				if (frameMS.node_data != NULL) {
+					size += (frameMS.node_data_size *
+						 sizeof(short) + 2);
+					/*make error code positive to print the
+					 * frame*/
+					res &= (~0x80000000);
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_TP_SENS_POSTCAL_MS:
+			/* need to pass: target1 target0 executeTest
+			 * percentage(optional) */
+			if (numberParam >= 4) {
+				if (cmd[3] != 0) {
+					if (numberParam > 4)
+						temp = cmd[4];
+					else
+						temp =
+						SENS_TEST_PERC_TARGET_POSTCAL;
+				} else
+					temp = -1;
+
+				dev_info(info->dev, "Setting target = %d and percentage = %d\n",
+					(cmd[1] << 8 | cmd[2]), temp);
+
+				res = tp_sensitivity_test_post_cal_ms(info,
+							      &frameMS,
+							      &deltas,
+							      (cmd[1] << 8 |
+									cmd[2]),
+							      temp,
+							      &meanNorm,
+							      &meanEdge);
+				if (res < OK)
+					dev_err(info->dev, "Error during TP Sensitivity Post Cal ... ERROR %08X\n",
+						res);
+
+				/* processing for a proper printing on the shell
+				 * */
+				if ((frameMS.node_data != NULL) &&
+				    (deltas.node_data != NULL)) {
+					size += ((frameMS.node_data_size +
+						  deltas.node_data_size) *
+						 sizeof(short) +
+						 2 + 8);/* +2 force and
+							 * sense len, +8
+							 * mean_normal/edge
+							 * */
+					/*make error code positive to print the
+					 * frame*/
+					res &= (~0x80000000);
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+
+		case CMD_TP_SENS_STD:
+			/* need to pass: numFrames */
+			if (numberParam >= 2) {
+				res =  tp_sensitivity_test_std_ms(info, cmd[1],
+								  &frameMS);
+				if (res < OK)
+					dev_err(info->dev, "Error during TP Sensitivity STD... ERROR %08X\n",
+						res);
+
+				/* processing for a proper printing on the shell
+				 * */
+				if (frameMS.node_data != NULL) {
+					size += ((frameMS.node_data_size) *
+						 sizeof(short) + 2);
+					/* +2 force and sense len */
+					/*make error code positive to print the
+					 * frame*/
+					res &= (~0x80000000);
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			break;
+
+		case CMD_FORCE_TOUCH_ACTIVE:
+			/* Single parameter indicates force touch state */
+			if (numberParam == 2) {
+				if (cmd[1] > 1) {
+					dev_err(info->dev, "Parameter should be 1 or 0\n");
+					res = ERROR_OP_NOT_ALLOW;
+				} else {
+					dev_info(info->dev, "FTS_BUS_REF_FORCE_ACTIVE: %s\n",
+						cmd[1] ? "ON" : "OFF");
+					fts_set_bus_ref(info,
+						FTS_BUS_REF_FORCE_ACTIVE,
+						cmd[1]);
+					res = OK;
+				}
+			} else if (numberParam == 3){
+				if (cmd[1] > 1) {
+					dev_err(info->dev, "Parameter should be 1 or 0\n");
+					res = ERROR_OP_NOT_ALLOW;
+				} else {
+					dev_info(info->dev, "%s: %s\n",
+						cmd[2] ? "FTS_BUS_REF_BUGREPORT" :
+							"FTS_BUS_REF_FORCE_ACTIVE",
+						cmd[1] ? "ON" : "OFF");
+					fts_set_bus_ref(info,
+						cmd[2] ? FTS_BUS_REF_BUGREPORT :
+							FTS_BUS_REF_FORCE_ACTIVE,
+						cmd[1]);
+					res = OK;
+				}
+			} else {
+				dev_err(info->dev, "Wrong number of parameters!\n");
+				res = ERROR_OP_NOT_ALLOW;
+			}
+			if (res == OK) {
+				if (cmd[1])
+					__pm_stay_awake(info->wakesrc);
+				else
+					__pm_relax(info->wakesrc);
+			}
+			break;
+
+		case CMD_INFOBLOCK_STATUS:
+			res = fts_system_reset(info);
+			if (res >= OK) {
+				res = pollForErrorType(info, error_to_search,
+						       2);
+				if (res < OK) {
+					dev_err(info->dev, "No info block corruption!\n");
+					res = OK;
+				} else {
+					dev_info(info->dev, "Info block errors found!\n");
+					res = ERROR_INFO_BLOCK;
+				}
+			}
+			break;
+
+		default:
+			dev_err(info->dev, "COMMAND ID NOT VALID!!!\n");
+			res = ERROR_OP_NOT_ALLOW;
+			break;
+		}
+
+		/* res2 = fts_enableInterrupt(info, true);
+		 * the interrupt was disabled on purpose in this node because it
+		 * can be used for testing procedure and between one step and
+		 * another the interrupt wan to be kept disabled
+		 * if (res2 < 0) {
+		 *      dev_err(info->dev, "stm_driver_test_show: ERROR %08X\n",
+		 * (res2 | ERROR_ENABLE_INTER));
+		 * }*/
+	} else {
+		dev_err(info->dev, "NO COMMAND SPECIFIED!!! do: 'echo [cmd_code] [args] > stm_fts_cmd' before looking for result!\n");
+		res = ERROR_OP_NOT_ALLOW;
+	}
+
+END:	/* here start the reporting phase, assembling the data to send in the
+	 * file node */
+	if (info->driver_test_buff != NULL) {
+		dev_info(info->dev, "Consecutive echo on the file node, free the buffer with the previous result\n");
+		kfree(info->driver_test_buff);
+	}
+
+	if (byte_call == 0) {
+		/* keep for ito_max_val array */
+		if (funcToTest[0] == CMD_ITOTEST)
+			size += (ARRAY_SIZE(ito_max_val) * sizeof(u16));
+		size *= 2;
+		size += 2;	/* add \n and \0 (terminator char) */
+	} else {
+		if (info->bin_output != 1) {
+			size *= 2; /* need to code each byte as HEX string */
+			size -= 1;	/* start byte is just one, the extra
+					 * byte of end byte taken by \n */
+		} else
+			size += 1;	/* add \n */
+	}
+
+	dev_info(info->dev, "Size = %d\n", size);
+	info->driver_test_buff = (u8 *)kzalloc(size, GFP_KERNEL);
+	dev_info(info->dev, "Finish to allocate memory!\n");
+	if (info->driver_test_buff == NULL) {
+		dev_err(info->dev, "Unable to allocate driver_test_buff! ERROR %08X\n",
+			ERROR_ALLOC);
+		goto ERROR;
+	}
+
+	if (byte_call == 0) {
+		index = 0;
+		index += scnprintf(&info->driver_test_buff[index],
+				   size - index, "{ ");
+		index += scnprintf(&info->driver_test_buff[index],
+				   size - index, "%08X", res);
+		if (res >= OK || report) {
+			/*all the other cases are already fine printing only the
+			 * res.*/
+			switch (funcToTest[0]) {
+			case CMD_VERSION:
+			case CMD_READ:
+			case CMD_WRITEREAD:
+			case CMD_WRITETHENWRITEREAD:
+			case CMD_WRITEREADU8UX:
+			case CMD_WRITEU8UXTHENWRITEREADU8UX:
+			case CMD_READCONFIG:
+			case CMD_POLLFOREVENT:
+				/* dev_err(info->dev, "Data = "); */
+				if (info->mess.dummy == 1)
+					j = 1;
+				else
+					j = 0;
+				for (; j < byteToRead + info->mess.dummy; j++) {
+					/* dev_err(info->dev, "%02X ", readData[j]); */
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X", readData[j]);
+					/* this approach is much more faster */
+				}
+				/* dev_err(info->dev, "\n"); */
+				break;
+			case CMD_GETFWFILE:
+			case CMD_GETLIMITSFILE:
+				dev_info(info->dev, "Start To parse!\n");
+				for (j = 0; j < fileSize; j++) {
+					/* dev_err(info->dev, "%02X ", readData[j]); */
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X", readData[j]);
+				}
+				dev_info(info->dev, "Finish to parse!\n");
+				break;
+			case CMD_GETFORCELEN:
+			case CMD_GETSENSELEN:
+				index += scnprintf(&info->driver_test_buff[index],
+						   size - index, "%02X",
+						   (u8)temp);
+				break;
+			case CMD_GETMSFRAME:
+			case CMD_TP_SENS_PRECAL_MS:
+			case CMD_TP_SENS_POSTCAL_MS:
+			case CMD_TP_SENS_STD:
+			case CMD_ITOTEST:
+
+				if (frameMS.node_data == NULL)
+					break;
+
+				if (res != OK)
+					info->driver_test_buff[2] = '8';
+				/* convert back error code to negative */
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)frameMS.header.force_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)frameMS.header.sense_node);
+
+				if (funcToTest[0] == CMD_ITOTEST) {
+					index += scnprintf(&info->driver_test_buff[index],
+							size - index,
+							"%02X%02X",
+							(ito_max_val[0] & 0xFF00) >> 8,
+							ito_max_val[0] & 0xFF);
+
+					index += scnprintf(&info->driver_test_buff[index],
+							size - index,
+							"%02X%02X",
+							(ito_max_val[1] & 0xFF00) >> 8,
+							ito_max_val[1] & 0xFF);
+				}
+
+				for (j = 0; j < frameMS.node_data_size; j++) {
+					index += scnprintf(
+					   &info->driver_test_buff[index],
+					   size - index,
+					   "%02X%02X",
+					   (frameMS.node_data[j] & 0xFF00) >> 8,
+					   frameMS.node_data[j] & 0xFF);
+				}
+
+				kfree(frameMS.node_data);
+
+				if (funcToTest[0] == CMD_TP_SENS_POSTCAL_MS) {
+					/* print also mean and deltas */
+					for (j = 0; j < deltas.node_data_size;
+					     j++) {
+						index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X%02X",
+						    (deltas.node_data[j] &
+							 0xFF00) >> 8,
+						    deltas.node_data[j] &
+							0xFF);
+					}
+					kfree(deltas.node_data);
+
+					index += scnprintf(
+						     &info->driver_test_buff[index],
+						     size - index,
+						     "%08X", meanNorm);
+
+					index += scnprintf(
+						     &info->driver_test_buff[index],
+						     size - index,
+						     "%08X", meanEdge);
+				}
+				break;
+			case CMD_GETSSFRAME:
+			case CMD_TP_SENS_PRECAL_SS:
+				if (res != OK)
+					info->driver_test_buff[2] = '8';
+				/* convert back error code to negative */
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)frameSS.header.force_node);
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)frameSS.header.sense_node);
+				/* Copying self raw data Force */
+				for (j = 0; j < frameSS.header.force_node;
+				     j++) {
+					index += scnprintf(
+					  &info->driver_test_buff[index],
+					  size - index,
+					  "%02X%02X",
+					  (frameSS.force_data[j] & 0xFF00) >> 8,
+					  frameSS.force_data[j] & 0xFF);
+				}
+
+				/* Copying self raw data Sense */
+				for (j = 0; j < frameSS.header.sense_node;
+				     j++) {
+					index += scnprintf(
+					  &info->driver_test_buff[index],
+					  size - index,
+					  "%02X%02X",
+					  (frameSS.sense_data[j] & 0xFF00) >> 8,
+					  frameSS.sense_data[j] & 0xFF);
+				}
+
+				kfree(frameSS.force_data);
+				kfree(frameSS.sense_data);
+				break;
+
+			case CMD_GETSYNCFRAME:
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)frameMS.header.force_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)frameMS.header.sense_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)frameSS.header.force_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)frameSS.header.sense_node);
+
+				/* Copying mutual data */
+				for (j = 0; j < frameMS.node_data_size; j++) {
+					index += scnprintf(
+						&info->driver_test_buff[index],
+						size - index,
+						"%02X%02X",
+						(frameMS.node_data[j] &
+							0xFF00) >> 8,
+						frameMS.node_data[j] & 0xFF);
+				}
+
+				/* Copying self data Force */
+				for (j = 0; j < frameSS.header.force_node;
+				     j++) {
+					index += scnprintf(
+						&info->driver_test_buff[index],
+						size - index,
+						"%02X%02X",
+						(frameSS.force_data[j] &
+							0xFF00) >> 8,
+						frameSS.force_data[j] & 0xFF);
+				}
+
+				/* Copying self  data Sense */
+				for (j = 0; j < frameSS.header.sense_node;
+				     j++) {
+					index += scnprintf(
+						&info->driver_test_buff[index],
+						size - index,
+						"%02X%02X",
+						(frameSS.sense_data[j] &
+							0xFF00) >> 8,
+						frameSS.sense_data[j] & 0xFF);
+				}
+
+				kfree(frameMS.node_data);
+				kfree(frameSS.force_data);
+				kfree(frameSS.sense_data);
+				break;
+
+			case CMD_READMSCOMPDATA:
+				index += scnprintf(&info->driver_test_buff[index],
+						   size - index, "%02X",
+						   (u8)compData.header.type);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)compData.header.force_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)compData.header.sense_node);
+
+				/* Cpying CX1 value */
+				index += scnprintf(&info->driver_test_buff[index],
+						   size - index, "%02X",
+						   compData.cx1 & 0xFF);
+
+				/* Copying CX2 values */
+				for (j = 0; j < compData.node_data_size; j++) {
+					index += scnprintf(
+						&info->driver_test_buff[index],
+						size - index,
+						"%02X",
+						compData.node_data[j] & 0xFF);
+				}
+
+				kfree(compData.node_data);
+				break;
+
+			case CMD_READSSCOMPDATA:
+				index += scnprintf(&info->driver_test_buff[index],
+						   size - index, "%02X",
+						   (u8)comData.header.type);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						   size - index, "%02X",
+						   comData.header.force_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						   size - index, "%02X",
+						   comData.header.sense_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						   size - index, "%02X",
+						   comData.f_ix1 & 0xFF);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						   size - index, "%02X",
+						   comData.s_ix1 & 0xFF);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						   size - index, "%02X",
+						   comData.f_cx1 & 0xFF);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						   size - index, "%02X",
+						   comData.s_cx1 & 0xFF);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						   size - index, "%02X",
+						   comData.f_ix0 & 0xFF);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						   size - index, "%02X",
+						   comData.s_ix0 & 0xFF);
+
+				/* Copying IX2 Force */
+				for (j = 0; j < comData.header.force_node;
+				     j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X",
+						    comData.ix2_fm[j] & 0xFF);
+				}
+
+				/* Copying IX2 Sense */
+				for (j = 0; j < comData.header.sense_node;
+				     j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X",
+						    comData.ix2_sn[j] & 0xFF);
+				}
+
+				/* Copying CX2 Force */
+				for (j = 0; j < comData.header.force_node;
+				     j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X",
+						    comData.cx2_fm[j] & 0xFF);
+				}
+
+				/* Copying CX2 Sense */
+				for (j = 0; j < comData.header.sense_node;
+				     j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X",
+						    comData.cx2_sn[j] & 0xFF);
+				}
+
+				kfree(comData.ix2_fm);
+				kfree(comData.ix2_sn);
+				kfree(comData.cx2_fm);
+				kfree(comData.cx2_sn);
+				break;
+
+
+			case CMD_READGOLDENMUTUAL:
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)gmRawData.hdm_hdr.type);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						gmRawData.hdr.ms_f_len);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						gmRawData.hdr.ms_s_len);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						gmRawData.hdr.ss_f_len);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						gmRawData.hdr.ss_s_len);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						gmRawData.hdr.ms_k_len);
+
+				/* Copying Golden Mutual raw values */
+				for (j = 0; j < gmRawData.data_size; j++) {
+					index += scnprintf(
+						&info->driver_test_buff[index],
+						size - index, "%04X",
+						(u16)gmRawData.data[j]);
+				}
+
+				kfree(gmRawData.data);
+				break;
+
+			case CMD_READTOTMSCOMPDATA:
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)totCompData.header.type);
+
+				index += scnprintf(&info->driver_test_buff[index],
+					    size - index, "%02X",
+					    (u8)totCompData.header.force_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+					    size - index, "%02X",
+					    (u8)totCompData.header.sense_node);
+
+				/* Copying TOT CX values */
+				for (j = 0; j < totCompData.node_data_size;
+				     j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X%02X",
+						    (totCompData.node_data[j] &
+							0xFF00) >> 8,
+						    totCompData.node_data[j] &
+							0xFF);
+				}
+
+				kfree(totCompData.node_data);
+				break;
+
+			case CMD_READTOTSSCOMPDATA:
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)totComData.header.type);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						totComData.header.force_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						totComData.header.sense_node);
+
+				/* Copying TOT IX Force */
+				for (j = 0; j < totComData.header.force_node;
+				     j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X%02X",
+						    (totComData.ix_fm[j] &
+							0xFF00) >> 8,
+						    totComData.ix_fm[j] &
+							0xFF);
+				}
+
+				/* Copying TOT IX Sense */
+				for (j = 0; j < totComData.header.sense_node;
+				     j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X%02X",
+						    (totComData.ix_sn[j] &
+							0xFF00) >> 8,
+						    totComData.ix_sn[j] &
+							0xFF);
+				}
+
+				/* Copying TOT CX Force */
+				for (j = 0; j < totComData.header.force_node;
+				     j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X%02X",
+						    (totComData.cx_fm[j] &
+							0xFF00) >> 8,
+						    totComData.cx_fm[j] &
+							0xFF);
+				}
+
+				/* Copying CX2 Sense */
+				for (j = 0; j < totComData.header.sense_node;
+				     j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X%02X",
+						    (totComData.cx_sn[j] &
+							0xFF00) >> 8,
+						    totComData.cx_sn[j] &
+							0xFF);
+				}
+
+				kfree(totComData.ix_fm);
+				kfree(totComData.ix_sn);
+				kfree(totComData.cx_fm);
+				kfree(totComData.cx_sn);
+				break;
+
+			case CMD_READSENSCOEFF:
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)msCoeff.header.force_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)msCoeff.header.sense_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)ssCoeff.header.force_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)ssCoeff.header.sense_node);
+
+				/* Copying MS Coefficients */
+				for (j = 0; j < msCoeff.node_data_size; j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X",
+						    msCoeff.ms_coeff[j] & 0xFF);
+				}
+
+				/* Copying SS force Coefficients */
+				for (j = 0; j < ssCoeff.header.force_node;
+				     j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X",
+						    ssCoeff.ss_force_coeff[j] &
+							0xFF);
+				}
+
+				/* Copying SS sense Coefficients */
+				for (j = 0; j < ssCoeff.header.sense_node;
+				     j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X",
+						    ssCoeff.ss_sense_coeff[j] &
+							0xFF);
+				}
+
+				kfree(msCoeff.ms_coeff);
+				kfree(ssCoeff.ss_force_coeff);
+				kfree(ssCoeff.ss_sense_coeff);
+				break;
+
+			case CMD_GETFWVER:
+				for (j = 0; j < EXTERNAL_RELEASE_INFO_SIZE;
+				     j++) {
+					index += scnprintf(
+					  &info->driver_test_buff[index],
+					  size - index,
+					  "%02X",
+					  info->systemInfo.u8_releaseInfo[j]);
+				}
+				break;
+
+			case CMD_READCOMPDATAHEAD:
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						dataHead.type);
+				break;
+
+			case CMD_READ_SYNC_FRAME:
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)frameMS.header.force_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)frameMS.header.sense_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)frameSS.header.force_node);
+
+				index += scnprintf(&info->driver_test_buff[index],
+						size - index, "%02X",
+						(u8)frameSS.header.sense_node);
+
+				/* Copying mutual data */
+				for (j = 0; j < frameMS.node_data_size; j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X%02X",
+						    (frameMS.node_data[j] &
+							0xFF00) >> 8,
+						    frameMS.node_data[j] &
+							0xFF);
+				}
+
+				/* Copying self data Force */
+				for (j = 0; j < frameSS.header.force_node;
+				     j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X%02X",
+						    (frameSS.force_data[j] &
+							0xFF00) >> 8,
+						    frameSS.force_data[j] &
+							0xFF);
+				}
+
+
+				/* Copying self  data Sense */
+				for (j = 0; j < frameSS.header.sense_node;
+				     j++) {
+					index += scnprintf(
+						    &info->driver_test_buff[index],
+						    size - index,
+						    "%02X%02X",
+						    (frameSS.sense_data[j] &
+							0xFF00) >> 8,
+						    frameSS.sense_data[j] &
+							0xFF);
+				}
+
+				kfree(frameMS.node_data);
+				kfree(frameSS.force_data);
+				kfree(frameSS.sense_data);
+				break;
+
+
+			default:
+				break;
+			}
+		}
+
+		index += scnprintf(&info->driver_test_buff[index],
+				   size - index, " }\n");
+		info->limit = size - 1;/* avoid to print \0 in the shell */
+		info->printed = 0;
+	} else {
+		/* start byte */
+		info->driver_test_buff[index++] = MESSAGE_START_BYTE;
+		if (info->bin_output == 1) {
+			/* msg_size */
+			info->driver_test_buff[index++] = (size & 0xFF00) >> 8;
+			info->driver_test_buff[index++] = (size & 0x00FF);
+			/* counter id */
+			info->driver_test_buff[index++] =
+				(info->mess.counter & 0xFF00) >> 8;
+			info->driver_test_buff[index++] = (info->mess.counter & 0x00FF);
+			/* action */
+			info->driver_test_buff[index++] = (info->mess.action & 0xFF00) >> 8;
+			info->driver_test_buff[index++] = (info->mess.action & 0x00FF);
+			/* error */
+			info->driver_test_buff[index++] = (res & 0xFF00) >> 8;
+			info->driver_test_buff[index++] = (res & 0x00FF);
+		} else {
+			if (funcToTest[0] == CMD_GETLIMITSFILE_BYTE ||
+			    funcToTest[0] == CMD_GETFWFILE_BYTE)
+				index += scnprintf(&info->driver_test_buff[index],
+					   size - index,
+					   "%02X%02X",
+					   (((fileSize + 3) / 4) & 0xFF00) >> 8,
+					   ((fileSize + 3) / 4) & 0x00FF);
+			else
+				index += scnprintf(&info->driver_test_buff[index],
+					    size - index,
+					    "%02X%02X", (size & 0xFF00) >> 8,
+					    size & 0xFF);
+
+			index += scnprintf(&info->driver_test_buff[index],
+					   size - index, "%04X",
+					   (u16)info->mess.counter);
+			index += scnprintf(&info->driver_test_buff[index],
+					   size - index, "%04X",
+					   (u16)info->mess.action);
+			index += scnprintf(&info->driver_test_buff[index],
+					   size - index,
+					   "%02X%02X", (res & 0xFF00) >> 8,
+					   res & 0xFF);
+		}
+
+		switch (funcToTest[0]) {
+		case CMD_VERSION_BYTE:
+		case CMD_READ_BYTE:
+		case CMD_WRITEREAD_BYTE:
+		case CMD_WRITETHENWRITEREAD_BYTE:
+		case CMD_WRITEREADU8UX_BYTE:
+		case CMD_WRITEU8UXTHENWRITEREADU8UX_BYTE:
+			if (info->bin_output == 1) {
+				if (info->mess.dummy == 1)
+					memcpy(&info->driver_test_buff[index],
+					       &readData[1], byteToRead);
+				else
+					memcpy(&info->driver_test_buff[index],
+					       readData, byteToRead);
+				index += byteToRead;
+			} else {
+				j = info->mess.dummy;
+				for (; j < byteToRead + info->mess.dummy; j++)
+					index += scnprintf(
+						&info->driver_test_buff[index],
+						size - index,
+						"%02X",
+						(u8)readData[j]);
+			}
+			break;
+
+		case CMD_GETLIMITSFILE_BYTE:
+		case CMD_GETFWFILE_BYTE:
+			if (info->bin_output == 1) {
+				/* override the msg_size with dimension in words
+				 * */
+				info->driver_test_buff[1] = (
+					((fileSize + 3) / 4) & 0xFF00) >> 8;
+				info->driver_test_buff[2] = (
+					((fileSize + 3) / 4) & 0x00FF);
+
+				if (readData != NULL)
+					memcpy(&info->driver_test_buff[index],
+					       readData, fileSize);
+				else
+					dev_err(info->dev, "readData = NULL... returning junk data!");
+				index += addr;	/* in this case the byte to read
+						 * are stored in addr because it
+						 * is a u64 end byte need to be
+						 * inserted at the end of the
+						 * padded memory */
+			} else {
+				/* snprintf(&info->driver_test_buff[1], 3, "%02X",
+				 * (((fileSize + 3) / 4)&0xFF00) >> 8); */
+				/* snprintf(&info->driver_test_buff[3], 3, "%02X",
+				 * ((fileSize + 3) / 4)&0x00FF); */
+				for (j = 0; j < fileSize; j++)
+					index += scnprintf(
+						&info->driver_test_buff[index],
+						size - index,
+						"%02X",
+						(u8)readData[j]);
+				for (; j < addr; j++)
+					index += scnprintf(
+						&info->driver_test_buff[index],
+						size - index,
+						"%02X", 0);	/* pad memory
+								 * with 0x00 */
+			}
+			break;
+		default:
+			break;
+		}
+
+		index += scnprintf(&info->driver_test_buff[index],
+				  size - index, "%c\n", MESSAGE_END_BYTE);
+		/*for(j=0; j<size; j++){
+		  *      dev_err(info->dev, "%c", info->driver_test_buff[j]);
+		  * }*/
+		info->limit = size;
+		info->printed = 0;
+	}
+ERROR:
+	numberParam = 0;/* need to reset the number of parameters in order to
+			 * wait the next command, comment if you want to repeat
+			 * the last command sent just doing a cat */
+
+	/* dev_err(info->dev, 0,"numberParameters = %d\n", numberParam); */
+
+	kfree(readData);
+	kfree(cmd);
+	kfree(funcToTest);
+	kfree(pbuf);
+
+	fts_set_bus_ref(info, FTS_BUS_REF_SYSFS, false);
+
+exit:
+	return count;
+}
+
+/** @}*/
+
+/**
+  * file_operations struct which define the functions for the canonical
+  * operation on a device file node (open. read, write etc.)
+  */
+static const struct proc_ops fts_driver_test_ops = {
+	.proc_open	= fts_driver_test_open,
+	.proc_read	= seq_read,
+	.proc_write	= fts_driver_test_write,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= fts_driver_test_release
+};
+
+/*****************************************************************************/
+
+/**
+  * This function is called in the probe to initialize and create the directory
+  * proc/fts and the driver test file node DRIVER_TEST_FILE_NODE into the /proc
+  * file system
+  * @return OK if success or an error code which specify the type of error
+  */
+int fts_proc_init(struct fts_ts_info *info)
+{
+	struct proc_dir_entry *entry;
+
+	int retval = 0;
+
+	info->fts_dir = proc_mkdir_data(info->board->device_name, 0555,
+					NULL, info);
+	if (info->fts_dir == NULL) {	/* directory creation failed */
+		retval = -ENOMEM;
+		goto out;
+	}
+
+	entry = proc_create_data(DRIVER_TEST_FILE_NODE, 0666, info->fts_dir,
+				 &fts_driver_test_ops, info);
+
+	if (entry)
+		dev_info(info->dev, "%s: proc entry CREATED!\n", __func__);
+	else {
+		dev_err(info->dev, "%s: error creating proc entry!\n", __func__);
+		retval = -ENOMEM;
+		goto badfile;
+	}
+	return OK;
+badfile:
+	remove_proc_entry("fts", NULL);
+out:
+	return retval;
+}
+
+/**
+  * Delete and Clean from the file system, all the references to the driver test
+  * file node
+  * @return OK
+  */
+int fts_proc_remove(struct fts_ts_info *info)
+{
+	remove_proc_entry(DRIVER_TEST_FILE_NODE, info->fts_dir);
+	remove_proc_entry("fts", NULL);
+	return OK;
+}
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("STMicroelectronics MultiTouch IC Driver");
+MODULE_AUTHOR("STMicroelectronics");
-- 
2.43.0


From 6ac9b6bfbb21973643a00b3bf308e1d716f76335 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sun, 1 Jun 2025 06:52:23 +0000
Subject: [PATCH 29/39] dts: qcom: update xiaomi 10 dts. - add touch node.

---
 .../arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts | 406 +++++++++---------
 1 file changed, 213 insertions(+), 193 deletions(-)

diff --git a/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts b/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts
index dc9247828411..9a12ece7181d 100644
--- a/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts
+++ b/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts
@@ -67,13 +67,21 @@ wcd938x: audio-codec {
 		#sound-dai-cells = <1>;
 	};
 
+	// battery: battery {
+	// 	compatible = "simple-battery";
+	// 	voltage-min-design-microvolt = <3400000>;
+	// 	voltage-max-design-microvolt = <4400000>;
+	// 	charge-full-design-microamp-hours = <4680000>;
+	// 	energy-full-design-microwatt-hours = <18400000>;
+	// };
+
 	chosen {
 		#address-cells = <2>;
 		#size-cells = <2>;
 		ranges;
 		// stdout-path = "serial0:115200n8";
-		stdout-path = "display0";
-		bootargs = "pd_ignore_unused clk_ignore_unused panic=30 loglevel=7 console=ttyS0,115200 console=tty1 rootfs_part=sda36 root=/dev/sda36 rw systemd.journald.forward_to_console=true systemd.log_level=debug systemd.log_target=kmsg log_buf_len=10M printk.devkmsg=on";
+		// stdout-path = "display0";
+		bootargs = "panic=30 loglevel=7 console=ttyS0,115200 console=tty1 rootfs_part=sda36 root=/dev/sda36 rw rootwait systemd.journald.forward_to_console=true systemd.log_level=debug systemd.log_target=kmsg log_buf_len=10M printk.devkmsg=on";
 		//  pd_ignore_unused clk_ignore_unused 
 		display0: framebuffer@9c000000 {
 			compatible = "simple-framebuffer";
@@ -82,6 +90,7 @@ display0: framebuffer@9c000000 {
 			height = <2340>;
 			stride = <(1080 * 4)>;
 			format = "a8r8g8b8";
+			status = "disabled";
 			/*
 			 * That's a lot of clocks, but it's necessary due
 			 * to unused clk cleanup & no panel driver yet..
@@ -103,7 +112,7 @@ qca6390-pmu {
 		compatible = "qcom,qca6390-pmu";
 
 		pinctrl-names = "default";
-		pinctrl-0 = <&bt_en_state>, <&wlan_en_state>, <&mdm2ap_default>, <&ap2mdm_default>, <&ap2mdm_active>;
+		pinctrl-0 = <&bt_en_state>, <&wlan_en_state>;
 
 		vddaon-supply = <&vreg_s6a_0p95>;
 		vddpmu-supply = <&vreg_s2f_0p95>;
@@ -260,6 +269,31 @@ active-config0 {
 		};
 	};
 
+	// slimbam: dma-controller@3a84000 {
+	// 	compatible = "qcom,bam-v1.7.4", "qcom,bam-v1.7.0";
+	// 	reg = <0x0 0x3a84000 0x0 0x2c000>;
+	// 	interrupts = <GIC_SPI 164 IRQ_TYPE_LEVEL_HIGH>;
+	// 	#dma-cells = <1>;
+	// 	qcom,ee = <1>;
+	// 	qcom,num-ees = <2>;
+	// 	num-channels = <31>;
+	// 	qcom,controlled-remotely;
+	// 	iommus = <&apps_smmu 0x1826 0x00>;
+	// };
+
+	// slim_msm: slim-ngd@3ac0000  {
+	// 	compatible = "qcom,slim-ngd-v1.5.0";
+	// 	reg = <0 0x3ac0000 0 0x2c000>;
+	// 	interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+	// 	dmas = <&slimbam 3>, <&slimbam 4>;
+	// 	dma-names = "rx", "tx";
+	// 	#address-cells = <1>;
+	// 	#size-cells = <0>;
+	// 	iommus = <&apps_smmu 0x1830 0x01>,
+	// 			<&apps_smmu 0x182f 0x00>;
+	// 	status = "disabled";
+	// };
+
 	vph_pwr: vph-pwr-regulator {
 		compatible = "regulator-fixed";
 		regulator-name = "vph_pwr";
@@ -302,6 +336,8 @@ key-vol-up {
 	vdd_boost_vreg: vdd_boost_vreg {
 		compatible = "regulator-fixed";
 		regulator-name = "vdd_boost_vreg";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
 		startup-delay-us = <4000>;
 		enable-active-high;
 		regulator-always-on;
@@ -309,30 +345,28 @@ vdd_boost_vreg: vdd_boost_vreg {
 	 };
 
 	ext_5v_boost: ext-5v-boost {
-		compatible = "regulator-fixed";
 		status = "okay";
-		regulator-name = "ext_5v_boost";
+		compatible = "regulator-fixed";
 		gpio = <&pm8150b_gpios 12 GPIO_ACTIVE_HIGH>;
-		enable-active-high;
-		regulator-enable-ramp-delay = <1600>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&otg_vbus_boost>;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-enable-ramp-delay = <1600>;
+		regulator-name = "ext_5v_boost";
+		enable-active-high;
 	};
 
 	touch_vddio_vreg: touch_vddio_vreg {
 		status = "okay";
 		compatible = "regulator-fixed";
 		regulator-name = "disp_vddio_vreg";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
 		enable-active-high;
 		gpio = <&tlmm 69 0>;
 	};
 
-	xiaomi_touch: xiaomi_touch {
-		compatible = "xiaomi-touch";
-		status = "ok";
-		touch,name = "xiaomi-touch";
-	};
-
 	reserved-memory {
 		xbl_aop_mem: memory@80600000 {
 			reg = <0x0 0x80600000 0x0 0x260000>;
@@ -374,11 +408,30 @@ disp_rdump_region: memory@b0400000 {
 			no-map;
 		};
 
-		cont_splash_region@9c000000 {
-			reg = <0x0 0x9c000000 0x0 0x2300000>;
-			label = "cont_splash_region";
+		adsp_dma_mem: memory@9E400000 {
+			reg = <0x0 0x9E400000 0x0 0xc00000>;
 			no-map;
 		};
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			size = <0x0 0x8000000>;
+			reusable;
+			linux,cma-default;
+		};
+
+		// cont_splash_region@9c000000 {
+		// 	reg = <0x0 0x9c000000 0x0 0x2300000>;
+		// 	label = "cont_splash_region";
+		// 	no-map;
+		// };
+
+		ramoops@b0000000 {
+			compatible = "ramoops";
+			reg = <0x0 0xb0000000 0x0 0x400000>;
+			record-size = <0>;
+			console-size = <0x200000>;
+		};
 	};
 };
 
@@ -400,47 +453,15 @@ &pon_resin {
 &adsp {
 	status = "okay";
 	firmware-name = "qcom/sm8250/umi/adsp.mbn";
+	glink-edge {
+		fastrpc {
+			memory-region = <&adsp_dma_mem>;
+		};
+	};
 };
 
-// &cpu0 {
-// 	capacity-dmips-mhz = <1024>;
-// 	dynamic-power-coefficient = <100>;
-// };
-
-// &cpu1 {
-// 	capacity-dmips-mhz = <1024>;
-// 	dynamic-power-coefficient = <100>;
-
-// };
-
-// &cpu2 {
-// 	capacity-dmips-mhz = <1024>;
-// 	dynamic-power-coefficient = <100>;
-// };
-
-// &cpu3 {
-// 	capacity-dmips-mhz = <1024>;
-// 	dynamic-power-coefficient = <100>;
-// };
-
-// &cpu4 {
-// 	capacity-dmips-mhz = <1894>;
-// 	dynamic-power-coefficient = <533>;
-// };
-
-// &cpu5 {
-// 	capacity-dmips-mhz = <1894>;
-// 	dynamic-power-coefficient = <533>;
-// };
-
-// &cpu6 {
-// 	capacity-dmips-mhz = <1894>;
-// 	dynamic-power-coefficient = <533>;
-// };
-
-// &cpu7 {
-// 	capacity-dmips-mhz = <1894>;
-// 	dynamic-power-coefficient = <642>;
+// &slim_msm {
+// 	status = "okay";
 // };
 
 &apps_rsc {
@@ -556,10 +577,10 @@ vreg_l15a_11ad_io_1p8: ldo15 {
 			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
 		};
 
-		vreg_l16a_2p7: ldo16 {
-			regulator-name = "vreg_l16a_2p7";
-			regulator-min-microvolt = <2704000>;
-			regulator-max-microvolt = <2960000>;
+		vreg_l16a_3p3: ldo16 {
+			regulator-name = "vreg_l16a_3p3";
+			regulator-min-microvolt = <3024000>;
+			regulator-max-microvolt = <3304000>;
 			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
 		};
 
@@ -616,6 +637,8 @@ vreg_l1c_1p8: ldo1 {
 			regulator-min-microvolt = <1800000>;
 			regulator-max-microvolt = <1800000>;
 			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+			// regulator-always-on;
+			// regulator-boot-on;
 		};
 
 		vreg_l2c_1p2: ldo2 {
@@ -774,21 +797,32 @@ zap-shader {
 };
 
 &i2c1 {
-	status = "disabled";
-
-	// nfc@28 {
-	// 	compatible = "nxp,nxp-nci-i2c";
-	// 	reg = <0x28>;
-	// 	interrupt-parent = <&tlmm>;
-	// 	interrupts = <111 IRQ_TYPE_EDGE_RISING>;
-	// 	enable-gpios = <&tlmm 83 GPIO_ACTIVE_HIGH>;
-	// 	firmware-gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
-	// };
+	status = "okay";
+
+	nfc@28 {
+		compatible = "nxp,nxp-nci-i2c";
+		status = "disabled";
+		reg = <0x28>;
+		interrupt-parent = <&tlmm>;
+		interrupts = <111 IRQ_TYPE_EDGE_RISING>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&nfc_int_default>,
+					<&nfc_ven_default>,
+					<&nfc_clk_req_default>;
+
+		enable-gpios = <&tlmm 83 GPIO_ACTIVE_HIGH>;
+		firmware-gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
+	};
 };
 
 &spi2 {
 	status = "okay";
-	spi-max-frequency = <0x124f800>;
+	spi-max-frequency = <19200000>;
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&qup_spi2_data_clk>, <&qup_spi2_cs_gpio>;
+	cs-gpios = <&tlmm 118 GPIO_ACTIVE_LOW>;
 
 	ir-spi@0 {
 		compatible = "ir-spi";
@@ -803,6 +837,7 @@ &i2c3 {
 
 	cs35l41_l: speaker-amp@40 {
 		compatible = "cirrus,cs35l41";
+		status = "okay";
 		reg = <0x40>;
 		interrupt-parent = <&tlmm>;
 		interrupts = <113 IRQ_TYPE_LEVEL_LOW>;
@@ -813,33 +848,35 @@ cs35l41_l: speaker-amp@40 {
 		cirrus,asp-sdout-hiz = <1>;
 		cirrus,gpio2-src-select = <4>;
 		cirrus,gpio2-output-enable;
+		sound-name-prefix = "L";
 		#sound-dai-cells = <1>;
 	};
 
 	cs35l41_r: speaker-amp@42 {
 		compatible = "cirrus,cs35l41";
+		status = "okay";
 		reg = <0x42>;
-		status = "disabled";
 		interrupt-parent = <&tlmm>;
 		interrupts = <112 IRQ_TYPE_LEVEL_LOW>;
 		reset-gpios = <&tlmm 114 GPIO_ACTIVE_HIGH>;
 		cirrus,boost-peak-milliamp = <4000>;
 		cirrus,boost-ind-nanohenry = <1000>;
 		cirrus,boost-cap-microfarad = <15>;
-		cirrus,asp-sdout-hiz = <1>;
+		cirrus,asp-sdout-hiz = <3>;
 		cirrus,gpio2-src-select = <4>;
 		cirrus,gpio2-output-enable;
+		sound-name-prefix = "R";
 		#sound-dai-cells = <1>;
 	};
 };
 
 &i2c13 {
 	clock-frequency = <400000>;
-	status = "disabled";
+	status = "okay";
 
-	/* st,stmfts @ 49 */
-	fts@49 {
-		status = "disabled";
+	/* st,fts @ 49 */
+	touchscreen: fts@49 {
+		status = "okay";
 		compatible = "st,fts";
 		reg = <0x49>;
 		interrupt-parent = <&tlmm>;
@@ -847,8 +884,8 @@ fts@49 {
 		pinctrl-names = "pmx_ts_active", "pmx_ts_suspend";
 		pinctrl-0 = <&ts_active>;
 		pinctrl-1 = <&ts_int_suspend &ts_reset_suspend>;
-		avdd-supply = <&touch_vddio_vreg>;
-		vdd-supply = <&vreg_l5a_0p875>;
+		vdd-supply = <&touch_vddio_vreg>;
+		avdd-supply = <&vreg_l1c_1p8>;
 		fts,pwr-reg-name = "avdd";
 		fts,bus-reg-name = "vdd";
 		fts,irq-gpio = <&tlmm 39 0x2008>;
@@ -859,65 +896,10 @@ fts@49 {
 		fts,irq-flags = <0x2008>; /* IRQF_ONESHOT | IRQF_TRIGGER_LOW */
 		fts,x-max = <1080>;
 		fts,y-max = <2340>;
-		fts,fod-lx = <421>;
-		fts,fod-ly = <1788>;
-		fts,fod-x-size = <238>;
-		fts,fod-y-size = <238>;
-		fts,default-fw-name = "st_fts_j2.ftb";
-		fts,config-array-size = <2>;
-		fts,dump-click-count;
-		fts,support-fod;
-		fts,touch-up-threshold-min = <40>;
-		fts,touch-up-threshold-max = <120>;
-		fts,touch-up-threshold-def = <80>;
-		fts,touch-tolerance-min = <5>;
-		fts,touch-tolerance-max = <35>;
-		fts,touch-tolerance-def = <25>;
-		fts,touch-idletime-min = <0>;
-		fts,touch-idletime-max = <12750>;
-		fts,touch-idletime-def = <12450>;
-
-		/*edge filter rects in gamemode*/
-		fts,cornerfilter-area-step1 = <100>;
-		fts,cornerfilter-area-step2 = <170>;
-		fts,cornerfilter-area-step3 = <250>;
-		fts,touch-deadzone-filter-ver = <2 0 0 0 0 0 0 0
-							2 1 0 0 0 0 0 0
-							2 2 0 0 5 2339 0 0
-							2 3 1074 0 1079 2339 0 0>;
-		fts,touch-deadzone-filter-hor = <2 0 0 0 1079 5 0 0
-							2 1 0 2334 1079 2339 0 0
-							2 2 0 0 5 2339 0 0
-							2 3 1074 0 1079 2339 0 0>;
-		fts,touch-edgezone-filter-ver = <1 0 0 0 0 0 0 0
-							1 1 0 0 0 0 0 0
-							1 2 0 0 40 2339 0 0
-							1 3 1039 0 1079 2339 0 0>;
-		fts,touch-edgezone-filter-hor = <1 0 0 0 1079 40 0 0
-							1 1 0 2299 1079 2339 0 0
-							1 2 0 0 40 2339 0 0
-							1 3 1039 0 1079 2339 0 0>;
-		fts,touch-cornerzone-filter-ver = <0 0 0 0 0 0 0 0
-							0 1 0 0 0 0 0 0
-							0 2 0 2039 150 2339 0 0
-							0 3 929 2039 1079 2339 0 0>;
-		fts,touch-cornerzone-filter-hor1 = <0 0 0 0 170 170 0 0
-							0 1 0 0 0 0 0 0
-							0 2 0 2169 170 2339 0 0
-							0 3 0 0 0 0 0 0>;
-		fts,touch-cornerzone-filter-hor2 = <0 0 0 0 0 0 0 0
-							0 1 909 0 1079 170 0 0
-							0 2 0 0 0 0 0 0
-							0 3 909 2169 1079 2339 0 0>;
+		fts,default-fw-name = "st_fts_j2_2.ftb";
+		fts,config-array-size = <1>;
 		fts,cfg_0 {
-			fts,tp-vendor = <0x38>;
-			fts,tp-module = <0>;
-			fts,fw-name = "st_fts_j2_1.ftb";
-			fts,limit-name = "stm_fts_production_limits_1.csv";
-		};
-		fts,cfg_1 {
-			fts,tp-vendor = <0x42>;
-			fts,tp-module = <1>;
+			fts,tp-vendor = <0x48>;
 			fts,fw-name = "st_fts_j2_2.ftb";
 			fts,limit-name = "stm_fts_production_limits_2.csv";
 		};
@@ -961,7 +943,7 @@ display_panel: panel@0 {
 		pinctrl-names = "default";
 		pinctrl-0 = <&panel_default>, <&te_default>;
 
-		status = "disabled";
+		status = "okay";
 
 		ports {
 			#address-cells = <1>;
@@ -1007,8 +989,9 @@ wifi@0 {
 
 &pcie2 {
 	status = "okay";
-	pinctrl-0 = <&pcie2_default_state>;
-	// &mdm2ap_default &ap2mdm_default &ap2mdm_active
+	pinctrl-0 = <&pcie2_default_state>, <&mdm2ap_default>, <&ap2mdm_default>, <&ap2mdm_active>, <&nfc_int_default>,
+                    <&nfc_ven_default>,
+                    <&nfc_clk_req_default>;
 };
 
 &pcie2_phy {
@@ -1161,10 +1144,10 @@ &rxmacro {
 	status = "okay";
 };
 
-&slpi {
-	status = "disabled";
-	firmware-name = "qcom/sm8250/umi/slpi.mbn";
-};
+// &slpi {
+// 	status = "okay";
+// 	firmware-name = "qcom/sm8250/umi/slpi.mbn";
+// };
 
 &sound {
 	status = "okay";
@@ -1172,27 +1155,25 @@ &sound {
 	model = "XIAOMI-UMI-WCD9380-CS35L41-VA-DMIC";
 	pinctrl-names = "default";
 	pinctrl-0 = <&tert_mi2s_active>;
+
 	audio-routing =
-		"SPK", "Main AMP",
+	    "L ASPRX1", 		"MM_DL1",
+		"L DSP RX1 Source", "L ASPRX1",
+		"L DSP1", 			"L DSP RX1 Source",
+		"L PCM Source", 	"L DSP1",
+	    "R ASPRX1", 		"MM_DL1",
+		"R DSP RX1 Source", "R ASPRX1",
+		"R DSP1", 			"R DSP RX1 Source",
+		"R PCM Source", 	"R DSP1",
 		"IN1_HPHL", "HPHL_OUT",
 		"IN2_HPHR", "HPHR_OUT",
 		"AMIC1", "MIC BIAS1",
 		"AMIC2", "MIC BIAS2",
 		"AMIC3", "MIC BIAS3",
-		"AMIC4", "MIC BIAS3",
 		"AMIC5", "MIC BIAS4",
-		"TX SWR_ADC0", "ADC1_OUTPUT",
-		"TX SWR_ADC1", "ADC2_OUTPUT",
-		"TX SWR_ADC2", "ADC3_OUTPUT",
-		"TX SWR_ADC3", "ADC4_OUTPUT",
-		"TX SWR_DMIC0", "DMIC1_OUTPUT",
-		"TX SWR_DMIC1", "DMIC2_OUTPUT",
-		"TX SWR_DMIC2", "DMIC3_OUTPUT",
-		"TX SWR_DMIC3", "DMIC4_OUTPUT",
-		"TX SWR_DMIC4", "DMIC5_OUTPUT",
-		"TX SWR_DMIC5", "DMIC6_OUTPUT",
-		"TX SWR_DMIC6", "DMIC7_OUTPUT",
-		"TX SWR_DMIC7", "DMIC8_OUTPUT";
+		"MM_DL1",  "MultiMedia1 Playback",
+		"MM_DL2",  "MultiMedia2 Playback",
+		"MultiMedia3 Capture", "MM_UL3";
 
 	mm1-dai-link {
 		link-name = "MultiMedia1";
@@ -1237,6 +1218,7 @@ cpu {
 		codec {
 			sound-dai = <&wcd938x 1>, <&swr2 0>, <&txmacro 0>;
 		};
+
 		platform {
 			sound-dai = <&q6routing>;
 		};
@@ -1253,31 +1235,39 @@ platform {
 		};
 
 		codec {
-			sound-dai = <&cs35l41_l 0>;//, <&cs35l41_r 0>;
+			sound-dai = <&cs35l41_l 0>, <&cs35l41_r 0>;
 		};
 	};
 
-	va-dai-link {
-		link-name = "VA Capture";
-		cpu {
-			sound-dai = <&q6afedai VA_CODEC_DMA_TX_0>;
-		};
+	// bt-slim-playback-dai-link {
+	// 	link-name = "Bluetooth Slimbus Playback";
+	// 	cpu {
+	// 		sound-dai = <&q6afedai SLIMBUS_0_TX>;
+	// 	};
 
-		platform {
-			sound-dai = <&q6routing>;
-		};
+	// 	platform {
+	// 		sound-dai = <&qca6390_bt 0>;
+	// 	};
 
-		codec {
-			sound-dai = <&vamacro 0>;
-		};
-	};
-};
+	// 	// codec {
+	// 	// 	sound-dai = <&qca6390_bt 0>;
+	// 	// };
+	// };
 
-&vamacro {
-	pinctrl-0 = <&dmic01_active>;
-	pinctrl-names = "default";
-	vdd-micb-supply = <&vreg_s4a_1p8>;
-	qcom,dmic-sample-rate = <600000>;
+	// bt-slim-capture-dai-link {
+	// 	link-name = "Bluetooth Slimbus Capture";
+	// 	cpu {
+	// 		sound-dai = <&q6afedai SLIMBUS_0_RX>;
+	// 	};
+
+	// 	platform {
+	// 		sound-dai = <&q6routing>;
+	// 	};
+		
+	// 	// codec {
+	// 	// 	sound-dai = <&qca6390_bt 0>;
+	// 	// };
+	// };
 };
 
 &q6afedai {
@@ -1319,13 +1309,19 @@ wcd_tx: wcd9380-tx@0,3 {
 	};
 };
 
-&tert_mi2s_active{
+&tert_mi2s_active {
+	/delete-node/ data0-pins;
+
+	ws-pins {
+		/delete-property/ output-high;
+	};
+
 	data1-pins {
 		pins = "gpio137";
 		function = "mi2s2_data1";
 		drive-strength = <8>;
 		bias-disable;
-		output-high;
+		// output-high;
 	};
 };
 
@@ -1346,32 +1342,33 @@ wcd938x_reset_sleep: wcd938x-reset-sleep-state {
 		bias-disable;
 		output-low;
 	};
-
-	ts_int_suspend: ts_int_suspend {
-		pins = "gpio39";
-		function = "gpio";
-		drive-strength = <2>;
-		bias-pull-down;
+	
+	bt_slim_active: bt-slim-active {
+		pins = "gpio142", "gpio143";
+		function = "lpass_slimbus";
+		drive-strength = <8>;
+		bias-disable;
 	};
 
-	ts_active: ts_active {
+	ts_active: ts_rst_active {
 		pins = "gpio38", "gpio39";
 		function = "gpio";
 		drive-strength = <8>;
 		bias-pull-up;
 	};
 
-	ts_reset_suspend: ts_reset_suspend {
-		pins = "gpio38";
+	ts_int_suspend: ts_int_suspend {
+		pins = "gpio39";
 		function = "gpio";
 		drive-strength = <2>;
 		bias-pull-down;
 	};
 
-	ts_release: ts_release {
-		pins = "gpio38", "gpio39";
+	ts_reset_suspend: ts_reset_suspend {
+		pins = "gpio38";
 		function = "gpio";
 		drive-strength = <2>;
+		bias-pull-down;
 	};
 
 	mdm2ap_default: mdm2ap-default-state {
@@ -1401,7 +1398,7 @@ bt_en_state: bt-default-state {
 		pins = "gpio21";
 		function = "gpio";
 		drive-strength = <16>;
-		output-low;
+		output-high;
 		bias-pull-up;
 	};
 
@@ -1426,20 +1423,43 @@ te_default: te-state {
 		drive-strength = <2>;
 		bias-pull-down;
 	};
+
+	nfc_clk_req_default: nfc-clk-req-default-state {
+		pins = "gpio7";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	nfc_ven_default: nfc-ven-default-state {
+		pins = "gpio83", "gpio110";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	nfc_int_default: nfc-int-default-state {
+		pins = "gpio111";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+		input-enable;
+	};
 };
 
 &uart6 {
 	status = "okay";
 
-	bluetooth {
+	qca6390_bt: bluetooth {
 		compatible = "qcom,qca6390-bt";
-
+		// When will it support btfm ?
+		// #sound-dai-cells = <0>;
 		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
 		vddaon-supply = <&vreg_pmu_aon_0p59>;
 		vddbtcmx-supply = <&vreg_pmu_btcmx_0p85>;
 		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
 		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
-		vddrfa1p7-supply = <&vreg_pmu_rfa_1p7>;
+		vddrfa1p7-supply = <&vreg_pmu_rfa_1p7>;		
 	};
 };
 
-- 
2.43.0


From 0487a76fa5d2ca198611b2fbf57bf39e856967da Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Mon, 2 Jun 2025 04:21:26 +0000
Subject: [PATCH 30/39] arm64: config: add new configs in q_defconfig. enabled
 ftsv521 and iris vpu decoder.

---
 arch/arm64/configs/q_defconfig | 72 +++++++++++++++++++++++++++-------
 1 file changed, 57 insertions(+), 15 deletions(-)

diff --git a/arch/arm64/configs/q_defconfig b/arch/arm64/configs/q_defconfig
index 0c97b696163e..dbe4b7105ebd 100644
--- a/arch/arm64/configs/q_defconfig
+++ b/arch/arm64/configs/q_defconfig
@@ -162,7 +162,6 @@ CONFIG_NFC_HCI=m
 CONFIG_NFC_SHDLC=y
 CONFIG_NFC_NXP_NCI=m
 CONFIG_NFC_NXP_NCI_I2C=m
-CONFIG_PAGE_POOL_STATS=y
 CONFIG_PCI=y
 CONFIG_PCIEPORTBUS=y
 CONFIG_PCIEAER=y
@@ -192,13 +191,11 @@ CONFIG_VEXPRESS_CONFIG=y
 CONFIG_MHI_BUS_PCI_GENERIC=m
 CONFIG_ARM_SCMI_PROTOCOL=y
 CONFIG_IMX_SCMI_BBM_EXT=y
-CONFIG_IMX_SCMI_MISC_EXT=y
 CONFIG_ARM_SCPI_PROTOCOL=y
 CONFIG_GOOGLE_FIRMWARE=y
 CONFIG_GOOGLE_CBMEM=m
 CONFIG_GOOGLE_COREBOOT_TABLE=m
 CONFIG_EFI_CAPSULE_LOADER=y
-CONFIG_IMX_SCMI_MISC_DRV=y
 CONFIG_QCOM_TZMEM_MODE_SHMBRIDGE=y
 CONFIG_QCOM_QSEECOM=y
 CONFIG_QCOM_QSEECOM_UEFISECAPP=y
@@ -367,6 +364,8 @@ CONFIG_JOYSTICK_PSXPAD_SPI=m
 CONFIG_JOYSTICK_PSXPAD_SPI_FF=y
 CONFIG_JOYSTICK_PXRC=y
 CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ST_FTS=y
+CONFIG_TOUCHSCREEN_ST_DEBUG_FS=y
 CONFIG_TOUCHSCREEN_GOODIX=m
 CONFIG_TOUCHSCREEN_GOODIX_BERLIN_I2C=m
 CONFIG_TOUCHSCREEN_GOODIX_BERLIN_SPI=m
@@ -425,7 +424,6 @@ CONFIG_TCG_TIS_I2C_CR50=m
 CONFIG_TCG_TIS_I2C_INFINEON=y
 CONFIG_I2C_CHARDEV=y
 CONFIG_I2C_MUX=y
-CONFIG_I2C_MUX_PCA954x=y
 CONFIG_I2C_CADENCE=m
 CONFIG_I2C_DESIGNWARE_CORE=y
 CONFIG_I2C_GPIO=m
@@ -498,6 +496,7 @@ CONFIG_PINCTRL_SM8450_LPASS_LPI=m
 CONFIG_PINCTRL_SC8280XP_LPASS_LPI=m
 CONFIG_PINCTRL_SM8550_LPASS_LPI=m
 CONFIG_PINCTRL_SM8650_LPASS_LPI=m
+CONFIG_GPIO_SYSFS=y
 CONFIG_GPIO_ALTERA=m
 CONFIG_GPIO_DWAPB=y
 CONFIG_GPIO_MB86S7X=y
@@ -583,8 +582,46 @@ CONFIG_REGULATOR_QCOM_USB_VBUS=m
 CONFIG_REGULATOR_RAA215300=y
 CONFIG_REGULATOR_RK808=y
 CONFIG_REGULATOR_S2MPS11=y
+CONFIG_REGULATOR_SGM3804=m
 CONFIG_REGULATOR_TPS65132=m
 CONFIG_REGULATOR_VCTRL=m
+CONFIG_RC_CORE=m
+CONFIG_LIRC=y
+CONFIG_RC_DECODERS=y
+CONFIG_IR_IMON_DECODER=m
+CONFIG_IR_JVC_DECODER=m
+CONFIG_IR_MCE_KBD_DECODER=m
+CONFIG_IR_NEC_DECODER=m
+CONFIG_IR_RC5_DECODER=m
+CONFIG_IR_RC6_DECODER=m
+CONFIG_IR_RCMM_DECODER=m
+CONFIG_IR_SANYO_DECODER=m
+CONFIG_IR_SHARP_DECODER=m
+CONFIG_IR_SONY_DECODER=m
+CONFIG_IR_XMP_DECODER=m
+CONFIG_RC_DEVICES=y
+CONFIG_IR_ENE=m
+CONFIG_IR_FINTEK=m
+CONFIG_IR_GPIO_CIR=m
+CONFIG_IR_GPIO_TX=m
+CONFIG_IR_HIX5HD2=m
+CONFIG_IR_IGORPLUGUSB=m
+CONFIG_IR_IGUANA=m
+CONFIG_IR_IMON=m
+CONFIG_IR_IMON_RAW=m
+CONFIG_IR_ITE_CIR=m
+CONFIG_IR_MCEUSB=m
+CONFIG_IR_NUVOTON=m
+CONFIG_IR_REDRAT3=m
+CONFIG_IR_SERIAL=m
+CONFIG_IR_SERIAL_TRANSMITTER=y
+CONFIG_IR_SPI=m
+CONFIG_IR_STREAMZAP=m
+CONFIG_IR_TOY=m
+CONFIG_IR_TTUSBIR=m
+CONFIG_RC_ATI_REMOTE=m
+CONFIG_RC_LOOPBACK=m
+CONFIG_RC_XBOX_DVD=m
 CONFIG_MEDIA_CEC_SUPPORT=y
 CONFIG_MEDIA_SUPPORT=m
 CONFIG_MEDIA_SUPPORT_FILTER=y
@@ -601,6 +638,7 @@ CONFIG_SDR_PLATFORM_DRIVERS=y
 CONFIG_V4L_MEM2MEM_DRIVERS=y
 CONFIG_VIDEO_CADENCE_CSI2RX=m
 CONFIG_VIDEO_QCOM_CAMSS=m
+CONFIG_VIDEO_QCOM_IRIS=m
 CONFIG_VIDEO_QCOM_VENUS=m
 CONFIG_VIDEO_IMX219=m
 CONFIG_VIDEO_IMX412=m
@@ -609,15 +647,13 @@ CONFIG_VIDEO_OV5645=m
 CONFIG_DRM=y
 CONFIG_DRM_DISPLAY_DP_AUX_CEC=y
 CONFIG_DRM_DISPLAY_DP_AUX_CHARDEV=y
-CONFIG_DRM_I2C_CH7006=m
-CONFIG_DRM_I2C_SIL164=m
-CONFIG_DRM_I2C_NXP_TDA998X=m
 CONFIG_DRM_MSM=m
 CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=m
 CONFIG_DRM_PANEL_DSI_CM=m
 CONFIG_DRM_PANEL_LVDS=m
 CONFIG_DRM_PANEL_CSOT_MP42020B=m
 CONFIG_DRM_PANEL_LG_SW43103=m
+CONFIG_DRM_PANEL_LG_SW43408=m
 CONFIG_DRM_PANEL_EDP=m
 CONFIG_DRM_PANEL_SIMPLE=m
 CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA=m
@@ -626,6 +662,7 @@ CONFIG_DRM_PANEL_VISIONOX_RM69299=m
 CONFIG_DRM_PANEL_VISIONOX_VTDR6130=m
 CONFIG_DRM_PANEL_AYANEO_WT0600_2K=m
 CONFIG_DRM_DISPLAY_CONNECTOR=m
+CONFIG_DRM_I2C_NXP_TDA998X=m
 CONFIG_DRM_LONTIUM_LT8912B=m
 CONFIG_DRM_LONTIUM_LT9611=m
 CONFIG_DRM_LONTIUM_LT9611UXC=m
@@ -651,7 +688,7 @@ CONFIG_FB_EFI=y
 CONFIG_FB_MODE_HELPERS=y
 CONFIG_BACKLIGHT_CLASS_DEVICE=m
 CONFIG_BACKLIGHT_KTZ8866=m
-CONFIG_BACKLIGHT_SY7758VGS=m
+CONFIG_BACKLIGHT_SY7758=m
 CONFIG_BACKLIGHT_PWM=m
 CONFIG_BACKLIGHT_QCOM_WLED=m
 CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
@@ -660,6 +697,10 @@ CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_VGA16 is not set
 CONFIG_SOUND=y
 CONFIG_SND=y
+CONFIG_SND_DEBUG=y
+CONFIG_SND_DEBUG_VERBOSE=y
+CONFIG_SND_PCM_XRUN_DEBUG=y
+CONFIG_SND_JACK_INJECTION_DEBUG=y
 CONFIG_SND_ALOOP=m
 # CONFIG_SND_PCI is not set
 CONFIG_SND_SOC=y
@@ -672,6 +713,7 @@ CONFIG_SND_SOC_FSL_ESAI=m
 CONFIG_SND_SOC_FSL_MICFIL=m
 CONFIG_SND_SOC_FSL_EASRC=m
 CONFIG_SND_SOC_IMX_AUDMUX=m
+CONFIG_SND_SOC_MTK_BTCVSD=m
 CONFIG_SND_SOC_QCOM=m
 CONFIG_SND_SOC_STORM=m
 CONFIG_SND_SOC_APQ8016_SBC=m
@@ -706,6 +748,7 @@ CONFIG_SND_SOC_LPASS_VA_MACRO=m
 CONFIG_SND_SIMPLE_CARD=m
 CONFIG_SND_AUDIO_GRAPH_CARD=m
 CONFIG_SND_AUDIO_GRAPH_CARD2=m
+CONFIG_SND_AUDIO_GRAPH_CARD2_CUSTOM_SAMPLE=m
 CONFIG_HID_A4TECH=y
 CONFIG_HID_APPLE=y
 CONFIG_HID_BELKIN=y
@@ -715,7 +758,7 @@ CONFIG_HID_CYPRESS=y
 CONFIG_HID_EZKEY=y
 CONFIG_HID_ITE=y
 CONFIG_HID_KENSINGTON=y
-CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH=m
 CONFIG_HID_REDRAGON=y
 CONFIG_HID_MICROSOFT=y
 CONFIG_HID_MONTEREY=y
@@ -841,7 +884,6 @@ CONFIG_SCSI_UFSHCD=y
 CONFIG_SCSI_UFS_BSG=y
 CONFIG_SCSI_UFSHCD_PLATFORM=y
 CONFIG_SCSI_UFS_QCOM=y
-CONFIG_NEW_LEDS=y
 CONFIG_LEDS_CLASS=y
 CONFIG_LEDS_CLASS_MULTICOLOR=m
 CONFIG_LEDS_LM3692X=m
@@ -1008,6 +1050,7 @@ CONFIG_REMOTEPROC=y
 CONFIG_QCOM_Q6V5_ADSP=m
 CONFIG_QCOM_Q6V5_MSS=m
 CONFIG_QCOM_Q6V5_PAS=m
+CONFIG_QCOM_Q6V5_WCSS=m
 CONFIG_QCOM_SYSMON=m
 CONFIG_QCOM_WCNSS_PIL=m
 CONFIG_RPMSG_CHAR=m
@@ -1158,7 +1201,10 @@ CONFIG_SQUASHFS_LZ4=y
 CONFIG_SQUASHFS_LZO=y
 CONFIG_SQUASHFS_XZ=y
 CONFIG_SQUASHFS_ZSTD=y
-CONFIG_PSTORE_RAM=m
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_PMSG=y
+CONFIG_PSTORE_RAM=y
+CONFIG_EROFS_FS=m
 CONFIG_NFS_FS=y
 CONFIG_NFS_V4=y
 CONFIG_NFS_V4_1=y
@@ -1169,7 +1215,6 @@ CONFIG_NLS_CODEPAGE_437=y
 CONFIG_NLS_ISO8859_1=y
 CONFIG_SECURITY=y
 CONFIG_CRYPTO_USER=y
-CONFIG_CRYPTO_TEST=m
 CONFIG_CRYPTO_DES=m
 CONFIG_CRYPTO_ECHAINIV=y
 CONFIG_CRYPTO_BLAKE2B=m
@@ -1178,10 +1223,8 @@ CONFIG_CRYPTO_DEFLATE=m
 CONFIG_CRYPTO_ZSTD=m
 CONFIG_CRYPTO_ANSI_CPRNG=y
 CONFIG_CRYPTO_USER_API_RNG=m
-CONFIG_CRYPTO_CHACHA20_NEON=m
 CONFIG_CRYPTO_GHASH_ARM64_CE=y
 CONFIG_CRYPTO_SHA1_ARM64_CE=y
-CONFIG_CRYPTO_SHA2_ARM64_CE=y
 CONFIG_CRYPTO_SHA512_ARM64_CE=m
 CONFIG_CRYPTO_SHA3_ARM64=m
 CONFIG_CRYPTO_SM3_ARM64_CE=m
@@ -1205,7 +1248,6 @@ CONFIG_DEBUG_INFO_REDUCED=y
 CONFIG_MAGIC_SYSRQ=y
 CONFIG_DEBUG_FS=y
 CONFIG_DEBUG_MEMORY_INIT=y
-# CONFIG_SCHED_DEBUG is not set
 # CONFIG_FTRACE is not set
 CONFIG_TEST_KALLSYMS=m
 CONFIG_MEMTEST=y
-- 
2.43.0


From 1599eb8691c9353d48e202a737849cfef1b842f2 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Thu, 5 Jun 2025 04:04:33 +0000
Subject: [PATCH 32/39] regulator: add sgm3804 i2c regulator for panel power
 management.

---
 drivers/regulator/Kconfig             |   6 +
 drivers/regulator/Makefile            |   1 +
 drivers/regulator/sgm3804-regulator.c | 175 ++++++++++++++++++++++++++
 3 files changed, 182 insertions(+)
 create mode 100644 drivers/regulator/sgm3804-regulator.c

diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 6d8988387da4..569de22f2cdb 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -1452,6 +1452,12 @@ config REGULATOR_SUN20I
 	help
 	  This driver supports the internal LDOs in the Allwinner D1 SoC.
 
+config REGULATOR_SGM3804
+	tristate "SGMicro sgm3804 voltage regulator"
+	depends on I2C && OF
+	help
+	  This driver supports SGMicro sgm3804 voltage regulator.
+
 config REGULATOR_SY7636A
 	tristate "Silergy SY7636A voltage regulator"
 	depends on MFD_SY7636A
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index c0bc7a0f4e67..642f84156a4c 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -167,6 +167,7 @@ obj-$(CONFIG_REGULATOR_STM32_PWR) += stm32-pwr.o
 obj-$(CONFIG_REGULATOR_STPMIC1) += stpmic1_regulator.o
 obj-$(CONFIG_REGULATOR_STW481X_VMMC) += stw481x-vmmc.o
 obj-$(CONFIG_REGULATOR_SUN20I) += sun20i-regulator.o
+obj-$(CONFIG_REGULATOR_SGM3804) += sgm3804-regulator.o
 obj-$(CONFIG_REGULATOR_SY7636A) += sy7636a-regulator.o
 obj-$(CONFIG_REGULATOR_SY8106A) += sy8106a-regulator.o
 obj-$(CONFIG_REGULATOR_SY8824X) += sy8824x.o
diff --git a/drivers/regulator/sgm3804-regulator.c b/drivers/regulator/sgm3804-regulator.c
new file mode 100644
index 000000000000..f550ce190a0b
--- /dev/null
+++ b/drivers/regulator/sgm3804-regulator.c
@@ -0,0 +1,175 @@
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/gpio/consumer.h>
+
+struct sgm3804_data {
+    struct regmap *regmap;
+    struct gpio_desc *reset_gpio[2];
+    bool enabled;
+};
+
+static const struct regmap_config sgm3804_regmap_config = {
+    .reg_bits = 8,
+    .val_bits = 8,
+    .max_register = 0x03,
+};
+
+static int sgm3804_enable(struct regulator_dev *rdev)
+{
+    struct sgm3804_data *data = rdev_get_drvdata(rdev);
+    struct regmap *regmap = data->regmap;
+    int ret;
+
+    pr_info("sgm3804_enable: called\n");
+
+    /* Set reset GPIO high to enable the device if available */
+    if (data->reset_gpio[0]) {
+        gpiod_set_value_cansleep(data->reset_gpio[0], 1);
+    }
+    if (data->reset_gpio[1]) {
+        gpiod_set_value_cansleep(data->reset_gpio[1], 1);
+    }
+
+    ret = regmap_write(regmap, 0x00, 0x0c);
+    if (ret) {
+        pr_err("sgm3804_enable: regmap_write 0x00 failed: %d\n", ret);
+        return ret;
+    }
+
+    ret = regmap_write(regmap, 0x01, 0x0c);
+    if (ret) {
+        pr_err("sgm3804_enable: regmap_write 0x01 failed: %d\n", ret);
+        return ret;
+    }
+
+    ret = regmap_write(regmap, 0x03, 0x03);
+    if (ret) {
+        pr_err("sgm3804_enable: regmap_write 0x03 failed: %d\n", ret);
+        return ret;
+    }
+
+    pr_info("sgm3804_enable: success\n");
+    data->enabled = true;
+    return 0;
+}
+
+static int sgm3804_disable(struct regulator_dev *rdev)
+{
+    struct sgm3804_data *data = rdev_get_drvdata(rdev);
+
+    pr_info("sgm3804_disable: called\n");
+
+    if (data->reset_gpio[0]) {
+        gpiod_set_value_cansleep(data->reset_gpio[0], 0);
+    }
+    if (data->reset_gpio[1]) {
+        gpiod_set_value_cansleep(data->reset_gpio[1], 0);
+    }
+
+    pr_info("sgm3804_disable: success\n");
+    data->enabled = false;
+    return 0;
+}
+
+static int sgm3804_is_enabled(struct regulator_dev *rdev)
+{
+    struct sgm3804_data *data = rdev_get_drvdata(rdev);
+    return data->enabled;
+}
+
+static int sgm3804_get_voltage(struct regulator_dev *rdev)
+{
+    return 5000000;  // 5V
+}
+
+static const struct regulator_ops sgm3804_ops = {
+    .enable = sgm3804_enable,
+    .disable = sgm3804_disable,
+    .is_enabled = sgm3804_is_enabled,
+    .get_voltage = sgm3804_get_voltage,
+};
+
+static const struct regulator_desc sgm3804_reg = {
+    .name = "SGM3804",
+    .id = 0,
+    .ops = &sgm3804_ops,
+    .type = REGULATOR_VOLTAGE,
+    .n_voltages = 1,
+    .min_uV = 5000000,
+    .owner = THIS_MODULE,
+};
+
+static int sgm3804_i2c_probe(struct i2c_client *i2c)
+{
+    struct device *dev = &i2c->dev;
+    struct regulator_config config = { };
+    struct regulator_dev *rdev;
+    struct sgm3804_data *data;
+    int error;
+
+    data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+    if (!data)
+        return -ENOMEM;
+
+    data->regmap = devm_regmap_init_i2c(i2c, &sgm3804_regmap_config);
+    if (IS_ERR(data->regmap))
+        return dev_err_probe(dev, PTR_ERR(data->regmap), "failed to init regmap\n");
+
+    /* Get reset-gpio from device tree */
+    data->reset_gpio[0] = devm_gpiod_get_index(dev, "reset", 0, GPIOD_OUT_HIGH);
+    if (IS_ERR(data->reset_gpio[0]))
+        return dev_err_probe(dev, PTR_ERR(data->reset_gpio[0]), "failed to get first reset GPIO\n");
+
+    data->reset_gpio[1] = devm_gpiod_get_index(dev, "reset", 1, GPIOD_OUT_HIGH);
+    if (IS_ERR(data->reset_gpio[1]))
+        dev_warn(dev, "failed to get second reset GPIO\n");
+
+    config.dev = dev;
+    config.regmap = data->regmap;
+    config.driver_data = data;
+    config.of_node = dev->of_node;
+    config.init_data = of_get_regulator_init_data(dev, dev->of_node, &sgm3804_reg);
+    if (!config.init_data)
+        return -ENOMEM;
+    data->enabled = false;
+    rdev = devm_regulator_register(dev, &sgm3804_reg, &config);
+    if (IS_ERR(rdev)) {
+        error = PTR_ERR(rdev);
+        dev_err(dev, "Failed to register SGM3804 regulator: %d\n", error);
+        return error;
+    }
+
+    return 0;
+}
+
+static const struct i2c_device_id sgm3804_i2c_id[] = {
+    { "sgm3804" },
+    { }
+};
+MODULE_DEVICE_TABLE(i2c, sgm3804_i2c_id);
+
+static const struct of_device_id sgm3804_i2c_of_match[] = {
+    { .compatible = "sgmicro,sgm3804" },
+    { }
+};
+MODULE_DEVICE_TABLE(of, sgm3804_i2c_of_match);
+
+static struct i2c_driver sgm3804_regulator_driver = {
+    .driver = {
+        .name = "sgm3804",
+        .probe_type = PROBE_PREFER_ASYNCHRONOUS,
+        .of_match_table = sgm3804_i2c_of_match,
+    },
+    .probe = sgm3804_i2c_probe,
+    .id_table = sgm3804_i2c_id,
+};
+
+module_i2c_driver(sgm3804_regulator_driver);
+
+MODULE_DESCRIPTION("SGMicro sgm3804 regulator Driver");
+MODULE_AUTHOR("Kancy Joe <kancy2333@outlook.com>");
+MODULE_LICENSE("GPL");
\ No newline at end of file
-- 
2.43.0


From 8088946d1702b74a91c0ae5fe001a0965b204a15 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Thu, 5 Jun 2025 04:05:43 +0000
Subject: [PATCH 33/39] video: backlight: rename sy7758vgs to sy7758 and
 simplify sy7758 initialization.

---
 drivers/video/backlight/Kconfig     |   6 +-
 drivers/video/backlight/Makefile    |   2 +-
 drivers/video/backlight/sy7758.c    | 167 +++++++++++++++++++++
 drivers/video/backlight/sy7758vgs.c | 220 ----------------------------
 4 files changed, 171 insertions(+), 224 deletions(-)
 create mode 100644 drivers/video/backlight/sy7758.c
 delete mode 100644 drivers/video/backlight/sy7758vgs.c

diff --git a/drivers/video/backlight/Kconfig b/drivers/video/backlight/Kconfig
index 0e79e1b40ad2..8109f4043a3b 100644
--- a/drivers/video/backlight/Kconfig
+++ b/drivers/video/backlight/Kconfig
@@ -198,12 +198,12 @@ config BACKLIGHT_KTZ8866
 		Say Y to enable the backlight driver for the Kinetic KTZ8866
 		found in Xiaomi Mi Pad 5 series.
 
-config BACKLIGHT_SY7758VGS
-	tristate "Backlight Driver for Silergy SY7758VGS"
+config BACKLIGHT_SY7758
+	tristate "Backlight Driver for Silergy SY7758"
 	depends on I2C
 	select REGMAP_I2C
 	help
-		Say Y to enable the backlight driver for the Silergy SY7758VGS
+		Say Y to enable the backlight driver for the Silergy SY7758
 		backlight controller found in ayaneo pocket s.
 
 config BACKLIGHT_LM3533
diff --git a/drivers/video/backlight/Makefile b/drivers/video/backlight/Makefile
index 712b22b071bf..c81f00f85aac 100644
--- a/drivers/video/backlight/Makefile
+++ b/drivers/video/backlight/Makefile
@@ -54,7 +54,7 @@ obj-$(CONFIG_BACKLIGHT_PWM)		+= pwm_bl.o
 obj-$(CONFIG_BACKLIGHT_QCOM_WLED)	+= qcom-wled.o
 obj-$(CONFIG_BACKLIGHT_RT4831)		+= rt4831-backlight.o
 obj-$(CONFIG_BACKLIGHT_SAHARA)		+= kb3886_bl.o
-obj-$(CONFIG_BACKLIGHT_SY7758VGS)	+= sy7758vgs.o
+obj-$(CONFIG_BACKLIGHT_SY7758)		+= sy7758.o
 obj-$(CONFIG_BACKLIGHT_SKY81452)	+= sky81452-backlight.o
 obj-$(CONFIG_BACKLIGHT_TPS65217)	+= tps65217_bl.o
 obj-$(CONFIG_BACKLIGHT_WM831X)		+= wm831x_bl.o
diff --git a/drivers/video/backlight/sy7758.c b/drivers/video/backlight/sy7758.c
new file mode 100644
index 000000000000..452164edee53
--- /dev/null
+++ b/drivers/video/backlight/sy7758.c
@@ -0,0 +1,167 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Backlight driver for the Silergy sy7758
+ *
+ * Copyright (C) 2025 Kancy Joe <kancy2333@outlook.com>
+ */
+
+#include <linux/backlight.h>
+#include <linux/err.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+
+#define DEFAULT_BRIGHTNESS 1500
+#define MAX_BRIGHTNESS 4080
+#define REG_MAX 0xa9
+
+/* reg */
+#define BL_BRT_L 0x10
+#define BL_BRT_H 0x11
+
+static DEFINE_MUTEX(sy7758_update_backlight_mutex);
+
+struct sy7758 {
+	struct i2c_client *client;
+	struct regmap *regmap;
+	bool led_on;
+};
+
+static void sy7758_init(struct sy7758 *sydev);
+
+static const struct regmap_config sy7758_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = REG_MAX,
+};
+
+static int sy7758_write(struct sy7758 *sydev, unsigned int reg,
+			 unsigned int val)
+{
+	return regmap_write(sydev->regmap, reg, val);
+}
+
+static int sy7758_backlight_update_status(struct backlight_device *backlight_dev)
+{
+	struct sy7758 *sydev = bl_get_data(backlight_dev);
+	unsigned int brightness = backlight_get_brightness(backlight_dev);
+	mutex_lock(&sy7758_update_backlight_mutex);
+
+	if (!sydev->led_on && brightness > 0) {
+		// Init
+		sy7758_init(sydev);
+		sydev->led_on = true;
+	} else if (brightness == 0) {
+		sydev->led_on = false;
+	}
+
+	/* Set brightness */
+	sy7758_write(sydev, BL_BRT_L, brightness & 0xf0);
+	sy7758_write(sydev, BL_BRT_H, (brightness >> 8) & 0xf);
+
+	mutex_unlock(&sy7758_update_backlight_mutex);
+	return 0;
+}
+
+static const struct backlight_ops sy7758_backlight_ops = {
+	.options = BL_CORE_SUSPENDRESUME,
+	.update_status = sy7758_backlight_update_status,
+};
+
+static void sy7758_init(struct sy7758 *sydev)
+{
+	sy7758_write(sydev, 0x01, 0x85);
+	sy7758_write(sydev, 0x10, 0x00);
+	sy7758_write(sydev, 0x11, 0x00);
+	sy7758_write(sydev, 0xa5, 0x64);
+	sy7758_write(sydev, 0xa0, 0x55);
+	sy7758_write(sydev, 0xa1, 0x9a);
+	sy7758_write(sydev, 0xa9, 0x80);
+	sy7758_write(sydev, 0xa2, 0x28);
+
+	
+	sy7758_write(sydev, 0x10, 0x40);
+	sy7758_write(sydev, 0x11, 0x01);
+	// Max brightness
+	// 0x10: 0xf0 Low
+	// 0x11: 0x0f High
+
+	// Min brightness
+	// 0x10: 0x10  Low
+	// 0x11: 0x00  High
+	sydev->led_on = true;
+}
+
+static int sy7758_probe(struct i2c_client *client)
+{
+	struct backlight_device *backlight_dev;
+	struct backlight_properties props;
+	struct sy7758 *sydev;
+
+	sydev = devm_kzalloc(&client->dev, sizeof(*sydev), GFP_KERNEL);
+	if (!sydev)
+		return -ENOMEM;
+
+	sydev->client = client;
+	sydev->regmap = devm_regmap_init_i2c(client, &sy7758_regmap_config);
+	if (IS_ERR(sydev->regmap))
+		return dev_err_probe(&client->dev, PTR_ERR(sydev->regmap), "failed to init regmap\n");
+
+	memset(&props, 0, sizeof(props));
+	props.type = BACKLIGHT_RAW;
+	props.max_brightness = MAX_BRIGHTNESS;
+	props.brightness = DEFAULT_BRIGHTNESS;
+	props.scale = BACKLIGHT_SCALE_LINEAR;
+
+	backlight_dev = devm_backlight_device_register(&client->dev, "sy7758-backlight",
+					&client->dev, sydev, &sy7758_backlight_ops, &props);
+	if (IS_ERR(backlight_dev))
+		return dev_err_probe(&client->dev, PTR_ERR(backlight_dev),
+				"failed to register backlight device\n");
+
+	sy7758_init(sydev);
+
+	i2c_set_clientdata(client, backlight_dev);
+	backlight_update_status(backlight_dev);
+
+	return 0;
+}
+
+static void sy7758_remove(struct i2c_client *client)
+{
+	struct backlight_device *backlight_dev = i2c_get_clientdata(client);
+	backlight_dev->props.brightness = 0;
+	backlight_update_status(backlight_dev);
+}
+
+static const struct i2c_device_id sy7758_ids[] = {
+	{ "sy7758" },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, sy7758_ids);
+
+static const struct of_device_id sy7758_match_table[] = {
+	{
+		.compatible = "silergy,sy7758",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, sy7758_match_table);
+
+static struct i2c_driver sy7758_driver = {
+	.driver = {
+		.name = "sy7758",
+		.of_match_table = sy7758_match_table,
+	},
+	.probe = sy7758_probe,
+	.remove = sy7758_remove,
+	.id_table = sy7758_ids,
+};
+
+module_i2c_driver(sy7758_driver);
+
+MODULE_DESCRIPTION("Silergy sy7758 Backlight Driver");
+MODULE_AUTHOR("Kancy Joe <kancy2333@outlook.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/backlight/sy7758vgs.c b/drivers/video/backlight/sy7758vgs.c
deleted file mode 100644
index a3dcf8d57d22..000000000000
--- a/drivers/video/backlight/sy7758vgs.c
+++ /dev/null
@@ -1,220 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Backlight driver for the Silergy sy7758vgs
- *
- * Copyright (C) 2025 Kancy Joe <kancy2333@outlook.com>
- */
-
-#include <linux/backlight.h>
-#include <linux/err.h>
-#include <linux/gpio/consumer.h>
-#include <linux/i2c.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/regmap.h>
-
-#define DEFAULT_BRIGHTNESS 1500
-#define MAX_BRIGHTNESS 4080
-#define REG_MAX 0xa9
-
-/* reg */
-#define BL_BRT_L 0x10
-#define BL_BRT_H 0x11
-
-struct sy7758vgs {
-	struct i2c_client *client;
-	struct regmap *regmap;
-	bool led_on;
-};
-
-static void sy7758vgs_init(struct sy7758vgs *sydev);
-
-static const struct regmap_config sy7758vgs_regmap_config = {
-	.reg_bits = 8,
-	.val_bits = 8,
-	.max_register = REG_MAX,
-};
-
-static int sy7758vgs_write(struct sy7758vgs *sydev, unsigned int reg,
-			 unsigned int val)
-{
-	return regmap_write(sydev->regmap, reg, val);
-}
-
-static int sy7758vgs_read(struct sy7758vgs *sydev, unsigned int reg,
-			 unsigned int *val)
-{
-	return regmap_read(sydev->regmap, reg, val);
-}
-
-static int sy7758vgs_backlight_update_status(struct backlight_device *backlight_dev)
-{
-	struct sy7758vgs *sydev = bl_get_data(backlight_dev);
-	unsigned int brightness = backlight_get_brightness(backlight_dev);
-
-	if (!sydev->led_on && brightness > 0) {
-		// Init
-		sy7758vgs_init(sydev);
-		sydev->led_on = true;
-	} else if (brightness == 0) {
-		sydev->led_on = false;
-	}
-
-	/* Set brightness */
-	sy7758vgs_write(sydev, BL_BRT_L, brightness & 0xf0);
-	sy7758vgs_write(sydev, BL_BRT_H, (brightness >> 8) & 0xf);
-
-	return 0;
-}
-
-static const struct backlight_ops sy7758vgs_backlight_ops = {
-	.options = BL_CORE_SUSPENDRESUME,
-	.update_status = sy7758vgs_backlight_update_status,
-};
-
-static void sy7758vgs_init(struct sy7758vgs *sydev)
-{
-	unsigned int val = 0;
-	sydev->led_on = true;
-
-    sy7758vgs_read(sydev, 0x03, &val);
-    if(val != 0x63)
-		pr_warn("no.1 sy7758vgs init 0x63\n");
-
-	sy7758vgs_read(sydev, 0x01, &val);
-	if(val != 0x01)
-		pr_warn("no.2 sy7758vgs init 0x01\n");
-
-	sy7758vgs_read(sydev, 0xa5, &val);
-	if(val != 0x00)
-		pr_warn("no.3 sy7758vgs init 0x00\n");
-
-	sy7758vgs_write(sydev, 0x01, 0x85);
-	sy7758vgs_write(sydev, 0x10, 0x00);
-	sy7758vgs_write(sydev, 0x11, 0x00);
-	sy7758vgs_write(sydev, 0xa5, 0x64);
-	sy7758vgs_write(sydev, 0xa0, 0x55);
-	sy7758vgs_write(sydev, 0xa1, 0x9a);
-	sy7758vgs_write(sydev, 0xa9, 0x80);
-	sy7758vgs_write(sydev, 0xa2, 0x28);
-
-	sy7758vgs_read(sydev, 0x01, &val);
-	if(val != 0x85)
-		pr_warn("no.4 sy7758vgs init 0x85\n");
-
-	sy7758vgs_read(sydev, 0x10, &val);
-	if(val != 0x00)
-		pr_warn("no.5 sy7758vgs init 0x00\n");
-
-	sy7758vgs_read(sydev, 0x11, &val);
-	if(val != 0x00)
-		pr_warn("no.6 sy7758vgs init 0x00\n");
-
-	sy7758vgs_read(sydev, 0xa5, &val);
-	if(val != 0x64)
-		pr_warn("no.7 sy7758vgs init 0x64\n");
-
-	sy7758vgs_read(sydev, 0xa0, &val);
-	if(val != 0x55)
-		pr_warn("no.8 sy7758vgs init 0x55\n");
-
-	sy7758vgs_read(sydev, 0xa1, &val);
-	if(val != 0x9a)
-		pr_warn("no.9 sy7758vgs init 0x9a\n");
-
-	sy7758vgs_read(sydev, 0xa2, &val);
-	if(val != 0x28)
-		pr_warn("no.10 sy7758vgs init 0x28\n");
-
-	sy7758vgs_read(sydev, 0xa9, &val);
-	if(val != 0x80)
-		pr_warn("no.11 sy7758vgs init 0x80\n");
-
-	sy7758vgs_read(sydev, 0x02, &val);
-	if(val != 0x3c)
-		pr_warn("no.12 sy7758vgs init 0x3c\n");
-
-	sy7758vgs_write(sydev, 0x10, 0x00);
-	sy7758vgs_write(sydev, 0x11, 0x00);
-	sy7758vgs_write(sydev, 0x10, 0x80);
-	sy7758vgs_write(sydev, 0x11, 0x02);
-	// Max brightness
-	// 0x10: 0xf0 Low
-	// 0x11: 0x0f High
-
-	// Min brightness
-	// 0x10: 0x10  Low
-	// 0x11: 0x00  High
-}
-
-static int sy7758vgs_probe(struct i2c_client *client)
-{
-	struct backlight_device *backlight_dev;
-	struct backlight_properties props;
-	struct sy7758vgs *sydev;
-
-	sydev = devm_kzalloc(&client->dev, sizeof(*sydev), GFP_KERNEL);
-	if (!sydev)
-		return -ENOMEM;
-
-	sydev->client = client;
-	sydev->regmap = devm_regmap_init_i2c(client, &sy7758vgs_regmap_config);
-	if (IS_ERR(sydev->regmap))
-		return dev_err_probe(&client->dev, PTR_ERR(sydev->regmap), "failed to init regmap\n");
-
-	memset(&props, 0, sizeof(props));
-	props.type = BACKLIGHT_RAW;
-	props.max_brightness = MAX_BRIGHTNESS;
-	props.brightness = DEFAULT_BRIGHTNESS;
-	props.scale = BACKLIGHT_SCALE_LINEAR;
-
-	backlight_dev = devm_backlight_device_register(&client->dev, "sy7758vgs-backlight",
-					&client->dev, sydev, &sy7758vgs_backlight_ops, &props);
-	if (IS_ERR(backlight_dev))
-		return dev_err_probe(&client->dev, PTR_ERR(backlight_dev),
-				"failed to register backlight device\n");
-
-	sy7758vgs_init(sydev);
-
-	i2c_set_clientdata(client, backlight_dev);
-	backlight_update_status(backlight_dev);
-
-	return 0;
-}
-
-static void sy7758vgs_remove(struct i2c_client *client)
-{
-	struct backlight_device *backlight_dev = i2c_get_clientdata(client);
-	backlight_dev->props.brightness = 0;
-	backlight_update_status(backlight_dev);
-}
-
-static const struct i2c_device_id sy7758vgs_ids[] = {
-	{ "sy7758vgs" },
-	{}
-};
-MODULE_DEVICE_TABLE(i2c, sy7758vgs_ids);
-
-static const struct of_device_id sy7758vgs_match_table[] = {
-	{
-		.compatible = "silergy,sy7758vgs",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, sy7758vgs_match_table);
-
-static struct i2c_driver sy7758vgs_driver = {
-	.driver = {
-		.name = "sy7758vgs",
-		.of_match_table = sy7758vgs_match_table,
-	},
-	.probe = sy7758vgs_probe,
-	.remove = sy7758vgs_remove,
-	.id_table = sy7758vgs_ids,
-};
-
-module_i2c_driver(sy7758vgs_driver);
-
-MODULE_DESCRIPTION("Silergy sy7758vgs Backlight Driver");
-MODULE_AUTHOR("Kancy Joe <kancy2333@outlook.com>");
-MODULE_LICENSE("GPL");
-- 
2.43.0


From ffbf25fe786e272947651e976004886dc3581846 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sat, 7 Jun 2025 03:44:21 +0000
Subject: [PATCH 34/39] video: backlight: optimize init seq of sy7758.

---
 drivers/video/backlight/sy7758.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/video/backlight/sy7758.c b/drivers/video/backlight/sy7758.c
index 452164edee53..7abad41b9641 100644
--- a/drivers/video/backlight/sy7758.c
+++ b/drivers/video/backlight/sy7758.c
@@ -80,8 +80,8 @@ static void sy7758_init(struct sy7758 *sydev)
 	sy7758_write(sydev, 0xa1, 0x9a);
 	sy7758_write(sydev, 0xa9, 0x80);
 	sy7758_write(sydev, 0xa2, 0x28);
-
-	
+	/* Wait init done */
+	msleep(10);
 	sy7758_write(sydev, 0x10, 0x40);
 	sy7758_write(sydev, 0x11, 0x01);
 	// Max brightness
-- 
2.43.0


From 27a88fc875f6e105c8ea440d31de2c2110066907 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sat, 7 Jun 2025 03:45:52 +0000
Subject: [PATCH 35/39] gpu: panel: rename wt0600 2k panel and fix bugs in
 parameters.

---
 drivers/gpu/drm/panel/Makefile            |   2 +-
 drivers/gpu/drm/panel/panel-wt0600-2k.c   | 292 ++++++++++++++++++++++
 drivers/gpu/drm/panel/panel-wt0600-60hz.c | 286 ---------------------
 3 files changed, 293 insertions(+), 287 deletions(-)
 create mode 100644 drivers/gpu/drm/panel/panel-wt0600-2k.c
 delete mode 100644 drivers/gpu/drm/panel/panel-wt0600-60hz.c

diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 821a6de43d6d..dbb2d0734edf 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -112,5 +112,5 @@ obj-$(CONFIG_DRM_PANEL_VISIONOX_RM692E5) += panel-visionox-rm692e5.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_VTDR6130) += panel-visionox-vtdr6130.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_R66451) += panel-visionox-r66451.o
 obj-$(CONFIG_DRM_PANEL_WIDECHIPS_WS2401) += panel-widechips-ws2401.o
-obj-$(CONFIG_DRM_PANEL_AYANEO_WT0600_2K) += panel-wt0600-60hz.o
+obj-$(CONFIG_DRM_PANEL_AYANEO_WT0600_2K) += panel-wt0600-2k.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
diff --git a/drivers/gpu/drm/panel/panel-wt0600-2k.c b/drivers/gpu/drm/panel/panel-wt0600-2k.c
new file mode 100644
index 000000000000..d72c63674bab
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-wt0600-2k.c
@@ -0,0 +1,292 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2025 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/pinctrl/consumer.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct wt0600 {
+    struct device *dev;
+	struct drm_panel panel;
+    struct mipi_dsi_device *dsi[2];
+    struct backlight_device *backlight;
+    struct regulator *vddio;
+    struct regulator *avdd;
+    /* Pinctrls */
+    struct gpio_desc *reset_gpio;
+    struct pinctrl *pinctrl;
+    struct pinctrl_state *state_default;
+    struct pinctrl_state *state_suspend;
+    enum drm_panel_orientation orientation;
+    /* DSI device info */
+    struct panel_desc *desc;
+};
+
+struct panel_desc {
+	const struct mipi_dsi_device_info dsi_info;
+};
+
+static struct panel_desc wt0600_desc = {
+    .dsi_info = {
+        .type = "wt0600-2k",
+        .channel = 0,
+        .node = NULL,
+    }
+};
+
+static inline struct wt0600 *panel_to_ctx(struct drm_panel *panel)
+{
+	return container_of(panel, struct wt0600, panel);
+}
+
+static void wt0600_reset(struct wt0600 *ctx)
+{
+    gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+    usleep_range(10000, 11000);
+    gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+    usleep_range(10000, 11000);
+    gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+    msleep(55);
+}
+
+static int wt0600_on(struct wt0600 *ctx)
+{
+    struct mipi_dsi_multi_context dsi_ctx = { .dsi = ctx->dsi[0] };
+    struct mipi_dsi_multi_context dsi_ctx1 = { .dsi = ctx->dsi[1] };
+    mipi_dsi_dcs_set_display_on_multi(&dsi_ctx);
+    mipi_dsi_dcs_set_display_on_multi(&dsi_ctx1);
+    mipi_dsi_msleep(&dsi_ctx, 150);
+    mipi_dsi_dcs_exit_sleep_mode_multi(&dsi_ctx);
+    mipi_dsi_dcs_exit_sleep_mode_multi(&dsi_ctx1);
+    mipi_dsi_msleep(&dsi_ctx, 50);
+    return dsi_ctx.accum_err;
+}
+
+static int wt0600_off(struct drm_panel *panel)
+{
+    struct wt0600 *ctx = panel_to_ctx(panel);
+    struct mipi_dsi_multi_context dsi_ctx = { .dsi = ctx->dsi[0] };
+    struct mipi_dsi_multi_context dsi_ctx1 = { .dsi = ctx->dsi[1] };
+    mipi_dsi_dcs_set_display_off_multi(&dsi_ctx);
+    mipi_dsi_dcs_set_display_off_multi(&dsi_ctx1);
+    mipi_dsi_msleep(&dsi_ctx, 50);
+    mipi_dsi_dcs_enter_sleep_mode_multi(&dsi_ctx);
+    mipi_dsi_dcs_enter_sleep_mode_multi(&dsi_ctx1);
+    mipi_dsi_msleep(&dsi_ctx, 150);
+    return dsi_ctx.accum_err;
+}
+
+static int wt0600_prepare(struct drm_panel *panel)
+{
+	struct wt0600 *ctx = panel_to_ctx(panel);
+	int ret = 0;
+    
+    // enable power
+	ret = regulator_enable(ctx->avdd);
+	if (ret) {
+		dev_err(panel->dev, "failed to enable avdd regulator: %d\n", ret);
+		return ret;
+	}
+    msleep(20);
+	wt0600_reset(ctx);
+
+	ret = wt0600_on(ctx);
+	if (ret < 0) {
+		dev_err(ctx->dev, "failed to initialize panel: %d\n", ret);
+		// gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+        // regulator_disable(ctx->vddio);
+		return ret;
+	}
+
+    return 0;
+}
+
+static int wt0600_unprepare(struct drm_panel *panel)
+{
+	struct wt0600 *ctx = panel_to_ctx(panel);
+	int ret = 0;
+
+    // Enter suspend mode 
+    // pinctrl_select_state(ctx->pinctrl, ctx->state_suspend);
+
+    gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+    // regulator_disable(ctx->avdd);
+	return ret;
+}
+
+static const struct drm_display_mode wt0600_mode = {
+    .clock = 2*(720 + 100 + 8 + 40) * (2560 + 15 + 2 + 8) * 60 / 1000,
+    .hdisplay = 2*720,
+    .hsync_start = 2*(720 + 100),
+    .hsync_end = 2*(720 + 100 + 8),
+    .htotal = 2*(720 + 100 + 8 + 40),
+    .vdisplay = 2560,
+    .vsync_start = 2560 + 15,
+    .vsync_end = 2560 + 15 + 2,
+    .vtotal = 2560 + 15 + 2 + 8,
+    .width_mm = 74,
+    .height_mm = 131,
+    .type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int wt0600_get_modes(struct drm_panel *panel,
+				 struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &wt0600_mode);
+}
+
+static enum drm_panel_orientation nt36532e_get_orientation(struct drm_panel *panel)
+{
+	struct wt0600 *ctx = panel_to_ctx(panel);
+
+	return ctx->orientation;
+}
+
+static const struct drm_panel_funcs wt0600_panel_funcs = {
+    .disable = wt0600_off,
+	.prepare = wt0600_prepare,
+	.unprepare = wt0600_unprepare,
+	.get_modes = wt0600_get_modes,
+	.get_orientation = nt36532e_get_orientation,
+};
+
+static int wt0600_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct wt0600 *ctx;
+    struct device_node *dsi1;
+    struct mipi_dsi_host *dsi1_host;
+
+	int ret=0,i=0;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+    
+    // ctx->pinctrl = devm_pinctrl_get(dev);
+    // if (IS_ERR(ctx->pinctrl))
+    //     return dev_err_probe(dev, PTR_ERR(ctx->pinctrl), "failed to get pinctrl\n");
+
+    // ctx->state_default = pinctrl_lookup_state(ctx->pinctrl, "default");
+    // if (IS_ERR(ctx->state_default))
+    //     return dev_err_probe(dev, PTR_ERR(ctx->state_default), "no default pinctrl state\n");
+
+    // ctx->state_suspend = pinctrl_lookup_state(ctx->pinctrl, "suspend");
+    // if (IS_ERR(ctx->state_suspend))
+    //     return dev_err_probe(dev, PTR_ERR(ctx->state_suspend), "no suspend pinctrl state\n");
+
+
+    // ctx->vddio = devm_regulator_get(dev, "vddio");
+	// if (IS_ERR(ctx->vddio))
+	// 	return dev_err_probe(dev, PTR_ERR(ctx->vddio), "failed to get vddio regulator\n");
+
+    ctx->avdd = devm_regulator_get(dev, "avdd");
+	if (IS_ERR(ctx->avdd))
+		return dev_err_probe(dev, PTR_ERR(ctx->avdd), "failed to get avdd regulator\n");
+
+    ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+    if (IS_ERR(ctx->reset_gpio)) {
+        return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio), "failed to get reset gpio\n");
+    }
+
+    /* Get panel data */
+    ctx->desc = (struct panel_desc *)of_device_get_match_data(dev);
+	if (!ctx->desc){
+        dev_err(dev, "failed to get panel description\n");
+		return -ENODEV;
+    }
+
+    /* Locate second dsi device */
+    dsi1 = of_graph_get_remote_node(dsi->dev.of_node, 1, -1);
+    if (!dsi1) {
+        dev_err(dev, "failed to get remote node for dsi1_device\n");
+        return -ENODEV;
+    }
+
+    dsi1_host = of_find_mipi_dsi_host_by_node(dsi1);
+    of_node_put(dsi1);
+    if (!dsi1_host)
+        return dev_err_probe(dev, -EPROBE_DEFER, "failed to find dsi host\n");
+
+    /* register the second DSI device */
+    ctx->dsi[1] = devm_mipi_dsi_device_register_full(dev, dsi1_host, &ctx->desc->dsi_info);
+    if (IS_ERR(ctx->dsi[1])) {
+        dev_err(dev, "failed to create dsi device\n");
+        return PTR_ERR(ctx->dsi[1]);
+    }
+
+    /* Orientation */
+    ret = of_drm_get_panel_orientation(dev->of_node, &ctx->orientation);
+	if (ret < 0) {
+		dev_err(dev, "failed to get orientation %d\n", ret);
+		return ret;
+	}
+
+    ctx->dev = dev;
+    ctx->dsi[0] = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+    drm_panel_init(&ctx->panel, dev, &wt0600_panel_funcs, DRM_MODE_CONNECTOR_DSI);
+
+	ctx->panel.prepare_prev_first = true;
+
+    ret = drm_panel_of_backlight(&ctx->panel);
+    if (ret) {
+        return dev_err_probe(dev, ret, "Failed to get backlight\n");
+	}
+    
+    drm_panel_add(&ctx->panel);
+    for (i = 0; i < ARRAY_SIZE(ctx->dsi); i++) {
+        ctx->dsi[i]->lanes = 4;
+        ctx->dsi[i]->format = MIPI_DSI_FMT_RGB888;
+        ctx->dsi[i]->mode_flags = MIPI_DSI_MODE_VIDEO_BURST | MIPI_DSI_MODE_VIDEO |
+                                MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+        ret = mipi_dsi_attach(ctx->dsi[i]);
+        if (ret < 0) {
+            return dev_err_probe(dev, ret, "dsi attach failed i = %d\n", i);
+        }
+    }
+    return 0;
+}
+
+static void wt0600_remove(struct mipi_dsi_device *dsi)
+{
+    struct wt0600 *ctx = mipi_dsi_get_drvdata(dsi);
+    drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id wt0600_of_match[] = {
+	{ 
+        .compatible = "ayaneo,wt0600-2k",
+        .data = &wt0600_desc,
+    },
+	{}
+};
+MODULE_DEVICE_TABLE(of, wt0600_of_match);
+
+static struct mipi_dsi_driver wt0600_driver = {
+	.probe = wt0600_probe,
+	.remove = wt0600_remove,
+	.driver = {
+		.name = "panel-wt0600-2k",
+		.of_match_table = wt0600_of_match,
+	},
+};
+module_mipi_dsi_driver(wt0600_driver);
+
+MODULE_AUTHOR("Kancy Joe <kancy2333@outlook.com>");
+MODULE_DESCRIPTION("DRM driver for wt0600 2k video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/panel-wt0600-60hz.c b/drivers/gpu/drm/panel/panel-wt0600-60hz.c
deleted file mode 100644
index c87d0eab4451..000000000000
--- a/drivers/gpu/drm/panel/panel-wt0600-60hz.c
+++ /dev/null
@@ -1,286 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-// Copyright (c) 2025 FIXME
-// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
-//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
-
-#include <linux/backlight.h>
-#include <linux/delay.h>
-#include <linux/gpio/consumer.h>
-#include <linux/mod_devicetable.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_graph.h>
-#include <video/mipi_display.h>
-
-#include <drm/drm_mipi_dsi.h>
-#include <drm/drm_modes.h>
-#include <drm/drm_panel.h>
-#include <drm/drm_probe_helper.h>
-
-struct wt0600 {
-    struct device *dev;
-	struct drm_panel panel;
-	struct gpio_desc *reset_gpio;
-    struct mipi_dsi_device *dsi[2];
-    struct backlight_device *backlight;
-    struct regulator *vddio;
-};
-
-static inline struct wt0600 *panel_to_ctx(struct drm_panel *panel)
-{
-	return container_of(panel, struct wt0600, panel);
-}
-
-static int wt0600_dcs_write(struct wt0600 *ctx, u32 command)
-{
-    int i, ret;
-
-    for (i = 0; i < ARRAY_SIZE(ctx->dsi); i++) {
-        ret = mipi_dsi_dcs_write(ctx->dsi[i], command, NULL, 0);
-        if (ret < 0) {
-            dev_err(ctx->dev, "cmd 0x%x failed for dsi = %d\n", command, i);
-        }
-    }
-
-    return ret;
-}
-
-static void wt0600_reset(struct wt0600 *ctx)
-{
-	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-	usleep_range(10000, 11000);
-	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
-	usleep_range(10000, 11000);
-	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
-	msleep(55);
-}
-
-static int wt0600_on(struct wt0600 *ctx)
-{
-    int ret = 0;
-
-    ctx->dsi[0]->mode_flags |= MIPI_DSI_MODE_LPM;
-    ctx->dsi[1]->mode_flags |= MIPI_DSI_MODE_LPM;
-
-    ret = wt0600_dcs_write(ctx, MIPI_DCS_SET_DISPLAY_ON);
-    if (ret < 0) {
-        dev_err(ctx->dev, "set_display_on cmd failed ret = %d\n", ret);
-        return ret;
-    }
-    msleep(150);
-
-    ret = wt0600_dcs_write(ctx, MIPI_DCS_EXIT_SLEEP_MODE);
-    if (ret < 0) {
-        dev_err(ctx->dev, "set_display_on cmd failed ret = %d\n", ret);
-        return ret;
-    }
-
-    msleep(50);
-    
-	return 0;
-}
-
-static int wt0600_off(struct wt0600 *ctx)
-{
-    int ret = 0;
-
-	ctx->dsi[0]->mode_flags &= ~MIPI_DSI_MODE_LPM;
-    ctx->dsi[1]->mode_flags &= ~MIPI_DSI_MODE_LPM;
-
-    ret = wt0600_dcs_write(ctx, MIPI_DCS_SET_DISPLAY_OFF);
-    if (ret < 0) {
-        dev_err(ctx->dev, "set_display_off cmd failed ret = %d\n", ret);
-    }
-
-    msleep(50);
-
-    ret =  wt0600_dcs_write(ctx, MIPI_DCS_ENTER_SLEEP_MODE);
-    if (ret < 0) {
-        dev_err(ctx->dev, "enter_sleep cmd failed ret = %d\n", ret);
-    }
-    msleep(150);
-
-	return ret;
-}
-
-static int wt0600_prepare(struct drm_panel *panel)
-{
-	struct wt0600 *ctx = panel_to_ctx(panel);
-	int ret;
-
-	// ret = regulator_enable(ctx->vddio);
-	// if (ret) {
-	// 	dev_err(panel->dev, "failed to enable vddio regulator: %d\n", ret);
-	// 	return ret;
-	// }
-
-	wt0600_reset(ctx);
-
-	ret = wt0600_on(ctx);
-	if (ret < 0) {
-		dev_err(ctx->dev, "Failed to initialize panel: %d\n", ret);
-		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-        // regulator_bulk_disable(ARRAY_SIZE(wt0600_supplies),
-        //               ctx->supplies);
-		return ret;
-	}
-
-	return 0;
-}
-
-static int wt0600_unprepare(struct drm_panel *panel)
-{
-	struct wt0600 *ctx = panel_to_ctx(panel);
-	int ret;
-
-	ret = wt0600_off(ctx);
-	if (ret < 0)
-		dev_err(ctx->dev, "Failed to un-initialize panel: %d\n", ret);
-
-	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-    // regulator_bulk_disable(ARRAY_SIZE(wt0600_supplies),
-                    //   ctx->supplies);
-	return 0;
-}
-
-static const struct drm_display_mode wt0600_mode = {
-    .clock = (1440 + 100 + 8 + 40) * (2560 + 8 + 2 + 7) * 60 / 1000,
-    .hdisplay = 1440,
-    .hsync_start = 1440 + 100,
-    .hsync_end = 1440 + 100 + 8,
-    .htotal = 1440 + 100 + 8 + 40,
-    .vdisplay = 2560,
-    .vsync_start = 2560 + 8,
-    .vsync_end = 2560 + 8 + 2,
-    .vtotal = 2560 + 8 + 2 + 7,
-    .width_mm = 74,
-    .height_mm = 131,
-    .type = DRM_MODE_TYPE_DRIVER,
-};
-
-static int wt0600_get_modes(struct drm_panel *panel,
-				 struct drm_connector *connector)
-{
-	return drm_connector_helper_get_modes_fixed(connector, &wt0600_mode);
-}
-
-static const struct drm_panel_funcs wt0600_panel_funcs = {
-	.prepare = wt0600_prepare,
-	.unprepare = wt0600_unprepare,
-	.get_modes = wt0600_get_modes,
-};
-
-static int wt0600_probe(struct mipi_dsi_device *dsi)
-{
-	struct device *dev = &dsi->dev;
-	struct wt0600 *ctx;
-    struct mipi_dsi_device *dsi1_device;
-    struct device_node *dsi1;
-    struct mipi_dsi_host *dsi1_host;
-
-	int ret,i;
-
-    const struct mipi_dsi_device_info info = {
-        .type = "wt0600panel",
-        .channel = 0,
-        .node = NULL,
-    };
-
-	pr_warn("panel: wt0600 1080p probe in\n");
-
-	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
-	if (!ctx)
-		return -ENOMEM;
-    
-    ctx->vddio = devm_regulator_get(dev, "vddio");
-	if (IS_ERR(ctx->vddio))
-		return dev_err_probe(dev, PTR_ERR(ctx->vddio), "failed to get vddio regulator\n");
-
-    ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
-    if (IS_ERR(ctx->reset_gpio)) {
-        return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio), "failed to get reset gpio\n");
-    }
-
-    /* Locate second dsi device */
-    dsi1 = of_graph_get_remote_node(dsi->dev.of_node, 1, -1);
-    if (!dsi1) {
-        dev_err(dev, "failed to get remote node for dsi1_device\n");
-        return -ENODEV;
-    }
-
-    dsi1_host = of_find_mipi_dsi_host_by_node(dsi1);
-    of_node_put(dsi1);
-    if (!dsi1_host)
-        return dev_err_probe(dev, -EPROBE_DEFER, "failed to find dsi host\n");
-
-    /* register the second DSI device */
-    ctx->dsi[1] = mipi_dsi_device_register_full(dsi1_host, &info);
-    if (IS_ERR(dsi1_device)) {
-        dev_err(dev, "failed to create dsi device\n");
-        return PTR_ERR(dsi1_device);
-    }
-
-    ctx->dev = dev;
-    ctx->dsi[0] = dsi;
-	mipi_dsi_set_drvdata(dsi, ctx);
-
-    drm_panel_init(&ctx->panel, dev, &wt0600_panel_funcs, DRM_MODE_CONNECTOR_DSI);
-	
-	ctx->panel.prepare_prev_first = true;
-
-    ret = drm_panel_of_backlight(&ctx->panel);
-    if (ret) {
-        return dev_err_probe(dev, ret, "Failed to get backlight\n");
-	}
-    
-    drm_panel_add(&ctx->panel);
-
-    for (i = 0; i < ARRAY_SIZE(ctx->dsi); i++) {
-        ctx->dsi[i]->lanes = 4;
-        ctx->dsi[i]->format = MIPI_DSI_FMT_RGB888;
-        ctx->dsi[i]->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
-            MIPI_DSI_CLOCK_NON_CONTINUOUS;
-        ret = mipi_dsi_attach(ctx->dsi[i]);
-        if (ret < 0) {
-            return dev_err_probe(dev, ret, "dsi attach failed i = %d\n", i);
-        }
-    }
-
-	pr_warn("panel: wt0600 1080p probe out\n");
-
-    return 0;
-}
-
-static void wt0600_remove(struct mipi_dsi_device *dsi)
-{
-    struct wt0600 *ctx = mipi_dsi_get_drvdata(dsi);
-
-    if (ctx->dsi[0])
-        mipi_dsi_detach(ctx->dsi[0]);
-    if (ctx->dsi[1]) {
-        mipi_dsi_detach(ctx->dsi[1]);
-        mipi_dsi_device_unregister(ctx->dsi[1]);
-    }
-
-    drm_panel_remove(&ctx->panel);
-}
-
-static const struct of_device_id wt0600_of_match[] = {
-	{ .compatible = "ayaneo,wt0600-1080p" },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, wt0600_of_match);
-
-static struct mipi_dsi_driver wt0600_driver = {
-	.probe = wt0600_probe,
-	.remove = wt0600_remove,
-	.driver = {
-		.name = "panel-wt0600-60hz-1080p",
-		.of_match_table = wt0600_of_match,
-	},
-};
-module_mipi_dsi_driver(wt0600_driver);
-
-MODULE_AUTHOR("Linux Panel Generator");
-MODULE_DESCRIPTION("DRM driver for wt0600 1080p video mode dsi panel");
-MODULE_LICENSE("GPL");
-- 
2.43.0


From a88612e6fda18f3e5f6485f7cbd526a5302a24dc Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sat, 7 Jun 2025 03:59:18 +0000
Subject: [PATCH 36/39] arm64: dts: qcom: fix sd, panels and add some devices
 nodes.

---
 arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts | 378 ++++++++++--------
 1 file changed, 211 insertions(+), 167 deletions(-)

diff --git a/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts b/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts
index c95b05d3dc69..97488cc17d56 100644
--- a/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts
+++ b/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts
@@ -28,27 +28,61 @@ / {
 	aliases {
 		serial0 = &uart7;
 		serial1 = &uart14;
+		display0 = &display0;
+	};
+
+	/* Memory and ddr regions are important for booting from ABL */
+	/* We use uefi as bootloader so here is the fallback choice */
+	memory {
+		ddr_device_type = <8>;
+		device_type = "memory";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		reg = <0x0 0x80000000 0x0 0xe00000>,
+			  <0x0 0x811d0000 0x0 0x56e30000>,
+			  <0x0 0xd8140000 0x0 0x20000>,
+			  <0x0 0xddde0000 0x0 0x22220000>,
+			  <0x8 0x80000000 0x0 0x39a00000>,
+			  <0x9 0x80000000 0x1 0x80000000>,
+			  <0x8 0xc0000000 0x0 0xc0000000>;
+	};
+
+	ddr-regions {
+		#address-cells = <0x02>;
+		#size-cells = <0x02>;
+		region2 = <0x09 0x80000000 0x01 0x80000000 0x00 0x00 0x00 0x08 0x00 0x400>;
+		region1 = <0x08 0x80000000 0x01 0x00 0x00 0x00 0x00 0x02 0x00 0x400>;
+		region0 = <0x00 0x80000000 0x00 0x80000000 0x00 0x00 0x00 0x00 0x00 0x400>;
 	};
-    
-	chosen {
-        #address-cells = <2>;
-        #size-cells = <2>;
-        ranges;
-
-        framebuffer: framebuffer@b8000000 {
-            compatible = "simple-framebuffer";
-            reg = <0 0xb8000000 0 0x2b00000>;
-            width = <1440>;
-            height = <2560>;
-            stride = <(1440 * 4)>;
-            format = "a8r8g8b8";
-			clocks = <&gcc GCC_DISP_AHB_CLK>,
-				 <&gcc GCC_DISP_HF_AXI_CLK>;
-		};
-    };
 
 	chosen {
-		stdout-path = "serial0:115200n8";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		stdout-path = "display0";
+		bootargs = "fbcon=rotate:1 panic=30 loglevel=7 efi=novamap init=/sbin/init root=/dev/sda10 ro rootwait console=ttyS0,115200 console=tty1 systemd.journald.forward_to_console=true systemd.log_level=debug systemd.log_target=kmsg log_buf_len=10M printk.devkmsg=on allow_mismatched_32bit_el0 kasan=off";
+		display0: framebuffer@b8000000 {
+			compatible = "simple-framebuffer";
+			reg = <0 0xb8000000 0 0x2b00000>;
+			status = "okay";
+			width = <1440>;
+			height = <2560>;
+			stride = <(1440 * 4)>;
+			format = "a8r8g8b8";
+			// clocks = <&gcc GCC_DISP_AHB_CLK>,
+				// <&gcc GCC_DISP_HF_AXI_CLK>;
+			 	// <&dispcc DISP_CC_MDSS_AHB_CLK>,
+				// <&dispcc DISP_CC_MDSS_MDP_CLK>,
+				// <&dispcc DISP_CC_MDSS_BYTE0_CLK>,
+				// <&dispcc DISP_CC_MDSS_BYTE0_INTF_CLK>,
+				// <&dispcc DISP_CC_MDSS_PCLK0_CLK>,
+				// <&dispcc DISP_CC_MDSS_ESC0_CLK>,
+				// <&dispcc DISP_CC_MDSS_BYTE1_CLK>,
+				// <&dispcc DISP_CC_MDSS_BYTE1_INTF_CLK>,
+				// <&dispcc DISP_CC_MDSS_PCLK1_CLK>,
+				// <&dispcc DISP_CC_MDSS_ESC1_CLK>;
+			// power-domains = <&dispcc MDSS_GDSC>;
+		};
 	};
 
 	gpio-keys {
@@ -167,106 +201,76 @@ vph_pwr: regulator-vph-pwr {
 
 	fan0: pwm-fan {
 		compatible = "pwm-fan";
+		// status = "disabled";
 		#cooling-cells = <2>;
 		interrupt-parent = <&tlmm>;
 		interrupts = <64 IRQ_TYPE_EDGE_FALLING>;
 		pinctrl-names = "default", "sleep";
-		pinctrl-0 = <&fan0_pwr_active>, <&pwm_fan_ctrl_default>;
+		pinctrl-0 = <&fan0_pwr_active>, <&pwm_fan_ctrl_default>, <&fan0_int_active>;
 		pinctrl-1 = <&fan0_pwr_sleep>;
 		pwms = <&pm8550_pwm 3 1000000>;
-		cooling-levels = <255 192 160 128 96 32 16 0>;
+		cooling-levels = <255 255 255 255 220 200 200 180 170 64 32 16 0>;
 	};
 
 	thermal-zones {
 		cpu7-top-thermal {
 			trips {
-				cpu7_top_trip0: trip-point2 {
-					temperature = <40000>;
-					hysteresis = <4000>;
-					type = "passive";
-				};
-
-				cpu7_top_trip1: trip-point3 {
-					temperature = <50000>;
-					hysteresis = <4000>;
-					type = "passive";
-				};
-				
-				cpu7_top_trip2: trip-point4 {
-					temperature = <60000>;
-					hysteresis = <4000>;
-					type = "passive";
-				};
-
-				cpu7_top_trip3: trip-point5 {
-					temperature = <70000>;
-					hysteresis = <4000>;
-					type = "passive";
-				};
+				cpu7_top_trip0: trip-point0 { temperature = <38000>; hysteresis = <2000>; type = "passive"; };
+				cpu7_top_trip1: trip-point1 { temperature = <42000>; hysteresis = <2000>; type = "passive"; };
+				cpu7_top_trip2: trip-point2 { temperature = <46000>; hysteresis = <2000>; type = "passive"; };
+				cpu7_top_trip3: trip-point3 { temperature = <50000>; hysteresis = <2000>; type = "passive"; };
+				cpu7_top_trip4: trip-point4 { temperature = <55000>; hysteresis = <2000>; type = "passive"; };
+				cpu7_top_trip5: trip-point5 { temperature = <70000>; hysteresis = <2000>; type = "passive"; };
+				cpu7_top_trip6: trip-point6 { temperature = <75000>; hysteresis = <3000>; type = "passive"; };
+				cpu7_top_trip7: trip-point7 { temperature = <80000>; hysteresis = <3000>; type = "passive"; };
 			};
-
 			cooling-maps {
-				map0 {
-					trip = <&cpu7_top_trip0>;
-					cooling-device = <&fan0 1 1>;
-				};
-
-				map1 {
-					trip = <&cpu7_top_trip1>;
-					cooling-device = <&fan0 2 2>;
-				};
-
-				map2 {
-					trip = <&cpu7_top_trip2>;
-					cooling-device = <&fan0 3 3>;
-				};
-
-				map3 {
-					trip = <&cpu7_top_trip3>;
-					cooling-device = <&fan0 4 4>;
-				};
-
-				map4 {
-					trip = <&cpu7_top_alert0>;
-					cooling-device = <&fan0 5 5>;
-				};
-
-				map5 {
-					trip = <&cpu7_top_alert1>;
-					cooling-device = <&fan0 6 6>;
-				};
-
-				map6 {
-					trip = <&cpu7_top_crit>;
-					cooling-device = <&fan0 7 THERMAL_NO_LIMIT>;
-				};
+				map0 { trip = <&cpu7_top_trip0>; cooling-device = <&fan0 1 1>; };
+				map1 { trip = <&cpu7_top_trip1>; cooling-device = <&fan0 2 3>; };
+				map2 { trip = <&cpu7_top_trip2>; cooling-device = <&fan0 4 5>; };
+				map3 { trip = <&cpu7_top_trip3>; cooling-device = <&fan0 6 6>; };
+				map4 { trip = <&cpu7_top_trip4>; cooling-device = <&fan0 7 8>; };
+				map5 { trip = <&cpu7_top_trip5>; cooling-device = <&fan0 9 9>; };
+				map6 { trip = <&cpu7_top_trip6>; cooling-device = <&fan0 10 10>; };
+				map7 { trip = <&cpu7_top_trip7>; cooling-device = <&fan0 11 11>; };
+				map8 { trip = <&cpu7_top_alert0>; cooling-device = <&fan0 12 12>; };
 			};
 		};
 	};
 
 	reserved-memory {
 		chipinfo_region: memory@81cf4000 {
-            reg = <0x00 0x81cf4000 0x00 0x1000>;
-            no-map;
-        };
+			reg = <0x00 0x81cf4000 0x00 0x1000>;
+			no-map;
+		};
 
 		hwfence_shbuf: memory@e6440000 {
 			reg = <0x00 0xe6440000 0x00 0x2dd000>;
-            no-map;
-        };
+			no-map;
+		};
 
 		splash_region: splash_region@b8000000 { 
 			reg = <0x0 0xb8000000 0x0 0x2b00000>;
+			label = "cont_splash_region";
 			no-map;
 		};
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			size = <0x0 0x8000000>;
+			reusable;
+			linux,cma-default;
+		};
 	};
 
 	sound {
-		status = "disabled";
+		status = "okay";
 		compatible = "qcom,sm8550-sndcard", "qcom,sm8450-sndcard";
 		model = "SM8550-APS";
 		audio-routing = "SpkrLeft IN", "WSA_SPK1 OUT",
-				"SpkrRight IN", "WSA_SPK2 OUT";
+				"SpkrRight IN", "WSA_SPK2 OUT",
+				"VA DMIC0", "vdd-micb",
+				"VA DMIC1", "vdd-micb";
 
 		wsa-dai-link {
 			link-name = "WSA Playback";
@@ -288,7 +292,7 @@ va-dai-link {
 			link-name = "VA Capture";
 
 			cpu {
-				sound-dai = <&q6apmbedai TX_CODEC_DMA_TX_3>;
+				sound-dai = <&q6apmbedai VA_CODEC_DMA_TX_0>;
 			};
 
 			codec {
@@ -303,7 +307,7 @@ platform {
 
 	wcn7850-pmu {
 		compatible = "qcom,wcn7850-pmu";
-		status = "disabled";
+		status = "okay";
 		pinctrl-names = "default";
 		pinctrl-0 = <&wlan_en>, <&bt_default>, <&pmk8550_sleep_clk>;
 
@@ -361,6 +365,14 @@ vreg_pmu_pcie_1p8: ldo9 {
 	};
 };
 
+/* DMIC 01 23 */
+&lpass_vamacro {
+	pinctrl-0 = <&dmic01_default>, <&dmic23_default>;
+	pinctrl-names = "default";
+	vdd-micb-supply = <&vreg_l10b_1p8>;
+	qcom,dmic-sample-rate = <4800000>;
+};
+
 &apps_rsc {
 	regulators-0 {
 		compatible = "qcom,pm8550-rpmh-regulators";
@@ -461,6 +473,8 @@ vreg_l12b_1p8: ldo12 {
 			regulator-min-microvolt = <1800000>;
 			regulator-max-microvolt = <1800000>;
 			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+			regulator-always-on;
+			regulator-boot-on;
 		};
 
 		vreg_l13b_3p0: ldo13 {
@@ -468,6 +482,8 @@ vreg_l13b_3p0: ldo13 {
 			regulator-min-microvolt = <3000000>;
 			regulator-max-microvolt = <3000000>;
 			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+			regulator-always-on;
+			regulator-boot-on;
 		};
 
 		vreg_l14b_3p2: ldo14 {
@@ -699,7 +715,6 @@ &i2c_hub_2 {
 	typec-retimer@1c {
 		compatible = "onnn,nb7vpq904m";
 		reg = <0x1c>;
-
 		vcc-supply = <&vreg_l15b_1p8>;
 
 		retimer-switch;
@@ -732,20 +747,28 @@ redriver_ss_in: endpoint {
 &i2c0 {
 	status = "okay";
 	/* Screen power */
-	// sgm3804@3e
+	sgm3804: regulator@3e {
+		compatible = "sgmicro,sgm3804";
+		reg = <0x3e>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&panel_pwr_active>;
+		regulator-name = "panel-avdd";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		reset-gpios = <&tlmm 152 GPIO_ACTIVE_HIGH>, <&tlmm 153 GPIO_ACTIVE_HIGH>;
+	};
 
 	/* Backlight */
-	// sy7758vgs@2e
-	sy7758vgs_bl: sy7758vgs@2e {
-		compatible = "silergy,sy7758vgs";
+	sy7758_bl: sy7758@2e {
+		compatible = "silergy,sy7758";
 		reg = <0x2e>;
-		status = "disabled";
+		status = "okay";
 	};
 };
 
 
 &i2c4 {
-	status = "disabled";
+	status = "okay";
 	clock-frequency = <400000>;
 
 	touchscreen@5d {
@@ -772,7 +795,7 @@ &ipa {
 	qcom,gsi-loader = "self";
 	memory-region = <&ipa_fw_mem>;
 	firmware-name = "qcom/sm8550/ayaneo/ipa_fws.mdt";
-	status = "disabled";
+	status = "okay";
 };
 
 &gpi_dma1 {
@@ -781,78 +804,102 @@ &gpi_dma1 {
 
 &gpu {
 	status = "okay";
-
+	compatible = "qcom,adreno-43050a01", "qcom,adreno";
 	zap-shader {
 		firmware-name = "qcom/sm8550/a740_zap.mbn";
 	};
 };
 
-// &dispcc {
-// 	status = "disabled";
-// };
-
-// &mdss {
-// 	status = "disabled";
-// };
+&gpu_opp_table {
+/* Additional speedbin for Adreno A32
+	719000000  RPMH_REGULATOR_LEVEL_SVS_L2
+	746000000 RPMH_REGULATOR_LEVEL_NOM
+	794000000 RPMH_REGULATOR_LEVEL_NOM_L1
+	827000000 RPMH_REGULATOR_LEVEL_TURBO
+	860000000 RPMH_REGULATOR_LEVEL_TURBO_L1 
+	1000000000 RPMH_REGULATOR_LEVEL_TURBO_L2
+*/
+	opp-719000000 {
+		opp-hz = /bits/ 64 <719000000>;
+		opp-level = <RPMH_REGULATOR_LEVEL_SVS_L2>;
+		opp-peak-kBps = <10687500>; // Level 7
+	};
 
-// &mdss_dsi0 {
-// 	status = "disabled";
-// };
+	opp-746000000 {
+		opp-hz = /bits/ 64 <746000000>;
+		opp-level = <RPMH_REGULATOR_LEVEL_NOM>;
+		opp-peak-kBps = <10687500>; // Level 7
+	};
 
-// &mdss_dsi0_out {
-// 	status = "disabled";
-// };
+	opp-794000000 {
+		opp-hz = /bits/ 64 <794000000>;
+		opp-level = <RPMH_REGULATOR_LEVEL_NOM_L1>;
+		opp-peak-kBps = <14398438>; // Level 8
+	};
 
-// &mdss_dsi0_phy {
-// 	status = "disabled";
-// };
+	// opp-827000000 {
+	// 	opp-hz = /bits/ 64 <827000000>;
+	// 	opp-level = <RPMH_REGULATOR_LEVEL_TURBO>;
+	// 	opp-peak-kBps = <16500000>; // Level 9
+	// };
 
-// &mdss_dsi1 {
-// 	status = "disabled";
-// };
+	// opp-860000000 {
+	// 	opp-hz = /bits/ 64 <860000000>;
+	// 	opp-level = <RPMH_REGULATOR_LEVEL_TURBO_L1>;
+	// 	opp-peak-kBps = <16500000>; // Level 9
+	// };
 
-// &mdss_dsi1_out {
-// 	status = "disabled";
-// };
+	// opp-1000000000 {
+	// 	opp-hz = /bits/ 64 <1000000000>;
+	// 	opp-level = <RPMH_REGULATOR_LEVEL_TURBO_L2>;
+	// 	opp-peak-kBps = <16500000>; // Level 9
+	// };
+};
 
-// &mdss_dsi1_phy {
-// 	status = "disabled";
-// };
+&iris {
+	status = "okay";
+	firmware-name = "qcom/sm8550/ayaneo/vpu30_4v.mbn";
+};
 
-// &mdss {
-// 	status = "okay";
-// };
+&mdss {
+	status = "okay";
+};
 
 /* wt0600 60hz 2k dual dsi dphy panel */
 &mdss_dsi0 {
-	vdda-supply = <&vreg_l3e_1p2>;
-	// qcom,dual-dsi-mode;
-	// qcom,sync-dual-dsi;
-	// qcom,master-dsi;
 	status = "okay";
+	qcom,master-dsi;
+	qcom,dual-dsi-mode;
+	qcom,sync-dual-dsi;
+	vdda-supply = <&vreg_l3e_1p2>;
 
 	panel@0 {
-		status = "disabled";
-		compatible = "ayaneo,wt0600-1080p";
+		status = "okay";
+		compatible = "ayaneo,wt0600-2k";
 		reg = <0>;
-		backlight = <&sy7758vgs_bl>;
-		pinctrl-0 = <&sde_dsi_active>, <&sde_te_active>;//, <&panel_pwr_active>;
-		pinctrl-1 = <&sde_dsi_suspend>, <&sde_te_suspend>;
-		pinctrl-names = "default", "sleep";
+		pinctrl-names = "default", "suspend";
+		pinctrl-0 = <&sde_dsi_active>;
+		pinctrl-1 = <&sde_dsi_suspend>;
 
-		vddio-supply = <&vreg_l11b_1p2>;
+		vdd-supply = <&vreg_l11b_1p2>;
+		vci-supply = <&vreg_l13b_3p0>;
+		vddio-supply = <&vreg_l12b_1p8>;
+		avdd-supply = <&sgm3804>;
 
-		reset-gpios = <&tlmm 133 GPIO_ACTIVE_LOW>;
+		reset-gpios = <&tlmm 133 GPIO_ACTIVE_HIGH>;
+		backlight = <&sy7758_bl>;
 
 		ports {
 			#address-cells = <1>;
 			#size-cells = <0>;
+
 			port@0 {
 				reg = <0>;
 				panel0_in_0: endpoint {
 					remote-endpoint = <&mdss_dsi0_out>;
 				};
 			};
+
 			port@1{
 				reg = <1>;
 				panel0_in_1: endpoint {
@@ -903,10 +950,10 @@ &pcie0 {
 	wake-gpios = <&tlmm 96 GPIO_ACTIVE_HIGH>;
 	perst-gpios = <&tlmm 94 GPIO_ACTIVE_LOW>;
 
-	pinctrl-0 = <&pcie0_default_state>;
 	pinctrl-names = "default";
+	pinctrl-0 = <&pcie0_default_state>;
 
-	status = "disabled";
+	status = "okay";
 };
 
 &pcieport0 {
@@ -930,7 +977,7 @@ &pcie0_phy {
 	vdda-phy-supply = <&vreg_l1e_0p88>;
 	vdda-pll-supply = <&vreg_l3e_1p2>;
 
-	status = "disabled";
+	status = "okay";
 };
 
 &pcie1 {
@@ -940,7 +987,7 @@ &pcie1 {
 	pinctrl-0 = <&pcie1_default_state>, <&upd720201_active>;
 	pinctrl-names = "default";
 
-	status = "disabled";
+	status = "okay";
 };
 
 &pcie1_phy {
@@ -948,7 +995,7 @@ &pcie1_phy {
 	vdda-pll-supply = <&vreg_l3e_1p2>;
 	vdda-qref-supply = <&vreg_l1e_0p88>;
 
-	status = "disabled";
+	status = "okay";
 };
 
 &pm8550_gpios {
@@ -984,7 +1031,7 @@ &pm8550_pwm {
 
 	multi-led {
 		color = <LED_COLOR_ID_RGB>;
-		function = LED_FUNCTION_DISK_ACTIVITY;
+		function = LED_FUNCTION_STATUS;
 
 		#address-cells = <1>;
 		#size-cells = <0>;
@@ -1016,9 +1063,8 @@ &pon_pwrkey {
 };
 
 &pon_resin {
-	/* The text on button is reverted so we also reverted here. */
+	/* The text on button is reverted so we need to revert the keycode here. */
 	linux,code = <KEY_VOLUMEUP>;
-
 	status = "okay";
 };
 
@@ -1035,6 +1081,7 @@ pmk8550_sleep_clk: sleep-clk-state {
 
 &qupv3_id_0 {
 	status = "okay";
+	/* UART seems enabled in android */
 	// uart5: uart@a94000 {
 	// 	compatible = "qcom,geni-uart";
 	// 	reg = <0 0x00a94000 0 0x4000>;
@@ -1052,6 +1099,7 @@ &qupv3_id_0 {
 
 &qupv3_id_1 {
 	status = "okay";
+	/* UART seems enabled in android */
 	// uart11: uart@88c000 {
 	// 	compatible = "qcom,geni-uart";
 	// 	reg = <0 0x0088c000 0 0x4000>;
@@ -1086,7 +1134,7 @@ &remoteproc_mpss {
 };
 
 &sdhc_2 {
-	cd-gpios = <&pm8550_gpios 12 GPIO_ACTIVE_HIGH>;
+	cd-gpios = <&pm8550_gpios 12 GPIO_ACTIVE_LOW>;
 
 	pinctrl-0 = <&sdc2_default>, <&sdc2_card_det_n>;
 	pinctrl-1 = <&sdc2_sleep>, <&sdc2_card_det_n>;
@@ -1103,7 +1151,7 @@ &sdhc_2 {
 };
 
 &sleep_clk {
-	clock-frequency = <32000>;
+	clock-frequency = <32764>;
 };
 
 &swr0 {
@@ -1147,7 +1195,7 @@ south_spkr: speaker@0,1 {
 };
 
 &tlmm {
-	/* Reserved I/Os for NFC */
+	/* Reserved I/Os for SPI pins */
 	gpio-reserved-ranges = <32 8>;
 
 	bt_default: bt-default-state {
@@ -1181,18 +1229,19 @@ wlan_en: wlan-en-state {
 	};
 
 	panel_pwr_active: panel-pwr-active-state {
-		pins = "gpio152", "gpio153","gpio42", "gpio72", "gpio41";
+		pins = "gpio41", "gpio72", "gpio42", "gpio152", "gpio153";
 		function = "gpio";
 		drive-strength = <8>;
 		bias-disable;
 		output-high;
 	};
-	
+
 	sde_dsi_active: sde-dsi-active-state {
 		pins = "gpio133";
 		function = "gpio";
 		drive-strength = <8>;
 		bias-disable;
+		output-high;
 	};
 
 	sde_dsi_suspend: sde-dsi-suspend-state {
@@ -1202,20 +1251,6 @@ sde_dsi_suspend: sde-dsi-suspend-state {
 		bias-pull-down;
 	};
 
-	sde_te_active: sde-te-active-state {
-		pins = "gpio86";
-		function = "mdp_vsync";
-		drive-strength = <2>;
-		bias-pull-down;
-	};
-
-	sde_te_suspend: sde-te-suspend-state {
-		pins = "gpio86";
-		function = "mdp_vsync";
-		drive-strength = <2>;
-		bias-pull-down;
-	};
-
 	ts_irq: ts-irq-state {
 		pins = "gpio25";
 		function = "gpio";
@@ -1280,6 +1315,14 @@ fan0_pwr_active: fan0-pwr-active-state {
 		output-high;
 	};
 
+	fan0_int_active: fan0-int-active-state {
+		pins = "gpio64";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-pull;
+		input-enable;
+	};
+
 	fan0_pwr_sleep: fan0-pwr-sleep-state {
 		pins = "gpio30", "gpio31";
 		function = "gpio";
@@ -1302,7 +1345,7 @@ &uart7 {
 };
 
 &uart14 {
-	status = "disabled";
+	status = "okay";
 
 	bluetooth {
 		compatible = "qcom,wcn7850-bt";
@@ -1314,6 +1357,7 @@ bluetooth {
 		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
 		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
 		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+		local-bd-address = [ F0 74 E4 61 E3 d4 ];
 
 		max-speed = <3200000>;
 	};
-- 
2.43.0


From e7613348b3b5c9c30b15226fa3c69c2535e94a7b Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sat, 7 Jun 2025 04:00:27 +0000
Subject: [PATCH 37/39] arm64: dts: qcom: replace spaces with tabs.

---
 .../arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts | 30 +++++++++----------
 1 file changed, 15 insertions(+), 15 deletions(-)

diff --git a/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts b/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts
index 9a12ece7181d..95287ccf44b9 100644
--- a/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts
+++ b/arch/arm64/boot/dts/qcom/sm8250-xiaomi-umi.dts
@@ -26,7 +26,7 @@ / {
 	model = "Xiaomi Technologies, Inc. Mi10";
 	compatible = "qcom,sm8250-mtp", "qcom,sm8250";
 	chassis-type = "handset";
-    qcom,msm-id = <0x164 0x20001>;
+	qcom,msm-id = <0x164 0x20001>;
 	qcom,board-id = <0x2b 0x00>;
 
 	aliases {
@@ -35,14 +35,14 @@ aliases {
 	};
 	
 	memory {
-        ddr_device_type = <0x08>;
-        device_type = "memory";
+		ddr_device_type = <0x08>;
+		device_type = "memory";
 		#address-cells = <2>;
 		#size-cells = <2>;
-        reg = <0x0 0x80000000 0x0 0x3b800000>,
-		<0x1 0x80000000 0x1 0x0>,
-		<0x0 0xc0000000 0x0 0xc0000000>;
-    };
+		reg = 	<0x0 0x80000000 0x0 0x3b800000>,
+				<0x1 0x80000000 0x1 0x0>,
+				<0x0 0xc0000000 0x0 0xc0000000>;
+	};
 
 	wcd938x: audio-codec {
 		compatible = "qcom,wcd9380-codec";
@@ -990,8 +990,8 @@ wifi@0 {
 &pcie2 {
 	status = "okay";
 	pinctrl-0 = <&pcie2_default_state>, <&mdm2ap_default>, <&ap2mdm_default>, <&ap2mdm_active>, <&nfc_int_default>,
-                    <&nfc_ven_default>,
-                    <&nfc_clk_req_default>;
+					<&nfc_ven_default>,
+					<&nfc_clk_req_default>;
 };
 
 &pcie2_phy {
@@ -1157,11 +1157,11 @@ &sound {
 	pinctrl-0 = <&tert_mi2s_active>;
 
 	audio-routing =
-	    "L ASPRX1", 		"MM_DL1",
+		"L ASPRX1", 		"MM_DL1",
 		"L DSP RX1 Source", "L ASPRX1",
 		"L DSP1", 			"L DSP RX1 Source",
 		"L PCM Source", 	"L DSP1",
-	    "R ASPRX1", 		"MM_DL1",
+		"R ASPRX1", 		"MM_DL1",
 		"R DSP RX1 Source", "R ASPRX1",
 		"R DSP1", 			"R DSP RX1 Source",
 		"R PCM Source", 	"R DSP1",
@@ -1387,12 +1387,12 @@ ap2mdm_default: ap2mdm-default-state {
 	};
 
 	ap2mdm_active: ap2mdm-active-state {
-        pins = "gpio56";
-        function = "gpio";
-        drive-strength = <16>;
+		pins = "gpio56";
+		function = "gpio";
+		drive-strength = <16>;
 		bias-disable;
 		output-high;
-    };
+	};
 
 	bt_en_state: bt-default-state {
 		pins = "gpio21";
-- 
2.43.0


From e8fe75dd72d040884d18867f61a2c7ba049aa955 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Tue, 10 Jun 2025 12:51:24 +0000
Subject: [PATCH 38/39] arm64: configs: enable binfmt misc in q_defconfig

---
 arch/arm64/configs/q_defconfig | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/arch/arm64/configs/q_defconfig b/arch/arm64/configs/q_defconfig
index dbe4b7105ebd..41259022c36f 100644
--- a/arch/arm64/configs/q_defconfig
+++ b/arch/arm64/configs/q_defconfig
@@ -67,12 +67,14 @@ CONFIG_ACPI_APEI_GHES=y
 CONFIG_ACPI_APEI_PCIEAER=y
 CONFIG_ACPI_APEI_MEMORY_FAILURE=y
 CONFIG_ACPI_APEI_EINJ=y
+CONFIG_ACPI_AGDI=y
 CONFIG_VIRTUALIZATION=y
 CONFIG_KVM=y
 CONFIG_JUMP_LABEL=y
 CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
 # CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_MISC=y
 # CONFIG_COMPAT_BRK is not set
 CONFIG_MEMORY_HOTPLUG=y
 CONFIG_MEMORY_HOTREMOVE=y
@@ -250,6 +252,7 @@ CONFIG_BLK_DEV_DM=m
 CONFIG_DM_MIRROR=m
 CONFIG_DM_ZERO=m
 CONFIG_NETDEVICES=y
+CONFIG_OVPN=y
 CONFIG_MACVLAN=m
 CONFIG_MACVTAP=m
 CONFIG_TUN=y
@@ -329,6 +332,7 @@ CONFIG_ATH11K_AHB=m
 CONFIG_ATH11K_PCI=m
 CONFIG_ATH11K_DEBUG=y
 CONFIG_ATH12K=m
+CONFIG_ATH12K_AHB=y
 CONFIG_ATH12K_DEBUG=y
 # CONFIG_WLAN_VENDOR_ATMEL is not set
 CONFIG_BRCMFMAC=m
@@ -647,6 +651,8 @@ CONFIG_VIDEO_OV5645=m
 CONFIG_DRM=y
 CONFIG_DRM_DISPLAY_DP_AUX_CEC=y
 CONFIG_DRM_DISPLAY_DP_AUX_CHARDEV=y
+CONFIG_DRM_EFIDRM=y
+CONFIG_DRM_SIMPLEDRM=y
 CONFIG_DRM_MSM=m
 CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=m
 CONFIG_DRM_PANEL_DSI_CM=m
@@ -682,7 +688,6 @@ CONFIG_DRM_ANALOGIX_ANX7625=m
 CONFIG_DRM_I2C_ADV7511=m
 CONFIG_DRM_I2C_ADV7511_AUDIO=y
 CONFIG_DRM_CDNS_MHDP8546=m
-CONFIG_DRM_SIMPLEDRM=y
 CONFIG_FB=y
 CONFIG_FB_EFI=y
 CONFIG_FB_MODE_HELPERS=y
@@ -917,7 +922,6 @@ CONFIG_RTC_DRV_RV8803=m
 CONFIG_RTC_DRV_S5M=y
 CONFIG_RTC_DRV_DS3232=y
 CONFIG_RTC_DRV_PCF2127=m
-CONFIG_RTC_DRV_EFI=y
 CONFIG_RTC_DRV_CROS_EC=y
 CONFIG_RTC_DRV_PL031=y
 CONFIG_RTC_DRV_PM8XXX=m
@@ -1218,6 +1222,7 @@ CONFIG_CRYPTO_USER=y
 CONFIG_CRYPTO_DES=m
 CONFIG_CRYPTO_ECHAINIV=y
 CONFIG_CRYPTO_BLAKE2B=m
+CONFIG_CRYPTO_SHA256=y
 CONFIG_CRYPTO_XXHASH=m
 CONFIG_CRYPTO_DEFLATE=m
 CONFIG_CRYPTO_ZSTD=m
-- 
2.43.0


From b80b37873305b2191e914bd5238878ecdbc64e54 Mon Sep 17 00:00:00 2001
From: KancyJoe <kancy2333@outlook.com>
Date: Sun, 15 Jun 2025 04:19:22 +0000
Subject: [PATCH 39/39] arm64: dts: qcom: add uart11 for ayaneo aps. uart11 is
 bus of the gamepad's control interface.

---
 arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts | 41 ++++++++++++-------
 1 file changed, 27 insertions(+), 14 deletions(-)

diff --git a/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts b/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts
index 97488cc17d56..fb83c6937148 100644
--- a/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts
+++ b/arch/arm64/boot/dts/qcom/sm8550-ayaneo-ps.dts
@@ -28,6 +28,7 @@ / {
 	aliases {
 		serial0 = &uart7;
 		serial1 = &uart14;
+		hsuart0 = &uart11;
 		display0 = &display0;
 	};
 
@@ -1099,20 +1100,24 @@ &qupv3_id_0 {
 
 &qupv3_id_1 {
 	status = "okay";
-	/* UART seems enabled in android */
-	// uart11: uart@88c000 {
-	// 	compatible = "qcom,geni-uart";
-	// 	reg = <0 0x0088c000 0 0x4000>;
-	// 	clock-names = "se";
-	// 	clocks = <&gcc GCC_QUPV3_WRAP2_S3_CLK>;
-	// 	pinctrl-names = "default";
-	// 	pinctrl-0 = <&qup_uart11_default>;
-	// 	interrupts = <GIC_SPI 585 IRQ_TYPE_LEVEL_HIGH>;
-	// 	interconnects = <&clk_virt MASTER_QUP_CORE_2 0 &clk_virt SLAVE_QUP_CORE_2 0>,
-	// 					<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_QUP_2 0>;
-	// 	interconnect-names = "qup-core", "qup-config";
-	// 	status = "disabled";
-	// };
+	/* AYANEO Controller serial interface */
+	uart11: uart@88c000 {
+		compatible = "qcom,geni-uart";
+		reg = <0 0x0088c000 0 0x4000>;
+		clock-names = "se";
+		clocks = <&gcc GCC_QUPV3_WRAP2_S3_CLK>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&qup_uart11_default>;
+		interrupts = <GIC_SPI 585 IRQ_TYPE_LEVEL_HIGH>;
+		interconnects = <&clk_virt MASTER_QUP_CORE_2 QCOM_ICC_TAG_ALWAYS
+						 &clk_virt SLAVE_QUP_CORE_2 QCOM_ICC_TAG_ALWAYS>,
+						<&gem_noc MASTER_APPSS_PROC QCOM_ICC_TAG_ACTIVE_ONLY
+						&config_noc SLAVE_QUP_2 QCOM_ICC_TAG_ACTIVE_ONLY>;
+		interconnect-names = "qup-core", "qup-config";
+		operating-points-v2 = <&qup_opp_table_100mhz>;
+		power-domains = <&rpmhpd RPMHPD_CX>;
+		status = "okay";
+	};
 };
 
 &remoteproc_adsp {
@@ -1299,6 +1304,14 @@ qup_uart11_default: qup-uart11-default-state {
 		bias-disable;
 	};
 
+	qup_uart11_sleep: qup-uart11-sleep-state {
+		/* TX, RX */
+		pins = "gpio70", "gpio71";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	upd720201_active: upd720201-active {
 		pins = "gpio10",  "gpio13", "gpio18", "gpio52";
 		function = "gpio";
-- 
2.43.0

