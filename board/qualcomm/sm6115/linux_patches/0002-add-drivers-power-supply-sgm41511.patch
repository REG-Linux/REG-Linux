diff -u -r -N a/Documentation/devicetree/bindings/power/supply/sgmicro,sgm41511.yaml b/Documentation/devicetree/bindings/power/supply/sgmicro,sgm41511.yaml
--- a/Documentation/devicetree/bindings/power/supply/sgmicro,sgm41511.yaml	1970-01-01 01:00:00.000000000 +0100
+++ b/Documentation/devicetree/bindings/power/supply/sgmicro,sgm41511.yaml	2025-12-24 03:19:16.439915780 +0100
@@ -0,0 +1,84 @@
+# SPDX-License-Identifier: GPL-2.0
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/power/supply/sgmicro,sgm41511.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: SGMicro SGM41511 Li-Ion Battery Charger
+
+maintainers:
+  - Romain Tisserand <romain.tisserand@gmail.com>
+
+allOf:
+  - $ref: power-supply.yaml#
+
+properties:
+  compatible:
+    const: sgmicro,sgm41511
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  irq-gpios:
+    description: |
+      Optional interrupt GPIO line, when the IRQ is provided as a GPIO.
+    maxItems: 1
+
+  enable-gpios:
+    description: |
+      Active high enable pin. When asserted, charging is enabled in hardware.
+    maxItems: 1
+
+  input-current-limit-microamp:
+    description:
+      Input current limit for the charger.
+
+  input-voltage-limit-microvolt:
+    description:
+      Input voltage limit for the charger (VINDPM).
+
+  constant-charge-current-max-microamp:
+    description:
+      Maximum fast charge current (ICHG).
+
+  constant-charge-voltage-max-microvolt:
+    description:
+      Maximum charge voltage (VREG).
+
+  precharge-current-microamp:
+    description:
+      Pre-charge current limit (IPRECHG).
+
+  termination-current-microamp:
+    description:
+      Termination current limit (ITERM).
+
+required:
+  - compatible
+  - reg
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+    #include <dt-bindings/interrupt-controller/irq.h>
+
+    i2c {
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      charger@1a {
+        compatible = "sgmicro,sgm41511";
+        reg = <0x1a>;
+        interrupt-parent = <&tlmm>;
+        interrupts = <70 IRQ_TYPE_LEVEL_LOW>;
+        enable-gpios = <&tlmm 85 GPIO_ACTIVE_HIGH>;
+        input-current-limit-microamp = <2400000>;
+        constant-charge-current-max-microamp = <2040000>;
+        constant-charge-voltage-max-microvolt = <4208000>;
+      };
+    };
diff -u -r -N a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
--- a/drivers/power/supply/Kconfig	2025-12-18 14:03:43.000000000 +0100
+++ b/drivers/power/supply/Kconfig	2025-12-24 03:18:31.587283650 +0100
@@ -797,6 +797,14 @@
 	help
 	  Say Y to enable support for the TI BQ25890 battery charger.
 
+config CHARGER_SGM41511
+	tristate "SGMicro SGM41511 battery charger driver"
+	depends on I2C
+	depends on GPIOLIB || COMPILE_TEST
+	select REGMAP_I2C
+	help
+	  Say Y to enable support for the SGMicro SGM41511 battery charger.
+
 config CHARGER_BQ25980
 	tristate "TI BQ25980 battery charger driver"
 	depends on I2C
diff -u -r -N a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
--- a/drivers/power/supply/Makefile	2025-12-18 14:03:43.000000000 +0100
+++ b/drivers/power/supply/Makefile	2025-12-24 03:18:41.122624882 +0100
@@ -101,6 +101,7 @@
 obj-$(CONFIG_CHARGER_BQ2515X)	+= bq2515x_charger.o
 obj-$(CONFIG_CHARGER_BQ257XX)	+= bq257xx_charger.o
 obj-$(CONFIG_CHARGER_BQ25890)	+= bq25890_charger.o
+obj-$(CONFIG_CHARGER_SGM41511)	+= sgm41511_charger.o
 obj-$(CONFIG_CHARGER_BQ25980)	+= bq25980_charger.o
 obj-$(CONFIG_CHARGER_BQ256XX)	+= bq256xx_charger.o
 obj-$(CONFIG_CHARGER_RK817)	+= rk817_charger.o
diff -u -r -N a/drivers/power/supply/sgm41511_charger.c b/drivers/power/supply/sgm41511_charger.c
--- a/drivers/power/supply/sgm41511_charger.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/power/supply/sgm41511_charger.c	2025-12-24 03:18:16.644755655 +0100
@@ -0,0 +1,750 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * SGMicro SGM41511 I2C Charger Driver
+ *
+ * Copyright (c) 2025
+ */
+
+#include <linux/bitfield.h>
+#include <linux/bitops.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/power_supply.h>
+#include <linux/regmap.h>
+
+#define SGM41511_REG_00			0x00
+#define SGM41511_REG_01			0x01
+#define SGM41511_REG_02			0x02
+#define SGM41511_REG_03			0x03
+#define SGM41511_REG_04			0x04
+#define SGM41511_REG_05			0x05
+#define SGM41511_REG_06			0x06
+#define SGM41511_REG_07			0x07
+#define SGM41511_REG_08			0x08
+#define SGM41511_REG_09			0x09
+#define SGM41511_REG_0A			0x0a
+#define SGM41511_REG_0B			0x0b
+
+#define SGM41511_PN_SGM41511		0x2
+
+#define SGM41511_IINDPM_MIN_UA		100000
+#define SGM41511_IINDPM_STEP_UA		100000
+#define SGM41511_IINDPM_MAX_REG		31
+
+#define SGM41511_ICHG_STEP_UA		60000
+#define SGM41511_ICHG_MAX_REG		50
+
+#define SGM41511_PRECHG_OFFSET_UA	60000
+#define SGM41511_PRECHG_STEP_UA		60000
+#define SGM41511_PRECHG_MAX_REG		12
+
+#define SGM41511_ITERM_OFFSET_UA	60000
+#define SGM41511_ITERM_STEP_UA		60000
+#define SGM41511_ITERM_MAX_REG		15
+
+#define SGM41511_VREG_MIN_UV		3856000
+#define SGM41511_VREG_STEP_UV		32000
+#define SGM41511_VREG_MAX_REG		24
+#define SGM41511_VREG_SPECIAL_REG	15
+#define SGM41511_VREG_SPECIAL_UV	4352000
+
+#define SGM41511_VINDPM_MIN_UV		3900000
+#define SGM41511_VINDPM_STEP_UV		100000
+#define SGM41511_VINDPM_MAX_REG		15
+
+enum sgm41511_fields {
+	F_EN_HIZ,
+	F_IINDPM,
+	F_PFM_DIS,
+	F_WD_RST,
+	F_OTG_CONFIG,
+	F_CHG_CONFIG,
+	F_ICHG,
+	F_IPRECHG,
+	F_ITERM,
+	F_VREG,
+	F_WATCHDOG,
+	F_VINDPM,
+	F_VBUS_STAT,
+	F_CHRG_STAT,
+	F_PG_STAT,
+	F_THERM_STAT,
+	F_VSYS_STAT,
+	F_WATCHDOG_FAULT,
+	F_BOOST_FAULT,
+	F_CHRG_FAULT,
+	F_BAT_FAULT,
+	F_NTC_FAULT,
+	F_VBUS_GD,
+	F_VINDPM_STAT,
+	F_IINDPM_STAT,
+	F_ACOV_STAT,
+	F_VINDPM_INT_MASK,
+	F_IINDPM_INT_MASK,
+	F_REG_RST,
+	F_PN,
+	F_DEV_REV,
+	F_MAX_FIELDS
+};
+
+static const struct reg_field sgm41511_reg_fields[] = {
+	[F_EN_HIZ]		= REG_FIELD(SGM41511_REG_00, 7, 7),
+	[F_IINDPM]		= REG_FIELD(SGM41511_REG_00, 4, 0),
+	[F_PFM_DIS]		= REG_FIELD(SGM41511_REG_01, 7, 7),
+	[F_WD_RST]		= REG_FIELD(SGM41511_REG_01, 6, 6),
+	[F_OTG_CONFIG]		= REG_FIELD(SGM41511_REG_01, 5, 5),
+	[F_CHG_CONFIG]		= REG_FIELD(SGM41511_REG_01, 4, 4),
+	[F_ICHG]		= REG_FIELD(SGM41511_REG_02, 5, 0),
+	[F_IPRECHG]		= REG_FIELD(SGM41511_REG_03, 7, 4),
+	[F_ITERM]		= REG_FIELD(SGM41511_REG_03, 3, 0),
+	[F_VREG]		= REG_FIELD(SGM41511_REG_04, 7, 3),
+	[F_WATCHDOG]		= REG_FIELD(SGM41511_REG_05, 5, 4),
+	[F_VINDPM]		= REG_FIELD(SGM41511_REG_06, 3, 0),
+	[F_VBUS_STAT]		= REG_FIELD(SGM41511_REG_08, 7, 5),
+	[F_CHRG_STAT]		= REG_FIELD(SGM41511_REG_08, 4, 3),
+	[F_PG_STAT]		= REG_FIELD(SGM41511_REG_08, 2, 2),
+	[F_THERM_STAT]		= REG_FIELD(SGM41511_REG_08, 1, 1),
+	[F_VSYS_STAT]		= REG_FIELD(SGM41511_REG_08, 0, 0),
+	[F_WATCHDOG_FAULT]	= REG_FIELD(SGM41511_REG_09, 7, 7),
+	[F_BOOST_FAULT]		= REG_FIELD(SGM41511_REG_09, 6, 6),
+	[F_CHRG_FAULT]		= REG_FIELD(SGM41511_REG_09, 5, 4),
+	[F_BAT_FAULT]		= REG_FIELD(SGM41511_REG_09, 3, 3),
+	[F_NTC_FAULT]		= REG_FIELD(SGM41511_REG_09, 2, 0),
+	[F_VBUS_GD]		= REG_FIELD(SGM41511_REG_0A, 7, 7),
+	[F_VINDPM_STAT]		= REG_FIELD(SGM41511_REG_0A, 6, 6),
+	[F_IINDPM_STAT]		= REG_FIELD(SGM41511_REG_0A, 5, 5),
+	[F_ACOV_STAT]		= REG_FIELD(SGM41511_REG_0A, 2, 2),
+	[F_VINDPM_INT_MASK]	= REG_FIELD(SGM41511_REG_0A, 1, 1),
+	[F_IINDPM_INT_MASK]	= REG_FIELD(SGM41511_REG_0A, 0, 0),
+	[F_REG_RST]		= REG_FIELD(SGM41511_REG_0B, 7, 7),
+	[F_PN]			= REG_FIELD(SGM41511_REG_0B, 6, 3),
+	[F_DEV_REV]		= REG_FIELD(SGM41511_REG_0B, 1, 0),
+};
+
+#define SGM41511_NUM_FIELDS	ARRAY_SIZE(sgm41511_reg_fields)
+
+BUILD_BUG_ON(SGM41511_NUM_FIELDS != F_MAX_FIELDS);
+
+struct sgm41511_device {
+	struct device *dev;
+	struct regmap *regmap;
+	struct regmap_field *rmap_fields[SGM41511_NUM_FIELDS];
+	struct power_supply *psy;
+	struct power_supply_desc psy_desc;
+	struct gpio_desc *enable_gpiod;
+	int irq;
+};
+
+static const struct regmap_range sgm41511_readonly_ranges[] = {
+	regmap_reg_range(SGM41511_REG_08, SGM41511_REG_09),
+};
+
+static const struct regmap_access_table sgm41511_writeable_regs = {
+	.no_ranges = sgm41511_readonly_ranges,
+	.n_no_ranges = ARRAY_SIZE(sgm41511_readonly_ranges),
+};
+
+static const struct regmap_range sgm41511_volatile_ranges[] = {
+	regmap_reg_range(SGM41511_REG_08, SGM41511_REG_0A),
+};
+
+static const struct regmap_access_table sgm41511_volatile_regs = {
+	.yes_ranges = sgm41511_volatile_ranges,
+	.n_yes_ranges = ARRAY_SIZE(sgm41511_volatile_ranges),
+};
+
+static const struct regmap_config sgm41511_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = SGM41511_REG_0B,
+	.wr_table = &sgm41511_writeable_regs,
+	.volatile_table = &sgm41511_volatile_regs,
+};
+
+static int sgm41511_field_read(struct sgm41511_device *sgm,
+			       enum sgm41511_fields field, u8 *val)
+{
+	unsigned int tmp;
+	int ret;
+
+	ret = regmap_field_read(sgm->rmap_fields[field], &tmp);
+	if (ret < 0)
+		return ret;
+
+	*val = tmp;
+	return 0;
+}
+
+static int sgm41511_field_write(struct sgm41511_device *sgm,
+				enum sgm41511_fields field, u8 val)
+{
+	return regmap_field_write(sgm->rmap_fields[field], val);
+}
+
+static u8 sgm41511_iindpm_ua_to_reg(u32 ua)
+{
+	u32 ma = ua / 1000;
+	u32 reg;
+
+	if (ma <= 100)
+		return 0;
+
+	reg = (ma - 100) / 100;
+	return min_t(u32, reg, SGM41511_IINDPM_MAX_REG);
+}
+
+static int sgm41511_iindpm_reg_to_ua(u8 reg)
+{
+	return (SGM41511_IINDPM_MIN_UA + reg * SGM41511_IINDPM_STEP_UA);
+}
+
+static u8 sgm41511_ichg_ua_to_reg(u32 ua)
+{
+	u32 reg = ua / SGM41511_ICHG_STEP_UA;
+
+	return min_t(u32, reg, SGM41511_ICHG_MAX_REG);
+}
+
+static int sgm41511_ichg_reg_to_ua(u8 reg)
+{
+	return reg * SGM41511_ICHG_STEP_UA;
+}
+
+static u8 sgm41511_iprechg_ua_to_reg(u32 ua)
+{
+	u32 reg;
+
+	if (ua <= SGM41511_PRECHG_OFFSET_UA)
+		return 0;
+
+	reg = (ua - SGM41511_PRECHG_OFFSET_UA) / SGM41511_PRECHG_STEP_UA;
+	return min_t(u32, reg, SGM41511_PRECHG_MAX_REG);
+}
+
+static int sgm41511_iprechg_reg_to_ua(u8 reg)
+{
+	return SGM41511_PRECHG_OFFSET_UA + reg * SGM41511_PRECHG_STEP_UA;
+}
+
+static u8 sgm41511_iterm_ua_to_reg(u32 ua)
+{
+	u32 reg;
+
+	if (ua <= SGM41511_ITERM_OFFSET_UA)
+		return 0;
+
+	reg = (ua - SGM41511_ITERM_OFFSET_UA) / SGM41511_ITERM_STEP_UA;
+	return min_t(u32, reg, SGM41511_ITERM_MAX_REG);
+}
+
+static int sgm41511_iterm_reg_to_ua(u8 reg)
+{
+	return SGM41511_ITERM_OFFSET_UA + reg * SGM41511_ITERM_STEP_UA;
+}
+
+static int sgm41511_vreg_reg_to_uv(u8 reg)
+{
+	if (reg == SGM41511_VREG_SPECIAL_REG)
+		return SGM41511_VREG_SPECIAL_UV;
+
+	return SGM41511_VREG_MIN_UV + reg * SGM41511_VREG_STEP_UV;
+}
+
+static u8 sgm41511_vreg_uv_to_reg(u32 uv)
+{
+	u8 reg;
+	int val;
+
+	if (uv <= SGM41511_VREG_MIN_UV)
+		return 0;
+	if (uv >= SGM41511_VREG_MIN_UV +
+		    SGM41511_VREG_STEP_UV * SGM41511_VREG_MAX_REG)
+		return SGM41511_VREG_MAX_REG;
+
+	for (reg = 0; reg <= SGM41511_VREG_MAX_REG; reg++) {
+		val = sgm41511_vreg_reg_to_uv(reg);
+		if (val > uv)
+			break;
+	}
+
+	return reg ? reg - 1 : 0;
+}
+
+static u8 sgm41511_vindpm_uv_to_reg(u32 uv)
+{
+	u32 reg;
+
+	if (uv <= SGM41511_VINDPM_MIN_UV)
+		return 0;
+
+	reg = (uv - SGM41511_VINDPM_MIN_UV) / SGM41511_VINDPM_STEP_UV;
+	return min_t(u32, reg, SGM41511_VINDPM_MAX_REG);
+}
+
+static int sgm41511_vindpm_reg_to_uv(u8 reg)
+{
+	return SGM41511_VINDPM_MIN_UV + reg * SGM41511_VINDPM_STEP_UV;
+}
+
+static int sgm41511_get_online(struct sgm41511_device *sgm, bool *online)
+{
+	u8 val;
+	int ret;
+
+	ret = sgm41511_field_read(sgm, F_VBUS_GD, &val);
+	if (ret < 0)
+		return ret;
+
+	*online = !!val;
+	return 0;
+}
+
+static int sgm41511_get_charge_status(struct sgm41511_device *sgm, int *status)
+{
+	u8 chrg_stat;
+	bool online;
+	int ret;
+
+	ret = sgm41511_get_online(sgm, &online);
+	if (ret < 0)
+		return ret;
+
+	if (!online) {
+		*status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		return 0;
+	}
+
+	ret = sgm41511_field_read(sgm, F_CHRG_STAT, &chrg_stat);
+	if (ret < 0)
+		return ret;
+
+	switch (chrg_stat) {
+	case 0x1:
+	case 0x2:
+		*status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case 0x3:
+		*status = POWER_SUPPLY_STATUS_FULL;
+		break;
+	default:
+		*status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	}
+
+	return 0;
+}
+
+static int sgm41511_get_charge_type(struct sgm41511_device *sgm, int *type)
+{
+	u8 chrg_stat;
+	int ret;
+
+	ret = sgm41511_field_read(sgm, F_CHRG_STAT, &chrg_stat);
+	if (ret < 0)
+		return ret;
+
+	switch (chrg_stat) {
+	case 0x1:
+		*type = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+		break;
+	case 0x2:
+		*type = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	default:
+		*type = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		break;
+	}
+
+	return 0;
+}
+
+static int sgm41511_get_health(struct sgm41511_device *sgm, int *health)
+{
+	u8 watchdog_fault;
+	u8 boost_fault;
+	u8 chrg_fault;
+	u8 bat_fault;
+	u8 ntc_fault;
+	int ret;
+
+	ret = sgm41511_field_read(sgm, F_WATCHDOG_FAULT, &watchdog_fault);
+	if (ret < 0)
+		return ret;
+	ret = sgm41511_field_read(sgm, F_BOOST_FAULT, &boost_fault);
+	if (ret < 0)
+		return ret;
+	ret = sgm41511_field_read(sgm, F_CHRG_FAULT, &chrg_fault);
+	if (ret < 0)
+		return ret;
+	ret = sgm41511_field_read(sgm, F_BAT_FAULT, &bat_fault);
+	if (ret < 0)
+		return ret;
+	ret = sgm41511_field_read(sgm, F_NTC_FAULT, &ntc_fault);
+	if (ret < 0)
+		return ret;
+
+	if (watchdog_fault)
+		*health = POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE;
+	else if (chrg_fault == 0x2)
+		*health = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (chrg_fault == 0x3)
+		*health = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;
+	else if (boost_fault)
+		*health = POWER_SUPPLY_HEALTH_OVERCURRENT;
+	else if (bat_fault)
+		*health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	else if (ntc_fault == 0x6)
+		*health = POWER_SUPPLY_HEALTH_HOT;
+	else if (ntc_fault == 0x5)
+		*health = POWER_SUPPLY_HEALTH_COLD;
+	else if (ntc_fault == 0x2)
+		*health = POWER_SUPPLY_HEALTH_WARM;
+	else if (ntc_fault == 0x3)
+		*health = POWER_SUPPLY_HEALTH_COOL;
+	else if (chrg_fault == 0x1)
+		*health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+	else
+		*health = POWER_SUPPLY_HEALTH_GOOD;
+
+	return 0;
+}
+
+static int sgm41511_get_usb_type(struct sgm41511_device *sgm,
+				 enum power_supply_usb_type *type)
+{
+	u8 vbus_stat;
+	int ret;
+
+	ret = sgm41511_field_read(sgm, F_VBUS_STAT, &vbus_stat);
+	if (ret < 0)
+		return ret;
+
+	switch (vbus_stat) {
+	case 0x1:
+		*type = POWER_SUPPLY_USB_TYPE_SDP;
+		break;
+	case 0x2:
+		*type = POWER_SUPPLY_USB_TYPE_DCP;
+		break;
+	default:
+		*type = POWER_SUPPLY_USB_TYPE_UNKNOWN;
+		break;
+	}
+
+	return 0;
+}
+
+static int sgm41511_power_supply_get_property(struct power_supply *psy,
+					      enum power_supply_property psp,
+					      union power_supply_propval *val)
+{
+	struct sgm41511_device *sgm = power_supply_get_drvdata(psy);
+	enum power_supply_usb_type usb_type;
+	u8 reg;
+	bool online;
+	int ret;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		return sgm41511_get_charge_status(sgm, &val->intval);
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		return sgm41511_get_charge_type(sgm, &val->intval);
+	case POWER_SUPPLY_PROP_ONLINE:
+		ret = sgm41511_get_online(sgm, &online);
+		if (ret < 0)
+			return ret;
+		val->intval = online;
+		return 0;
+	case POWER_SUPPLY_PROP_HEALTH:
+		return sgm41511_get_health(sgm, &val->intval);
+	case POWER_SUPPLY_PROP_USB_TYPE:
+		ret = sgm41511_get_usb_type(sgm, &usb_type);
+		if (ret < 0)
+			return ret;
+		val->intval = usb_type;
+		return 0;
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+		ret = sgm41511_field_read(sgm, F_IINDPM, &reg);
+		if (ret < 0)
+			return ret;
+		val->intval = sgm41511_iindpm_reg_to_ua(reg);
+		return 0;
+	case POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:
+		ret = sgm41511_field_read(sgm, F_VINDPM, &reg);
+		if (ret < 0)
+			return ret;
+		val->intval = sgm41511_vindpm_reg_to_uv(reg);
+		return 0;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
+		ret = sgm41511_field_read(sgm, F_ICHG, &reg);
+		if (ret < 0)
+			return ret;
+		val->intval = sgm41511_ichg_reg_to_ua(reg);
+		return 0;
+	case POWER_SUPPLY_PROP_PRECHARGE_CURRENT:
+		ret = sgm41511_field_read(sgm, F_IPRECHG, &reg);
+		if (ret < 0)
+			return ret;
+		val->intval = sgm41511_iprechg_reg_to_ua(reg);
+		return 0;
+	case POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:
+		ret = sgm41511_field_read(sgm, F_ITERM, &reg);
+		if (ret < 0)
+			return ret;
+		val->intval = sgm41511_iterm_reg_to_ua(reg);
+		return 0;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
+		ret = sgm41511_field_read(sgm, F_VREG, &reg);
+		if (ret < 0)
+			return ret;
+		val->intval = sgm41511_vreg_reg_to_uv(reg);
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int sgm41511_power_supply_set_property(struct power_supply *psy,
+					      enum power_supply_property psp,
+					      const union power_supply_propval *val)
+{
+	struct sgm41511_device *sgm = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+		return sgm41511_field_write(sgm, F_IINDPM,
+					    sgm41511_iindpm_ua_to_reg(val->intval));
+	case POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:
+		return sgm41511_field_write(sgm, F_VINDPM,
+					    sgm41511_vindpm_uv_to_reg(val->intval));
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
+		return sgm41511_field_write(sgm, F_ICHG,
+					    sgm41511_ichg_ua_to_reg(val->intval));
+	case POWER_SUPPLY_PROP_PRECHARGE_CURRENT:
+		return sgm41511_field_write(sgm, F_IPRECHG,
+					    sgm41511_iprechg_ua_to_reg(val->intval));
+	case POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:
+		return sgm41511_field_write(sgm, F_ITERM,
+					    sgm41511_iterm_ua_to_reg(val->intval));
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
+		return sgm41511_field_write(sgm, F_VREG,
+					    sgm41511_vreg_uv_to_reg(val->intval));
+	default:
+		return -EINVAL;
+	}
+}
+
+static int sgm41511_power_supply_property_is_writeable(struct power_supply *psy,
+						       enum power_supply_property psp)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+	case POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
+	case POWER_SUPPLY_PROP_PRECHARGE_CURRENT:
+	case POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
+	default:
+		return 0;
+	}
+}
+
+static enum power_supply_property sgm41511_power_supply_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_USB_TYPE,
+	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
+	POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,
+	POWER_SUPPLY_PROP_PRECHARGE_CURRENT,
+	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,
+};
+
+static irqreturn_t sgm41511_irq_handler_thread(int irq, void *data)
+{
+	struct sgm41511_device *sgm = data;
+	unsigned int val;
+
+	regmap_read(sgm->regmap, SGM41511_REG_09, &val);
+	power_supply_changed(sgm->psy);
+
+	return IRQ_HANDLED;
+}
+
+static int sgm41511_apply_dt_props(struct sgm41511_device *sgm)
+{
+	struct device *dev = sgm->dev;
+	u32 val;
+	int ret;
+
+	if (!device_property_read_u32(dev, "input-current-limit-microamp", &val)) {
+		ret = sgm41511_field_write(sgm, F_IINDPM,
+					   sgm41511_iindpm_ua_to_reg(val));
+		if (ret)
+			return ret;
+	}
+
+	if (!device_property_read_u32(dev, "input-voltage-limit-microvolt", &val)) {
+		ret = sgm41511_field_write(sgm, F_VINDPM,
+					   sgm41511_vindpm_uv_to_reg(val));
+		if (ret)
+			return ret;
+	}
+
+	if (!device_property_read_u32(dev, "constant-charge-current-max-microamp", &val)) {
+		ret = sgm41511_field_write(sgm, F_ICHG,
+					   sgm41511_ichg_ua_to_reg(val));
+		if (ret)
+			return ret;
+	}
+
+	if (!device_property_read_u32(dev, "constant-charge-voltage-max-microvolt", &val)) {
+		ret = sgm41511_field_write(sgm, F_VREG,
+					   sgm41511_vreg_uv_to_reg(val));
+		if (ret)
+			return ret;
+	}
+
+	if (!device_property_read_u32(dev, "precharge-current-microamp", &val)) {
+		ret = sgm41511_field_write(sgm, F_IPRECHG,
+					   sgm41511_iprechg_ua_to_reg(val));
+		if (ret)
+			return ret;
+	}
+
+	if (!device_property_read_u32(dev, "termination-current-microamp", &val)) {
+		ret = sgm41511_field_write(sgm, F_ITERM,
+					   sgm41511_iterm_ua_to_reg(val));
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int sgm41511_hw_init(struct sgm41511_device *sgm)
+{
+	int ret;
+
+	ret = sgm41511_field_write(sgm, F_REG_RST, 1);
+	if (ret < 0)
+		return ret;
+
+	ret = sgm41511_field_write(sgm, F_WATCHDOG, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = sgm41511_field_write(sgm, F_CHG_CONFIG, 1);
+	if (ret < 0)
+		return ret;
+
+	return sgm41511_apply_dt_props(sgm);
+}
+
+static int sgm41511_init_power_supply(struct sgm41511_device *sgm)
+{
+	sgm->psy_desc.name = "sgm41511-charger";
+	sgm->psy_desc.type = POWER_SUPPLY_TYPE_USB;
+	sgm->psy_desc.properties = sgm41511_power_supply_props;
+	sgm->psy_desc.num_properties = ARRAY_SIZE(sgm41511_power_supply_props);
+	sgm->psy_desc.get_property = sgm41511_power_supply_get_property;
+	sgm->psy_desc.set_property = sgm41511_power_supply_set_property;
+	sgm->psy_desc.property_is_writeable = sgm41511_power_supply_property_is_writeable;
+	sgm->psy_desc.usb_types = BIT(POWER_SUPPLY_USB_TYPE_UNKNOWN) |
+				  BIT(POWER_SUPPLY_USB_TYPE_SDP) |
+				  BIT(POWER_SUPPLY_USB_TYPE_DCP);
+
+	sgm->psy = devm_power_supply_register(sgm->dev, &sgm->psy_desc, NULL);
+	return PTR_ERR_OR_ZERO(sgm->psy);
+}
+
+static int sgm41511_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct sgm41511_device *sgm;
+	u8 pn;
+	int ret;
+	int i;
+
+	sgm = devm_kzalloc(dev, sizeof(*sgm), GFP_KERNEL);
+	if (!sgm)
+		return -ENOMEM;
+
+	sgm->dev = dev;
+	i2c_set_clientdata(client, sgm);
+
+	sgm->regmap = devm_regmap_init_i2c(client, &sgm41511_regmap_config);
+	if (IS_ERR(sgm->regmap))
+		return dev_err_probe(dev, PTR_ERR(sgm->regmap),
+				     "Failed to init regmap\n");
+
+	for (i = 0; i < SGM41511_NUM_FIELDS; i++) {
+		sgm->rmap_fields[i] = devm_regmap_field_alloc(dev, sgm->regmap,
+							     sgm41511_reg_fields[i]);
+		if (IS_ERR(sgm->rmap_fields[i]))
+			return dev_err_probe(dev, PTR_ERR(sgm->rmap_fields[i]),
+					     "Failed to alloc reg field %d\n", i);
+	}
+
+	ret = sgm41511_field_read(sgm, F_PN, &pn);
+	if (ret < 0)
+		return ret;
+	if (pn != SGM41511_PN_SGM41511)
+		dev_warn(dev, "Unexpected part ID 0x%x\n", pn);
+
+	sgm->enable_gpiod = devm_gpiod_get_optional(dev, "enable", GPIOD_OUT_HIGH);
+	if (IS_ERR(sgm->enable_gpiod))
+		return dev_err_probe(dev, PTR_ERR(sgm->enable_gpiod),
+				     "Failed to get enable gpio\n");
+
+	ret = sgm41511_hw_init(sgm);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to init charger\n");
+
+	ret = sgm41511_init_power_supply(sgm);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to register power supply\n");
+
+	if (client->irq > 0) {
+		ret = devm_request_threaded_irq(dev, client->irq, NULL,
+						sgm41511_irq_handler_thread,
+						IRQF_ONESHOT,
+						"sgm41511", sgm);
+		if (ret)
+			return dev_err_probe(dev, ret, "Failed to request IRQ\n");
+	}
+
+	return 0;
+}
+
+static const struct of_device_id sgm41511_of_match[] = {
+	{ .compatible = "sgmicro,sgm41511" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, sgm41511_of_match);
+
+static const struct i2c_device_id sgm41511_i2c_ids[] = {
+	{ "sgm41511" },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sgm41511_i2c_ids);
+
+static struct i2c_driver sgm41511_driver = {
+	.driver = {
+		.name = "sgm41511-charger",
+		.of_match_table = sgm41511_of_match,
+	},
+	.probe = sgm41511_probe,
+	.id_table = sgm41511_i2c_ids,
+};
+module_i2c_driver(sgm41511_driver);
+
+MODULE_DESCRIPTION("SGMicro SGM41511 charger driver");
+MODULE_LICENSE("GPL");
