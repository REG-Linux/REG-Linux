From e05ed5ba9b2d6d6dd579f318768aa9aeb0441141 Mon Sep 17 00:00:00 2001
From: Philippe Simons <simons.philippe@gmail.com>
Date: Sat, 5 Jul 2025 23:02:03 +0200
Subject: [PATCH] regulator: add sgm3804 i2c regulator for panel power
 management.


Add sgm3804 regulator support used for panel power.

Signed-off-by: Romain Tisserand <romain.tisserand@gmail.com>

---
 drivers/regulator/Kconfig             |   6 +
 drivers/regulator/Makefile            |   1 +
 drivers/regulator/sgm3804-regulator.c | 175 ++++++++++++++++++++++++++
 3 files changed, 182 insertions(+)
 create mode 100644 drivers/regulator/sgm3804-regulator.c

diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 05e32d764028..631a0ad98724 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -1353,6 +1353,12 @@ config REGULATOR_SC2731
 	  This driver provides support for the voltage regulators on the
 	  SC2731 PMIC.
 
+config REGULATOR_SGM3804
+	tristate "SGMicro sgm3804 voltage regulator"
+	depends on I2C && OF
+	help
+	  This driver supports SGMicro sgm3804 voltage regulator.
+
 config REGULATOR_SKY81452
 	tristate "Skyworks Solutions SKY81452 voltage regulator"
 	depends on MFD_SKY81452
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 524e026c0273..8b6925a159a3 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -158,6 +158,7 @@ obj-$(CONFIG_REGULATOR_S2MPA01) += s2mpa01.o
 obj-$(CONFIG_REGULATOR_S2MPS11) += s2mps11.o
 obj-$(CONFIG_REGULATOR_S5M8767) += s5m8767.o
 obj-$(CONFIG_REGULATOR_SC2731) += sc2731-regulator.o
+obj-$(CONFIG_REGULATOR_SGM3804) += sgm3804-regulator.o
 obj-$(CONFIG_REGULATOR_SKY81452) += sky81452-regulator.o
 obj-$(CONFIG_REGULATOR_SLG51000) += slg51000-regulator.o
 obj-$(CONFIG_REGULATOR_STM32_BOOSTER) += stm32-booster.o
diff --git a/drivers/regulator/sgm3804-regulator.c b/drivers/regulator/sgm3804-regulator.c
new file mode 100644
index 000000000000..0002c24e9f2c
--- /dev/null
+++ b/drivers/regulator/sgm3804-regulator.c
@@ -0,0 +1,227 @@
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of.h>
+
+struct sgm3804_data {
+    struct regmap *regmap;
+    struct gpio_desc *reset_gpio[2];
+    int enable_count;
+};
+
+static const struct regmap_config sgm3804_regmap_config = {
+    .reg_bits = 8,
+    .val_bits = 8,
+    .max_register = 0x03,
+};
+
+static int sgm3804_hw_enable(struct regulator_dev *rdev)
+{
+    struct sgm3804_data *data = rdev_get_drvdata(rdev);
+    struct regmap *regmap = data->regmap;
+    int ret = 0;
+
+    if (data->enable_count++ > 0)
+        return 0;
+
+    /* Set reset GPIO high to enable the device if available */
+    if (data->reset_gpio[0]) {
+        gpiod_set_value_cansleep(data->reset_gpio[0], 1);
+    }
+    if (data->reset_gpio[1]) {
+        gpiod_set_value_cansleep(data->reset_gpio[1], 1);
+    }
+
+    /* Set both rails to +/-5.5V (code 0x0F) */
+    ret |= regmap_write(regmap, 0x00, 0x0f);
+    ret |= regmap_write(regmap, 0x01, 0x0f);
+    ret |= regmap_write(regmap, 0x03, 0x03);
+    if (ret) {
+        dev_err(rdev->dev.parent, "Failed to enable SGM3804 regulator\n");
+        data->enable_count--;
+        return ret;
+    }
+
+    return 0;
+}
+
+static int sgm3804_hw_disable(struct regulator_dev *rdev)
+{
+    struct sgm3804_data *data = rdev_get_drvdata(rdev);
+
+    if (data->enable_count <= 0)
+        return 0;
+    if (--data->enable_count > 0)
+        return 0;
+
+    if (data->reset_gpio[0]) {
+        gpiod_set_value_cansleep(data->reset_gpio[0], 0);
+    }
+    if (data->reset_gpio[1]) {
+        gpiod_set_value_cansleep(data->reset_gpio[1], 0);
+    }
+
+    return 0;
+}
+
+static int sgm3804_enable(struct regulator_dev *rdev)
+{
+    return sgm3804_hw_enable(rdev);
+}
+
+static int sgm3804_disable(struct regulator_dev *rdev)
+{
+    return sgm3804_hw_disable(rdev);
+}
+
+static int sgm3804_is_enabled(struct regulator_dev *rdev)
+{
+    struct sgm3804_data *data = rdev_get_drvdata(rdev);
+    return data->enable_count > 0;
+}
+
+static int sgm3804_get_voltage(struct regulator_dev *rdev)
+{
+    return 5500000;
+}
+
+static const struct regulator_ops sgm3804_ops = {
+    .enable = sgm3804_enable,
+    .disable = sgm3804_disable,
+    .is_enabled = sgm3804_is_enabled,
+    .get_voltage = sgm3804_get_voltage,
+};
+
+static const struct regulator_desc sgm3804_regulators[] = {
+{
+    .name = "sgm3804-vpos",
+    .id = 0,
+    .ops = &sgm3804_ops,
+    .type = REGULATOR_VOLTAGE,
+    .n_voltages = 1,
+    .min_uV = 5500000,
+    .owner = THIS_MODULE,
+},
+{
+    .name = "sgm3804-vneg",
+    .id = 1,
+    .ops = &sgm3804_ops,
+    .type = REGULATOR_VOLTAGE,
+    .n_voltages = 1,
+    .min_uV = 5500000,
+    .owner = THIS_MODULE,
+},
+};
+
+static int sgm3804_i2c_probe(struct i2c_client *i2c)
+{
+    struct device *dev = &i2c->dev;
+    struct regulator_config config = { };
+    struct regulator_dev *rdev;
+    struct of_regulator_match matches[] = {
+        { .name = "vpos" },
+        { .name = "vneg" },
+    };
+    struct device_node *regulators;
+    struct sgm3804_data *data;
+    int error;
+    int i;
+
+    data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+    if (!data)
+        return -ENOMEM;
+
+    data->regmap = devm_regmap_init_i2c(i2c, &sgm3804_regmap_config);
+    if (IS_ERR(data->regmap))
+        return dev_err_probe(dev, PTR_ERR(data->regmap), "failed to init regmap\n");
+
+    /* Get reset-gpio from device tree */
+    data->reset_gpio[0] = devm_gpiod_get_index(dev, "reset", 0, GPIOD_OUT_HIGH);
+    if (IS_ERR(data->reset_gpio[0]))
+        return dev_err_probe(dev, PTR_ERR(data->reset_gpio[0]), "failed to get first reset GPIO\n");
+
+    data->reset_gpio[1] = devm_gpiod_get_index(dev, "reset", 1, GPIOD_OUT_HIGH);
+    if (IS_ERR(data->reset_gpio[1]))
+        dev_warn(dev, "failed to get second reset GPIO\n");
+
+    regulators = of_get_child_by_name(dev->of_node, "regulators");
+    if (regulators) {
+        error = of_regulator_match(dev, regulators, matches,
+                                   ARRAY_SIZE(matches));
+        of_node_put(regulators);
+        if (error < 0)
+            return dev_err_probe(dev, error, "Failed to match regulators\n");
+
+        for (i = 0; i < ARRAY_SIZE(matches); i++) {
+            if (!matches[i].init_data || !matches[i].of_node)
+                return dev_err_probe(dev, -EINVAL,
+                                     "Missing regulator data for %s\n",
+                                     matches[i].name);
+
+            config.dev = dev;
+            config.regmap = data->regmap;
+            config.driver_data = data;
+            config.of_node = matches[i].of_node;
+            config.init_data = matches[i].init_data;
+
+            rdev = devm_regulator_register(dev, &sgm3804_regulators[i], &config);
+            if (IS_ERR(rdev)) {
+                error = PTR_ERR(rdev);
+                dev_err(dev, "Failed to register %s regulator: %d\n",
+                        matches[i].name, error);
+                return error;
+            }
+        }
+    } else {
+        config.dev = dev;
+        config.regmap = data->regmap;
+        config.driver_data = data;
+        config.of_node = dev->of_node;
+        config.init_data = of_get_regulator_init_data(dev, dev->of_node,
+                                                      &sgm3804_regulators[0]);
+        if (!config.init_data)
+            return -ENOMEM;
+
+        rdev = devm_regulator_register(dev, &sgm3804_regulators[0], &config);
+        if (IS_ERR(rdev)) {
+            error = PTR_ERR(rdev);
+            dev_err(dev, "Failed to register SGM3804 regulator: %d\n", error);
+            return error;
+        }
+    }
+
+    return 0;
+}
+
+static const struct i2c_device_id sgm3804_i2c_id[] = {
+    { "sgm3804" },
+    { }
+};
+MODULE_DEVICE_TABLE(i2c, sgm3804_i2c_id);
+
+static const struct of_device_id sgm3804_i2c_of_match[] = {
+    { .compatible = "sgmicro,sgm3804" },
+    { }
+};
+MODULE_DEVICE_TABLE(of, sgm3804_i2c_of_match);
+
+static struct i2c_driver sgm3804_regulator_driver = {
+    .driver = {
+        .name = "sgm3804",
+        .probe_type = PROBE_PREFER_ASYNCHRONOUS,
+        .of_match_table = sgm3804_i2c_of_match,
+    },
+    .probe = sgm3804_i2c_probe,
+    .id_table = sgm3804_i2c_id,
+};
+
+module_i2c_driver(sgm3804_regulator_driver);
+
+MODULE_DESCRIPTION("SGMicro sgm3804 regulator Driver");
+MODULE_AUTHOR("Kancy Joe <kancy2333@outlook.com>");
+MODULE_AUTHOR("Romain Tisserand <romain.tisserand@gmail.com>");
+MODULE_LICENSE("GPL");
