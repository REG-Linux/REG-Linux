diff -u -r -N linux-mangmi/drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c
--- linux-mangmi/drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c	2025-12-18 14:03:43.000000000 +0100
+++ linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c	2025-12-23 16:36:17.730086049 +0100
@@ -1409,6 +1409,8 @@
 	if (!msm_disp_drv_should_bind(&pdev->dev, true))
 		return -ENODEV;
 
+	dev_info(dev, "dpu probe start\n");
+
 	dpu_kms = devm_kzalloc(dev, sizeof(*dpu_kms), GFP_KERNEL);
 	if (!dpu_kms)
 		return -ENOMEM;
@@ -1446,7 +1448,13 @@
 	if (ret)
 		return ret;
 
-	return msm_drv_probe(&pdev->dev, dpu_kms_init, &dpu_kms->base);
+	ret = msm_drv_probe(&pdev->dev, dpu_kms_init, &dpu_kms->base);
+	if (ret)
+		dev_err(dev, "msm_drv_probe failed: %d\n", ret);
+	else
+		dev_info(dev, "dpu probe done\n");
+
+	return ret;
 }
 
 static void dpu_dev_remove(struct platform_device *pdev)
diff -u -r -N linux-mangmi/drivers/gpu/drm/msm/dsi/dsi.c linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/dsi/dsi.c
--- linux-mangmi/drivers/gpu/drm/msm/dsi/dsi.c	2025-12-18 14:03:43.000000000 +0100
+++ linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/dsi/dsi.c	2025-12-24 02:34:39.314018450 +0100
@@ -103,6 +103,8 @@
 	if (ret)
 		goto destroy_dsi;
 
+	msm_dsi_host_copy_panel_timings(msm_dsi->host, msm_dsi->phy);
+
 	/* Register to dsi manager */
 	ret = msm_dsi_manager_register(msm_dsi);
 	if (ret)
@@ -169,6 +171,7 @@
 static int dsi_dev_probe(struct platform_device *pdev)
 {
 	struct msm_dsi *msm_dsi;
+	bool component_on_probe;
 
 	DBG("");
 	msm_dsi = dsi_init(pdev);
@@ -180,6 +183,20 @@
 			return PTR_ERR(msm_dsi);
 	}
 
+	component_on_probe = of_property_read_bool(pdev->dev.of_node,
+						   "qcom,component-on-probe");
+	if (component_on_probe) {
+		int ret;
+
+		ret = dsi_dev_attach(pdev);
+		if (ret)
+			return ret;
+
+		msm_dsi->component_attached = true;
+		msm_dsi->component_attach_on_probe = true;
+		dev_info(&pdev->dev, "component attached on probe\n");
+	}
+
 	return 0;
 }
 
@@ -188,6 +205,8 @@
 	struct msm_dsi *msm_dsi = platform_get_drvdata(pdev);
 
 	DBG("");
+	if (msm_dsi && msm_dsi->component_attached)
+		dsi_dev_detach(pdev);
 	dsi_destroy(msm_dsi);
 }
 
diff -u -r -N linux-mangmi/drivers/gpu/drm/msm/dsi/dsi.h linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/dsi/dsi.h
--- linux-mangmi/drivers/gpu/drm/msm/dsi/dsi.h	2025-12-18 14:03:43.000000000 +0100
+++ linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/dsi/dsi.h	2025-12-24 01:02:58.707412988 +0100
@@ -43,6 +43,8 @@
 
 	struct device *phy_dev;
 	bool phy_enabled;
+	bool component_attached;
+	bool component_attach_on_probe;
 
 	int id;
 };
@@ -85,6 +87,8 @@
 void msm_dsi_host_unregister(struct mipi_dsi_host *host);
 void msm_dsi_host_set_phy_mode(struct mipi_dsi_host *host,
 			struct msm_dsi_phy *src_phy);
+void msm_dsi_host_copy_panel_timings(struct mipi_dsi_host *host,
+			struct msm_dsi_phy *phy);
 int msm_dsi_host_set_src_pll(struct mipi_dsi_host *host,
 			struct msm_dsi_phy *src_phy);
 void msm_dsi_host_reset_phy(struct mipi_dsi_host *host);
@@ -152,4 +156,3 @@
 bool msm_dsi_phy_set_continuous_clock(struct msm_dsi_phy *phy, bool enable);
 
 #endif /* __DSI_CONNECTOR_H__ */
-
diff -u -r -N linux-mangmi/drivers/gpu/drm/msm/dsi/dsi_host.c linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/dsi/dsi_host.c
--- linux-mangmi/drivers/gpu/drm/msm/dsi/dsi_host.c	2025-12-18 14:03:43.000000000 +0100
+++ linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/dsi/dsi_host.c	2025-12-24 01:08:36.670482111 +0100
@@ -133,6 +133,13 @@
 	unsigned long pixel_clk_rate;
 	unsigned long esc_clk_rate;
 
+	bool panel_phy_timing_override;
+	u32 panel_phy_timings[10];
+	bool panel_phy_timings_be;
+	bool panel_clk_pre_post_override;
+	u32 panel_clk_pre;
+	u32 panel_clk_post;
+
 	/* DSI v2 specific clocks */
 	struct clk *src_clk;
 
@@ -245,6 +252,28 @@
 	return container_of(host, struct msm_dsi_host, base);
 }
 
+void msm_dsi_host_copy_panel_timings(struct mipi_dsi_host *host,
+				     struct msm_dsi_phy *phy)
+{
+	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
+
+	if (!phy)
+		return;
+
+	if (msm_host->panel_phy_timing_override) {
+		memcpy(phy->panel_phy_timings, msm_host->panel_phy_timings,
+		       sizeof(msm_host->panel_phy_timings));
+		phy->panel_phy_timing_override = true;
+		phy->panel_phy_timings_be = msm_host->panel_phy_timings_be;
+	}
+
+	if (msm_host->panel_clk_pre_post_override) {
+		phy->panel_clk_pre = msm_host->panel_clk_pre;
+		phy->panel_clk_post = msm_host->panel_clk_post;
+		phy->panel_clk_pre_post_override = true;
+	}
+}
+
 int dsi_clk_init_v2(struct msm_dsi_host *msm_host)
 {
 	struct platform_device *pdev = msm_host->pdev;
@@ -1674,6 +1703,7 @@
 					struct mipi_dsi_device *dsi)
 {
 	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
+	struct msm_dsi *msm_dsi = platform_get_drvdata(msm_host->pdev);
 	int ret;
 
 	if (dsi->lanes > msm_host->num_data_lanes)
@@ -1686,9 +1716,13 @@
 	if (dsi->dsc)
 		msm_host->dsc = dsi->dsc;
 
-	ret = dsi_dev_attach(msm_host->pdev);
-	if (ret)
-		return ret;
+	if (!msm_dsi || !msm_dsi->component_attached) {
+		ret = dsi_dev_attach(msm_host->pdev);
+		if (ret)
+			return ret;
+		if (msm_dsi)
+			msm_dsi->component_attached = true;
+	}
 
 	DBG("id=%d", msm_host->id);
 
@@ -1699,8 +1733,12 @@
 					struct mipi_dsi_device *dsi)
 {
 	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
+	struct msm_dsi *msm_dsi = platform_get_drvdata(msm_host->pdev);
 
-	dsi_dev_detach(msm_host->pdev);
+	if (!msm_dsi || !msm_dsi->component_attach_on_probe)
+		dsi_dev_detach(msm_host->pdev);
+	if (msm_dsi && !msm_dsi->component_attach_on_probe)
+		msm_dsi->component_attached = false;
 
 	DBG("id=%d", msm_host->id);
 
@@ -1863,6 +1901,8 @@
 	struct device *dev = &msm_host->pdev->dev;
 	struct device_node *np = dev->of_node;
 	struct device_node *endpoint;
+	struct device_node *remote = NULL;
+	struct device_node *panel_np = NULL;
 	const char *te_source;
 	int ret = 0;
 
@@ -1903,6 +1943,41 @@
 	}
 	ret = 0;
 
+	remote = of_graph_get_remote_endpoint(endpoint);
+	if (remote) {
+		panel_np = of_get_parent(remote);
+		if (panel_np)
+			panel_np = of_get_parent(panel_np);
+	}
+
+	if (panel_np) {
+		u32 timings[ARRAY_SIZE(msm_host->panel_phy_timings)];
+		u32 val;
+
+		if (!of_property_read_u32_array(panel_np,
+						"qcom,mdss-dsi-panel-phy-timings",
+						timings, ARRAY_SIZE(timings))) {
+			memcpy(msm_host->panel_phy_timings, timings,
+			       sizeof(timings));
+			msm_host->panel_phy_timing_override = true;
+			msm_host->panel_phy_timings_be =
+				of_property_read_bool(panel_np,
+						      "qcom,mdss-dsi-panel-phy-timings-be");
+		}
+
+		if (!of_property_read_u32(panel_np,
+					  "qcom,mdss-dsi-t-clk-pre", &val)) {
+			msm_host->panel_clk_pre = val;
+			msm_host->panel_clk_pre_post_override = true;
+		}
+
+		if (!of_property_read_u32(panel_np,
+					  "qcom,mdss-dsi-t-clk-post", &val)) {
+			msm_host->panel_clk_post = val;
+			msm_host->panel_clk_pre_post_override = true;
+		}
+	}
+
 	if (of_property_present(np, "syscon-sfpb")) {
 		msm_host->sfpb = syscon_regmap_lookup_by_phandle(np,
 					"syscon-sfpb");
@@ -1915,6 +1990,8 @@
 
 err:
 	of_node_put(endpoint);
+	of_node_put(remote);
+	of_node_put(panel_np);
 
 	return ret;
 }
diff -u -r -N linux-mangmi/drivers/gpu/drm/msm/dsi/phy/dsi_phy_14nm.c linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/dsi/phy/dsi_phy_14nm.c
--- linux-mangmi/drivers/gpu/drm/msm/dsi/phy/dsi_phy_14nm.c	2025-12-18 14:03:43.000000000 +0100
+++ linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/dsi/phy/dsi_phy_14nm.c	2025-12-24 01:08:49.940366699 +0100
@@ -944,6 +944,34 @@
 	       base + REG_DSI_14nm_PHY_LN_TIMING_CTRL_11(lane_idx));
 }
 
+static u8 dsi_timing_byte(u32 val, u32 idx, bool be)
+{
+	u32 shift = be ? (24 - idx * 8) : (idx * 8);
+
+	return (val >> shift) & 0xff;
+}
+
+static void dsi_14nm_apply_panel_timings(struct msm_dsi_phy *phy,
+					 struct msm_dsi_dphy_timing *timing)
+{
+	bool be = phy->panel_phy_timings_be;
+	u32 data0 = phy->panel_phy_timings[0];
+	u32 data1 = phy->panel_phy_timings[1];
+	u32 clk0 = phy->panel_phy_timings[8];
+	u32 clk1 = phy->panel_phy_timings[9];
+
+	timing->clk_zero = dsi_timing_byte(clk0, 0, be);
+	timing->clk_prepare = dsi_timing_byte(clk0, 1, be);
+	timing->clk_trail = dsi_timing_byte(clk0, 2, be);
+
+	timing->hs_exit = dsi_timing_byte(data0, 3, be);
+	timing->hs_zero = dsi_timing_byte(data1, 0, be);
+	timing->hs_prepare = dsi_timing_byte(data1, 1, be);
+	timing->hs_trail = dsi_timing_byte(data1, 2, be);
+	timing->hs_rqst = dsi_timing_byte(data1, 3, be);
+	timing->hs_rqst_ckln = dsi_timing_byte(clk1, 3, be);
+}
+
 static int dsi_14nm_phy_enable(struct msm_dsi_phy *phy,
 			       struct msm_dsi_phy_clk_request *clk_req)
 {
@@ -962,6 +990,26 @@
 		return -EINVAL;
 	}
 
+	if (phy->panel_phy_timing_override)
+		dsi_14nm_apply_panel_timings(phy, timing);
+
+	if (phy->panel_clk_pre_post_override) {
+		timing->shared_timings.clk_pre = phy->panel_clk_pre;
+		timing->shared_timings.clk_post = phy->panel_clk_post;
+		timing->shared_timings.clk_pre_inc_by_2 = false;
+	}
+
+	if (phy->panel_phy_timing_override || phy->panel_clk_pre_post_override) {
+		DRM_DEV_INFO(&phy->pdev->dev,
+			     "panel PHY override: clk_pre=%u clk_post=%u hs_exit=%u hs_zero=%u hs_prepare=%u hs_trail=%u hs_rqst=%u clk_zero=%u clk_prepare=%u clk_trail=%u\n",
+			     timing->shared_timings.clk_pre,
+			     timing->shared_timings.clk_post,
+			     timing->hs_exit, timing->hs_zero,
+			     timing->hs_prepare, timing->hs_trail,
+			     timing->hs_rqst, timing->clk_zero,
+			     timing->clk_prepare, timing->clk_trail);
+	}
+
 	data = 0x1c;
 	if (phy->usecase != MSM_DSI_PHY_STANDALONE)
 		data |= DSI_14nm_PHY_CMN_LDO_CNTRL_VREG_CTRL(32);
diff -u -r -N linux-mangmi/drivers/gpu/drm/msm/dsi/phy/dsi_phy.h linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/dsi/phy/dsi_phy.h
--- linux-mangmi/drivers/gpu/drm/msm/dsi/phy/dsi_phy.h	2025-12-18 14:03:43.000000000 +0100
+++ linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/dsi/phy/dsi_phy.h	2025-12-24 01:08:03.856767415 +0100
@@ -120,6 +120,13 @@
 	struct clk_hw_onecell_data *provided_clocks;
 
 	bool state_saved;
+
+	bool panel_phy_timing_override;
+	u32 panel_phy_timings[10];
+	bool panel_phy_timings_be;
+	bool panel_clk_pre_post_override;
+	u32 panel_clk_pre;
+	u32 panel_clk_post;
 };
 
 /*
diff -u -r -N linux-mangmi/drivers/gpu/drm/msm/msm_drv.c linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/msm_drv.c
--- linux-mangmi/drivers/gpu/drm/msm/msm_drv.c	2025-12-18 14:03:43.000000000 +0100
+++ linux-6.18.2-MANGMI-PANEL-UP-but-black/drivers/gpu/drm/msm/msm_drv.c	2025-12-23 16:36:28.335055459 +0100
@@ -1042,6 +1042,8 @@
 	struct component_match *match = NULL;
 	int ret;
 
+	dev_info(master_dev, "msm_drv_probe start\n");
+
 	priv = devm_kzalloc(master_dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
@@ -1055,12 +1057,16 @@
 		ret = add_mdp_components(master_dev, &match);
 		if (ret)
 			return ret;
+		if (!match)
+			dev_warn(master_dev, "no display components matched\n");
 	}
 
 	if (!msm_gpu_no_components()) {
 		ret = add_gpu_components(master_dev, &match);
 		if (ret)
 			return ret;
+		if (!match)
+			dev_warn(master_dev, "no display/gpu components matched\n");
 	}
 
 	/* on all devices that I am aware of, iommu's which can map
@@ -1072,6 +1078,10 @@
 
 	ret = component_master_add_with_match(master_dev, &msm_drm_ops, match);
 	if (ret)
+		dev_err(master_dev, "component master add failed: %d\n", ret);
+	else
+		dev_info(master_dev, "msm_drv_probe done\n");
+	if (ret)
 		return ret;
 
 	return 0;
