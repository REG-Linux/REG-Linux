#!/bin/dash

usage() {
    printf '%s\n' \
        "usage: system-config [command] [args]" \
        "With command in" \
        "	overscan [enable|disable|set L R T B]" \
        "	canupdate" \
        "	update" \
        "	storage [current|list|INTERNAL|ANYEXTERNAL|RAM|DEV UUID]" \
        "	setRootPassword [password]" \
        "	getRootPassword" \
        "	tz [|tz]"
    exit 1
}
[ -z "$1" ] && usage

configFile="/boot/config.txt"
storageFile="/boot/system-boot.conf"
command="$1"
mode="$2"
extra1="$3"
extra2="$4"
extra3="$5"
extra4="$6"

preBootConfig() {
    mount -o remount,rw /boot
}

postBootConfig() {
    mount -o remount,ro /boot
}

log="/userdata/system/logs/reglinux.log"

do_setRootPassword() {
    PASSWD="$1"
    [ -z "$PASSWD" ] && PASSWD=$(dd if=/dev/urandom bs=1024 count=1 2>/dev/null | tr -dc '0-9A-Za-z_-' | head -c8)
    PASSWDENC=$(/usr/bin/system-encode encode "$PASSWD") || return 1

    preBootConfig
    if /usr/bin/regmsg systemconf setconfigkey "$storageFile" rootshadowpassword "$PASSWDENC" ; then
        postBootConfig
        return 1
    else
        postBootConfig
        return 0
    fi
}

load_or_unload_module() {
    modulename="$1"
    map="$2"
    action="$3"  # typically "load" or anything else = unload-only
    log="/var/log/myapp.log"
    kernel_version="$(uname -r)"
    module_path=""

    if [ -f "/lib/modules/$kernel_version/updates/${modulename}.ko" ]; then
        module_path="/lib/modules/$kernel_version/updates/${modulename}.ko"
    elif [ -f "/lib/modules/$kernel_version/extra/${modulename}.ko" ]; then
        module_path="/lib/modules/$kernel_version/extra/${modulename}.ko"
    else
        echo "Error: Module ${modulename} not found in /lib/modules/$kernel_version/{updates,extra}." >> "$log"
        return 1
    fi

    # Always try to unload first
    rmmod "$module_path" >> "$log" 2>&1

    if [ "$action" = "load" ]; then
        echo "Loading module $modulename with args $map" >> "$log"
        if ! insmod "$module_path" $map >> "$log" 2>&1; then
            echo "Error: Failed to load module ${modulename} with args ${map}" >> "$log"
            return 1
        fi
    fi
    return 0
}

case "$command" in
    getRootPassword)
        [ -z "$mode" ] && mode="$(/usr/bin/regmsg systemconf getconfigkey system.security.enabled)"
        [ "$mode" != "1" ] && { echo "linux"; exit 0; }
        rootshadowpassword="$(/usr/bin/regmsg systemconf getconfigkey rootshadowpassword)"
        if [ -z "$rootshadowpassword" ]; then
            PASSWD=$(dd if=/dev/urandom bs=1024 count=1 2>/dev/null | tr -dc '0-9A-Za-z_-' | head -c8)
            do_setRootPassword "$PASSWD" || exit 1
        else
            PASSWD=$(/usr/bin/system-encode decode "$rootshadowpassword")
        fi
        { [ -z "$PASSWD" ] && exit 1; } || { echo "$PASSWD"; exit 0; }
        ;;

    setRootPassword)
        [ "$(/usr/bin/regmsg systemconf getconfigkey system.security.enabled)" != "1" ] && exit 0
        { do_setRootPassword "$2" && exit 0; } || exit 1
        ;;

    overscan)
        if [ "$mode" = "set" ]; then
            if [ -z "$extra1" ] || [ -z "$extra2" ] || [ -z "$extra3" ] || [ -z "$extra4" ]; then
                echo "$0 $command $mode needs 4 arguments:"
                echo "$0 $command $mode overscan_left overscan_right overscan_top overscan_bottom"
                exit 2
            fi
            preBootConfig
            printf "setting overscan values %s %s %s %s\n" "$extra1" "$extra2" "$extra3" "$extra4" >> "$log"
            if /usr/bin/regmsg systemconf setconfigkey "$configFile" disable_overscan 0 overscan_scale 1 overscan_left "$extra1" overscan_right "$extra2" overscan_top "$extra3" overscan_bottom "$extra4" ; then
                postBootConfig
                exit 1
            else
                postBootConfig
                exit 0
            fi
        fi

        if [ -f "$configFile" ]; then
            preBootConfig
            case "$mode" in
                enable)
                    echo "enabling overscan" >> "$log"
                    if /usr/bin/regmsg systemconf setconfigkey "$configFile" disable_overscan 0 overscan_scale 1 ; then
                        postBootConfig
                        exit 1
                    else
                        postBootConfig
                        exit 0
                    fi
                    ;;
                disable)
                    echo "disabling overscan" >> "$log"
                    if /usr/bin/regmsg systemconf setconfigkey "$configFile" disable_overscan 01 overscan_scale 0 ; then
                        postBootConfig
                        exit 1
                    else
                        postBootConfig
                        exit 0
                    fi
                    ;;
                *)
                    postBootConfig
                    exit 1
                    ;;
            esac
        else
            exit 2
        fi
        ;;

    lsoutputs)
        echo "auto"
        exec /usr/bin/regmsg screen listoutputs
        ;;

    gpiocontrollers)
        load_or_unload_module "mk_arcade_joystick_rpi" "map=1,2" "load" || exit 1
        exit 0
        ;;

    module)
        load_or_unload_module "$extra1" "$extra2" "$mode" || exit 1
        exit 0
        ;;

    canupdate)
        updatetype="$(/usr/bin/regmsg systemconf getconfigkey updates.type)"
        [ "$updatetype" != "beta" ] && updatetype="stable"

        board=$(cat /boot/boot/system.board 2>/dev/null) || board="unknown"
        installed=$(/usr/bin/system-version)

        latestrelease=$(curl -s "https://api.github.com/repos/REG-Linux/REG-Linux/releases/latest" | jq -r '.tag_name')
        if [ "$updatetype" = "beta" ]; then
            latestbeta=$(curl -s https://api.github.com/repos/REG-Linux/REG-Linux/releases | jq -r 'map(select(.prerelease)) | first | .tag_name')
            if [ -n "$latestbeta" ] && { [ -z "$latestrelease" ] || [ "${latestbeta%.*}" != "${latestrelease%.*}" ] || [ "$latestbeta" \> "$latestrelease" ]; }; then
                latestrelease="$latestbeta"
            fi
        fi

        if [ -z "$latestrelease" ] || [ -z "$installed" ]; then
            exit 12
        fi

        need_update=0
        case "$installed" in
            *beta*)
                if [ "$latestrelease" != "${latestrelease#*beta}" ]; then
                    [ "$latestrelease" \> "$installed" ] && need_update=1
                else
                    [ "${latestrelease%.*}" \> "${installed%%-*}" ] && need_update=1
                fi
                ;;
            *)
                if [ "$latestrelease" != "${latestrelease#*beta}" ]; then
                    [ "${latestrelease%%-*}" \> "${installed%%.*}" ] && need_update=1
                else
                    [ "$latestrelease" \> "$installed" ] && need_update=1
                fi
                ;;
        esac

        [ "$need_update" = "1" ] || exit 12

        url="https://github.com/REG-Linux/REG-Linux/releases/download/${latestrelease}/boot-${board}.tar.zst"
        if curl -sfIL "$url" > /dev/null; then
            echo "$latestrelease"
            exit 0
        else
            exit 12
        fi
        ;;

    update)
        exec /usr/bin/system-upgrade
        ;;

    storage)
        if [ "$mode" = "current" ]; then
            if [ -e "$storageFile" ]; then
                SHAREDEVICE=$(grep -m1 "^sharedevice=" "$storageFile" | cut -d= -f2)
                [ -z "$SHAREDEVICE" ] && SHAREDEVICE="INTERNAL"
                echo "$SHAREDEVICE"
            else
                echo "INTERNAL"
            fi
            exit 0
        elif [ "$mode" = "list" ]; then
            echo "INTERNAL INTERNAL"
            echo "ANYEXTERNAL ANY EXTERNAL"
            INTERNAL_DEVICE=$(/usr/bin/system-part share_internal)
            PARTPREFIX=$(/usr/bin/system-part prefix "$INTERNAL_DEVICE")
            lsblk -n -P -o NAME,FSTYPE,LABEL,UUID,SIZE,TYPE |
            grep -E 'TYPE="(part|lvm)"' |
            grep -vE 'FSTYPE="(swap|LVM2_member)"' |
            sed -e 's|^NAME="|NAME="/dev/|' -e 's|LABEL=""|LABEL="NO_NAME"|' |
            grep -v "^NAME=\"${PARTPREFIX}" |
            sed -n 's|^NAME="[^"]*" FSTYPE="[^"]*" LABEL="\([^"]*\)" UUID="\([^"]*\)" SIZE="\([^"]*\)" TYPE="[^"]*"$|DEV \2 \1 - \3|p'
            exit 0
        elif [ "$mode" = "INTERNAL" ] || [ "$mode" = "ANYEXTERNAL" ] || [ "$mode" = "RAM" ] || [ "$mode" = "DEV" ]; then
            preBootConfig
            if [ "$mode" = "DEV" ]; then
                newval="DEV $extra1"
            else
                newval="$mode"
            fi
            if /usr/bin/regmsg systemconf setconfigkey "$storageFile" sharedevice "$newval" ; then
                postBootConfig
                exit 1
            else
                postBootConfig
                exit 0
            fi
        fi
        ;;

    forgetBT)
        killall -9 hcitool 2>/dev/null || true
        /etc/init.d/S32bluetooth stop
        rm -rf /var/lib/bluetooth
        mkdir -p /var/lib/bluetooth
        rm -f /userdata/system/bluetooth/bluetooth.tar
        /etc/init.d/S32bluetooth start
        exit 0
        ;;

    tz)
        if [ -z "$mode" ]; then
            exec at /usr/share/reglinux/tz
        else
            if [ -f "/usr/share/zoneinfo/$mode" ]; then
                printf "%s\n" "$mode" > /etc/timezone
                ln -sf "/usr/share/zoneinfo/$mode" /etc/localtime
                exit 0
            else
                exit 1
            fi
        fi
        ;;

    *)
        usage
        ;;
esac
exit 10